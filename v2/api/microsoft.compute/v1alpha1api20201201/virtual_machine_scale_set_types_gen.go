// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20201201

import (
	"fmt"
	"github.com/Azure/azure-service-operator/hack/generated/pkg/genruntime"
	"github.com/Azure/azure-service-operator/hack/generated/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/hack/generated/pkg/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/api/microsoft.compute/v1alpha1api20201201storage"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:rbac:groups=microsoft.compute.azure.com,resources=virtualmachinescalesets,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=microsoft.compute.azure.com,resources={virtualmachinescalesets/status,virtualmachinescalesets/finalizers},verbs=get;update;patch

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/resourceDefinitions/virtualMachineScaleSets
type VirtualMachineScaleSet struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualMachineScaleSets_Spec  `json:"spec,omitempty"`
	Status            VirtualMachineScaleSet_Status `json:"status,omitempty"`
}

var _ conditions.Conditioner = &VirtualMachineScaleSet{}

// GetConditions returns the conditions of the resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) GetConditions() conditions.Conditions {
	return virtualMachineScaleSet.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (virtualMachineScaleSet *VirtualMachineScaleSet) SetConditions(conditions conditions.Conditions) {
	virtualMachineScaleSet.Status.Conditions = conditions
}

// +kubebuilder:webhook:path=/mutate-microsoft-compute-azure-com-v1alpha1api20201201-virtualmachinescaleset,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=microsoft.compute.azure.com,resources=virtualmachinescalesets,verbs=create;update,versions=v1alpha1api20201201,name=default.v1alpha1api20201201.virtualmachinescalesets.microsoft.compute.azure.com,admissionReviewVersions=v1beta1

var _ admission.Defaulter = &VirtualMachineScaleSet{}

// Default applies defaults to the VirtualMachineScaleSet resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) Default() {
	virtualMachineScaleSet.defaultImpl()
	var temp interface{} = virtualMachineScaleSet
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (virtualMachineScaleSet *VirtualMachineScaleSet) defaultAzureName() {
	if virtualMachineScaleSet.Spec.AzureName == "" {
		virtualMachineScaleSet.Spec.AzureName = virtualMachineScaleSet.Name
	}
}

// defaultImpl applies the code generated defaults to the VirtualMachineScaleSet resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) defaultImpl() {
	virtualMachineScaleSet.defaultAzureName()
}

var _ genruntime.KubernetesResource = &VirtualMachineScaleSet{}

// AzureName returns the Azure name of the resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) AzureName() string {
	return virtualMachineScaleSet.Spec.AzureName
}

// GetResourceKind returns the kind of the resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) GetSpec() genruntime.ConvertibleSpec {
	return &virtualMachineScaleSet.Spec
}

// GetStatus returns the status of this resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) GetStatus() genruntime.ConvertibleStatus {
	return &virtualMachineScaleSet.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Compute/virtualMachineScaleSets"
func (virtualMachineScaleSet *VirtualMachineScaleSet) GetType() string {
	return "Microsoft.Compute/virtualMachineScaleSets"
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (virtualMachineScaleSet *VirtualMachineScaleSet) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(virtualMachineScaleSet.Spec)
	return &genruntime.ResourceReference{Group: group, Kind: kind, Namespace: virtualMachineScaleSet.Namespace, Name: virtualMachineScaleSet.Spec.Owner.Name}
}

// SetStatus sets the status of this resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*VirtualMachineScaleSet_Status); ok {
		virtualMachineScaleSet.Status = *st
		return nil
	}

	// Convert status to required version
	var st VirtualMachineScaleSet_Status
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	virtualMachineScaleSet.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-microsoft-compute-azure-com-v1alpha1api20201201-virtualmachinescaleset,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=microsoft.compute.azure.com,resources=virtualmachinescalesets,verbs=create;update,versions=v1alpha1api20201201,name=validate.v1alpha1api20201201.virtualmachinescalesets.microsoft.compute.azure.com,admissionReviewVersions=v1beta1

var _ admission.Validator = &VirtualMachineScaleSet{}

// ValidateCreate validates the creation of the resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) ValidateCreate() error {
	validations := virtualMachineScaleSet.createValidations()
	var temp interface{} = virtualMachineScaleSet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) ValidateDelete() error {
	validations := virtualMachineScaleSet.deleteValidations()
	var temp interface{} = virtualMachineScaleSet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) ValidateUpdate(old runtime.Object) error {
	validations := virtualMachineScaleSet.updateValidations()
	var temp interface{} = virtualMachineScaleSet
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) createValidations() []func() error {
	return []func() error{virtualMachineScaleSet.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return virtualMachineScaleSet.validateResourceReferences()
		},
	}
}

// validateResourceReferences validates all resource references
func (virtualMachineScaleSet *VirtualMachineScaleSet) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&virtualMachineScaleSet.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// AssignPropertiesFromVirtualMachineScaleSet populates our VirtualMachineScaleSet from the provided source VirtualMachineScaleSet
func (virtualMachineScaleSet *VirtualMachineScaleSet) AssignPropertiesFromVirtualMachineScaleSet(source *v1alpha1api20201201storage.VirtualMachineScaleSet) error {

	// Spec
	var spec VirtualMachineScaleSets_Spec
	err := spec.AssignPropertiesFromVirtualMachineScaleSetsSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesFromVirtualMachineScaleSetsSpec()")
	}
	virtualMachineScaleSet.Spec = spec

	// Status
	var status VirtualMachineScaleSet_Status
	err = status.AssignPropertiesFromVirtualMachineScaleSetStatus(&source.Status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesFromVirtualMachineScaleSetStatus()")
	}
	virtualMachineScaleSet.Status = status

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSet populates the provided destination VirtualMachineScaleSet from our VirtualMachineScaleSet
func (virtualMachineScaleSet *VirtualMachineScaleSet) AssignPropertiesToVirtualMachineScaleSet(destination *v1alpha1api20201201storage.VirtualMachineScaleSet) error {

	// Spec
	var spec v1alpha1api20201201storage.VirtualMachineScaleSets_Spec
	err := virtualMachineScaleSet.Spec.AssignPropertiesToVirtualMachineScaleSetsSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "populating Spec from Spec, calling AssignPropertiesToVirtualMachineScaleSetsSpec()")
	}
	destination.Spec = spec

	// Status
	var status v1alpha1api20201201storage.VirtualMachineScaleSet_Status
	err = virtualMachineScaleSet.Status.AssignPropertiesToVirtualMachineScaleSetStatus(&status)
	if err != nil {
		return errors.Wrap(err, "populating Status from Status, calling AssignPropertiesToVirtualMachineScaleSetStatus()")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (virtualMachineScaleSet *VirtualMachineScaleSet) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: virtualMachineScaleSet.Spec.OriginalVersion(),
		Kind:    "VirtualMachineScaleSet",
	}
}

// +kubebuilder:object:root=true
//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/resourceDefinitions/virtualMachineScaleSets
type VirtualMachineScaleSetList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualMachineScaleSet `json:"items"`
}

//Generated from:
type VirtualMachineScaleSet_Status struct {
	//AdditionalCapabilities: Specifies additional capabilities enabled or disabled on
	//the Virtual Machines in the Virtual Machine Scale Set. For instance: whether the
	//Virtual Machines have the capability to support attaching managed data disks
	//with UltraSSD_LRS storage account type.
	AdditionalCapabilities *AdditionalCapabilities_Status `json:"additionalCapabilities,omitempty"`

	//AutomaticRepairsPolicy: Policy for automatic repairs.
	AutomaticRepairsPolicy *AutomaticRepairsPolicy_Status `json:"automaticRepairsPolicy,omitempty"`

	//Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	//DoNotRunExtensionsOnOverprovisionedVMs: When Overprovision is enabled,
	//extensions are launched only on the requested number of VMs which are finally
	//kept. This property will hence ensure that the extensions do not run on the
	//extra overprovisioned VMs.
	DoNotRunExtensionsOnOverprovisionedVMs *bool `json:"doNotRunExtensionsOnOverprovisionedVMs,omitempty"`

	//ExtendedLocation: The extended location of the Virtual Machine Scale Set.
	ExtendedLocation *ExtendedLocation_Status `json:"extendedLocation,omitempty"`

	//HostGroup: Specifies information about the dedicated host group that the virtual
	//machine scale set resides in.
	//Minimum api-version: 2020-06-01.
	HostGroup *SubResource_Status `json:"hostGroup,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//Identity: The identity of the virtual machine scale set, if configured.
	Identity *VirtualMachineScaleSetIdentity_Status `json:"identity,omitempty"`

	//Location: Resource location
	Location *string `json:"location,omitempty"`

	//Name: Resource name
	Name *string `json:"name,omitempty"`

	//OrchestrationMode: Specifies the orchestration mode for the virtual machine
	//scale set.
	OrchestrationMode *OrchestrationMode_Status `json:"orchestrationMode,omitempty"`

	//Overprovision: Specifies whether the Virtual Machine Scale Set should be
	//overprovisioned.
	Overprovision *bool `json:"overprovision,omitempty"`

	//Plan: Specifies information about the marketplace image used to create the
	//virtual machine. This element is only used for marketplace images. Before you
	//can use a marketplace image from an API, you must enable the image for
	//programmatic use.  In the Azure portal, find the marketplace image that you want
	//to use and then click Want to deploy programmatically, Get Started ->. Enter any
	//required information and then click Save.
	Plan *Plan_Status `json:"plan,omitempty"`

	//PlatformFaultDomainCount: Fault Domain count for each placement group.
	PlatformFaultDomainCount *int `json:"platformFaultDomainCount,omitempty"`

	//ProvisioningState: The provisioning state, which only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	//ProximityPlacementGroup: Specifies information about the proximity placement
	//group that the virtual machine scale set should be assigned to.
	//Minimum api-version: 2018-04-01.
	ProximityPlacementGroup *SubResource_Status `json:"proximityPlacementGroup,omitempty"`

	//ScaleInPolicy: Specifies the scale-in policy that decides which virtual machines
	//are chosen for removal when a Virtual Machine Scale Set is scaled-in.
	ScaleInPolicy *ScaleInPolicy_Status `json:"scaleInPolicy,omitempty"`

	//SinglePlacementGroup: When true this limits the scale set to a single placement
	//group, of max size 100 virtual machines. NOTE: If singlePlacementGroup is true,
	//it may be modified to false. However, if singlePlacementGroup is false, it may
	//not be modified to true.
	SinglePlacementGroup *bool `json:"singlePlacementGroup,omitempty"`

	//Sku: The virtual machine scale set sku.
	Sku *Sku_Status `json:"sku,omitempty"`

	//Tags: Resource tags
	Tags map[string]string `json:"tags,omitempty"`

	//Type: Resource type
	Type *string `json:"type,omitempty"`

	//UniqueId: Specifies the ID which uniquely identifies a Virtual Machine Scale Set.
	UniqueId *string `json:"uniqueId,omitempty"`

	//UpgradePolicy: The upgrade policy.
	UpgradePolicy *UpgradePolicy_Status `json:"upgradePolicy,omitempty"`

	//VirtualMachineProfile: The virtual machine profile.
	VirtualMachineProfile *VirtualMachineScaleSetVMProfile_Status `json:"virtualMachineProfile,omitempty"`

	//ZoneBalance: Whether to force strictly even Virtual Machine distribution cross
	//x-zones in case there is zone outage.
	ZoneBalance *bool `json:"zoneBalance,omitempty"`

	//Zones: The virtual machine scale set zones. NOTE: Availability zones can only be
	//set when you create the scale set
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &VirtualMachineScaleSet_Status{}

// ConvertStatusFrom populates our VirtualMachineScaleSet_Status from the provided source
func (virtualMachineScaleSetStatus *VirtualMachineScaleSet_Status) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1alpha1api20201201storage.VirtualMachineScaleSet_Status)
	if ok {
		// Populate our instance from source
		return virtualMachineScaleSetStatus.AssignPropertiesFromVirtualMachineScaleSetStatus(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201201storage.VirtualMachineScaleSet_Status{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = virtualMachineScaleSetStatus.AssignPropertiesFromVirtualMachineScaleSetStatus(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our VirtualMachineScaleSet_Status
func (virtualMachineScaleSetStatus *VirtualMachineScaleSet_Status) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1alpha1api20201201storage.VirtualMachineScaleSet_Status)
	if ok {
		// Populate destination from our instance
		return virtualMachineScaleSetStatus.AssignPropertiesToVirtualMachineScaleSetStatus(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201201storage.VirtualMachineScaleSet_Status{}
	err := virtualMachineScaleSetStatus.AssignPropertiesToVirtualMachineScaleSetStatus(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSet_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetStatus *VirtualMachineScaleSet_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSet_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetStatus *VirtualMachineScaleSet_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSet_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSet_StatusARM, got %T", armInput)
	}

	// Set property ‘AdditionalCapabilities’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdditionalCapabilities != nil {
			var additionalCapabilities1 AdditionalCapabilities_Status
			err := additionalCapabilities1.PopulateFromARM(owner, *typedInput.Properties.AdditionalCapabilities)
			if err != nil {
				return err
			}
			additionalCapabilities := additionalCapabilities1
			virtualMachineScaleSetStatus.AdditionalCapabilities = &additionalCapabilities
		}
	}

	// Set property ‘AutomaticRepairsPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutomaticRepairsPolicy != nil {
			var automaticRepairsPolicy1 AutomaticRepairsPolicy_Status
			err := automaticRepairsPolicy1.PopulateFromARM(owner, *typedInput.Properties.AutomaticRepairsPolicy)
			if err != nil {
				return err
			}
			automaticRepairsPolicy := automaticRepairsPolicy1
			virtualMachineScaleSetStatus.AutomaticRepairsPolicy = &automaticRepairsPolicy
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘DoNotRunExtensionsOnOverprovisionedVMs’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs != nil {
			doNotRunExtensionsOnOverprovisionedVMs := *typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs
			virtualMachineScaleSetStatus.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVMs
		}
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation_Status
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		virtualMachineScaleSetStatus.ExtendedLocation = &extendedLocation
	}

	// Set property ‘HostGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostGroup != nil {
			var hostGroup1 SubResource_Status
			err := hostGroup1.PopulateFromARM(owner, *typedInput.Properties.HostGroup)
			if err != nil {
				return err
			}
			hostGroup := hostGroup1
			virtualMachineScaleSetStatus.HostGroup = &hostGroup
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		virtualMachineScaleSetStatus.Id = &id
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 VirtualMachineScaleSetIdentity_Status
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		virtualMachineScaleSetStatus.Identity = &identity
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		virtualMachineScaleSetStatus.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		virtualMachineScaleSetStatus.Name = &name
	}

	// Set property ‘OrchestrationMode’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OrchestrationMode != nil {
			orchestrationMode := *typedInput.Properties.OrchestrationMode
			virtualMachineScaleSetStatus.OrchestrationMode = &orchestrationMode
		}
	}

	// Set property ‘Overprovision’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Overprovision != nil {
			overprovision := *typedInput.Properties.Overprovision
			virtualMachineScaleSetStatus.Overprovision = &overprovision
		}
	}

	// Set property ‘Plan’:
	if typedInput.Plan != nil {
		var plan1 Plan_Status
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		virtualMachineScaleSetStatus.Plan = &plan
	}

	// Set property ‘PlatformFaultDomainCount’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PlatformFaultDomainCount != nil {
			platformFaultDomainCount := *typedInput.Properties.PlatformFaultDomainCount
			virtualMachineScaleSetStatus.PlatformFaultDomainCount = &platformFaultDomainCount
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			virtualMachineScaleSetStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ProximityPlacementGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProximityPlacementGroup != nil {
			var proximityPlacementGroup1 SubResource_Status
			err := proximityPlacementGroup1.PopulateFromARM(owner, *typedInput.Properties.ProximityPlacementGroup)
			if err != nil {
				return err
			}
			proximityPlacementGroup := proximityPlacementGroup1
			virtualMachineScaleSetStatus.ProximityPlacementGroup = &proximityPlacementGroup
		}
	}

	// Set property ‘ScaleInPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ScaleInPolicy != nil {
			var scaleInPolicy1 ScaleInPolicy_Status
			err := scaleInPolicy1.PopulateFromARM(owner, *typedInput.Properties.ScaleInPolicy)
			if err != nil {
				return err
			}
			scaleInPolicy := scaleInPolicy1
			virtualMachineScaleSetStatus.ScaleInPolicy = &scaleInPolicy
		}
	}

	// Set property ‘SinglePlacementGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SinglePlacementGroup != nil {
			singlePlacementGroup := *typedInput.Properties.SinglePlacementGroup
			virtualMachineScaleSetStatus.SinglePlacementGroup = &singlePlacementGroup
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku_Status
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		virtualMachineScaleSetStatus.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		virtualMachineScaleSetStatus.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			virtualMachineScaleSetStatus.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		virtualMachineScaleSetStatus.Type = &typeVar
	}

	// Set property ‘UniqueId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UniqueId != nil {
			uniqueId := *typedInput.Properties.UniqueId
			virtualMachineScaleSetStatus.UniqueId = &uniqueId
		}
	}

	// Set property ‘UpgradePolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UpgradePolicy != nil {
			var upgradePolicy1 UpgradePolicy_Status
			err := upgradePolicy1.PopulateFromARM(owner, *typedInput.Properties.UpgradePolicy)
			if err != nil {
				return err
			}
			upgradePolicy := upgradePolicy1
			virtualMachineScaleSetStatus.UpgradePolicy = &upgradePolicy
		}
	}

	// Set property ‘VirtualMachineProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.VirtualMachineProfile != nil {
			var virtualMachineProfile1 VirtualMachineScaleSetVMProfile_Status
			err := virtualMachineProfile1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachineProfile)
			if err != nil {
				return err
			}
			virtualMachineProfile := virtualMachineProfile1
			virtualMachineScaleSetStatus.VirtualMachineProfile = &virtualMachineProfile
		}
	}

	// Set property ‘ZoneBalance’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ZoneBalance != nil {
			zoneBalance := *typedInput.Properties.ZoneBalance
			virtualMachineScaleSetStatus.ZoneBalance = &zoneBalance
		}
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		virtualMachineScaleSetStatus.Zones = append(virtualMachineScaleSetStatus.Zones, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetStatus populates our VirtualMachineScaleSet_Status from the provided source VirtualMachineScaleSet_Status
func (virtualMachineScaleSetStatus *VirtualMachineScaleSet_Status) AssignPropertiesFromVirtualMachineScaleSetStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSet_Status) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities_Status
		err := additionalCapability.AssignPropertiesFromAdditionalCapabilitiesStatus(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "populating AdditionalCapabilities from AdditionalCapabilities, calling AssignPropertiesFromAdditionalCapabilitiesStatus()")
		}
		virtualMachineScaleSetStatus.AdditionalCapabilities = &additionalCapability
	} else {
		virtualMachineScaleSetStatus.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if source.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy AutomaticRepairsPolicy_Status
		err := automaticRepairsPolicy.AssignPropertiesFromAutomaticRepairsPolicyStatus(source.AutomaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "populating AutomaticRepairsPolicy from AutomaticRepairsPolicy, calling AssignPropertiesFromAutomaticRepairsPolicyStatus()")
		}
		virtualMachineScaleSetStatus.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		virtualMachineScaleSetStatus.AutomaticRepairsPolicy = nil
	}

	// Conditions
	conditionList := make([]conditions.Condition, len(source.Conditions))
	for conditionIndex, conditionItem := range source.Conditions {
		// Shadow the loop variable to avoid aliasing
		conditionItem := conditionItem
		conditionList[conditionIndex] = conditionItem.Copy()
	}
	virtualMachineScaleSetStatus.Conditions = conditionList

	// DoNotRunExtensionsOnOverprovisionedVMs
	if source.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *source.DoNotRunExtensionsOnOverprovisionedVMs
		virtualMachineScaleSetStatus.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		virtualMachineScaleSetStatus.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_Status
		err := extendedLocation.AssignPropertiesFromExtendedLocationStatus(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesFromExtendedLocationStatus()")
		}
		virtualMachineScaleSetStatus.ExtendedLocation = &extendedLocation
	} else {
		virtualMachineScaleSetStatus.ExtendedLocation = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource_Status
		err := hostGroup.AssignPropertiesFromSubResourceStatus(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "populating HostGroup from HostGroup, calling AssignPropertiesFromSubResourceStatus()")
		}
		virtualMachineScaleSetStatus.HostGroup = &hostGroup
	} else {
		virtualMachineScaleSetStatus.HostGroup = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		virtualMachineScaleSetStatus.Id = &id
	} else {
		virtualMachineScaleSetStatus.Id = nil
	}

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineScaleSetIdentity_Status
		err := identity.AssignPropertiesFromVirtualMachineScaleSetIdentityStatus(source.Identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesFromVirtualMachineScaleSetIdentityStatus()")
		}
		virtualMachineScaleSetStatus.Identity = &identity
	} else {
		virtualMachineScaleSetStatus.Identity = nil
	}

	// Location
	if source.Location != nil {
		location := *source.Location
		virtualMachineScaleSetStatus.Location = &location
	} else {
		virtualMachineScaleSetStatus.Location = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		virtualMachineScaleSetStatus.Name = &name
	} else {
		virtualMachineScaleSetStatus.Name = nil
	}

	// OrchestrationMode
	if source.OrchestrationMode != nil {
		orchestrationMode := OrchestrationMode_Status(*source.OrchestrationMode)
		virtualMachineScaleSetStatus.OrchestrationMode = &orchestrationMode
	} else {
		virtualMachineScaleSetStatus.OrchestrationMode = nil
	}

	// Overprovision
	if source.Overprovision != nil {
		overprovision := *source.Overprovision
		virtualMachineScaleSetStatus.Overprovision = &overprovision
	} else {
		virtualMachineScaleSetStatus.Overprovision = nil
	}

	// Plan
	if source.Plan != nil {
		var plan Plan_Status
		err := plan.AssignPropertiesFromPlanStatus(source.Plan)
		if err != nil {
			return errors.Wrap(err, "populating Plan from Plan, calling AssignPropertiesFromPlanStatus()")
		}
		virtualMachineScaleSetStatus.Plan = &plan
	} else {
		virtualMachineScaleSetStatus.Plan = nil
	}

	// PlatformFaultDomainCount
	if source.PlatformFaultDomainCount != nil {
		platformFaultDomainCount := *source.PlatformFaultDomainCount
		virtualMachineScaleSetStatus.PlatformFaultDomainCount = &platformFaultDomainCount
	} else {
		virtualMachineScaleSetStatus.PlatformFaultDomainCount = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		virtualMachineScaleSetStatus.ProvisioningState = &provisioningState
	} else {
		virtualMachineScaleSetStatus.ProvisioningState = nil
	}

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource_Status
		err := proximityPlacementGroup.AssignPropertiesFromSubResourceStatus(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "populating ProximityPlacementGroup from ProximityPlacementGroup, calling AssignPropertiesFromSubResourceStatus()")
		}
		virtualMachineScaleSetStatus.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		virtualMachineScaleSetStatus.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if source.ScaleInPolicy != nil {
		var scaleInPolicy ScaleInPolicy_Status
		err := scaleInPolicy.AssignPropertiesFromScaleInPolicyStatus(source.ScaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "populating ScaleInPolicy from ScaleInPolicy, calling AssignPropertiesFromScaleInPolicyStatus()")
		}
		virtualMachineScaleSetStatus.ScaleInPolicy = &scaleInPolicy
	} else {
		virtualMachineScaleSetStatus.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if source.SinglePlacementGroup != nil {
		singlePlacementGroup := *source.SinglePlacementGroup
		virtualMachineScaleSetStatus.SinglePlacementGroup = &singlePlacementGroup
	} else {
		virtualMachineScaleSetStatus.SinglePlacementGroup = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_Status
		err := sku.AssignPropertiesFromSkuStatus(source.Sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesFromSkuStatus()")
		}
		virtualMachineScaleSetStatus.Sku = &sku
	} else {
		virtualMachineScaleSetStatus.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range source.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	virtualMachineScaleSetStatus.Tags = tagMap

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		virtualMachineScaleSetStatus.Type = &typeVar
	} else {
		virtualMachineScaleSetStatus.Type = nil
	}

	// UniqueId
	if source.UniqueId != nil {
		uniqueId := *source.UniqueId
		virtualMachineScaleSetStatus.UniqueId = &uniqueId
	} else {
		virtualMachineScaleSetStatus.UniqueId = nil
	}

	// UpgradePolicy
	if source.UpgradePolicy != nil {
		var upgradePolicy UpgradePolicy_Status
		err := upgradePolicy.AssignPropertiesFromUpgradePolicyStatus(source.UpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "populating UpgradePolicy from UpgradePolicy, calling AssignPropertiesFromUpgradePolicyStatus()")
		}
		virtualMachineScaleSetStatus.UpgradePolicy = &upgradePolicy
	} else {
		virtualMachineScaleSetStatus.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if source.VirtualMachineProfile != nil {
		var virtualMachineProfile VirtualMachineScaleSetVMProfile_Status
		err := virtualMachineProfile.AssignPropertiesFromVirtualMachineScaleSetVMProfileStatus(source.VirtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "populating VirtualMachineProfile from VirtualMachineProfile, calling AssignPropertiesFromVirtualMachineScaleSetVMProfileStatus()")
		}
		virtualMachineScaleSetStatus.VirtualMachineProfile = &virtualMachineProfile
	} else {
		virtualMachineScaleSetStatus.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if source.ZoneBalance != nil {
		zoneBalance := *source.ZoneBalance
		virtualMachineScaleSetStatus.ZoneBalance = &zoneBalance
	} else {
		virtualMachineScaleSetStatus.ZoneBalance = nil
	}

	// Zones
	zoneList := make([]string, len(source.Zones))
	for zoneIndex, zoneItem := range source.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	virtualMachineScaleSetStatus.Zones = zoneList

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetStatus populates the provided destination VirtualMachineScaleSet_Status from our VirtualMachineScaleSet_Status
func (virtualMachineScaleSetStatus *VirtualMachineScaleSet_Status) AssignPropertiesToVirtualMachineScaleSetStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSet_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalCapabilities
	if virtualMachineScaleSetStatus.AdditionalCapabilities != nil {
		var additionalCapability v1alpha1api20201201storage.AdditionalCapabilities_Status
		err := (*virtualMachineScaleSetStatus.AdditionalCapabilities).AssignPropertiesToAdditionalCapabilitiesStatus(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "populating AdditionalCapabilities from AdditionalCapabilities, calling AssignPropertiesToAdditionalCapabilitiesStatus()")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if virtualMachineScaleSetStatus.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy v1alpha1api20201201storage.AutomaticRepairsPolicy_Status
		err := (*virtualMachineScaleSetStatus.AutomaticRepairsPolicy).AssignPropertiesToAutomaticRepairsPolicyStatus(&automaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "populating AutomaticRepairsPolicy from AutomaticRepairsPolicy, calling AssignPropertiesToAutomaticRepairsPolicyStatus()")
		}
		destination.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		destination.AutomaticRepairsPolicy = nil
	}

	// Conditions
	conditionList := make([]conditions.Condition, len(virtualMachineScaleSetStatus.Conditions))
	for conditionIndex, conditionItem := range virtualMachineScaleSetStatus.Conditions {
		// Shadow the loop variable to avoid aliasing
		conditionItem := conditionItem
		conditionList[conditionIndex] = conditionItem.Copy()
	}
	destination.Conditions = conditionList

	// DoNotRunExtensionsOnOverprovisionedVMs
	if virtualMachineScaleSetStatus.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *virtualMachineScaleSetStatus.DoNotRunExtensionsOnOverprovisionedVMs
		destination.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		destination.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if virtualMachineScaleSetStatus.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201201storage.ExtendedLocation_Status
		err := (*virtualMachineScaleSetStatus.ExtendedLocation).AssignPropertiesToExtendedLocationStatus(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesToExtendedLocationStatus()")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostGroup
	if virtualMachineScaleSetStatus.HostGroup != nil {
		var hostGroup v1alpha1api20201201storage.SubResource_Status
		err := (*virtualMachineScaleSetStatus.HostGroup).AssignPropertiesToSubResourceStatus(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "populating HostGroup from HostGroup, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Id
	if virtualMachineScaleSetStatus.Id != nil {
		id := *virtualMachineScaleSetStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Identity
	if virtualMachineScaleSetStatus.Identity != nil {
		var identity v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status
		err := (*virtualMachineScaleSetStatus.Identity).AssignPropertiesToVirtualMachineScaleSetIdentityStatus(&identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesToVirtualMachineScaleSetIdentityStatus()")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	if virtualMachineScaleSetStatus.Location != nil {
		location := *virtualMachineScaleSetStatus.Location
		destination.Location = &location
	} else {
		destination.Location = nil
	}

	// Name
	if virtualMachineScaleSetStatus.Name != nil {
		name := *virtualMachineScaleSetStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// OrchestrationMode
	if virtualMachineScaleSetStatus.OrchestrationMode != nil {
		orchestrationMode := string(*virtualMachineScaleSetStatus.OrchestrationMode)
		destination.OrchestrationMode = &orchestrationMode
	} else {
		destination.OrchestrationMode = nil
	}

	// Overprovision
	if virtualMachineScaleSetStatus.Overprovision != nil {
		overprovision := *virtualMachineScaleSetStatus.Overprovision
		destination.Overprovision = &overprovision
	} else {
		destination.Overprovision = nil
	}

	// Plan
	if virtualMachineScaleSetStatus.Plan != nil {
		var plan v1alpha1api20201201storage.Plan_Status
		err := (*virtualMachineScaleSetStatus.Plan).AssignPropertiesToPlanStatus(&plan)
		if err != nil {
			return errors.Wrap(err, "populating Plan from Plan, calling AssignPropertiesToPlanStatus()")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomainCount
	if virtualMachineScaleSetStatus.PlatformFaultDomainCount != nil {
		platformFaultDomainCount := *virtualMachineScaleSetStatus.PlatformFaultDomainCount
		destination.PlatformFaultDomainCount = &platformFaultDomainCount
	} else {
		destination.PlatformFaultDomainCount = nil
	}

	// ProvisioningState
	if virtualMachineScaleSetStatus.ProvisioningState != nil {
		provisioningState := *virtualMachineScaleSetStatus.ProvisioningState
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ProximityPlacementGroup
	if virtualMachineScaleSetStatus.ProximityPlacementGroup != nil {
		var proximityPlacementGroup v1alpha1api20201201storage.SubResource_Status
		err := (*virtualMachineScaleSetStatus.ProximityPlacementGroup).AssignPropertiesToSubResourceStatus(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "populating ProximityPlacementGroup from ProximityPlacementGroup, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if virtualMachineScaleSetStatus.ScaleInPolicy != nil {
		var scaleInPolicy v1alpha1api20201201storage.ScaleInPolicy_Status
		err := (*virtualMachineScaleSetStatus.ScaleInPolicy).AssignPropertiesToScaleInPolicyStatus(&scaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "populating ScaleInPolicy from ScaleInPolicy, calling AssignPropertiesToScaleInPolicyStatus()")
		}
		destination.ScaleInPolicy = &scaleInPolicy
	} else {
		destination.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if virtualMachineScaleSetStatus.SinglePlacementGroup != nil {
		singlePlacementGroup := *virtualMachineScaleSetStatus.SinglePlacementGroup
		destination.SinglePlacementGroup = &singlePlacementGroup
	} else {
		destination.SinglePlacementGroup = nil
	}

	// Sku
	if virtualMachineScaleSetStatus.Sku != nil {
		var sku v1alpha1api20201201storage.Sku_Status
		err := (*virtualMachineScaleSetStatus.Sku).AssignPropertiesToSkuStatus(&sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesToSkuStatus()")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range virtualMachineScaleSetStatus.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	destination.Tags = tagMap

	// Type
	if virtualMachineScaleSetStatus.Type != nil {
		typeVar := *virtualMachineScaleSetStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UniqueId
	if virtualMachineScaleSetStatus.UniqueId != nil {
		uniqueId := *virtualMachineScaleSetStatus.UniqueId
		destination.UniqueId = &uniqueId
	} else {
		destination.UniqueId = nil
	}

	// UpgradePolicy
	if virtualMachineScaleSetStatus.UpgradePolicy != nil {
		var upgradePolicy v1alpha1api20201201storage.UpgradePolicy_Status
		err := (*virtualMachineScaleSetStatus.UpgradePolicy).AssignPropertiesToUpgradePolicyStatus(&upgradePolicy)
		if err != nil {
			return errors.Wrap(err, "populating UpgradePolicy from UpgradePolicy, calling AssignPropertiesToUpgradePolicyStatus()")
		}
		destination.UpgradePolicy = &upgradePolicy
	} else {
		destination.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if virtualMachineScaleSetStatus.VirtualMachineProfile != nil {
		var virtualMachineProfile v1alpha1api20201201storage.VirtualMachineScaleSetVMProfile_Status
		err := (*virtualMachineScaleSetStatus.VirtualMachineProfile).AssignPropertiesToVirtualMachineScaleSetVMProfileStatus(&virtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "populating VirtualMachineProfile from VirtualMachineProfile, calling AssignPropertiesToVirtualMachineScaleSetVMProfileStatus()")
		}
		destination.VirtualMachineProfile = &virtualMachineProfile
	} else {
		destination.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if virtualMachineScaleSetStatus.ZoneBalance != nil {
		zoneBalance := *virtualMachineScaleSetStatus.ZoneBalance
		destination.ZoneBalance = &zoneBalance
	} else {
		destination.ZoneBalance = nil
	}

	// Zones
	zoneList := make([]string, len(virtualMachineScaleSetStatus.Zones))
	for zoneIndex, zoneItem := range virtualMachineScaleSetStatus.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	destination.Zones = zoneList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type VirtualMachineScaleSets_Spec struct {
	//AdditionalCapabilities: Enables or disables a capability on the virtual machine
	//or virtual machine scale set.
	AdditionalCapabilities *AdditionalCapabilities `json:"additionalCapabilities,omitempty"`

	//AutomaticRepairsPolicy: Specifies the configuration parameters for automatic
	//repairs on the virtual machine scale set.
	AutomaticRepairsPolicy *AutomaticRepairsPolicy `json:"automaticRepairsPolicy,omitempty"`

	//AzureName: The name of the resource in Azure. This is often the same as the name
	//of the resource in Kubernetes but it doesn't have to be.
	AzureName string `json:"azureName"`

	//DoNotRunExtensionsOnOverprovisionedVMs: When Overprovision is enabled,
	//extensions are launched only on the requested number of VMs which are finally
	//kept. This property will hence ensure that the extensions do not run on the
	//extra overprovisioned VMs.
	DoNotRunExtensionsOnOverprovisionedVMs *bool `json:"doNotRunExtensionsOnOverprovisionedVMs,omitempty"`

	//ExtendedLocation: The complex type of the extended location.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	HostGroup        *SubResource      `json:"hostGroup,omitempty"`

	//Identity: Identity for the virtual machine scale set.
	Identity *VirtualMachineScaleSetIdentity `json:"identity,omitempty"`

	//Location: Location to deploy resource to
	Location string `json:"location,omitempty"`

	//OrchestrationMode: Specifies the orchestration mode for the virtual machine
	//scale set.
	OrchestrationMode *VirtualMachineScaleSetsSpecPropertiesOrchestrationMode `json:"orchestrationMode,omitempty"`

	//Overprovision: Specifies whether the Virtual Machine Scale Set should be
	//overprovisioned.
	Overprovision *bool `json:"overprovision,omitempty"`

	// +kubebuilder:validation:Required
	Owner genruntime.KnownResourceReference `group:"microsoft.resources.azure.com" json:"owner" kind:"ResourceGroup"`

	//Plan: Specifies information about the marketplace image used to create the
	//virtual machine. This element is only used for marketplace images. Before you
	//can use a marketplace image from an API, you must enable the image for
	//programmatic use.  In the Azure portal, find the marketplace image that you want
	//to use and then click Want to deploy programmatically, Get Started ->. Enter any
	//required information and then click Save.
	Plan *Plan `json:"plan,omitempty"`

	//PlatformFaultDomainCount: Fault Domain count for each placement group.
	PlatformFaultDomainCount *int         `json:"platformFaultDomainCount,omitempty"`
	ProximityPlacementGroup  *SubResource `json:"proximityPlacementGroup,omitempty"`

	//ScaleInPolicy: Describes a scale-in policy for a virtual machine scale set.
	ScaleInPolicy *ScaleInPolicy `json:"scaleInPolicy,omitempty"`

	//SinglePlacementGroup: When true this limits the scale set to a single placement
	//group, of max size 100 virtual machines. NOTE: If singlePlacementGroup is true,
	//it may be modified to false. However, if singlePlacementGroup is false, it may
	//not be modified to true.
	SinglePlacementGroup *bool `json:"singlePlacementGroup,omitempty"`

	//Sku: Describes a virtual machine scale set sku. NOTE: If the new VM SKU is not
	//supported on the hardware the scale set is currently on, you need to deallocate
	//the VMs in the scale set before you modify the SKU name.
	Sku *Sku `json:"sku,omitempty"`

	//Tags: Name-value pairs to add to the resource
	Tags map[string]string `json:"tags,omitempty"`

	//UpgradePolicy: Describes an upgrade policy - automatic, manual, or rolling.
	UpgradePolicy *UpgradePolicy `json:"upgradePolicy,omitempty"`

	//VirtualMachineProfile: Describes a virtual machine scale set virtual machine
	//profile.
	VirtualMachineProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile `json:"virtualMachineProfile,omitempty"`

	//ZoneBalance: Whether to force strictly even Virtual Machine distribution cross
	//x-zones in case there is zone outage.
	ZoneBalance *bool `json:"zoneBalance,omitempty"`

	//Zones: The virtual machine scale set zones. NOTE: Availability zones can only be
	//set when you create the scale set
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSets_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetsSpec *VirtualMachineScaleSets_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetsSpec == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSets_SpecARM

	// Set property ‘APIVersion’:
	result.APIVersion = VirtualMachineScaleSetsSpecAPIVersion20201201

	// Set property ‘ExtendedLocation’:
	if virtualMachineScaleSetsSpec.ExtendedLocation != nil {
		extendedLocationARM, err := (*virtualMachineScaleSetsSpec.ExtendedLocation).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extendedLocation := extendedLocationARM.(ExtendedLocationARM)
		result.ExtendedLocation = &extendedLocation
	}

	// Set property ‘Identity’:
	if virtualMachineScaleSetsSpec.Identity != nil {
		identityARM, err := (*virtualMachineScaleSetsSpec.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := identityARM.(VirtualMachineScaleSetIdentityARM)
		result.Identity = &identity
	}

	// Set property ‘Location’:
	result.Location = virtualMachineScaleSetsSpec.Location

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Plan’:
	if virtualMachineScaleSetsSpec.Plan != nil {
		planARM, err := (*virtualMachineScaleSetsSpec.Plan).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		plan := planARM.(PlanARM)
		result.Plan = &plan
	}

	// Set property ‘Properties’:
	if virtualMachineScaleSetsSpec.AdditionalCapabilities != nil {
		additionalCapabilitiesARM, err := (*virtualMachineScaleSetsSpec.AdditionalCapabilities).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		additionalCapabilities := additionalCapabilitiesARM.(AdditionalCapabilitiesARM)
		result.Properties.AdditionalCapabilities = &additionalCapabilities
	}
	if virtualMachineScaleSetsSpec.AutomaticRepairsPolicy != nil {
		automaticRepairsPolicyARM, err := (*virtualMachineScaleSetsSpec.AutomaticRepairsPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		automaticRepairsPolicy := automaticRepairsPolicyARM.(AutomaticRepairsPolicyARM)
		result.Properties.AutomaticRepairsPolicy = &automaticRepairsPolicy
	}
	if virtualMachineScaleSetsSpec.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVMs := *virtualMachineScaleSetsSpec.DoNotRunExtensionsOnOverprovisionedVMs
		result.Properties.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVMs
	}
	if virtualMachineScaleSetsSpec.HostGroup != nil {
		hostGroupARM, err := (*virtualMachineScaleSetsSpec.HostGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hostGroup := hostGroupARM.(SubResourceARM)
		result.Properties.HostGroup = &hostGroup
	}
	if virtualMachineScaleSetsSpec.OrchestrationMode != nil {
		orchestrationMode := *virtualMachineScaleSetsSpec.OrchestrationMode
		result.Properties.OrchestrationMode = &orchestrationMode
	}
	if virtualMachineScaleSetsSpec.Overprovision != nil {
		overprovision := *virtualMachineScaleSetsSpec.Overprovision
		result.Properties.Overprovision = &overprovision
	}
	if virtualMachineScaleSetsSpec.PlatformFaultDomainCount != nil {
		platformFaultDomainCount := *virtualMachineScaleSetsSpec.PlatformFaultDomainCount
		result.Properties.PlatformFaultDomainCount = &platformFaultDomainCount
	}
	if virtualMachineScaleSetsSpec.ProximityPlacementGroup != nil {
		proximityPlacementGroupARM, err := (*virtualMachineScaleSetsSpec.ProximityPlacementGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		proximityPlacementGroup := proximityPlacementGroupARM.(SubResourceARM)
		result.Properties.ProximityPlacementGroup = &proximityPlacementGroup
	}
	if virtualMachineScaleSetsSpec.ScaleInPolicy != nil {
		scaleInPolicyARM, err := (*virtualMachineScaleSetsSpec.ScaleInPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scaleInPolicy := scaleInPolicyARM.(ScaleInPolicyARM)
		result.Properties.ScaleInPolicy = &scaleInPolicy
	}
	if virtualMachineScaleSetsSpec.SinglePlacementGroup != nil {
		singlePlacementGroup := *virtualMachineScaleSetsSpec.SinglePlacementGroup
		result.Properties.SinglePlacementGroup = &singlePlacementGroup
	}
	if virtualMachineScaleSetsSpec.UpgradePolicy != nil {
		upgradePolicyARM, err := (*virtualMachineScaleSetsSpec.UpgradePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		upgradePolicy := upgradePolicyARM.(UpgradePolicyARM)
		result.Properties.UpgradePolicy = &upgradePolicy
	}
	if virtualMachineScaleSetsSpec.VirtualMachineProfile != nil {
		virtualMachineProfileARM, err := (*virtualMachineScaleSetsSpec.VirtualMachineProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		virtualMachineProfile := virtualMachineProfileARM.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfileARM)
		result.Properties.VirtualMachineProfile = &virtualMachineProfile
	}
	if virtualMachineScaleSetsSpec.ZoneBalance != nil {
		zoneBalance := *virtualMachineScaleSetsSpec.ZoneBalance
		result.Properties.ZoneBalance = &zoneBalance
	}

	// Set property ‘Sku’:
	if virtualMachineScaleSetsSpec.Sku != nil {
		skuARM, err := (*virtualMachineScaleSetsSpec.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := skuARM.(SkuARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if virtualMachineScaleSetsSpec.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range virtualMachineScaleSetsSpec.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	result.Type = VirtualMachineScaleSetsSpecTypeMicrosoftComputeVirtualMachineScaleSets

	// Set property ‘Zones’:
	for _, item := range virtualMachineScaleSetsSpec.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetsSpec *VirtualMachineScaleSets_Spec) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSets_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetsSpec *VirtualMachineScaleSets_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSets_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSets_SpecARM, got %T", armInput)
	}

	// Set property ‘AdditionalCapabilities’:
	// copying flattened property:
	if typedInput.Properties.AdditionalCapabilities != nil {
		var additionalCapabilities1 AdditionalCapabilities
		err := additionalCapabilities1.PopulateFromARM(owner, *typedInput.Properties.AdditionalCapabilities)
		if err != nil {
			return err
		}
		additionalCapabilities := additionalCapabilities1
		virtualMachineScaleSetsSpec.AdditionalCapabilities = &additionalCapabilities
	}

	// Set property ‘AutomaticRepairsPolicy’:
	// copying flattened property:
	if typedInput.Properties.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy1 AutomaticRepairsPolicy
		err := automaticRepairsPolicy1.PopulateFromARM(owner, *typedInput.Properties.AutomaticRepairsPolicy)
		if err != nil {
			return err
		}
		automaticRepairsPolicy := automaticRepairsPolicy1
		virtualMachineScaleSetsSpec.AutomaticRepairsPolicy = &automaticRepairsPolicy
	}

	// Set property ‘AzureName’:
	virtualMachineScaleSetsSpec.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘DoNotRunExtensionsOnOverprovisionedVMs’:
	// copying flattened property:
	if typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVMs := *typedInput.Properties.DoNotRunExtensionsOnOverprovisionedVMs
		virtualMachineScaleSetsSpec.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVMs
	}

	// Set property ‘ExtendedLocation’:
	if typedInput.ExtendedLocation != nil {
		var extendedLocation1 ExtendedLocation
		err := extendedLocation1.PopulateFromARM(owner, *typedInput.ExtendedLocation)
		if err != nil {
			return err
		}
		extendedLocation := extendedLocation1
		virtualMachineScaleSetsSpec.ExtendedLocation = &extendedLocation
	}

	// Set property ‘HostGroup’:
	// copying flattened property:
	if typedInput.Properties.HostGroup != nil {
		var hostGroup1 SubResource
		err := hostGroup1.PopulateFromARM(owner, *typedInput.Properties.HostGroup)
		if err != nil {
			return err
		}
		hostGroup := hostGroup1
		virtualMachineScaleSetsSpec.HostGroup = &hostGroup
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 VirtualMachineScaleSetIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		virtualMachineScaleSetsSpec.Identity = &identity
	}

	// Set property ‘Location’:
	virtualMachineScaleSetsSpec.Location = typedInput.Location

	// Set property ‘OrchestrationMode’:
	// copying flattened property:
	if typedInput.Properties.OrchestrationMode != nil {
		orchestrationMode := *typedInput.Properties.OrchestrationMode
		virtualMachineScaleSetsSpec.OrchestrationMode = &orchestrationMode
	}

	// Set property ‘Overprovision’:
	// copying flattened property:
	if typedInput.Properties.Overprovision != nil {
		overprovision := *typedInput.Properties.Overprovision
		virtualMachineScaleSetsSpec.Overprovision = &overprovision
	}

	// Set property ‘Owner’:
	virtualMachineScaleSetsSpec.Owner = genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘Plan’:
	if typedInput.Plan != nil {
		var plan1 Plan
		err := plan1.PopulateFromARM(owner, *typedInput.Plan)
		if err != nil {
			return err
		}
		plan := plan1
		virtualMachineScaleSetsSpec.Plan = &plan
	}

	// Set property ‘PlatformFaultDomainCount’:
	// copying flattened property:
	if typedInput.Properties.PlatformFaultDomainCount != nil {
		platformFaultDomainCount := *typedInput.Properties.PlatformFaultDomainCount
		virtualMachineScaleSetsSpec.PlatformFaultDomainCount = &platformFaultDomainCount
	}

	// Set property ‘ProximityPlacementGroup’:
	// copying flattened property:
	if typedInput.Properties.ProximityPlacementGroup != nil {
		var proximityPlacementGroup1 SubResource
		err := proximityPlacementGroup1.PopulateFromARM(owner, *typedInput.Properties.ProximityPlacementGroup)
		if err != nil {
			return err
		}
		proximityPlacementGroup := proximityPlacementGroup1
		virtualMachineScaleSetsSpec.ProximityPlacementGroup = &proximityPlacementGroup
	}

	// Set property ‘ScaleInPolicy’:
	// copying flattened property:
	if typedInput.Properties.ScaleInPolicy != nil {
		var scaleInPolicy1 ScaleInPolicy
		err := scaleInPolicy1.PopulateFromARM(owner, *typedInput.Properties.ScaleInPolicy)
		if err != nil {
			return err
		}
		scaleInPolicy := scaleInPolicy1
		virtualMachineScaleSetsSpec.ScaleInPolicy = &scaleInPolicy
	}

	// Set property ‘SinglePlacementGroup’:
	// copying flattened property:
	if typedInput.Properties.SinglePlacementGroup != nil {
		singlePlacementGroup := *typedInput.Properties.SinglePlacementGroup
		virtualMachineScaleSetsSpec.SinglePlacementGroup = &singlePlacementGroup
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		virtualMachineScaleSetsSpec.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		virtualMachineScaleSetsSpec.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			virtualMachineScaleSetsSpec.Tags[key] = value
		}
	}

	// Set property ‘UpgradePolicy’:
	// copying flattened property:
	if typedInput.Properties.UpgradePolicy != nil {
		var upgradePolicy1 UpgradePolicy
		err := upgradePolicy1.PopulateFromARM(owner, *typedInput.Properties.UpgradePolicy)
		if err != nil {
			return err
		}
		upgradePolicy := upgradePolicy1
		virtualMachineScaleSetsSpec.UpgradePolicy = &upgradePolicy
	}

	// Set property ‘VirtualMachineProfile’:
	// copying flattened property:
	if typedInput.Properties.VirtualMachineProfile != nil {
		var virtualMachineProfile1 VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile
		err := virtualMachineProfile1.PopulateFromARM(owner, *typedInput.Properties.VirtualMachineProfile)
		if err != nil {
			return err
		}
		virtualMachineProfile := virtualMachineProfile1
		virtualMachineScaleSetsSpec.VirtualMachineProfile = &virtualMachineProfile
	}

	// Set property ‘ZoneBalance’:
	// copying flattened property:
	if typedInput.Properties.ZoneBalance != nil {
		zoneBalance := *typedInput.Properties.ZoneBalance
		virtualMachineScaleSetsSpec.ZoneBalance = &zoneBalance
	}

	// Set property ‘Zones’:
	for _, item := range typedInput.Zones {
		virtualMachineScaleSetsSpec.Zones = append(virtualMachineScaleSetsSpec.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &VirtualMachineScaleSets_Spec{}

// ConvertSpecFrom populates our VirtualMachineScaleSets_Spec from the provided source
func (virtualMachineScaleSetsSpec *VirtualMachineScaleSets_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1alpha1api20201201storage.VirtualMachineScaleSets_Spec)
	if ok {
		// Populate our instance from source
		return virtualMachineScaleSetsSpec.AssignPropertiesFromVirtualMachineScaleSetsSpec(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20201201storage.VirtualMachineScaleSets_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = virtualMachineScaleSetsSpec.AssignPropertiesFromVirtualMachineScaleSetsSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our VirtualMachineScaleSets_Spec
func (virtualMachineScaleSetsSpec *VirtualMachineScaleSets_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1alpha1api20201201storage.VirtualMachineScaleSets_Spec)
	if ok {
		// Populate destination from our instance
		return virtualMachineScaleSetsSpec.AssignPropertiesToVirtualMachineScaleSetsSpec(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20201201storage.VirtualMachineScaleSets_Spec{}
	err := virtualMachineScaleSetsSpec.AssignPropertiesToVirtualMachineScaleSetsSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetsSpec populates our VirtualMachineScaleSets_Spec from the provided source VirtualMachineScaleSets_Spec
func (virtualMachineScaleSetsSpec *VirtualMachineScaleSets_Spec) AssignPropertiesFromVirtualMachineScaleSetsSpec(source *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec) error {

	// AdditionalCapabilities
	if source.AdditionalCapabilities != nil {
		var additionalCapability AdditionalCapabilities
		err := additionalCapability.AssignPropertiesFromAdditionalCapabilities(source.AdditionalCapabilities)
		if err != nil {
			return errors.Wrap(err, "populating AdditionalCapabilities from AdditionalCapabilities, calling AssignPropertiesFromAdditionalCapabilities()")
		}
		virtualMachineScaleSetsSpec.AdditionalCapabilities = &additionalCapability
	} else {
		virtualMachineScaleSetsSpec.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if source.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy AutomaticRepairsPolicy
		err := automaticRepairsPolicy.AssignPropertiesFromAutomaticRepairsPolicy(source.AutomaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "populating AutomaticRepairsPolicy from AutomaticRepairsPolicy, calling AssignPropertiesFromAutomaticRepairsPolicy()")
		}
		virtualMachineScaleSetsSpec.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		virtualMachineScaleSetsSpec.AutomaticRepairsPolicy = nil
	}

	// AzureName
	virtualMachineScaleSetsSpec.AzureName = source.AzureName

	// DoNotRunExtensionsOnOverprovisionedVMs
	if source.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *source.DoNotRunExtensionsOnOverprovisionedVMs
		virtualMachineScaleSetsSpec.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		virtualMachineScaleSetsSpec.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignPropertiesFromExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesFromExtendedLocation()")
		}
		virtualMachineScaleSetsSpec.ExtendedLocation = &extendedLocation
	} else {
		virtualMachineScaleSetsSpec.ExtendedLocation = nil
	}

	// HostGroup
	if source.HostGroup != nil {
		var hostGroup SubResource
		err := hostGroup.AssignPropertiesFromSubResource(source.HostGroup)
		if err != nil {
			return errors.Wrap(err, "populating HostGroup from HostGroup, calling AssignPropertiesFromSubResource()")
		}
		virtualMachineScaleSetsSpec.HostGroup = &hostGroup
	} else {
		virtualMachineScaleSetsSpec.HostGroup = nil
	}

	// Identity
	if source.Identity != nil {
		var identity VirtualMachineScaleSetIdentity
		err := identity.AssignPropertiesFromVirtualMachineScaleSetIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesFromVirtualMachineScaleSetIdentity()")
		}
		virtualMachineScaleSetsSpec.Identity = &identity
	} else {
		virtualMachineScaleSetsSpec.Identity = nil
	}

	// Location
	if source.Location != nil {
		virtualMachineScaleSetsSpec.Location = *source.Location
	} else {
		virtualMachineScaleSetsSpec.Location = ""
	}

	// OrchestrationMode
	if source.OrchestrationMode != nil {
		orchestrationMode := VirtualMachineScaleSetsSpecPropertiesOrchestrationMode(*source.OrchestrationMode)
		virtualMachineScaleSetsSpec.OrchestrationMode = &orchestrationMode
	} else {
		virtualMachineScaleSetsSpec.OrchestrationMode = nil
	}

	// Overprovision
	if source.Overprovision != nil {
		overprovision := *source.Overprovision
		virtualMachineScaleSetsSpec.Overprovision = &overprovision
	} else {
		virtualMachineScaleSetsSpec.Overprovision = nil
	}

	// Owner
	virtualMachineScaleSetsSpec.Owner = source.Owner.Copy()

	// Plan
	if source.Plan != nil {
		var plan Plan
		err := plan.AssignPropertiesFromPlan(source.Plan)
		if err != nil {
			return errors.Wrap(err, "populating Plan from Plan, calling AssignPropertiesFromPlan()")
		}
		virtualMachineScaleSetsSpec.Plan = &plan
	} else {
		virtualMachineScaleSetsSpec.Plan = nil
	}

	// PlatformFaultDomainCount
	if source.PlatformFaultDomainCount != nil {
		platformFaultDomainCount := *source.PlatformFaultDomainCount
		virtualMachineScaleSetsSpec.PlatformFaultDomainCount = &platformFaultDomainCount
	} else {
		virtualMachineScaleSetsSpec.PlatformFaultDomainCount = nil
	}

	// ProximityPlacementGroup
	if source.ProximityPlacementGroup != nil {
		var proximityPlacementGroup SubResource
		err := proximityPlacementGroup.AssignPropertiesFromSubResource(source.ProximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "populating ProximityPlacementGroup from ProximityPlacementGroup, calling AssignPropertiesFromSubResource()")
		}
		virtualMachineScaleSetsSpec.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		virtualMachineScaleSetsSpec.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if source.ScaleInPolicy != nil {
		var scaleInPolicy ScaleInPolicy
		err := scaleInPolicy.AssignPropertiesFromScaleInPolicy(source.ScaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "populating ScaleInPolicy from ScaleInPolicy, calling AssignPropertiesFromScaleInPolicy()")
		}
		virtualMachineScaleSetsSpec.ScaleInPolicy = &scaleInPolicy
	} else {
		virtualMachineScaleSetsSpec.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if source.SinglePlacementGroup != nil {
		singlePlacementGroup := *source.SinglePlacementGroup
		virtualMachineScaleSetsSpec.SinglePlacementGroup = &singlePlacementGroup
	} else {
		virtualMachineScaleSetsSpec.SinglePlacementGroup = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignPropertiesFromSku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesFromSku()")
		}
		virtualMachineScaleSetsSpec.Sku = &sku
	} else {
		virtualMachineScaleSetsSpec.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range source.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	virtualMachineScaleSetsSpec.Tags = tagMap

	// UpgradePolicy
	if source.UpgradePolicy != nil {
		var upgradePolicy UpgradePolicy
		err := upgradePolicy.AssignPropertiesFromUpgradePolicy(source.UpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "populating UpgradePolicy from UpgradePolicy, calling AssignPropertiesFromUpgradePolicy()")
		}
		virtualMachineScaleSetsSpec.UpgradePolicy = &upgradePolicy
	} else {
		virtualMachineScaleSetsSpec.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if source.VirtualMachineProfile != nil {
		var virtualMachineProfile VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile
		err := virtualMachineProfile.AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfile(source.VirtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "populating VirtualMachineProfile from VirtualMachineProfile, calling AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfile()")
		}
		virtualMachineScaleSetsSpec.VirtualMachineProfile = &virtualMachineProfile
	} else {
		virtualMachineScaleSetsSpec.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if source.ZoneBalance != nil {
		zoneBalance := *source.ZoneBalance
		virtualMachineScaleSetsSpec.ZoneBalance = &zoneBalance
	} else {
		virtualMachineScaleSetsSpec.ZoneBalance = nil
	}

	// Zones
	zoneList := make([]string, len(source.Zones))
	for zoneIndex, zoneItem := range source.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	virtualMachineScaleSetsSpec.Zones = zoneList

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetsSpec populates the provided destination VirtualMachineScaleSets_Spec from our VirtualMachineScaleSets_Spec
func (virtualMachineScaleSetsSpec *VirtualMachineScaleSets_Spec) AssignPropertiesToVirtualMachineScaleSetsSpec(destination *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalCapabilities
	if virtualMachineScaleSetsSpec.AdditionalCapabilities != nil {
		var additionalCapability v1alpha1api20201201storage.AdditionalCapabilities
		err := (*virtualMachineScaleSetsSpec.AdditionalCapabilities).AssignPropertiesToAdditionalCapabilities(&additionalCapability)
		if err != nil {
			return errors.Wrap(err, "populating AdditionalCapabilities from AdditionalCapabilities, calling AssignPropertiesToAdditionalCapabilities()")
		}
		destination.AdditionalCapabilities = &additionalCapability
	} else {
		destination.AdditionalCapabilities = nil
	}

	// AutomaticRepairsPolicy
	if virtualMachineScaleSetsSpec.AutomaticRepairsPolicy != nil {
		var automaticRepairsPolicy v1alpha1api20201201storage.AutomaticRepairsPolicy
		err := (*virtualMachineScaleSetsSpec.AutomaticRepairsPolicy).AssignPropertiesToAutomaticRepairsPolicy(&automaticRepairsPolicy)
		if err != nil {
			return errors.Wrap(err, "populating AutomaticRepairsPolicy from AutomaticRepairsPolicy, calling AssignPropertiesToAutomaticRepairsPolicy()")
		}
		destination.AutomaticRepairsPolicy = &automaticRepairsPolicy
	} else {
		destination.AutomaticRepairsPolicy = nil
	}

	// AzureName
	destination.AzureName = virtualMachineScaleSetsSpec.AzureName

	// DoNotRunExtensionsOnOverprovisionedVMs
	if virtualMachineScaleSetsSpec.DoNotRunExtensionsOnOverprovisionedVMs != nil {
		doNotRunExtensionsOnOverprovisionedVM := *virtualMachineScaleSetsSpec.DoNotRunExtensionsOnOverprovisionedVMs
		destination.DoNotRunExtensionsOnOverprovisionedVMs = &doNotRunExtensionsOnOverprovisionedVM
	} else {
		destination.DoNotRunExtensionsOnOverprovisionedVMs = nil
	}

	// ExtendedLocation
	if virtualMachineScaleSetsSpec.ExtendedLocation != nil {
		var extendedLocation v1alpha1api20201201storage.ExtendedLocation
		err := (*virtualMachineScaleSetsSpec.ExtendedLocation).AssignPropertiesToExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "populating ExtendedLocation from ExtendedLocation, calling AssignPropertiesToExtendedLocation()")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// HostGroup
	if virtualMachineScaleSetsSpec.HostGroup != nil {
		var hostGroup v1alpha1api20201201storage.SubResource
		err := (*virtualMachineScaleSetsSpec.HostGroup).AssignPropertiesToSubResource(&hostGroup)
		if err != nil {
			return errors.Wrap(err, "populating HostGroup from HostGroup, calling AssignPropertiesToSubResource()")
		}
		destination.HostGroup = &hostGroup
	} else {
		destination.HostGroup = nil
	}

	// Identity
	if virtualMachineScaleSetsSpec.Identity != nil {
		var identity v1alpha1api20201201storage.VirtualMachineScaleSetIdentity
		err := (*virtualMachineScaleSetsSpec.Identity).AssignPropertiesToVirtualMachineScaleSetIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "populating Identity from Identity, calling AssignPropertiesToVirtualMachineScaleSetIdentity()")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	location := virtualMachineScaleSetsSpec.Location
	destination.Location = &location

	// OrchestrationMode
	if virtualMachineScaleSetsSpec.OrchestrationMode != nil {
		orchestrationMode := string(*virtualMachineScaleSetsSpec.OrchestrationMode)
		destination.OrchestrationMode = &orchestrationMode
	} else {
		destination.OrchestrationMode = nil
	}

	// OriginalVersion
	destination.OriginalVersion = virtualMachineScaleSetsSpec.OriginalVersion()

	// Overprovision
	if virtualMachineScaleSetsSpec.Overprovision != nil {
		overprovision := *virtualMachineScaleSetsSpec.Overprovision
		destination.Overprovision = &overprovision
	} else {
		destination.Overprovision = nil
	}

	// Owner
	destination.Owner = virtualMachineScaleSetsSpec.Owner.Copy()

	// Plan
	if virtualMachineScaleSetsSpec.Plan != nil {
		var plan v1alpha1api20201201storage.Plan
		err := (*virtualMachineScaleSetsSpec.Plan).AssignPropertiesToPlan(&plan)
		if err != nil {
			return errors.Wrap(err, "populating Plan from Plan, calling AssignPropertiesToPlan()")
		}
		destination.Plan = &plan
	} else {
		destination.Plan = nil
	}

	// PlatformFaultDomainCount
	if virtualMachineScaleSetsSpec.PlatformFaultDomainCount != nil {
		platformFaultDomainCount := *virtualMachineScaleSetsSpec.PlatformFaultDomainCount
		destination.PlatformFaultDomainCount = &platformFaultDomainCount
	} else {
		destination.PlatformFaultDomainCount = nil
	}

	// ProximityPlacementGroup
	if virtualMachineScaleSetsSpec.ProximityPlacementGroup != nil {
		var proximityPlacementGroup v1alpha1api20201201storage.SubResource
		err := (*virtualMachineScaleSetsSpec.ProximityPlacementGroup).AssignPropertiesToSubResource(&proximityPlacementGroup)
		if err != nil {
			return errors.Wrap(err, "populating ProximityPlacementGroup from ProximityPlacementGroup, calling AssignPropertiesToSubResource()")
		}
		destination.ProximityPlacementGroup = &proximityPlacementGroup
	} else {
		destination.ProximityPlacementGroup = nil
	}

	// ScaleInPolicy
	if virtualMachineScaleSetsSpec.ScaleInPolicy != nil {
		var scaleInPolicy v1alpha1api20201201storage.ScaleInPolicy
		err := (*virtualMachineScaleSetsSpec.ScaleInPolicy).AssignPropertiesToScaleInPolicy(&scaleInPolicy)
		if err != nil {
			return errors.Wrap(err, "populating ScaleInPolicy from ScaleInPolicy, calling AssignPropertiesToScaleInPolicy()")
		}
		destination.ScaleInPolicy = &scaleInPolicy
	} else {
		destination.ScaleInPolicy = nil
	}

	// SinglePlacementGroup
	if virtualMachineScaleSetsSpec.SinglePlacementGroup != nil {
		singlePlacementGroup := *virtualMachineScaleSetsSpec.SinglePlacementGroup
		destination.SinglePlacementGroup = &singlePlacementGroup
	} else {
		destination.SinglePlacementGroup = nil
	}

	// Sku
	if virtualMachineScaleSetsSpec.Sku != nil {
		var sku v1alpha1api20201201storage.Sku
		err := (*virtualMachineScaleSetsSpec.Sku).AssignPropertiesToSku(&sku)
		if err != nil {
			return errors.Wrap(err, "populating Sku from Sku, calling AssignPropertiesToSku()")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	tagMap := make(map[string]string)
	for tagKey, tagValue := range virtualMachineScaleSetsSpec.Tags {
		// Shadow the loop variable to avoid aliasing
		tagValue := tagValue
		tagMap[tagKey] = tagValue
	}
	destination.Tags = tagMap

	// UpgradePolicy
	if virtualMachineScaleSetsSpec.UpgradePolicy != nil {
		var upgradePolicy v1alpha1api20201201storage.UpgradePolicy
		err := (*virtualMachineScaleSetsSpec.UpgradePolicy).AssignPropertiesToUpgradePolicy(&upgradePolicy)
		if err != nil {
			return errors.Wrap(err, "populating UpgradePolicy from UpgradePolicy, calling AssignPropertiesToUpgradePolicy()")
		}
		destination.UpgradePolicy = &upgradePolicy
	} else {
		destination.UpgradePolicy = nil
	}

	// VirtualMachineProfile
	if virtualMachineScaleSetsSpec.VirtualMachineProfile != nil {
		var virtualMachineProfile v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile
		err := (*virtualMachineScaleSetsSpec.VirtualMachineProfile).AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfile(&virtualMachineProfile)
		if err != nil {
			return errors.Wrap(err, "populating VirtualMachineProfile from VirtualMachineProfile, calling AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfile()")
		}
		destination.VirtualMachineProfile = &virtualMachineProfile
	} else {
		destination.VirtualMachineProfile = nil
	}

	// ZoneBalance
	if virtualMachineScaleSetsSpec.ZoneBalance != nil {
		zoneBalance := *virtualMachineScaleSetsSpec.ZoneBalance
		destination.ZoneBalance = &zoneBalance
	} else {
		destination.ZoneBalance = nil
	}

	// Zones
	zoneList := make([]string, len(virtualMachineScaleSetsSpec.Zones))
	for zoneIndex, zoneItem := range virtualMachineScaleSetsSpec.Zones {
		// Shadow the loop variable to avoid aliasing
		zoneItem := zoneItem
		zoneList[zoneIndex] = zoneItem
	}
	destination.Zones = zoneList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

func (virtualMachineScaleSetsSpec *VirtualMachineScaleSets_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (virtualMachineScaleSetsSpec *VirtualMachineScaleSets_Spec) SetAzureName(azureName string) {
	virtualMachineScaleSetsSpec.AzureName = azureName
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/AdditionalCapabilities
type AdditionalCapabilities struct {
	//UltraSSDEnabled: The flag that enables or disables a capability to have one or
	//more managed data disks with UltraSSD_LRS storage account type on the VM or
	//VMSS. Managed disks with storage account type UltraSSD_LRS can be added to a
	//virtual machine or virtual machine scale set only if this property is enabled.
	UltraSSDEnabled *bool `json:"ultraSSDEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &AdditionalCapabilities{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (additionalCapabilities *AdditionalCapabilities) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if additionalCapabilities == nil {
		return nil, nil
	}
	var result AdditionalCapabilitiesARM

	// Set property ‘UltraSSDEnabled’:
	if additionalCapabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *additionalCapabilities.UltraSSDEnabled
		result.UltraSSDEnabled = &ultraSSDEnabled
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (additionalCapabilities *AdditionalCapabilities) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdditionalCapabilitiesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (additionalCapabilities *AdditionalCapabilities) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdditionalCapabilitiesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdditionalCapabilitiesARM, got %T", armInput)
	}

	// Set property ‘UltraSSDEnabled’:
	if typedInput.UltraSSDEnabled != nil {
		ultraSSDEnabled := *typedInput.UltraSSDEnabled
		additionalCapabilities.UltraSSDEnabled = &ultraSSDEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromAdditionalCapabilities populates our AdditionalCapabilities from the provided source AdditionalCapabilities
func (additionalCapabilities *AdditionalCapabilities) AssignPropertiesFromAdditionalCapabilities(source *v1alpha1api20201201storage.AdditionalCapabilities) error {

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		additionalCapabilities.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		additionalCapabilities.UltraSSDEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalCapabilities populates the provided destination AdditionalCapabilities from our AdditionalCapabilities
func (additionalCapabilities *AdditionalCapabilities) AssignPropertiesToAdditionalCapabilities(destination *v1alpha1api20201201storage.AdditionalCapabilities) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UltraSSDEnabled
	if additionalCapabilities.UltraSSDEnabled != nil {
		ultraSSDEnabled := *additionalCapabilities.UltraSSDEnabled
		destination.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		destination.UltraSSDEnabled = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type AdditionalCapabilities_Status struct {
	//UltraSSDEnabled: The flag that enables or disables a capability to have one or
	//more managed data disks with UltraSSD_LRS storage account type on the VM or
	//VMSS. Managed disks with storage account type UltraSSD_LRS can be added to a
	//virtual machine or virtual machine scale set only if this property is enabled.
	UltraSSDEnabled *bool `json:"ultraSSDEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &AdditionalCapabilities_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (additionalCapabilitiesStatus *AdditionalCapabilities_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdditionalCapabilities_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (additionalCapabilitiesStatus *AdditionalCapabilities_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdditionalCapabilities_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdditionalCapabilities_StatusARM, got %T", armInput)
	}

	// Set property ‘UltraSSDEnabled’:
	if typedInput.UltraSSDEnabled != nil {
		ultraSSDEnabled := *typedInput.UltraSSDEnabled
		additionalCapabilitiesStatus.UltraSSDEnabled = &ultraSSDEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromAdditionalCapabilitiesStatus populates our AdditionalCapabilities_Status from the provided source AdditionalCapabilities_Status
func (additionalCapabilitiesStatus *AdditionalCapabilities_Status) AssignPropertiesFromAdditionalCapabilitiesStatus(source *v1alpha1api20201201storage.AdditionalCapabilities_Status) error {

	// UltraSSDEnabled
	if source.UltraSSDEnabled != nil {
		ultraSSDEnabled := *source.UltraSSDEnabled
		additionalCapabilitiesStatus.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		additionalCapabilitiesStatus.UltraSSDEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalCapabilitiesStatus populates the provided destination AdditionalCapabilities_Status from our AdditionalCapabilities_Status
func (additionalCapabilitiesStatus *AdditionalCapabilities_Status) AssignPropertiesToAdditionalCapabilitiesStatus(destination *v1alpha1api20201201storage.AdditionalCapabilities_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UltraSSDEnabled
	if additionalCapabilitiesStatus.UltraSSDEnabled != nil {
		ultraSSDEnabled := *additionalCapabilitiesStatus.UltraSSDEnabled
		destination.UltraSSDEnabled = &ultraSSDEnabled
	} else {
		destination.UltraSSDEnabled = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/AutomaticRepairsPolicy
type AutomaticRepairsPolicy struct {
	//Enabled: Specifies whether automatic repairs should be enabled on the virtual
	//machine scale set. The default value is false.
	Enabled *bool `json:"enabled,omitempty"`

	//GracePeriod: The amount of time for which automatic repairs are suspended due to
	//a state change on VM. The grace time starts after the state change has
	//completed. This helps avoid premature or accidental repairs. The time duration
	//should be specified in ISO 8601 format. The minimum allowed grace period is 30
	//minutes (PT30M), which is also the default value. The maximum allowed grace
	//period is 90 minutes (PT90M).
	GracePeriod *string `json:"gracePeriod,omitempty"`
}

var _ genruntime.ARMTransformer = &AutomaticRepairsPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (automaticRepairsPolicy *AutomaticRepairsPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if automaticRepairsPolicy == nil {
		return nil, nil
	}
	var result AutomaticRepairsPolicyARM

	// Set property ‘Enabled’:
	if automaticRepairsPolicy.Enabled != nil {
		enabled := *automaticRepairsPolicy.Enabled
		result.Enabled = &enabled
	}

	// Set property ‘GracePeriod’:
	if automaticRepairsPolicy.GracePeriod != nil {
		gracePeriod := *automaticRepairsPolicy.GracePeriod
		result.GracePeriod = &gracePeriod
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (automaticRepairsPolicy *AutomaticRepairsPolicy) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutomaticRepairsPolicyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (automaticRepairsPolicy *AutomaticRepairsPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutomaticRepairsPolicyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutomaticRepairsPolicyARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		automaticRepairsPolicy.Enabled = &enabled
	}

	// Set property ‘GracePeriod’:
	if typedInput.GracePeriod != nil {
		gracePeriod := *typedInput.GracePeriod
		automaticRepairsPolicy.GracePeriod = &gracePeriod
	}

	// No error
	return nil
}

// AssignPropertiesFromAutomaticRepairsPolicy populates our AutomaticRepairsPolicy from the provided source AutomaticRepairsPolicy
func (automaticRepairsPolicy *AutomaticRepairsPolicy) AssignPropertiesFromAutomaticRepairsPolicy(source *v1alpha1api20201201storage.AutomaticRepairsPolicy) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		automaticRepairsPolicy.Enabled = &enabled
	} else {
		automaticRepairsPolicy.Enabled = nil
	}

	// GracePeriod
	if source.GracePeriod != nil {
		gracePeriod := *source.GracePeriod
		automaticRepairsPolicy.GracePeriod = &gracePeriod
	} else {
		automaticRepairsPolicy.GracePeriod = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAutomaticRepairsPolicy populates the provided destination AutomaticRepairsPolicy from our AutomaticRepairsPolicy
func (automaticRepairsPolicy *AutomaticRepairsPolicy) AssignPropertiesToAutomaticRepairsPolicy(destination *v1alpha1api20201201storage.AutomaticRepairsPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if automaticRepairsPolicy.Enabled != nil {
		enabled := *automaticRepairsPolicy.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GracePeriod
	if automaticRepairsPolicy.GracePeriod != nil {
		gracePeriod := *automaticRepairsPolicy.GracePeriod
		destination.GracePeriod = &gracePeriod
	} else {
		destination.GracePeriod = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type AutomaticRepairsPolicy_Status struct {
	//Enabled: Specifies whether automatic repairs should be enabled on the virtual
	//machine scale set. The default value is false.
	Enabled *bool `json:"enabled,omitempty"`

	//GracePeriod: The amount of time for which automatic repairs are suspended due to
	//a state change on VM. The grace time starts after the state change has
	//completed. This helps avoid premature or accidental repairs. The time duration
	//should be specified in ISO 8601 format. The minimum allowed grace period is 30
	//minutes (PT30M), which is also the default value. The maximum allowed grace
	//period is 90 minutes (PT90M).
	GracePeriod *string `json:"gracePeriod,omitempty"`
}

var _ genruntime.FromARMConverter = &AutomaticRepairsPolicy_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (automaticRepairsPolicyStatus *AutomaticRepairsPolicy_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutomaticRepairsPolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (automaticRepairsPolicyStatus *AutomaticRepairsPolicy_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutomaticRepairsPolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutomaticRepairsPolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		automaticRepairsPolicyStatus.Enabled = &enabled
	}

	// Set property ‘GracePeriod’:
	if typedInput.GracePeriod != nil {
		gracePeriod := *typedInput.GracePeriod
		automaticRepairsPolicyStatus.GracePeriod = &gracePeriod
	}

	// No error
	return nil
}

// AssignPropertiesFromAutomaticRepairsPolicyStatus populates our AutomaticRepairsPolicy_Status from the provided source AutomaticRepairsPolicy_Status
func (automaticRepairsPolicyStatus *AutomaticRepairsPolicy_Status) AssignPropertiesFromAutomaticRepairsPolicyStatus(source *v1alpha1api20201201storage.AutomaticRepairsPolicy_Status) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		automaticRepairsPolicyStatus.Enabled = &enabled
	} else {
		automaticRepairsPolicyStatus.Enabled = nil
	}

	// GracePeriod
	if source.GracePeriod != nil {
		gracePeriod := *source.GracePeriod
		automaticRepairsPolicyStatus.GracePeriod = &gracePeriod
	} else {
		automaticRepairsPolicyStatus.GracePeriod = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAutomaticRepairsPolicyStatus populates the provided destination AutomaticRepairsPolicy_Status from our AutomaticRepairsPolicy_Status
func (automaticRepairsPolicyStatus *AutomaticRepairsPolicy_Status) AssignPropertiesToAutomaticRepairsPolicyStatus(destination *v1alpha1api20201201storage.AutomaticRepairsPolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if automaticRepairsPolicyStatus.Enabled != nil {
		enabled := *automaticRepairsPolicyStatus.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// GracePeriod
	if automaticRepairsPolicyStatus.GracePeriod != nil {
		gracePeriod := *automaticRepairsPolicyStatus.GracePeriod
		destination.GracePeriod = &gracePeriod
	} else {
		destination.GracePeriod = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/ExtendedLocation
type ExtendedLocation struct {
	//Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	//Type: The type of the extended location.
	Type *ExtendedLocationType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ExtendedLocation{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (extendedLocation *ExtendedLocation) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if extendedLocation == nil {
		return nil, nil
	}
	var result ExtendedLocationARM

	// Set property ‘Name’:
	if extendedLocation.Name != nil {
		name := *extendedLocation.Name
		result.Name = &name
	}

	// Set property ‘Type’:
	if extendedLocation.Type != nil {
		typeVar := *extendedLocation.Type
		result.Type = &typeVar
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extendedLocation *ExtendedLocation) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extendedLocation *ExtendedLocation) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocationARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		extendedLocation.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		extendedLocation.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (extendedLocation *ExtendedLocation) AssignPropertiesFromExtendedLocation(source *v1alpha1api20201201storage.ExtendedLocation) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		extendedLocation.Name = &name
	} else {
		extendedLocation.Name = nil
	}

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType(*source.Type)
		extendedLocation.Type = &typeVar
	} else {
		extendedLocation.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (extendedLocation *ExtendedLocation) AssignPropertiesToExtendedLocation(destination *v1alpha1api20201201storage.ExtendedLocation) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if extendedLocation.Name != nil {
		name := *extendedLocation.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Type
	if extendedLocation.Type != nil {
		typeVar := string(*extendedLocation.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ExtendedLocation_Status struct {
	//Name: The name of the extended location.
	Name *string `json:"name,omitempty"`

	//Type: The type of the extended location.
	Type *ExtendedLocationType_Status `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ExtendedLocation_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (extendedLocationStatus *ExtendedLocation_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExtendedLocation_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (extendedLocationStatus *ExtendedLocation_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExtendedLocation_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExtendedLocation_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		extendedLocationStatus.Name = &name
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		extendedLocationStatus.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromExtendedLocationStatus populates our ExtendedLocation_Status from the provided source ExtendedLocation_Status
func (extendedLocationStatus *ExtendedLocation_Status) AssignPropertiesFromExtendedLocationStatus(source *v1alpha1api20201201storage.ExtendedLocation_Status) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		extendedLocationStatus.Name = &name
	} else {
		extendedLocationStatus.Name = nil
	}

	// Type
	if source.Type != nil {
		typeVar := ExtendedLocationType_Status(*source.Type)
		extendedLocationStatus.Type = &typeVar
	} else {
		extendedLocationStatus.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToExtendedLocationStatus populates the provided destination ExtendedLocation_Status from our ExtendedLocation_Status
func (extendedLocationStatus *ExtendedLocation_Status) AssignPropertiesToExtendedLocationStatus(destination *v1alpha1api20201201storage.ExtendedLocation_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if extendedLocationStatus.Name != nil {
		name := *extendedLocationStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Type
	if extendedLocationStatus.Type != nil {
		typeVar := string(*extendedLocationStatus.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type OrchestrationMode_Status string

const (
	OrchestrationMode_StatusFlexible = OrchestrationMode_Status("Flexible")
	OrchestrationMode_StatusUniform  = OrchestrationMode_Status("Uniform")
)

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/Plan
type Plan struct {
	//Name: The plan ID.
	Name *string `json:"name,omitempty"`

	//Product: Specifies the product of the image from the marketplace. This is the
	//same value as Offer under the imageReference element.
	Product *string `json:"product,omitempty"`

	//PromotionCode: The promotion code.
	PromotionCode *string `json:"promotionCode,omitempty"`

	//Publisher: The publisher ID.
	Publisher *string `json:"publisher,omitempty"`
}

var _ genruntime.ARMTransformer = &Plan{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (plan *Plan) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if plan == nil {
		return nil, nil
	}
	var result PlanARM

	// Set property ‘Name’:
	if plan.Name != nil {
		name := *plan.Name
		result.Name = &name
	}

	// Set property ‘Product’:
	if plan.Product != nil {
		product := *plan.Product
		result.Product = &product
	}

	// Set property ‘PromotionCode’:
	if plan.PromotionCode != nil {
		promotionCode := *plan.PromotionCode
		result.PromotionCode = &promotionCode
	}

	// Set property ‘Publisher’:
	if plan.Publisher != nil {
		publisher := *plan.Publisher
		result.Publisher = &publisher
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (plan *Plan) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &PlanARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (plan *Plan) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PlanARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PlanARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		plan.Name = &name
	}

	// Set property ‘Product’:
	if typedInput.Product != nil {
		product := *typedInput.Product
		plan.Product = &product
	}

	// Set property ‘PromotionCode’:
	if typedInput.PromotionCode != nil {
		promotionCode := *typedInput.PromotionCode
		plan.PromotionCode = &promotionCode
	}

	// Set property ‘Publisher’:
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		plan.Publisher = &publisher
	}

	// No error
	return nil
}

// AssignPropertiesFromPlan populates our Plan from the provided source Plan
func (plan *Plan) AssignPropertiesFromPlan(source *v1alpha1api20201201storage.Plan) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		plan.Name = &name
	} else {
		plan.Name = nil
	}

	// Product
	if source.Product != nil {
		product := *source.Product
		plan.Product = &product
	} else {
		plan.Product = nil
	}

	// PromotionCode
	if source.PromotionCode != nil {
		promotionCode := *source.PromotionCode
		plan.PromotionCode = &promotionCode
	} else {
		plan.PromotionCode = nil
	}

	// Publisher
	if source.Publisher != nil {
		publisher := *source.Publisher
		plan.Publisher = &publisher
	} else {
		plan.Publisher = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPlan populates the provided destination Plan from our Plan
func (plan *Plan) AssignPropertiesToPlan(destination *v1alpha1api20201201storage.Plan) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if plan.Name != nil {
		name := *plan.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Product
	if plan.Product != nil {
		product := *plan.Product
		destination.Product = &product
	} else {
		destination.Product = nil
	}

	// PromotionCode
	if plan.PromotionCode != nil {
		promotionCode := *plan.PromotionCode
		destination.PromotionCode = &promotionCode
	} else {
		destination.PromotionCode = nil
	}

	// Publisher
	if plan.Publisher != nil {
		publisher := *plan.Publisher
		destination.Publisher = &publisher
	} else {
		destination.Publisher = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type Plan_Status struct {
	//Name: The plan ID.
	Name *string `json:"name,omitempty"`

	//Product: Specifies the product of the image from the marketplace. This is the
	//same value as Offer under the imageReference element.
	Product *string `json:"product,omitempty"`

	//PromotionCode: The promotion code.
	PromotionCode *string `json:"promotionCode,omitempty"`

	//Publisher: The publisher ID.
	Publisher *string `json:"publisher,omitempty"`
}

var _ genruntime.FromARMConverter = &Plan_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (planStatus *Plan_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &Plan_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (planStatus *Plan_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Plan_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Plan_StatusARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		planStatus.Name = &name
	}

	// Set property ‘Product’:
	if typedInput.Product != nil {
		product := *typedInput.Product
		planStatus.Product = &product
	}

	// Set property ‘PromotionCode’:
	if typedInput.PromotionCode != nil {
		promotionCode := *typedInput.PromotionCode
		planStatus.PromotionCode = &promotionCode
	}

	// Set property ‘Publisher’:
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		planStatus.Publisher = &publisher
	}

	// No error
	return nil
}

// AssignPropertiesFromPlanStatus populates our Plan_Status from the provided source Plan_Status
func (planStatus *Plan_Status) AssignPropertiesFromPlanStatus(source *v1alpha1api20201201storage.Plan_Status) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		planStatus.Name = &name
	} else {
		planStatus.Name = nil
	}

	// Product
	if source.Product != nil {
		product := *source.Product
		planStatus.Product = &product
	} else {
		planStatus.Product = nil
	}

	// PromotionCode
	if source.PromotionCode != nil {
		promotionCode := *source.PromotionCode
		planStatus.PromotionCode = &promotionCode
	} else {
		planStatus.PromotionCode = nil
	}

	// Publisher
	if source.Publisher != nil {
		publisher := *source.Publisher
		planStatus.Publisher = &publisher
	} else {
		planStatus.Publisher = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPlanStatus populates the provided destination Plan_Status from our Plan_Status
func (planStatus *Plan_Status) AssignPropertiesToPlanStatus(destination *v1alpha1api20201201storage.Plan_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if planStatus.Name != nil {
		name := *planStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Product
	if planStatus.Product != nil {
		product := *planStatus.Product
		destination.Product = &product
	} else {
		destination.Product = nil
	}

	// PromotionCode
	if planStatus.PromotionCode != nil {
		promotionCode := *planStatus.PromotionCode
		destination.PromotionCode = &promotionCode
	} else {
		destination.PromotionCode = nil
	}

	// Publisher
	if planStatus.Publisher != nil {
		publisher := *planStatus.Publisher
		destination.Publisher = &publisher
	} else {
		destination.Publisher = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/ScaleInPolicy
type ScaleInPolicy struct {
	//Rules: The rules to be followed when scaling-in a virtual machine scale set.
	//Possible values are:
	//Default When a virtual machine scale set is scaled in, the scale set will first
	//be balanced across zones if it is a zonal scale set. Then, it will be balanced
	//across Fault Domains as far as possible. Within each Fault Domain, the virtual
	//machines chosen for removal will be the newest ones that are not protected from
	//scale-in.
	//OldestVM When a virtual machine scale set is being scaled-in, the oldest virtual
	//machines that are not protected from scale-in will be chosen for removal. For
	//zonal virtual machine scale sets, the scale set will first be balanced across
	//zones. Within each zone, the oldest virtual machines that are not protected will
	//be chosen for removal.
	//NewestVM When a virtual machine scale set is being scaled-in, the newest virtual
	//machines that are not protected from scale-in will be chosen for removal. For
	//zonal virtual machine scale sets, the scale set will first be balanced across
	//zones. Within each zone, the newest virtual machines that are not protected will
	//be chosen for removal.
	Rules []ScaleInPolicyRules `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &ScaleInPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (scaleInPolicy *ScaleInPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if scaleInPolicy == nil {
		return nil, nil
	}
	var result ScaleInPolicyARM

	// Set property ‘Rules’:
	for _, item := range scaleInPolicy.Rules {
		result.Rules = append(result.Rules, item)
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scaleInPolicy *ScaleInPolicy) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScaleInPolicyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scaleInPolicy *ScaleInPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScaleInPolicyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScaleInPolicyARM, got %T", armInput)
	}

	// Set property ‘Rules’:
	for _, item := range typedInput.Rules {
		scaleInPolicy.Rules = append(scaleInPolicy.Rules, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromScaleInPolicy populates our ScaleInPolicy from the provided source ScaleInPolicy
func (scaleInPolicy *ScaleInPolicy) AssignPropertiesFromScaleInPolicy(source *v1alpha1api20201201storage.ScaleInPolicy) error {

	// Rules
	ruleList := make([]ScaleInPolicyRules, len(source.Rules))
	for ruleIndex, ruleItem := range source.Rules {
		// Shadow the loop variable to avoid aliasing
		ruleItem := ruleItem
		ruleList[ruleIndex] = ScaleInPolicyRules(ruleItem)
	}
	scaleInPolicy.Rules = ruleList

	// No error
	return nil
}

// AssignPropertiesToScaleInPolicy populates the provided destination ScaleInPolicy from our ScaleInPolicy
func (scaleInPolicy *ScaleInPolicy) AssignPropertiesToScaleInPolicy(destination *v1alpha1api20201201storage.ScaleInPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Rules
	ruleList := make([]string, len(scaleInPolicy.Rules))
	for ruleIndex, ruleItem := range scaleInPolicy.Rules {
		// Shadow the loop variable to avoid aliasing
		ruleItem := ruleItem
		ruleList[ruleIndex] = string(ruleItem)
	}
	destination.Rules = ruleList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ScaleInPolicy_Status struct {
	//Rules: The rules to be followed when scaling-in a virtual machine scale set.
	//Possible values are:
	//Default When a virtual machine scale set is scaled in, the scale set will first
	//be balanced across zones if it is a zonal scale set. Then, it will be balanced
	//across Fault Domains as far as possible. Within each Fault Domain, the virtual
	//machines chosen for removal will be the newest ones that are not protected from
	//scale-in.
	//OldestVM When a virtual machine scale set is being scaled-in, the oldest virtual
	//machines that are not protected from scale-in will be chosen for removal. For
	//zonal virtual machine scale sets, the scale set will first be balanced across
	//zones. Within each zone, the oldest virtual machines that are not protected will
	//be chosen for removal.
	//NewestVM When a virtual machine scale set is being scaled-in, the newest virtual
	//machines that are not protected from scale-in will be chosen for removal. For
	//zonal virtual machine scale sets, the scale set will first be balanced across
	//zones. Within each zone, the newest virtual machines that are not protected will
	//be chosen for removal.
	Rules []ScaleInPolicyStatusRules `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &ScaleInPolicy_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scaleInPolicyStatus *ScaleInPolicy_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScaleInPolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scaleInPolicyStatus *ScaleInPolicy_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScaleInPolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScaleInPolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘Rules’:
	for _, item := range typedInput.Rules {
		scaleInPolicyStatus.Rules = append(scaleInPolicyStatus.Rules, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromScaleInPolicyStatus populates our ScaleInPolicy_Status from the provided source ScaleInPolicy_Status
func (scaleInPolicyStatus *ScaleInPolicy_Status) AssignPropertiesFromScaleInPolicyStatus(source *v1alpha1api20201201storage.ScaleInPolicy_Status) error {

	// Rules
	ruleList := make([]ScaleInPolicyStatusRules, len(source.Rules))
	for ruleIndex, ruleItem := range source.Rules {
		// Shadow the loop variable to avoid aliasing
		ruleItem := ruleItem
		ruleList[ruleIndex] = ScaleInPolicyStatusRules(ruleItem)
	}
	scaleInPolicyStatus.Rules = ruleList

	// No error
	return nil
}

// AssignPropertiesToScaleInPolicyStatus populates the provided destination ScaleInPolicy_Status from our ScaleInPolicy_Status
func (scaleInPolicyStatus *ScaleInPolicy_Status) AssignPropertiesToScaleInPolicyStatus(destination *v1alpha1api20201201storage.ScaleInPolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Rules
	ruleList := make([]string, len(scaleInPolicyStatus.Rules))
	for ruleIndex, ruleItem := range scaleInPolicyStatus.Rules {
		// Shadow the loop variable to avoid aliasing
		ruleItem := ruleItem
		ruleList[ruleIndex] = string(ruleItem)
	}
	destination.Rules = ruleList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/Sku
type Sku struct {
	//Capacity: Specifies the number of virtual machines in the scale set.
	Capacity *int `json:"capacity,omitempty"`

	//Name: The sku name.
	Name *string `json:"name,omitempty"`

	//Tier: Specifies the tier of virtual machines in a scale set.
	//Possible Values:
	//Standard
	//Basic
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	var result SkuARM

	// Set property ‘Capacity’:
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		result.Capacity = &capacity
	}

	// Set property ‘Name’:
	if sku.Name != nil {
		name := *sku.Name
		result.Name = &name
	}

	// Set property ‘Tier’:
	if sku.Tier != nil {
		tier := *sku.Tier
		result.Tier = &tier
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &SkuARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SkuARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SkuARM, got %T", armInput)
	}

	// Set property ‘Capacity’:
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromSku populates our Sku from the provided source Sku
func (sku *Sku) AssignPropertiesFromSku(source *v1alpha1api20201201storage.Sku) error {

	// Capacity
	if source.Capacity != nil {
		capacity := *source.Capacity
		sku.Capacity = &capacity
	} else {
		sku.Capacity = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		sku.Name = &name
	} else {
		sku.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		sku.Tier = &tier
	} else {
		sku.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSku populates the provided destination Sku from our Sku
func (sku *Sku) AssignPropertiesToSku(destination *v1alpha1api20201201storage.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		destination.Capacity = &capacity
	} else {
		destination.Capacity = nil
	}

	// Name
	if sku.Name != nil {
		name := *sku.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if sku.Tier != nil {
		tier := *sku.Tier
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type Sku_Status struct {
	//Capacity: Specifies the number of virtual machines in the scale set.
	Capacity *int `json:"capacity,omitempty"`

	//Name: The sku name.
	Name *string `json:"name,omitempty"`

	//Tier: Specifies the tier of virtual machines in a scale set.
	//Possible Values:
	//Standard
	//Basic
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (skuStatus *Sku_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (skuStatus *Sku_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_StatusARM, got %T", armInput)
	}

	// Set property ‘Capacity’:
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		skuStatus.Capacity = &capacity
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		skuStatus.Name = &name
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		skuStatus.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromSkuStatus populates our Sku_Status from the provided source Sku_Status
func (skuStatus *Sku_Status) AssignPropertiesFromSkuStatus(source *v1alpha1api20201201storage.Sku_Status) error {

	// Capacity
	if source.Capacity != nil {
		capacity := *source.Capacity
		skuStatus.Capacity = &capacity
	} else {
		skuStatus.Capacity = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		skuStatus.Name = &name
	} else {
		skuStatus.Name = nil
	}

	// Tier
	if source.Tier != nil {
		tier := *source.Tier
		skuStatus.Tier = &tier
	} else {
		skuStatus.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSkuStatus populates the provided destination Sku_Status from our Sku_Status
func (skuStatus *Sku_Status) AssignPropertiesToSkuStatus(destination *v1alpha1api20201201storage.Sku_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	if skuStatus.Capacity != nil {
		capacity := *skuStatus.Capacity
		destination.Capacity = &capacity
	} else {
		destination.Capacity = nil
	}

	// Name
	if skuStatus.Name != nil {
		name := *skuStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Tier
	if skuStatus.Tier != nil {
		tier := *skuStatus.Tier
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/SubResource
type SubResource struct {
	//Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &SubResource{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (subResource *SubResource) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if subResource == nil {
		return nil, nil
	}
	var result SubResourceARM

	// Set property ‘Id’:
	if subResource.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*subResource.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subResource *SubResource) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &SubResourceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subResource *SubResource) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(SubResourceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SubResourceARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromSubResource populates our SubResource from the provided source SubResource
func (subResource *SubResource) AssignPropertiesFromSubResource(source *v1alpha1api20201201storage.SubResource) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		subResource.Reference = &reference
	} else {
		subResource.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSubResource populates the provided destination SubResource from our SubResource
func (subResource *SubResource) AssignPropertiesToSubResource(destination *v1alpha1api20201201storage.SubResource) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if subResource.Reference != nil {
		reference := subResource.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type SubResource_Status struct {
	//Id: Resource Id
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &SubResource_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (subResourceStatus *SubResource_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &SubResource_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (subResourceStatus *SubResource_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SubResource_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SubResource_StatusARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		subResourceStatus.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromSubResourceStatus populates our SubResource_Status from the provided source SubResource_Status
func (subResourceStatus *SubResource_Status) AssignPropertiesFromSubResourceStatus(source *v1alpha1api20201201storage.SubResource_Status) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		subResourceStatus.Id = &id
	} else {
		subResourceStatus.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSubResourceStatus populates the provided destination SubResource_Status from our SubResource_Status
func (subResourceStatus *SubResource_Status) AssignPropertiesToSubResourceStatus(destination *v1alpha1api20201201storage.SubResource_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if subResourceStatus.Id != nil {
		id := *subResourceStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/UpgradePolicy
type UpgradePolicy struct {
	//AutomaticOSUpgradePolicy: The configuration parameters used for performing
	//automatic OS upgrade.
	AutomaticOSUpgradePolicy *AutomaticOSUpgradePolicy `json:"automaticOSUpgradePolicy,omitempty"`

	//Mode: Specifies the mode of an upgrade to virtual machines in the scale set.
	//Possible values are:
	//Manual - You  control the application of updates to virtual machines in the
	//scale set. You do this by using the manualUpgrade action.
	//Automatic - All virtual machines in the scale set are  automatically updated at
	//the same time.
	Mode *UpgradePolicyMode `json:"mode,omitempty"`

	//RollingUpgradePolicy: The configuration parameters used while performing a
	//rolling upgrade.
	RollingUpgradePolicy *RollingUpgradePolicy `json:"rollingUpgradePolicy,omitempty"`
}

var _ genruntime.ARMTransformer = &UpgradePolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (upgradePolicy *UpgradePolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if upgradePolicy == nil {
		return nil, nil
	}
	var result UpgradePolicyARM

	// Set property ‘AutomaticOSUpgradePolicy’:
	if upgradePolicy.AutomaticOSUpgradePolicy != nil {
		automaticOSUpgradePolicyARM, err := (*upgradePolicy.AutomaticOSUpgradePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		automaticOSUpgradePolicy := automaticOSUpgradePolicyARM.(AutomaticOSUpgradePolicyARM)
		result.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	}

	// Set property ‘Mode’:
	if upgradePolicy.Mode != nil {
		mode := *upgradePolicy.Mode
		result.Mode = &mode
	}

	// Set property ‘RollingUpgradePolicy’:
	if upgradePolicy.RollingUpgradePolicy != nil {
		rollingUpgradePolicyARM, err := (*upgradePolicy.RollingUpgradePolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		rollingUpgradePolicy := rollingUpgradePolicyARM.(RollingUpgradePolicyARM)
		result.RollingUpgradePolicy = &rollingUpgradePolicy
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (upgradePolicy *UpgradePolicy) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &UpgradePolicyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (upgradePolicy *UpgradePolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UpgradePolicyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UpgradePolicyARM, got %T", armInput)
	}

	// Set property ‘AutomaticOSUpgradePolicy’:
	if typedInput.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy1 AutomaticOSUpgradePolicy
		err := automaticOSUpgradePolicy1.PopulateFromARM(owner, *typedInput.AutomaticOSUpgradePolicy)
		if err != nil {
			return err
		}
		automaticOSUpgradePolicy := automaticOSUpgradePolicy1
		upgradePolicy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	}

	// Set property ‘Mode’:
	if typedInput.Mode != nil {
		mode := *typedInput.Mode
		upgradePolicy.Mode = &mode
	}

	// Set property ‘RollingUpgradePolicy’:
	if typedInput.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy1 RollingUpgradePolicy
		err := rollingUpgradePolicy1.PopulateFromARM(owner, *typedInput.RollingUpgradePolicy)
		if err != nil {
			return err
		}
		rollingUpgradePolicy := rollingUpgradePolicy1
		upgradePolicy.RollingUpgradePolicy = &rollingUpgradePolicy
	}

	// No error
	return nil
}

// AssignPropertiesFromUpgradePolicy populates our UpgradePolicy from the provided source UpgradePolicy
func (upgradePolicy *UpgradePolicy) AssignPropertiesFromUpgradePolicy(source *v1alpha1api20201201storage.UpgradePolicy) error {

	// AutomaticOSUpgradePolicy
	if source.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy AutomaticOSUpgradePolicy
		err := automaticOSUpgradePolicy.AssignPropertiesFromAutomaticOSUpgradePolicy(source.AutomaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "populating AutomaticOSUpgradePolicy from AutomaticOSUpgradePolicy, calling AssignPropertiesFromAutomaticOSUpgradePolicy()")
		}
		upgradePolicy.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		upgradePolicy.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if source.Mode != nil {
		mode := UpgradePolicyMode(*source.Mode)
		upgradePolicy.Mode = &mode
	} else {
		upgradePolicy.Mode = nil
	}

	// RollingUpgradePolicy
	if source.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy RollingUpgradePolicy
		err := rollingUpgradePolicy.AssignPropertiesFromRollingUpgradePolicy(source.RollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "populating RollingUpgradePolicy from RollingUpgradePolicy, calling AssignPropertiesFromRollingUpgradePolicy()")
		}
		upgradePolicy.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		upgradePolicy.RollingUpgradePolicy = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUpgradePolicy populates the provided destination UpgradePolicy from our UpgradePolicy
func (upgradePolicy *UpgradePolicy) AssignPropertiesToUpgradePolicy(destination *v1alpha1api20201201storage.UpgradePolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutomaticOSUpgradePolicy
	if upgradePolicy.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy v1alpha1api20201201storage.AutomaticOSUpgradePolicy
		err := (*upgradePolicy.AutomaticOSUpgradePolicy).AssignPropertiesToAutomaticOSUpgradePolicy(&automaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "populating AutomaticOSUpgradePolicy from AutomaticOSUpgradePolicy, calling AssignPropertiesToAutomaticOSUpgradePolicy()")
		}
		destination.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		destination.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if upgradePolicy.Mode != nil {
		mode := string(*upgradePolicy.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// RollingUpgradePolicy
	if upgradePolicy.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy v1alpha1api20201201storage.RollingUpgradePolicy
		err := (*upgradePolicy.RollingUpgradePolicy).AssignPropertiesToRollingUpgradePolicy(&rollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "populating RollingUpgradePolicy from RollingUpgradePolicy, calling AssignPropertiesToRollingUpgradePolicy()")
		}
		destination.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		destination.RollingUpgradePolicy = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type UpgradePolicy_Status struct {
	//AutomaticOSUpgradePolicy: Configuration parameters used for performing automatic
	//OS Upgrade.
	AutomaticOSUpgradePolicy *AutomaticOSUpgradePolicy_Status `json:"automaticOSUpgradePolicy,omitempty"`

	//Mode: Specifies the mode of an upgrade to virtual machines in the scale set.
	//Possible values are:
	//Manual - You  control the application of updates to virtual machines in the
	//scale set. You do this by using the manualUpgrade action.
	//Automatic - All virtual machines in the scale set are  automatically updated at
	//the same time.
	Mode *UpgradePolicyStatusMode `json:"mode,omitempty"`

	//RollingUpgradePolicy: The configuration parameters used while performing a
	//rolling upgrade.
	RollingUpgradePolicy *RollingUpgradePolicy_Status `json:"rollingUpgradePolicy,omitempty"`
}

var _ genruntime.FromARMConverter = &UpgradePolicy_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (upgradePolicyStatus *UpgradePolicy_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &UpgradePolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (upgradePolicyStatus *UpgradePolicy_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UpgradePolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UpgradePolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘AutomaticOSUpgradePolicy’:
	if typedInput.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy1 AutomaticOSUpgradePolicy_Status
		err := automaticOSUpgradePolicy1.PopulateFromARM(owner, *typedInput.AutomaticOSUpgradePolicy)
		if err != nil {
			return err
		}
		automaticOSUpgradePolicy := automaticOSUpgradePolicy1
		upgradePolicyStatus.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	}

	// Set property ‘Mode’:
	if typedInput.Mode != nil {
		mode := *typedInput.Mode
		upgradePolicyStatus.Mode = &mode
	}

	// Set property ‘RollingUpgradePolicy’:
	if typedInput.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy1 RollingUpgradePolicy_Status
		err := rollingUpgradePolicy1.PopulateFromARM(owner, *typedInput.RollingUpgradePolicy)
		if err != nil {
			return err
		}
		rollingUpgradePolicy := rollingUpgradePolicy1
		upgradePolicyStatus.RollingUpgradePolicy = &rollingUpgradePolicy
	}

	// No error
	return nil
}

// AssignPropertiesFromUpgradePolicyStatus populates our UpgradePolicy_Status from the provided source UpgradePolicy_Status
func (upgradePolicyStatus *UpgradePolicy_Status) AssignPropertiesFromUpgradePolicyStatus(source *v1alpha1api20201201storage.UpgradePolicy_Status) error {

	// AutomaticOSUpgradePolicy
	if source.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy AutomaticOSUpgradePolicy_Status
		err := automaticOSUpgradePolicy.AssignPropertiesFromAutomaticOSUpgradePolicyStatus(source.AutomaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "populating AutomaticOSUpgradePolicy from AutomaticOSUpgradePolicy, calling AssignPropertiesFromAutomaticOSUpgradePolicyStatus()")
		}
		upgradePolicyStatus.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		upgradePolicyStatus.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if source.Mode != nil {
		mode := UpgradePolicyStatusMode(*source.Mode)
		upgradePolicyStatus.Mode = &mode
	} else {
		upgradePolicyStatus.Mode = nil
	}

	// RollingUpgradePolicy
	if source.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy RollingUpgradePolicy_Status
		err := rollingUpgradePolicy.AssignPropertiesFromRollingUpgradePolicyStatus(source.RollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "populating RollingUpgradePolicy from RollingUpgradePolicy, calling AssignPropertiesFromRollingUpgradePolicyStatus()")
		}
		upgradePolicyStatus.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		upgradePolicyStatus.RollingUpgradePolicy = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUpgradePolicyStatus populates the provided destination UpgradePolicy_Status from our UpgradePolicy_Status
func (upgradePolicyStatus *UpgradePolicy_Status) AssignPropertiesToUpgradePolicyStatus(destination *v1alpha1api20201201storage.UpgradePolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutomaticOSUpgradePolicy
	if upgradePolicyStatus.AutomaticOSUpgradePolicy != nil {
		var automaticOSUpgradePolicy v1alpha1api20201201storage.AutomaticOSUpgradePolicy_Status
		err := (*upgradePolicyStatus.AutomaticOSUpgradePolicy).AssignPropertiesToAutomaticOSUpgradePolicyStatus(&automaticOSUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "populating AutomaticOSUpgradePolicy from AutomaticOSUpgradePolicy, calling AssignPropertiesToAutomaticOSUpgradePolicyStatus()")
		}
		destination.AutomaticOSUpgradePolicy = &automaticOSUpgradePolicy
	} else {
		destination.AutomaticOSUpgradePolicy = nil
	}

	// Mode
	if upgradePolicyStatus.Mode != nil {
		mode := string(*upgradePolicyStatus.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// RollingUpgradePolicy
	if upgradePolicyStatus.RollingUpgradePolicy != nil {
		var rollingUpgradePolicy v1alpha1api20201201storage.RollingUpgradePolicy_Status
		err := (*upgradePolicyStatus.RollingUpgradePolicy).AssignPropertiesToRollingUpgradePolicyStatus(&rollingUpgradePolicy)
		if err != nil {
			return errors.Wrap(err, "populating RollingUpgradePolicy from RollingUpgradePolicy, calling AssignPropertiesToRollingUpgradePolicyStatus()")
		}
		destination.RollingUpgradePolicy = &rollingUpgradePolicy
	} else {
		destination.RollingUpgradePolicy = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VirtualMachineScaleSetIdentity
type VirtualMachineScaleSetIdentity struct {
	//Type: The type of identity used for the virtual machine scale set. The type
	//'SystemAssigned, UserAssigned' includes both an implicitly created identity and
	//a set of user assigned identities. The type 'None' will remove any identities
	//from the virtual machine scale set.
	Type *VirtualMachineScaleSetIdentityType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetIdentity *VirtualMachineScaleSetIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetIdentity == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetIdentityARM

	// Set property ‘Type’:
	if virtualMachineScaleSetIdentity.Type != nil {
		typeVar := *virtualMachineScaleSetIdentity.Type
		result.Type = &typeVar
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetIdentity *VirtualMachineScaleSetIdentity) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIdentityARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetIdentity *VirtualMachineScaleSetIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIdentityARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIdentityARM, got %T", armInput)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		virtualMachineScaleSetIdentity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIdentity populates our VirtualMachineScaleSetIdentity from the provided source VirtualMachineScaleSetIdentity
func (virtualMachineScaleSetIdentity *VirtualMachineScaleSetIdentity) AssignPropertiesFromVirtualMachineScaleSetIdentity(source *v1alpha1api20201201storage.VirtualMachineScaleSetIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := VirtualMachineScaleSetIdentityType(*source.Type)
		virtualMachineScaleSetIdentity.Type = &typeVar
	} else {
		virtualMachineScaleSetIdentity.Type = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIdentity populates the provided destination VirtualMachineScaleSetIdentity from our VirtualMachineScaleSetIdentity
func (virtualMachineScaleSetIdentity *VirtualMachineScaleSetIdentity) AssignPropertiesToVirtualMachineScaleSetIdentity(destination *v1alpha1api20201201storage.VirtualMachineScaleSetIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if virtualMachineScaleSetIdentity.Type != nil {
		typeVar := string(*virtualMachineScaleSetIdentity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VirtualMachineScaleSetIdentity_Status struct {
	//PrincipalId: The principal id of virtual machine scale set identity. This
	//property will only be provided for a system assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`

	//TenantId: The tenant id associated with the virtual machine scale set. This
	//property will only be provided for a system assigned identity.
	TenantId *string `json:"tenantId,omitempty"`

	//Type: The type of identity used for the virtual machine scale set. The type
	//'SystemAssigned, UserAssigned' includes both an implicitly created identity and
	//a set of user assigned identities. The type 'None' will remove any identities
	//from the virtual machine scale set.
	Type *VirtualMachineScaleSetIdentityStatusType `json:"type,omitempty"`

	//UserAssignedIdentities: The list of user identities associated with the virtual
	//machine scale set. The user identity dictionary key references will be ARM
	//resource ids in the form:
	//'/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIdentity_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetIdentityStatus *VirtualMachineScaleSetIdentity_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIdentity_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetIdentityStatus *VirtualMachineScaleSetIdentity_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIdentity_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIdentity_StatusARM, got %T", armInput)
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		virtualMachineScaleSetIdentityStatus.PrincipalId = &principalId
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		virtualMachineScaleSetIdentityStatus.TenantId = &tenantId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		virtualMachineScaleSetIdentityStatus.Type = &typeVar
	}

	// Set property ‘UserAssignedIdentities’:
	if typedInput.UserAssignedIdentities != nil {
		virtualMachineScaleSetIdentityStatus.UserAssignedIdentities = make(map[string]VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities)
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			virtualMachineScaleSetIdentityStatus.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIdentityStatus populates our VirtualMachineScaleSetIdentity_Status from the provided source VirtualMachineScaleSetIdentity_Status
func (virtualMachineScaleSetIdentityStatus *VirtualMachineScaleSetIdentity_Status) AssignPropertiesFromVirtualMachineScaleSetIdentityStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status) error {

	// PrincipalId
	if source.PrincipalId != nil {
		principalId := *source.PrincipalId
		virtualMachineScaleSetIdentityStatus.PrincipalId = &principalId
	} else {
		virtualMachineScaleSetIdentityStatus.PrincipalId = nil
	}

	// TenantId
	if source.TenantId != nil {
		tenantId := *source.TenantId
		virtualMachineScaleSetIdentityStatus.TenantId = &tenantId
	} else {
		virtualMachineScaleSetIdentityStatus.TenantId = nil
	}

	// Type
	if source.Type != nil {
		typeVar := VirtualMachineScaleSetIdentityStatusType(*source.Type)
		virtualMachineScaleSetIdentityStatus.Type = &typeVar
	} else {
		virtualMachineScaleSetIdentityStatus.Type = nil
	}

	// UserAssignedIdentities
	userAssignedIdentityMap := make(map[string]VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities)
	for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
		// Shadow the loop variable to avoid aliasing
		userAssignedIdentityValue := userAssignedIdentityValue
		var userAssignedIdentity VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities
		err := userAssignedIdentity.AssignPropertiesFromVirtualMachineScaleSetIdentityStatusUserAssignedIdentities(&userAssignedIdentityValue)
		if err != nil {
			return errors.Wrap(err, "populating UserAssignedIdentities from UserAssignedIdentities, calling AssignPropertiesFromVirtualMachineScaleSetIdentityStatusUserAssignedIdentities()")
		}
		userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
	}
	virtualMachineScaleSetIdentityStatus.UserAssignedIdentities = userAssignedIdentityMap

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIdentityStatus populates the provided destination VirtualMachineScaleSetIdentity_Status from our VirtualMachineScaleSetIdentity_Status
func (virtualMachineScaleSetIdentityStatus *VirtualMachineScaleSetIdentity_Status) AssignPropertiesToVirtualMachineScaleSetIdentityStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	if virtualMachineScaleSetIdentityStatus.PrincipalId != nil {
		principalId := *virtualMachineScaleSetIdentityStatus.PrincipalId
		destination.PrincipalId = &principalId
	} else {
		destination.PrincipalId = nil
	}

	// TenantId
	if virtualMachineScaleSetIdentityStatus.TenantId != nil {
		tenantId := *virtualMachineScaleSetIdentityStatus.TenantId
		destination.TenantId = &tenantId
	} else {
		destination.TenantId = nil
	}

	// Type
	if virtualMachineScaleSetIdentityStatus.Type != nil {
		typeVar := string(*virtualMachineScaleSetIdentityStatus.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	userAssignedIdentityMap := make(map[string]v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities)
	for userAssignedIdentityKey, userAssignedIdentityValue := range virtualMachineScaleSetIdentityStatus.UserAssignedIdentities {
		// Shadow the loop variable to avoid aliasing
		userAssignedIdentityValue := userAssignedIdentityValue
		var userAssignedIdentity v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities
		err := userAssignedIdentityValue.AssignPropertiesToVirtualMachineScaleSetIdentityStatusUserAssignedIdentities(&userAssignedIdentity)
		if err != nil {
			return errors.Wrap(err, "populating UserAssignedIdentities from UserAssignedIdentities, calling AssignPropertiesToVirtualMachineScaleSetIdentityStatusUserAssignedIdentities()")
		}
		userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
	}
	destination.UserAssignedIdentities = userAssignedIdentityMap

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VirtualMachineScaleSetVMProfile_Status struct {
	//BillingProfile: Specifies the billing related details of a Azure Spot VMSS.
	//Minimum api-version: 2019-03-01.
	BillingProfile *BillingProfile_Status `json:"billingProfile,omitempty"`

	//DiagnosticsProfile: Specifies the boot diagnostic settings state.
	//Minimum api-version: 2015-06-15.
	DiagnosticsProfile *DiagnosticsProfile_Status `json:"diagnosticsProfile,omitempty"`

	//EvictionPolicy: Specifies the eviction policy for the Azure Spot virtual machine
	//and Azure Spot scale set.
	//For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported
	//and the minimum api-version is 2019-03-01.
	//For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the
	//minimum api-version is 2017-10-30-preview.
	EvictionPolicy *EvictionPolicy_Status `json:"evictionPolicy,omitempty"`

	//ExtensionProfile: Specifies a collection of settings for extensions installed on
	//virtual machines in the scale set.
	ExtensionProfile *VirtualMachineScaleSetExtensionProfile_Status `json:"extensionProfile,omitempty"`

	//LicenseType: Specifies that the image or disk that is being used was licensed
	//on-premises.
	//Possible values for Windows Server operating system are:
	//Windows_Client
	//Windows_Server
	//Possible values for Linux Server operating system are:
	//RHEL_BYOS (for RHEL)
	//SLES_BYOS (for SUSE)
	//For more information, see [Azure Hybrid Use Benefit for Windows
	//Server](https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing)
	//[Azure Hybrid Use Benefit for Linux
	//Server](https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux)
	//Minimum api-version: 2015-06-15
	LicenseType *string `json:"licenseType,omitempty"`

	//NetworkProfile: Specifies properties of the network interfaces of the virtual
	//machines in the scale set.
	NetworkProfile *VirtualMachineScaleSetNetworkProfile_Status `json:"networkProfile,omitempty"`

	//OsProfile: Specifies the operating system settings for the virtual machines in
	//the scale set.
	OsProfile *VirtualMachineScaleSetOSProfile_Status `json:"osProfile,omitempty"`

	//Priority: Specifies the priority for the virtual machines in the scale set.
	//Minimum api-version: 2017-10-30-preview
	Priority *Priority_Status `json:"priority,omitempty"`

	//ScheduledEventsProfile: Specifies Scheduled Event related configurations.
	ScheduledEventsProfile *ScheduledEventsProfile_Status `json:"scheduledEventsProfile,omitempty"`

	//SecurityProfile: Specifies the Security related profile settings for the virtual
	//machines in the scale set.
	SecurityProfile *SecurityProfile_Status `json:"securityProfile,omitempty"`

	//StorageProfile: Specifies the storage settings for the virtual machine disks.
	StorageProfile *VirtualMachineScaleSetStorageProfile_Status `json:"storageProfile,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetVMProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetVMProfileStatus *VirtualMachineScaleSetVMProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetVMProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetVMProfileStatus *VirtualMachineScaleSetVMProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetVMProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetVMProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘BillingProfile’:
	if typedInput.BillingProfile != nil {
		var billingProfile1 BillingProfile_Status
		err := billingProfile1.PopulateFromARM(owner, *typedInput.BillingProfile)
		if err != nil {
			return err
		}
		billingProfile := billingProfile1
		virtualMachineScaleSetVMProfileStatus.BillingProfile = &billingProfile
	}

	// Set property ‘DiagnosticsProfile’:
	if typedInput.DiagnosticsProfile != nil {
		var diagnosticsProfile1 DiagnosticsProfile_Status
		err := diagnosticsProfile1.PopulateFromARM(owner, *typedInput.DiagnosticsProfile)
		if err != nil {
			return err
		}
		diagnosticsProfile := diagnosticsProfile1
		virtualMachineScaleSetVMProfileStatus.DiagnosticsProfile = &diagnosticsProfile
	}

	// Set property ‘EvictionPolicy’:
	if typedInput.EvictionPolicy != nil {
		evictionPolicy := *typedInput.EvictionPolicy
		virtualMachineScaleSetVMProfileStatus.EvictionPolicy = &evictionPolicy
	}

	// Set property ‘ExtensionProfile’:
	if typedInput.ExtensionProfile != nil {
		var extensionProfile1 VirtualMachineScaleSetExtensionProfile_Status
		err := extensionProfile1.PopulateFromARM(owner, *typedInput.ExtensionProfile)
		if err != nil {
			return err
		}
		extensionProfile := extensionProfile1
		virtualMachineScaleSetVMProfileStatus.ExtensionProfile = &extensionProfile
	}

	// Set property ‘LicenseType’:
	if typedInput.LicenseType != nil {
		licenseType := *typedInput.LicenseType
		virtualMachineScaleSetVMProfileStatus.LicenseType = &licenseType
	}

	// Set property ‘NetworkProfile’:
	if typedInput.NetworkProfile != nil {
		var networkProfile1 VirtualMachineScaleSetNetworkProfile_Status
		err := networkProfile1.PopulateFromARM(owner, *typedInput.NetworkProfile)
		if err != nil {
			return err
		}
		networkProfile := networkProfile1
		virtualMachineScaleSetVMProfileStatus.NetworkProfile = &networkProfile
	}

	// Set property ‘OsProfile’:
	if typedInput.OsProfile != nil {
		var osProfile1 VirtualMachineScaleSetOSProfile_Status
		err := osProfile1.PopulateFromARM(owner, *typedInput.OsProfile)
		if err != nil {
			return err
		}
		osProfile := osProfile1
		virtualMachineScaleSetVMProfileStatus.OsProfile = &osProfile
	}

	// Set property ‘Priority’:
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		virtualMachineScaleSetVMProfileStatus.Priority = &priority
	}

	// Set property ‘ScheduledEventsProfile’:
	if typedInput.ScheduledEventsProfile != nil {
		var scheduledEventsProfile1 ScheduledEventsProfile_Status
		err := scheduledEventsProfile1.PopulateFromARM(owner, *typedInput.ScheduledEventsProfile)
		if err != nil {
			return err
		}
		scheduledEventsProfile := scheduledEventsProfile1
		virtualMachineScaleSetVMProfileStatus.ScheduledEventsProfile = &scheduledEventsProfile
	}

	// Set property ‘SecurityProfile’:
	if typedInput.SecurityProfile != nil {
		var securityProfile1 SecurityProfile_Status
		err := securityProfile1.PopulateFromARM(owner, *typedInput.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		virtualMachineScaleSetVMProfileStatus.SecurityProfile = &securityProfile
	}

	// Set property ‘StorageProfile’:
	if typedInput.StorageProfile != nil {
		var storageProfile1 VirtualMachineScaleSetStorageProfile_Status
		err := storageProfile1.PopulateFromARM(owner, *typedInput.StorageProfile)
		if err != nil {
			return err
		}
		storageProfile := storageProfile1
		virtualMachineScaleSetVMProfileStatus.StorageProfile = &storageProfile
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetVMProfileStatus populates our VirtualMachineScaleSetVMProfile_Status from the provided source VirtualMachineScaleSetVMProfile_Status
func (virtualMachineScaleSetVMProfileStatus *VirtualMachineScaleSetVMProfile_Status) AssignPropertiesFromVirtualMachineScaleSetVMProfileStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetVMProfile_Status) error {

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile_Status
		err := billingProfile.AssignPropertiesFromBillingProfileStatus(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "populating BillingProfile from BillingProfile, calling AssignPropertiesFromBillingProfileStatus()")
		}
		virtualMachineScaleSetVMProfileStatus.BillingProfile = &billingProfile
	} else {
		virtualMachineScaleSetVMProfileStatus.BillingProfile = nil
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile_Status
		err := diagnosticsProfile.AssignPropertiesFromDiagnosticsProfileStatus(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "populating DiagnosticsProfile from DiagnosticsProfile, calling AssignPropertiesFromDiagnosticsProfileStatus()")
		}
		virtualMachineScaleSetVMProfileStatus.DiagnosticsProfile = &diagnosticsProfile
	} else {
		virtualMachineScaleSetVMProfileStatus.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := EvictionPolicy_Status(*source.EvictionPolicy)
		virtualMachineScaleSetVMProfileStatus.EvictionPolicy = &evictionPolicy
	} else {
		virtualMachineScaleSetVMProfileStatus.EvictionPolicy = nil
	}

	// ExtensionProfile
	if source.ExtensionProfile != nil {
		var extensionProfile VirtualMachineScaleSetExtensionProfile_Status
		err := extensionProfile.AssignPropertiesFromVirtualMachineScaleSetExtensionProfileStatus(source.ExtensionProfile)
		if err != nil {
			return errors.Wrap(err, "populating ExtensionProfile from ExtensionProfile, calling AssignPropertiesFromVirtualMachineScaleSetExtensionProfileStatus()")
		}
		virtualMachineScaleSetVMProfileStatus.ExtensionProfile = &extensionProfile
	} else {
		virtualMachineScaleSetVMProfileStatus.ExtensionProfile = nil
	}

	// LicenseType
	if source.LicenseType != nil {
		licenseType := *source.LicenseType
		virtualMachineScaleSetVMProfileStatus.LicenseType = &licenseType
	} else {
		virtualMachineScaleSetVMProfileStatus.LicenseType = nil
	}

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile VirtualMachineScaleSetNetworkProfile_Status
		err := networkProfile.AssignPropertiesFromVirtualMachineScaleSetNetworkProfileStatus(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "populating NetworkProfile from NetworkProfile, calling AssignPropertiesFromVirtualMachineScaleSetNetworkProfileStatus()")
		}
		virtualMachineScaleSetVMProfileStatus.NetworkProfile = &networkProfile
	} else {
		virtualMachineScaleSetVMProfileStatus.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile VirtualMachineScaleSetOSProfile_Status
		err := osProfile.AssignPropertiesFromVirtualMachineScaleSetOSProfileStatus(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "populating OsProfile from OsProfile, calling AssignPropertiesFromVirtualMachineScaleSetOSProfileStatus()")
		}
		virtualMachineScaleSetVMProfileStatus.OsProfile = &osProfile
	} else {
		virtualMachineScaleSetVMProfileStatus.OsProfile = nil
	}

	// Priority
	if source.Priority != nil {
		priority := Priority_Status(*source.Priority)
		virtualMachineScaleSetVMProfileStatus.Priority = &priority
	} else {
		virtualMachineScaleSetVMProfileStatus.Priority = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		var scheduledEventsProfile ScheduledEventsProfile_Status
		err := scheduledEventsProfile.AssignPropertiesFromScheduledEventsProfileStatus(source.ScheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "populating ScheduledEventsProfile from ScheduledEventsProfile, calling AssignPropertiesFromScheduledEventsProfileStatus()")
		}
		virtualMachineScaleSetVMProfileStatus.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		virtualMachineScaleSetVMProfileStatus.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile_Status
		err := securityProfile.AssignPropertiesFromSecurityProfileStatus(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "populating SecurityProfile from SecurityProfile, calling AssignPropertiesFromSecurityProfileStatus()")
		}
		virtualMachineScaleSetVMProfileStatus.SecurityProfile = &securityProfile
	} else {
		virtualMachineScaleSetVMProfileStatus.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile VirtualMachineScaleSetStorageProfile_Status
		err := storageProfile.AssignPropertiesFromVirtualMachineScaleSetStorageProfileStatus(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "populating StorageProfile from StorageProfile, calling AssignPropertiesFromVirtualMachineScaleSetStorageProfileStatus()")
		}
		virtualMachineScaleSetVMProfileStatus.StorageProfile = &storageProfile
	} else {
		virtualMachineScaleSetVMProfileStatus.StorageProfile = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetVMProfileStatus populates the provided destination VirtualMachineScaleSetVMProfile_Status from our VirtualMachineScaleSetVMProfile_Status
func (virtualMachineScaleSetVMProfileStatus *VirtualMachineScaleSetVMProfile_Status) AssignPropertiesToVirtualMachineScaleSetVMProfileStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetVMProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BillingProfile
	if virtualMachineScaleSetVMProfileStatus.BillingProfile != nil {
		var billingProfile v1alpha1api20201201storage.BillingProfile_Status
		err := (*virtualMachineScaleSetVMProfileStatus.BillingProfile).AssignPropertiesToBillingProfileStatus(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "populating BillingProfile from BillingProfile, calling AssignPropertiesToBillingProfileStatus()")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// DiagnosticsProfile
	if virtualMachineScaleSetVMProfileStatus.DiagnosticsProfile != nil {
		var diagnosticsProfile v1alpha1api20201201storage.DiagnosticsProfile_Status
		err := (*virtualMachineScaleSetVMProfileStatus.DiagnosticsProfile).AssignPropertiesToDiagnosticsProfileStatus(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "populating DiagnosticsProfile from DiagnosticsProfile, calling AssignPropertiesToDiagnosticsProfileStatus()")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if virtualMachineScaleSetVMProfileStatus.EvictionPolicy != nil {
		evictionPolicy := string(*virtualMachineScaleSetVMProfileStatus.EvictionPolicy)
		destination.EvictionPolicy = &evictionPolicy
	} else {
		destination.EvictionPolicy = nil
	}

	// ExtensionProfile
	if virtualMachineScaleSetVMProfileStatus.ExtensionProfile != nil {
		var extensionProfile v1alpha1api20201201storage.VirtualMachineScaleSetExtensionProfile_Status
		err := (*virtualMachineScaleSetVMProfileStatus.ExtensionProfile).AssignPropertiesToVirtualMachineScaleSetExtensionProfileStatus(&extensionProfile)
		if err != nil {
			return errors.Wrap(err, "populating ExtensionProfile from ExtensionProfile, calling AssignPropertiesToVirtualMachineScaleSetExtensionProfileStatus()")
		}
		destination.ExtensionProfile = &extensionProfile
	} else {
		destination.ExtensionProfile = nil
	}

	// LicenseType
	if virtualMachineScaleSetVMProfileStatus.LicenseType != nil {
		licenseType := *virtualMachineScaleSetVMProfileStatus.LicenseType
		destination.LicenseType = &licenseType
	} else {
		destination.LicenseType = nil
	}

	// NetworkProfile
	if virtualMachineScaleSetVMProfileStatus.NetworkProfile != nil {
		var networkProfile v1alpha1api20201201storage.VirtualMachineScaleSetNetworkProfile_Status
		err := (*virtualMachineScaleSetVMProfileStatus.NetworkProfile).AssignPropertiesToVirtualMachineScaleSetNetworkProfileStatus(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "populating NetworkProfile from NetworkProfile, calling AssignPropertiesToVirtualMachineScaleSetNetworkProfileStatus()")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if virtualMachineScaleSetVMProfileStatus.OsProfile != nil {
		var osProfile v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile_Status
		err := (*virtualMachineScaleSetVMProfileStatus.OsProfile).AssignPropertiesToVirtualMachineScaleSetOSProfileStatus(&osProfile)
		if err != nil {
			return errors.Wrap(err, "populating OsProfile from OsProfile, calling AssignPropertiesToVirtualMachineScaleSetOSProfileStatus()")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Priority
	if virtualMachineScaleSetVMProfileStatus.Priority != nil {
		priority := string(*virtualMachineScaleSetVMProfileStatus.Priority)
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// ScheduledEventsProfile
	if virtualMachineScaleSetVMProfileStatus.ScheduledEventsProfile != nil {
		var scheduledEventsProfile v1alpha1api20201201storage.ScheduledEventsProfile_Status
		err := (*virtualMachineScaleSetVMProfileStatus.ScheduledEventsProfile).AssignPropertiesToScheduledEventsProfileStatus(&scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "populating ScheduledEventsProfile from ScheduledEventsProfile, calling AssignPropertiesToScheduledEventsProfileStatus()")
		}
		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if virtualMachineScaleSetVMProfileStatus.SecurityProfile != nil {
		var securityProfile v1alpha1api20201201storage.SecurityProfile_Status
		err := (*virtualMachineScaleSetVMProfileStatus.SecurityProfile).AssignPropertiesToSecurityProfileStatus(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "populating SecurityProfile from SecurityProfile, calling AssignPropertiesToSecurityProfileStatus()")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if virtualMachineScaleSetVMProfileStatus.StorageProfile != nil {
		var storageProfile v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile_Status
		err := (*virtualMachineScaleSetVMProfileStatus.StorageProfile).AssignPropertiesToVirtualMachineScaleSetStorageProfileStatus(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "populating StorageProfile from StorageProfile, calling AssignPropertiesToVirtualMachineScaleSetStorageProfileStatus()")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Flexible","Uniform"}
type VirtualMachineScaleSetsSpecPropertiesOrchestrationMode string

const (
	VirtualMachineScaleSetsSpecPropertiesOrchestrationModeFlexible = VirtualMachineScaleSetsSpecPropertiesOrchestrationMode("Flexible")
	VirtualMachineScaleSetsSpecPropertiesOrchestrationModeUniform  = VirtualMachineScaleSetsSpecPropertiesOrchestrationMode("Uniform")
)

type VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile struct {
	//BillingProfile: Specifies the billing related details of a Azure Spot VM or VMSS.
	//Minimum api-version: 2019-03-01.
	BillingProfile *BillingProfile `json:"billingProfile,omitempty"`

	//DiagnosticsProfile: Specifies the boot diagnostic settings state.
	//Minimum api-version: 2015-06-15.
	DiagnosticsProfile *DiagnosticsProfile `json:"diagnosticsProfile,omitempty"`

	//EvictionPolicy: Specifies the eviction policy for the Azure Spot virtual machine
	//and Azure Spot scale set.
	//For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported
	//and the minimum api-version is 2019-03-01.
	//For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the
	//minimum api-version is 2017-10-30-preview.
	EvictionPolicy *VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicy `json:"evictionPolicy,omitempty"`

	//ExtensionProfile: Describes a virtual machine scale set extension profile.
	ExtensionProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile `json:"extensionProfile,omitempty"`

	//LicenseType: Specifies that the image or disk that is being used was licensed
	//on-premises.
	//Possible values for Windows Server operating system are:
	//Windows_Client
	//Windows_Server
	//Possible values for Linux Server operating system are:
	//RHEL_BYOS (for RHEL)
	//SLES_BYOS (for SUSE)
	//For more information, see [Azure Hybrid Use Benefit for Windows
	//Server](https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing)
	//[Azure Hybrid Use Benefit for Linux
	//Server](https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux)
	//Minimum api-version: 2015-06-15
	LicenseType *string `json:"licenseType,omitempty"`

	//NetworkProfile: Describes a virtual machine scale set network profile.
	NetworkProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile `json:"networkProfile,omitempty"`

	//OsProfile: Describes a virtual machine scale set OS profile.
	OsProfile *VirtualMachineScaleSetOSProfile `json:"osProfile,omitempty"`

	//Priority: Specifies the priority for the virtual machines in the scale set.
	//Minimum api-version: 2017-10-30-preview.
	Priority               *VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority `json:"priority,omitempty"`
	ScheduledEventsProfile *ScheduledEventsProfile                                             `json:"scheduledEventsProfile,omitempty"`

	//SecurityProfile: Specifies the Security profile settings for the virtual machine
	//or virtual machine scale set.
	SecurityProfile *SecurityProfile `json:"securityProfile,omitempty"`

	//StorageProfile: Describes a virtual machine scale set storage profile.
	StorageProfile *VirtualMachineScaleSetStorageProfile `json:"storageProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfileARM

	// Set property ‘BillingProfile’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.BillingProfile != nil {
		billingProfileARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.BillingProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		billingProfile := billingProfileARM.(BillingProfileARM)
		result.BillingProfile = &billingProfile
	}

	// Set property ‘DiagnosticsProfile’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.DiagnosticsProfile != nil {
		diagnosticsProfileARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.DiagnosticsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diagnosticsProfile := diagnosticsProfileARM.(DiagnosticsProfileARM)
		result.DiagnosticsProfile = &diagnosticsProfile
	}

	// Set property ‘EvictionPolicy’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.EvictionPolicy != nil {
		evictionPolicy := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.EvictionPolicy
		result.EvictionPolicy = &evictionPolicy
	}

	// Set property ‘ExtensionProfile’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.ExtensionProfile != nil {
		extensionProfileARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.ExtensionProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		extensionProfile := extensionProfileARM.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfileARM)
		result.ExtensionProfile = &extensionProfile
	}

	// Set property ‘LicenseType’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.LicenseType != nil {
		licenseType := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.LicenseType
		result.LicenseType = &licenseType
	}

	// Set property ‘NetworkProfile’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.NetworkProfile != nil {
		networkProfileARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.NetworkProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkProfile := networkProfileARM.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfileARM)
		result.NetworkProfile = &networkProfile
	}

	// Set property ‘OsProfile’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.OsProfile != nil {
		osProfileARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.OsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osProfile := osProfileARM.(VirtualMachineScaleSetOSProfileARM)
		result.OsProfile = &osProfile
	}

	// Set property ‘Priority’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.Priority != nil {
		priority := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.Priority
		result.Priority = &priority
	}

	// Set property ‘ScheduledEventsProfile’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.ScheduledEventsProfile != nil {
		scheduledEventsProfileARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.ScheduledEventsProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		scheduledEventsProfile := scheduledEventsProfileARM.(ScheduledEventsProfileARM)
		result.ScheduledEventsProfile = &scheduledEventsProfile
	}

	// Set property ‘SecurityProfile’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.SecurityProfile != nil {
		securityProfileARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.SecurityProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		securityProfile := securityProfileARM.(SecurityProfileARM)
		result.SecurityProfile = &securityProfile
	}

	// Set property ‘StorageProfile’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.StorageProfile != nil {
		storageProfileARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.StorageProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageProfile := storageProfileARM.(VirtualMachineScaleSetStorageProfileARM)
		result.StorageProfile = &storageProfile
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfileARM, got %T", armInput)
	}

	// Set property ‘BillingProfile’:
	if typedInput.BillingProfile != nil {
		var billingProfile1 BillingProfile
		err := billingProfile1.PopulateFromARM(owner, *typedInput.BillingProfile)
		if err != nil {
			return err
		}
		billingProfile := billingProfile1
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.BillingProfile = &billingProfile
	}

	// Set property ‘DiagnosticsProfile’:
	if typedInput.DiagnosticsProfile != nil {
		var diagnosticsProfile1 DiagnosticsProfile
		err := diagnosticsProfile1.PopulateFromARM(owner, *typedInput.DiagnosticsProfile)
		if err != nil {
			return err
		}
		diagnosticsProfile := diagnosticsProfile1
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.DiagnosticsProfile = &diagnosticsProfile
	}

	// Set property ‘EvictionPolicy’:
	if typedInput.EvictionPolicy != nil {
		evictionPolicy := *typedInput.EvictionPolicy
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.EvictionPolicy = &evictionPolicy
	}

	// Set property ‘ExtensionProfile’:
	if typedInput.ExtensionProfile != nil {
		var extensionProfile1 VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile
		err := extensionProfile1.PopulateFromARM(owner, *typedInput.ExtensionProfile)
		if err != nil {
			return err
		}
		extensionProfile := extensionProfile1
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.ExtensionProfile = &extensionProfile
	}

	// Set property ‘LicenseType’:
	if typedInput.LicenseType != nil {
		licenseType := *typedInput.LicenseType
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.LicenseType = &licenseType
	}

	// Set property ‘NetworkProfile’:
	if typedInput.NetworkProfile != nil {
		var networkProfile1 VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile
		err := networkProfile1.PopulateFromARM(owner, *typedInput.NetworkProfile)
		if err != nil {
			return err
		}
		networkProfile := networkProfile1
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.NetworkProfile = &networkProfile
	}

	// Set property ‘OsProfile’:
	if typedInput.OsProfile != nil {
		var osProfile1 VirtualMachineScaleSetOSProfile
		err := osProfile1.PopulateFromARM(owner, *typedInput.OsProfile)
		if err != nil {
			return err
		}
		osProfile := osProfile1
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.OsProfile = &osProfile
	}

	// Set property ‘Priority’:
	if typedInput.Priority != nil {
		priority := *typedInput.Priority
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.Priority = &priority
	}

	// Set property ‘ScheduledEventsProfile’:
	if typedInput.ScheduledEventsProfile != nil {
		var scheduledEventsProfile1 ScheduledEventsProfile
		err := scheduledEventsProfile1.PopulateFromARM(owner, *typedInput.ScheduledEventsProfile)
		if err != nil {
			return err
		}
		scheduledEventsProfile := scheduledEventsProfile1
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.ScheduledEventsProfile = &scheduledEventsProfile
	}

	// Set property ‘SecurityProfile’:
	if typedInput.SecurityProfile != nil {
		var securityProfile1 SecurityProfile
		err := securityProfile1.PopulateFromARM(owner, *typedInput.SecurityProfile)
		if err != nil {
			return err
		}
		securityProfile := securityProfile1
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.SecurityProfile = &securityProfile
	}

	// Set property ‘StorageProfile’:
	if typedInput.StorageProfile != nil {
		var storageProfile1 VirtualMachineScaleSetStorageProfile
		err := storageProfile1.PopulateFromARM(owner, *typedInput.StorageProfile)
		if err != nil {
			return err
		}
		storageProfile := storageProfile1
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.StorageProfile = &storageProfile
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfile populates our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile from the provided source VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile) AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfile(source *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile) error {

	// BillingProfile
	if source.BillingProfile != nil {
		var billingProfile BillingProfile
		err := billingProfile.AssignPropertiesFromBillingProfile(source.BillingProfile)
		if err != nil {
			return errors.Wrap(err, "populating BillingProfile from BillingProfile, calling AssignPropertiesFromBillingProfile()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.BillingProfile = &billingProfile
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.BillingProfile = nil
	}

	// DiagnosticsProfile
	if source.DiagnosticsProfile != nil {
		var diagnosticsProfile DiagnosticsProfile
		err := diagnosticsProfile.AssignPropertiesFromDiagnosticsProfile(source.DiagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "populating DiagnosticsProfile from DiagnosticsProfile, calling AssignPropertiesFromDiagnosticsProfile()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.DiagnosticsProfile = &diagnosticsProfile
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if source.EvictionPolicy != nil {
		evictionPolicy := VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicy(*source.EvictionPolicy)
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.EvictionPolicy = &evictionPolicy
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.EvictionPolicy = nil
	}

	// ExtensionProfile
	if source.ExtensionProfile != nil {
		var extensionProfile VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile
		err := extensionProfile.AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile(source.ExtensionProfile)
		if err != nil {
			return errors.Wrap(err, "populating ExtensionProfile from ExtensionProfile, calling AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.ExtensionProfile = &extensionProfile
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.ExtensionProfile = nil
	}

	// LicenseType
	if source.LicenseType != nil {
		licenseType := *source.LicenseType
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.LicenseType = &licenseType
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.LicenseType = nil
	}

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile
		err := networkProfile.AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "populating NetworkProfile from NetworkProfile, calling AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.NetworkProfile = &networkProfile
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.NetworkProfile = nil
	}

	// OsProfile
	if source.OsProfile != nil {
		var osProfile VirtualMachineScaleSetOSProfile
		err := osProfile.AssignPropertiesFromVirtualMachineScaleSetOSProfile(source.OsProfile)
		if err != nil {
			return errors.Wrap(err, "populating OsProfile from OsProfile, calling AssignPropertiesFromVirtualMachineScaleSetOSProfile()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.OsProfile = &osProfile
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.OsProfile = nil
	}

	// Priority
	if source.Priority != nil {
		priority := VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority(*source.Priority)
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.Priority = &priority
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.Priority = nil
	}

	// ScheduledEventsProfile
	if source.ScheduledEventsProfile != nil {
		var scheduledEventsProfile ScheduledEventsProfile
		err := scheduledEventsProfile.AssignPropertiesFromScheduledEventsProfile(source.ScheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "populating ScheduledEventsProfile from ScheduledEventsProfile, calling AssignPropertiesFromScheduledEventsProfile()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if source.SecurityProfile != nil {
		var securityProfile SecurityProfile
		err := securityProfile.AssignPropertiesFromSecurityProfile(source.SecurityProfile)
		if err != nil {
			return errors.Wrap(err, "populating SecurityProfile from SecurityProfile, calling AssignPropertiesFromSecurityProfile()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.SecurityProfile = &securityProfile
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.SecurityProfile = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile VirtualMachineScaleSetStorageProfile
		err := storageProfile.AssignPropertiesFromVirtualMachineScaleSetStorageProfile(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "populating StorageProfile from StorageProfile, calling AssignPropertiesFromVirtualMachineScaleSetStorageProfile()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.StorageProfile = &storageProfile
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.StorageProfile = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfile populates the provided destination VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile from our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile) AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfile(destination *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BillingProfile
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.BillingProfile != nil {
		var billingProfile v1alpha1api20201201storage.BillingProfile
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.BillingProfile).AssignPropertiesToBillingProfile(&billingProfile)
		if err != nil {
			return errors.Wrap(err, "populating BillingProfile from BillingProfile, calling AssignPropertiesToBillingProfile()")
		}
		destination.BillingProfile = &billingProfile
	} else {
		destination.BillingProfile = nil
	}

	// DiagnosticsProfile
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.DiagnosticsProfile != nil {
		var diagnosticsProfile v1alpha1api20201201storage.DiagnosticsProfile
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.DiagnosticsProfile).AssignPropertiesToDiagnosticsProfile(&diagnosticsProfile)
		if err != nil {
			return errors.Wrap(err, "populating DiagnosticsProfile from DiagnosticsProfile, calling AssignPropertiesToDiagnosticsProfile()")
		}
		destination.DiagnosticsProfile = &diagnosticsProfile
	} else {
		destination.DiagnosticsProfile = nil
	}

	// EvictionPolicy
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.EvictionPolicy != nil {
		evictionPolicy := string(*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.EvictionPolicy)
		destination.EvictionPolicy = &evictionPolicy
	} else {
		destination.EvictionPolicy = nil
	}

	// ExtensionProfile
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.ExtensionProfile != nil {
		var extensionProfile v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.ExtensionProfile).AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile(&extensionProfile)
		if err != nil {
			return errors.Wrap(err, "populating ExtensionProfile from ExtensionProfile, calling AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile()")
		}
		destination.ExtensionProfile = &extensionProfile
	} else {
		destination.ExtensionProfile = nil
	}

	// LicenseType
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.LicenseType != nil {
		licenseType := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.LicenseType
		destination.LicenseType = &licenseType
	} else {
		destination.LicenseType = nil
	}

	// NetworkProfile
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.NetworkProfile != nil {
		var networkProfile v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.NetworkProfile).AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "populating NetworkProfile from NetworkProfile, calling AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile()")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// OsProfile
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.OsProfile != nil {
		var osProfile v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.OsProfile).AssignPropertiesToVirtualMachineScaleSetOSProfile(&osProfile)
		if err != nil {
			return errors.Wrap(err, "populating OsProfile from OsProfile, calling AssignPropertiesToVirtualMachineScaleSetOSProfile()")
		}
		destination.OsProfile = &osProfile
	} else {
		destination.OsProfile = nil
	}

	// Priority
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.Priority != nil {
		priority := string(*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.Priority)
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// ScheduledEventsProfile
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.ScheduledEventsProfile != nil {
		var scheduledEventsProfile v1alpha1api20201201storage.ScheduledEventsProfile
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.ScheduledEventsProfile).AssignPropertiesToScheduledEventsProfile(&scheduledEventsProfile)
		if err != nil {
			return errors.Wrap(err, "populating ScheduledEventsProfile from ScheduledEventsProfile, calling AssignPropertiesToScheduledEventsProfile()")
		}
		destination.ScheduledEventsProfile = &scheduledEventsProfile
	} else {
		destination.ScheduledEventsProfile = nil
	}

	// SecurityProfile
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.SecurityProfile != nil {
		var securityProfile v1alpha1api20201201storage.SecurityProfile
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.SecurityProfile).AssignPropertiesToSecurityProfile(&securityProfile)
		if err != nil {
			return errors.Wrap(err, "populating SecurityProfile from SecurityProfile, calling AssignPropertiesToSecurityProfile()")
		}
		destination.SecurityProfile = &securityProfile
	} else {
		destination.SecurityProfile = nil
	}

	// StorageProfile
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.StorageProfile != nil {
		var storageProfile v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfile.StorageProfile).AssignPropertiesToVirtualMachineScaleSetStorageProfile(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "populating StorageProfile from StorageProfile, calling AssignPropertiesToVirtualMachineScaleSetStorageProfile()")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/AutomaticOSUpgradePolicy
type AutomaticOSUpgradePolicy struct {
	//DisableAutomaticRollback: Whether OS image rollback feature should be disabled.
	//Default value is false.
	DisableAutomaticRollback *bool `json:"disableAutomaticRollback,omitempty"`

	//EnableAutomaticOSUpgrade: Indicates whether OS upgrades should automatically be
	//applied to scale set instances in a rolling fashion when a newer version of the
	//OS image becomes available. Default value is false.
	//If this is set to true for Windows based scale sets,
	//[enableAutomaticUpdates](https://docs.microsoft.com/dotnet/api/microsoft.azure.management.compute.models.windowsconfiguration.enableautomaticupdates?view=azure-dotnet)
	//is automatically set to false and cannot be set to true.
	EnableAutomaticOSUpgrade *bool `json:"enableAutomaticOSUpgrade,omitempty"`
}

var _ genruntime.ARMTransformer = &AutomaticOSUpgradePolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (automaticOSUpgradePolicy *AutomaticOSUpgradePolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if automaticOSUpgradePolicy == nil {
		return nil, nil
	}
	var result AutomaticOSUpgradePolicyARM

	// Set property ‘DisableAutomaticRollback’:
	if automaticOSUpgradePolicy.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *automaticOSUpgradePolicy.DisableAutomaticRollback
		result.DisableAutomaticRollback = &disableAutomaticRollback
	}

	// Set property ‘EnableAutomaticOSUpgrade’:
	if automaticOSUpgradePolicy.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *automaticOSUpgradePolicy.EnableAutomaticOSUpgrade
		result.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (automaticOSUpgradePolicy *AutomaticOSUpgradePolicy) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutomaticOSUpgradePolicyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (automaticOSUpgradePolicy *AutomaticOSUpgradePolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutomaticOSUpgradePolicyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutomaticOSUpgradePolicyARM, got %T", armInput)
	}

	// Set property ‘DisableAutomaticRollback’:
	if typedInput.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *typedInput.DisableAutomaticRollback
		automaticOSUpgradePolicy.DisableAutomaticRollback = &disableAutomaticRollback
	}

	// Set property ‘EnableAutomaticOSUpgrade’:
	if typedInput.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *typedInput.EnableAutomaticOSUpgrade
		automaticOSUpgradePolicy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	}

	// No error
	return nil
}

// AssignPropertiesFromAutomaticOSUpgradePolicy populates our AutomaticOSUpgradePolicy from the provided source AutomaticOSUpgradePolicy
func (automaticOSUpgradePolicy *AutomaticOSUpgradePolicy) AssignPropertiesFromAutomaticOSUpgradePolicy(source *v1alpha1api20201201storage.AutomaticOSUpgradePolicy) error {

	// DisableAutomaticRollback
	if source.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *source.DisableAutomaticRollback
		automaticOSUpgradePolicy.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		automaticOSUpgradePolicy.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if source.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *source.EnableAutomaticOSUpgrade
		automaticOSUpgradePolicy.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		automaticOSUpgradePolicy.EnableAutomaticOSUpgrade = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAutomaticOSUpgradePolicy populates the provided destination AutomaticOSUpgradePolicy from our AutomaticOSUpgradePolicy
func (automaticOSUpgradePolicy *AutomaticOSUpgradePolicy) AssignPropertiesToAutomaticOSUpgradePolicy(destination *v1alpha1api20201201storage.AutomaticOSUpgradePolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisableAutomaticRollback
	if automaticOSUpgradePolicy.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *automaticOSUpgradePolicy.DisableAutomaticRollback
		destination.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		destination.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if automaticOSUpgradePolicy.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *automaticOSUpgradePolicy.EnableAutomaticOSUpgrade
		destination.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		destination.EnableAutomaticOSUpgrade = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type AutomaticOSUpgradePolicy_Status struct {
	//DisableAutomaticRollback: Whether OS image rollback feature should be disabled.
	//Default value is false.
	DisableAutomaticRollback *bool `json:"disableAutomaticRollback,omitempty"`

	//EnableAutomaticOSUpgrade: Indicates whether OS upgrades should automatically be
	//applied to scale set instances in a rolling fashion when a newer version of the
	//OS image becomes available. Default value is false.
	//If this is set to true for Windows based scale sets,
	//[enableAutomaticUpdates](https://docs.microsoft.com/dotnet/api/microsoft.azure.management.compute.models.windowsconfiguration.enableautomaticupdates?view=azure-dotnet)
	//is automatically set to false and cannot be set to true.
	EnableAutomaticOSUpgrade *bool `json:"enableAutomaticOSUpgrade,omitempty"`
}

var _ genruntime.FromARMConverter = &AutomaticOSUpgradePolicy_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (automaticOSUpgradePolicyStatus *AutomaticOSUpgradePolicy_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &AutomaticOSUpgradePolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (automaticOSUpgradePolicyStatus *AutomaticOSUpgradePolicy_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AutomaticOSUpgradePolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AutomaticOSUpgradePolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘DisableAutomaticRollback’:
	if typedInput.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *typedInput.DisableAutomaticRollback
		automaticOSUpgradePolicyStatus.DisableAutomaticRollback = &disableAutomaticRollback
	}

	// Set property ‘EnableAutomaticOSUpgrade’:
	if typedInput.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *typedInput.EnableAutomaticOSUpgrade
		automaticOSUpgradePolicyStatus.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	}

	// No error
	return nil
}

// AssignPropertiesFromAutomaticOSUpgradePolicyStatus populates our AutomaticOSUpgradePolicy_Status from the provided source AutomaticOSUpgradePolicy_Status
func (automaticOSUpgradePolicyStatus *AutomaticOSUpgradePolicy_Status) AssignPropertiesFromAutomaticOSUpgradePolicyStatus(source *v1alpha1api20201201storage.AutomaticOSUpgradePolicy_Status) error {

	// DisableAutomaticRollback
	if source.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *source.DisableAutomaticRollback
		automaticOSUpgradePolicyStatus.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		automaticOSUpgradePolicyStatus.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if source.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *source.EnableAutomaticOSUpgrade
		automaticOSUpgradePolicyStatus.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		automaticOSUpgradePolicyStatus.EnableAutomaticOSUpgrade = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAutomaticOSUpgradePolicyStatus populates the provided destination AutomaticOSUpgradePolicy_Status from our AutomaticOSUpgradePolicy_Status
func (automaticOSUpgradePolicyStatus *AutomaticOSUpgradePolicy_Status) AssignPropertiesToAutomaticOSUpgradePolicyStatus(destination *v1alpha1api20201201storage.AutomaticOSUpgradePolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisableAutomaticRollback
	if automaticOSUpgradePolicyStatus.DisableAutomaticRollback != nil {
		disableAutomaticRollback := *automaticOSUpgradePolicyStatus.DisableAutomaticRollback
		destination.DisableAutomaticRollback = &disableAutomaticRollback
	} else {
		destination.DisableAutomaticRollback = nil
	}

	// EnableAutomaticOSUpgrade
	if automaticOSUpgradePolicyStatus.EnableAutomaticOSUpgrade != nil {
		enableAutomaticOSUpgrade := *automaticOSUpgradePolicyStatus.EnableAutomaticOSUpgrade
		destination.EnableAutomaticOSUpgrade = &enableAutomaticOSUpgrade
	} else {
		destination.EnableAutomaticOSUpgrade = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/BillingProfile
type BillingProfile struct {
	//MaxPrice: Specifies the maximum price you are willing to pay for a Azure Spot
	//VM/VMSS. This price is in US Dollars.
	//This price will be compared with the current Azure Spot price for the VM size.
	//Also, the prices are compared at the time of create/update of Azure Spot VM/VMSS
	//and the operation will only succeed if  the maxPrice is greater than the current
	//Azure Spot price.
	//The maxPrice will also be used for evicting a Azure Spot VM/VMSS if the current
	//Azure Spot price goes beyond the maxPrice after creation of VM/VMSS.
	//Possible values are:
	//- Any decimal value greater than zero. Example: 0.01538
	//-1 – indicates default price to be up-to on-demand.
	//You can set the maxPrice to -1 to indicate that the Azure Spot VM/VMSS should
	//not be evicted for price reasons. Also, the default max price is -1 if it is not
	//provided by you.
	//Minimum api-version: 2019-03-01.
	MaxPrice *float64 `json:"maxPrice,omitempty"`
}

var _ genruntime.ARMTransformer = &BillingProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (billingProfile *BillingProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if billingProfile == nil {
		return nil, nil
	}
	var result BillingProfileARM

	// Set property ‘MaxPrice’:
	if billingProfile.MaxPrice != nil {
		maxPrice := *billingProfile.MaxPrice
		result.MaxPrice = &maxPrice
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (billingProfile *BillingProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &BillingProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (billingProfile *BillingProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BillingProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BillingProfileARM, got %T", armInput)
	}

	// Set property ‘MaxPrice’:
	if typedInput.MaxPrice != nil {
		maxPrice := *typedInput.MaxPrice
		billingProfile.MaxPrice = &maxPrice
	}

	// No error
	return nil
}

// AssignPropertiesFromBillingProfile populates our BillingProfile from the provided source BillingProfile
func (billingProfile *BillingProfile) AssignPropertiesFromBillingProfile(source *v1alpha1api20201201storage.BillingProfile) error {

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		billingProfile.MaxPrice = &maxPrice
	} else {
		billingProfile.MaxPrice = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBillingProfile populates the provided destination BillingProfile from our BillingProfile
func (billingProfile *BillingProfile) AssignPropertiesToBillingProfile(destination *v1alpha1api20201201storage.BillingProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxPrice
	if billingProfile.MaxPrice != nil {
		maxPrice := *billingProfile.MaxPrice
		destination.MaxPrice = &maxPrice
	} else {
		destination.MaxPrice = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type BillingProfile_Status struct {
	//MaxPrice: Specifies the maximum price you are willing to pay for a Azure Spot
	//VM/VMSS. This price is in US Dollars.
	//This price will be compared with the current Azure Spot price for the VM size.
	//Also, the prices are compared at the time of create/update of Azure Spot VM/VMSS
	//and the operation will only succeed if  the maxPrice is greater than the current
	//Azure Spot price.
	//The maxPrice will also be used for evicting a Azure Spot VM/VMSS if the current
	//Azure Spot price goes beyond the maxPrice after creation of VM/VMSS.
	//Possible values are:
	//- Any decimal value greater than zero. Example: 0.01538
	//-1 – indicates default price to be up-to on-demand.
	//You can set the maxPrice to -1 to indicate that the Azure Spot VM/VMSS should
	//not be evicted for price reasons. Also, the default max price is -1 if it is not
	//provided by you.
	//Minimum api-version: 2019-03-01.
	MaxPrice *float64 `json:"maxPrice,omitempty"`
}

var _ genruntime.FromARMConverter = &BillingProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (billingProfileStatus *BillingProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &BillingProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (billingProfileStatus *BillingProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BillingProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BillingProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘MaxPrice’:
	if typedInput.MaxPrice != nil {
		maxPrice := *typedInput.MaxPrice
		billingProfileStatus.MaxPrice = &maxPrice
	}

	// No error
	return nil
}

// AssignPropertiesFromBillingProfileStatus populates our BillingProfile_Status from the provided source BillingProfile_Status
func (billingProfileStatus *BillingProfile_Status) AssignPropertiesFromBillingProfileStatus(source *v1alpha1api20201201storage.BillingProfile_Status) error {

	// MaxPrice
	if source.MaxPrice != nil {
		maxPrice := *source.MaxPrice
		billingProfileStatus.MaxPrice = &maxPrice
	} else {
		billingProfileStatus.MaxPrice = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBillingProfileStatus populates the provided destination BillingProfile_Status from our BillingProfile_Status
func (billingProfileStatus *BillingProfile_Status) AssignPropertiesToBillingProfileStatus(destination *v1alpha1api20201201storage.BillingProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxPrice
	if billingProfileStatus.MaxPrice != nil {
		maxPrice := *billingProfileStatus.MaxPrice
		destination.MaxPrice = &maxPrice
	} else {
		destination.MaxPrice = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/DiagnosticsProfile
type DiagnosticsProfile struct {
	//BootDiagnostics: Boot Diagnostics is a debugging feature which allows you to
	//view Console Output and Screenshot to diagnose VM status.
	//You can easily view the output of your console log.
	//Azure also enables you to see a screenshot of the VM from the hypervisor.
	BootDiagnostics *BootDiagnostics `json:"bootDiagnostics,omitempty"`
}

var _ genruntime.ARMTransformer = &DiagnosticsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (diagnosticsProfile *DiagnosticsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if diagnosticsProfile == nil {
		return nil, nil
	}
	var result DiagnosticsProfileARM

	// Set property ‘BootDiagnostics’:
	if diagnosticsProfile.BootDiagnostics != nil {
		bootDiagnosticsARM, err := (*diagnosticsProfile.BootDiagnostics).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		bootDiagnostics := bootDiagnosticsARM.(BootDiagnosticsARM)
		result.BootDiagnostics = &bootDiagnostics
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diagnosticsProfile *DiagnosticsProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiagnosticsProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diagnosticsProfile *DiagnosticsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiagnosticsProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiagnosticsProfileARM, got %T", armInput)
	}

	// Set property ‘BootDiagnostics’:
	if typedInput.BootDiagnostics != nil {
		var bootDiagnostics1 BootDiagnostics
		err := bootDiagnostics1.PopulateFromARM(owner, *typedInput.BootDiagnostics)
		if err != nil {
			return err
		}
		bootDiagnostics := bootDiagnostics1
		diagnosticsProfile.BootDiagnostics = &bootDiagnostics
	}

	// No error
	return nil
}

// AssignPropertiesFromDiagnosticsProfile populates our DiagnosticsProfile from the provided source DiagnosticsProfile
func (diagnosticsProfile *DiagnosticsProfile) AssignPropertiesFromDiagnosticsProfile(source *v1alpha1api20201201storage.DiagnosticsProfile) error {

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics
		err := bootDiagnostic.AssignPropertiesFromBootDiagnostics(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "populating BootDiagnostics from BootDiagnostics, calling AssignPropertiesFromBootDiagnostics()")
		}
		diagnosticsProfile.BootDiagnostics = &bootDiagnostic
	} else {
		diagnosticsProfile.BootDiagnostics = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiagnosticsProfile populates the provided destination DiagnosticsProfile from our DiagnosticsProfile
func (diagnosticsProfile *DiagnosticsProfile) AssignPropertiesToDiagnosticsProfile(destination *v1alpha1api20201201storage.DiagnosticsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BootDiagnostics
	if diagnosticsProfile.BootDiagnostics != nil {
		var bootDiagnostic v1alpha1api20201201storage.BootDiagnostics
		err := (*diagnosticsProfile.BootDiagnostics).AssignPropertiesToBootDiagnostics(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "populating BootDiagnostics from BootDiagnostics, calling AssignPropertiesToBootDiagnostics()")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type DiagnosticsProfile_Status struct {
	//BootDiagnostics: Boot Diagnostics is a debugging feature which allows you to
	//view Console Output and Screenshot to diagnose VM status.
	//You can easily view the output of your console log.
	//Azure also enables you to see a screenshot of the VM from the hypervisor.
	BootDiagnostics *BootDiagnostics_Status `json:"bootDiagnostics,omitempty"`
}

var _ genruntime.FromARMConverter = &DiagnosticsProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diagnosticsProfileStatus *DiagnosticsProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiagnosticsProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diagnosticsProfileStatus *DiagnosticsProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiagnosticsProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiagnosticsProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘BootDiagnostics’:
	if typedInput.BootDiagnostics != nil {
		var bootDiagnostics1 BootDiagnostics_Status
		err := bootDiagnostics1.PopulateFromARM(owner, *typedInput.BootDiagnostics)
		if err != nil {
			return err
		}
		bootDiagnostics := bootDiagnostics1
		diagnosticsProfileStatus.BootDiagnostics = &bootDiagnostics
	}

	// No error
	return nil
}

// AssignPropertiesFromDiagnosticsProfileStatus populates our DiagnosticsProfile_Status from the provided source DiagnosticsProfile_Status
func (diagnosticsProfileStatus *DiagnosticsProfile_Status) AssignPropertiesFromDiagnosticsProfileStatus(source *v1alpha1api20201201storage.DiagnosticsProfile_Status) error {

	// BootDiagnostics
	if source.BootDiagnostics != nil {
		var bootDiagnostic BootDiagnostics_Status
		err := bootDiagnostic.AssignPropertiesFromBootDiagnosticsStatus(source.BootDiagnostics)
		if err != nil {
			return errors.Wrap(err, "populating BootDiagnostics from BootDiagnostics, calling AssignPropertiesFromBootDiagnosticsStatus()")
		}
		diagnosticsProfileStatus.BootDiagnostics = &bootDiagnostic
	} else {
		diagnosticsProfileStatus.BootDiagnostics = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiagnosticsProfileStatus populates the provided destination DiagnosticsProfile_Status from our DiagnosticsProfile_Status
func (diagnosticsProfileStatus *DiagnosticsProfile_Status) AssignPropertiesToDiagnosticsProfileStatus(destination *v1alpha1api20201201storage.DiagnosticsProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BootDiagnostics
	if diagnosticsProfileStatus.BootDiagnostics != nil {
		var bootDiagnostic v1alpha1api20201201storage.BootDiagnostics_Status
		err := (*diagnosticsProfileStatus.BootDiagnostics).AssignPropertiesToBootDiagnosticsStatus(&bootDiagnostic)
		if err != nil {
			return errors.Wrap(err, "populating BootDiagnostics from BootDiagnostics, calling AssignPropertiesToBootDiagnosticsStatus()")
		}
		destination.BootDiagnostics = &bootDiagnostic
	} else {
		destination.BootDiagnostics = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type EvictionPolicy_Status string

const (
	EvictionPolicy_StatusDeallocate = EvictionPolicy_Status("Deallocate")
	EvictionPolicy_StatusDelete     = EvictionPolicy_Status("Delete")
)

//Generated from:
type Priority_Status string

const (
	Priority_StatusLow     = Priority_Status("Low")
	Priority_StatusRegular = Priority_Status("Regular")
	Priority_StatusSpot    = Priority_Status("Spot")
)

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/RollingUpgradePolicy
type RollingUpgradePolicy struct {
	//EnableCrossZoneUpgrade: Allow VMSS to ignore AZ boundaries when constructing
	//upgrade batches. Take into consideration the Update Domain and
	//maxBatchInstancePercent to determine the batch size.
	EnableCrossZoneUpgrade *bool `json:"enableCrossZoneUpgrade,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=5
	//MaxBatchInstancePercent: The maximum percent of total virtual machine instances
	//that will be upgraded simultaneously by the rolling upgrade in one batch. As
	//this is a maximum, unhealthy instances in previous or future batches can cause
	//the percentage of instances in a batch to decrease to ensure higher reliability.
	//The default value for this parameter is 20%.
	MaxBatchInstancePercent *int `json:"maxBatchInstancePercent,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=5
	//MaxUnhealthyInstancePercent: The maximum percentage of the total virtual machine
	//instances in the scale set that can be simultaneously unhealthy, either as a
	//result of being upgraded, or by being found in an unhealthy state by the virtual
	//machine health checks before the rolling upgrade aborts. This constraint will be
	//checked prior to starting any batch. The default value for this parameter is 20%.
	MaxUnhealthyInstancePercent *int `json:"maxUnhealthyInstancePercent,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=0
	//MaxUnhealthyUpgradedInstancePercent: The maximum percentage of upgraded virtual
	//machine instances that can be found to be in an unhealthy state. This check will
	//happen after each batch is upgraded. If this percentage is ever exceeded, the
	//rolling update aborts. The default value for this parameter is 20%.
	MaxUnhealthyUpgradedInstancePercent *int `json:"maxUnhealthyUpgradedInstancePercent,omitempty"`

	//PauseTimeBetweenBatches: The wait time between completing the update for all
	//virtual machines in one batch and starting the next batch. The time duration
	//should be specified in ISO 8601 format. The default value is 0 seconds (PT0S).
	PauseTimeBetweenBatches *string `json:"pauseTimeBetweenBatches,omitempty"`

	//PrioritizeUnhealthyInstances: Upgrade all unhealthy instances in a scale set
	//before any healthy instances.
	PrioritizeUnhealthyInstances *bool `json:"prioritizeUnhealthyInstances,omitempty"`
}

var _ genruntime.ARMTransformer = &RollingUpgradePolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rollingUpgradePolicy *RollingUpgradePolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rollingUpgradePolicy == nil {
		return nil, nil
	}
	var result RollingUpgradePolicyARM

	// Set property ‘EnableCrossZoneUpgrade’:
	if rollingUpgradePolicy.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *rollingUpgradePolicy.EnableCrossZoneUpgrade
		result.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	}

	// Set property ‘MaxBatchInstancePercent’:
	if rollingUpgradePolicy.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *rollingUpgradePolicy.MaxBatchInstancePercent
		result.MaxBatchInstancePercent = &maxBatchInstancePercent
	}

	// Set property ‘MaxUnhealthyInstancePercent’:
	if rollingUpgradePolicy.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *rollingUpgradePolicy.MaxUnhealthyInstancePercent
		result.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	}

	// Set property ‘MaxUnhealthyUpgradedInstancePercent’:
	if rollingUpgradePolicy.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *rollingUpgradePolicy.MaxUnhealthyUpgradedInstancePercent
		result.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	}

	// Set property ‘PauseTimeBetweenBatches’:
	if rollingUpgradePolicy.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatches := *rollingUpgradePolicy.PauseTimeBetweenBatches
		result.PauseTimeBetweenBatches = &pauseTimeBetweenBatches
	}

	// Set property ‘PrioritizeUnhealthyInstances’:
	if rollingUpgradePolicy.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstances := *rollingUpgradePolicy.PrioritizeUnhealthyInstances
		result.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstances
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rollingUpgradePolicy *RollingUpgradePolicy) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &RollingUpgradePolicyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rollingUpgradePolicy *RollingUpgradePolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RollingUpgradePolicyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RollingUpgradePolicyARM, got %T", armInput)
	}

	// Set property ‘EnableCrossZoneUpgrade’:
	if typedInput.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *typedInput.EnableCrossZoneUpgrade
		rollingUpgradePolicy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	}

	// Set property ‘MaxBatchInstancePercent’:
	if typedInput.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *typedInput.MaxBatchInstancePercent
		rollingUpgradePolicy.MaxBatchInstancePercent = &maxBatchInstancePercent
	}

	// Set property ‘MaxUnhealthyInstancePercent’:
	if typedInput.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *typedInput.MaxUnhealthyInstancePercent
		rollingUpgradePolicy.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	}

	// Set property ‘MaxUnhealthyUpgradedInstancePercent’:
	if typedInput.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *typedInput.MaxUnhealthyUpgradedInstancePercent
		rollingUpgradePolicy.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	}

	// Set property ‘PauseTimeBetweenBatches’:
	if typedInput.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatches := *typedInput.PauseTimeBetweenBatches
		rollingUpgradePolicy.PauseTimeBetweenBatches = &pauseTimeBetweenBatches
	}

	// Set property ‘PrioritizeUnhealthyInstances’:
	if typedInput.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstances := *typedInput.PrioritizeUnhealthyInstances
		rollingUpgradePolicy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstances
	}

	// No error
	return nil
}

// AssignPropertiesFromRollingUpgradePolicy populates our RollingUpgradePolicy from the provided source RollingUpgradePolicy
func (rollingUpgradePolicy *RollingUpgradePolicy) AssignPropertiesFromRollingUpgradePolicy(source *v1alpha1api20201201storage.RollingUpgradePolicy) error {

	// EnableCrossZoneUpgrade
	if source.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *source.EnableCrossZoneUpgrade
		rollingUpgradePolicy.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		rollingUpgradePolicy.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	if source.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *source.MaxBatchInstancePercent
		rollingUpgradePolicy.MaxBatchInstancePercent = &maxBatchInstancePercent
	} else {
		rollingUpgradePolicy.MaxBatchInstancePercent = nil
	}

	// MaxUnhealthyInstancePercent
	if source.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *source.MaxUnhealthyInstancePercent
		rollingUpgradePolicy.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	} else {
		rollingUpgradePolicy.MaxUnhealthyInstancePercent = nil
	}

	// MaxUnhealthyUpgradedInstancePercent
	if source.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *source.MaxUnhealthyUpgradedInstancePercent
		rollingUpgradePolicy.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	} else {
		rollingUpgradePolicy.MaxUnhealthyUpgradedInstancePercent = nil
	}

	// PauseTimeBetweenBatches
	if source.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatch := *source.PauseTimeBetweenBatches
		rollingUpgradePolicy.PauseTimeBetweenBatches = &pauseTimeBetweenBatch
	} else {
		rollingUpgradePolicy.PauseTimeBetweenBatches = nil
	}

	// PrioritizeUnhealthyInstances
	if source.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *source.PrioritizeUnhealthyInstances
		rollingUpgradePolicy.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		rollingUpgradePolicy.PrioritizeUnhealthyInstances = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRollingUpgradePolicy populates the provided destination RollingUpgradePolicy from our RollingUpgradePolicy
func (rollingUpgradePolicy *RollingUpgradePolicy) AssignPropertiesToRollingUpgradePolicy(destination *v1alpha1api20201201storage.RollingUpgradePolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableCrossZoneUpgrade
	if rollingUpgradePolicy.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *rollingUpgradePolicy.EnableCrossZoneUpgrade
		destination.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		destination.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	if rollingUpgradePolicy.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *rollingUpgradePolicy.MaxBatchInstancePercent
		destination.MaxBatchInstancePercent = &maxBatchInstancePercent
	} else {
		destination.MaxBatchInstancePercent = nil
	}

	// MaxUnhealthyInstancePercent
	if rollingUpgradePolicy.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *rollingUpgradePolicy.MaxUnhealthyInstancePercent
		destination.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	} else {
		destination.MaxUnhealthyInstancePercent = nil
	}

	// MaxUnhealthyUpgradedInstancePercent
	if rollingUpgradePolicy.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *rollingUpgradePolicy.MaxUnhealthyUpgradedInstancePercent
		destination.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	} else {
		destination.MaxUnhealthyUpgradedInstancePercent = nil
	}

	// PauseTimeBetweenBatches
	if rollingUpgradePolicy.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatch := *rollingUpgradePolicy.PauseTimeBetweenBatches
		destination.PauseTimeBetweenBatches = &pauseTimeBetweenBatch
	} else {
		destination.PauseTimeBetweenBatches = nil
	}

	// PrioritizeUnhealthyInstances
	if rollingUpgradePolicy.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *rollingUpgradePolicy.PrioritizeUnhealthyInstances
		destination.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		destination.PrioritizeUnhealthyInstances = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type RollingUpgradePolicy_Status struct {
	//EnableCrossZoneUpgrade: Allow VMSS to ignore AZ boundaries when constructing
	//upgrade batches. Take into consideration the Update Domain and
	//maxBatchInstancePercent to determine the batch size.
	EnableCrossZoneUpgrade *bool `json:"enableCrossZoneUpgrade,omitempty"`

	//MaxBatchInstancePercent: The maximum percent of total virtual machine instances
	//that will be upgraded simultaneously by the rolling upgrade in one batch. As
	//this is a maximum, unhealthy instances in previous or future batches can cause
	//the percentage of instances in a batch to decrease to ensure higher reliability.
	//The default value for this parameter is 20%.
	MaxBatchInstancePercent *int `json:"maxBatchInstancePercent,omitempty"`

	//MaxUnhealthyInstancePercent: The maximum percentage of the total virtual machine
	//instances in the scale set that can be simultaneously unhealthy, either as a
	//result of being upgraded, or by being found in an unhealthy state by the virtual
	//machine health checks before the rolling upgrade aborts. This constraint will be
	//checked prior to starting any batch. The default value for this parameter is 20%.
	MaxUnhealthyInstancePercent *int `json:"maxUnhealthyInstancePercent,omitempty"`

	//MaxUnhealthyUpgradedInstancePercent: The maximum percentage of upgraded virtual
	//machine instances that can be found to be in an unhealthy state. This check will
	//happen after each batch is upgraded. If this percentage is ever exceeded, the
	//rolling update aborts. The default value for this parameter is 20%.
	MaxUnhealthyUpgradedInstancePercent *int `json:"maxUnhealthyUpgradedInstancePercent,omitempty"`

	//PauseTimeBetweenBatches: The wait time between completing the update for all
	//virtual machines in one batch and starting the next batch. The time duration
	//should be specified in ISO 8601 format. The default value is 0 seconds (PT0S).
	PauseTimeBetweenBatches *string `json:"pauseTimeBetweenBatches,omitempty"`

	//PrioritizeUnhealthyInstances: Upgrade all unhealthy instances in a scale set
	//before any healthy instances.
	PrioritizeUnhealthyInstances *bool `json:"prioritizeUnhealthyInstances,omitempty"`
}

var _ genruntime.FromARMConverter = &RollingUpgradePolicy_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rollingUpgradePolicyStatus *RollingUpgradePolicy_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &RollingUpgradePolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rollingUpgradePolicyStatus *RollingUpgradePolicy_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RollingUpgradePolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RollingUpgradePolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘EnableCrossZoneUpgrade’:
	if typedInput.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *typedInput.EnableCrossZoneUpgrade
		rollingUpgradePolicyStatus.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	}

	// Set property ‘MaxBatchInstancePercent’:
	if typedInput.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *typedInput.MaxBatchInstancePercent
		rollingUpgradePolicyStatus.MaxBatchInstancePercent = &maxBatchInstancePercent
	}

	// Set property ‘MaxUnhealthyInstancePercent’:
	if typedInput.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *typedInput.MaxUnhealthyInstancePercent
		rollingUpgradePolicyStatus.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	}

	// Set property ‘MaxUnhealthyUpgradedInstancePercent’:
	if typedInput.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *typedInput.MaxUnhealthyUpgradedInstancePercent
		rollingUpgradePolicyStatus.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	}

	// Set property ‘PauseTimeBetweenBatches’:
	if typedInput.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatches := *typedInput.PauseTimeBetweenBatches
		rollingUpgradePolicyStatus.PauseTimeBetweenBatches = &pauseTimeBetweenBatches
	}

	// Set property ‘PrioritizeUnhealthyInstances’:
	if typedInput.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstances := *typedInput.PrioritizeUnhealthyInstances
		rollingUpgradePolicyStatus.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstances
	}

	// No error
	return nil
}

// AssignPropertiesFromRollingUpgradePolicyStatus populates our RollingUpgradePolicy_Status from the provided source RollingUpgradePolicy_Status
func (rollingUpgradePolicyStatus *RollingUpgradePolicy_Status) AssignPropertiesFromRollingUpgradePolicyStatus(source *v1alpha1api20201201storage.RollingUpgradePolicy_Status) error {

	// EnableCrossZoneUpgrade
	if source.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *source.EnableCrossZoneUpgrade
		rollingUpgradePolicyStatus.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		rollingUpgradePolicyStatus.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	if source.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *source.MaxBatchInstancePercent
		rollingUpgradePolicyStatus.MaxBatchInstancePercent = &maxBatchInstancePercent
	} else {
		rollingUpgradePolicyStatus.MaxBatchInstancePercent = nil
	}

	// MaxUnhealthyInstancePercent
	if source.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *source.MaxUnhealthyInstancePercent
		rollingUpgradePolicyStatus.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	} else {
		rollingUpgradePolicyStatus.MaxUnhealthyInstancePercent = nil
	}

	// MaxUnhealthyUpgradedInstancePercent
	if source.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *source.MaxUnhealthyUpgradedInstancePercent
		rollingUpgradePolicyStatus.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	} else {
		rollingUpgradePolicyStatus.MaxUnhealthyUpgradedInstancePercent = nil
	}

	// PauseTimeBetweenBatches
	if source.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatch := *source.PauseTimeBetweenBatches
		rollingUpgradePolicyStatus.PauseTimeBetweenBatches = &pauseTimeBetweenBatch
	} else {
		rollingUpgradePolicyStatus.PauseTimeBetweenBatches = nil
	}

	// PrioritizeUnhealthyInstances
	if source.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *source.PrioritizeUnhealthyInstances
		rollingUpgradePolicyStatus.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		rollingUpgradePolicyStatus.PrioritizeUnhealthyInstances = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRollingUpgradePolicyStatus populates the provided destination RollingUpgradePolicy_Status from our RollingUpgradePolicy_Status
func (rollingUpgradePolicyStatus *RollingUpgradePolicy_Status) AssignPropertiesToRollingUpgradePolicyStatus(destination *v1alpha1api20201201storage.RollingUpgradePolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableCrossZoneUpgrade
	if rollingUpgradePolicyStatus.EnableCrossZoneUpgrade != nil {
		enableCrossZoneUpgrade := *rollingUpgradePolicyStatus.EnableCrossZoneUpgrade
		destination.EnableCrossZoneUpgrade = &enableCrossZoneUpgrade
	} else {
		destination.EnableCrossZoneUpgrade = nil
	}

	// MaxBatchInstancePercent
	if rollingUpgradePolicyStatus.MaxBatchInstancePercent != nil {
		maxBatchInstancePercent := *rollingUpgradePolicyStatus.MaxBatchInstancePercent
		destination.MaxBatchInstancePercent = &maxBatchInstancePercent
	} else {
		destination.MaxBatchInstancePercent = nil
	}

	// MaxUnhealthyInstancePercent
	if rollingUpgradePolicyStatus.MaxUnhealthyInstancePercent != nil {
		maxUnhealthyInstancePercent := *rollingUpgradePolicyStatus.MaxUnhealthyInstancePercent
		destination.MaxUnhealthyInstancePercent = &maxUnhealthyInstancePercent
	} else {
		destination.MaxUnhealthyInstancePercent = nil
	}

	// MaxUnhealthyUpgradedInstancePercent
	if rollingUpgradePolicyStatus.MaxUnhealthyUpgradedInstancePercent != nil {
		maxUnhealthyUpgradedInstancePercent := *rollingUpgradePolicyStatus.MaxUnhealthyUpgradedInstancePercent
		destination.MaxUnhealthyUpgradedInstancePercent = &maxUnhealthyUpgradedInstancePercent
	} else {
		destination.MaxUnhealthyUpgradedInstancePercent = nil
	}

	// PauseTimeBetweenBatches
	if rollingUpgradePolicyStatus.PauseTimeBetweenBatches != nil {
		pauseTimeBetweenBatch := *rollingUpgradePolicyStatus.PauseTimeBetweenBatches
		destination.PauseTimeBetweenBatches = &pauseTimeBetweenBatch
	} else {
		destination.PauseTimeBetweenBatches = nil
	}

	// PrioritizeUnhealthyInstances
	if rollingUpgradePolicyStatus.PrioritizeUnhealthyInstances != nil {
		prioritizeUnhealthyInstance := *rollingUpgradePolicyStatus.PrioritizeUnhealthyInstances
		destination.PrioritizeUnhealthyInstances = &prioritizeUnhealthyInstance
	} else {
		destination.PrioritizeUnhealthyInstances = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Default","NewestVM","OldestVM"}
type ScaleInPolicyRules string

const (
	ScaleInPolicyRulesDefault  = ScaleInPolicyRules("Default")
	ScaleInPolicyRulesNewestVM = ScaleInPolicyRules("NewestVM")
	ScaleInPolicyRulesOldestVM = ScaleInPolicyRules("OldestVM")
)

type ScaleInPolicyStatusRules string

const (
	ScaleInPolicyStatusRulesDefault  = ScaleInPolicyStatusRules("Default")
	ScaleInPolicyStatusRulesNewestVM = ScaleInPolicyStatusRules("NewestVM")
	ScaleInPolicyStatusRulesOldestVM = ScaleInPolicyStatusRules("OldestVM")
)

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/ScheduledEventsProfile
type ScheduledEventsProfile struct {
	TerminateNotificationProfile *TerminateNotificationProfile `json:"terminateNotificationProfile,omitempty"`
}

var _ genruntime.ARMTransformer = &ScheduledEventsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (scheduledEventsProfile *ScheduledEventsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if scheduledEventsProfile == nil {
		return nil, nil
	}
	var result ScheduledEventsProfileARM

	// Set property ‘TerminateNotificationProfile’:
	if scheduledEventsProfile.TerminateNotificationProfile != nil {
		terminateNotificationProfileARM, err := (*scheduledEventsProfile.TerminateNotificationProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		terminateNotificationProfile := terminateNotificationProfileARM.(TerminateNotificationProfileARM)
		result.TerminateNotificationProfile = &terminateNotificationProfile
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scheduledEventsProfile *ScheduledEventsProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScheduledEventsProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scheduledEventsProfile *ScheduledEventsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScheduledEventsProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScheduledEventsProfileARM, got %T", armInput)
	}

	// Set property ‘TerminateNotificationProfile’:
	if typedInput.TerminateNotificationProfile != nil {
		var terminateNotificationProfile1 TerminateNotificationProfile
		err := terminateNotificationProfile1.PopulateFromARM(owner, *typedInput.TerminateNotificationProfile)
		if err != nil {
			return err
		}
		terminateNotificationProfile := terminateNotificationProfile1
		scheduledEventsProfile.TerminateNotificationProfile = &terminateNotificationProfile
	}

	// No error
	return nil
}

// AssignPropertiesFromScheduledEventsProfile populates our ScheduledEventsProfile from the provided source ScheduledEventsProfile
func (scheduledEventsProfile *ScheduledEventsProfile) AssignPropertiesFromScheduledEventsProfile(source *v1alpha1api20201201storage.ScheduledEventsProfile) error {

	// TerminateNotificationProfile
	if source.TerminateNotificationProfile != nil {
		var terminateNotificationProfile TerminateNotificationProfile
		err := terminateNotificationProfile.AssignPropertiesFromTerminateNotificationProfile(source.TerminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "populating TerminateNotificationProfile from TerminateNotificationProfile, calling AssignPropertiesFromTerminateNotificationProfile()")
		}
		scheduledEventsProfile.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		scheduledEventsProfile.TerminateNotificationProfile = nil
	}

	// No error
	return nil
}

// AssignPropertiesToScheduledEventsProfile populates the provided destination ScheduledEventsProfile from our ScheduledEventsProfile
func (scheduledEventsProfile *ScheduledEventsProfile) AssignPropertiesToScheduledEventsProfile(destination *v1alpha1api20201201storage.ScheduledEventsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TerminateNotificationProfile
	if scheduledEventsProfile.TerminateNotificationProfile != nil {
		var terminateNotificationProfile v1alpha1api20201201storage.TerminateNotificationProfile
		err := (*scheduledEventsProfile.TerminateNotificationProfile).AssignPropertiesToTerminateNotificationProfile(&terminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "populating TerminateNotificationProfile from TerminateNotificationProfile, calling AssignPropertiesToTerminateNotificationProfile()")
		}
		destination.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		destination.TerminateNotificationProfile = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ScheduledEventsProfile_Status struct {
	//TerminateNotificationProfile: Specifies Terminate Scheduled Event related
	//configurations.
	TerminateNotificationProfile *TerminateNotificationProfile_Status `json:"terminateNotificationProfile,omitempty"`
}

var _ genruntime.FromARMConverter = &ScheduledEventsProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scheduledEventsProfileStatus *ScheduledEventsProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ScheduledEventsProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scheduledEventsProfileStatus *ScheduledEventsProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ScheduledEventsProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ScheduledEventsProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘TerminateNotificationProfile’:
	if typedInput.TerminateNotificationProfile != nil {
		var terminateNotificationProfile1 TerminateNotificationProfile_Status
		err := terminateNotificationProfile1.PopulateFromARM(owner, *typedInput.TerminateNotificationProfile)
		if err != nil {
			return err
		}
		terminateNotificationProfile := terminateNotificationProfile1
		scheduledEventsProfileStatus.TerminateNotificationProfile = &terminateNotificationProfile
	}

	// No error
	return nil
}

// AssignPropertiesFromScheduledEventsProfileStatus populates our ScheduledEventsProfile_Status from the provided source ScheduledEventsProfile_Status
func (scheduledEventsProfileStatus *ScheduledEventsProfile_Status) AssignPropertiesFromScheduledEventsProfileStatus(source *v1alpha1api20201201storage.ScheduledEventsProfile_Status) error {

	// TerminateNotificationProfile
	if source.TerminateNotificationProfile != nil {
		var terminateNotificationProfile TerminateNotificationProfile_Status
		err := terminateNotificationProfile.AssignPropertiesFromTerminateNotificationProfileStatus(source.TerminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "populating TerminateNotificationProfile from TerminateNotificationProfile, calling AssignPropertiesFromTerminateNotificationProfileStatus()")
		}
		scheduledEventsProfileStatus.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		scheduledEventsProfileStatus.TerminateNotificationProfile = nil
	}

	// No error
	return nil
}

// AssignPropertiesToScheduledEventsProfileStatus populates the provided destination ScheduledEventsProfile_Status from our ScheduledEventsProfile_Status
func (scheduledEventsProfileStatus *ScheduledEventsProfile_Status) AssignPropertiesToScheduledEventsProfileStatus(destination *v1alpha1api20201201storage.ScheduledEventsProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// TerminateNotificationProfile
	if scheduledEventsProfileStatus.TerminateNotificationProfile != nil {
		var terminateNotificationProfile v1alpha1api20201201storage.TerminateNotificationProfile_Status
		err := (*scheduledEventsProfileStatus.TerminateNotificationProfile).AssignPropertiesToTerminateNotificationProfileStatus(&terminateNotificationProfile)
		if err != nil {
			return errors.Wrap(err, "populating TerminateNotificationProfile from TerminateNotificationProfile, calling AssignPropertiesToTerminateNotificationProfileStatus()")
		}
		destination.TerminateNotificationProfile = &terminateNotificationProfile
	} else {
		destination.TerminateNotificationProfile = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/SecurityProfile
type SecurityProfile struct {
	//EncryptionAtHost: This property can be used by user in the request to enable or
	//disable the Host Encryption for the virtual machine or virtual machine scale
	//set. This will enable the encryption for all the disks including Resource/Temp
	//disk at host itself.
	//Default: The Encryption at host will be disabled unless this property is set to
	//true for the resource.
	EncryptionAtHost *bool `json:"encryptionAtHost,omitempty"`

	//SecurityType: Specifies the SecurityType of the virtual machine. It is set as
	//TrustedLaunch to enable UefiSettings.
	//Default: UefiSettings will not be enabled unless this property is set as
	//TrustedLaunch.
	SecurityType *SecurityProfileSecurityType `json:"securityType,omitempty"`

	//UefiSettings: Specifies the security settings like secure boot and vTPM used
	//while creating the virtual machine.
	//Minimum api-version: 2020-12-01
	UefiSettings *UefiSettings `json:"uefiSettings,omitempty"`
}

var _ genruntime.ARMTransformer = &SecurityProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (securityProfile *SecurityProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if securityProfile == nil {
		return nil, nil
	}
	var result SecurityProfileARM

	// Set property ‘EncryptionAtHost’:
	if securityProfile.EncryptionAtHost != nil {
		encryptionAtHost := *securityProfile.EncryptionAtHost
		result.EncryptionAtHost = &encryptionAtHost
	}

	// Set property ‘SecurityType’:
	if securityProfile.SecurityType != nil {
		securityType := *securityProfile.SecurityType
		result.SecurityType = &securityType
	}

	// Set property ‘UefiSettings’:
	if securityProfile.UefiSettings != nil {
		uefiSettingsARM, err := (*securityProfile.UefiSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		uefiSettings := uefiSettingsARM.(UefiSettingsARM)
		result.UefiSettings = &uefiSettings
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (securityProfile *SecurityProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &SecurityProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (securityProfile *SecurityProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SecurityProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SecurityProfileARM, got %T", armInput)
	}

	// Set property ‘EncryptionAtHost’:
	if typedInput.EncryptionAtHost != nil {
		encryptionAtHost := *typedInput.EncryptionAtHost
		securityProfile.EncryptionAtHost = &encryptionAtHost
	}

	// Set property ‘SecurityType’:
	if typedInput.SecurityType != nil {
		securityType := *typedInput.SecurityType
		securityProfile.SecurityType = &securityType
	}

	// Set property ‘UefiSettings’:
	if typedInput.UefiSettings != nil {
		var uefiSettings1 UefiSettings
		err := uefiSettings1.PopulateFromARM(owner, *typedInput.UefiSettings)
		if err != nil {
			return err
		}
		uefiSettings := uefiSettings1
		securityProfile.UefiSettings = &uefiSettings
	}

	// No error
	return nil
}

// AssignPropertiesFromSecurityProfile populates our SecurityProfile from the provided source SecurityProfile
func (securityProfile *SecurityProfile) AssignPropertiesFromSecurityProfile(source *v1alpha1api20201201storage.SecurityProfile) error {

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		securityProfile.EncryptionAtHost = &encryptionAtHost
	} else {
		securityProfile.EncryptionAtHost = nil
	}

	// SecurityType
	if source.SecurityType != nil {
		securityType := SecurityProfileSecurityType(*source.SecurityType)
		securityProfile.SecurityType = &securityType
	} else {
		securityProfile.SecurityType = nil
	}

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings
		err := uefiSetting.AssignPropertiesFromUefiSettings(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "populating UefiSettings from UefiSettings, calling AssignPropertiesFromUefiSettings()")
		}
		securityProfile.UefiSettings = &uefiSetting
	} else {
		securityProfile.UefiSettings = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSecurityProfile populates the provided destination SecurityProfile from our SecurityProfile
func (securityProfile *SecurityProfile) AssignPropertiesToSecurityProfile(destination *v1alpha1api20201201storage.SecurityProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionAtHost
	if securityProfile.EncryptionAtHost != nil {
		encryptionAtHost := *securityProfile.EncryptionAtHost
		destination.EncryptionAtHost = &encryptionAtHost
	} else {
		destination.EncryptionAtHost = nil
	}

	// SecurityType
	if securityProfile.SecurityType != nil {
		securityType := string(*securityProfile.SecurityType)
		destination.SecurityType = &securityType
	} else {
		destination.SecurityType = nil
	}

	// UefiSettings
	if securityProfile.UefiSettings != nil {
		var uefiSetting v1alpha1api20201201storage.UefiSettings
		err := (*securityProfile.UefiSettings).AssignPropertiesToUefiSettings(&uefiSetting)
		if err != nil {
			return errors.Wrap(err, "populating UefiSettings from UefiSettings, calling AssignPropertiesToUefiSettings()")
		}
		destination.UefiSettings = &uefiSetting
	} else {
		destination.UefiSettings = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type SecurityProfile_Status struct {
	//EncryptionAtHost: This property can be used by user in the request to enable or
	//disable the Host Encryption for the virtual machine or virtual machine scale
	//set. This will enable the encryption for all the disks including Resource/Temp
	//disk at host itself.
	//Default: The Encryption at host will be disabled unless this property is set to
	//true for the resource.
	EncryptionAtHost *bool `json:"encryptionAtHost,omitempty"`

	//SecurityType: Specifies the SecurityType of the virtual machine. It is set as
	//TrustedLaunch to enable UefiSettings.
	//Default: UefiSettings will not be enabled unless this property is set as
	//TrustedLaunch.
	SecurityType *SecurityProfileStatusSecurityType `json:"securityType,omitempty"`

	//UefiSettings: Specifies the security settings like secure boot and vTPM used
	//while creating the virtual machine.
	//Minimum api-version: 2020-12-01
	UefiSettings *UefiSettings_Status `json:"uefiSettings,omitempty"`
}

var _ genruntime.FromARMConverter = &SecurityProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (securityProfileStatus *SecurityProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &SecurityProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (securityProfileStatus *SecurityProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SecurityProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SecurityProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘EncryptionAtHost’:
	if typedInput.EncryptionAtHost != nil {
		encryptionAtHost := *typedInput.EncryptionAtHost
		securityProfileStatus.EncryptionAtHost = &encryptionAtHost
	}

	// Set property ‘SecurityType’:
	if typedInput.SecurityType != nil {
		securityType := *typedInput.SecurityType
		securityProfileStatus.SecurityType = &securityType
	}

	// Set property ‘UefiSettings’:
	if typedInput.UefiSettings != nil {
		var uefiSettings1 UefiSettings_Status
		err := uefiSettings1.PopulateFromARM(owner, *typedInput.UefiSettings)
		if err != nil {
			return err
		}
		uefiSettings := uefiSettings1
		securityProfileStatus.UefiSettings = &uefiSettings
	}

	// No error
	return nil
}

// AssignPropertiesFromSecurityProfileStatus populates our SecurityProfile_Status from the provided source SecurityProfile_Status
func (securityProfileStatus *SecurityProfile_Status) AssignPropertiesFromSecurityProfileStatus(source *v1alpha1api20201201storage.SecurityProfile_Status) error {

	// EncryptionAtHost
	if source.EncryptionAtHost != nil {
		encryptionAtHost := *source.EncryptionAtHost
		securityProfileStatus.EncryptionAtHost = &encryptionAtHost
	} else {
		securityProfileStatus.EncryptionAtHost = nil
	}

	// SecurityType
	if source.SecurityType != nil {
		securityType := SecurityProfileStatusSecurityType(*source.SecurityType)
		securityProfileStatus.SecurityType = &securityType
	} else {
		securityProfileStatus.SecurityType = nil
	}

	// UefiSettings
	if source.UefiSettings != nil {
		var uefiSetting UefiSettings_Status
		err := uefiSetting.AssignPropertiesFromUefiSettingsStatus(source.UefiSettings)
		if err != nil {
			return errors.Wrap(err, "populating UefiSettings from UefiSettings, calling AssignPropertiesFromUefiSettingsStatus()")
		}
		securityProfileStatus.UefiSettings = &uefiSetting
	} else {
		securityProfileStatus.UefiSettings = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSecurityProfileStatus populates the provided destination SecurityProfile_Status from our SecurityProfile_Status
func (securityProfileStatus *SecurityProfile_Status) AssignPropertiesToSecurityProfileStatus(destination *v1alpha1api20201201storage.SecurityProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionAtHost
	if securityProfileStatus.EncryptionAtHost != nil {
		encryptionAtHost := *securityProfileStatus.EncryptionAtHost
		destination.EncryptionAtHost = &encryptionAtHost
	} else {
		destination.EncryptionAtHost = nil
	}

	// SecurityType
	if securityProfileStatus.SecurityType != nil {
		securityType := string(*securityProfileStatus.SecurityType)
		destination.SecurityType = &securityType
	} else {
		destination.SecurityType = nil
	}

	// UefiSettings
	if securityProfileStatus.UefiSettings != nil {
		var uefiSetting v1alpha1api20201201storage.UefiSettings_Status
		err := (*securityProfileStatus.UefiSettings).AssignPropertiesToUefiSettingsStatus(&uefiSetting)
		if err != nil {
			return errors.Wrap(err, "populating UefiSettings from UefiSettings, calling AssignPropertiesToUefiSettingsStatus()")
		}
		destination.UefiSettings = &uefiSetting
	} else {
		destination.UefiSettings = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Automatic","Manual","Rolling"}
type UpgradePolicyMode string

const (
	UpgradePolicyModeAutomatic = UpgradePolicyMode("Automatic")
	UpgradePolicyModeManual    = UpgradePolicyMode("Manual")
	UpgradePolicyModeRolling   = UpgradePolicyMode("Rolling")
)

type UpgradePolicyStatusMode string

const (
	UpgradePolicyStatusModeAutomatic = UpgradePolicyStatusMode("Automatic")
	UpgradePolicyStatusModeManual    = UpgradePolicyStatusMode("Manual")
	UpgradePolicyStatusModeRolling   = UpgradePolicyStatusMode("Rolling")
)

//Generated from:
type VirtualMachineScaleSetExtensionProfile_Status struct {
	//Extensions: The virtual machine scale set child extension resources.
	Extensions []VirtualMachineScaleSetExtension_Status `json:"extensions,omitempty"`

	//ExtensionsTimeBudget: Specifies the time alloted for all extensions to start.
	//The time duration should be between 15 minutes and 120 minutes (inclusive) and
	//should be specified in ISO 8601 format. The default value is 90 minutes
	//(PT1H30M).
	//Minimum api-version: 2020-06-01
	ExtensionsTimeBudget *string `json:"extensionsTimeBudget,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetExtensionProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetExtensionProfileStatus *VirtualMachineScaleSetExtensionProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetExtensionProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetExtensionProfileStatus *VirtualMachineScaleSetExtensionProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetExtensionProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetExtensionProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘Extensions’:
	for _, item := range typedInput.Extensions {
		var item1 VirtualMachineScaleSetExtension_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineScaleSetExtensionProfileStatus.Extensions = append(virtualMachineScaleSetExtensionProfileStatus.Extensions, item1)
	}

	// Set property ‘ExtensionsTimeBudget’:
	if typedInput.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *typedInput.ExtensionsTimeBudget
		virtualMachineScaleSetExtensionProfileStatus.ExtensionsTimeBudget = &extensionsTimeBudget
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetExtensionProfileStatus populates our VirtualMachineScaleSetExtensionProfile_Status from the provided source VirtualMachineScaleSetExtensionProfile_Status
func (virtualMachineScaleSetExtensionProfileStatus *VirtualMachineScaleSetExtensionProfile_Status) AssignPropertiesFromVirtualMachineScaleSetExtensionProfileStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetExtensionProfile_Status) error {

	// Extensions
	extensionList := make([]VirtualMachineScaleSetExtension_Status, len(source.Extensions))
	for extensionIndex, extensionItem := range source.Extensions {
		// Shadow the loop variable to avoid aliasing
		extensionItem := extensionItem
		var extension VirtualMachineScaleSetExtension_Status
		err := extension.AssignPropertiesFromVirtualMachineScaleSetExtensionStatus(&extensionItem)
		if err != nil {
			return errors.Wrap(err, "populating Extensions from Extensions, calling AssignPropertiesFromVirtualMachineScaleSetExtensionStatus()")
		}
		extensionList[extensionIndex] = extension
	}
	virtualMachineScaleSetExtensionProfileStatus.Extensions = extensionList

	// ExtensionsTimeBudget
	if source.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *source.ExtensionsTimeBudget
		virtualMachineScaleSetExtensionProfileStatus.ExtensionsTimeBudget = &extensionsTimeBudget
	} else {
		virtualMachineScaleSetExtensionProfileStatus.ExtensionsTimeBudget = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetExtensionProfileStatus populates the provided destination VirtualMachineScaleSetExtensionProfile_Status from our VirtualMachineScaleSetExtensionProfile_Status
func (virtualMachineScaleSetExtensionProfileStatus *VirtualMachineScaleSetExtensionProfile_Status) AssignPropertiesToVirtualMachineScaleSetExtensionProfileStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetExtensionProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Extensions
	extensionList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetExtension_Status, len(virtualMachineScaleSetExtensionProfileStatus.Extensions))
	for extensionIndex, extensionItem := range virtualMachineScaleSetExtensionProfileStatus.Extensions {
		// Shadow the loop variable to avoid aliasing
		extensionItem := extensionItem
		var extension v1alpha1api20201201storage.VirtualMachineScaleSetExtension_Status
		err := extensionItem.AssignPropertiesToVirtualMachineScaleSetExtensionStatus(&extension)
		if err != nil {
			return errors.Wrap(err, "populating Extensions from Extensions, calling AssignPropertiesToVirtualMachineScaleSetExtensionStatus()")
		}
		extensionList[extensionIndex] = extension
	}
	destination.Extensions = extensionList

	// ExtensionsTimeBudget
	if virtualMachineScaleSetExtensionProfileStatus.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *virtualMachineScaleSetExtensionProfileStatus.ExtensionsTimeBudget
		destination.ExtensionsTimeBudget = &extensionsTimeBudget
	} else {
		destination.ExtensionsTimeBudget = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities struct {
	//ClientId: The client id of user assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	//PrincipalId: The principal id of user assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetIdentityStatusUserAssignedIdentities *VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIdentity_Status_UserAssignedIdentitiesARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetIdentityStatusUserAssignedIdentities *VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIdentity_Status_UserAssignedIdentitiesARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIdentity_Status_UserAssignedIdentitiesARM, got %T", armInput)
	}

	// Set property ‘ClientId’:
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		virtualMachineScaleSetIdentityStatusUserAssignedIdentities.ClientId = &clientId
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		virtualMachineScaleSetIdentityStatusUserAssignedIdentities.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIdentityStatusUserAssignedIdentities populates our VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities from the provided source VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities
func (virtualMachineScaleSetIdentityStatusUserAssignedIdentities *VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities) AssignPropertiesFromVirtualMachineScaleSetIdentityStatusUserAssignedIdentities(source *v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities) error {

	// ClientId
	if source.ClientId != nil {
		clientId := *source.ClientId
		virtualMachineScaleSetIdentityStatusUserAssignedIdentities.ClientId = &clientId
	} else {
		virtualMachineScaleSetIdentityStatusUserAssignedIdentities.ClientId = nil
	}

	// PrincipalId
	if source.PrincipalId != nil {
		principalId := *source.PrincipalId
		virtualMachineScaleSetIdentityStatusUserAssignedIdentities.PrincipalId = &principalId
	} else {
		virtualMachineScaleSetIdentityStatusUserAssignedIdentities.PrincipalId = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIdentityStatusUserAssignedIdentities populates the provided destination VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities from our VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities
func (virtualMachineScaleSetIdentityStatusUserAssignedIdentities *VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities) AssignPropertiesToVirtualMachineScaleSetIdentityStatusUserAssignedIdentities(destination *v1alpha1api20201201storage.VirtualMachineScaleSetIdentity_Status_UserAssignedIdentities) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	if virtualMachineScaleSetIdentityStatusUserAssignedIdentities.ClientId != nil {
		clientId := *virtualMachineScaleSetIdentityStatusUserAssignedIdentities.ClientId
		destination.ClientId = &clientId
	} else {
		destination.ClientId = nil
	}

	// PrincipalId
	if virtualMachineScaleSetIdentityStatusUserAssignedIdentities.PrincipalId != nil {
		principalId := *virtualMachineScaleSetIdentityStatusUserAssignedIdentities.PrincipalId
		destination.PrincipalId = &principalId
	} else {
		destination.PrincipalId = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VirtualMachineScaleSetNetworkProfile_Status struct {
	//HealthProbe: A reference to a load balancer probe used to determine the health
	//of an instance in the virtual machine scale set. The reference will be in the
	//form:
	//'/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/probes/{probeName}'.
	HealthProbe *ApiEntityReference_Status `json:"healthProbe,omitempty"`

	//NetworkInterfaceConfigurations: The list of network configurations.
	NetworkInterfaceConfigurations []VirtualMachineScaleSetNetworkConfiguration_Status `json:"networkInterfaceConfigurations,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetNetworkProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetNetworkProfileStatus *VirtualMachineScaleSetNetworkProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetNetworkProfileStatus *VirtualMachineScaleSetNetworkProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘HealthProbe’:
	if typedInput.HealthProbe != nil {
		var healthProbe1 ApiEntityReference_Status
		err := healthProbe1.PopulateFromARM(owner, *typedInput.HealthProbe)
		if err != nil {
			return err
		}
		healthProbe := healthProbe1
		virtualMachineScaleSetNetworkProfileStatus.HealthProbe = &healthProbe
	}

	// Set property ‘NetworkInterfaceConfigurations’:
	for _, item := range typedInput.NetworkInterfaceConfigurations {
		var item1 VirtualMachineScaleSetNetworkConfiguration_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineScaleSetNetworkProfileStatus.NetworkInterfaceConfigurations = append(virtualMachineScaleSetNetworkProfileStatus.NetworkInterfaceConfigurations, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetNetworkProfileStatus populates our VirtualMachineScaleSetNetworkProfile_Status from the provided source VirtualMachineScaleSetNetworkProfile_Status
func (virtualMachineScaleSetNetworkProfileStatus *VirtualMachineScaleSetNetworkProfile_Status) AssignPropertiesFromVirtualMachineScaleSetNetworkProfileStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkProfile_Status) error {

	// HealthProbe
	if source.HealthProbe != nil {
		var healthProbe ApiEntityReference_Status
		err := healthProbe.AssignPropertiesFromApiEntityReferenceStatus(source.HealthProbe)
		if err != nil {
			return errors.Wrap(err, "populating HealthProbe from HealthProbe, calling AssignPropertiesFromApiEntityReferenceStatus()")
		}
		virtualMachineScaleSetNetworkProfileStatus.HealthProbe = &healthProbe
	} else {
		virtualMachineScaleSetNetworkProfileStatus.HealthProbe = nil
	}

	// NetworkInterfaceConfigurations
	networkInterfaceConfigurationList := make([]VirtualMachineScaleSetNetworkConfiguration_Status, len(source.NetworkInterfaceConfigurations))
	for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
		// Shadow the loop variable to avoid aliasing
		networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
		var networkInterfaceConfiguration VirtualMachineScaleSetNetworkConfiguration_Status
		err := networkInterfaceConfiguration.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationStatus(&networkInterfaceConfigurationItem)
		if err != nil {
			return errors.Wrap(err, "populating NetworkInterfaceConfigurations from NetworkInterfaceConfigurations, calling AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationStatus()")
		}
		networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
	}
	virtualMachineScaleSetNetworkProfileStatus.NetworkInterfaceConfigurations = networkInterfaceConfigurationList

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetNetworkProfileStatus populates the provided destination VirtualMachineScaleSetNetworkProfile_Status from our VirtualMachineScaleSetNetworkProfile_Status
func (virtualMachineScaleSetNetworkProfileStatus *VirtualMachineScaleSetNetworkProfile_Status) AssignPropertiesToVirtualMachineScaleSetNetworkProfileStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HealthProbe
	if virtualMachineScaleSetNetworkProfileStatus.HealthProbe != nil {
		var healthProbe v1alpha1api20201201storage.ApiEntityReference_Status
		err := (*virtualMachineScaleSetNetworkProfileStatus.HealthProbe).AssignPropertiesToApiEntityReferenceStatus(&healthProbe)
		if err != nil {
			return errors.Wrap(err, "populating HealthProbe from HealthProbe, calling AssignPropertiesToApiEntityReferenceStatus()")
		}
		destination.HealthProbe = &healthProbe
	} else {
		destination.HealthProbe = nil
	}

	// NetworkInterfaceConfigurations
	networkInterfaceConfigurationList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Status, len(virtualMachineScaleSetNetworkProfileStatus.NetworkInterfaceConfigurations))
	for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range virtualMachineScaleSetNetworkProfileStatus.NetworkInterfaceConfigurations {
		// Shadow the loop variable to avoid aliasing
		networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
		var networkInterfaceConfiguration v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Status
		err := networkInterfaceConfigurationItem.AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationStatus(&networkInterfaceConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating NetworkInterfaceConfigurations from NetworkInterfaceConfigurations, calling AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationStatus()")
		}
		networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
	}
	destination.NetworkInterfaceConfigurations = networkInterfaceConfigurationList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VirtualMachineScaleSetOSProfile
type VirtualMachineScaleSetOSProfile struct {
	//AdminPassword: Specifies the password of the administrator account.
	//Minimum-length (Windows): 8 characters
	//Minimum-length (Linux): 6 characters
	//Max-length (Windows): 123 characters
	//Max-length (Linux): 72 characters
	//Complexity requirements: 3 out of 4 conditions below need to be fulfilled
	//Has lower characters
	//Has upper characters
	//Has a digit
	//Has a special character (Regex match [\W_])
	//Disallowed values: "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word",
	//"pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
	//For resetting the password, see [How to reset the Remote Desktop service or its
	//login password in a Windows
	//VM](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-reset-rdp?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json)
	//For resetting root password, see [Manage users, SSH, and check or repair disks
	//on Azure Linux VMs using the VMAccess
	//Extension](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-vmaccess-extension?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#reset-root-password)
	AdminPassword *string `json:"adminPassword,omitempty"`

	//AdminUsername: Specifies the name of the administrator account.
	//Windows-only restriction: Cannot end in "."
	//Disallowed values: "administrator", "admin", "user", "user1", "test", "user2",
	//"test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2",
	//"aspnet", "backup", "console", "david", "guest", "john", "owner", "root",
	//"server", "sql", "support", "support_388945a0", "sys", "test2", "test3",
	//"user4", "user5".
	//Minimum-length (Linux): 1  character
	//Max-length (Linux): 64 characters
	//Max-length (Windows): 20 characters
	//<li> For root access to the Linux VM, see [Using root privileges on Linux
	//virtual machines in
	//Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-use-root-privileges?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	//<li> For a list of built-in system users on Linux that should not be used in
	//this field, see [Selecting User Names for Linux on
	//Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-usernames?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	AdminUsername *string `json:"adminUsername,omitempty"`

	//ComputerNamePrefix: Specifies the computer name prefix for all of the virtual
	//machines in the scale set. Computer name prefixes must be 1 to 15 characters
	//long.
	ComputerNamePrefix *string `json:"computerNamePrefix,omitempty"`

	//CustomData: Specifies a base-64 encoded string of custom data. The base-64
	//encoded string is decoded to a binary array that is saved as a file on the
	//Virtual Machine. The maximum length of the binary array is 65535 bytes.
	//For using cloud-init for your VM, see [Using cloud-init to customize a Linux VM
	//during
	//creation](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-cloud-init?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	CustomData *string `json:"customData,omitempty"`

	//LinuxConfiguration: Specifies the Linux operating system settings on the virtual
	//machine.
	//For a list of supported Linux distributions, see [Linux on Azure-Endorsed
	//Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	//For running non-endorsed distributions, see [Information for Non-Endorsed
	//Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
	LinuxConfiguration *LinuxConfiguration `json:"linuxConfiguration,omitempty"`

	//Secrets: Specifies set of certificates that should be installed onto the virtual
	//machines in the scale set.
	Secrets []VaultSecretGroup `json:"secrets,omitempty"`

	//WindowsConfiguration: Specifies Windows operating system settings on the virtual
	//machine.
	WindowsConfiguration *WindowsConfiguration `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetOSProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetOSProfile *VirtualMachineScaleSetOSProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetOSProfile == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetOSProfileARM

	// Set property ‘AdminPassword’:
	if virtualMachineScaleSetOSProfile.AdminPassword != nil {
		adminPassword := *virtualMachineScaleSetOSProfile.AdminPassword
		result.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	if virtualMachineScaleSetOSProfile.AdminUsername != nil {
		adminUsername := *virtualMachineScaleSetOSProfile.AdminUsername
		result.AdminUsername = &adminUsername
	}

	// Set property ‘ComputerNamePrefix’:
	if virtualMachineScaleSetOSProfile.ComputerNamePrefix != nil {
		computerNamePrefix := *virtualMachineScaleSetOSProfile.ComputerNamePrefix
		result.ComputerNamePrefix = &computerNamePrefix
	}

	// Set property ‘CustomData’:
	if virtualMachineScaleSetOSProfile.CustomData != nil {
		customData := *virtualMachineScaleSetOSProfile.CustomData
		result.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if virtualMachineScaleSetOSProfile.LinuxConfiguration != nil {
		linuxConfigurationARM, err := (*virtualMachineScaleSetOSProfile.LinuxConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		linuxConfiguration := linuxConfigurationARM.(LinuxConfigurationARM)
		result.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘Secrets’:
	for _, item := range virtualMachineScaleSetOSProfile.Secrets {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Secrets = append(result.Secrets, itemARM.(VaultSecretGroupARM))
	}

	// Set property ‘WindowsConfiguration’:
	if virtualMachineScaleSetOSProfile.WindowsConfiguration != nil {
		windowsConfigurationARM, err := (*virtualMachineScaleSetOSProfile.WindowsConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		windowsConfiguration := windowsConfigurationARM.(WindowsConfigurationARM)
		result.WindowsConfiguration = &windowsConfiguration
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetOSProfile *VirtualMachineScaleSetOSProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetOSProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetOSProfile *VirtualMachineScaleSetOSProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetOSProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetOSProfileARM, got %T", armInput)
	}

	// Set property ‘AdminPassword’:
	if typedInput.AdminPassword != nil {
		adminPassword := *typedInput.AdminPassword
		virtualMachineScaleSetOSProfile.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		virtualMachineScaleSetOSProfile.AdminUsername = &adminUsername
	}

	// Set property ‘ComputerNamePrefix’:
	if typedInput.ComputerNamePrefix != nil {
		computerNamePrefix := *typedInput.ComputerNamePrefix
		virtualMachineScaleSetOSProfile.ComputerNamePrefix = &computerNamePrefix
	}

	// Set property ‘CustomData’:
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		virtualMachineScaleSetOSProfile.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		virtualMachineScaleSetOSProfile.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘Secrets’:
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineScaleSetOSProfile.Secrets = append(virtualMachineScaleSetOSProfile.Secrets, item1)
	}

	// Set property ‘WindowsConfiguration’:
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		virtualMachineScaleSetOSProfile.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetOSProfile populates our VirtualMachineScaleSetOSProfile from the provided source VirtualMachineScaleSetOSProfile
func (virtualMachineScaleSetOSProfile *VirtualMachineScaleSetOSProfile) AssignPropertiesFromVirtualMachineScaleSetOSProfile(source *v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile) error {

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := *source.AdminPassword
		virtualMachineScaleSetOSProfile.AdminPassword = &adminPassword
	} else {
		virtualMachineScaleSetOSProfile.AdminPassword = nil
	}

	// AdminUsername
	if source.AdminUsername != nil {
		adminUsername := *source.AdminUsername
		virtualMachineScaleSetOSProfile.AdminUsername = &adminUsername
	} else {
		virtualMachineScaleSetOSProfile.AdminUsername = nil
	}

	// ComputerNamePrefix
	if source.ComputerNamePrefix != nil {
		computerNamePrefix := *source.ComputerNamePrefix
		virtualMachineScaleSetOSProfile.ComputerNamePrefix = &computerNamePrefix
	} else {
		virtualMachineScaleSetOSProfile.ComputerNamePrefix = nil
	}

	// CustomData
	if source.CustomData != nil {
		customDatum := *source.CustomData
		virtualMachineScaleSetOSProfile.CustomData = &customDatum
	} else {
		virtualMachineScaleSetOSProfile.CustomData = nil
	}

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration
		err := linuxConfiguration.AssignPropertiesFromLinuxConfiguration(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating LinuxConfiguration from LinuxConfiguration, calling AssignPropertiesFromLinuxConfiguration()")
		}
		virtualMachineScaleSetOSProfile.LinuxConfiguration = &linuxConfiguration
	} else {
		virtualMachineScaleSetOSProfile.LinuxConfiguration = nil
	}

	// Secrets
	secretList := make([]VaultSecretGroup, len(source.Secrets))
	for secretIndex, secretItem := range source.Secrets {
		// Shadow the loop variable to avoid aliasing
		secretItem := secretItem
		var secret VaultSecretGroup
		err := secret.AssignPropertiesFromVaultSecretGroup(&secretItem)
		if err != nil {
			return errors.Wrap(err, "populating Secrets from Secrets, calling AssignPropertiesFromVaultSecretGroup()")
		}
		secretList[secretIndex] = secret
	}
	virtualMachineScaleSetOSProfile.Secrets = secretList

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration
		err := windowsConfiguration.AssignPropertiesFromWindowsConfiguration(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating WindowsConfiguration from WindowsConfiguration, calling AssignPropertiesFromWindowsConfiguration()")
		}
		virtualMachineScaleSetOSProfile.WindowsConfiguration = &windowsConfiguration
	} else {
		virtualMachineScaleSetOSProfile.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetOSProfile populates the provided destination VirtualMachineScaleSetOSProfile from our VirtualMachineScaleSetOSProfile
func (virtualMachineScaleSetOSProfile *VirtualMachineScaleSetOSProfile) AssignPropertiesToVirtualMachineScaleSetOSProfile(destination *v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	if virtualMachineScaleSetOSProfile.AdminPassword != nil {
		adminPassword := *virtualMachineScaleSetOSProfile.AdminPassword
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	if virtualMachineScaleSetOSProfile.AdminUsername != nil {
		adminUsername := *virtualMachineScaleSetOSProfile.AdminUsername
		destination.AdminUsername = &adminUsername
	} else {
		destination.AdminUsername = nil
	}

	// ComputerNamePrefix
	if virtualMachineScaleSetOSProfile.ComputerNamePrefix != nil {
		computerNamePrefix := *virtualMachineScaleSetOSProfile.ComputerNamePrefix
		destination.ComputerNamePrefix = &computerNamePrefix
	} else {
		destination.ComputerNamePrefix = nil
	}

	// CustomData
	if virtualMachineScaleSetOSProfile.CustomData != nil {
		customDatum := *virtualMachineScaleSetOSProfile.CustomData
		destination.CustomData = &customDatum
	} else {
		destination.CustomData = nil
	}

	// LinuxConfiguration
	if virtualMachineScaleSetOSProfile.LinuxConfiguration != nil {
		var linuxConfiguration v1alpha1api20201201storage.LinuxConfiguration
		err := (*virtualMachineScaleSetOSProfile.LinuxConfiguration).AssignPropertiesToLinuxConfiguration(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating LinuxConfiguration from LinuxConfiguration, calling AssignPropertiesToLinuxConfiguration()")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// Secrets
	secretList := make([]v1alpha1api20201201storage.VaultSecretGroup, len(virtualMachineScaleSetOSProfile.Secrets))
	for secretIndex, secretItem := range virtualMachineScaleSetOSProfile.Secrets {
		// Shadow the loop variable to avoid aliasing
		secretItem := secretItem
		var secret v1alpha1api20201201storage.VaultSecretGroup
		err := secretItem.AssignPropertiesToVaultSecretGroup(&secret)
		if err != nil {
			return errors.Wrap(err, "populating Secrets from Secrets, calling AssignPropertiesToVaultSecretGroup()")
		}
		secretList[secretIndex] = secret
	}
	destination.Secrets = secretList

	// WindowsConfiguration
	if virtualMachineScaleSetOSProfile.WindowsConfiguration != nil {
		var windowsConfiguration v1alpha1api20201201storage.WindowsConfiguration
		err := (*virtualMachineScaleSetOSProfile.WindowsConfiguration).AssignPropertiesToWindowsConfiguration(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating WindowsConfiguration from WindowsConfiguration, calling AssignPropertiesToWindowsConfiguration()")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VirtualMachineScaleSetOSProfile_Status struct {
	//AdminPassword: Specifies the password of the administrator account.
	//Minimum-length (Windows): 8 characters
	//Minimum-length (Linux): 6 characters
	//Max-length (Windows): 123 characters
	//Max-length (Linux): 72 characters
	//Complexity requirements: 3 out of 4 conditions below need to be fulfilled
	//Has lower characters
	//Has upper characters
	//Has a digit
	//Has a special character (Regex match [\W_])
	//Disallowed values: "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word",
	//"pass@word1", "Password!", "Password1", "Password22", "iloveyou!"
	//For resetting the password, see [How to reset the Remote Desktop service or its
	//login password in a Windows
	//VM](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-reset-rdp?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json)
	//For resetting root password, see [Manage users, SSH, and check or repair disks
	//on Azure Linux VMs using the VMAccess
	//Extension](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-vmaccess-extension?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#reset-root-password)
	AdminPassword *string `json:"adminPassword,omitempty"`

	//AdminUsername: Specifies the name of the administrator account.
	//Windows-only restriction: Cannot end in "."
	//Disallowed values: "administrator", "admin", "user", "user1", "test", "user2",
	//"test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2",
	//"aspnet", "backup", "console", "david", "guest", "john", "owner", "root",
	//"server", "sql", "support", "support_388945a0", "sys", "test2", "test3",
	//"user4", "user5".
	//Minimum-length (Linux): 1  character
	//Max-length (Linux): 64 characters
	//Max-length (Windows): 20 characters
	//<li> For root access to the Linux VM, see [Using root privileges on Linux
	//virtual machines in
	//Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-use-root-privileges?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	//<li> For a list of built-in system users on Linux that should not be used in
	//this field, see [Selecting User Names for Linux on
	//Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-usernames?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	AdminUsername *string `json:"adminUsername,omitempty"`

	//ComputerNamePrefix: Specifies the computer name prefix for all of the virtual
	//machines in the scale set. Computer name prefixes must be 1 to 15 characters
	//long.
	ComputerNamePrefix *string `json:"computerNamePrefix,omitempty"`

	//CustomData: Specifies a base-64 encoded string of custom data. The base-64
	//encoded string is decoded to a binary array that is saved as a file on the
	//Virtual Machine. The maximum length of the binary array is 65535 bytes.
	//For using cloud-init for your VM, see [Using cloud-init to customize a Linux VM
	//during
	//creation](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-cloud-init?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	CustomData *string `json:"customData,omitempty"`

	//LinuxConfiguration: Specifies the Linux operating system settings on the virtual
	//machine.
	//For a list of supported Linux distributions, see [Linux on Azure-Endorsed
	//Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
	//For running non-endorsed distributions, see [Information for Non-Endorsed
	//Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
	LinuxConfiguration *LinuxConfiguration_Status `json:"linuxConfiguration,omitempty"`

	//Secrets: Specifies set of certificates that should be installed onto the virtual
	//machines in the scale set.
	Secrets []VaultSecretGroup_Status `json:"secrets,omitempty"`

	//WindowsConfiguration: Specifies Windows operating system settings on the virtual
	//machine.
	WindowsConfiguration *WindowsConfiguration_Status `json:"windowsConfiguration,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetOSProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetOSProfileStatus *VirtualMachineScaleSetOSProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetOSProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetOSProfileStatus *VirtualMachineScaleSetOSProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetOSProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetOSProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘AdminPassword’:
	if typedInput.AdminPassword != nil {
		adminPassword := *typedInput.AdminPassword
		virtualMachineScaleSetOSProfileStatus.AdminPassword = &adminPassword
	}

	// Set property ‘AdminUsername’:
	if typedInput.AdminUsername != nil {
		adminUsername := *typedInput.AdminUsername
		virtualMachineScaleSetOSProfileStatus.AdminUsername = &adminUsername
	}

	// Set property ‘ComputerNamePrefix’:
	if typedInput.ComputerNamePrefix != nil {
		computerNamePrefix := *typedInput.ComputerNamePrefix
		virtualMachineScaleSetOSProfileStatus.ComputerNamePrefix = &computerNamePrefix
	}

	// Set property ‘CustomData’:
	if typedInput.CustomData != nil {
		customData := *typedInput.CustomData
		virtualMachineScaleSetOSProfileStatus.CustomData = &customData
	}

	// Set property ‘LinuxConfiguration’:
	if typedInput.LinuxConfiguration != nil {
		var linuxConfiguration1 LinuxConfiguration_Status
		err := linuxConfiguration1.PopulateFromARM(owner, *typedInput.LinuxConfiguration)
		if err != nil {
			return err
		}
		linuxConfiguration := linuxConfiguration1
		virtualMachineScaleSetOSProfileStatus.LinuxConfiguration = &linuxConfiguration
	}

	// Set property ‘Secrets’:
	for _, item := range typedInput.Secrets {
		var item1 VaultSecretGroup_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineScaleSetOSProfileStatus.Secrets = append(virtualMachineScaleSetOSProfileStatus.Secrets, item1)
	}

	// Set property ‘WindowsConfiguration’:
	if typedInput.WindowsConfiguration != nil {
		var windowsConfiguration1 WindowsConfiguration_Status
		err := windowsConfiguration1.PopulateFromARM(owner, *typedInput.WindowsConfiguration)
		if err != nil {
			return err
		}
		windowsConfiguration := windowsConfiguration1
		virtualMachineScaleSetOSProfileStatus.WindowsConfiguration = &windowsConfiguration
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetOSProfileStatus populates our VirtualMachineScaleSetOSProfile_Status from the provided source VirtualMachineScaleSetOSProfile_Status
func (virtualMachineScaleSetOSProfileStatus *VirtualMachineScaleSetOSProfile_Status) AssignPropertiesFromVirtualMachineScaleSetOSProfileStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile_Status) error {

	// AdminPassword
	if source.AdminPassword != nil {
		adminPassword := *source.AdminPassword
		virtualMachineScaleSetOSProfileStatus.AdminPassword = &adminPassword
	} else {
		virtualMachineScaleSetOSProfileStatus.AdminPassword = nil
	}

	// AdminUsername
	if source.AdminUsername != nil {
		adminUsername := *source.AdminUsername
		virtualMachineScaleSetOSProfileStatus.AdminUsername = &adminUsername
	} else {
		virtualMachineScaleSetOSProfileStatus.AdminUsername = nil
	}

	// ComputerNamePrefix
	if source.ComputerNamePrefix != nil {
		computerNamePrefix := *source.ComputerNamePrefix
		virtualMachineScaleSetOSProfileStatus.ComputerNamePrefix = &computerNamePrefix
	} else {
		virtualMachineScaleSetOSProfileStatus.ComputerNamePrefix = nil
	}

	// CustomData
	if source.CustomData != nil {
		customDatum := *source.CustomData
		virtualMachineScaleSetOSProfileStatus.CustomData = &customDatum
	} else {
		virtualMachineScaleSetOSProfileStatus.CustomData = nil
	}

	// LinuxConfiguration
	if source.LinuxConfiguration != nil {
		var linuxConfiguration LinuxConfiguration_Status
		err := linuxConfiguration.AssignPropertiesFromLinuxConfigurationStatus(source.LinuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating LinuxConfiguration from LinuxConfiguration, calling AssignPropertiesFromLinuxConfigurationStatus()")
		}
		virtualMachineScaleSetOSProfileStatus.LinuxConfiguration = &linuxConfiguration
	} else {
		virtualMachineScaleSetOSProfileStatus.LinuxConfiguration = nil
	}

	// Secrets
	secretList := make([]VaultSecretGroup_Status, len(source.Secrets))
	for secretIndex, secretItem := range source.Secrets {
		// Shadow the loop variable to avoid aliasing
		secretItem := secretItem
		var secret VaultSecretGroup_Status
		err := secret.AssignPropertiesFromVaultSecretGroupStatus(&secretItem)
		if err != nil {
			return errors.Wrap(err, "populating Secrets from Secrets, calling AssignPropertiesFromVaultSecretGroupStatus()")
		}
		secretList[secretIndex] = secret
	}
	virtualMachineScaleSetOSProfileStatus.Secrets = secretList

	// WindowsConfiguration
	if source.WindowsConfiguration != nil {
		var windowsConfiguration WindowsConfiguration_Status
		err := windowsConfiguration.AssignPropertiesFromWindowsConfigurationStatus(source.WindowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating WindowsConfiguration from WindowsConfiguration, calling AssignPropertiesFromWindowsConfigurationStatus()")
		}
		virtualMachineScaleSetOSProfileStatus.WindowsConfiguration = &windowsConfiguration
	} else {
		virtualMachineScaleSetOSProfileStatus.WindowsConfiguration = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetOSProfileStatus populates the provided destination VirtualMachineScaleSetOSProfile_Status from our VirtualMachineScaleSetOSProfile_Status
func (virtualMachineScaleSetOSProfileStatus *VirtualMachineScaleSetOSProfile_Status) AssignPropertiesToVirtualMachineScaleSetOSProfileStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetOSProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminPassword
	if virtualMachineScaleSetOSProfileStatus.AdminPassword != nil {
		adminPassword := *virtualMachineScaleSetOSProfileStatus.AdminPassword
		destination.AdminPassword = &adminPassword
	} else {
		destination.AdminPassword = nil
	}

	// AdminUsername
	if virtualMachineScaleSetOSProfileStatus.AdminUsername != nil {
		adminUsername := *virtualMachineScaleSetOSProfileStatus.AdminUsername
		destination.AdminUsername = &adminUsername
	} else {
		destination.AdminUsername = nil
	}

	// ComputerNamePrefix
	if virtualMachineScaleSetOSProfileStatus.ComputerNamePrefix != nil {
		computerNamePrefix := *virtualMachineScaleSetOSProfileStatus.ComputerNamePrefix
		destination.ComputerNamePrefix = &computerNamePrefix
	} else {
		destination.ComputerNamePrefix = nil
	}

	// CustomData
	if virtualMachineScaleSetOSProfileStatus.CustomData != nil {
		customDatum := *virtualMachineScaleSetOSProfileStatus.CustomData
		destination.CustomData = &customDatum
	} else {
		destination.CustomData = nil
	}

	// LinuxConfiguration
	if virtualMachineScaleSetOSProfileStatus.LinuxConfiguration != nil {
		var linuxConfiguration v1alpha1api20201201storage.LinuxConfiguration_Status
		err := (*virtualMachineScaleSetOSProfileStatus.LinuxConfiguration).AssignPropertiesToLinuxConfigurationStatus(&linuxConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating LinuxConfiguration from LinuxConfiguration, calling AssignPropertiesToLinuxConfigurationStatus()")
		}
		destination.LinuxConfiguration = &linuxConfiguration
	} else {
		destination.LinuxConfiguration = nil
	}

	// Secrets
	secretList := make([]v1alpha1api20201201storage.VaultSecretGroup_Status, len(virtualMachineScaleSetOSProfileStatus.Secrets))
	for secretIndex, secretItem := range virtualMachineScaleSetOSProfileStatus.Secrets {
		// Shadow the loop variable to avoid aliasing
		secretItem := secretItem
		var secret v1alpha1api20201201storage.VaultSecretGroup_Status
		err := secretItem.AssignPropertiesToVaultSecretGroupStatus(&secret)
		if err != nil {
			return errors.Wrap(err, "populating Secrets from Secrets, calling AssignPropertiesToVaultSecretGroupStatus()")
		}
		secretList[secretIndex] = secret
	}
	destination.Secrets = secretList

	// WindowsConfiguration
	if virtualMachineScaleSetOSProfileStatus.WindowsConfiguration != nil {
		var windowsConfiguration v1alpha1api20201201storage.WindowsConfiguration_Status
		err := (*virtualMachineScaleSetOSProfileStatus.WindowsConfiguration).AssignPropertiesToWindowsConfigurationStatus(&windowsConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating WindowsConfiguration from WindowsConfiguration, calling AssignPropertiesToWindowsConfigurationStatus()")
		}
		destination.WindowsConfiguration = &windowsConfiguration
	} else {
		destination.WindowsConfiguration = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VirtualMachineScaleSetStorageProfile
type VirtualMachineScaleSetStorageProfile struct {
	//DataDisks: Specifies the parameters that are used to add data disks to the
	//virtual machines in the scale set.
	//For more information about disks, see [About disks and VHDs for Azure virtual
	//machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
	DataDisks []VirtualMachineScaleSetDataDisk `json:"dataDisks,omitempty"`

	//ImageReference: Specifies information about the image to use. You can specify
	//information about platform images, marketplace images, or virtual machine
	//images. This element is required when you want to use a platform image,
	//marketplace image, or virtual machine image, but is not used in other creation
	//operations. NOTE: Image reference publisher and offer can only be set when you
	//create the scale set.
	ImageReference *ImageReference `json:"imageReference,omitempty"`

	//OsDisk: Describes a virtual machine scale set operating system disk.
	OsDisk *VirtualMachineScaleSetOSDisk `json:"osDisk,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetStorageProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetStorageProfile *VirtualMachineScaleSetStorageProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetStorageProfile == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetStorageProfileARM

	// Set property ‘DataDisks’:
	for _, item := range virtualMachineScaleSetStorageProfile.DataDisks {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.DataDisks = append(result.DataDisks, itemARM.(VirtualMachineScaleSetDataDiskARM))
	}

	// Set property ‘ImageReference’:
	if virtualMachineScaleSetStorageProfile.ImageReference != nil {
		imageReferenceARM, err := (*virtualMachineScaleSetStorageProfile.ImageReference).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		imageReference := imageReferenceARM.(ImageReferenceARM)
		result.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if virtualMachineScaleSetStorageProfile.OsDisk != nil {
		osDiskARM, err := (*virtualMachineScaleSetStorageProfile.OsDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osDisk := osDiskARM.(VirtualMachineScaleSetOSDiskARM)
		result.OsDisk = &osDisk
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetStorageProfile *VirtualMachineScaleSetStorageProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetStorageProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetStorageProfile *VirtualMachineScaleSetStorageProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetStorageProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetStorageProfileARM, got %T", armInput)
	}

	// Set property ‘DataDisks’:
	for _, item := range typedInput.DataDisks {
		var item1 VirtualMachineScaleSetDataDisk
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineScaleSetStorageProfile.DataDisks = append(virtualMachineScaleSetStorageProfile.DataDisks, item1)
	}

	// Set property ‘ImageReference’:
	if typedInput.ImageReference != nil {
		var imageReference1 ImageReference
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		virtualMachineScaleSetStorageProfile.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if typedInput.OsDisk != nil {
		var osDisk1 VirtualMachineScaleSetOSDisk
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		virtualMachineScaleSetStorageProfile.OsDisk = &osDisk
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetStorageProfile populates our VirtualMachineScaleSetStorageProfile from the provided source VirtualMachineScaleSetStorageProfile
func (virtualMachineScaleSetStorageProfile *VirtualMachineScaleSetStorageProfile) AssignPropertiesFromVirtualMachineScaleSetStorageProfile(source *v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile) error {

	// DataDisks
	dataDiskList := make([]VirtualMachineScaleSetDataDisk, len(source.DataDisks))
	for dataDiskIndex, dataDiskItem := range source.DataDisks {
		// Shadow the loop variable to avoid aliasing
		dataDiskItem := dataDiskItem
		var dataDisk VirtualMachineScaleSetDataDisk
		err := dataDisk.AssignPropertiesFromVirtualMachineScaleSetDataDisk(&dataDiskItem)
		if err != nil {
			return errors.Wrap(err, "populating DataDisks from DataDisks, calling AssignPropertiesFromVirtualMachineScaleSetDataDisk()")
		}
		dataDiskList[dataDiskIndex] = dataDisk
	}
	virtualMachineScaleSetStorageProfile.DataDisks = dataDiskList

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference
		err := imageReference.AssignPropertiesFromImageReference(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "populating ImageReference from ImageReference, calling AssignPropertiesFromImageReference()")
		}
		virtualMachineScaleSetStorageProfile.ImageReference = &imageReference
	} else {
		virtualMachineScaleSetStorageProfile.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk VirtualMachineScaleSetOSDisk
		err := osDisk.AssignPropertiesFromVirtualMachineScaleSetOSDisk(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "populating OsDisk from OsDisk, calling AssignPropertiesFromVirtualMachineScaleSetOSDisk()")
		}
		virtualMachineScaleSetStorageProfile.OsDisk = &osDisk
	} else {
		virtualMachineScaleSetStorageProfile.OsDisk = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetStorageProfile populates the provided destination VirtualMachineScaleSetStorageProfile from our VirtualMachineScaleSetStorageProfile
func (virtualMachineScaleSetStorageProfile *VirtualMachineScaleSetStorageProfile) AssignPropertiesToVirtualMachineScaleSetStorageProfile(destination *v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataDisks
	dataDiskList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk, len(virtualMachineScaleSetStorageProfile.DataDisks))
	for dataDiskIndex, dataDiskItem := range virtualMachineScaleSetStorageProfile.DataDisks {
		// Shadow the loop variable to avoid aliasing
		dataDiskItem := dataDiskItem
		var dataDisk v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk
		err := dataDiskItem.AssignPropertiesToVirtualMachineScaleSetDataDisk(&dataDisk)
		if err != nil {
			return errors.Wrap(err, "populating DataDisks from DataDisks, calling AssignPropertiesToVirtualMachineScaleSetDataDisk()")
		}
		dataDiskList[dataDiskIndex] = dataDisk
	}
	destination.DataDisks = dataDiskList

	// ImageReference
	if virtualMachineScaleSetStorageProfile.ImageReference != nil {
		var imageReference v1alpha1api20201201storage.ImageReference
		err := (*virtualMachineScaleSetStorageProfile.ImageReference).AssignPropertiesToImageReference(&imageReference)
		if err != nil {
			return errors.Wrap(err, "populating ImageReference from ImageReference, calling AssignPropertiesToImageReference()")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if virtualMachineScaleSetStorageProfile.OsDisk != nil {
		var osDisk v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk
		err := (*virtualMachineScaleSetStorageProfile.OsDisk).AssignPropertiesToVirtualMachineScaleSetOSDisk(&osDisk)
		if err != nil {
			return errors.Wrap(err, "populating OsDisk from OsDisk, calling AssignPropertiesToVirtualMachineScaleSetOSDisk()")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VirtualMachineScaleSetStorageProfile_Status struct {
	//DataDisks: Specifies the parameters that are used to add data disks to the
	//virtual machines in the scale set.
	//For more information about disks, see [About disks and VHDs for Azure virtual
	//machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
	DataDisks []VirtualMachineScaleSetDataDisk_Status `json:"dataDisks,omitempty"`

	//ImageReference: Specifies information about the image to use. You can specify
	//information about platform images, marketplace images, or virtual machine
	//images. This element is required when you want to use a platform image,
	//marketplace image, or virtual machine image, but is not used in other creation
	//operations.
	ImageReference *ImageReference_Status `json:"imageReference,omitempty"`

	//OsDisk: Specifies information about the operating system disk used by the
	//virtual machines in the scale set.
	//For more information about disks, see [About disks and VHDs for Azure virtual
	//machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
	OsDisk *VirtualMachineScaleSetOSDisk_Status `json:"osDisk,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetStorageProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetStorageProfileStatus *VirtualMachineScaleSetStorageProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetStorageProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetStorageProfileStatus *VirtualMachineScaleSetStorageProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetStorageProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetStorageProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘DataDisks’:
	for _, item := range typedInput.DataDisks {
		var item1 VirtualMachineScaleSetDataDisk_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineScaleSetStorageProfileStatus.DataDisks = append(virtualMachineScaleSetStorageProfileStatus.DataDisks, item1)
	}

	// Set property ‘ImageReference’:
	if typedInput.ImageReference != nil {
		var imageReference1 ImageReference_Status
		err := imageReference1.PopulateFromARM(owner, *typedInput.ImageReference)
		if err != nil {
			return err
		}
		imageReference := imageReference1
		virtualMachineScaleSetStorageProfileStatus.ImageReference = &imageReference
	}

	// Set property ‘OsDisk’:
	if typedInput.OsDisk != nil {
		var osDisk1 VirtualMachineScaleSetOSDisk_Status
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		virtualMachineScaleSetStorageProfileStatus.OsDisk = &osDisk
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetStorageProfileStatus populates our VirtualMachineScaleSetStorageProfile_Status from the provided source VirtualMachineScaleSetStorageProfile_Status
func (virtualMachineScaleSetStorageProfileStatus *VirtualMachineScaleSetStorageProfile_Status) AssignPropertiesFromVirtualMachineScaleSetStorageProfileStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile_Status) error {

	// DataDisks
	dataDiskList := make([]VirtualMachineScaleSetDataDisk_Status, len(source.DataDisks))
	for dataDiskIndex, dataDiskItem := range source.DataDisks {
		// Shadow the loop variable to avoid aliasing
		dataDiskItem := dataDiskItem
		var dataDisk VirtualMachineScaleSetDataDisk_Status
		err := dataDisk.AssignPropertiesFromVirtualMachineScaleSetDataDiskStatus(&dataDiskItem)
		if err != nil {
			return errors.Wrap(err, "populating DataDisks from DataDisks, calling AssignPropertiesFromVirtualMachineScaleSetDataDiskStatus()")
		}
		dataDiskList[dataDiskIndex] = dataDisk
	}
	virtualMachineScaleSetStorageProfileStatus.DataDisks = dataDiskList

	// ImageReference
	if source.ImageReference != nil {
		var imageReference ImageReference_Status
		err := imageReference.AssignPropertiesFromImageReferenceStatus(source.ImageReference)
		if err != nil {
			return errors.Wrap(err, "populating ImageReference from ImageReference, calling AssignPropertiesFromImageReferenceStatus()")
		}
		virtualMachineScaleSetStorageProfileStatus.ImageReference = &imageReference
	} else {
		virtualMachineScaleSetStorageProfileStatus.ImageReference = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk VirtualMachineScaleSetOSDisk_Status
		err := osDisk.AssignPropertiesFromVirtualMachineScaleSetOSDiskStatus(source.OsDisk)
		if err != nil {
			return errors.Wrap(err, "populating OsDisk from OsDisk, calling AssignPropertiesFromVirtualMachineScaleSetOSDiskStatus()")
		}
		virtualMachineScaleSetStorageProfileStatus.OsDisk = &osDisk
	} else {
		virtualMachineScaleSetStorageProfileStatus.OsDisk = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetStorageProfileStatus populates the provided destination VirtualMachineScaleSetStorageProfile_Status from our VirtualMachineScaleSetStorageProfile_Status
func (virtualMachineScaleSetStorageProfileStatus *VirtualMachineScaleSetStorageProfile_Status) AssignPropertiesToVirtualMachineScaleSetStorageProfileStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetStorageProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataDisks
	dataDiskList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Status, len(virtualMachineScaleSetStorageProfileStatus.DataDisks))
	for dataDiskIndex, dataDiskItem := range virtualMachineScaleSetStorageProfileStatus.DataDisks {
		// Shadow the loop variable to avoid aliasing
		dataDiskItem := dataDiskItem
		var dataDisk v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Status
		err := dataDiskItem.AssignPropertiesToVirtualMachineScaleSetDataDiskStatus(&dataDisk)
		if err != nil {
			return errors.Wrap(err, "populating DataDisks from DataDisks, calling AssignPropertiesToVirtualMachineScaleSetDataDiskStatus()")
		}
		dataDiskList[dataDiskIndex] = dataDisk
	}
	destination.DataDisks = dataDiskList

	// ImageReference
	if virtualMachineScaleSetStorageProfileStatus.ImageReference != nil {
		var imageReference v1alpha1api20201201storage.ImageReference_Status
		err := (*virtualMachineScaleSetStorageProfileStatus.ImageReference).AssignPropertiesToImageReferenceStatus(&imageReference)
		if err != nil {
			return errors.Wrap(err, "populating ImageReference from ImageReference, calling AssignPropertiesToImageReferenceStatus()")
		}
		destination.ImageReference = &imageReference
	} else {
		destination.ImageReference = nil
	}

	// OsDisk
	if virtualMachineScaleSetStorageProfileStatus.OsDisk != nil {
		var osDisk v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk_Status
		err := (*virtualMachineScaleSetStorageProfileStatus.OsDisk).AssignPropertiesToVirtualMachineScaleSetOSDiskStatus(&osDisk)
		if err != nil {
			return errors.Wrap(err, "populating OsDisk from OsDisk, calling AssignPropertiesToVirtualMachineScaleSetOSDiskStatus()")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Deallocate","Delete"}
type VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicy string

const (
	VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicyDeallocate = VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicy("Deallocate")
	VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicyDelete     = VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileEvictionPolicy("Delete")
)

// +kubebuilder:validation:Enum={"Low","Regular","Spot"}
type VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority string

const (
	VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriorityLow     = VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority("Low")
	VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriorityRegular = VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority("Regular")
	VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePrioritySpot    = VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfilePriority("Spot")
)

type VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile struct {
	//Extensions: The virtual machine scale set child extension resources.
	Extensions []VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions `json:"extensions,omitempty"`

	//ExtensionsTimeBudget: Specifies the time alloted for all extensions to start.
	//The time duration should be between 15 minutes and 120 minutes (inclusive) and
	//should be specified in ISO 8601 format. The default value is 90 minutes
	//(PT1H30M).
	//Minimum api-version: 2020-06-01
	ExtensionsTimeBudget *string `json:"extensionsTimeBudget,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfileARM

	// Set property ‘Extensions’:
	for _, item := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile.Extensions {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Extensions = append(result.Extensions, itemARM.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_ExtensionsARM))
	}

	// Set property ‘ExtensionsTimeBudget’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile.ExtensionsTimeBudget
		result.ExtensionsTimeBudget = &extensionsTimeBudget
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfileARM, got %T", armInput)
	}

	// Set property ‘Extensions’:
	for _, item := range typedInput.Extensions {
		var item1 VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile.Extensions = append(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile.Extensions, item1)
	}

	// Set property ‘ExtensionsTimeBudget’:
	if typedInput.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *typedInput.ExtensionsTimeBudget
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile.ExtensionsTimeBudget = &extensionsTimeBudget
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile populates our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile from the provided source VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile) AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile(source *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile) error {

	// Extensions
	extensionList := make([]VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions, len(source.Extensions))
	for extensionIndex, extensionItem := range source.Extensions {
		// Shadow the loop variable to avoid aliasing
		extensionItem := extensionItem
		var extension VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions
		err := extension.AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions(&extensionItem)
		if err != nil {
			return errors.Wrap(err, "populating Extensions from Extensions, calling AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions()")
		}
		extensionList[extensionIndex] = extension
	}
	virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile.Extensions = extensionList

	// ExtensionsTimeBudget
	if source.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *source.ExtensionsTimeBudget
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile.ExtensionsTimeBudget = &extensionsTimeBudget
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile.ExtensionsTimeBudget = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile populates the provided destination VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile from our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile) AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile(destination *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Extensions
	extensionList := make([]v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions, len(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile.Extensions))
	for extensionIndex, extensionItem := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile.Extensions {
		// Shadow the loop variable to avoid aliasing
		extensionItem := extensionItem
		var extension v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions
		err := extensionItem.AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions(&extension)
		if err != nil {
			return errors.Wrap(err, "populating Extensions from Extensions, calling AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions()")
		}
		extensionList[extensionIndex] = extension
	}
	destination.Extensions = extensionList

	// ExtensionsTimeBudget
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile.ExtensionsTimeBudget != nil {
		extensionsTimeBudget := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfile.ExtensionsTimeBudget
		destination.ExtensionsTimeBudget = &extensionsTimeBudget
	} else {
		destination.ExtensionsTimeBudget = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile struct {
	//HealthProbe: The API entity reference.
	HealthProbe *ApiEntityReference `json:"healthProbe,omitempty"`

	//NetworkInterfaceConfigurations: The list of network configurations.
	NetworkInterfaceConfigurations []VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations `json:"networkInterfaceConfigurations,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfileARM

	// Set property ‘HealthProbe’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile.HealthProbe != nil {
		healthProbeARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile.HealthProbe).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		healthProbe := healthProbeARM.(ApiEntityReferenceARM)
		result.HealthProbe = &healthProbe
	}

	// Set property ‘NetworkInterfaceConfigurations’:
	for _, item := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile.NetworkInterfaceConfigurations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.NetworkInterfaceConfigurations = append(result.NetworkInterfaceConfigurations, itemARM.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurationsARM))
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfileARM, got %T", armInput)
	}

	// Set property ‘HealthProbe’:
	if typedInput.HealthProbe != nil {
		var healthProbe1 ApiEntityReference
		err := healthProbe1.PopulateFromARM(owner, *typedInput.HealthProbe)
		if err != nil {
			return err
		}
		healthProbe := healthProbe1
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile.HealthProbe = &healthProbe
	}

	// Set property ‘NetworkInterfaceConfigurations’:
	for _, item := range typedInput.NetworkInterfaceConfigurations {
		var item1 VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile.NetworkInterfaceConfigurations = append(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile.NetworkInterfaceConfigurations, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile populates our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile from the provided source VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile) AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile(source *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile) error {

	// HealthProbe
	if source.HealthProbe != nil {
		var healthProbe ApiEntityReference
		err := healthProbe.AssignPropertiesFromApiEntityReference(source.HealthProbe)
		if err != nil {
			return errors.Wrap(err, "populating HealthProbe from HealthProbe, calling AssignPropertiesFromApiEntityReference()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile.HealthProbe = &healthProbe
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile.HealthProbe = nil
	}

	// NetworkInterfaceConfigurations
	networkInterfaceConfigurationList := make([]VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations, len(source.NetworkInterfaceConfigurations))
	for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range source.NetworkInterfaceConfigurations {
		// Shadow the loop variable to avoid aliasing
		networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
		var networkInterfaceConfiguration VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations
		err := networkInterfaceConfiguration.AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations(&networkInterfaceConfigurationItem)
		if err != nil {
			return errors.Wrap(err, "populating NetworkInterfaceConfigurations from NetworkInterfaceConfigurations, calling AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations()")
		}
		networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
	}
	virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile.NetworkInterfaceConfigurations = networkInterfaceConfigurationList

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile populates the provided destination VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile from our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile) AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile(destination *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HealthProbe
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile.HealthProbe != nil {
		var healthProbe v1alpha1api20201201storage.ApiEntityReference
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile.HealthProbe).AssignPropertiesToApiEntityReference(&healthProbe)
		if err != nil {
			return errors.Wrap(err, "populating HealthProbe from HealthProbe, calling AssignPropertiesToApiEntityReference()")
		}
		destination.HealthProbe = &healthProbe
	} else {
		destination.HealthProbe = nil
	}

	// NetworkInterfaceConfigurations
	networkInterfaceConfigurationList := make([]v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations, len(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile.NetworkInterfaceConfigurations))
	for networkInterfaceConfigurationIndex, networkInterfaceConfigurationItem := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfile.NetworkInterfaceConfigurations {
		// Shadow the loop variable to avoid aliasing
		networkInterfaceConfigurationItem := networkInterfaceConfigurationItem
		var networkInterfaceConfiguration v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations
		err := networkInterfaceConfigurationItem.AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations(&networkInterfaceConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating NetworkInterfaceConfigurations from NetworkInterfaceConfigurations, calling AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations()")
		}
		networkInterfaceConfigurationList[networkInterfaceConfigurationIndex] = networkInterfaceConfiguration
	}
	destination.NetworkInterfaceConfigurations = networkInterfaceConfigurationList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/ApiEntityReference
type ApiEntityReference struct {
	//Reference: The ARM resource id in the form of
	///subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ApiEntityReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (apiEntityReference *ApiEntityReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if apiEntityReference == nil {
		return nil, nil
	}
	var result ApiEntityReferenceARM

	// Set property ‘Id’:
	if apiEntityReference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*apiEntityReference.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (apiEntityReference *ApiEntityReference) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiEntityReferenceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (apiEntityReference *ApiEntityReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(ApiEntityReferenceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiEntityReferenceARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromApiEntityReference populates our ApiEntityReference from the provided source ApiEntityReference
func (apiEntityReference *ApiEntityReference) AssignPropertiesFromApiEntityReference(source *v1alpha1api20201201storage.ApiEntityReference) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		apiEntityReference.Reference = &reference
	} else {
		apiEntityReference.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApiEntityReference populates the provided destination ApiEntityReference from our ApiEntityReference
func (apiEntityReference *ApiEntityReference) AssignPropertiesToApiEntityReference(destination *v1alpha1api20201201storage.ApiEntityReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if apiEntityReference.Reference != nil {
		reference := apiEntityReference.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ApiEntityReference_Status struct {
	//Id: The ARM resource id in the form of
	///subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiEntityReference_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (apiEntityReferenceStatus *ApiEntityReference_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ApiEntityReference_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (apiEntityReferenceStatus *ApiEntityReference_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ApiEntityReference_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ApiEntityReference_StatusARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		apiEntityReferenceStatus.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromApiEntityReferenceStatus populates our ApiEntityReference_Status from the provided source ApiEntityReference_Status
func (apiEntityReferenceStatus *ApiEntityReference_Status) AssignPropertiesFromApiEntityReferenceStatus(source *v1alpha1api20201201storage.ApiEntityReference_Status) error {

	// Id
	if source.Id != nil {
		id := *source.Id
		apiEntityReferenceStatus.Id = &id
	} else {
		apiEntityReferenceStatus.Id = nil
	}

	// No error
	return nil
}

// AssignPropertiesToApiEntityReferenceStatus populates the provided destination ApiEntityReference_Status from our ApiEntityReference_Status
func (apiEntityReferenceStatus *ApiEntityReference_Status) AssignPropertiesToApiEntityReferenceStatus(destination *v1alpha1api20201201storage.ApiEntityReference_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	if apiEntityReferenceStatus.Id != nil {
		id := *apiEntityReferenceStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/BootDiagnostics
type BootDiagnostics struct {
	//Enabled: Whether boot diagnostics should be enabled on the Virtual Machine.
	Enabled *bool `json:"enabled,omitempty"`

	//StorageUri: Uri of the storage account to use for placing the console output and
	//screenshot.
	//If storageUri is not specified while enabling boot diagnostics, managed storage
	//will be used.
	StorageUri *string `json:"storageUri,omitempty"`
}

var _ genruntime.ARMTransformer = &BootDiagnostics{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (bootDiagnostics *BootDiagnostics) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if bootDiagnostics == nil {
		return nil, nil
	}
	var result BootDiagnosticsARM

	// Set property ‘Enabled’:
	if bootDiagnostics.Enabled != nil {
		enabled := *bootDiagnostics.Enabled
		result.Enabled = &enabled
	}

	// Set property ‘StorageUri’:
	if bootDiagnostics.StorageUri != nil {
		storageUri := *bootDiagnostics.StorageUri
		result.StorageUri = &storageUri
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (bootDiagnostics *BootDiagnostics) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &BootDiagnosticsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (bootDiagnostics *BootDiagnostics) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BootDiagnosticsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BootDiagnosticsARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		bootDiagnostics.Enabled = &enabled
	}

	// Set property ‘StorageUri’:
	if typedInput.StorageUri != nil {
		storageUri := *typedInput.StorageUri
		bootDiagnostics.StorageUri = &storageUri
	}

	// No error
	return nil
}

// AssignPropertiesFromBootDiagnostics populates our BootDiagnostics from the provided source BootDiagnostics
func (bootDiagnostics *BootDiagnostics) AssignPropertiesFromBootDiagnostics(source *v1alpha1api20201201storage.BootDiagnostics) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		bootDiagnostics.Enabled = &enabled
	} else {
		bootDiagnostics.Enabled = nil
	}

	// StorageUri
	if source.StorageUri != nil {
		storageUri := *source.StorageUri
		bootDiagnostics.StorageUri = &storageUri
	} else {
		bootDiagnostics.StorageUri = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBootDiagnostics populates the provided destination BootDiagnostics from our BootDiagnostics
func (bootDiagnostics *BootDiagnostics) AssignPropertiesToBootDiagnostics(destination *v1alpha1api20201201storage.BootDiagnostics) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if bootDiagnostics.Enabled != nil {
		enabled := *bootDiagnostics.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// StorageUri
	if bootDiagnostics.StorageUri != nil {
		storageUri := *bootDiagnostics.StorageUri
		destination.StorageUri = &storageUri
	} else {
		destination.StorageUri = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type BootDiagnostics_Status struct {
	//Enabled: Whether boot diagnostics should be enabled on the Virtual Machine.
	Enabled *bool `json:"enabled,omitempty"`

	//StorageUri: Uri of the storage account to use for placing the console output and
	//screenshot.
	//If storageUri is not specified while enabling boot diagnostics, managed storage
	//will be used.
	StorageUri *string `json:"storageUri,omitempty"`
}

var _ genruntime.FromARMConverter = &BootDiagnostics_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (bootDiagnosticsStatus *BootDiagnostics_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &BootDiagnostics_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (bootDiagnosticsStatus *BootDiagnostics_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(BootDiagnostics_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected BootDiagnostics_StatusARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	if typedInput.Enabled != nil {
		enabled := *typedInput.Enabled
		bootDiagnosticsStatus.Enabled = &enabled
	}

	// Set property ‘StorageUri’:
	if typedInput.StorageUri != nil {
		storageUri := *typedInput.StorageUri
		bootDiagnosticsStatus.StorageUri = &storageUri
	}

	// No error
	return nil
}

// AssignPropertiesFromBootDiagnosticsStatus populates our BootDiagnostics_Status from the provided source BootDiagnostics_Status
func (bootDiagnosticsStatus *BootDiagnostics_Status) AssignPropertiesFromBootDiagnosticsStatus(source *v1alpha1api20201201storage.BootDiagnostics_Status) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		bootDiagnosticsStatus.Enabled = &enabled
	} else {
		bootDiagnosticsStatus.Enabled = nil
	}

	// StorageUri
	if source.StorageUri != nil {
		storageUri := *source.StorageUri
		bootDiagnosticsStatus.StorageUri = &storageUri
	} else {
		bootDiagnosticsStatus.StorageUri = nil
	}

	// No error
	return nil
}

// AssignPropertiesToBootDiagnosticsStatus populates the provided destination BootDiagnostics_Status from our BootDiagnostics_Status
func (bootDiagnosticsStatus *BootDiagnostics_Status) AssignPropertiesToBootDiagnosticsStatus(destination *v1alpha1api20201201storage.BootDiagnostics_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if bootDiagnosticsStatus.Enabled != nil {
		enabled := *bootDiagnosticsStatus.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// StorageUri
	if bootDiagnosticsStatus.StorageUri != nil {
		storageUri := *bootDiagnosticsStatus.StorageUri
		destination.StorageUri = &storageUri
	} else {
		destination.StorageUri = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/ImageReference
type ImageReference struct {
	//Offer: Specifies the offer of the platform image or marketplace image used to
	//create the virtual machine.
	Offer *string `json:"offer,omitempty"`

	//Publisher: The image publisher.
	Publisher *string `json:"publisher,omitempty"`

	//Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	//Sku: The image SKU.
	Sku *string `json:"sku,omitempty"`

	//Version: Specifies the version of the platform image or marketplace image used
	//to create the virtual machine. The allowed formats are Major.Minor.Build or
	//'latest'. Major, Minor, and Build are decimal numbers. Specify 'latest' to use
	//the latest version of an image available at deploy time. Even if you use
	//'latest', the VM image will not automatically update after deploy time even if a
	//new version becomes available.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &ImageReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (imageReference *ImageReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if imageReference == nil {
		return nil, nil
	}
	var result ImageReferenceARM

	// Set property ‘Id’:
	if imageReference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*imageReference.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property ‘Offer’:
	if imageReference.Offer != nil {
		offer := *imageReference.Offer
		result.Offer = &offer
	}

	// Set property ‘Publisher’:
	if imageReference.Publisher != nil {
		publisher := *imageReference.Publisher
		result.Publisher = &publisher
	}

	// Set property ‘Sku’:
	if imageReference.Sku != nil {
		sku := *imageReference.Sku
		result.Sku = &sku
	}

	// Set property ‘Version’:
	if imageReference.Version != nil {
		version := *imageReference.Version
		result.Version = &version
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (imageReference *ImageReference) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ImageReferenceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (imageReference *ImageReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ImageReferenceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ImageReferenceARM, got %T", armInput)
	}

	// Set property ‘Offer’:
	if typedInput.Offer != nil {
		offer := *typedInput.Offer
		imageReference.Offer = &offer
	}

	// Set property ‘Publisher’:
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		imageReference.Publisher = &publisher
	}

	// no assignment for property ‘Reference’

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		sku := *typedInput.Sku
		imageReference.Sku = &sku
	}

	// Set property ‘Version’:
	if typedInput.Version != nil {
		version := *typedInput.Version
		imageReference.Version = &version
	}

	// No error
	return nil
}

// AssignPropertiesFromImageReference populates our ImageReference from the provided source ImageReference
func (imageReference *ImageReference) AssignPropertiesFromImageReference(source *v1alpha1api20201201storage.ImageReference) error {

	// Offer
	if source.Offer != nil {
		offer := *source.Offer
		imageReference.Offer = &offer
	} else {
		imageReference.Offer = nil
	}

	// Publisher
	if source.Publisher != nil {
		publisher := *source.Publisher
		imageReference.Publisher = &publisher
	} else {
		imageReference.Publisher = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		imageReference.Reference = &reference
	} else {
		imageReference.Reference = nil
	}

	// Sku
	if source.Sku != nil {
		sku := *source.Sku
		imageReference.Sku = &sku
	} else {
		imageReference.Sku = nil
	}

	// Version
	if source.Version != nil {
		version := *source.Version
		imageReference.Version = &version
	} else {
		imageReference.Version = nil
	}

	// No error
	return nil
}

// AssignPropertiesToImageReference populates the provided destination ImageReference from our ImageReference
func (imageReference *ImageReference) AssignPropertiesToImageReference(destination *v1alpha1api20201201storage.ImageReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Offer
	if imageReference.Offer != nil {
		offer := *imageReference.Offer
		destination.Offer = &offer
	} else {
		destination.Offer = nil
	}

	// Publisher
	if imageReference.Publisher != nil {
		publisher := *imageReference.Publisher
		destination.Publisher = &publisher
	} else {
		destination.Publisher = nil
	}

	// Reference
	if imageReference.Reference != nil {
		reference := imageReference.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Sku
	if imageReference.Sku != nil {
		sku := *imageReference.Sku
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Version
	if imageReference.Version != nil {
		version := *imageReference.Version
		destination.Version = &version
	} else {
		destination.Version = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type ImageReference_Status struct {
	//ExactVersion: Specifies in decimal numbers, the version of platform image or
	//marketplace image used to create the virtual machine. This readonly field
	//differs from 'version', only if the value specified in 'version' field is
	//'latest'.
	ExactVersion *string `json:"exactVersion,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//Offer: Specifies the offer of the platform image or marketplace image used to
	//create the virtual machine.
	Offer *string `json:"offer,omitempty"`

	//Publisher: The image publisher.
	Publisher *string `json:"publisher,omitempty"`

	//Sku: The image SKU.
	Sku *string `json:"sku,omitempty"`

	//Version: Specifies the version of the platform image or marketplace image used
	//to create the virtual machine. The allowed formats are Major.Minor.Build or
	//'latest'. Major, Minor, and Build are decimal numbers. Specify 'latest' to use
	//the latest version of an image available at deploy time. Even if you use
	//'latest', the VM image will not automatically update after deploy time even if a
	//new version becomes available.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &ImageReference_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (imageReferenceStatus *ImageReference_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &ImageReference_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (imageReferenceStatus *ImageReference_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ImageReference_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ImageReference_StatusARM, got %T", armInput)
	}

	// Set property ‘ExactVersion’:
	if typedInput.ExactVersion != nil {
		exactVersion := *typedInput.ExactVersion
		imageReferenceStatus.ExactVersion = &exactVersion
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		imageReferenceStatus.Id = &id
	}

	// Set property ‘Offer’:
	if typedInput.Offer != nil {
		offer := *typedInput.Offer
		imageReferenceStatus.Offer = &offer
	}

	// Set property ‘Publisher’:
	if typedInput.Publisher != nil {
		publisher := *typedInput.Publisher
		imageReferenceStatus.Publisher = &publisher
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		sku := *typedInput.Sku
		imageReferenceStatus.Sku = &sku
	}

	// Set property ‘Version’:
	if typedInput.Version != nil {
		version := *typedInput.Version
		imageReferenceStatus.Version = &version
	}

	// No error
	return nil
}

// AssignPropertiesFromImageReferenceStatus populates our ImageReference_Status from the provided source ImageReference_Status
func (imageReferenceStatus *ImageReference_Status) AssignPropertiesFromImageReferenceStatus(source *v1alpha1api20201201storage.ImageReference_Status) error {

	// ExactVersion
	if source.ExactVersion != nil {
		exactVersion := *source.ExactVersion
		imageReferenceStatus.ExactVersion = &exactVersion
	} else {
		imageReferenceStatus.ExactVersion = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		imageReferenceStatus.Id = &id
	} else {
		imageReferenceStatus.Id = nil
	}

	// Offer
	if source.Offer != nil {
		offer := *source.Offer
		imageReferenceStatus.Offer = &offer
	} else {
		imageReferenceStatus.Offer = nil
	}

	// Publisher
	if source.Publisher != nil {
		publisher := *source.Publisher
		imageReferenceStatus.Publisher = &publisher
	} else {
		imageReferenceStatus.Publisher = nil
	}

	// Sku
	if source.Sku != nil {
		sku := *source.Sku
		imageReferenceStatus.Sku = &sku
	} else {
		imageReferenceStatus.Sku = nil
	}

	// Version
	if source.Version != nil {
		version := *source.Version
		imageReferenceStatus.Version = &version
	} else {
		imageReferenceStatus.Version = nil
	}

	// No error
	return nil
}

// AssignPropertiesToImageReferenceStatus populates the provided destination ImageReference_Status from our ImageReference_Status
func (imageReferenceStatus *ImageReference_Status) AssignPropertiesToImageReferenceStatus(destination *v1alpha1api20201201storage.ImageReference_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ExactVersion
	if imageReferenceStatus.ExactVersion != nil {
		exactVersion := *imageReferenceStatus.ExactVersion
		destination.ExactVersion = &exactVersion
	} else {
		destination.ExactVersion = nil
	}

	// Id
	if imageReferenceStatus.Id != nil {
		id := *imageReferenceStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Offer
	if imageReferenceStatus.Offer != nil {
		offer := *imageReferenceStatus.Offer
		destination.Offer = &offer
	} else {
		destination.Offer = nil
	}

	// Publisher
	if imageReferenceStatus.Publisher != nil {
		publisher := *imageReferenceStatus.Publisher
		destination.Publisher = &publisher
	} else {
		destination.Publisher = nil
	}

	// Sku
	if imageReferenceStatus.Sku != nil {
		sku := *imageReferenceStatus.Sku
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Version
	if imageReferenceStatus.Version != nil {
		version := *imageReferenceStatus.Version
		destination.Version = &version
	} else {
		destination.Version = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/LinuxConfiguration
type LinuxConfiguration struct {
	//DisablePasswordAuthentication: Specifies whether password authentication should
	//be disabled.
	DisablePasswordAuthentication *bool `json:"disablePasswordAuthentication,omitempty"`

	//PatchSettings: Specifies settings related to VM Guest Patching on Linux.
	PatchSettings *LinuxPatchSettings `json:"patchSettings,omitempty"`

	//ProvisionVMAgent: Indicates whether virtual machine agent should be provisioned
	//on the virtual machine.
	//When this property is not specified in the request body, default behavior is to
	//set it to true.  This will ensure that VM Agent is installed on the VM so that
	//extensions can be added to the VM later.
	ProvisionVMAgent *bool `json:"provisionVMAgent,omitempty"`

	//Ssh: SSH configuration for Linux based VMs running on Azure
	Ssh *SshConfiguration `json:"ssh,omitempty"`
}

var _ genruntime.ARMTransformer = &LinuxConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (linuxConfiguration *LinuxConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if linuxConfiguration == nil {
		return nil, nil
	}
	var result LinuxConfigurationARM

	// Set property ‘DisablePasswordAuthentication’:
	if linuxConfiguration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *linuxConfiguration.DisablePasswordAuthentication
		result.DisablePasswordAuthentication = &disablePasswordAuthentication
	}

	// Set property ‘PatchSettings’:
	if linuxConfiguration.PatchSettings != nil {
		patchSettingsARM, err := (*linuxConfiguration.PatchSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		patchSettings := patchSettingsARM.(LinuxPatchSettingsARM)
		result.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if linuxConfiguration.ProvisionVMAgent != nil {
		provisionVMAgent := *linuxConfiguration.ProvisionVMAgent
		result.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘Ssh’:
	if linuxConfiguration.Ssh != nil {
		sshARM, err := (*linuxConfiguration.Ssh).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		ssh := sshARM.(SshConfigurationARM)
		result.Ssh = &ssh
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (linuxConfiguration *LinuxConfiguration) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LinuxConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (linuxConfiguration *LinuxConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LinuxConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LinuxConfigurationARM, got %T", armInput)
	}

	// Set property ‘DisablePasswordAuthentication’:
	if typedInput.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *typedInput.DisablePasswordAuthentication
		linuxConfiguration.DisablePasswordAuthentication = &disablePasswordAuthentication
	}

	// Set property ‘PatchSettings’:
	if typedInput.PatchSettings != nil {
		var patchSettings1 LinuxPatchSettings
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		linuxConfiguration.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		linuxConfiguration.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘Ssh’:
	if typedInput.Ssh != nil {
		var ssh1 SshConfiguration
		err := ssh1.PopulateFromARM(owner, *typedInput.Ssh)
		if err != nil {
			return err
		}
		ssh := ssh1
		linuxConfiguration.Ssh = &ssh
	}

	// No error
	return nil
}

// AssignPropertiesFromLinuxConfiguration populates our LinuxConfiguration from the provided source LinuxConfiguration
func (linuxConfiguration *LinuxConfiguration) AssignPropertiesFromLinuxConfiguration(source *v1alpha1api20201201storage.LinuxConfiguration) error {

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		linuxConfiguration.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		linuxConfiguration.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings
		err := patchSetting.AssignPropertiesFromLinuxPatchSettings(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesFromLinuxPatchSettings()")
		}
		linuxConfiguration.PatchSettings = &patchSetting
	} else {
		linuxConfiguration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		linuxConfiguration.ProvisionVMAgent = &provisionVMAgent
	} else {
		linuxConfiguration.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration
		err := ssh.AssignPropertiesFromSshConfiguration(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "populating Ssh from Ssh, calling AssignPropertiesFromSshConfiguration()")
		}
		linuxConfiguration.Ssh = &ssh
	} else {
		linuxConfiguration.Ssh = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxConfiguration populates the provided destination LinuxConfiguration from our LinuxConfiguration
func (linuxConfiguration *LinuxConfiguration) AssignPropertiesToLinuxConfiguration(destination *v1alpha1api20201201storage.LinuxConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisablePasswordAuthentication
	if linuxConfiguration.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *linuxConfiguration.DisablePasswordAuthentication
		destination.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		destination.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if linuxConfiguration.PatchSettings != nil {
		var patchSetting v1alpha1api20201201storage.LinuxPatchSettings
		err := (*linuxConfiguration.PatchSettings).AssignPropertiesToLinuxPatchSettings(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesToLinuxPatchSettings()")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if linuxConfiguration.ProvisionVMAgent != nil {
		provisionVMAgent := *linuxConfiguration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// Ssh
	if linuxConfiguration.Ssh != nil {
		var ssh v1alpha1api20201201storage.SshConfiguration
		err := (*linuxConfiguration.Ssh).AssignPropertiesToSshConfiguration(&ssh)
		if err != nil {
			return errors.Wrap(err, "populating Ssh from Ssh, calling AssignPropertiesToSshConfiguration()")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type LinuxConfiguration_Status struct {
	//DisablePasswordAuthentication: Specifies whether password authentication should
	//be disabled.
	DisablePasswordAuthentication *bool `json:"disablePasswordAuthentication,omitempty"`

	//PatchSettings: [Preview Feature] Specifies settings related to VM Guest Patching
	//on Linux.
	PatchSettings *LinuxPatchSettings_Status `json:"patchSettings,omitempty"`

	//ProvisionVMAgent: Indicates whether virtual machine agent should be provisioned
	//on the virtual machine.
	//When this property is not specified in the request body, default behavior is to
	//set it to true.  This will ensure that VM Agent is installed on the VM so that
	//extensions can be added to the VM later.
	ProvisionVMAgent *bool `json:"provisionVMAgent,omitempty"`

	//Ssh: Specifies the ssh key configuration for a Linux OS.
	Ssh *SshConfiguration_Status `json:"ssh,omitempty"`
}

var _ genruntime.FromARMConverter = &LinuxConfiguration_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (linuxConfigurationStatus *LinuxConfiguration_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LinuxConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (linuxConfigurationStatus *LinuxConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LinuxConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LinuxConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘DisablePasswordAuthentication’:
	if typedInput.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *typedInput.DisablePasswordAuthentication
		linuxConfigurationStatus.DisablePasswordAuthentication = &disablePasswordAuthentication
	}

	// Set property ‘PatchSettings’:
	if typedInput.PatchSettings != nil {
		var patchSettings1 LinuxPatchSettings_Status
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		linuxConfigurationStatus.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		linuxConfigurationStatus.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘Ssh’:
	if typedInput.Ssh != nil {
		var ssh1 SshConfiguration_Status
		err := ssh1.PopulateFromARM(owner, *typedInput.Ssh)
		if err != nil {
			return err
		}
		ssh := ssh1
		linuxConfigurationStatus.Ssh = &ssh
	}

	// No error
	return nil
}

// AssignPropertiesFromLinuxConfigurationStatus populates our LinuxConfiguration_Status from the provided source LinuxConfiguration_Status
func (linuxConfigurationStatus *LinuxConfiguration_Status) AssignPropertiesFromLinuxConfigurationStatus(source *v1alpha1api20201201storage.LinuxConfiguration_Status) error {

	// DisablePasswordAuthentication
	if source.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *source.DisablePasswordAuthentication
		linuxConfigurationStatus.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		linuxConfigurationStatus.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting LinuxPatchSettings_Status
		err := patchSetting.AssignPropertiesFromLinuxPatchSettingsStatus(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesFromLinuxPatchSettingsStatus()")
		}
		linuxConfigurationStatus.PatchSettings = &patchSetting
	} else {
		linuxConfigurationStatus.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		linuxConfigurationStatus.ProvisionVMAgent = &provisionVMAgent
	} else {
		linuxConfigurationStatus.ProvisionVMAgent = nil
	}

	// Ssh
	if source.Ssh != nil {
		var ssh SshConfiguration_Status
		err := ssh.AssignPropertiesFromSshConfigurationStatus(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "populating Ssh from Ssh, calling AssignPropertiesFromSshConfigurationStatus()")
		}
		linuxConfigurationStatus.Ssh = &ssh
	} else {
		linuxConfigurationStatus.Ssh = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxConfigurationStatus populates the provided destination LinuxConfiguration_Status from our LinuxConfiguration_Status
func (linuxConfigurationStatus *LinuxConfiguration_Status) AssignPropertiesToLinuxConfigurationStatus(destination *v1alpha1api20201201storage.LinuxConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DisablePasswordAuthentication
	if linuxConfigurationStatus.DisablePasswordAuthentication != nil {
		disablePasswordAuthentication := *linuxConfigurationStatus.DisablePasswordAuthentication
		destination.DisablePasswordAuthentication = &disablePasswordAuthentication
	} else {
		destination.DisablePasswordAuthentication = nil
	}

	// PatchSettings
	if linuxConfigurationStatus.PatchSettings != nil {
		var patchSetting v1alpha1api20201201storage.LinuxPatchSettings_Status
		err := (*linuxConfigurationStatus.PatchSettings).AssignPropertiesToLinuxPatchSettingsStatus(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesToLinuxPatchSettingsStatus()")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if linuxConfigurationStatus.ProvisionVMAgent != nil {
		provisionVMAgent := *linuxConfigurationStatus.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// Ssh
	if linuxConfigurationStatus.Ssh != nil {
		var ssh v1alpha1api20201201storage.SshConfiguration_Status
		err := (*linuxConfigurationStatus.Ssh).AssignPropertiesToSshConfigurationStatus(&ssh)
		if err != nil {
			return errors.Wrap(err, "populating Ssh from Ssh, calling AssignPropertiesToSshConfigurationStatus()")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"TrustedLaunch"}
type SecurityProfileSecurityType string

const SecurityProfileSecurityTypeTrustedLaunch = SecurityProfileSecurityType("TrustedLaunch")

type SecurityProfileStatusSecurityType string

const SecurityProfileStatusSecurityTypeTrustedLaunch = SecurityProfileStatusSecurityType("TrustedLaunch")

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/TerminateNotificationProfile
type TerminateNotificationProfile struct {
	//Enable: Specifies whether the Terminate Scheduled event is enabled or disabled.
	Enable *bool `json:"enable,omitempty"`

	//NotBeforeTimeout: Configurable length of time a Virtual Machine being deleted
	//will have to potentially approve the Terminate Scheduled Event before the event
	//is auto approved (timed out). The configuration must be specified in ISO 8601
	//format, the default value is 5 minutes (PT5M)
	NotBeforeTimeout *string `json:"notBeforeTimeout,omitempty"`
}

var _ genruntime.ARMTransformer = &TerminateNotificationProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (terminateNotificationProfile *TerminateNotificationProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if terminateNotificationProfile == nil {
		return nil, nil
	}
	var result TerminateNotificationProfileARM

	// Set property ‘Enable’:
	if terminateNotificationProfile.Enable != nil {
		enable := *terminateNotificationProfile.Enable
		result.Enable = &enable
	}

	// Set property ‘NotBeforeTimeout’:
	if terminateNotificationProfile.NotBeforeTimeout != nil {
		notBeforeTimeout := *terminateNotificationProfile.NotBeforeTimeout
		result.NotBeforeTimeout = &notBeforeTimeout
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (terminateNotificationProfile *TerminateNotificationProfile) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &TerminateNotificationProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (terminateNotificationProfile *TerminateNotificationProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(TerminateNotificationProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected TerminateNotificationProfileARM, got %T", armInput)
	}

	// Set property ‘Enable’:
	if typedInput.Enable != nil {
		enable := *typedInput.Enable
		terminateNotificationProfile.Enable = &enable
	}

	// Set property ‘NotBeforeTimeout’:
	if typedInput.NotBeforeTimeout != nil {
		notBeforeTimeout := *typedInput.NotBeforeTimeout
		terminateNotificationProfile.NotBeforeTimeout = &notBeforeTimeout
	}

	// No error
	return nil
}

// AssignPropertiesFromTerminateNotificationProfile populates our TerminateNotificationProfile from the provided source TerminateNotificationProfile
func (terminateNotificationProfile *TerminateNotificationProfile) AssignPropertiesFromTerminateNotificationProfile(source *v1alpha1api20201201storage.TerminateNotificationProfile) error {

	// Enable
	if source.Enable != nil {
		enable := *source.Enable
		terminateNotificationProfile.Enable = &enable
	} else {
		terminateNotificationProfile.Enable = nil
	}

	// NotBeforeTimeout
	if source.NotBeforeTimeout != nil {
		notBeforeTimeout := *source.NotBeforeTimeout
		terminateNotificationProfile.NotBeforeTimeout = &notBeforeTimeout
	} else {
		terminateNotificationProfile.NotBeforeTimeout = nil
	}

	// No error
	return nil
}

// AssignPropertiesToTerminateNotificationProfile populates the provided destination TerminateNotificationProfile from our TerminateNotificationProfile
func (terminateNotificationProfile *TerminateNotificationProfile) AssignPropertiesToTerminateNotificationProfile(destination *v1alpha1api20201201storage.TerminateNotificationProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enable
	if terminateNotificationProfile.Enable != nil {
		enable := *terminateNotificationProfile.Enable
		destination.Enable = &enable
	} else {
		destination.Enable = nil
	}

	// NotBeforeTimeout
	if terminateNotificationProfile.NotBeforeTimeout != nil {
		notBeforeTimeout := *terminateNotificationProfile.NotBeforeTimeout
		destination.NotBeforeTimeout = &notBeforeTimeout
	} else {
		destination.NotBeforeTimeout = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type TerminateNotificationProfile_Status struct {
	//Enable: Specifies whether the Terminate Scheduled event is enabled or disabled.
	Enable *bool `json:"enable,omitempty"`

	//NotBeforeTimeout: Configurable length of time a Virtual Machine being deleted
	//will have to potentially approve the Terminate Scheduled Event before the event
	//is auto approved (timed out). The configuration must be specified in ISO 8601
	//format, the default value is 5 minutes (PT5M)
	NotBeforeTimeout *string `json:"notBeforeTimeout,omitempty"`
}

var _ genruntime.FromARMConverter = &TerminateNotificationProfile_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (terminateNotificationProfileStatus *TerminateNotificationProfile_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &TerminateNotificationProfile_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (terminateNotificationProfileStatus *TerminateNotificationProfile_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(TerminateNotificationProfile_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected TerminateNotificationProfile_StatusARM, got %T", armInput)
	}

	// Set property ‘Enable’:
	if typedInput.Enable != nil {
		enable := *typedInput.Enable
		terminateNotificationProfileStatus.Enable = &enable
	}

	// Set property ‘NotBeforeTimeout’:
	if typedInput.NotBeforeTimeout != nil {
		notBeforeTimeout := *typedInput.NotBeforeTimeout
		terminateNotificationProfileStatus.NotBeforeTimeout = &notBeforeTimeout
	}

	// No error
	return nil
}

// AssignPropertiesFromTerminateNotificationProfileStatus populates our TerminateNotificationProfile_Status from the provided source TerminateNotificationProfile_Status
func (terminateNotificationProfileStatus *TerminateNotificationProfile_Status) AssignPropertiesFromTerminateNotificationProfileStatus(source *v1alpha1api20201201storage.TerminateNotificationProfile_Status) error {

	// Enable
	if source.Enable != nil {
		enable := *source.Enable
		terminateNotificationProfileStatus.Enable = &enable
	} else {
		terminateNotificationProfileStatus.Enable = nil
	}

	// NotBeforeTimeout
	if source.NotBeforeTimeout != nil {
		notBeforeTimeout := *source.NotBeforeTimeout
		terminateNotificationProfileStatus.NotBeforeTimeout = &notBeforeTimeout
	} else {
		terminateNotificationProfileStatus.NotBeforeTimeout = nil
	}

	// No error
	return nil
}

// AssignPropertiesToTerminateNotificationProfileStatus populates the provided destination TerminateNotificationProfile_Status from our TerminateNotificationProfile_Status
func (terminateNotificationProfileStatus *TerminateNotificationProfile_Status) AssignPropertiesToTerminateNotificationProfileStatus(destination *v1alpha1api20201201storage.TerminateNotificationProfile_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enable
	if terminateNotificationProfileStatus.Enable != nil {
		enable := *terminateNotificationProfileStatus.Enable
		destination.Enable = &enable
	} else {
		destination.Enable = nil
	}

	// NotBeforeTimeout
	if terminateNotificationProfileStatus.NotBeforeTimeout != nil {
		notBeforeTimeout := *terminateNotificationProfileStatus.NotBeforeTimeout
		destination.NotBeforeTimeout = &notBeforeTimeout
	} else {
		destination.NotBeforeTimeout = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/UefiSettings
type UefiSettings struct {
	//SecureBootEnabled: Specifies whether secure boot should be enabled on the
	//virtual machine.
	//Minimum api-version: 2020-12-01
	SecureBootEnabled *bool `json:"secureBootEnabled,omitempty"`

	//VTpmEnabled: Specifies whether vTPM should be enabled on the virtual machine.
	//Minimum api-version: 2020-12-01
	VTpmEnabled *bool `json:"vTpmEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &UefiSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (uefiSettings *UefiSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if uefiSettings == nil {
		return nil, nil
	}
	var result UefiSettingsARM

	// Set property ‘SecureBootEnabled’:
	if uefiSettings.SecureBootEnabled != nil {
		secureBootEnabled := *uefiSettings.SecureBootEnabled
		result.SecureBootEnabled = &secureBootEnabled
	}

	// Set property ‘VTpmEnabled’:
	if uefiSettings.VTpmEnabled != nil {
		vTpmEnabled := *uefiSettings.VTpmEnabled
		result.VTpmEnabled = &vTpmEnabled
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (uefiSettings *UefiSettings) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &UefiSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (uefiSettings *UefiSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UefiSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UefiSettingsARM, got %T", armInput)
	}

	// Set property ‘SecureBootEnabled’:
	if typedInput.SecureBootEnabled != nil {
		secureBootEnabled := *typedInput.SecureBootEnabled
		uefiSettings.SecureBootEnabled = &secureBootEnabled
	}

	// Set property ‘VTpmEnabled’:
	if typedInput.VTpmEnabled != nil {
		vTpmEnabled := *typedInput.VTpmEnabled
		uefiSettings.VTpmEnabled = &vTpmEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromUefiSettings populates our UefiSettings from the provided source UefiSettings
func (uefiSettings *UefiSettings) AssignPropertiesFromUefiSettings(source *v1alpha1api20201201storage.UefiSettings) error {

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		uefiSettings.SecureBootEnabled = &secureBootEnabled
	} else {
		uefiSettings.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		uefiSettings.VTpmEnabled = &vTpmEnabled
	} else {
		uefiSettings.VTpmEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUefiSettings populates the provided destination UefiSettings from our UefiSettings
func (uefiSettings *UefiSettings) AssignPropertiesToUefiSettings(destination *v1alpha1api20201201storage.UefiSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecureBootEnabled
	if uefiSettings.SecureBootEnabled != nil {
		secureBootEnabled := *uefiSettings.SecureBootEnabled
		destination.SecureBootEnabled = &secureBootEnabled
	} else {
		destination.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if uefiSettings.VTpmEnabled != nil {
		vTpmEnabled := *uefiSettings.VTpmEnabled
		destination.VTpmEnabled = &vTpmEnabled
	} else {
		destination.VTpmEnabled = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type UefiSettings_Status struct {
	//SecureBootEnabled: Specifies whether secure boot should be enabled on the
	//virtual machine.
	//Minimum api-version: 2020-12-01
	SecureBootEnabled *bool `json:"secureBootEnabled,omitempty"`

	//VTpmEnabled: Specifies whether vTPM should be enabled on the virtual machine.
	//Minimum api-version: 2020-12-01
	VTpmEnabled *bool `json:"vTpmEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &UefiSettings_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (uefiSettingsStatus *UefiSettings_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &UefiSettings_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (uefiSettingsStatus *UefiSettings_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UefiSettings_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UefiSettings_StatusARM, got %T", armInput)
	}

	// Set property ‘SecureBootEnabled’:
	if typedInput.SecureBootEnabled != nil {
		secureBootEnabled := *typedInput.SecureBootEnabled
		uefiSettingsStatus.SecureBootEnabled = &secureBootEnabled
	}

	// Set property ‘VTpmEnabled’:
	if typedInput.VTpmEnabled != nil {
		vTpmEnabled := *typedInput.VTpmEnabled
		uefiSettingsStatus.VTpmEnabled = &vTpmEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromUefiSettingsStatus populates our UefiSettings_Status from the provided source UefiSettings_Status
func (uefiSettingsStatus *UefiSettings_Status) AssignPropertiesFromUefiSettingsStatus(source *v1alpha1api20201201storage.UefiSettings_Status) error {

	// SecureBootEnabled
	if source.SecureBootEnabled != nil {
		secureBootEnabled := *source.SecureBootEnabled
		uefiSettingsStatus.SecureBootEnabled = &secureBootEnabled
	} else {
		uefiSettingsStatus.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if source.VTpmEnabled != nil {
		vTpmEnabled := *source.VTpmEnabled
		uefiSettingsStatus.VTpmEnabled = &vTpmEnabled
	} else {
		uefiSettingsStatus.VTpmEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUefiSettingsStatus populates the provided destination UefiSettings_Status from our UefiSettings_Status
func (uefiSettingsStatus *UefiSettings_Status) AssignPropertiesToUefiSettingsStatus(destination *v1alpha1api20201201storage.UefiSettings_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SecureBootEnabled
	if uefiSettingsStatus.SecureBootEnabled != nil {
		secureBootEnabled := *uefiSettingsStatus.SecureBootEnabled
		destination.SecureBootEnabled = &secureBootEnabled
	} else {
		destination.SecureBootEnabled = nil
	}

	// VTpmEnabled
	if uefiSettingsStatus.VTpmEnabled != nil {
		vTpmEnabled := *uefiSettingsStatus.VTpmEnabled
		destination.VTpmEnabled = &vTpmEnabled
	} else {
		destination.VTpmEnabled = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VaultSecretGroup
type VaultSecretGroup struct {
	SourceVault *SubResource `json:"sourceVault,omitempty"`

	//VaultCertificates: The list of key vault references in SourceVault which contain
	//certificates.
	VaultCertificates []VaultCertificate `json:"vaultCertificates,omitempty"`
}

var _ genruntime.ARMTransformer = &VaultSecretGroup{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (vaultSecretGroup *VaultSecretGroup) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if vaultSecretGroup == nil {
		return nil, nil
	}
	var result VaultSecretGroupARM

	// Set property ‘SourceVault’:
	if vaultSecretGroup.SourceVault != nil {
		sourceVaultARM, err := (*vaultSecretGroup.SourceVault).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sourceVault := sourceVaultARM.(SubResourceARM)
		result.SourceVault = &sourceVault
	}

	// Set property ‘VaultCertificates’:
	for _, item := range vaultSecretGroup.VaultCertificates {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.VaultCertificates = append(result.VaultCertificates, itemARM.(VaultCertificateARM))
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vaultSecretGroup *VaultSecretGroup) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VaultSecretGroupARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vaultSecretGroup *VaultSecretGroup) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VaultSecretGroupARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VaultSecretGroupARM, got %T", armInput)
	}

	// Set property ‘SourceVault’:
	if typedInput.SourceVault != nil {
		var sourceVault1 SubResource
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		vaultSecretGroup.SourceVault = &sourceVault
	}

	// Set property ‘VaultCertificates’:
	for _, item := range typedInput.VaultCertificates {
		var item1 VaultCertificate
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		vaultSecretGroup.VaultCertificates = append(vaultSecretGroup.VaultCertificates, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromVaultSecretGroup populates our VaultSecretGroup from the provided source VaultSecretGroup
func (vaultSecretGroup *VaultSecretGroup) AssignPropertiesFromVaultSecretGroup(source *v1alpha1api20201201storage.VaultSecretGroup) error {

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource
		err := sourceVault.AssignPropertiesFromSubResource(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesFromSubResource()")
		}
		vaultSecretGroup.SourceVault = &sourceVault
	} else {
		vaultSecretGroup.SourceVault = nil
	}

	// VaultCertificates
	vaultCertificateList := make([]VaultCertificate, len(source.VaultCertificates))
	for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
		// Shadow the loop variable to avoid aliasing
		vaultCertificateItem := vaultCertificateItem
		var vaultCertificate VaultCertificate
		err := vaultCertificate.AssignPropertiesFromVaultCertificate(&vaultCertificateItem)
		if err != nil {
			return errors.Wrap(err, "populating VaultCertificates from VaultCertificates, calling AssignPropertiesFromVaultCertificate()")
		}
		vaultCertificateList[vaultCertificateIndex] = vaultCertificate
	}
	vaultSecretGroup.VaultCertificates = vaultCertificateList

	// No error
	return nil
}

// AssignPropertiesToVaultSecretGroup populates the provided destination VaultSecretGroup from our VaultSecretGroup
func (vaultSecretGroup *VaultSecretGroup) AssignPropertiesToVaultSecretGroup(destination *v1alpha1api20201201storage.VaultSecretGroup) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SourceVault
	if vaultSecretGroup.SourceVault != nil {
		var sourceVault v1alpha1api20201201storage.SubResource
		err := (*vaultSecretGroup.SourceVault).AssignPropertiesToSubResource(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesToSubResource()")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// VaultCertificates
	vaultCertificateList := make([]v1alpha1api20201201storage.VaultCertificate, len(vaultSecretGroup.VaultCertificates))
	for vaultCertificateIndex, vaultCertificateItem := range vaultSecretGroup.VaultCertificates {
		// Shadow the loop variable to avoid aliasing
		vaultCertificateItem := vaultCertificateItem
		var vaultCertificate v1alpha1api20201201storage.VaultCertificate
		err := vaultCertificateItem.AssignPropertiesToVaultCertificate(&vaultCertificate)
		if err != nil {
			return errors.Wrap(err, "populating VaultCertificates from VaultCertificates, calling AssignPropertiesToVaultCertificate()")
		}
		vaultCertificateList[vaultCertificateIndex] = vaultCertificate
	}
	destination.VaultCertificates = vaultCertificateList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VaultSecretGroup_Status struct {
	//SourceVault: The relative URL of the Key Vault containing all of the
	//certificates in VaultCertificates.
	SourceVault *SubResource_Status `json:"sourceVault,omitempty"`

	//VaultCertificates: The list of key vault references in SourceVault which contain
	//certificates.
	VaultCertificates []VaultCertificate_Status `json:"vaultCertificates,omitempty"`
}

var _ genruntime.FromARMConverter = &VaultSecretGroup_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vaultSecretGroupStatus *VaultSecretGroup_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VaultSecretGroup_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vaultSecretGroupStatus *VaultSecretGroup_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VaultSecretGroup_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VaultSecretGroup_StatusARM, got %T", armInput)
	}

	// Set property ‘SourceVault’:
	if typedInput.SourceVault != nil {
		var sourceVault1 SubResource_Status
		err := sourceVault1.PopulateFromARM(owner, *typedInput.SourceVault)
		if err != nil {
			return err
		}
		sourceVault := sourceVault1
		vaultSecretGroupStatus.SourceVault = &sourceVault
	}

	// Set property ‘VaultCertificates’:
	for _, item := range typedInput.VaultCertificates {
		var item1 VaultCertificate_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		vaultSecretGroupStatus.VaultCertificates = append(vaultSecretGroupStatus.VaultCertificates, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromVaultSecretGroupStatus populates our VaultSecretGroup_Status from the provided source VaultSecretGroup_Status
func (vaultSecretGroupStatus *VaultSecretGroup_Status) AssignPropertiesFromVaultSecretGroupStatus(source *v1alpha1api20201201storage.VaultSecretGroup_Status) error {

	// SourceVault
	if source.SourceVault != nil {
		var sourceVault SubResource_Status
		err := sourceVault.AssignPropertiesFromSubResourceStatus(source.SourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesFromSubResourceStatus()")
		}
		vaultSecretGroupStatus.SourceVault = &sourceVault
	} else {
		vaultSecretGroupStatus.SourceVault = nil
	}

	// VaultCertificates
	vaultCertificateList := make([]VaultCertificate_Status, len(source.VaultCertificates))
	for vaultCertificateIndex, vaultCertificateItem := range source.VaultCertificates {
		// Shadow the loop variable to avoid aliasing
		vaultCertificateItem := vaultCertificateItem
		var vaultCertificate VaultCertificate_Status
		err := vaultCertificate.AssignPropertiesFromVaultCertificateStatus(&vaultCertificateItem)
		if err != nil {
			return errors.Wrap(err, "populating VaultCertificates from VaultCertificates, calling AssignPropertiesFromVaultCertificateStatus()")
		}
		vaultCertificateList[vaultCertificateIndex] = vaultCertificate
	}
	vaultSecretGroupStatus.VaultCertificates = vaultCertificateList

	// No error
	return nil
}

// AssignPropertiesToVaultSecretGroupStatus populates the provided destination VaultSecretGroup_Status from our VaultSecretGroup_Status
func (vaultSecretGroupStatus *VaultSecretGroup_Status) AssignPropertiesToVaultSecretGroupStatus(destination *v1alpha1api20201201storage.VaultSecretGroup_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// SourceVault
	if vaultSecretGroupStatus.SourceVault != nil {
		var sourceVault v1alpha1api20201201storage.SubResource_Status
		err := (*vaultSecretGroupStatus.SourceVault).AssignPropertiesToSubResourceStatus(&sourceVault)
		if err != nil {
			return errors.Wrap(err, "populating SourceVault from SourceVault, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.SourceVault = &sourceVault
	} else {
		destination.SourceVault = nil
	}

	// VaultCertificates
	vaultCertificateList := make([]v1alpha1api20201201storage.VaultCertificate_Status, len(vaultSecretGroupStatus.VaultCertificates))
	for vaultCertificateIndex, vaultCertificateItem := range vaultSecretGroupStatus.VaultCertificates {
		// Shadow the loop variable to avoid aliasing
		vaultCertificateItem := vaultCertificateItem
		var vaultCertificate v1alpha1api20201201storage.VaultCertificate_Status
		err := vaultCertificateItem.AssignPropertiesToVaultCertificateStatus(&vaultCertificate)
		if err != nil {
			return errors.Wrap(err, "populating VaultCertificates from VaultCertificates, calling AssignPropertiesToVaultCertificateStatus()")
		}
		vaultCertificateList[vaultCertificateIndex] = vaultCertificate
	}
	destination.VaultCertificates = vaultCertificateList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VirtualMachineScaleSetDataDisk
type VirtualMachineScaleSetDataDisk struct {
	//Caching: Specifies the caching requirements.
	//Possible values are:
	//None
	//ReadOnly
	//ReadWrite
	//Default: None for Standard storage. ReadOnly for Premium storage.
	Caching *VirtualMachineScaleSetDataDiskCaching `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	//CreateOption: The create option.
	CreateOption VirtualMachineScaleSetDataDiskCreateOption `json:"createOption"`

	//DiskIOPSReadWrite: Specifies the Read-Write IOPS for the managed disk. Should be
	//used only when StorageAccountType is UltraSSD_LRS. If not specified, a default
	//value would be assigned based on diskSizeGB.
	DiskIOPSReadWrite *int `json:"diskIOPSReadWrite,omitempty"`

	//DiskMBpsReadWrite: Specifies the bandwidth in MB per second for the managed
	//disk. Should be used only when StorageAccountType is UltraSSD_LRS. If not
	//specified, a default value would be assigned based on diskSizeGB.
	DiskMBpsReadWrite *int `json:"diskMBpsReadWrite,omitempty"`

	//DiskSizeGB: Specifies the size of an empty data disk in gigabytes. This element
	//can be used to overwrite the size of the disk in a virtual machine image.
	//This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// +kubebuilder:validation:Required
	//Lun: Specifies the logical unit number of the data disk. This value is used to
	//identify data disks within the VM and therefore must be unique for each data
	//disk attached to a VM.
	Lun int `json:"lun"`

	//ManagedDisk: Describes the parameters of a ScaleSet managed disk.
	ManagedDisk *VirtualMachineScaleSetManagedDiskParameters `json:"managedDisk,omitempty"`

	//Name: The disk name.
	Name *string `json:"name,omitempty"`

	//WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or
	//disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetDataDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetDataDisk *VirtualMachineScaleSetDataDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetDataDisk == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetDataDiskARM

	// Set property ‘Caching’:
	if virtualMachineScaleSetDataDisk.Caching != nil {
		caching := *virtualMachineScaleSetDataDisk.Caching
		result.Caching = &caching
	}

	// Set property ‘CreateOption’:
	result.CreateOption = virtualMachineScaleSetDataDisk.CreateOption

	// Set property ‘DiskIOPSReadWrite’:
	if virtualMachineScaleSetDataDisk.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *virtualMachineScaleSetDataDisk.DiskIOPSReadWrite
		result.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property ‘DiskMBpsReadWrite’:
	if virtualMachineScaleSetDataDisk.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *virtualMachineScaleSetDataDisk.DiskMBpsReadWrite
		result.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property ‘DiskSizeGB’:
	if virtualMachineScaleSetDataDisk.DiskSizeGB != nil {
		diskSizeGB := *virtualMachineScaleSetDataDisk.DiskSizeGB
		result.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Lun’:
	result.Lun = virtualMachineScaleSetDataDisk.Lun

	// Set property ‘ManagedDisk’:
	if virtualMachineScaleSetDataDisk.ManagedDisk != nil {
		managedDiskARM, err := (*virtualMachineScaleSetDataDisk.ManagedDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := managedDiskARM.(VirtualMachineScaleSetManagedDiskParametersARM)
		result.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if virtualMachineScaleSetDataDisk.Name != nil {
		name := *virtualMachineScaleSetDataDisk.Name
		result.Name = &name
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if virtualMachineScaleSetDataDisk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *virtualMachineScaleSetDataDisk.WriteAcceleratorEnabled
		result.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetDataDisk *VirtualMachineScaleSetDataDisk) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetDataDiskARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetDataDisk *VirtualMachineScaleSetDataDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetDataDiskARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetDataDiskARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		virtualMachineScaleSetDataDisk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	virtualMachineScaleSetDataDisk.CreateOption = typedInput.CreateOption

	// Set property ‘DiskIOPSReadWrite’:
	if typedInput.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *typedInput.DiskIOPSReadWrite
		virtualMachineScaleSetDataDisk.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property ‘DiskMBpsReadWrite’:
	if typedInput.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *typedInput.DiskMBpsReadWrite
		virtualMachineScaleSetDataDisk.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		virtualMachineScaleSetDataDisk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Lun’:
	virtualMachineScaleSetDataDisk.Lun = typedInput.Lun

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		virtualMachineScaleSetDataDisk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		virtualMachineScaleSetDataDisk.Name = &name
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		virtualMachineScaleSetDataDisk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetDataDisk populates our VirtualMachineScaleSetDataDisk from the provided source VirtualMachineScaleSetDataDisk
func (virtualMachineScaleSetDataDisk *VirtualMachineScaleSetDataDisk) AssignPropertiesFromVirtualMachineScaleSetDataDisk(source *v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk) error {

	// Caching
	if source.Caching != nil {
		caching := VirtualMachineScaleSetDataDiskCaching(*source.Caching)
		virtualMachineScaleSetDataDisk.Caching = &caching
	} else {
		virtualMachineScaleSetDataDisk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		virtualMachineScaleSetDataDisk.CreateOption = VirtualMachineScaleSetDataDiskCreateOption(*source.CreateOption)
	} else {
		virtualMachineScaleSetDataDisk.CreateOption = ""
	}

	// DiskIOPSReadWrite
	if source.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *source.DiskIOPSReadWrite
		virtualMachineScaleSetDataDisk.DiskIOPSReadWrite = &diskIOPSReadWrite
	} else {
		virtualMachineScaleSetDataDisk.DiskIOPSReadWrite = nil
	}

	// DiskMBpsReadWrite
	if source.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *source.DiskMBpsReadWrite
		virtualMachineScaleSetDataDisk.DiskMBpsReadWrite = &diskMBpsReadWrite
	} else {
		virtualMachineScaleSetDataDisk.DiskMBpsReadWrite = nil
	}

	// DiskSizeGB
	if source.DiskSizeGB != nil {
		diskSizeGB := *source.DiskSizeGB
		virtualMachineScaleSetDataDisk.DiskSizeGB = &diskSizeGB
	} else {
		virtualMachineScaleSetDataDisk.DiskSizeGB = nil
	}

	// Lun
	if source.Lun != nil {
		virtualMachineScaleSetDataDisk.Lun = *source.Lun
	} else {
		virtualMachineScaleSetDataDisk.Lun = 0
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters()")
		}
		virtualMachineScaleSetDataDisk.ManagedDisk = &managedDisk
	} else {
		virtualMachineScaleSetDataDisk.ManagedDisk = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		virtualMachineScaleSetDataDisk.Name = &name
	} else {
		virtualMachineScaleSetDataDisk.Name = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		virtualMachineScaleSetDataDisk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		virtualMachineScaleSetDataDisk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetDataDisk populates the provided destination VirtualMachineScaleSetDataDisk from our VirtualMachineScaleSetDataDisk
func (virtualMachineScaleSetDataDisk *VirtualMachineScaleSetDataDisk) AssignPropertiesToVirtualMachineScaleSetDataDisk(destination *v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if virtualMachineScaleSetDataDisk.Caching != nil {
		caching := string(*virtualMachineScaleSetDataDisk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	createOption := string(virtualMachineScaleSetDataDisk.CreateOption)
	destination.CreateOption = &createOption

	// DiskIOPSReadWrite
	if virtualMachineScaleSetDataDisk.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *virtualMachineScaleSetDataDisk.DiskIOPSReadWrite
		destination.DiskIOPSReadWrite = &diskIOPSReadWrite
	} else {
		destination.DiskIOPSReadWrite = nil
	}

	// DiskMBpsReadWrite
	if virtualMachineScaleSetDataDisk.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *virtualMachineScaleSetDataDisk.DiskMBpsReadWrite
		destination.DiskMBpsReadWrite = &diskMBpsReadWrite
	} else {
		destination.DiskMBpsReadWrite = nil
	}

	// DiskSizeGB
	if virtualMachineScaleSetDataDisk.DiskSizeGB != nil {
		diskSizeGB := *virtualMachineScaleSetDataDisk.DiskSizeGB
		destination.DiskSizeGB = &diskSizeGB
	} else {
		destination.DiskSizeGB = nil
	}

	// Lun
	lun := virtualMachineScaleSetDataDisk.Lun
	destination.Lun = &lun

	// ManagedDisk
	if virtualMachineScaleSetDataDisk.ManagedDisk != nil {
		var managedDisk v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters
		err := (*virtualMachineScaleSetDataDisk.ManagedDisk).AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters()")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	if virtualMachineScaleSetDataDisk.Name != nil {
		name := *virtualMachineScaleSetDataDisk.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// WriteAcceleratorEnabled
	if virtualMachineScaleSetDataDisk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *virtualMachineScaleSetDataDisk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VirtualMachineScaleSetDataDisk_Status struct {
	//Caching: Specifies the caching requirements.
	//Possible values are:
	//None
	//ReadOnly
	//ReadWrite
	//Default: None for Standard storage. ReadOnly for Premium storage
	Caching *Caching_Status `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	//CreateOption: The create option.
	CreateOption CreateOption_Status `json:"createOption"`

	//DiskIOPSReadWrite: Specifies the Read-Write IOPS for the managed disk. Should be
	//used only when StorageAccountType is UltraSSD_LRS. If not specified, a default
	//value would be assigned based on diskSizeGB.
	DiskIOPSReadWrite *int `json:"diskIOPSReadWrite,omitempty"`

	//DiskMBpsReadWrite: Specifies the bandwidth in MB per second for the managed
	//disk. Should be used only when StorageAccountType is UltraSSD_LRS. If not
	//specified, a default value would be assigned based on diskSizeGB.
	DiskMBpsReadWrite *int `json:"diskMBpsReadWrite,omitempty"`

	//DiskSizeGB: Specifies the size of an empty data disk in gigabytes. This element
	//can be used to overwrite the size of the disk in a virtual machine image.
	//This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	// +kubebuilder:validation:Required
	//Lun: Specifies the logical unit number of the data disk. This value is used to
	//identify data disks within the VM and therefore must be unique for each data
	//disk attached to a VM.
	Lun int `json:"lun"`

	//ManagedDisk: The managed disk parameters.
	ManagedDisk *VirtualMachineScaleSetManagedDiskParameters_Status `json:"managedDisk,omitempty"`

	//Name: The disk name.
	Name *string `json:"name,omitempty"`

	//WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or
	//disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetDataDisk_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetDataDiskStatus *VirtualMachineScaleSetDataDisk_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetDataDisk_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetDataDiskStatus *VirtualMachineScaleSetDataDisk_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetDataDisk_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetDataDisk_StatusARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		virtualMachineScaleSetDataDiskStatus.Caching = &caching
	}

	// Set property ‘CreateOption’:
	virtualMachineScaleSetDataDiskStatus.CreateOption = typedInput.CreateOption

	// Set property ‘DiskIOPSReadWrite’:
	if typedInput.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *typedInput.DiskIOPSReadWrite
		virtualMachineScaleSetDataDiskStatus.DiskIOPSReadWrite = &diskIOPSReadWrite
	}

	// Set property ‘DiskMBpsReadWrite’:
	if typedInput.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *typedInput.DiskMBpsReadWrite
		virtualMachineScaleSetDataDiskStatus.DiskMBpsReadWrite = &diskMBpsReadWrite
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		virtualMachineScaleSetDataDiskStatus.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Lun’:
	virtualMachineScaleSetDataDiskStatus.Lun = typedInput.Lun

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters_Status
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		virtualMachineScaleSetDataDiskStatus.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		virtualMachineScaleSetDataDiskStatus.Name = &name
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		virtualMachineScaleSetDataDiskStatus.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetDataDiskStatus populates our VirtualMachineScaleSetDataDisk_Status from the provided source VirtualMachineScaleSetDataDisk_Status
func (virtualMachineScaleSetDataDiskStatus *VirtualMachineScaleSetDataDisk_Status) AssignPropertiesFromVirtualMachineScaleSetDataDiskStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Status) error {

	// Caching
	if source.Caching != nil {
		caching := Caching_Status(*source.Caching)
		virtualMachineScaleSetDataDiskStatus.Caching = &caching
	} else {
		virtualMachineScaleSetDataDiskStatus.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		virtualMachineScaleSetDataDiskStatus.CreateOption = CreateOption_Status(*source.CreateOption)
	} else {
		virtualMachineScaleSetDataDiskStatus.CreateOption = ""
	}

	// DiskIOPSReadWrite
	if source.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *source.DiskIOPSReadWrite
		virtualMachineScaleSetDataDiskStatus.DiskIOPSReadWrite = &diskIOPSReadWrite
	} else {
		virtualMachineScaleSetDataDiskStatus.DiskIOPSReadWrite = nil
	}

	// DiskMBpsReadWrite
	if source.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *source.DiskMBpsReadWrite
		virtualMachineScaleSetDataDiskStatus.DiskMBpsReadWrite = &diskMBpsReadWrite
	} else {
		virtualMachineScaleSetDataDiskStatus.DiskMBpsReadWrite = nil
	}

	// DiskSizeGB
	if source.DiskSizeGB != nil {
		diskSizeGB := *source.DiskSizeGB
		virtualMachineScaleSetDataDiskStatus.DiskSizeGB = &diskSizeGB
	} else {
		virtualMachineScaleSetDataDiskStatus.DiskSizeGB = nil
	}

	// Lun
	if source.Lun != nil {
		virtualMachineScaleSetDataDiskStatus.Lun = *source.Lun
	} else {
		virtualMachineScaleSetDataDiskStatus.Lun = 0
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters_Status
		err := managedDisk.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersStatus(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersStatus()")
		}
		virtualMachineScaleSetDataDiskStatus.ManagedDisk = &managedDisk
	} else {
		virtualMachineScaleSetDataDiskStatus.ManagedDisk = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		virtualMachineScaleSetDataDiskStatus.Name = &name
	} else {
		virtualMachineScaleSetDataDiskStatus.Name = nil
	}

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		virtualMachineScaleSetDataDiskStatus.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		virtualMachineScaleSetDataDiskStatus.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetDataDiskStatus populates the provided destination VirtualMachineScaleSetDataDisk_Status from our VirtualMachineScaleSetDataDisk_Status
func (virtualMachineScaleSetDataDiskStatus *VirtualMachineScaleSetDataDisk_Status) AssignPropertiesToVirtualMachineScaleSetDataDiskStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetDataDisk_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if virtualMachineScaleSetDataDiskStatus.Caching != nil {
		caching := string(*virtualMachineScaleSetDataDiskStatus.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	createOption := string(virtualMachineScaleSetDataDiskStatus.CreateOption)
	destination.CreateOption = &createOption

	// DiskIOPSReadWrite
	if virtualMachineScaleSetDataDiskStatus.DiskIOPSReadWrite != nil {
		diskIOPSReadWrite := *virtualMachineScaleSetDataDiskStatus.DiskIOPSReadWrite
		destination.DiskIOPSReadWrite = &diskIOPSReadWrite
	} else {
		destination.DiskIOPSReadWrite = nil
	}

	// DiskMBpsReadWrite
	if virtualMachineScaleSetDataDiskStatus.DiskMBpsReadWrite != nil {
		diskMBpsReadWrite := *virtualMachineScaleSetDataDiskStatus.DiskMBpsReadWrite
		destination.DiskMBpsReadWrite = &diskMBpsReadWrite
	} else {
		destination.DiskMBpsReadWrite = nil
	}

	// DiskSizeGB
	if virtualMachineScaleSetDataDiskStatus.DiskSizeGB != nil {
		diskSizeGB := *virtualMachineScaleSetDataDiskStatus.DiskSizeGB
		destination.DiskSizeGB = &diskSizeGB
	} else {
		destination.DiskSizeGB = nil
	}

	// Lun
	lun := virtualMachineScaleSetDataDiskStatus.Lun
	destination.Lun = &lun

	// ManagedDisk
	if virtualMachineScaleSetDataDiskStatus.ManagedDisk != nil {
		var managedDisk v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Status
		err := (*virtualMachineScaleSetDataDiskStatus.ManagedDisk).AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersStatus(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersStatus()")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	if virtualMachineScaleSetDataDiskStatus.Name != nil {
		name := *virtualMachineScaleSetDataDiskStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// WriteAcceleratorEnabled
	if virtualMachineScaleSetDataDiskStatus.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *virtualMachineScaleSetDataDiskStatus.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VirtualMachineScaleSetExtension_Status struct {
	//AutoUpgradeMinorVersion: Indicates whether the extension should use a newer
	//minor version if one is available at deployment time. Once deployed, however,
	//the extension will not upgrade minor versions unless redeployed, even with this
	//property set to true.
	AutoUpgradeMinorVersion *bool `json:"autoUpgradeMinorVersion,omitempty"`

	//EnableAutomaticUpgrade: Indicates whether the extension should be automatically
	//upgraded by the platform if there is a newer version of the extension available.
	EnableAutomaticUpgrade *bool `json:"enableAutomaticUpgrade,omitempty"`

	//ForceUpdateTag: If a value is provided and is different from the previous value,
	//the extension handler will be forced to update even if the extension
	//configuration has not changed.
	ForceUpdateTag *string `json:"forceUpdateTag,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//Name: The name of the extension.
	Name *string `json:"name,omitempty"`

	//PropertiesType: Specifies the type of the extension; an example is
	//"CustomScriptExtension".
	PropertiesType *string `json:"properties_type,omitempty"`

	//ProtectedSettings: The extension can contain either protectedSettings or
	//protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings map[string]v1.JSON `json:"protectedSettings,omitempty"`

	//ProvisionAfterExtensions: Collection of extension names after which this
	//extension needs to be provisioned.
	ProvisionAfterExtensions []string `json:"provisionAfterExtensions,omitempty"`

	//ProvisioningState: The provisioning state, which only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	//Publisher: The name of the extension handler publisher.
	Publisher *string `json:"publisher,omitempty"`

	//Settings: Json formatted public settings for the extension.
	Settings map[string]v1.JSON `json:"settings,omitempty"`

	//Type: Resource type
	Type *string `json:"type,omitempty"`

	//TypeHandlerVersion: Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetExtension_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetExtensionStatus *VirtualMachineScaleSetExtension_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetExtension_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetExtensionStatus *VirtualMachineScaleSetExtension_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetExtension_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetExtension_StatusARM, got %T", armInput)
	}

	// Set property ‘AutoUpgradeMinorVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AutoUpgradeMinorVersion != nil {
			autoUpgradeMinorVersion := *typedInput.Properties.AutoUpgradeMinorVersion
			virtualMachineScaleSetExtensionStatus.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
		}
	}

	// Set property ‘EnableAutomaticUpgrade’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAutomaticUpgrade != nil {
			enableAutomaticUpgrade := *typedInput.Properties.EnableAutomaticUpgrade
			virtualMachineScaleSetExtensionStatus.EnableAutomaticUpgrade = &enableAutomaticUpgrade
		}
	}

	// Set property ‘ForceUpdateTag’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ForceUpdateTag != nil {
			forceUpdateTag := *typedInput.Properties.ForceUpdateTag
			virtualMachineScaleSetExtensionStatus.ForceUpdateTag = &forceUpdateTag
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		virtualMachineScaleSetExtensionStatus.Id = &id
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		virtualMachineScaleSetExtensionStatus.Name = &name
	}

	// Set property ‘PropertiesType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Type != nil {
			propertiesType := *typedInput.Properties.Type
			virtualMachineScaleSetExtensionStatus.PropertiesType = &propertiesType
		}
	}

	// Set property ‘ProtectedSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProtectedSettings != nil {
			virtualMachineScaleSetExtensionStatus.ProtectedSettings = make(map[string]v1.JSON)
			for key, value := range typedInput.Properties.ProtectedSettings {
				virtualMachineScaleSetExtensionStatus.ProtectedSettings[key] = *value.DeepCopy()
			}
		}
	}

	// Set property ‘ProvisionAfterExtensions’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ProvisionAfterExtensions {
			virtualMachineScaleSetExtensionStatus.ProvisionAfterExtensions = append(virtualMachineScaleSetExtensionStatus.ProvisionAfterExtensions, item)
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			virtualMachineScaleSetExtensionStatus.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘Publisher’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Publisher != nil {
			publisher := *typedInput.Properties.Publisher
			virtualMachineScaleSetExtensionStatus.Publisher = &publisher
		}
	}

	// Set property ‘Settings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Settings != nil {
			virtualMachineScaleSetExtensionStatus.Settings = make(map[string]v1.JSON)
			for key, value := range typedInput.Properties.Settings {
				virtualMachineScaleSetExtensionStatus.Settings[key] = *value.DeepCopy()
			}
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		virtualMachineScaleSetExtensionStatus.Type = &typeVar
	}

	// Set property ‘TypeHandlerVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TypeHandlerVersion != nil {
			typeHandlerVersion := *typedInput.Properties.TypeHandlerVersion
			virtualMachineScaleSetExtensionStatus.TypeHandlerVersion = &typeHandlerVersion
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetExtensionStatus populates our VirtualMachineScaleSetExtension_Status from the provided source VirtualMachineScaleSetExtension_Status
func (virtualMachineScaleSetExtensionStatus *VirtualMachineScaleSetExtension_Status) AssignPropertiesFromVirtualMachineScaleSetExtensionStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetExtension_Status) error {

	// AutoUpgradeMinorVersion
	if source.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *source.AutoUpgradeMinorVersion
		virtualMachineScaleSetExtensionStatus.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		virtualMachineScaleSetExtensionStatus.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if source.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *source.EnableAutomaticUpgrade
		virtualMachineScaleSetExtensionStatus.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		virtualMachineScaleSetExtensionStatus.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	if source.ForceUpdateTag != nil {
		forceUpdateTag := *source.ForceUpdateTag
		virtualMachineScaleSetExtensionStatus.ForceUpdateTag = &forceUpdateTag
	} else {
		virtualMachineScaleSetExtensionStatus.ForceUpdateTag = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		virtualMachineScaleSetExtensionStatus.Id = &id
	} else {
		virtualMachineScaleSetExtensionStatus.Id = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		virtualMachineScaleSetExtensionStatus.Name = &name
	} else {
		virtualMachineScaleSetExtensionStatus.Name = nil
	}

	// PropertiesType
	if source.PropertiesType != nil {
		propertiesType := *source.PropertiesType
		virtualMachineScaleSetExtensionStatus.PropertiesType = &propertiesType
	} else {
		virtualMachineScaleSetExtensionStatus.PropertiesType = nil
	}

	// ProtectedSettings
	protectedSettingMap := make(map[string]v1.JSON)
	for protectedSettingKey, protectedSettingValue := range source.ProtectedSettings {
		// Shadow the loop variable to avoid aliasing
		protectedSettingValue := protectedSettingValue
		protectedSettingMap[protectedSettingKey] = *protectedSettingValue.DeepCopy()
	}
	virtualMachineScaleSetExtensionStatus.ProtectedSettings = protectedSettingMap

	// ProvisionAfterExtensions
	provisionAfterExtensionList := make([]string, len(source.ProvisionAfterExtensions))
	for provisionAfterExtensionIndex, provisionAfterExtensionItem := range source.ProvisionAfterExtensions {
		// Shadow the loop variable to avoid aliasing
		provisionAfterExtensionItem := provisionAfterExtensionItem
		provisionAfterExtensionList[provisionAfterExtensionIndex] = provisionAfterExtensionItem
	}
	virtualMachineScaleSetExtensionStatus.ProvisionAfterExtensions = provisionAfterExtensionList

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		virtualMachineScaleSetExtensionStatus.ProvisioningState = &provisioningState
	} else {
		virtualMachineScaleSetExtensionStatus.ProvisioningState = nil
	}

	// Publisher
	if source.Publisher != nil {
		publisher := *source.Publisher
		virtualMachineScaleSetExtensionStatus.Publisher = &publisher
	} else {
		virtualMachineScaleSetExtensionStatus.Publisher = nil
	}

	// Settings
	settingMap := make(map[string]v1.JSON)
	for settingKey, settingValue := range source.Settings {
		// Shadow the loop variable to avoid aliasing
		settingValue := settingValue
		settingMap[settingKey] = *settingValue.DeepCopy()
	}
	virtualMachineScaleSetExtensionStatus.Settings = settingMap

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		virtualMachineScaleSetExtensionStatus.Type = &typeVar
	} else {
		virtualMachineScaleSetExtensionStatus.Type = nil
	}

	// TypeHandlerVersion
	if source.TypeHandlerVersion != nil {
		typeHandlerVersion := *source.TypeHandlerVersion
		virtualMachineScaleSetExtensionStatus.TypeHandlerVersion = &typeHandlerVersion
	} else {
		virtualMachineScaleSetExtensionStatus.TypeHandlerVersion = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetExtensionStatus populates the provided destination VirtualMachineScaleSetExtension_Status from our VirtualMachineScaleSetExtension_Status
func (virtualMachineScaleSetExtensionStatus *VirtualMachineScaleSetExtension_Status) AssignPropertiesToVirtualMachineScaleSetExtensionStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetExtension_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoUpgradeMinorVersion
	if virtualMachineScaleSetExtensionStatus.AutoUpgradeMinorVersion != nil {
		autoUpgradeMinorVersion := *virtualMachineScaleSetExtensionStatus.AutoUpgradeMinorVersion
		destination.AutoUpgradeMinorVersion = &autoUpgradeMinorVersion
	} else {
		destination.AutoUpgradeMinorVersion = nil
	}

	// EnableAutomaticUpgrade
	if virtualMachineScaleSetExtensionStatus.EnableAutomaticUpgrade != nil {
		enableAutomaticUpgrade := *virtualMachineScaleSetExtensionStatus.EnableAutomaticUpgrade
		destination.EnableAutomaticUpgrade = &enableAutomaticUpgrade
	} else {
		destination.EnableAutomaticUpgrade = nil
	}

	// ForceUpdateTag
	if virtualMachineScaleSetExtensionStatus.ForceUpdateTag != nil {
		forceUpdateTag := *virtualMachineScaleSetExtensionStatus.ForceUpdateTag
		destination.ForceUpdateTag = &forceUpdateTag
	} else {
		destination.ForceUpdateTag = nil
	}

	// Id
	if virtualMachineScaleSetExtensionStatus.Id != nil {
		id := *virtualMachineScaleSetExtensionStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// Name
	if virtualMachineScaleSetExtensionStatus.Name != nil {
		name := *virtualMachineScaleSetExtensionStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// PropertiesType
	if virtualMachineScaleSetExtensionStatus.PropertiesType != nil {
		propertiesType := *virtualMachineScaleSetExtensionStatus.PropertiesType
		destination.PropertiesType = &propertiesType
	} else {
		destination.PropertiesType = nil
	}

	// ProtectedSettings
	protectedSettingMap := make(map[string]v1.JSON)
	for protectedSettingKey, protectedSettingValue := range virtualMachineScaleSetExtensionStatus.ProtectedSettings {
		// Shadow the loop variable to avoid aliasing
		protectedSettingValue := protectedSettingValue
		protectedSettingMap[protectedSettingKey] = *protectedSettingValue.DeepCopy()
	}
	destination.ProtectedSettings = protectedSettingMap

	// ProvisionAfterExtensions
	provisionAfterExtensionList := make([]string, len(virtualMachineScaleSetExtensionStatus.ProvisionAfterExtensions))
	for provisionAfterExtensionIndex, provisionAfterExtensionItem := range virtualMachineScaleSetExtensionStatus.ProvisionAfterExtensions {
		// Shadow the loop variable to avoid aliasing
		provisionAfterExtensionItem := provisionAfterExtensionItem
		provisionAfterExtensionList[provisionAfterExtensionIndex] = provisionAfterExtensionItem
	}
	destination.ProvisionAfterExtensions = provisionAfterExtensionList

	// ProvisioningState
	if virtualMachineScaleSetExtensionStatus.ProvisioningState != nil {
		provisioningState := *virtualMachineScaleSetExtensionStatus.ProvisioningState
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Publisher
	if virtualMachineScaleSetExtensionStatus.Publisher != nil {
		publisher := *virtualMachineScaleSetExtensionStatus.Publisher
		destination.Publisher = &publisher
	} else {
		destination.Publisher = nil
	}

	// Settings
	settingMap := make(map[string]v1.JSON)
	for settingKey, settingValue := range virtualMachineScaleSetExtensionStatus.Settings {
		// Shadow the loop variable to avoid aliasing
		settingValue := settingValue
		settingMap[settingKey] = *settingValue.DeepCopy()
	}
	destination.Settings = settingMap

	// Type
	if virtualMachineScaleSetExtensionStatus.Type != nil {
		typeVar := *virtualMachineScaleSetExtensionStatus.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// TypeHandlerVersion
	if virtualMachineScaleSetExtensionStatus.TypeHandlerVersion != nil {
		typeHandlerVersion := *virtualMachineScaleSetExtensionStatus.TypeHandlerVersion
		destination.TypeHandlerVersion = &typeHandlerVersion
	} else {
		destination.TypeHandlerVersion = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VirtualMachineScaleSetNetworkConfiguration_Status struct {
	//DnsSettings: The dns settings to be applied on the network interfaces.
	DnsSettings *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status `json:"dnsSettings,omitempty"`

	//EnableAcceleratedNetworking: Specifies whether the network interface is
	//accelerated networking-enabled.
	EnableAcceleratedNetworking *bool `json:"enableAcceleratedNetworking,omitempty"`

	//EnableFpga: Specifies whether the network interface is FPGA networking-enabled.
	EnableFpga *bool `json:"enableFpga,omitempty"`

	//EnableIPForwarding: Whether IP forwarding enabled on this NIC.
	EnableIPForwarding *bool `json:"enableIPForwarding,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//IpConfigurations: Specifies the IP configurations of the network interface.
	IpConfigurations []VirtualMachineScaleSetIPConfiguration_Status `json:"ipConfigurations,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The network configuration name.
	Name string `json:"name"`

	//NetworkSecurityGroup: The network security group.
	NetworkSecurityGroup *SubResource_Status `json:"networkSecurityGroup,omitempty"`

	//Primary: Specifies the primary network interface in case the virtual machine has
	//more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetNetworkConfiguration_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetNetworkConfigurationStatus *VirtualMachineScaleSetNetworkConfiguration_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetNetworkConfigurationStatus *VirtualMachineScaleSetNetworkConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			virtualMachineScaleSetNetworkConfigurationStatus.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘EnableAcceleratedNetworking’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			virtualMachineScaleSetNetworkConfigurationStatus.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property ‘EnableFpga’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFpga != nil {
			enableFpga := *typedInput.Properties.EnableFpga
			virtualMachineScaleSetNetworkConfigurationStatus.EnableFpga = &enableFpga
		}
	}

	// Set property ‘EnableIPForwarding’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			virtualMachineScaleSetNetworkConfigurationStatus.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		virtualMachineScaleSetNetworkConfigurationStatus.Id = &id
	}

	// Set property ‘IpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 VirtualMachineScaleSetIPConfiguration_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			virtualMachineScaleSetNetworkConfigurationStatus.IpConfigurations = append(virtualMachineScaleSetNetworkConfigurationStatus.IpConfigurations, item1)
		}
	}

	// Set property ‘Name’:
	virtualMachineScaleSetNetworkConfigurationStatus.Name = typedInput.Name

	// Set property ‘NetworkSecurityGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 SubResource_Status
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			virtualMachineScaleSetNetworkConfigurationStatus.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			virtualMachineScaleSetNetworkConfigurationStatus.Primary = &primary
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationStatus populates our VirtualMachineScaleSetNetworkConfiguration_Status from the provided source VirtualMachineScaleSetNetworkConfiguration_Status
func (virtualMachineScaleSetNetworkConfigurationStatus *VirtualMachineScaleSetNetworkConfiguration_Status) AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Status) error {

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "populating DnsSettings from DnsSettings, calling AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus()")
		}
		virtualMachineScaleSetNetworkConfigurationStatus.DnsSettings = &dnsSetting
	} else {
		virtualMachineScaleSetNetworkConfigurationStatus.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		virtualMachineScaleSetNetworkConfigurationStatus.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		virtualMachineScaleSetNetworkConfigurationStatus.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		virtualMachineScaleSetNetworkConfigurationStatus.EnableFpga = &enableFpga
	} else {
		virtualMachineScaleSetNetworkConfigurationStatus.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		virtualMachineScaleSetNetworkConfigurationStatus.EnableIPForwarding = &enableIPForwarding
	} else {
		virtualMachineScaleSetNetworkConfigurationStatus.EnableIPForwarding = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		virtualMachineScaleSetNetworkConfigurationStatus.Id = &id
	} else {
		virtualMachineScaleSetNetworkConfigurationStatus.Id = nil
	}

	// IpConfigurations
	ipConfigurationList := make([]VirtualMachineScaleSetIPConfiguration_Status, len(source.IpConfigurations))
	for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
		// Shadow the loop variable to avoid aliasing
		ipConfigurationItem := ipConfigurationItem
		var ipConfiguration VirtualMachineScaleSetIPConfiguration_Status
		err := ipConfiguration.AssignPropertiesFromVirtualMachineScaleSetIPConfigurationStatus(&ipConfigurationItem)
		if err != nil {
			return errors.Wrap(err, "populating IpConfigurations from IpConfigurations, calling AssignPropertiesFromVirtualMachineScaleSetIPConfigurationStatus()")
		}
		ipConfigurationList[ipConfigurationIndex] = ipConfiguration
	}
	virtualMachineScaleSetNetworkConfigurationStatus.IpConfigurations = ipConfigurationList

	// Name
	if source.Name != nil {
		virtualMachineScaleSetNetworkConfigurationStatus.Name = *source.Name
	} else {
		virtualMachineScaleSetNetworkConfigurationStatus.Name = ""
	}

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup SubResource_Status
		err := networkSecurityGroup.AssignPropertiesFromSubResourceStatus(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "populating NetworkSecurityGroup from NetworkSecurityGroup, calling AssignPropertiesFromSubResourceStatus()")
		}
		virtualMachineScaleSetNetworkConfigurationStatus.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		virtualMachineScaleSetNetworkConfigurationStatus.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		virtualMachineScaleSetNetworkConfigurationStatus.Primary = &primary
	} else {
		virtualMachineScaleSetNetworkConfigurationStatus.Primary = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationStatus populates the provided destination VirtualMachineScaleSetNetworkConfiguration_Status from our VirtualMachineScaleSetNetworkConfiguration_Status
func (virtualMachineScaleSetNetworkConfigurationStatus *VirtualMachineScaleSetNetworkConfiguration_Status) AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsSettings
	if virtualMachineScaleSetNetworkConfigurationStatus.DnsSettings != nil {
		var dnsSetting v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
		err := (*virtualMachineScaleSetNetworkConfigurationStatus.DnsSettings).AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "populating DnsSettings from DnsSettings, calling AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus()")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if virtualMachineScaleSetNetworkConfigurationStatus.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *virtualMachineScaleSetNetworkConfigurationStatus.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if virtualMachineScaleSetNetworkConfigurationStatus.EnableFpga != nil {
		enableFpga := *virtualMachineScaleSetNetworkConfigurationStatus.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if virtualMachineScaleSetNetworkConfigurationStatus.EnableIPForwarding != nil {
		enableIPForwarding := *virtualMachineScaleSetNetworkConfigurationStatus.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// Id
	if virtualMachineScaleSetNetworkConfigurationStatus.Id != nil {
		id := *virtualMachineScaleSetNetworkConfigurationStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// IpConfigurations
	ipConfigurationList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Status, len(virtualMachineScaleSetNetworkConfigurationStatus.IpConfigurations))
	for ipConfigurationIndex, ipConfigurationItem := range virtualMachineScaleSetNetworkConfigurationStatus.IpConfigurations {
		// Shadow the loop variable to avoid aliasing
		ipConfigurationItem := ipConfigurationItem
		var ipConfiguration v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Status
		err := ipConfigurationItem.AssignPropertiesToVirtualMachineScaleSetIPConfigurationStatus(&ipConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating IpConfigurations from IpConfigurations, calling AssignPropertiesToVirtualMachineScaleSetIPConfigurationStatus()")
		}
		ipConfigurationList[ipConfigurationIndex] = ipConfiguration
	}
	destination.IpConfigurations = ipConfigurationList

	// Name
	name := virtualMachineScaleSetNetworkConfigurationStatus.Name
	destination.Name = &name

	// NetworkSecurityGroup
	if virtualMachineScaleSetNetworkConfigurationStatus.NetworkSecurityGroup != nil {
		var networkSecurityGroup v1alpha1api20201201storage.SubResource_Status
		err := (*virtualMachineScaleSetNetworkConfigurationStatus.NetworkSecurityGroup).AssignPropertiesToSubResourceStatus(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "populating NetworkSecurityGroup from NetworkSecurityGroup, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if virtualMachineScaleSetNetworkConfigurationStatus.Primary != nil {
		primary := *virtualMachineScaleSetNetworkConfigurationStatus.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VirtualMachineScaleSetOSDisk
type VirtualMachineScaleSetOSDisk struct {
	//Caching: Specifies the caching requirements.
	//Possible values are:
	//None
	//ReadOnly
	//ReadWrite
	//Default: None for Standard storage. ReadOnly for Premium storage.
	Caching *VirtualMachineScaleSetOSDiskCaching `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	//CreateOption: Specifies how the virtual machines in the scale set should be
	//created.
	//The only allowed value is: FromImage \u2013 This value is used when you are
	//using an image to create the virtual machine. If you are using a platform image,
	//you also use the imageReference element described above. If you are using a
	//marketplace image, you  also use the plan element previously described.
	CreateOption VirtualMachineScaleSetOSDiskCreateOption `json:"createOption"`

	//DiffDiskSettings: Describes the parameters of ephemeral disk settings that can
	//be specified for operating system disk.
	//NOTE: The ephemeral disk settings can only be specified for managed disk.
	DiffDiskSettings *DiffDiskSettings `json:"diffDiskSettings,omitempty"`

	//DiskSizeGB: Specifies the size of the operating system disk in gigabytes. This
	//element can be used to overwrite the size of the disk in a virtual machine image.
	//This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	//Image: Describes the uri of a disk.
	Image *VirtualHardDisk `json:"image,omitempty"`

	//ManagedDisk: Describes the parameters of a ScaleSet managed disk.
	ManagedDisk *VirtualMachineScaleSetManagedDiskParameters `json:"managedDisk,omitempty"`

	//Name: The disk name.
	Name *string `json:"name,omitempty"`

	//OsType: This property allows you to specify the type of the OS that is included
	//in the disk if creating a VM from user-image or a specialized VHD.
	//Possible values are:
	//Windows
	//Linux.
	OsType *VirtualMachineScaleSetOSDiskOsType `json:"osType,omitempty"`

	//VhdContainers: Specifies the container urls that are used to store operating
	//system disks for the scale set.
	VhdContainers []string `json:"vhdContainers,omitempty"`

	//WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or
	//disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetOSDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetOSDisk *VirtualMachineScaleSetOSDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetOSDisk == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetOSDiskARM

	// Set property ‘Caching’:
	if virtualMachineScaleSetOSDisk.Caching != nil {
		caching := *virtualMachineScaleSetOSDisk.Caching
		result.Caching = &caching
	}

	// Set property ‘CreateOption’:
	result.CreateOption = virtualMachineScaleSetOSDisk.CreateOption

	// Set property ‘DiffDiskSettings’:
	if virtualMachineScaleSetOSDisk.DiffDiskSettings != nil {
		diffDiskSettingsARM, err := (*virtualMachineScaleSetOSDisk.DiffDiskSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diffDiskSettings := diffDiskSettingsARM.(DiffDiskSettingsARM)
		result.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if virtualMachineScaleSetOSDisk.DiskSizeGB != nil {
		diskSizeGB := *virtualMachineScaleSetOSDisk.DiskSizeGB
		result.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if virtualMachineScaleSetOSDisk.Image != nil {
		imageARM, err := (*virtualMachineScaleSetOSDisk.Image).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		image := imageARM.(VirtualHardDiskARM)
		result.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if virtualMachineScaleSetOSDisk.ManagedDisk != nil {
		managedDiskARM, err := (*virtualMachineScaleSetOSDisk.ManagedDisk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := managedDiskARM.(VirtualMachineScaleSetManagedDiskParametersARM)
		result.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if virtualMachineScaleSetOSDisk.Name != nil {
		name := *virtualMachineScaleSetOSDisk.Name
		result.Name = &name
	}

	// Set property ‘OsType’:
	if virtualMachineScaleSetOSDisk.OsType != nil {
		osType := *virtualMachineScaleSetOSDisk.OsType
		result.OsType = &osType
	}

	// Set property ‘VhdContainers’:
	for _, item := range virtualMachineScaleSetOSDisk.VhdContainers {
		result.VhdContainers = append(result.VhdContainers, item)
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if virtualMachineScaleSetOSDisk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *virtualMachineScaleSetOSDisk.WriteAcceleratorEnabled
		result.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetOSDisk *VirtualMachineScaleSetOSDisk) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetOSDiskARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetOSDisk *VirtualMachineScaleSetOSDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetOSDiskARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetOSDiskARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		virtualMachineScaleSetOSDisk.Caching = &caching
	}

	// Set property ‘CreateOption’:
	virtualMachineScaleSetOSDisk.CreateOption = typedInput.CreateOption

	// Set property ‘DiffDiskSettings’:
	if typedInput.DiffDiskSettings != nil {
		var diffDiskSettings1 DiffDiskSettings
		err := diffDiskSettings1.PopulateFromARM(owner, *typedInput.DiffDiskSettings)
		if err != nil {
			return err
		}
		diffDiskSettings := diffDiskSettings1
		virtualMachineScaleSetOSDisk.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		virtualMachineScaleSetOSDisk.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if typedInput.Image != nil {
		var image1 VirtualHardDisk
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		virtualMachineScaleSetOSDisk.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		virtualMachineScaleSetOSDisk.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		virtualMachineScaleSetOSDisk.Name = &name
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		virtualMachineScaleSetOSDisk.OsType = &osType
	}

	// Set property ‘VhdContainers’:
	for _, item := range typedInput.VhdContainers {
		virtualMachineScaleSetOSDisk.VhdContainers = append(virtualMachineScaleSetOSDisk.VhdContainers, item)
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		virtualMachineScaleSetOSDisk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetOSDisk populates our VirtualMachineScaleSetOSDisk from the provided source VirtualMachineScaleSetOSDisk
func (virtualMachineScaleSetOSDisk *VirtualMachineScaleSetOSDisk) AssignPropertiesFromVirtualMachineScaleSetOSDisk(source *v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk) error {

	// Caching
	if source.Caching != nil {
		caching := VirtualMachineScaleSetOSDiskCaching(*source.Caching)
		virtualMachineScaleSetOSDisk.Caching = &caching
	} else {
		virtualMachineScaleSetOSDisk.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		virtualMachineScaleSetOSDisk.CreateOption = VirtualMachineScaleSetOSDiskCreateOption(*source.CreateOption)
	} else {
		virtualMachineScaleSetOSDisk.CreateOption = ""
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings
		err := diffDiskSetting.AssignPropertiesFromDiffDiskSettings(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "populating DiffDiskSettings from DiffDiskSettings, calling AssignPropertiesFromDiffDiskSettings()")
		}
		virtualMachineScaleSetOSDisk.DiffDiskSettings = &diffDiskSetting
	} else {
		virtualMachineScaleSetOSDisk.DiffDiskSettings = nil
	}

	// DiskSizeGB
	if source.DiskSizeGB != nil {
		diskSizeGB := *source.DiskSizeGB
		virtualMachineScaleSetOSDisk.DiskSizeGB = &diskSizeGB
	} else {
		virtualMachineScaleSetOSDisk.DiskSizeGB = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk
		err := image.AssignPropertiesFromVirtualHardDisk(source.Image)
		if err != nil {
			return errors.Wrap(err, "populating Image from Image, calling AssignPropertiesFromVirtualHardDisk()")
		}
		virtualMachineScaleSetOSDisk.Image = &image
	} else {
		virtualMachineScaleSetOSDisk.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters
		err := managedDisk.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters()")
		}
		virtualMachineScaleSetOSDisk.ManagedDisk = &managedDisk
	} else {
		virtualMachineScaleSetOSDisk.ManagedDisk = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		virtualMachineScaleSetOSDisk.Name = &name
	} else {
		virtualMachineScaleSetOSDisk.Name = nil
	}

	// OsType
	if source.OsType != nil {
		osType := VirtualMachineScaleSetOSDiskOsType(*source.OsType)
		virtualMachineScaleSetOSDisk.OsType = &osType
	} else {
		virtualMachineScaleSetOSDisk.OsType = nil
	}

	// VhdContainers
	vhdContainerList := make([]string, len(source.VhdContainers))
	for vhdContainerIndex, vhdContainerItem := range source.VhdContainers {
		// Shadow the loop variable to avoid aliasing
		vhdContainerItem := vhdContainerItem
		vhdContainerList[vhdContainerIndex] = vhdContainerItem
	}
	virtualMachineScaleSetOSDisk.VhdContainers = vhdContainerList

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		virtualMachineScaleSetOSDisk.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		virtualMachineScaleSetOSDisk.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetOSDisk populates the provided destination VirtualMachineScaleSetOSDisk from our VirtualMachineScaleSetOSDisk
func (virtualMachineScaleSetOSDisk *VirtualMachineScaleSetOSDisk) AssignPropertiesToVirtualMachineScaleSetOSDisk(destination *v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if virtualMachineScaleSetOSDisk.Caching != nil {
		caching := string(*virtualMachineScaleSetOSDisk.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	createOption := string(virtualMachineScaleSetOSDisk.CreateOption)
	destination.CreateOption = &createOption

	// DiffDiskSettings
	if virtualMachineScaleSetOSDisk.DiffDiskSettings != nil {
		var diffDiskSetting v1alpha1api20201201storage.DiffDiskSettings
		err := (*virtualMachineScaleSetOSDisk.DiffDiskSettings).AssignPropertiesToDiffDiskSettings(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "populating DiffDiskSettings from DiffDiskSettings, calling AssignPropertiesToDiffDiskSettings()")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	if virtualMachineScaleSetOSDisk.DiskSizeGB != nil {
		diskSizeGB := *virtualMachineScaleSetOSDisk.DiskSizeGB
		destination.DiskSizeGB = &diskSizeGB
	} else {
		destination.DiskSizeGB = nil
	}

	// Image
	if virtualMachineScaleSetOSDisk.Image != nil {
		var image v1alpha1api20201201storage.VirtualHardDisk
		err := (*virtualMachineScaleSetOSDisk.Image).AssignPropertiesToVirtualHardDisk(&image)
		if err != nil {
			return errors.Wrap(err, "populating Image from Image, calling AssignPropertiesToVirtualHardDisk()")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if virtualMachineScaleSetOSDisk.ManagedDisk != nil {
		var managedDisk v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters
		err := (*virtualMachineScaleSetOSDisk.ManagedDisk).AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters()")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	if virtualMachineScaleSetOSDisk.Name != nil {
		name := *virtualMachineScaleSetOSDisk.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// OsType
	if virtualMachineScaleSetOSDisk.OsType != nil {
		osType := string(*virtualMachineScaleSetOSDisk.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// VhdContainers
	vhdContainerList := make([]string, len(virtualMachineScaleSetOSDisk.VhdContainers))
	for vhdContainerIndex, vhdContainerItem := range virtualMachineScaleSetOSDisk.VhdContainers {
		// Shadow the loop variable to avoid aliasing
		vhdContainerItem := vhdContainerItem
		vhdContainerList[vhdContainerIndex] = vhdContainerItem
	}
	destination.VhdContainers = vhdContainerList

	// WriteAcceleratorEnabled
	if virtualMachineScaleSetOSDisk.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *virtualMachineScaleSetOSDisk.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VirtualMachineScaleSetOSDisk_Status struct {
	//Caching: Specifies the caching requirements.
	//Possible values are:
	//None
	//ReadOnly
	//ReadWrite
	//Default: None for Standard storage. ReadOnly for Premium storage
	Caching *Caching_Status `json:"caching,omitempty"`

	// +kubebuilder:validation:Required
	//CreateOption: Specifies how the virtual machines in the scale set should be
	//created.
	//The only allowed value is: FromImage \u2013 This value is used when you are
	//using an image to create the virtual machine. If you are using a platform image,
	//you also use the imageReference element described above. If you are using a
	//marketplace image, you  also use the plan element previously described.
	CreateOption CreateOption_Status `json:"createOption"`

	//DiffDiskSettings: Specifies the ephemeral disk Settings for the operating system
	//disk used by the virtual machine scale set.
	DiffDiskSettings *DiffDiskSettings_Status `json:"diffDiskSettings,omitempty"`

	//DiskSizeGB: Specifies the size of the operating system disk in gigabytes. This
	//element can be used to overwrite the size of the disk in a virtual machine image.
	//This value cannot be larger than 1023 GB
	DiskSizeGB *int `json:"diskSizeGB,omitempty"`

	//Image: Specifies information about the unmanaged user image to base the scale
	//set on.
	Image *VirtualHardDisk_Status `json:"image,omitempty"`

	//ManagedDisk: The managed disk parameters.
	ManagedDisk *VirtualMachineScaleSetManagedDiskParameters_Status `json:"managedDisk,omitempty"`

	//Name: The disk name.
	Name *string `json:"name,omitempty"`

	//OsType: This property allows you to specify the type of the OS that is included
	//in the disk if creating a VM from user-image or a specialized VHD.
	//Possible values are:
	//Windows
	//Linux
	OsType *VirtualMachineScaleSetOSDiskStatusOsType `json:"osType,omitempty"`

	//VhdContainers: Specifies the container urls that are used to store operating
	//system disks for the scale set.
	VhdContainers []string `json:"vhdContainers,omitempty"`

	//WriteAcceleratorEnabled: Specifies whether writeAccelerator should be enabled or
	//disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetOSDisk_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetOSDiskStatus *VirtualMachineScaleSetOSDisk_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetOSDisk_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetOSDiskStatus *VirtualMachineScaleSetOSDisk_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetOSDisk_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetOSDisk_StatusARM, got %T", armInput)
	}

	// Set property ‘Caching’:
	if typedInput.Caching != nil {
		caching := *typedInput.Caching
		virtualMachineScaleSetOSDiskStatus.Caching = &caching
	}

	// Set property ‘CreateOption’:
	virtualMachineScaleSetOSDiskStatus.CreateOption = typedInput.CreateOption

	// Set property ‘DiffDiskSettings’:
	if typedInput.DiffDiskSettings != nil {
		var diffDiskSettings1 DiffDiskSettings_Status
		err := diffDiskSettings1.PopulateFromARM(owner, *typedInput.DiffDiskSettings)
		if err != nil {
			return err
		}
		diffDiskSettings := diffDiskSettings1
		virtualMachineScaleSetOSDiskStatus.DiffDiskSettings = &diffDiskSettings
	}

	// Set property ‘DiskSizeGB’:
	if typedInput.DiskSizeGB != nil {
		diskSizeGB := *typedInput.DiskSizeGB
		virtualMachineScaleSetOSDiskStatus.DiskSizeGB = &diskSizeGB
	}

	// Set property ‘Image’:
	if typedInput.Image != nil {
		var image1 VirtualHardDisk_Status
		err := image1.PopulateFromARM(owner, *typedInput.Image)
		if err != nil {
			return err
		}
		image := image1
		virtualMachineScaleSetOSDiskStatus.Image = &image
	}

	// Set property ‘ManagedDisk’:
	if typedInput.ManagedDisk != nil {
		var managedDisk1 VirtualMachineScaleSetManagedDiskParameters_Status
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		virtualMachineScaleSetOSDiskStatus.ManagedDisk = &managedDisk
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		virtualMachineScaleSetOSDiskStatus.Name = &name
	}

	// Set property ‘OsType’:
	if typedInput.OsType != nil {
		osType := *typedInput.OsType
		virtualMachineScaleSetOSDiskStatus.OsType = &osType
	}

	// Set property ‘VhdContainers’:
	for _, item := range typedInput.VhdContainers {
		virtualMachineScaleSetOSDiskStatus.VhdContainers = append(virtualMachineScaleSetOSDiskStatus.VhdContainers, item)
	}

	// Set property ‘WriteAcceleratorEnabled’:
	if typedInput.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *typedInput.WriteAcceleratorEnabled
		virtualMachineScaleSetOSDiskStatus.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetOSDiskStatus populates our VirtualMachineScaleSetOSDisk_Status from the provided source VirtualMachineScaleSetOSDisk_Status
func (virtualMachineScaleSetOSDiskStatus *VirtualMachineScaleSetOSDisk_Status) AssignPropertiesFromVirtualMachineScaleSetOSDiskStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk_Status) error {

	// Caching
	if source.Caching != nil {
		caching := Caching_Status(*source.Caching)
		virtualMachineScaleSetOSDiskStatus.Caching = &caching
	} else {
		virtualMachineScaleSetOSDiskStatus.Caching = nil
	}

	// CreateOption
	if source.CreateOption != nil {
		virtualMachineScaleSetOSDiskStatus.CreateOption = CreateOption_Status(*source.CreateOption)
	} else {
		virtualMachineScaleSetOSDiskStatus.CreateOption = ""
	}

	// DiffDiskSettings
	if source.DiffDiskSettings != nil {
		var diffDiskSetting DiffDiskSettings_Status
		err := diffDiskSetting.AssignPropertiesFromDiffDiskSettingsStatus(source.DiffDiskSettings)
		if err != nil {
			return errors.Wrap(err, "populating DiffDiskSettings from DiffDiskSettings, calling AssignPropertiesFromDiffDiskSettingsStatus()")
		}
		virtualMachineScaleSetOSDiskStatus.DiffDiskSettings = &diffDiskSetting
	} else {
		virtualMachineScaleSetOSDiskStatus.DiffDiskSettings = nil
	}

	// DiskSizeGB
	if source.DiskSizeGB != nil {
		diskSizeGB := *source.DiskSizeGB
		virtualMachineScaleSetOSDiskStatus.DiskSizeGB = &diskSizeGB
	} else {
		virtualMachineScaleSetOSDiskStatus.DiskSizeGB = nil
	}

	// Image
	if source.Image != nil {
		var image VirtualHardDisk_Status
		err := image.AssignPropertiesFromVirtualHardDiskStatus(source.Image)
		if err != nil {
			return errors.Wrap(err, "populating Image from Image, calling AssignPropertiesFromVirtualHardDiskStatus()")
		}
		virtualMachineScaleSetOSDiskStatus.Image = &image
	} else {
		virtualMachineScaleSetOSDiskStatus.Image = nil
	}

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk VirtualMachineScaleSetManagedDiskParameters_Status
		err := managedDisk.AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersStatus(source.ManagedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersStatus()")
		}
		virtualMachineScaleSetOSDiskStatus.ManagedDisk = &managedDisk
	} else {
		virtualMachineScaleSetOSDiskStatus.ManagedDisk = nil
	}

	// Name
	if source.Name != nil {
		name := *source.Name
		virtualMachineScaleSetOSDiskStatus.Name = &name
	} else {
		virtualMachineScaleSetOSDiskStatus.Name = nil
	}

	// OsType
	if source.OsType != nil {
		osType := VirtualMachineScaleSetOSDiskStatusOsType(*source.OsType)
		virtualMachineScaleSetOSDiskStatus.OsType = &osType
	} else {
		virtualMachineScaleSetOSDiskStatus.OsType = nil
	}

	// VhdContainers
	vhdContainerList := make([]string, len(source.VhdContainers))
	for vhdContainerIndex, vhdContainerItem := range source.VhdContainers {
		// Shadow the loop variable to avoid aliasing
		vhdContainerItem := vhdContainerItem
		vhdContainerList[vhdContainerIndex] = vhdContainerItem
	}
	virtualMachineScaleSetOSDiskStatus.VhdContainers = vhdContainerList

	// WriteAcceleratorEnabled
	if source.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *source.WriteAcceleratorEnabled
		virtualMachineScaleSetOSDiskStatus.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		virtualMachineScaleSetOSDiskStatus.WriteAcceleratorEnabled = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetOSDiskStatus populates the provided destination VirtualMachineScaleSetOSDisk_Status from our VirtualMachineScaleSetOSDisk_Status
func (virtualMachineScaleSetOSDiskStatus *VirtualMachineScaleSetOSDisk_Status) AssignPropertiesToVirtualMachineScaleSetOSDiskStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetOSDisk_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Caching
	if virtualMachineScaleSetOSDiskStatus.Caching != nil {
		caching := string(*virtualMachineScaleSetOSDiskStatus.Caching)
		destination.Caching = &caching
	} else {
		destination.Caching = nil
	}

	// CreateOption
	createOption := string(virtualMachineScaleSetOSDiskStatus.CreateOption)
	destination.CreateOption = &createOption

	// DiffDiskSettings
	if virtualMachineScaleSetOSDiskStatus.DiffDiskSettings != nil {
		var diffDiskSetting v1alpha1api20201201storage.DiffDiskSettings_Status
		err := (*virtualMachineScaleSetOSDiskStatus.DiffDiskSettings).AssignPropertiesToDiffDiskSettingsStatus(&diffDiskSetting)
		if err != nil {
			return errors.Wrap(err, "populating DiffDiskSettings from DiffDiskSettings, calling AssignPropertiesToDiffDiskSettingsStatus()")
		}
		destination.DiffDiskSettings = &diffDiskSetting
	} else {
		destination.DiffDiskSettings = nil
	}

	// DiskSizeGB
	if virtualMachineScaleSetOSDiskStatus.DiskSizeGB != nil {
		diskSizeGB := *virtualMachineScaleSetOSDiskStatus.DiskSizeGB
		destination.DiskSizeGB = &diskSizeGB
	} else {
		destination.DiskSizeGB = nil
	}

	// Image
	if virtualMachineScaleSetOSDiskStatus.Image != nil {
		var image v1alpha1api20201201storage.VirtualHardDisk_Status
		err := (*virtualMachineScaleSetOSDiskStatus.Image).AssignPropertiesToVirtualHardDiskStatus(&image)
		if err != nil {
			return errors.Wrap(err, "populating Image from Image, calling AssignPropertiesToVirtualHardDiskStatus()")
		}
		destination.Image = &image
	} else {
		destination.Image = nil
	}

	// ManagedDisk
	if virtualMachineScaleSetOSDiskStatus.ManagedDisk != nil {
		var managedDisk v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Status
		err := (*virtualMachineScaleSetOSDiskStatus.ManagedDisk).AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersStatus(&managedDisk)
		if err != nil {
			return errors.Wrap(err, "populating ManagedDisk from ManagedDisk, calling AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersStatus()")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// Name
	if virtualMachineScaleSetOSDiskStatus.Name != nil {
		name := *virtualMachineScaleSetOSDiskStatus.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// OsType
	if virtualMachineScaleSetOSDiskStatus.OsType != nil {
		osType := string(*virtualMachineScaleSetOSDiskStatus.OsType)
		destination.OsType = &osType
	} else {
		destination.OsType = nil
	}

	// VhdContainers
	vhdContainerList := make([]string, len(virtualMachineScaleSetOSDiskStatus.VhdContainers))
	for vhdContainerIndex, vhdContainerItem := range virtualMachineScaleSetOSDiskStatus.VhdContainers {
		// Shadow the loop variable to avoid aliasing
		vhdContainerItem := vhdContainerItem
		vhdContainerList[vhdContainerIndex] = vhdContainerItem
	}
	destination.VhdContainers = vhdContainerList

	// WriteAcceleratorEnabled
	if virtualMachineScaleSetOSDiskStatus.WriteAcceleratorEnabled != nil {
		writeAcceleratorEnabled := *virtualMachineScaleSetOSDiskStatus.WriteAcceleratorEnabled
		destination.WriteAcceleratorEnabled = &writeAcceleratorEnabled
	} else {
		destination.WriteAcceleratorEnabled = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions struct {
	//Name: The name of the extension.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:MinLength=1
	//Publisher: Microsoft.Compute/extensions - Publisher
	Publisher *string `json:"publisher,omitempty"`

	//Settings: Microsoft.Compute/extensions - Settings
	Settings map[string]v1.JSON `json:"settings,omitempty"`

	// +kubebuilder:validation:MinLength=1
	//Type: Microsoft.Compute/extensions - Type
	Type *string `json:"type,omitempty"`

	// +kubebuilder:validation:MinLength=1
	//TypeHandlerVersion: Microsoft.Compute/extensions - Type handler version
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_ExtensionsARM

	// Set property ‘Name’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Name != nil {
		name := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Publisher != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Settings != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Type != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.TypeHandlerVersion != nil {
		result.Properties = &GenericExtensionARM{}
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Publisher != nil {
		result.Properties.Publisher = *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Publisher
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Settings != nil {
		result.Properties.Settings = make(map[string]v1.JSON)
		for key, value := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Settings {
			result.Properties.Settings[key] = *value.DeepCopy()
		}
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Type != nil {
		result.Properties.Type = *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Type
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.TypeHandlerVersion != nil {
		result.Properties.TypeHandlerVersion = *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.TypeHandlerVersion
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_ExtensionsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_ExtensionsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_ExtensionsARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Name = &name
	}

	// Set property ‘Publisher’:
	// copying flattened property:
	if typedInput.Properties != nil {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Publisher = &typedInput.Properties.Publisher
	}

	// Set property ‘Settings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Settings != nil {
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Settings = make(map[string]v1.JSON)
			for key, value := range typedInput.Properties.Settings {
				virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Settings[key] = *value.DeepCopy()
			}
		}
	}

	// Set property ‘Type’:
	// copying flattened property:
	if typedInput.Properties != nil {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Type = &typedInput.Properties.Type
	}

	// Set property ‘TypeHandlerVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.TypeHandlerVersion = &typedInput.Properties.TypeHandlerVersion
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions populates our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions from the provided source VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions) AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions(source *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions) error {

	// Name
	if source.Name != nil {
		name := *source.Name
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Name = &name
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Name = nil
	}

	// Publisher
	if source.Publisher != nil {
		publisher := *source.Publisher
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Publisher = &publisher
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Publisher = nil
	}

	// Settings
	settingMap := make(map[string]v1.JSON)
	for settingKey, settingValue := range source.Settings {
		// Shadow the loop variable to avoid aliasing
		settingValue := settingValue
		settingMap[settingKey] = *settingValue.DeepCopy()
	}
	virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Settings = settingMap

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Type = &typeVar
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Type = nil
	}

	// TypeHandlerVersion
	if source.TypeHandlerVersion != nil {
		typeHandlerVersion := *source.TypeHandlerVersion
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.TypeHandlerVersion = &typeHandlerVersion
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.TypeHandlerVersion = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions populates the provided destination VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions from our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions) AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions(destination *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_ExtensionProfile_Extensions) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Name != nil {
		name := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Name
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Publisher
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Publisher != nil {
		publisher := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Publisher
		destination.Publisher = &publisher
	} else {
		destination.Publisher = nil
	}

	// Settings
	settingMap := make(map[string]v1.JSON)
	for settingKey, settingValue := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Settings {
		// Shadow the loop variable to avoid aliasing
		settingValue := settingValue
		settingMap[settingKey] = *settingValue.DeepCopy()
	}
	destination.Settings = settingMap

	// Type
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Type != nil {
		typeVar := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.Type
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// TypeHandlerVersion
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.TypeHandlerVersion != nil {
		typeHandlerVersion := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileExtensionProfileExtensions.TypeHandlerVersion
		destination.TypeHandlerVersion = &typeHandlerVersion
	} else {
		destination.TypeHandlerVersion = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

type VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations struct {
	//DnsSettings: Describes a virtual machines scale sets network configuration's DNS
	//settings.
	DnsSettings *VirtualMachineScaleSetNetworkConfigurationDnsSettings `json:"dnsSettings,omitempty"`

	//EnableAcceleratedNetworking: Specifies whether the network interface is
	//accelerated networking-enabled.
	EnableAcceleratedNetworking *bool `json:"enableAcceleratedNetworking,omitempty"`

	//EnableFpga: Specifies whether the network interface is FPGA networking-enabled.
	EnableFpga *bool `json:"enableFpga,omitempty"`

	//EnableIPForwarding: Whether IP forwarding enabled on this NIC.
	EnableIPForwarding *bool `json:"enableIPForwarding,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//IpConfigurations: Specifies the IP configurations of the network interface.
	IpConfigurations []VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations `json:"ipConfigurations,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The network configuration name.
	Name                 string       `json:"name"`
	NetworkSecurityGroup *SubResource `json:"networkSecurityGroup,omitempty"`

	//Primary: Specifies the primary network interface in case the virtual machine has
	//more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurationsARM

	// Set property ‘Id’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Id != nil {
		id := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Id
		result.Id = &id
	}

	// Set property ‘Name’:
	result.Name = virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Name

	// Set property ‘Properties’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.DnsSettings != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableAcceleratedNetworking != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableFpga != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableIPForwarding != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.IpConfigurations != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.NetworkSecurityGroup != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Primary != nil {
		result.Properties = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_PropertiesARM{}
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.DnsSettings != nil {
		dnsSettingsARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := dnsSettingsARM.(VirtualMachineScaleSetNetworkConfigurationDnsSettingsARM)
		result.Properties.DnsSettings = &dnsSettings
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableAcceleratedNetworking
		result.Properties.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableFpga != nil {
		enableFpga := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableFpga
		result.Properties.EnableFpga = &enableFpga
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableIPForwarding != nil {
		enableIPForwarding := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableIPForwarding
		result.Properties.EnableIPForwarding = &enableIPForwarding
	}
	for _, item := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.IpConfigurations {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpConfigurations = append(result.Properties.IpConfigurations, itemARM.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM))
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.NetworkSecurityGroup != nil {
		networkSecurityGroupARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.NetworkSecurityGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkSecurityGroup := networkSecurityGroupARM.(SubResourceARM)
		result.Properties.NetworkSecurityGroup = &networkSecurityGroup
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Primary != nil {
		primary := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Primary
		result.Properties.Primary = &primary
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurationsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurationsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurationsARM, got %T", armInput)
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetNetworkConfigurationDnsSettings
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘EnableAcceleratedNetworking’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableAcceleratedNetworking != nil {
			enableAcceleratedNetworking := *typedInput.Properties.EnableAcceleratedNetworking
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableAcceleratedNetworking = &enableAcceleratedNetworking
		}
	}

	// Set property ‘EnableFpga’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableFpga != nil {
			enableFpga := *typedInput.Properties.EnableFpga
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableFpga = &enableFpga
		}
	}

	// Set property ‘EnableIPForwarding’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnableIPForwarding != nil {
			enableIPForwarding := *typedInput.Properties.EnableIPForwarding
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableIPForwarding = &enableIPForwarding
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Id = &id
	}

	// Set property ‘IpConfigurations’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpConfigurations {
			var item1 VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.IpConfigurations = append(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.IpConfigurations, item1)
		}
	}

	// Set property ‘Name’:
	virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Name = typedInput.Name

	// Set property ‘NetworkSecurityGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkSecurityGroup != nil {
			var networkSecurityGroup1 SubResource
			err := networkSecurityGroup1.PopulateFromARM(owner, *typedInput.Properties.NetworkSecurityGroup)
			if err != nil {
				return err
			}
			networkSecurityGroup := networkSecurityGroup1
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.NetworkSecurityGroup = &networkSecurityGroup
		}
	}

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Primary = &primary
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations populates our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations from the provided source VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations) AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations(source *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations) error {

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetNetworkConfigurationDnsSettings
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "populating DnsSettings from DnsSettings, calling AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.DnsSettings = &dnsSetting
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if source.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *source.EnableAcceleratedNetworking
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if source.EnableFpga != nil {
		enableFpga := *source.EnableFpga
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableFpga = &enableFpga
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableFpga = nil
	}

	// EnableIPForwarding
	if source.EnableIPForwarding != nil {
		enableIPForwarding := *source.EnableIPForwarding
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableIPForwarding = &enableIPForwarding
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableIPForwarding = nil
	}

	// Id
	if source.Id != nil {
		id := *source.Id
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Id = &id
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Id = nil
	}

	// IpConfigurations
	ipConfigurationList := make([]VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations, len(source.IpConfigurations))
	for ipConfigurationIndex, ipConfigurationItem := range source.IpConfigurations {
		// Shadow the loop variable to avoid aliasing
		ipConfigurationItem := ipConfigurationItem
		var ipConfiguration VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations
		err := ipConfiguration.AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations(&ipConfigurationItem)
		if err != nil {
			return errors.Wrap(err, "populating IpConfigurations from IpConfigurations, calling AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations()")
		}
		ipConfigurationList[ipConfigurationIndex] = ipConfiguration
	}
	virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.IpConfigurations = ipConfigurationList

	// Name
	if source.Name != nil {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Name = *source.Name
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Name = ""
	}

	// NetworkSecurityGroup
	if source.NetworkSecurityGroup != nil {
		var networkSecurityGroup SubResource
		err := networkSecurityGroup.AssignPropertiesFromSubResource(source.NetworkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "populating NetworkSecurityGroup from NetworkSecurityGroup, calling AssignPropertiesFromSubResource()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.NetworkSecurityGroup = nil
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Primary = &primary
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Primary = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations populates the provided destination VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations from our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations) AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations(destination *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsSettings
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.DnsSettings != nil {
		var dnsSetting v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.DnsSettings).AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "populating DnsSettings from DnsSettings, calling AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings()")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// EnableAcceleratedNetworking
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableAcceleratedNetworking != nil {
		enableAcceleratedNetworking := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableAcceleratedNetworking
		destination.EnableAcceleratedNetworking = &enableAcceleratedNetworking
	} else {
		destination.EnableAcceleratedNetworking = nil
	}

	// EnableFpga
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableFpga != nil {
		enableFpga := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableFpga
		destination.EnableFpga = &enableFpga
	} else {
		destination.EnableFpga = nil
	}

	// EnableIPForwarding
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableIPForwarding != nil {
		enableIPForwarding := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.EnableIPForwarding
		destination.EnableIPForwarding = &enableIPForwarding
	} else {
		destination.EnableIPForwarding = nil
	}

	// Id
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Id != nil {
		id := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// IpConfigurations
	ipConfigurationList := make([]v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations, len(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.IpConfigurations))
	for ipConfigurationIndex, ipConfigurationItem := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.IpConfigurations {
		// Shadow the loop variable to avoid aliasing
		ipConfigurationItem := ipConfigurationItem
		var ipConfiguration v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations
		err := ipConfigurationItem.AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations(&ipConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating IpConfigurations from IpConfigurations, calling AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations()")
		}
		ipConfigurationList[ipConfigurationIndex] = ipConfiguration
	}
	destination.IpConfigurations = ipConfigurationList

	// Name
	name := virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Name
	destination.Name = &name

	// NetworkSecurityGroup
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.NetworkSecurityGroup != nil {
		var networkSecurityGroup v1alpha1api20201201storage.SubResource
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.NetworkSecurityGroup).AssignPropertiesToSubResource(&networkSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "populating NetworkSecurityGroup from NetworkSecurityGroup, calling AssignPropertiesToSubResource()")
		}
		destination.NetworkSecurityGroup = &networkSecurityGroup
	} else {
		destination.NetworkSecurityGroup = nil
	}

	// Primary
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Primary != nil {
		primary := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurations.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/WindowsConfiguration
type WindowsConfiguration struct {
	//AdditionalUnattendContent: Specifies additional base-64 encoded XML formatted
	//information that can be included in the Unattend.xml file, which is used by
	//Windows Setup.
	AdditionalUnattendContent []AdditionalUnattendContent `json:"additionalUnattendContent,omitempty"`

	//EnableAutomaticUpdates: Indicates whether Automatic Updates is enabled for the
	//Windows virtual machine. Default value is true.
	//For virtual machine scale sets, this property can be updated and updates will
	//take effect on OS reprovisioning.
	EnableAutomaticUpdates *bool `json:"enableAutomaticUpdates,omitempty"`

	//PatchSettings: Specifies settings related to VM Guest Patching on Windows.
	PatchSettings *PatchSettings `json:"patchSettings,omitempty"`

	//ProvisionVMAgent: Indicates whether virtual machine agent should be provisioned
	//on the virtual machine.
	//When this property is not specified in the request body, default behavior is to
	//set it to true.  This will ensure that VM Agent is installed on the VM so that
	//extensions can be added to the VM later.
	ProvisionVMAgent *bool `json:"provisionVMAgent,omitempty"`

	//TimeZone: Specifies the time zone of the virtual machine. e.g. "Pacific Standard
	//Time".
	//Possible values can be
	//[TimeZoneInfo.Id](https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.id?#System_TimeZoneInfo_Id)
	//value from time zones returned by
	//[TimeZoneInfo.GetSystemTimeZones](https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.getsystemtimezones).
	TimeZone *string `json:"timeZone,omitempty"`

	//WinRM: Describes Windows Remote Management configuration of the VM
	WinRM *WinRMConfiguration `json:"winRM,omitempty"`
}

var _ genruntime.ARMTransformer = &WindowsConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (windowsConfiguration *WindowsConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if windowsConfiguration == nil {
		return nil, nil
	}
	var result WindowsConfigurationARM

	// Set property ‘AdditionalUnattendContent’:
	for _, item := range windowsConfiguration.AdditionalUnattendContent {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.AdditionalUnattendContent = append(result.AdditionalUnattendContent, itemARM.(AdditionalUnattendContentARM))
	}

	// Set property ‘EnableAutomaticUpdates’:
	if windowsConfiguration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdates := *windowsConfiguration.EnableAutomaticUpdates
		result.EnableAutomaticUpdates = &enableAutomaticUpdates
	}

	// Set property ‘PatchSettings’:
	if windowsConfiguration.PatchSettings != nil {
		patchSettingsARM, err := (*windowsConfiguration.PatchSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		patchSettings := patchSettingsARM.(PatchSettingsARM)
		result.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if windowsConfiguration.ProvisionVMAgent != nil {
		provisionVMAgent := *windowsConfiguration.ProvisionVMAgent
		result.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘TimeZone’:
	if windowsConfiguration.TimeZone != nil {
		timeZone := *windowsConfiguration.TimeZone
		result.TimeZone = &timeZone
	}

	// Set property ‘WinRM’:
	if windowsConfiguration.WinRM != nil {
		winRMARM, err := (*windowsConfiguration.WinRM).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		winRM := winRMARM.(WinRMConfigurationARM)
		result.WinRM = &winRM
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (windowsConfiguration *WindowsConfiguration) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &WindowsConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (windowsConfiguration *WindowsConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WindowsConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WindowsConfigurationARM, got %T", armInput)
	}

	// Set property ‘AdditionalUnattendContent’:
	for _, item := range typedInput.AdditionalUnattendContent {
		var item1 AdditionalUnattendContent
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		windowsConfiguration.AdditionalUnattendContent = append(windowsConfiguration.AdditionalUnattendContent, item1)
	}

	// Set property ‘EnableAutomaticUpdates’:
	if typedInput.EnableAutomaticUpdates != nil {
		enableAutomaticUpdates := *typedInput.EnableAutomaticUpdates
		windowsConfiguration.EnableAutomaticUpdates = &enableAutomaticUpdates
	}

	// Set property ‘PatchSettings’:
	if typedInput.PatchSettings != nil {
		var patchSettings1 PatchSettings
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		windowsConfiguration.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		windowsConfiguration.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘TimeZone’:
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		windowsConfiguration.TimeZone = &timeZone
	}

	// Set property ‘WinRM’:
	if typedInput.WinRM != nil {
		var winRM1 WinRMConfiguration
		err := winRM1.PopulateFromARM(owner, *typedInput.WinRM)
		if err != nil {
			return err
		}
		winRM := winRM1
		windowsConfiguration.WinRM = &winRM
	}

	// No error
	return nil
}

// AssignPropertiesFromWindowsConfiguration populates our WindowsConfiguration from the provided source WindowsConfiguration
func (windowsConfiguration *WindowsConfiguration) AssignPropertiesFromWindowsConfiguration(source *v1alpha1api20201201storage.WindowsConfiguration) error {

	// AdditionalUnattendContent
	additionalUnattendContentList := make([]AdditionalUnattendContent, len(source.AdditionalUnattendContent))
	for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
		// Shadow the loop variable to avoid aliasing
		additionalUnattendContentItem := additionalUnattendContentItem
		var additionalUnattendContent AdditionalUnattendContent
		err := additionalUnattendContent.AssignPropertiesFromAdditionalUnattendContent(&additionalUnattendContentItem)
		if err != nil {
			return errors.Wrap(err, "populating AdditionalUnattendContent from AdditionalUnattendContent, calling AssignPropertiesFromAdditionalUnattendContent()")
		}
		additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
	}
	windowsConfiguration.AdditionalUnattendContent = additionalUnattendContentList

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		windowsConfiguration.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		windowsConfiguration.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings
		err := patchSetting.AssignPropertiesFromPatchSettings(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesFromPatchSettings()")
		}
		windowsConfiguration.PatchSettings = &patchSetting
	} else {
		windowsConfiguration.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		windowsConfiguration.ProvisionVMAgent = &provisionVMAgent
	} else {
		windowsConfiguration.ProvisionVMAgent = nil
	}

	// TimeZone
	if source.TimeZone != nil {
		timeZone := *source.TimeZone
		windowsConfiguration.TimeZone = &timeZone
	} else {
		windowsConfiguration.TimeZone = nil
	}

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration
		err := winRM.AssignPropertiesFromWinRMConfiguration(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "populating WinRM from WinRM, calling AssignPropertiesFromWinRMConfiguration()")
		}
		windowsConfiguration.WinRM = &winRM
	} else {
		windowsConfiguration.WinRM = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWindowsConfiguration populates the provided destination WindowsConfiguration from our WindowsConfiguration
func (windowsConfiguration *WindowsConfiguration) AssignPropertiesToWindowsConfiguration(destination *v1alpha1api20201201storage.WindowsConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalUnattendContent
	additionalUnattendContentList := make([]v1alpha1api20201201storage.AdditionalUnattendContent, len(windowsConfiguration.AdditionalUnattendContent))
	for additionalUnattendContentIndex, additionalUnattendContentItem := range windowsConfiguration.AdditionalUnattendContent {
		// Shadow the loop variable to avoid aliasing
		additionalUnattendContentItem := additionalUnattendContentItem
		var additionalUnattendContent v1alpha1api20201201storage.AdditionalUnattendContent
		err := additionalUnattendContentItem.AssignPropertiesToAdditionalUnattendContent(&additionalUnattendContent)
		if err != nil {
			return errors.Wrap(err, "populating AdditionalUnattendContent from AdditionalUnattendContent, calling AssignPropertiesToAdditionalUnattendContent()")
		}
		additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
	}
	destination.AdditionalUnattendContent = additionalUnattendContentList

	// EnableAutomaticUpdates
	if windowsConfiguration.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *windowsConfiguration.EnableAutomaticUpdates
		destination.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		destination.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if windowsConfiguration.PatchSettings != nil {
		var patchSetting v1alpha1api20201201storage.PatchSettings
		err := (*windowsConfiguration.PatchSettings).AssignPropertiesToPatchSettings(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesToPatchSettings()")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if windowsConfiguration.ProvisionVMAgent != nil {
		provisionVMAgent := *windowsConfiguration.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// TimeZone
	if windowsConfiguration.TimeZone != nil {
		timeZone := *windowsConfiguration.TimeZone
		destination.TimeZone = &timeZone
	} else {
		destination.TimeZone = nil
	}

	// WinRM
	if windowsConfiguration.WinRM != nil {
		var winRM v1alpha1api20201201storage.WinRMConfiguration
		err := (*windowsConfiguration.WinRM).AssignPropertiesToWinRMConfiguration(&winRM)
		if err != nil {
			return errors.Wrap(err, "populating WinRM from WinRM, calling AssignPropertiesToWinRMConfiguration()")
		}
		destination.WinRM = &winRM
	} else {
		destination.WinRM = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type WindowsConfiguration_Status struct {
	//AdditionalUnattendContent: Specifies additional base-64 encoded XML formatted
	//information that can be included in the Unattend.xml file, which is used by
	//Windows Setup.
	AdditionalUnattendContent []AdditionalUnattendContent_Status `json:"additionalUnattendContent,omitempty"`

	//EnableAutomaticUpdates: Indicates whether Automatic Updates is enabled for the
	//Windows virtual machine. Default value is true.
	//For virtual machine scale sets, this property can be updated and updates will
	//take effect on OS reprovisioning.
	EnableAutomaticUpdates *bool `json:"enableAutomaticUpdates,omitempty"`

	//PatchSettings: [Preview Feature] Specifies settings related to VM Guest Patching
	//on Windows.
	PatchSettings *PatchSettings_Status `json:"patchSettings,omitempty"`

	//ProvisionVMAgent: Indicates whether virtual machine agent should be provisioned
	//on the virtual machine.
	//When this property is not specified in the request body, default behavior is to
	//set it to true.  This will ensure that VM Agent is installed on the VM so that
	//extensions can be added to the VM later.
	ProvisionVMAgent *bool `json:"provisionVMAgent,omitempty"`

	//TimeZone: Specifies the time zone of the virtual machine. e.g. "Pacific Standard
	//Time".
	//Possible values can be
	//[TimeZoneInfo.Id](https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.id?#System_TimeZoneInfo_Id)
	//value from time zones returned by
	//[TimeZoneInfo.GetSystemTimeZones](https://docs.microsoft.com/en-us/dotnet/api/system.timezoneinfo.getsystemtimezones).
	TimeZone *string `json:"timeZone,omitempty"`

	//WinRM: Specifies the Windows Remote Management listeners. This enables remote
	//Windows PowerShell.
	WinRM *WinRMConfiguration_Status `json:"winRM,omitempty"`
}

var _ genruntime.FromARMConverter = &WindowsConfiguration_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (windowsConfigurationStatus *WindowsConfiguration_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &WindowsConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (windowsConfigurationStatus *WindowsConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WindowsConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WindowsConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘AdditionalUnattendContent’:
	for _, item := range typedInput.AdditionalUnattendContent {
		var item1 AdditionalUnattendContent_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		windowsConfigurationStatus.AdditionalUnattendContent = append(windowsConfigurationStatus.AdditionalUnattendContent, item1)
	}

	// Set property ‘EnableAutomaticUpdates’:
	if typedInput.EnableAutomaticUpdates != nil {
		enableAutomaticUpdates := *typedInput.EnableAutomaticUpdates
		windowsConfigurationStatus.EnableAutomaticUpdates = &enableAutomaticUpdates
	}

	// Set property ‘PatchSettings’:
	if typedInput.PatchSettings != nil {
		var patchSettings1 PatchSettings_Status
		err := patchSettings1.PopulateFromARM(owner, *typedInput.PatchSettings)
		if err != nil {
			return err
		}
		patchSettings := patchSettings1
		windowsConfigurationStatus.PatchSettings = &patchSettings
	}

	// Set property ‘ProvisionVMAgent’:
	if typedInput.ProvisionVMAgent != nil {
		provisionVMAgent := *typedInput.ProvisionVMAgent
		windowsConfigurationStatus.ProvisionVMAgent = &provisionVMAgent
	}

	// Set property ‘TimeZone’:
	if typedInput.TimeZone != nil {
		timeZone := *typedInput.TimeZone
		windowsConfigurationStatus.TimeZone = &timeZone
	}

	// Set property ‘WinRM’:
	if typedInput.WinRM != nil {
		var winRM1 WinRMConfiguration_Status
		err := winRM1.PopulateFromARM(owner, *typedInput.WinRM)
		if err != nil {
			return err
		}
		winRM := winRM1
		windowsConfigurationStatus.WinRM = &winRM
	}

	// No error
	return nil
}

// AssignPropertiesFromWindowsConfigurationStatus populates our WindowsConfiguration_Status from the provided source WindowsConfiguration_Status
func (windowsConfigurationStatus *WindowsConfiguration_Status) AssignPropertiesFromWindowsConfigurationStatus(source *v1alpha1api20201201storage.WindowsConfiguration_Status) error {

	// AdditionalUnattendContent
	additionalUnattendContentList := make([]AdditionalUnattendContent_Status, len(source.AdditionalUnattendContent))
	for additionalUnattendContentIndex, additionalUnattendContentItem := range source.AdditionalUnattendContent {
		// Shadow the loop variable to avoid aliasing
		additionalUnattendContentItem := additionalUnattendContentItem
		var additionalUnattendContent AdditionalUnattendContent_Status
		err := additionalUnattendContent.AssignPropertiesFromAdditionalUnattendContentStatus(&additionalUnattendContentItem)
		if err != nil {
			return errors.Wrap(err, "populating AdditionalUnattendContent from AdditionalUnattendContent, calling AssignPropertiesFromAdditionalUnattendContentStatus()")
		}
		additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
	}
	windowsConfigurationStatus.AdditionalUnattendContent = additionalUnattendContentList

	// EnableAutomaticUpdates
	if source.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *source.EnableAutomaticUpdates
		windowsConfigurationStatus.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		windowsConfigurationStatus.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if source.PatchSettings != nil {
		var patchSetting PatchSettings_Status
		err := patchSetting.AssignPropertiesFromPatchSettingsStatus(source.PatchSettings)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesFromPatchSettingsStatus()")
		}
		windowsConfigurationStatus.PatchSettings = &patchSetting
	} else {
		windowsConfigurationStatus.PatchSettings = nil
	}

	// ProvisionVMAgent
	if source.ProvisionVMAgent != nil {
		provisionVMAgent := *source.ProvisionVMAgent
		windowsConfigurationStatus.ProvisionVMAgent = &provisionVMAgent
	} else {
		windowsConfigurationStatus.ProvisionVMAgent = nil
	}

	// TimeZone
	if source.TimeZone != nil {
		timeZone := *source.TimeZone
		windowsConfigurationStatus.TimeZone = &timeZone
	} else {
		windowsConfigurationStatus.TimeZone = nil
	}

	// WinRM
	if source.WinRM != nil {
		var winRM WinRMConfiguration_Status
		err := winRM.AssignPropertiesFromWinRMConfigurationStatus(source.WinRM)
		if err != nil {
			return errors.Wrap(err, "populating WinRM from WinRM, calling AssignPropertiesFromWinRMConfigurationStatus()")
		}
		windowsConfigurationStatus.WinRM = &winRM
	} else {
		windowsConfigurationStatus.WinRM = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWindowsConfigurationStatus populates the provided destination WindowsConfiguration_Status from our WindowsConfiguration_Status
func (windowsConfigurationStatus *WindowsConfiguration_Status) AssignPropertiesToWindowsConfigurationStatus(destination *v1alpha1api20201201storage.WindowsConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdditionalUnattendContent
	additionalUnattendContentList := make([]v1alpha1api20201201storage.AdditionalUnattendContent_Status, len(windowsConfigurationStatus.AdditionalUnattendContent))
	for additionalUnattendContentIndex, additionalUnattendContentItem := range windowsConfigurationStatus.AdditionalUnattendContent {
		// Shadow the loop variable to avoid aliasing
		additionalUnattendContentItem := additionalUnattendContentItem
		var additionalUnattendContent v1alpha1api20201201storage.AdditionalUnattendContent_Status
		err := additionalUnattendContentItem.AssignPropertiesToAdditionalUnattendContentStatus(&additionalUnattendContent)
		if err != nil {
			return errors.Wrap(err, "populating AdditionalUnattendContent from AdditionalUnattendContent, calling AssignPropertiesToAdditionalUnattendContentStatus()")
		}
		additionalUnattendContentList[additionalUnattendContentIndex] = additionalUnattendContent
	}
	destination.AdditionalUnattendContent = additionalUnattendContentList

	// EnableAutomaticUpdates
	if windowsConfigurationStatus.EnableAutomaticUpdates != nil {
		enableAutomaticUpdate := *windowsConfigurationStatus.EnableAutomaticUpdates
		destination.EnableAutomaticUpdates = &enableAutomaticUpdate
	} else {
		destination.EnableAutomaticUpdates = nil
	}

	// PatchSettings
	if windowsConfigurationStatus.PatchSettings != nil {
		var patchSetting v1alpha1api20201201storage.PatchSettings_Status
		err := (*windowsConfigurationStatus.PatchSettings).AssignPropertiesToPatchSettingsStatus(&patchSetting)
		if err != nil {
			return errors.Wrap(err, "populating PatchSettings from PatchSettings, calling AssignPropertiesToPatchSettingsStatus()")
		}
		destination.PatchSettings = &patchSetting
	} else {
		destination.PatchSettings = nil
	}

	// ProvisionVMAgent
	if windowsConfigurationStatus.ProvisionVMAgent != nil {
		provisionVMAgent := *windowsConfigurationStatus.ProvisionVMAgent
		destination.ProvisionVMAgent = &provisionVMAgent
	} else {
		destination.ProvisionVMAgent = nil
	}

	// TimeZone
	if windowsConfigurationStatus.TimeZone != nil {
		timeZone := *windowsConfigurationStatus.TimeZone
		destination.TimeZone = &timeZone
	} else {
		destination.TimeZone = nil
	}

	// WinRM
	if windowsConfigurationStatus.WinRM != nil {
		var winRM v1alpha1api20201201storage.WinRMConfiguration_Status
		err := (*windowsConfigurationStatus.WinRM).AssignPropertiesToWinRMConfigurationStatus(&winRM)
		if err != nil {
			return errors.Wrap(err, "populating WinRM from WinRM, calling AssignPropertiesToWinRMConfigurationStatus()")
		}
		destination.WinRM = &winRM
	} else {
		destination.WinRM = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/AdditionalUnattendContent
type AdditionalUnattendContent struct {
	//ComponentName: The component name. Currently, the only allowable value is
	//Microsoft-Windows-Shell-Setup.
	ComponentName *AdditionalUnattendContentComponentName `json:"componentName,omitempty"`

	//Content: Specifies the XML formatted content that is added to the unattend.xml
	//file for the specified path and component. The XML must be less than 4KB and
	//must include the root element for the setting or feature that is being inserted.
	Content *string `json:"content,omitempty"`

	//PassName: The pass name. Currently, the only allowable value is OobeSystem.
	PassName *AdditionalUnattendContentPassName `json:"passName,omitempty"`

	//SettingName: Specifies the name of the setting to which the content applies.
	//Possible values are: FirstLogonCommands and AutoLogon.
	SettingName *AdditionalUnattendContentSettingName `json:"settingName,omitempty"`
}

var _ genruntime.ARMTransformer = &AdditionalUnattendContent{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (additionalUnattendContent *AdditionalUnattendContent) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if additionalUnattendContent == nil {
		return nil, nil
	}
	var result AdditionalUnattendContentARM

	// Set property ‘ComponentName’:
	if additionalUnattendContent.ComponentName != nil {
		componentName := *additionalUnattendContent.ComponentName
		result.ComponentName = &componentName
	}

	// Set property ‘Content’:
	if additionalUnattendContent.Content != nil {
		content := *additionalUnattendContent.Content
		result.Content = &content
	}

	// Set property ‘PassName’:
	if additionalUnattendContent.PassName != nil {
		passName := *additionalUnattendContent.PassName
		result.PassName = &passName
	}

	// Set property ‘SettingName’:
	if additionalUnattendContent.SettingName != nil {
		settingName := *additionalUnattendContent.SettingName
		result.SettingName = &settingName
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (additionalUnattendContent *AdditionalUnattendContent) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdditionalUnattendContentARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (additionalUnattendContent *AdditionalUnattendContent) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdditionalUnattendContentARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdditionalUnattendContentARM, got %T", armInput)
	}

	// Set property ‘ComponentName’:
	if typedInput.ComponentName != nil {
		componentName := *typedInput.ComponentName
		additionalUnattendContent.ComponentName = &componentName
	}

	// Set property ‘Content’:
	if typedInput.Content != nil {
		content := *typedInput.Content
		additionalUnattendContent.Content = &content
	}

	// Set property ‘PassName’:
	if typedInput.PassName != nil {
		passName := *typedInput.PassName
		additionalUnattendContent.PassName = &passName
	}

	// Set property ‘SettingName’:
	if typedInput.SettingName != nil {
		settingName := *typedInput.SettingName
		additionalUnattendContent.SettingName = &settingName
	}

	// No error
	return nil
}

// AssignPropertiesFromAdditionalUnattendContent populates our AdditionalUnattendContent from the provided source AdditionalUnattendContent
func (additionalUnattendContent *AdditionalUnattendContent) AssignPropertiesFromAdditionalUnattendContent(source *v1alpha1api20201201storage.AdditionalUnattendContent) error {

	// ComponentName
	if source.ComponentName != nil {
		componentName := AdditionalUnattendContentComponentName(*source.ComponentName)
		additionalUnattendContent.ComponentName = &componentName
	} else {
		additionalUnattendContent.ComponentName = nil
	}

	// Content
	if source.Content != nil {
		content := *source.Content
		additionalUnattendContent.Content = &content
	} else {
		additionalUnattendContent.Content = nil
	}

	// PassName
	if source.PassName != nil {
		passName := AdditionalUnattendContentPassName(*source.PassName)
		additionalUnattendContent.PassName = &passName
	} else {
		additionalUnattendContent.PassName = nil
	}

	// SettingName
	if source.SettingName != nil {
		settingName := AdditionalUnattendContentSettingName(*source.SettingName)
		additionalUnattendContent.SettingName = &settingName
	} else {
		additionalUnattendContent.SettingName = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalUnattendContent populates the provided destination AdditionalUnattendContent from our AdditionalUnattendContent
func (additionalUnattendContent *AdditionalUnattendContent) AssignPropertiesToAdditionalUnattendContent(destination *v1alpha1api20201201storage.AdditionalUnattendContent) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComponentName
	if additionalUnattendContent.ComponentName != nil {
		componentName := string(*additionalUnattendContent.ComponentName)
		destination.ComponentName = &componentName
	} else {
		destination.ComponentName = nil
	}

	// Content
	if additionalUnattendContent.Content != nil {
		content := *additionalUnattendContent.Content
		destination.Content = &content
	} else {
		destination.Content = nil
	}

	// PassName
	if additionalUnattendContent.PassName != nil {
		passName := string(*additionalUnattendContent.PassName)
		destination.PassName = &passName
	} else {
		destination.PassName = nil
	}

	// SettingName
	if additionalUnattendContent.SettingName != nil {
		settingName := string(*additionalUnattendContent.SettingName)
		destination.SettingName = &settingName
	} else {
		destination.SettingName = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type AdditionalUnattendContent_Status struct {
	//ComponentName: The component name. Currently, the only allowable value is
	//Microsoft-Windows-Shell-Setup.
	ComponentName *AdditionalUnattendContentStatusComponentName `json:"componentName,omitempty"`

	//Content: Specifies the XML formatted content that is added to the unattend.xml
	//file for the specified path and component. The XML must be less than 4KB and
	//must include the root element for the setting or feature that is being inserted.
	Content *string `json:"content,omitempty"`

	//PassName: The pass name. Currently, the only allowable value is OobeSystem.
	PassName *AdditionalUnattendContentStatusPassName `json:"passName,omitempty"`

	//SettingName: Specifies the name of the setting to which the content applies.
	//Possible values are: FirstLogonCommands and AutoLogon.
	SettingName *AdditionalUnattendContentStatusSettingName `json:"settingName,omitempty"`
}

var _ genruntime.FromARMConverter = &AdditionalUnattendContent_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (additionalUnattendContentStatus *AdditionalUnattendContent_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &AdditionalUnattendContent_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (additionalUnattendContentStatus *AdditionalUnattendContent_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(AdditionalUnattendContent_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected AdditionalUnattendContent_StatusARM, got %T", armInput)
	}

	// Set property ‘ComponentName’:
	if typedInput.ComponentName != nil {
		componentName := *typedInput.ComponentName
		additionalUnattendContentStatus.ComponentName = &componentName
	}

	// Set property ‘Content’:
	if typedInput.Content != nil {
		content := *typedInput.Content
		additionalUnattendContentStatus.Content = &content
	}

	// Set property ‘PassName’:
	if typedInput.PassName != nil {
		passName := *typedInput.PassName
		additionalUnattendContentStatus.PassName = &passName
	}

	// Set property ‘SettingName’:
	if typedInput.SettingName != nil {
		settingName := *typedInput.SettingName
		additionalUnattendContentStatus.SettingName = &settingName
	}

	// No error
	return nil
}

// AssignPropertiesFromAdditionalUnattendContentStatus populates our AdditionalUnattendContent_Status from the provided source AdditionalUnattendContent_Status
func (additionalUnattendContentStatus *AdditionalUnattendContent_Status) AssignPropertiesFromAdditionalUnattendContentStatus(source *v1alpha1api20201201storage.AdditionalUnattendContent_Status) error {

	// ComponentName
	if source.ComponentName != nil {
		componentName := AdditionalUnattendContentStatusComponentName(*source.ComponentName)
		additionalUnattendContentStatus.ComponentName = &componentName
	} else {
		additionalUnattendContentStatus.ComponentName = nil
	}

	// Content
	if source.Content != nil {
		content := *source.Content
		additionalUnattendContentStatus.Content = &content
	} else {
		additionalUnattendContentStatus.Content = nil
	}

	// PassName
	if source.PassName != nil {
		passName := AdditionalUnattendContentStatusPassName(*source.PassName)
		additionalUnattendContentStatus.PassName = &passName
	} else {
		additionalUnattendContentStatus.PassName = nil
	}

	// SettingName
	if source.SettingName != nil {
		settingName := AdditionalUnattendContentStatusSettingName(*source.SettingName)
		additionalUnattendContentStatus.SettingName = &settingName
	} else {
		additionalUnattendContentStatus.SettingName = nil
	}

	// No error
	return nil
}

// AssignPropertiesToAdditionalUnattendContentStatus populates the provided destination AdditionalUnattendContent_Status from our AdditionalUnattendContent_Status
func (additionalUnattendContentStatus *AdditionalUnattendContent_Status) AssignPropertiesToAdditionalUnattendContentStatus(destination *v1alpha1api20201201storage.AdditionalUnattendContent_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComponentName
	if additionalUnattendContentStatus.ComponentName != nil {
		componentName := string(*additionalUnattendContentStatus.ComponentName)
		destination.ComponentName = &componentName
	} else {
		destination.ComponentName = nil
	}

	// Content
	if additionalUnattendContentStatus.Content != nil {
		content := *additionalUnattendContentStatus.Content
		destination.Content = &content
	} else {
		destination.Content = nil
	}

	// PassName
	if additionalUnattendContentStatus.PassName != nil {
		passName := string(*additionalUnattendContentStatus.PassName)
		destination.PassName = &passName
	} else {
		destination.PassName = nil
	}

	// SettingName
	if additionalUnattendContentStatus.SettingName != nil {
		settingName := string(*additionalUnattendContentStatus.SettingName)
		destination.SettingName = &settingName
	} else {
		destination.SettingName = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type Caching_Status string

const (
	Caching_StatusNone      = Caching_Status("None")
	Caching_StatusReadOnly  = Caching_Status("ReadOnly")
	Caching_StatusReadWrite = Caching_Status("ReadWrite")
)

//Generated from:
type CreateOption_Status string

const (
	CreateOption_StatusAttach    = CreateOption_Status("Attach")
	CreateOption_StatusEmpty     = CreateOption_Status("Empty")
	CreateOption_StatusFromImage = CreateOption_Status("FromImage")
)

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/DiffDiskSettings
type DiffDiskSettings struct {
	//Option: Specifies the ephemeral disk settings for operating system disk.
	Option *DiffDiskSettingsOption `json:"option,omitempty"`

	//Placement: Specifies the ephemeral disk placement for operating system disk.
	//Possible values are:
	//CacheDisk
	//ResourceDisk
	//Default: CacheDisk if one is configured for the VM size otherwise ResourceDisk
	//is used.
	//Refer to VM size documentation for Windows VM at
	//https://docs.microsoft.com/en-us/azure/virtual-machines/windows/sizes and Linux
	//VM at https://docs.microsoft.com/en-us/azure/virtual-machines/linux/sizes to
	//check which VM sizes exposes a cache disk.
	Placement *DiffDiskSettingsPlacement `json:"placement,omitempty"`
}

var _ genruntime.ARMTransformer = &DiffDiskSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (diffDiskSettings *DiffDiskSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if diffDiskSettings == nil {
		return nil, nil
	}
	var result DiffDiskSettingsARM

	// Set property ‘Option’:
	if diffDiskSettings.Option != nil {
		option := *diffDiskSettings.Option
		result.Option = &option
	}

	// Set property ‘Placement’:
	if diffDiskSettings.Placement != nil {
		placement := *diffDiskSettings.Placement
		result.Placement = &placement
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diffDiskSettings *DiffDiskSettings) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiffDiskSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diffDiskSettings *DiffDiskSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiffDiskSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiffDiskSettingsARM, got %T", armInput)
	}

	// Set property ‘Option’:
	if typedInput.Option != nil {
		option := *typedInput.Option
		diffDiskSettings.Option = &option
	}

	// Set property ‘Placement’:
	if typedInput.Placement != nil {
		placement := *typedInput.Placement
		diffDiskSettings.Placement = &placement
	}

	// No error
	return nil
}

// AssignPropertiesFromDiffDiskSettings populates our DiffDiskSettings from the provided source DiffDiskSettings
func (diffDiskSettings *DiffDiskSettings) AssignPropertiesFromDiffDiskSettings(source *v1alpha1api20201201storage.DiffDiskSettings) error {

	// Option
	if source.Option != nil {
		option := DiffDiskSettingsOption(*source.Option)
		diffDiskSettings.Option = &option
	} else {
		diffDiskSettings.Option = nil
	}

	// Placement
	if source.Placement != nil {
		placement := DiffDiskSettingsPlacement(*source.Placement)
		diffDiskSettings.Placement = &placement
	} else {
		diffDiskSettings.Placement = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiffDiskSettings populates the provided destination DiffDiskSettings from our DiffDiskSettings
func (diffDiskSettings *DiffDiskSettings) AssignPropertiesToDiffDiskSettings(destination *v1alpha1api20201201storage.DiffDiskSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Option
	if diffDiskSettings.Option != nil {
		option := string(*diffDiskSettings.Option)
		destination.Option = &option
	} else {
		destination.Option = nil
	}

	// Placement
	if diffDiskSettings.Placement != nil {
		placement := string(*diffDiskSettings.Placement)
		destination.Placement = &placement
	} else {
		destination.Placement = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type DiffDiskSettings_Status struct {
	//Option: Specifies the ephemeral disk settings for operating system disk.
	Option *DiffDiskOption_Status `json:"option,omitempty"`

	//Placement: Specifies the ephemeral disk placement for operating system disk.
	//Possible values are:
	//CacheDisk
	//ResourceDisk
	//Default: CacheDisk if one is configured for the VM size otherwise ResourceDisk
	//is used.
	//Refer to VM size documentation for Windows VM at
	//https://docs.microsoft.com/en-us/azure/virtual-machines/windows/sizes and Linux
	//VM at https://docs.microsoft.com/en-us/azure/virtual-machines/linux/sizes to
	//check which VM sizes exposes a cache disk.
	Placement *DiffDiskPlacement_Status `json:"placement,omitempty"`
}

var _ genruntime.FromARMConverter = &DiffDiskSettings_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diffDiskSettingsStatus *DiffDiskSettings_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiffDiskSettings_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diffDiskSettingsStatus *DiffDiskSettings_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DiffDiskSettings_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiffDiskSettings_StatusARM, got %T", armInput)
	}

	// Set property ‘Option’:
	if typedInput.Option != nil {
		option := *typedInput.Option
		diffDiskSettingsStatus.Option = &option
	}

	// Set property ‘Placement’:
	if typedInput.Placement != nil {
		placement := *typedInput.Placement
		diffDiskSettingsStatus.Placement = &placement
	}

	// No error
	return nil
}

// AssignPropertiesFromDiffDiskSettingsStatus populates our DiffDiskSettings_Status from the provided source DiffDiskSettings_Status
func (diffDiskSettingsStatus *DiffDiskSettings_Status) AssignPropertiesFromDiffDiskSettingsStatus(source *v1alpha1api20201201storage.DiffDiskSettings_Status) error {

	// Option
	if source.Option != nil {
		option := DiffDiskOption_Status(*source.Option)
		diffDiskSettingsStatus.Option = &option
	} else {
		diffDiskSettingsStatus.Option = nil
	}

	// Placement
	if source.Placement != nil {
		placement := DiffDiskPlacement_Status(*source.Placement)
		diffDiskSettingsStatus.Placement = &placement
	} else {
		diffDiskSettingsStatus.Placement = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiffDiskSettingsStatus populates the provided destination DiffDiskSettings_Status from our DiffDiskSettings_Status
func (diffDiskSettingsStatus *DiffDiskSettings_Status) AssignPropertiesToDiffDiskSettingsStatus(destination *v1alpha1api20201201storage.DiffDiskSettings_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Option
	if diffDiskSettingsStatus.Option != nil {
		option := string(*diffDiskSettingsStatus.Option)
		destination.Option = &option
	} else {
		destination.Option = nil
	}

	// Placement
	if diffDiskSettingsStatus.Placement != nil {
		placement := string(*diffDiskSettingsStatus.Placement)
		destination.Placement = &placement
	} else {
		destination.Placement = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/LinuxPatchSettings
type LinuxPatchSettings struct {
	//PatchMode: Specifies the mode of VM Guest Patching to IaaS virtual machine.
	//Possible values are:
	//ImageDefault - The virtual machine's default patching configuration is used.
	//AutomaticByPlatform - The virtual machine will be automatically updated by the
	//platform. The property provisionVMAgent must be true.
	PatchMode *LinuxPatchSettingsPatchMode `json:"patchMode,omitempty"`
}

var _ genruntime.ARMTransformer = &LinuxPatchSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (linuxPatchSettings *LinuxPatchSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if linuxPatchSettings == nil {
		return nil, nil
	}
	var result LinuxPatchSettingsARM

	// Set property ‘PatchMode’:
	if linuxPatchSettings.PatchMode != nil {
		patchMode := *linuxPatchSettings.PatchMode
		result.PatchMode = &patchMode
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (linuxPatchSettings *LinuxPatchSettings) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LinuxPatchSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (linuxPatchSettings *LinuxPatchSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LinuxPatchSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LinuxPatchSettingsARM, got %T", armInput)
	}

	// Set property ‘PatchMode’:
	if typedInput.PatchMode != nil {
		patchMode := *typedInput.PatchMode
		linuxPatchSettings.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignPropertiesFromLinuxPatchSettings populates our LinuxPatchSettings from the provided source LinuxPatchSettings
func (linuxPatchSettings *LinuxPatchSettings) AssignPropertiesFromLinuxPatchSettings(source *v1alpha1api20201201storage.LinuxPatchSettings) error {

	// PatchMode
	if source.PatchMode != nil {
		patchMode := LinuxPatchSettingsPatchMode(*source.PatchMode)
		linuxPatchSettings.PatchMode = &patchMode
	} else {
		linuxPatchSettings.PatchMode = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxPatchSettings populates the provided destination LinuxPatchSettings from our LinuxPatchSettings
func (linuxPatchSettings *LinuxPatchSettings) AssignPropertiesToLinuxPatchSettings(destination *v1alpha1api20201201storage.LinuxPatchSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PatchMode
	if linuxPatchSettings.PatchMode != nil {
		patchMode := string(*linuxPatchSettings.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type LinuxPatchSettings_Status struct {
	//PatchMode: Specifies the mode of VM Guest Patching to IaaS virtual machine.
	//Possible values are:
	//ImageDefault - The virtual machine's default patching configuration is used.
	//AutomaticByPlatform - The virtual machine will be automatically updated by the
	//platform. The property provisionVMAgent must be true
	PatchMode *LinuxPatchSettingsStatusPatchMode `json:"patchMode,omitempty"`
}

var _ genruntime.FromARMConverter = &LinuxPatchSettings_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (linuxPatchSettingsStatus *LinuxPatchSettings_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &LinuxPatchSettings_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (linuxPatchSettingsStatus *LinuxPatchSettings_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(LinuxPatchSettings_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected LinuxPatchSettings_StatusARM, got %T", armInput)
	}

	// Set property ‘PatchMode’:
	if typedInput.PatchMode != nil {
		patchMode := *typedInput.PatchMode
		linuxPatchSettingsStatus.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignPropertiesFromLinuxPatchSettingsStatus populates our LinuxPatchSettings_Status from the provided source LinuxPatchSettings_Status
func (linuxPatchSettingsStatus *LinuxPatchSettings_Status) AssignPropertiesFromLinuxPatchSettingsStatus(source *v1alpha1api20201201storage.LinuxPatchSettings_Status) error {

	// PatchMode
	if source.PatchMode != nil {
		patchMode := LinuxPatchSettingsStatusPatchMode(*source.PatchMode)
		linuxPatchSettingsStatus.PatchMode = &patchMode
	} else {
		linuxPatchSettingsStatus.PatchMode = nil
	}

	// No error
	return nil
}

// AssignPropertiesToLinuxPatchSettingsStatus populates the provided destination LinuxPatchSettings_Status from our LinuxPatchSettings_Status
func (linuxPatchSettingsStatus *LinuxPatchSettings_Status) AssignPropertiesToLinuxPatchSettingsStatus(destination *v1alpha1api20201201storage.LinuxPatchSettings_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PatchMode
	if linuxPatchSettingsStatus.PatchMode != nil {
		patchMode := string(*linuxPatchSettingsStatus.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/PatchSettings
type PatchSettings struct {
	//EnableHotpatching: Enables customers to patch their Azure VMs without requiring
	//a reboot. For enableHotpatching, the 'provisionVMAgent' must be set to true and
	//'patchMode' must be set to 'AutomaticByPlatform'.
	EnableHotpatching *bool `json:"enableHotpatching,omitempty"`

	//PatchMode: Specifies the mode of VM Guest Patching to IaaS virtual machine.
	//Possible values are:
	//Manual - You  control the application of patches to a virtual machine. You do
	//this by applying patches manually inside the VM. In this mode, automatic updates
	//are disabled; the property WindowsConfiguration.enableAutomaticUpdates must be
	//false
	//AutomaticByOS - The virtual machine will automatically be updated by the OS. The
	//property WindowsConfiguration.enableAutomaticUpdates must be true.
	//AutomaticByPlatform - the virtual machine will automatically updated by the
	//platform. The properties provisionVMAgent and
	//WindowsConfiguration.enableAutomaticUpdates must be true.
	PatchMode *PatchSettingsPatchMode `json:"patchMode,omitempty"`
}

var _ genruntime.ARMTransformer = &PatchSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (patchSettings *PatchSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if patchSettings == nil {
		return nil, nil
	}
	var result PatchSettingsARM

	// Set property ‘EnableHotpatching’:
	if patchSettings.EnableHotpatching != nil {
		enableHotpatching := *patchSettings.EnableHotpatching
		result.EnableHotpatching = &enableHotpatching
	}

	// Set property ‘PatchMode’:
	if patchSettings.PatchMode != nil {
		patchMode := *patchSettings.PatchMode
		result.PatchMode = &patchMode
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (patchSettings *PatchSettings) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &PatchSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (patchSettings *PatchSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PatchSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PatchSettingsARM, got %T", armInput)
	}

	// Set property ‘EnableHotpatching’:
	if typedInput.EnableHotpatching != nil {
		enableHotpatching := *typedInput.EnableHotpatching
		patchSettings.EnableHotpatching = &enableHotpatching
	}

	// Set property ‘PatchMode’:
	if typedInput.PatchMode != nil {
		patchMode := *typedInput.PatchMode
		patchSettings.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignPropertiesFromPatchSettings populates our PatchSettings from the provided source PatchSettings
func (patchSettings *PatchSettings) AssignPropertiesFromPatchSettings(source *v1alpha1api20201201storage.PatchSettings) error {

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		patchSettings.EnableHotpatching = &enableHotpatching
	} else {
		patchSettings.EnableHotpatching = nil
	}

	// PatchMode
	if source.PatchMode != nil {
		patchMode := PatchSettingsPatchMode(*source.PatchMode)
		patchSettings.PatchMode = &patchMode
	} else {
		patchSettings.PatchMode = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPatchSettings populates the provided destination PatchSettings from our PatchSettings
func (patchSettings *PatchSettings) AssignPropertiesToPatchSettings(destination *v1alpha1api20201201storage.PatchSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableHotpatching
	if patchSettings.EnableHotpatching != nil {
		enableHotpatching := *patchSettings.EnableHotpatching
		destination.EnableHotpatching = &enableHotpatching
	} else {
		destination.EnableHotpatching = nil
	}

	// PatchMode
	if patchSettings.PatchMode != nil {
		patchMode := string(*patchSettings.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type PatchSettings_Status struct {
	//EnableHotpatching: Enables customers to patch their Azure VMs without requiring
	//a reboot. For enableHotpatching, the 'provisionVMAgent' must be set to true and
	//'patchMode' must be set to 'AutomaticByPlatform'.
	EnableHotpatching *bool `json:"enableHotpatching,omitempty"`

	//PatchMode: Specifies the mode of VM Guest Patching to IaaS virtual machine.
	//Possible values are:
	//Manual - You  control the application of patches to a virtual machine. You do
	//this by applying patches manually inside the VM. In this mode, automatic updates
	//are disabled; the property WindowsConfiguration.enableAutomaticUpdates must be
	//false
	//AutomaticByOS - The virtual machine will automatically be updated by the OS. The
	//property WindowsConfiguration.enableAutomaticUpdates must be true.
	//AutomaticByPlatform - the virtual machine will automatically updated by the
	//platform. The properties provisionVMAgent and
	//WindowsConfiguration.enableAutomaticUpdates must be true
	PatchMode *PatchSettingsStatusPatchMode `json:"patchMode,omitempty"`
}

var _ genruntime.FromARMConverter = &PatchSettings_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (patchSettingsStatus *PatchSettings_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &PatchSettings_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (patchSettingsStatus *PatchSettings_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PatchSettings_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PatchSettings_StatusARM, got %T", armInput)
	}

	// Set property ‘EnableHotpatching’:
	if typedInput.EnableHotpatching != nil {
		enableHotpatching := *typedInput.EnableHotpatching
		patchSettingsStatus.EnableHotpatching = &enableHotpatching
	}

	// Set property ‘PatchMode’:
	if typedInput.PatchMode != nil {
		patchMode := *typedInput.PatchMode
		patchSettingsStatus.PatchMode = &patchMode
	}

	// No error
	return nil
}

// AssignPropertiesFromPatchSettingsStatus populates our PatchSettings_Status from the provided source PatchSettings_Status
func (patchSettingsStatus *PatchSettings_Status) AssignPropertiesFromPatchSettingsStatus(source *v1alpha1api20201201storage.PatchSettings_Status) error {

	// EnableHotpatching
	if source.EnableHotpatching != nil {
		enableHotpatching := *source.EnableHotpatching
		patchSettingsStatus.EnableHotpatching = &enableHotpatching
	} else {
		patchSettingsStatus.EnableHotpatching = nil
	}

	// PatchMode
	if source.PatchMode != nil {
		patchMode := PatchSettingsStatusPatchMode(*source.PatchMode)
		patchSettingsStatus.PatchMode = &patchMode
	} else {
		patchSettingsStatus.PatchMode = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPatchSettingsStatus populates the provided destination PatchSettings_Status from our PatchSettings_Status
func (patchSettingsStatus *PatchSettings_Status) AssignPropertiesToPatchSettingsStatus(destination *v1alpha1api20201201storage.PatchSettings_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EnableHotpatching
	if patchSettingsStatus.EnableHotpatching != nil {
		enableHotpatching := *patchSettingsStatus.EnableHotpatching
		destination.EnableHotpatching = &enableHotpatching
	} else {
		destination.EnableHotpatching = nil
	}

	// PatchMode
	if patchSettingsStatus.PatchMode != nil {
		patchMode := string(*patchSettingsStatus.PatchMode)
		destination.PatchMode = &patchMode
	} else {
		destination.PatchMode = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/SshConfiguration
type SshConfiguration struct {
	//PublicKeys: The list of SSH public keys used to authenticate with linux based
	//VMs.
	PublicKeys []SshPublicKey `json:"publicKeys,omitempty"`
}

var _ genruntime.ARMTransformer = &SshConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sshConfiguration *SshConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sshConfiguration == nil {
		return nil, nil
	}
	var result SshConfigurationARM

	// Set property ‘PublicKeys’:
	for _, item := range sshConfiguration.PublicKeys {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.PublicKeys = append(result.PublicKeys, itemARM.(SshPublicKeyARM))
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sshConfiguration *SshConfiguration) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &SshConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sshConfiguration *SshConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SshConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SshConfigurationARM, got %T", armInput)
	}

	// Set property ‘PublicKeys’:
	for _, item := range typedInput.PublicKeys {
		var item1 SshPublicKey
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sshConfiguration.PublicKeys = append(sshConfiguration.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromSshConfiguration populates our SshConfiguration from the provided source SshConfiguration
func (sshConfiguration *SshConfiguration) AssignPropertiesFromSshConfiguration(source *v1alpha1api20201201storage.SshConfiguration) error {

	// PublicKeys
	publicKeyList := make([]SshPublicKey, len(source.PublicKeys))
	for publicKeyIndex, publicKeyItem := range source.PublicKeys {
		// Shadow the loop variable to avoid aliasing
		publicKeyItem := publicKeyItem
		var publicKey SshPublicKey
		err := publicKey.AssignPropertiesFromSshPublicKey(&publicKeyItem)
		if err != nil {
			return errors.Wrap(err, "populating PublicKeys from PublicKeys, calling AssignPropertiesFromSshPublicKey()")
		}
		publicKeyList[publicKeyIndex] = publicKey
	}
	sshConfiguration.PublicKeys = publicKeyList

	// No error
	return nil
}

// AssignPropertiesToSshConfiguration populates the provided destination SshConfiguration from our SshConfiguration
func (sshConfiguration *SshConfiguration) AssignPropertiesToSshConfiguration(destination *v1alpha1api20201201storage.SshConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	publicKeyList := make([]v1alpha1api20201201storage.SshPublicKey, len(sshConfiguration.PublicKeys))
	for publicKeyIndex, publicKeyItem := range sshConfiguration.PublicKeys {
		// Shadow the loop variable to avoid aliasing
		publicKeyItem := publicKeyItem
		var publicKey v1alpha1api20201201storage.SshPublicKey
		err := publicKeyItem.AssignPropertiesToSshPublicKey(&publicKey)
		if err != nil {
			return errors.Wrap(err, "populating PublicKeys from PublicKeys, calling AssignPropertiesToSshPublicKey()")
		}
		publicKeyList[publicKeyIndex] = publicKey
	}
	destination.PublicKeys = publicKeyList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type SshConfiguration_Status struct {
	//PublicKeys: The list of SSH public keys used to authenticate with linux based
	//VMs.
	PublicKeys []SshPublicKey_Status `json:"publicKeys,omitempty"`
}

var _ genruntime.FromARMConverter = &SshConfiguration_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sshConfigurationStatus *SshConfiguration_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &SshConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sshConfigurationStatus *SshConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SshConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SshConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘PublicKeys’:
	for _, item := range typedInput.PublicKeys {
		var item1 SshPublicKey_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		sshConfigurationStatus.PublicKeys = append(sshConfigurationStatus.PublicKeys, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromSshConfigurationStatus populates our SshConfiguration_Status from the provided source SshConfiguration_Status
func (sshConfigurationStatus *SshConfiguration_Status) AssignPropertiesFromSshConfigurationStatus(source *v1alpha1api20201201storage.SshConfiguration_Status) error {

	// PublicKeys
	publicKeyList := make([]SshPublicKey_Status, len(source.PublicKeys))
	for publicKeyIndex, publicKeyItem := range source.PublicKeys {
		// Shadow the loop variable to avoid aliasing
		publicKeyItem := publicKeyItem
		var publicKey SshPublicKey_Status
		err := publicKey.AssignPropertiesFromSshPublicKeyStatus(&publicKeyItem)
		if err != nil {
			return errors.Wrap(err, "populating PublicKeys from PublicKeys, calling AssignPropertiesFromSshPublicKeyStatus()")
		}
		publicKeyList[publicKeyIndex] = publicKey
	}
	sshConfigurationStatus.PublicKeys = publicKeyList

	// No error
	return nil
}

// AssignPropertiesToSshConfigurationStatus populates the provided destination SshConfiguration_Status from our SshConfiguration_Status
func (sshConfigurationStatus *SshConfiguration_Status) AssignPropertiesToSshConfigurationStatus(destination *v1alpha1api20201201storage.SshConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PublicKeys
	publicKeyList := make([]v1alpha1api20201201storage.SshPublicKey_Status, len(sshConfigurationStatus.PublicKeys))
	for publicKeyIndex, publicKeyItem := range sshConfigurationStatus.PublicKeys {
		// Shadow the loop variable to avoid aliasing
		publicKeyItem := publicKeyItem
		var publicKey v1alpha1api20201201storage.SshPublicKey_Status
		err := publicKeyItem.AssignPropertiesToSshPublicKeyStatus(&publicKey)
		if err != nil {
			return errors.Wrap(err, "populating PublicKeys from PublicKeys, calling AssignPropertiesToSshPublicKeyStatus()")
		}
		publicKeyList[publicKeyIndex] = publicKey
	}
	destination.PublicKeys = publicKeyList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VaultCertificate
type VaultCertificate struct {
	//CertificateStore: For Windows VMs, specifies the certificate store on the
	//Virtual Machine to which the certificate should be added. The specified
	//certificate store is implicitly in the LocalMachine account.
	//For Linux VMs, the certificate file is placed under the /var/lib/waagent
	//directory, with the file name &lt;UppercaseThumbprint&gt;.crt for the X509
	//certificate file and &lt;UppercaseThumbprint&gt;.prv for private key. Both of
	//these files are .pem formatted.
	CertificateStore *string `json:"certificateStore,omitempty"`

	//CertificateUrl: This is the URL of a certificate that has been uploaded to Key
	//Vault as a secret. For adding a secret to the Key Vault, see [Add a key or
	//secret to the key
	//vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
	//In this case, your certificate needs to be It is the Base64 encoding of the
	//following JSON Object which is encoded in UTF-8:
	//{
	//"data":"<Base64-encoded-certificate>",
	//"dataType":"pfx",
	//"password":"<pfx-file-password>"
	//}
	CertificateUrl *string `json:"certificateUrl,omitempty"`
}

var _ genruntime.ARMTransformer = &VaultCertificate{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (vaultCertificate *VaultCertificate) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if vaultCertificate == nil {
		return nil, nil
	}
	var result VaultCertificateARM

	// Set property ‘CertificateStore’:
	if vaultCertificate.CertificateStore != nil {
		certificateStore := *vaultCertificate.CertificateStore
		result.CertificateStore = &certificateStore
	}

	// Set property ‘CertificateUrl’:
	if vaultCertificate.CertificateUrl != nil {
		certificateUrl := *vaultCertificate.CertificateUrl
		result.CertificateUrl = &certificateUrl
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vaultCertificate *VaultCertificate) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VaultCertificateARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vaultCertificate *VaultCertificate) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VaultCertificateARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VaultCertificateARM, got %T", armInput)
	}

	// Set property ‘CertificateStore’:
	if typedInput.CertificateStore != nil {
		certificateStore := *typedInput.CertificateStore
		vaultCertificate.CertificateStore = &certificateStore
	}

	// Set property ‘CertificateUrl’:
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		vaultCertificate.CertificateUrl = &certificateUrl
	}

	// No error
	return nil
}

// AssignPropertiesFromVaultCertificate populates our VaultCertificate from the provided source VaultCertificate
func (vaultCertificate *VaultCertificate) AssignPropertiesFromVaultCertificate(source *v1alpha1api20201201storage.VaultCertificate) error {

	// CertificateStore
	if source.CertificateStore != nil {
		certificateStore := *source.CertificateStore
		vaultCertificate.CertificateStore = &certificateStore
	} else {
		vaultCertificate.CertificateStore = nil
	}

	// CertificateUrl
	if source.CertificateUrl != nil {
		certificateUrl := *source.CertificateUrl
		vaultCertificate.CertificateUrl = &certificateUrl
	} else {
		vaultCertificate.CertificateUrl = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVaultCertificate populates the provided destination VaultCertificate from our VaultCertificate
func (vaultCertificate *VaultCertificate) AssignPropertiesToVaultCertificate(destination *v1alpha1api20201201storage.VaultCertificate) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateStore
	if vaultCertificate.CertificateStore != nil {
		certificateStore := *vaultCertificate.CertificateStore
		destination.CertificateStore = &certificateStore
	} else {
		destination.CertificateStore = nil
	}

	// CertificateUrl
	if vaultCertificate.CertificateUrl != nil {
		certificateUrl := *vaultCertificate.CertificateUrl
		destination.CertificateUrl = &certificateUrl
	} else {
		destination.CertificateUrl = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VaultCertificate_Status struct {
	//CertificateStore: For Windows VMs, specifies the certificate store on the
	//Virtual Machine to which the certificate should be added. The specified
	//certificate store is implicitly in the LocalMachine account.
	//For Linux VMs, the certificate file is placed under the /var/lib/waagent
	//directory, with the file name &lt;UppercaseThumbprint&gt;.crt for the X509
	//certificate file and &lt;UppercaseThumbprint&gt;.prv for private key. Both of
	//these files are .pem formatted.
	CertificateStore *string `json:"certificateStore,omitempty"`

	//CertificateUrl: This is the URL of a certificate that has been uploaded to Key
	//Vault as a secret. For adding a secret to the Key Vault, see [Add a key or
	//secret to the key
	//vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
	//In this case, your certificate needs to be It is the Base64 encoding of the
	//following JSON Object which is encoded in UTF-8:
	//{
	//"data":"<Base64-encoded-certificate>",
	//"dataType":"pfx",
	//"password":"<pfx-file-password>"
	//}
	CertificateUrl *string `json:"certificateUrl,omitempty"`
}

var _ genruntime.FromARMConverter = &VaultCertificate_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (vaultCertificateStatus *VaultCertificate_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VaultCertificate_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (vaultCertificateStatus *VaultCertificate_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VaultCertificate_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VaultCertificate_StatusARM, got %T", armInput)
	}

	// Set property ‘CertificateStore’:
	if typedInput.CertificateStore != nil {
		certificateStore := *typedInput.CertificateStore
		vaultCertificateStatus.CertificateStore = &certificateStore
	}

	// Set property ‘CertificateUrl’:
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		vaultCertificateStatus.CertificateUrl = &certificateUrl
	}

	// No error
	return nil
}

// AssignPropertiesFromVaultCertificateStatus populates our VaultCertificate_Status from the provided source VaultCertificate_Status
func (vaultCertificateStatus *VaultCertificate_Status) AssignPropertiesFromVaultCertificateStatus(source *v1alpha1api20201201storage.VaultCertificate_Status) error {

	// CertificateStore
	if source.CertificateStore != nil {
		certificateStore := *source.CertificateStore
		vaultCertificateStatus.CertificateStore = &certificateStore
	} else {
		vaultCertificateStatus.CertificateStore = nil
	}

	// CertificateUrl
	if source.CertificateUrl != nil {
		certificateUrl := *source.CertificateUrl
		vaultCertificateStatus.CertificateUrl = &certificateUrl
	} else {
		vaultCertificateStatus.CertificateUrl = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVaultCertificateStatus populates the provided destination VaultCertificate_Status from our VaultCertificate_Status
func (vaultCertificateStatus *VaultCertificate_Status) AssignPropertiesToVaultCertificateStatus(destination *v1alpha1api20201201storage.VaultCertificate_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateStore
	if vaultCertificateStatus.CertificateStore != nil {
		certificateStore := *vaultCertificateStatus.CertificateStore
		destination.CertificateStore = &certificateStore
	} else {
		destination.CertificateStore = nil
	}

	// CertificateUrl
	if vaultCertificateStatus.CertificateUrl != nil {
		certificateUrl := *vaultCertificateStatus.CertificateUrl
		destination.CertificateUrl = &certificateUrl
	} else {
		destination.CertificateUrl = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VirtualHardDisk
type VirtualHardDisk struct {
	//Uri: Specifies the virtual hard disk's uri.
	Uri *string `json:"uri,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualHardDisk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualHardDisk *VirtualHardDisk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualHardDisk == nil {
		return nil, nil
	}
	var result VirtualHardDiskARM

	// Set property ‘Uri’:
	if virtualHardDisk.Uri != nil {
		uri := *virtualHardDisk.Uri
		result.Uri = &uri
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualHardDisk *VirtualHardDisk) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualHardDiskARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualHardDisk *VirtualHardDisk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualHardDiskARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualHardDiskARM, got %T", armInput)
	}

	// Set property ‘Uri’:
	if typedInput.Uri != nil {
		uri := *typedInput.Uri
		virtualHardDisk.Uri = &uri
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualHardDisk populates our VirtualHardDisk from the provided source VirtualHardDisk
func (virtualHardDisk *VirtualHardDisk) AssignPropertiesFromVirtualHardDisk(source *v1alpha1api20201201storage.VirtualHardDisk) error {

	// Uri
	if source.Uri != nil {
		uri := *source.Uri
		virtualHardDisk.Uri = &uri
	} else {
		virtualHardDisk.Uri = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualHardDisk populates the provided destination VirtualHardDisk from our VirtualHardDisk
func (virtualHardDisk *VirtualHardDisk) AssignPropertiesToVirtualHardDisk(destination *v1alpha1api20201201storage.VirtualHardDisk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Uri
	if virtualHardDisk.Uri != nil {
		uri := *virtualHardDisk.Uri
		destination.Uri = &uri
	} else {
		destination.Uri = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VirtualHardDisk_Status struct {
	//Uri: Specifies the virtual hard disk's uri.
	Uri *string `json:"uri,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualHardDisk_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualHardDiskStatus *VirtualHardDisk_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualHardDisk_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualHardDiskStatus *VirtualHardDisk_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualHardDisk_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualHardDisk_StatusARM, got %T", armInput)
	}

	// Set property ‘Uri’:
	if typedInput.Uri != nil {
		uri := *typedInput.Uri
		virtualHardDiskStatus.Uri = &uri
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualHardDiskStatus populates our VirtualHardDisk_Status from the provided source VirtualHardDisk_Status
func (virtualHardDiskStatus *VirtualHardDisk_Status) AssignPropertiesFromVirtualHardDiskStatus(source *v1alpha1api20201201storage.VirtualHardDisk_Status) error {

	// Uri
	if source.Uri != nil {
		uri := *source.Uri
		virtualHardDiskStatus.Uri = &uri
	} else {
		virtualHardDiskStatus.Uri = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualHardDiskStatus populates the provided destination VirtualHardDisk_Status from our VirtualHardDisk_Status
func (virtualHardDiskStatus *VirtualHardDisk_Status) AssignPropertiesToVirtualHardDiskStatus(destination *v1alpha1api20201201storage.VirtualHardDisk_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Uri
	if virtualHardDiskStatus.Uri != nil {
		uri := *virtualHardDiskStatus.Uri
		destination.Uri = &uri
	} else {
		destination.Uri = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"None","ReadOnly","ReadWrite"}
type VirtualMachineScaleSetDataDiskCaching string

const (
	VirtualMachineScaleSetDataDiskCachingNone      = VirtualMachineScaleSetDataDiskCaching("None")
	VirtualMachineScaleSetDataDiskCachingReadOnly  = VirtualMachineScaleSetDataDiskCaching("ReadOnly")
	VirtualMachineScaleSetDataDiskCachingReadWrite = VirtualMachineScaleSetDataDiskCaching("ReadWrite")
)

// +kubebuilder:validation:Enum={"Attach","Empty","FromImage"}
type VirtualMachineScaleSetDataDiskCreateOption string

const (
	VirtualMachineScaleSetDataDiskCreateOptionAttach    = VirtualMachineScaleSetDataDiskCreateOption("Attach")
	VirtualMachineScaleSetDataDiskCreateOptionEmpty     = VirtualMachineScaleSetDataDiskCreateOption("Empty")
	VirtualMachineScaleSetDataDiskCreateOptionFromImage = VirtualMachineScaleSetDataDiskCreateOption("FromImage")
)

//Generated from:
type VirtualMachineScaleSetIPConfiguration_Status struct {
	//ApplicationGatewayBackendAddressPools: Specifies an array of references to
	//backend address pools of application gateways. A scale set can reference backend
	//address pools of multiple application gateways. Multiple scale sets cannot use
	//the same application gateway.
	ApplicationGatewayBackendAddressPools []SubResource_Status `json:"applicationGatewayBackendAddressPools,omitempty"`

	//ApplicationSecurityGroups: Specifies an array of references to application
	//security group.
	ApplicationSecurityGroups []SubResource_Status `json:"applicationSecurityGroups,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//LoadBalancerBackendAddressPools: Specifies an array of references to backend
	//address pools of load balancers. A scale set can reference backend address pools
	//of one public and one internal load balancer. Multiple scale sets cannot use the
	//same basic sku load balancer.
	LoadBalancerBackendAddressPools []SubResource_Status `json:"loadBalancerBackendAddressPools,omitempty"`

	//LoadBalancerInboundNatPools: Specifies an array of references to inbound Nat
	//pools of the load balancers. A scale set can reference inbound nat pools of one
	//public and one internal load balancer. Multiple scale sets cannot use the same
	//basic sku load balancer.
	LoadBalancerInboundNatPools []SubResource_Status `json:"loadBalancerInboundNatPools,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The IP configuration name.
	Name string `json:"name"`

	//Primary: Specifies the primary network interface in case the virtual machine has
	//more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`

	//PrivateIPAddressVersion: Available from Api-Version 2017-03-30 onwards, it
	//represents whether the specific ipconfiguration is IPv4 or IPv6. Default is
	//taken as IPv4.  Possible values are: 'IPv4' and 'IPv6'.
	PrivateIPAddressVersion *VirtualMachineScaleSetIPConfigurationPropertiesStatusPrivateIPAddressVersion `json:"privateIPAddressVersion,omitempty"`

	//PublicIPAddressConfiguration: The publicIPAddressConfiguration.
	PublicIPAddressConfiguration *VirtualMachineScaleSetPublicIPAddressConfiguration_Status `json:"publicIPAddressConfiguration,omitempty"`

	//Subnet: Specifies the identifier of the subnet.
	Subnet *ApiEntityReference_Status `json:"subnet,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIPConfiguration_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetIPConfigurationStatus *VirtualMachineScaleSetIPConfiguration_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIPConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetIPConfigurationStatus *VirtualMachineScaleSetIPConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIPConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIPConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘ApplicationGatewayBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			virtualMachineScaleSetIPConfigurationStatus.ApplicationGatewayBackendAddressPools = append(virtualMachineScaleSetIPConfigurationStatus.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property ‘ApplicationSecurityGroups’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			virtualMachineScaleSetIPConfigurationStatus.ApplicationSecurityGroups = append(virtualMachineScaleSetIPConfigurationStatus.ApplicationSecurityGroups, item1)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		virtualMachineScaleSetIPConfigurationStatus.Id = &id
	}

	// Set property ‘LoadBalancerBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			virtualMachineScaleSetIPConfigurationStatus.LoadBalancerBackendAddressPools = append(virtualMachineScaleSetIPConfigurationStatus.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property ‘LoadBalancerInboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerInboundNatPools {
			var item1 SubResource_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			virtualMachineScaleSetIPConfigurationStatus.LoadBalancerInboundNatPools = append(virtualMachineScaleSetIPConfigurationStatus.LoadBalancerInboundNatPools, item1)
		}
	}

	// Set property ‘Name’:
	virtualMachineScaleSetIPConfigurationStatus.Name = typedInput.Name

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			virtualMachineScaleSetIPConfigurationStatus.Primary = &primary
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			virtualMachineScaleSetIPConfigurationStatus.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PublicIPAddressConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressConfiguration != nil {
			var publicIPAddressConfiguration1 VirtualMachineScaleSetPublicIPAddressConfiguration_Status
			err := publicIPAddressConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddressConfiguration)
			if err != nil {
				return err
			}
			publicIPAddressConfiguration := publicIPAddressConfiguration1
			virtualMachineScaleSetIPConfigurationStatus.PublicIPAddressConfiguration = &publicIPAddressConfiguration
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 ApiEntityReference_Status
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			virtualMachineScaleSetIPConfigurationStatus.Subnet = &subnet
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIPConfigurationStatus populates our VirtualMachineScaleSetIPConfiguration_Status from the provided source VirtualMachineScaleSetIPConfiguration_Status
func (virtualMachineScaleSetIPConfigurationStatus *VirtualMachineScaleSetIPConfiguration_Status) AssignPropertiesFromVirtualMachineScaleSetIPConfigurationStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Status) error {

	// ApplicationGatewayBackendAddressPools
	applicationGatewayBackendAddressPoolList := make([]SubResource_Status, len(source.ApplicationGatewayBackendAddressPools))
	for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
		var applicationGatewayBackendAddressPool SubResource_Status
		err := applicationGatewayBackendAddressPool.AssignPropertiesFromSubResourceStatus(&applicationGatewayBackendAddressPoolItem)
		if err != nil {
			return errors.Wrap(err, "populating ApplicationGatewayBackendAddressPools from ApplicationGatewayBackendAddressPools, calling AssignPropertiesFromSubResourceStatus()")
		}
		applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
	}
	virtualMachineScaleSetIPConfigurationStatus.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList

	// ApplicationSecurityGroups
	applicationSecurityGroupList := make([]SubResource_Status, len(source.ApplicationSecurityGroups))
	for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
		// Shadow the loop variable to avoid aliasing
		applicationSecurityGroupItem := applicationSecurityGroupItem
		var applicationSecurityGroup SubResource_Status
		err := applicationSecurityGroup.AssignPropertiesFromSubResourceStatus(&applicationSecurityGroupItem)
		if err != nil {
			return errors.Wrap(err, "populating ApplicationSecurityGroups from ApplicationSecurityGroups, calling AssignPropertiesFromSubResourceStatus()")
		}
		applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
	}
	virtualMachineScaleSetIPConfigurationStatus.ApplicationSecurityGroups = applicationSecurityGroupList

	// Id
	if source.Id != nil {
		id := *source.Id
		virtualMachineScaleSetIPConfigurationStatus.Id = &id
	} else {
		virtualMachineScaleSetIPConfigurationStatus.Id = nil
	}

	// LoadBalancerBackendAddressPools
	loadBalancerBackendAddressPoolList := make([]SubResource_Status, len(source.LoadBalancerBackendAddressPools))
	for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
		var loadBalancerBackendAddressPool SubResource_Status
		err := loadBalancerBackendAddressPool.AssignPropertiesFromSubResourceStatus(&loadBalancerBackendAddressPoolItem)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerBackendAddressPools from LoadBalancerBackendAddressPools, calling AssignPropertiesFromSubResourceStatus()")
		}
		loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
	}
	virtualMachineScaleSetIPConfigurationStatus.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList

	// LoadBalancerInboundNatPools
	loadBalancerInboundNatPoolList := make([]SubResource_Status, len(source.LoadBalancerInboundNatPools))
	for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range source.LoadBalancerInboundNatPools {
		// Shadow the loop variable to avoid aliasing
		loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
		var loadBalancerInboundNatPool SubResource_Status
		err := loadBalancerInboundNatPool.AssignPropertiesFromSubResourceStatus(&loadBalancerInboundNatPoolItem)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerInboundNatPools from LoadBalancerInboundNatPools, calling AssignPropertiesFromSubResourceStatus()")
		}
		loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
	}
	virtualMachineScaleSetIPConfigurationStatus.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList

	// Name
	if source.Name != nil {
		virtualMachineScaleSetIPConfigurationStatus.Name = *source.Name
	} else {
		virtualMachineScaleSetIPConfigurationStatus.Name = ""
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		virtualMachineScaleSetIPConfigurationStatus.Primary = &primary
	} else {
		virtualMachineScaleSetIPConfigurationStatus.Primary = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := VirtualMachineScaleSetIPConfigurationPropertiesStatusPrivateIPAddressVersion(*source.PrivateIPAddressVersion)
		virtualMachineScaleSetIPConfigurationStatus.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		virtualMachineScaleSetIPConfigurationStatus.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachineScaleSetPublicIPAddressConfiguration_Status
		err := publicIPAddressConfiguration.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationStatus(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPAddressConfiguration from PublicIPAddressConfiguration, calling AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationStatus()")
		}
		virtualMachineScaleSetIPConfigurationStatus.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		virtualMachineScaleSetIPConfigurationStatus.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ApiEntityReference_Status
		err := subnet.AssignPropertiesFromApiEntityReferenceStatus(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesFromApiEntityReferenceStatus()")
		}
		virtualMachineScaleSetIPConfigurationStatus.Subnet = &subnet
	} else {
		virtualMachineScaleSetIPConfigurationStatus.Subnet = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIPConfigurationStatus populates the provided destination VirtualMachineScaleSetIPConfiguration_Status from our VirtualMachineScaleSetIPConfiguration_Status
func (virtualMachineScaleSetIPConfigurationStatus *VirtualMachineScaleSetIPConfiguration_Status) AssignPropertiesToVirtualMachineScaleSetIPConfigurationStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetIPConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	applicationGatewayBackendAddressPoolList := make([]v1alpha1api20201201storage.SubResource_Status, len(virtualMachineScaleSetIPConfigurationStatus.ApplicationGatewayBackendAddressPools))
	for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range virtualMachineScaleSetIPConfigurationStatus.ApplicationGatewayBackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
		var applicationGatewayBackendAddressPool v1alpha1api20201201storage.SubResource_Status
		err := applicationGatewayBackendAddressPoolItem.AssignPropertiesToSubResourceStatus(&applicationGatewayBackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating ApplicationGatewayBackendAddressPools from ApplicationGatewayBackendAddressPools, calling AssignPropertiesToSubResourceStatus()")
		}
		applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
	}
	destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList

	// ApplicationSecurityGroups
	applicationSecurityGroupList := make([]v1alpha1api20201201storage.SubResource_Status, len(virtualMachineScaleSetIPConfigurationStatus.ApplicationSecurityGroups))
	for applicationSecurityGroupIndex, applicationSecurityGroupItem := range virtualMachineScaleSetIPConfigurationStatus.ApplicationSecurityGroups {
		// Shadow the loop variable to avoid aliasing
		applicationSecurityGroupItem := applicationSecurityGroupItem
		var applicationSecurityGroup v1alpha1api20201201storage.SubResource_Status
		err := applicationSecurityGroupItem.AssignPropertiesToSubResourceStatus(&applicationSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "populating ApplicationSecurityGroups from ApplicationSecurityGroups, calling AssignPropertiesToSubResourceStatus()")
		}
		applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
	}
	destination.ApplicationSecurityGroups = applicationSecurityGroupList

	// Id
	if virtualMachineScaleSetIPConfigurationStatus.Id != nil {
		id := *virtualMachineScaleSetIPConfigurationStatus.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// LoadBalancerBackendAddressPools
	loadBalancerBackendAddressPoolList := make([]v1alpha1api20201201storage.SubResource_Status, len(virtualMachineScaleSetIPConfigurationStatus.LoadBalancerBackendAddressPools))
	for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range virtualMachineScaleSetIPConfigurationStatus.LoadBalancerBackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
		var loadBalancerBackendAddressPool v1alpha1api20201201storage.SubResource_Status
		err := loadBalancerBackendAddressPoolItem.AssignPropertiesToSubResourceStatus(&loadBalancerBackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerBackendAddressPools from LoadBalancerBackendAddressPools, calling AssignPropertiesToSubResourceStatus()")
		}
		loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
	}
	destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList

	// LoadBalancerInboundNatPools
	loadBalancerInboundNatPoolList := make([]v1alpha1api20201201storage.SubResource_Status, len(virtualMachineScaleSetIPConfigurationStatus.LoadBalancerInboundNatPools))
	for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range virtualMachineScaleSetIPConfigurationStatus.LoadBalancerInboundNatPools {
		// Shadow the loop variable to avoid aliasing
		loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
		var loadBalancerInboundNatPool v1alpha1api20201201storage.SubResource_Status
		err := loadBalancerInboundNatPoolItem.AssignPropertiesToSubResourceStatus(&loadBalancerInboundNatPool)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerInboundNatPools from LoadBalancerInboundNatPools, calling AssignPropertiesToSubResourceStatus()")
		}
		loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
	}
	destination.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList

	// Name
	name := virtualMachineScaleSetIPConfigurationStatus.Name
	destination.Name = &name

	// Primary
	if virtualMachineScaleSetIPConfigurationStatus.Primary != nil {
		primary := *virtualMachineScaleSetIPConfigurationStatus.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	if virtualMachineScaleSetIPConfigurationStatus.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*virtualMachineScaleSetIPConfigurationStatus.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if virtualMachineScaleSetIPConfigurationStatus.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfiguration_Status
		err := (*virtualMachineScaleSetIPConfigurationStatus.PublicIPAddressConfiguration).AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationStatus(&publicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPAddressConfiguration from PublicIPAddressConfiguration, calling AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationStatus()")
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if virtualMachineScaleSetIPConfigurationStatus.Subnet != nil {
		var subnet v1alpha1api20201201storage.ApiEntityReference_Status
		err := (*virtualMachineScaleSetIPConfigurationStatus.Subnet).AssignPropertiesToApiEntityReferenceStatus(&subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesToApiEntityReferenceStatus()")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VirtualMachineScaleSetManagedDiskParameters
type VirtualMachineScaleSetManagedDiskParameters struct {
	//DiskEncryptionSet: Describes the parameter of customer managed disk encryption
	//set resource id that can be specified for disk.
	//NOTE: The disk encryption set resource id can only be specified for managed
	//disk. Please refer https://aka.ms/mdssewithcmkoverview for more details.
	DiskEncryptionSet *DiskEncryptionSetParameters `json:"diskEncryptionSet,omitempty"`

	//StorageAccountType: Specifies the storage account type for the managed disk.
	//NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS
	//Disk.
	StorageAccountType *VirtualMachineScaleSetManagedDiskParametersStorageAccountType `json:"storageAccountType,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetManagedDiskParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetManagedDiskParameters *VirtualMachineScaleSetManagedDiskParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetManagedDiskParameters == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetManagedDiskParametersARM

	// Set property ‘DiskEncryptionSet’:
	if virtualMachineScaleSetManagedDiskParameters.DiskEncryptionSet != nil {
		diskEncryptionSetARM, err := (*virtualMachineScaleSetManagedDiskParameters.DiskEncryptionSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		diskEncryptionSet := diskEncryptionSetARM.(DiskEncryptionSetParametersARM)
		result.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property ‘StorageAccountType’:
	if virtualMachineScaleSetManagedDiskParameters.StorageAccountType != nil {
		storageAccountType := *virtualMachineScaleSetManagedDiskParameters.StorageAccountType
		result.StorageAccountType = &storageAccountType
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetManagedDiskParameters *VirtualMachineScaleSetManagedDiskParameters) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetManagedDiskParametersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetManagedDiskParameters *VirtualMachineScaleSetManagedDiskParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetManagedDiskParametersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetManagedDiskParametersARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionSet’:
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 DiskEncryptionSetParameters
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		virtualMachineScaleSetManagedDiskParameters.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property ‘StorageAccountType’:
	if typedInput.StorageAccountType != nil {
		storageAccountType := *typedInput.StorageAccountType
		virtualMachineScaleSetManagedDiskParameters.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters populates our VirtualMachineScaleSetManagedDiskParameters from the provided source VirtualMachineScaleSetManagedDiskParameters
func (virtualMachineScaleSetManagedDiskParameters *VirtualMachineScaleSetManagedDiskParameters) AssignPropertiesFromVirtualMachineScaleSetManagedDiskParameters(source *v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet DiskEncryptionSetParameters
		err := diskEncryptionSet.AssignPropertiesFromDiskEncryptionSetParameters(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionSet from DiskEncryptionSet, calling AssignPropertiesFromDiskEncryptionSetParameters()")
		}
		virtualMachineScaleSetManagedDiskParameters.DiskEncryptionSet = &diskEncryptionSet
	} else {
		virtualMachineScaleSetManagedDiskParameters.DiskEncryptionSet = nil
	}

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := VirtualMachineScaleSetManagedDiskParametersStorageAccountType(*source.StorageAccountType)
		virtualMachineScaleSetManagedDiskParameters.StorageAccountType = &storageAccountType
	} else {
		virtualMachineScaleSetManagedDiskParameters.StorageAccountType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters populates the provided destination VirtualMachineScaleSetManagedDiskParameters from our VirtualMachineScaleSetManagedDiskParameters
func (virtualMachineScaleSetManagedDiskParameters *VirtualMachineScaleSetManagedDiskParameters) AssignPropertiesToVirtualMachineScaleSetManagedDiskParameters(destination *v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if virtualMachineScaleSetManagedDiskParameters.DiskEncryptionSet != nil {
		var diskEncryptionSet v1alpha1api20201201storage.DiskEncryptionSetParameters
		err := (*virtualMachineScaleSetManagedDiskParameters.DiskEncryptionSet).AssignPropertiesToDiskEncryptionSetParameters(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionSet from DiskEncryptionSet, calling AssignPropertiesToDiskEncryptionSetParameters()")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// StorageAccountType
	if virtualMachineScaleSetManagedDiskParameters.StorageAccountType != nil {
		storageAccountType := string(*virtualMachineScaleSetManagedDiskParameters.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VirtualMachineScaleSetManagedDiskParameters_Status struct {
	//DiskEncryptionSet: Specifies the customer managed disk encryption set resource
	//id for the managed disk.
	DiskEncryptionSet *SubResource_Status `json:"diskEncryptionSet,omitempty"`

	//StorageAccountType: Specifies the storage account type for the managed disk.
	//NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS
	//Disk.
	StorageAccountType *StorageAccountType_Status `json:"storageAccountType,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetManagedDiskParameters_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetManagedDiskParametersStatus *VirtualMachineScaleSetManagedDiskParameters_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetManagedDiskParameters_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetManagedDiskParametersStatus *VirtualMachineScaleSetManagedDiskParameters_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetManagedDiskParameters_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetManagedDiskParameters_StatusARM, got %T", armInput)
	}

	// Set property ‘DiskEncryptionSet’:
	if typedInput.DiskEncryptionSet != nil {
		var diskEncryptionSet1 SubResource_Status
		err := diskEncryptionSet1.PopulateFromARM(owner, *typedInput.DiskEncryptionSet)
		if err != nil {
			return err
		}
		diskEncryptionSet := diskEncryptionSet1
		virtualMachineScaleSetManagedDiskParametersStatus.DiskEncryptionSet = &diskEncryptionSet
	}

	// Set property ‘StorageAccountType’:
	if typedInput.StorageAccountType != nil {
		storageAccountType := *typedInput.StorageAccountType
		virtualMachineScaleSetManagedDiskParametersStatus.StorageAccountType = &storageAccountType
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersStatus populates our VirtualMachineScaleSetManagedDiskParameters_Status from the provided source VirtualMachineScaleSetManagedDiskParameters_Status
func (virtualMachineScaleSetManagedDiskParametersStatus *VirtualMachineScaleSetManagedDiskParameters_Status) AssignPropertiesFromVirtualMachineScaleSetManagedDiskParametersStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Status) error {

	// DiskEncryptionSet
	if source.DiskEncryptionSet != nil {
		var diskEncryptionSet SubResource_Status
		err := diskEncryptionSet.AssignPropertiesFromSubResourceStatus(source.DiskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionSet from DiskEncryptionSet, calling AssignPropertiesFromSubResourceStatus()")
		}
		virtualMachineScaleSetManagedDiskParametersStatus.DiskEncryptionSet = &diskEncryptionSet
	} else {
		virtualMachineScaleSetManagedDiskParametersStatus.DiskEncryptionSet = nil
	}

	// StorageAccountType
	if source.StorageAccountType != nil {
		storageAccountType := StorageAccountType_Status(*source.StorageAccountType)
		virtualMachineScaleSetManagedDiskParametersStatus.StorageAccountType = &storageAccountType
	} else {
		virtualMachineScaleSetManagedDiskParametersStatus.StorageAccountType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersStatus populates the provided destination VirtualMachineScaleSetManagedDiskParameters_Status from our VirtualMachineScaleSetManagedDiskParameters_Status
func (virtualMachineScaleSetManagedDiskParametersStatus *VirtualMachineScaleSetManagedDiskParameters_Status) AssignPropertiesToVirtualMachineScaleSetManagedDiskParametersStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetManagedDiskParameters_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskEncryptionSet
	if virtualMachineScaleSetManagedDiskParametersStatus.DiskEncryptionSet != nil {
		var diskEncryptionSet v1alpha1api20201201storage.SubResource_Status
		err := (*virtualMachineScaleSetManagedDiskParametersStatus.DiskEncryptionSet).AssignPropertiesToSubResourceStatus(&diskEncryptionSet)
		if err != nil {
			return errors.Wrap(err, "populating DiskEncryptionSet from DiskEncryptionSet, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.DiskEncryptionSet = &diskEncryptionSet
	} else {
		destination.DiskEncryptionSet = nil
	}

	// StorageAccountType
	if virtualMachineScaleSetManagedDiskParametersStatus.StorageAccountType != nil {
		storageAccountType := string(*virtualMachineScaleSetManagedDiskParametersStatus.StorageAccountType)
		destination.StorageAccountType = &storageAccountType
	} else {
		destination.StorageAccountType = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VirtualMachineScaleSetNetworkConfigurationDnsSettings
type VirtualMachineScaleSetNetworkConfigurationDnsSettings struct {
	//DnsServers: List of DNS servers IP addresses
	DnsServers []string `json:"dnsServers,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetNetworkConfigurationDnsSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetNetworkConfigurationDnsSettings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetNetworkConfigurationDnsSettings == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetNetworkConfigurationDnsSettingsARM

	// Set property ‘DnsServers’:
	for _, item := range virtualMachineScaleSetNetworkConfigurationDnsSettings.DnsServers {
		result.DnsServers = append(result.DnsServers, item)
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetNetworkConfigurationDnsSettings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkConfigurationDnsSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetNetworkConfigurationDnsSettings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkConfigurationDnsSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkConfigurationDnsSettingsARM, got %T", armInput)
	}

	// Set property ‘DnsServers’:
	for _, item := range typedInput.DnsServers {
		virtualMachineScaleSetNetworkConfigurationDnsSettings.DnsServers = append(virtualMachineScaleSetNetworkConfigurationDnsSettings.DnsServers, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings populates our VirtualMachineScaleSetNetworkConfigurationDnsSettings from the provided source VirtualMachineScaleSetNetworkConfigurationDnsSettings
func (virtualMachineScaleSetNetworkConfigurationDnsSettings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettings(source *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings) error {

	// DnsServers
	dnsServerList := make([]string, len(source.DnsServers))
	for dnsServerIndex, dnsServerItem := range source.DnsServers {
		// Shadow the loop variable to avoid aliasing
		dnsServerItem := dnsServerItem
		dnsServerList[dnsServerIndex] = dnsServerItem
	}
	virtualMachineScaleSetNetworkConfigurationDnsSettings.DnsServers = dnsServerList

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings populates the provided destination VirtualMachineScaleSetNetworkConfigurationDnsSettings from our VirtualMachineScaleSetNetworkConfigurationDnsSettings
func (virtualMachineScaleSetNetworkConfigurationDnsSettings *VirtualMachineScaleSetNetworkConfigurationDnsSettings) AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettings(destination *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServers
	dnsServerList := make([]string, len(virtualMachineScaleSetNetworkConfigurationDnsSettings.DnsServers))
	for dnsServerIndex, dnsServerItem := range virtualMachineScaleSetNetworkConfigurationDnsSettings.DnsServers {
		// Shadow the loop variable to avoid aliasing
		dnsServerItem := dnsServerItem
		dnsServerList[dnsServerIndex] = dnsServerItem
	}
	destination.DnsServers = dnsServerList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status struct {
	//DnsServers: List of DNS servers IP addresses
	DnsServers []string `json:"dnsServers,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetNetworkConfigurationDnsSettingsStatus *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetNetworkConfigurationDnsSettingsStatus *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetNetworkConfigurationDnsSettings_StatusARM, got %T", armInput)
	}

	// Set property ‘DnsServers’:
	for _, item := range typedInput.DnsServers {
		virtualMachineScaleSetNetworkConfigurationDnsSettingsStatus.DnsServers = append(virtualMachineScaleSetNetworkConfigurationDnsSettingsStatus.DnsServers, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus populates our VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status from the provided source VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
func (virtualMachineScaleSetNetworkConfigurationDnsSettingsStatus *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) AssignPropertiesFromVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) error {

	// DnsServers
	dnsServerList := make([]string, len(source.DnsServers))
	for dnsServerIndex, dnsServerItem := range source.DnsServers {
		// Shadow the loop variable to avoid aliasing
		dnsServerItem := dnsServerItem
		dnsServerList[dnsServerIndex] = dnsServerItem
	}
	virtualMachineScaleSetNetworkConfigurationDnsSettingsStatus.DnsServers = dnsServerList

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus populates the provided destination VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status from our VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status
func (virtualMachineScaleSetNetworkConfigurationDnsSettingsStatus *VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) AssignPropertiesToVirtualMachineScaleSetNetworkConfigurationDnsSettingsStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetNetworkConfigurationDnsSettings_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsServers
	dnsServerList := make([]string, len(virtualMachineScaleSetNetworkConfigurationDnsSettingsStatus.DnsServers))
	for dnsServerIndex, dnsServerItem := range virtualMachineScaleSetNetworkConfigurationDnsSettingsStatus.DnsServers {
		// Shadow the loop variable to avoid aliasing
		dnsServerItem := dnsServerItem
		dnsServerList[dnsServerIndex] = dnsServerItem
	}
	destination.DnsServers = dnsServerList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"None","ReadOnly","ReadWrite"}
type VirtualMachineScaleSetOSDiskCaching string

const (
	VirtualMachineScaleSetOSDiskCachingNone      = VirtualMachineScaleSetOSDiskCaching("None")
	VirtualMachineScaleSetOSDiskCachingReadOnly  = VirtualMachineScaleSetOSDiskCaching("ReadOnly")
	VirtualMachineScaleSetOSDiskCachingReadWrite = VirtualMachineScaleSetOSDiskCaching("ReadWrite")
)

// +kubebuilder:validation:Enum={"Attach","Empty","FromImage"}
type VirtualMachineScaleSetOSDiskCreateOption string

const (
	VirtualMachineScaleSetOSDiskCreateOptionAttach    = VirtualMachineScaleSetOSDiskCreateOption("Attach")
	VirtualMachineScaleSetOSDiskCreateOptionEmpty     = VirtualMachineScaleSetOSDiskCreateOption("Empty")
	VirtualMachineScaleSetOSDiskCreateOptionFromImage = VirtualMachineScaleSetOSDiskCreateOption("FromImage")
)

// +kubebuilder:validation:Enum={"Linux","Windows"}
type VirtualMachineScaleSetOSDiskOsType string

const (
	VirtualMachineScaleSetOSDiskOsTypeLinux   = VirtualMachineScaleSetOSDiskOsType("Linux")
	VirtualMachineScaleSetOSDiskOsTypeWindows = VirtualMachineScaleSetOSDiskOsType("Windows")
)

type VirtualMachineScaleSetOSDiskStatusOsType string

const (
	VirtualMachineScaleSetOSDiskStatusOsTypeLinux   = VirtualMachineScaleSetOSDiskStatusOsType("Linux")
	VirtualMachineScaleSetOSDiskStatusOsTypeWindows = VirtualMachineScaleSetOSDiskStatusOsType("Windows")
)

type VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations struct {
	//ApplicationGatewayBackendAddressPools: Specifies an array of references to
	//backend address pools of application gateways. A scale set can reference backend
	//address pools of multiple application gateways. Multiple scale sets cannot use
	//the same application gateway.
	ApplicationGatewayBackendAddressPools []SubResource `json:"applicationGatewayBackendAddressPools,omitempty"`

	//ApplicationSecurityGroups: Specifies an array of references to application
	//security group.
	ApplicationSecurityGroups []SubResource `json:"applicationSecurityGroups,omitempty"`

	//Id: Resource Id
	Id *string `json:"id,omitempty"`

	//LoadBalancerBackendAddressPools: Specifies an array of references to backend
	//address pools of load balancers. A scale set can reference backend address pools
	//of one public and one internal load balancer. Multiple scale sets cannot use the
	//same basic sku load balancer.
	LoadBalancerBackendAddressPools []SubResource `json:"loadBalancerBackendAddressPools,omitempty"`

	//LoadBalancerInboundNatPools: Specifies an array of references to inbound Nat
	//pools of the load balancers. A scale set can reference inbound nat pools of one
	//public and one internal load balancer. Multiple scale sets cannot use the same
	//basic sku load balancer.
	LoadBalancerInboundNatPools []SubResource `json:"loadBalancerInboundNatPools,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The IP configuration name.
	Name string `json:"name"`

	//Primary: Specifies the primary network interface in case the virtual machine has
	//more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`

	//PrivateIPAddressVersion: Available from Api-Version 2017-03-30 onwards, it
	//represents whether the specific ipconfiguration is IPv4 or IPv6. Default is
	//taken as IPv4.  Possible values are: 'IPv4' and 'IPv6'.
	PrivateIPAddressVersion *VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersion `json:"privateIPAddressVersion,omitempty"`

	//PublicIPAddressConfiguration: Describes a virtual machines scale set IP
	//Configuration's PublicIPAddress configuration
	PublicIPAddressConfiguration *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration `json:"publicIPAddressConfiguration,omitempty"`

	//Subnet: The API entity reference.
	Subnet *ApiEntityReference `json:"subnet,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM

	// Set property ‘Id’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Id != nil {
		id := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Id
		result.Id = &id
	}

	// Set property ‘Name’:
	result.Name = virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Name

	// Set property ‘Properties’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.ApplicationGatewayBackendAddressPools != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.ApplicationSecurityGroups != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.LoadBalancerBackendAddressPools != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.LoadBalancerInboundNatPools != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Primary != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PrivateIPAddressVersion != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PublicIPAddressConfiguration != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Subnet != nil {
		result.Properties = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_PropertiesARM{}
	}
	for _, item := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.ApplicationGatewayBackendAddressPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationGatewayBackendAddressPools = append(result.Properties.ApplicationGatewayBackendAddressPools, itemARM.(SubResourceARM))
	}
	for _, item := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.ApplicationSecurityGroups {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.ApplicationSecurityGroups = append(result.Properties.ApplicationSecurityGroups, itemARM.(SubResourceARM))
	}
	for _, item := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.LoadBalancerBackendAddressPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerBackendAddressPools = append(result.Properties.LoadBalancerBackendAddressPools, itemARM.(SubResourceARM))
	}
	for _, item := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.LoadBalancerInboundNatPools {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.LoadBalancerInboundNatPools = append(result.Properties.LoadBalancerInboundNatPools, itemARM.(SubResourceARM))
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Primary != nil {
		primary := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Primary
		result.Properties.Primary = &primary
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PrivateIPAddressVersion
		result.Properties.PrivateIPAddressVersion = &privateIPAddressVersion
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PublicIPAddressConfiguration != nil {
		publicIPAddressConfigurationARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PublicIPAddressConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPAddressConfiguration := publicIPAddressConfigurationARM.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM)
		result.Properties.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Subnet != nil {
		subnetARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Subnet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		subnet := subnetARM.(ApiEntityReferenceARM)
		result.Properties.Subnet = &subnet
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurationsARM, got %T", armInput)
	}

	// Set property ‘ApplicationGatewayBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationGatewayBackendAddressPools {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.ApplicationGatewayBackendAddressPools = append(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.ApplicationGatewayBackendAddressPools, item1)
		}
	}

	// Set property ‘ApplicationSecurityGroups’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ApplicationSecurityGroups {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.ApplicationSecurityGroups = append(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.ApplicationSecurityGroups, item1)
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Id = &id
	}

	// Set property ‘LoadBalancerBackendAddressPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerBackendAddressPools {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.LoadBalancerBackendAddressPools = append(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.LoadBalancerBackendAddressPools, item1)
		}
	}

	// Set property ‘LoadBalancerInboundNatPools’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.LoadBalancerInboundNatPools {
			var item1 SubResource
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.LoadBalancerInboundNatPools = append(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.LoadBalancerInboundNatPools, item1)
		}
	}

	// Set property ‘Name’:
	virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Name = typedInput.Name

	// Set property ‘Primary’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Primary != nil {
			primary := *typedInput.Properties.Primary
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Primary = &primary
		}
	}

	// Set property ‘PrivateIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateIPAddressVersion != nil {
			privateIPAddressVersion := *typedInput.Properties.PrivateIPAddressVersion
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PrivateIPAddressVersion = &privateIPAddressVersion
		}
	}

	// Set property ‘PublicIPAddressConfiguration’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressConfiguration != nil {
			var publicIPAddressConfiguration1 VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration
			err := publicIPAddressConfiguration1.PopulateFromARM(owner, *typedInput.Properties.PublicIPAddressConfiguration)
			if err != nil {
				return err
			}
			publicIPAddressConfiguration := publicIPAddressConfiguration1
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PublicIPAddressConfiguration = &publicIPAddressConfiguration
		}
	}

	// Set property ‘Subnet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Subnet != nil {
			var subnet1 ApiEntityReference
			err := subnet1.PopulateFromARM(owner, *typedInput.Properties.Subnet)
			if err != nil {
				return err
			}
			subnet := subnet1
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Subnet = &subnet
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations populates our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations from the provided source VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations(source *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) error {

	// ApplicationGatewayBackendAddressPools
	applicationGatewayBackendAddressPoolList := make([]SubResource, len(source.ApplicationGatewayBackendAddressPools))
	for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range source.ApplicationGatewayBackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
		var applicationGatewayBackendAddressPool SubResource
		err := applicationGatewayBackendAddressPool.AssignPropertiesFromSubResource(&applicationGatewayBackendAddressPoolItem)
		if err != nil {
			return errors.Wrap(err, "populating ApplicationGatewayBackendAddressPools from ApplicationGatewayBackendAddressPools, calling AssignPropertiesFromSubResource()")
		}
		applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
	}
	virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList

	// ApplicationSecurityGroups
	applicationSecurityGroupList := make([]SubResource, len(source.ApplicationSecurityGroups))
	for applicationSecurityGroupIndex, applicationSecurityGroupItem := range source.ApplicationSecurityGroups {
		// Shadow the loop variable to avoid aliasing
		applicationSecurityGroupItem := applicationSecurityGroupItem
		var applicationSecurityGroup SubResource
		err := applicationSecurityGroup.AssignPropertiesFromSubResource(&applicationSecurityGroupItem)
		if err != nil {
			return errors.Wrap(err, "populating ApplicationSecurityGroups from ApplicationSecurityGroups, calling AssignPropertiesFromSubResource()")
		}
		applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
	}
	virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.ApplicationSecurityGroups = applicationSecurityGroupList

	// Id
	if source.Id != nil {
		id := *source.Id
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Id = &id
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Id = nil
	}

	// LoadBalancerBackendAddressPools
	loadBalancerBackendAddressPoolList := make([]SubResource, len(source.LoadBalancerBackendAddressPools))
	for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range source.LoadBalancerBackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
		var loadBalancerBackendAddressPool SubResource
		err := loadBalancerBackendAddressPool.AssignPropertiesFromSubResource(&loadBalancerBackendAddressPoolItem)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerBackendAddressPools from LoadBalancerBackendAddressPools, calling AssignPropertiesFromSubResource()")
		}
		loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
	}
	virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList

	// LoadBalancerInboundNatPools
	loadBalancerInboundNatPoolList := make([]SubResource, len(source.LoadBalancerInboundNatPools))
	for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range source.LoadBalancerInboundNatPools {
		// Shadow the loop variable to avoid aliasing
		loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
		var loadBalancerInboundNatPool SubResource
		err := loadBalancerInboundNatPool.AssignPropertiesFromSubResource(&loadBalancerInboundNatPoolItem)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerInboundNatPools from LoadBalancerInboundNatPools, calling AssignPropertiesFromSubResource()")
		}
		loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
	}
	virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList

	// Name
	if source.Name != nil {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Name = *source.Name
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Name = ""
	}

	// Primary
	if source.Primary != nil {
		primary := *source.Primary
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Primary = &primary
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Primary = nil
	}

	// PrivateIPAddressVersion
	if source.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersion(*source.PrivateIPAddressVersion)
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if source.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration
		err := publicIPAddressConfiguration.AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration(source.PublicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPAddressConfiguration from PublicIPAddressConfiguration, calling AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if source.Subnet != nil {
		var subnet ApiEntityReference
		err := subnet.AssignPropertiesFromApiEntityReference(source.Subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesFromApiEntityReference()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Subnet = &subnet
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Subnet = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations populates the provided destination VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations from our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations(destination *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationGatewayBackendAddressPools
	applicationGatewayBackendAddressPoolList := make([]v1alpha1api20201201storage.SubResource, len(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.ApplicationGatewayBackendAddressPools))
	for applicationGatewayBackendAddressPoolIndex, applicationGatewayBackendAddressPoolItem := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.ApplicationGatewayBackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		applicationGatewayBackendAddressPoolItem := applicationGatewayBackendAddressPoolItem
		var applicationGatewayBackendAddressPool v1alpha1api20201201storage.SubResource
		err := applicationGatewayBackendAddressPoolItem.AssignPropertiesToSubResource(&applicationGatewayBackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating ApplicationGatewayBackendAddressPools from ApplicationGatewayBackendAddressPools, calling AssignPropertiesToSubResource()")
		}
		applicationGatewayBackendAddressPoolList[applicationGatewayBackendAddressPoolIndex] = applicationGatewayBackendAddressPool
	}
	destination.ApplicationGatewayBackendAddressPools = applicationGatewayBackendAddressPoolList

	// ApplicationSecurityGroups
	applicationSecurityGroupList := make([]v1alpha1api20201201storage.SubResource, len(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.ApplicationSecurityGroups))
	for applicationSecurityGroupIndex, applicationSecurityGroupItem := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.ApplicationSecurityGroups {
		// Shadow the loop variable to avoid aliasing
		applicationSecurityGroupItem := applicationSecurityGroupItem
		var applicationSecurityGroup v1alpha1api20201201storage.SubResource
		err := applicationSecurityGroupItem.AssignPropertiesToSubResource(&applicationSecurityGroup)
		if err != nil {
			return errors.Wrap(err, "populating ApplicationSecurityGroups from ApplicationSecurityGroups, calling AssignPropertiesToSubResource()")
		}
		applicationSecurityGroupList[applicationSecurityGroupIndex] = applicationSecurityGroup
	}
	destination.ApplicationSecurityGroups = applicationSecurityGroupList

	// Id
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Id != nil {
		id := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Id
		destination.Id = &id
	} else {
		destination.Id = nil
	}

	// LoadBalancerBackendAddressPools
	loadBalancerBackendAddressPoolList := make([]v1alpha1api20201201storage.SubResource, len(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.LoadBalancerBackendAddressPools))
	for loadBalancerBackendAddressPoolIndex, loadBalancerBackendAddressPoolItem := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.LoadBalancerBackendAddressPools {
		// Shadow the loop variable to avoid aliasing
		loadBalancerBackendAddressPoolItem := loadBalancerBackendAddressPoolItem
		var loadBalancerBackendAddressPool v1alpha1api20201201storage.SubResource
		err := loadBalancerBackendAddressPoolItem.AssignPropertiesToSubResource(&loadBalancerBackendAddressPool)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerBackendAddressPools from LoadBalancerBackendAddressPools, calling AssignPropertiesToSubResource()")
		}
		loadBalancerBackendAddressPoolList[loadBalancerBackendAddressPoolIndex] = loadBalancerBackendAddressPool
	}
	destination.LoadBalancerBackendAddressPools = loadBalancerBackendAddressPoolList

	// LoadBalancerInboundNatPools
	loadBalancerInboundNatPoolList := make([]v1alpha1api20201201storage.SubResource, len(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.LoadBalancerInboundNatPools))
	for loadBalancerInboundNatPoolIndex, loadBalancerInboundNatPoolItem := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.LoadBalancerInboundNatPools {
		// Shadow the loop variable to avoid aliasing
		loadBalancerInboundNatPoolItem := loadBalancerInboundNatPoolItem
		var loadBalancerInboundNatPool v1alpha1api20201201storage.SubResource
		err := loadBalancerInboundNatPoolItem.AssignPropertiesToSubResource(&loadBalancerInboundNatPool)
		if err != nil {
			return errors.Wrap(err, "populating LoadBalancerInboundNatPools from LoadBalancerInboundNatPools, calling AssignPropertiesToSubResource()")
		}
		loadBalancerInboundNatPoolList[loadBalancerInboundNatPoolIndex] = loadBalancerInboundNatPool
	}
	destination.LoadBalancerInboundNatPools = loadBalancerInboundNatPoolList

	// Name
	name := virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Name
	destination.Name = &name

	// Primary
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Primary != nil {
		primary := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Primary
		destination.Primary = &primary
	} else {
		destination.Primary = nil
	}

	// PrivateIPAddressVersion
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PrivateIPAddressVersion != nil {
		privateIPAddressVersion := string(*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PrivateIPAddressVersion)
		destination.PrivateIPAddressVersion = &privateIPAddressVersion
	} else {
		destination.PrivateIPAddressVersion = nil
	}

	// PublicIPAddressConfiguration
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PublicIPAddressConfiguration != nil {
		var publicIPAddressConfiguration v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.PublicIPAddressConfiguration).AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration(&publicIPAddressConfiguration)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPAddressConfiguration from PublicIPAddressConfiguration, calling AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration()")
		}
		destination.PublicIPAddressConfiguration = &publicIPAddressConfiguration
	} else {
		destination.PublicIPAddressConfiguration = nil
	}

	// Subnet
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Subnet != nil {
		var subnet v1alpha1api20201201storage.ApiEntityReference
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurations.Subnet).AssignPropertiesToApiEntityReference(&subnet)
		if err != nil {
			return errors.Wrap(err, "populating Subnet from Subnet, calling AssignPropertiesToApiEntityReference()")
		}
		destination.Subnet = &subnet
	} else {
		destination.Subnet = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/WinRMConfiguration
type WinRMConfiguration struct {
	//Listeners: The list of Windows Remote Management listeners
	Listeners []WinRMListener `json:"listeners,omitempty"`
}

var _ genruntime.ARMTransformer = &WinRMConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (winRMConfiguration *WinRMConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if winRMConfiguration == nil {
		return nil, nil
	}
	var result WinRMConfigurationARM

	// Set property ‘Listeners’:
	for _, item := range winRMConfiguration.Listeners {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Listeners = append(result.Listeners, itemARM.(WinRMListenerARM))
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (winRMConfiguration *WinRMConfiguration) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &WinRMConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (winRMConfiguration *WinRMConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WinRMConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WinRMConfigurationARM, got %T", armInput)
	}

	// Set property ‘Listeners’:
	for _, item := range typedInput.Listeners {
		var item1 WinRMListener
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		winRMConfiguration.Listeners = append(winRMConfiguration.Listeners, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromWinRMConfiguration populates our WinRMConfiguration from the provided source WinRMConfiguration
func (winRMConfiguration *WinRMConfiguration) AssignPropertiesFromWinRMConfiguration(source *v1alpha1api20201201storage.WinRMConfiguration) error {

	// Listeners
	listenerList := make([]WinRMListener, len(source.Listeners))
	for listenerIndex, listenerItem := range source.Listeners {
		// Shadow the loop variable to avoid aliasing
		listenerItem := listenerItem
		var listener WinRMListener
		err := listener.AssignPropertiesFromWinRMListener(&listenerItem)
		if err != nil {
			return errors.Wrap(err, "populating Listeners from Listeners, calling AssignPropertiesFromWinRMListener()")
		}
		listenerList[listenerIndex] = listener
	}
	winRMConfiguration.Listeners = listenerList

	// No error
	return nil
}

// AssignPropertiesToWinRMConfiguration populates the provided destination WinRMConfiguration from our WinRMConfiguration
func (winRMConfiguration *WinRMConfiguration) AssignPropertiesToWinRMConfiguration(destination *v1alpha1api20201201storage.WinRMConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Listeners
	listenerList := make([]v1alpha1api20201201storage.WinRMListener, len(winRMConfiguration.Listeners))
	for listenerIndex, listenerItem := range winRMConfiguration.Listeners {
		// Shadow the loop variable to avoid aliasing
		listenerItem := listenerItem
		var listener v1alpha1api20201201storage.WinRMListener
		err := listenerItem.AssignPropertiesToWinRMListener(&listener)
		if err != nil {
			return errors.Wrap(err, "populating Listeners from Listeners, calling AssignPropertiesToWinRMListener()")
		}
		listenerList[listenerIndex] = listener
	}
	destination.Listeners = listenerList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type WinRMConfiguration_Status struct {
	//Listeners: The list of Windows Remote Management listeners
	Listeners []WinRMListener_Status `json:"listeners,omitempty"`
}

var _ genruntime.FromARMConverter = &WinRMConfiguration_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (winRMConfigurationStatus *WinRMConfiguration_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &WinRMConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (winRMConfigurationStatus *WinRMConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WinRMConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WinRMConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘Listeners’:
	for _, item := range typedInput.Listeners {
		var item1 WinRMListener_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		winRMConfigurationStatus.Listeners = append(winRMConfigurationStatus.Listeners, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromWinRMConfigurationStatus populates our WinRMConfiguration_Status from the provided source WinRMConfiguration_Status
func (winRMConfigurationStatus *WinRMConfiguration_Status) AssignPropertiesFromWinRMConfigurationStatus(source *v1alpha1api20201201storage.WinRMConfiguration_Status) error {

	// Listeners
	listenerList := make([]WinRMListener_Status, len(source.Listeners))
	for listenerIndex, listenerItem := range source.Listeners {
		// Shadow the loop variable to avoid aliasing
		listenerItem := listenerItem
		var listener WinRMListener_Status
		err := listener.AssignPropertiesFromWinRMListenerStatus(&listenerItem)
		if err != nil {
			return errors.Wrap(err, "populating Listeners from Listeners, calling AssignPropertiesFromWinRMListenerStatus()")
		}
		listenerList[listenerIndex] = listener
	}
	winRMConfigurationStatus.Listeners = listenerList

	// No error
	return nil
}

// AssignPropertiesToWinRMConfigurationStatus populates the provided destination WinRMConfiguration_Status from our WinRMConfiguration_Status
func (winRMConfigurationStatus *WinRMConfiguration_Status) AssignPropertiesToWinRMConfigurationStatus(destination *v1alpha1api20201201storage.WinRMConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Listeners
	listenerList := make([]v1alpha1api20201201storage.WinRMListener_Status, len(winRMConfigurationStatus.Listeners))
	for listenerIndex, listenerItem := range winRMConfigurationStatus.Listeners {
		// Shadow the loop variable to avoid aliasing
		listenerItem := listenerItem
		var listener v1alpha1api20201201storage.WinRMListener_Status
		err := listenerItem.AssignPropertiesToWinRMListenerStatus(&listener)
		if err != nil {
			return errors.Wrap(err, "populating Listeners from Listeners, calling AssignPropertiesToWinRMListenerStatus()")
		}
		listenerList[listenerIndex] = listener
	}
	destination.Listeners = listenerList

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Microsoft-Windows-Shell-Setup"}
type AdditionalUnattendContentComponentName string

const AdditionalUnattendContentComponentNameMicrosoftWindowsShellSetup = AdditionalUnattendContentComponentName("Microsoft-Windows-Shell-Setup")

// +kubebuilder:validation:Enum={"OobeSystem"}
type AdditionalUnattendContentPassName string

const AdditionalUnattendContentPassNameOobeSystem = AdditionalUnattendContentPassName("OobeSystem")

// +kubebuilder:validation:Enum={"AutoLogon","FirstLogonCommands"}
type AdditionalUnattendContentSettingName string

const (
	AdditionalUnattendContentSettingNameAutoLogon          = AdditionalUnattendContentSettingName("AutoLogon")
	AdditionalUnattendContentSettingNameFirstLogonCommands = AdditionalUnattendContentSettingName("FirstLogonCommands")
)

type AdditionalUnattendContentStatusComponentName string

const AdditionalUnattendContentStatusComponentNameMicrosoftWindowsShellSetup = AdditionalUnattendContentStatusComponentName("Microsoft-Windows-Shell-Setup")

type AdditionalUnattendContentStatusPassName string

const AdditionalUnattendContentStatusPassNameOobeSystem = AdditionalUnattendContentStatusPassName("OobeSystem")

type AdditionalUnattendContentStatusSettingName string

const (
	AdditionalUnattendContentStatusSettingNameAutoLogon          = AdditionalUnattendContentStatusSettingName("AutoLogon")
	AdditionalUnattendContentStatusSettingNameFirstLogonCommands = AdditionalUnattendContentStatusSettingName("FirstLogonCommands")
)

//Generated from:
type DiffDiskOption_Status string

const DiffDiskOption_StatusLocal = DiffDiskOption_Status("Local")

//Generated from:
type DiffDiskPlacement_Status string

const (
	DiffDiskPlacement_StatusCacheDisk    = DiffDiskPlacement_Status("CacheDisk")
	DiffDiskPlacement_StatusResourceDisk = DiffDiskPlacement_Status("ResourceDisk")
)

// +kubebuilder:validation:Enum={"Local"}
type DiffDiskSettingsOption string

const DiffDiskSettingsOptionLocal = DiffDiskSettingsOption("Local")

// +kubebuilder:validation:Enum={"CacheDisk","ResourceDisk"}
type DiffDiskSettingsPlacement string

const (
	DiffDiskSettingsPlacementCacheDisk    = DiffDiskSettingsPlacement("CacheDisk")
	DiffDiskSettingsPlacementResourceDisk = DiffDiskSettingsPlacement("ResourceDisk")
)

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/DiskEncryptionSetParameters
type DiskEncryptionSetParameters struct {
	//Reference: Resource Id
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &DiskEncryptionSetParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (diskEncryptionSetParameters *DiskEncryptionSetParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if diskEncryptionSetParameters == nil {
		return nil, nil
	}
	var result DiskEncryptionSetParametersARM

	// Set property ‘Id’:
	if diskEncryptionSetParameters.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*diskEncryptionSetParameters.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (diskEncryptionSetParameters *DiskEncryptionSetParameters) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &DiskEncryptionSetParametersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (diskEncryptionSetParameters *DiskEncryptionSetParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(DiskEncryptionSetParametersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DiskEncryptionSetParametersARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromDiskEncryptionSetParameters populates our DiskEncryptionSetParameters from the provided source DiskEncryptionSetParameters
func (diskEncryptionSetParameters *DiskEncryptionSetParameters) AssignPropertiesFromDiskEncryptionSetParameters(source *v1alpha1api20201201storage.DiskEncryptionSetParameters) error {

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		diskEncryptionSetParameters.Reference = &reference
	} else {
		diskEncryptionSetParameters.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDiskEncryptionSetParameters populates the provided destination DiskEncryptionSetParameters from our DiskEncryptionSetParameters
func (diskEncryptionSetParameters *DiskEncryptionSetParameters) AssignPropertiesToDiskEncryptionSetParameters(destination *v1alpha1api20201201storage.DiskEncryptionSetParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if diskEncryptionSetParameters.Reference != nil {
		reference := diskEncryptionSetParameters.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AutomaticByPlatform","ImageDefault"}
type LinuxPatchSettingsPatchMode string

const (
	LinuxPatchSettingsPatchModeAutomaticByPlatform = LinuxPatchSettingsPatchMode("AutomaticByPlatform")
	LinuxPatchSettingsPatchModeImageDefault        = LinuxPatchSettingsPatchMode("ImageDefault")
)

type LinuxPatchSettingsStatusPatchMode string

const (
	LinuxPatchSettingsStatusPatchModeAutomaticByPlatform = LinuxPatchSettingsStatusPatchMode("AutomaticByPlatform")
	LinuxPatchSettingsStatusPatchModeImageDefault        = LinuxPatchSettingsStatusPatchMode("ImageDefault")
)

// +kubebuilder:validation:Enum={"AutomaticByOS","AutomaticByPlatform","Manual"}
type PatchSettingsPatchMode string

const (
	PatchSettingsPatchModeAutomaticByOS       = PatchSettingsPatchMode("AutomaticByOS")
	PatchSettingsPatchModeAutomaticByPlatform = PatchSettingsPatchMode("AutomaticByPlatform")
	PatchSettingsPatchModeManual              = PatchSettingsPatchMode("Manual")
)

type PatchSettingsStatusPatchMode string

const (
	PatchSettingsStatusPatchModeAutomaticByOS       = PatchSettingsStatusPatchMode("AutomaticByOS")
	PatchSettingsStatusPatchModeAutomaticByPlatform = PatchSettingsStatusPatchMode("AutomaticByPlatform")
	PatchSettingsStatusPatchModeManual              = PatchSettingsStatusPatchMode("Manual")
)

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/SshPublicKey
type SshPublicKey struct {
	//KeyData: SSH public key certificate used to authenticate with the VM through
	//ssh. The key needs to be at least 2048-bit and in ssh-rsa format.
	//For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in
	//Azure](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
	KeyData *string `json:"keyData,omitempty"`

	//Path: Specifies the full path on the created VM where ssh public key is stored.
	//If the file already exists, the specified key is appended to the file. Example:
	///home/user/.ssh/authorized_keys
	Path *string `json:"path,omitempty"`
}

var _ genruntime.ARMTransformer = &SshPublicKey{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sshPublicKey *SshPublicKey) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sshPublicKey == nil {
		return nil, nil
	}
	var result SshPublicKeyARM

	// Set property ‘KeyData’:
	if sshPublicKey.KeyData != nil {
		keyData := *sshPublicKey.KeyData
		result.KeyData = &keyData
	}

	// Set property ‘Path’:
	if sshPublicKey.Path != nil {
		path := *sshPublicKey.Path
		result.Path = &path
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sshPublicKey *SshPublicKey) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &SshPublicKeyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sshPublicKey *SshPublicKey) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SshPublicKeyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SshPublicKeyARM, got %T", armInput)
	}

	// Set property ‘KeyData’:
	if typedInput.KeyData != nil {
		keyData := *typedInput.KeyData
		sshPublicKey.KeyData = &keyData
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		sshPublicKey.Path = &path
	}

	// No error
	return nil
}

// AssignPropertiesFromSshPublicKey populates our SshPublicKey from the provided source SshPublicKey
func (sshPublicKey *SshPublicKey) AssignPropertiesFromSshPublicKey(source *v1alpha1api20201201storage.SshPublicKey) error {

	// KeyData
	if source.KeyData != nil {
		keyDatum := *source.KeyData
		sshPublicKey.KeyData = &keyDatum
	} else {
		sshPublicKey.KeyData = nil
	}

	// Path
	if source.Path != nil {
		path := *source.Path
		sshPublicKey.Path = &path
	} else {
		sshPublicKey.Path = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSshPublicKey populates the provided destination SshPublicKey from our SshPublicKey
func (sshPublicKey *SshPublicKey) AssignPropertiesToSshPublicKey(destination *v1alpha1api20201201storage.SshPublicKey) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	if sshPublicKey.KeyData != nil {
		keyDatum := *sshPublicKey.KeyData
		destination.KeyData = &keyDatum
	} else {
		destination.KeyData = nil
	}

	// Path
	if sshPublicKey.Path != nil {
		path := *sshPublicKey.Path
		destination.Path = &path
	} else {
		destination.Path = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type SshPublicKey_Status struct {
	//KeyData: SSH public key certificate used to authenticate with the VM through
	//ssh. The key needs to be at least 2048-bit and in ssh-rsa format.
	//For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in
	//Azure](https://docs.microsoft.com/en-us/azure/virtual-machines/linux/mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
	KeyData *string `json:"keyData,omitempty"`

	//Path: Specifies the full path on the created VM where ssh public key is stored.
	//If the file already exists, the specified key is appended to the file. Example:
	///home/user/.ssh/authorized_keys
	Path *string `json:"path,omitempty"`
}

var _ genruntime.FromARMConverter = &SshPublicKey_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sshPublicKeyStatus *SshPublicKey_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &SshPublicKey_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sshPublicKeyStatus *SshPublicKey_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SshPublicKey_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SshPublicKey_StatusARM, got %T", armInput)
	}

	// Set property ‘KeyData’:
	if typedInput.KeyData != nil {
		keyData := *typedInput.KeyData
		sshPublicKeyStatus.KeyData = &keyData
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		sshPublicKeyStatus.Path = &path
	}

	// No error
	return nil
}

// AssignPropertiesFromSshPublicKeyStatus populates our SshPublicKey_Status from the provided source SshPublicKey_Status
func (sshPublicKeyStatus *SshPublicKey_Status) AssignPropertiesFromSshPublicKeyStatus(source *v1alpha1api20201201storage.SshPublicKey_Status) error {

	// KeyData
	if source.KeyData != nil {
		keyDatum := *source.KeyData
		sshPublicKeyStatus.KeyData = &keyDatum
	} else {
		sshPublicKeyStatus.KeyData = nil
	}

	// Path
	if source.Path != nil {
		path := *source.Path
		sshPublicKeyStatus.Path = &path
	} else {
		sshPublicKeyStatus.Path = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSshPublicKeyStatus populates the provided destination SshPublicKey_Status from our SshPublicKey_Status
func (sshPublicKeyStatus *SshPublicKey_Status) AssignPropertiesToSshPublicKeyStatus(destination *v1alpha1api20201201storage.SshPublicKey_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyData
	if sshPublicKeyStatus.KeyData != nil {
		keyDatum := *sshPublicKeyStatus.KeyData
		destination.KeyData = &keyDatum
	} else {
		destination.KeyData = nil
	}

	// Path
	if sshPublicKeyStatus.Path != nil {
		path := *sshPublicKeyStatus.Path
		destination.Path = &path
	} else {
		destination.Path = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type StorageAccountType_Status string

const (
	StorageAccountType_StatusPremiumLRS     = StorageAccountType_Status("Premium_LRS")
	StorageAccountType_StatusPremiumZRS     = StorageAccountType_Status("Premium_ZRS")
	StorageAccountType_StatusStandardLRS    = StorageAccountType_Status("Standard_LRS")
	StorageAccountType_StatusStandardSSDLRS = StorageAccountType_Status("StandardSSD_LRS")
	StorageAccountType_StatusStandardSSDZRS = StorageAccountType_Status("StandardSSD_ZRS")
	StorageAccountType_StatusUltraSSDLRS    = StorageAccountType_Status("UltraSSD_LRS")
)

type VirtualMachineScaleSetIPConfigurationPropertiesStatusPrivateIPAddressVersion string

const (
	VirtualMachineScaleSetIPConfigurationPropertiesStatusPrivateIPAddressVersionIPv4 = VirtualMachineScaleSetIPConfigurationPropertiesStatusPrivateIPAddressVersion("IPv4")
	VirtualMachineScaleSetIPConfigurationPropertiesStatusPrivateIPAddressVersionIPv6 = VirtualMachineScaleSetIPConfigurationPropertiesStatusPrivateIPAddressVersion("IPv6")
)

// +kubebuilder:validation:Enum={"Premium_LRS","Standard_LRS","StandardSSD_LRS","UltraSSD_LRS"}
type VirtualMachineScaleSetManagedDiskParametersStorageAccountType string

const (
	VirtualMachineScaleSetManagedDiskParametersStorageAccountTypePremiumLRS     = VirtualMachineScaleSetManagedDiskParametersStorageAccountType("Premium_LRS")
	VirtualMachineScaleSetManagedDiskParametersStorageAccountTypeStandardLRS    = VirtualMachineScaleSetManagedDiskParametersStorageAccountType("Standard_LRS")
	VirtualMachineScaleSetManagedDiskParametersStorageAccountTypeStandardSSDLRS = VirtualMachineScaleSetManagedDiskParametersStorageAccountType("StandardSSD_LRS")
	VirtualMachineScaleSetManagedDiskParametersStorageAccountTypeUltraSSDLRS    = VirtualMachineScaleSetManagedDiskParametersStorageAccountType("UltraSSD_LRS")
)

//Generated from:
type VirtualMachineScaleSetPublicIPAddressConfiguration_Status struct {
	//DnsSettings: The dns settings to be applied on the publicIP addresses .
	DnsSettings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status `json:"dnsSettings,omitempty"`

	//IdleTimeoutInMinutes: The idle timeout of the public IP address.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//IpTags: The list of IP tags associated with the public IP address.
	IpTags []VirtualMachineScaleSetIpTag_Status `json:"ipTags,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The publicIP address configuration name.
	Name string `json:"name"`

	//PublicIPAddressVersion: Available from Api-Version 2019-07-01 onwards, it
	//represents whether the specific ipconfiguration is IPv4 or IPv6. Default is
	//taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
	PublicIPAddressVersion *VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesStatusPublicIPAddressVersion `json:"publicIPAddressVersion,omitempty"`

	//PublicIPPrefix: The PublicIPPrefix from which to allocate publicIP addresses.
	PublicIPPrefix *SubResource_Status `json:"publicIPPrefix,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetPublicIPAddressConfiguration_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetPublicIPAddressConfigurationStatus *VirtualMachineScaleSetPublicIPAddressConfiguration_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetPublicIPAddressConfiguration_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetPublicIPAddressConfigurationStatus *VirtualMachineScaleSetPublicIPAddressConfiguration_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetPublicIPAddressConfiguration_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetPublicIPAddressConfiguration_StatusARM, got %T", armInput)
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			virtualMachineScaleSetPublicIPAddressConfigurationStatus.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			virtualMachineScaleSetPublicIPAddressConfigurationStatus.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘IpTags’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpTags {
			var item1 VirtualMachineScaleSetIpTag_Status
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			virtualMachineScaleSetPublicIPAddressConfigurationStatus.IpTags = append(virtualMachineScaleSetPublicIPAddressConfigurationStatus.IpTags, item1)
		}
	}

	// Set property ‘Name’:
	virtualMachineScaleSetPublicIPAddressConfigurationStatus.Name = typedInput.Name

	// Set property ‘PublicIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressVersion != nil {
			publicIPAddressVersion := *typedInput.Properties.PublicIPAddressVersion
			virtualMachineScaleSetPublicIPAddressConfigurationStatus.PublicIPAddressVersion = &publicIPAddressVersion
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource_Status
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			virtualMachineScaleSetPublicIPAddressConfigurationStatus.PublicIPPrefix = &publicIPPrefix
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationStatus populates our VirtualMachineScaleSetPublicIPAddressConfiguration_Status from the provided source VirtualMachineScaleSetPublicIPAddressConfiguration_Status
func (virtualMachineScaleSetPublicIPAddressConfigurationStatus *VirtualMachineScaleSetPublicIPAddressConfiguration_Status) AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfiguration_Status) error {

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "populating DnsSettings from DnsSettings, calling AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus()")
		}
		virtualMachineScaleSetPublicIPAddressConfigurationStatus.DnsSettings = &dnsSetting
	} else {
		virtualMachineScaleSetPublicIPAddressConfigurationStatus.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	if source.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *source.IdleTimeoutInMinutes
		virtualMachineScaleSetPublicIPAddressConfigurationStatus.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		virtualMachineScaleSetPublicIPAddressConfigurationStatus.IdleTimeoutInMinutes = nil
	}

	// IpTags
	ipTagList := make([]VirtualMachineScaleSetIpTag_Status, len(source.IpTags))
	for ipTagIndex, ipTagItem := range source.IpTags {
		// Shadow the loop variable to avoid aliasing
		ipTagItem := ipTagItem
		var ipTag VirtualMachineScaleSetIpTag_Status
		err := ipTag.AssignPropertiesFromVirtualMachineScaleSetIpTagStatus(&ipTagItem)
		if err != nil {
			return errors.Wrap(err, "populating IpTags from IpTags, calling AssignPropertiesFromVirtualMachineScaleSetIpTagStatus()")
		}
		ipTagList[ipTagIndex] = ipTag
	}
	virtualMachineScaleSetPublicIPAddressConfigurationStatus.IpTags = ipTagList

	// Name
	if source.Name != nil {
		virtualMachineScaleSetPublicIPAddressConfigurationStatus.Name = *source.Name
	} else {
		virtualMachineScaleSetPublicIPAddressConfigurationStatus.Name = ""
	}

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesStatusPublicIPAddressVersion(*source.PublicIPAddressVersion)
		virtualMachineScaleSetPublicIPAddressConfigurationStatus.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		virtualMachineScaleSetPublicIPAddressConfigurationStatus.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource_Status
		err := publicIPPrefix.AssignPropertiesFromSubResourceStatus(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPPrefix from PublicIPPrefix, calling AssignPropertiesFromSubResourceStatus()")
		}
		virtualMachineScaleSetPublicIPAddressConfigurationStatus.PublicIPPrefix = &publicIPPrefix
	} else {
		virtualMachineScaleSetPublicIPAddressConfigurationStatus.PublicIPPrefix = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationStatus populates the provided destination VirtualMachineScaleSetPublicIPAddressConfiguration_Status from our VirtualMachineScaleSetPublicIPAddressConfiguration_Status
func (virtualMachineScaleSetPublicIPAddressConfigurationStatus *VirtualMachineScaleSetPublicIPAddressConfiguration_Status) AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfiguration_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsSettings
	if virtualMachineScaleSetPublicIPAddressConfigurationStatus.DnsSettings != nil {
		var dnsSetting v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
		err := (*virtualMachineScaleSetPublicIPAddressConfigurationStatus.DnsSettings).AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "populating DnsSettings from DnsSettings, calling AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus()")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	if virtualMachineScaleSetPublicIPAddressConfigurationStatus.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *virtualMachineScaleSetPublicIPAddressConfigurationStatus.IdleTimeoutInMinutes
		destination.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		destination.IdleTimeoutInMinutes = nil
	}

	// IpTags
	ipTagList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Status, len(virtualMachineScaleSetPublicIPAddressConfigurationStatus.IpTags))
	for ipTagIndex, ipTagItem := range virtualMachineScaleSetPublicIPAddressConfigurationStatus.IpTags {
		// Shadow the loop variable to avoid aliasing
		ipTagItem := ipTagItem
		var ipTag v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Status
		err := ipTagItem.AssignPropertiesToVirtualMachineScaleSetIpTagStatus(&ipTag)
		if err != nil {
			return errors.Wrap(err, "populating IpTags from IpTags, calling AssignPropertiesToVirtualMachineScaleSetIpTagStatus()")
		}
		ipTagList[ipTagIndex] = ipTag
	}
	destination.IpTags = ipTagList

	// Name
	name := virtualMachineScaleSetPublicIPAddressConfigurationStatus.Name
	destination.Name = &name

	// PublicIPAddressVersion
	if virtualMachineScaleSetPublicIPAddressConfigurationStatus.PublicIPAddressVersion != nil {
		publicIPAddressVersion := string(*virtualMachineScaleSetPublicIPAddressConfigurationStatus.PublicIPAddressVersion)
		destination.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		destination.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if virtualMachineScaleSetPublicIPAddressConfigurationStatus.PublicIPPrefix != nil {
		var publicIPPrefix v1alpha1api20201201storage.SubResource_Status
		err := (*virtualMachineScaleSetPublicIPAddressConfigurationStatus.PublicIPPrefix).AssignPropertiesToSubResourceStatus(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPPrefix from PublicIPPrefix, calling AssignPropertiesToSubResourceStatus()")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"IPv4","IPv6"}
type VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersion string

const (
	VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersionIPv4 = VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersion("IPv4")
	VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersionIPv6 = VirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPrivateIPAddressVersion("IPv6")
)

type VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration struct {
	//DnsSettings: Describes a virtual machines scale sets network configuration's DNS
	//settings.
	DnsSettings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings `json:"dnsSettings,omitempty"`

	//IdleTimeoutInMinutes: The idle timeout of the public IP address.
	IdleTimeoutInMinutes *int `json:"idleTimeoutInMinutes,omitempty"`

	//IpTags: The list of IP tags associated with the public IP address.
	IpTags []VirtualMachineScaleSetIpTag `json:"ipTags,omitempty"`

	// +kubebuilder:validation:Required
	//Name: The publicIP address configuration name.
	Name string `json:"name"`

	//PublicIPAddressVersion: Available from Api-Version 2019-07-01 onwards, it
	//represents whether the specific ipconfiguration is IPv4 or IPv6. Default is
	//taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
	PublicIPAddressVersion *VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesPublicIPAddressVersion `json:"publicIPAddressVersion,omitempty"`
	PublicIPPrefix         *SubResource                                                                        `json:"publicIPPrefix,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM

	// Set property ‘Name’:
	result.Name = virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.Name

	// Set property ‘Properties’:
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.DnsSettings != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IdleTimeoutInMinutes != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IpTags != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPAddressVersion != nil || virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPPrefix != nil {
		result.Properties = &VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesARM{}
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.DnsSettings != nil {
		dnsSettingsARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.DnsSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dnsSettings := dnsSettingsARM.(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsARM)
		result.Properties.DnsSettings = &dnsSettings
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinutes := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IdleTimeoutInMinutes
		result.Properties.IdleTimeoutInMinutes = &idleTimeoutInMinutes
	}
	for _, item := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IpTags {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.IpTags = append(result.Properties.IpTags, itemARM.(VirtualMachineScaleSetIpTagARM))
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPAddressVersion != nil {
		publicIPAddressVersion := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPAddressVersion
		result.Properties.PublicIPAddressVersion = &publicIPAddressVersion
	}
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPPrefix != nil {
		publicIPPrefixARM, err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPPrefix).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIPPrefix := publicIPPrefixARM.(SubResourceARM)
		result.Properties.PublicIPPrefix = &publicIPPrefix
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfigurationARM, got %T", armInput)
	}

	// Set property ‘DnsSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DnsSettings != nil {
			var dnsSettings1 VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
			err := dnsSettings1.PopulateFromARM(owner, *typedInput.Properties.DnsSettings)
			if err != nil {
				return err
			}
			dnsSettings := dnsSettings1
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.DnsSettings = &dnsSettings
		}
	}

	// Set property ‘IdleTimeoutInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IdleTimeoutInMinutes != nil {
			idleTimeoutInMinutes := *typedInput.Properties.IdleTimeoutInMinutes
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IdleTimeoutInMinutes = &idleTimeoutInMinutes
		}
	}

	// Set property ‘IpTags’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.IpTags {
			var item1 VirtualMachineScaleSetIpTag
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IpTags = append(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IpTags, item1)
		}
	}

	// Set property ‘Name’:
	virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.Name = typedInput.Name

	// Set property ‘PublicIPAddressVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPAddressVersion != nil {
			publicIPAddressVersion := *typedInput.Properties.PublicIPAddressVersion
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPAddressVersion = &publicIPAddressVersion
		}
	}

	// Set property ‘PublicIPPrefix’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicIPPrefix != nil {
			var publicIPPrefix1 SubResource
			err := publicIPPrefix1.PopulateFromARM(owner, *typedInput.Properties.PublicIPPrefix)
			if err != nil {
				return err
			}
			publicIPPrefix := publicIPPrefix1
			virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPPrefix = &publicIPPrefix
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration populates our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration from the provided source VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration) AssignPropertiesFromVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration(source *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration) error {

	// DnsSettings
	if source.DnsSettings != nil {
		var dnsSetting VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
		err := dnsSetting.AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(source.DnsSettings)
		if err != nil {
			return errors.Wrap(err, "populating DnsSettings from DnsSettings, calling AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.DnsSettings = &dnsSetting
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	if source.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *source.IdleTimeoutInMinutes
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IdleTimeoutInMinutes = nil
	}

	// IpTags
	ipTagList := make([]VirtualMachineScaleSetIpTag, len(source.IpTags))
	for ipTagIndex, ipTagItem := range source.IpTags {
		// Shadow the loop variable to avoid aliasing
		ipTagItem := ipTagItem
		var ipTag VirtualMachineScaleSetIpTag
		err := ipTag.AssignPropertiesFromVirtualMachineScaleSetIpTag(&ipTagItem)
		if err != nil {
			return errors.Wrap(err, "populating IpTags from IpTags, calling AssignPropertiesFromVirtualMachineScaleSetIpTag()")
		}
		ipTagList[ipTagIndex] = ipTag
	}
	virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IpTags = ipTagList

	// Name
	if source.Name != nil {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.Name = *source.Name
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.Name = ""
	}

	// PublicIPAddressVersion
	if source.PublicIPAddressVersion != nil {
		publicIPAddressVersion := VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesPublicIPAddressVersion(*source.PublicIPAddressVersion)
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if source.PublicIPPrefix != nil {
		var publicIPPrefix SubResource
		err := publicIPPrefix.AssignPropertiesFromSubResource(source.PublicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPPrefix from PublicIPPrefix, calling AssignPropertiesFromSubResource()")
		}
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPPrefix = &publicIPPrefix
	} else {
		virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPPrefix = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration populates the provided destination VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration from our VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration
func (virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration *VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration) AssignPropertiesToVirtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration(destination *v1alpha1api20201201storage.VirtualMachineScaleSets_Spec_Properties_VirtualMachineProfile_NetworkProfile_NetworkInterfaceConfigurations_Properties_IpConfigurations_Properties_PublicIPAddressConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DnsSettings
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.DnsSettings != nil {
		var dnsSetting v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.DnsSettings).AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(&dnsSetting)
		if err != nil {
			return errors.Wrap(err, "populating DnsSettings from DnsSettings, calling AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings()")
		}
		destination.DnsSettings = &dnsSetting
	} else {
		destination.DnsSettings = nil
	}

	// IdleTimeoutInMinutes
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IdleTimeoutInMinutes != nil {
		idleTimeoutInMinute := *virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IdleTimeoutInMinutes
		destination.IdleTimeoutInMinutes = &idleTimeoutInMinute
	} else {
		destination.IdleTimeoutInMinutes = nil
	}

	// IpTags
	ipTagList := make([]v1alpha1api20201201storage.VirtualMachineScaleSetIpTag, len(virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IpTags))
	for ipTagIndex, ipTagItem := range virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.IpTags {
		// Shadow the loop variable to avoid aliasing
		ipTagItem := ipTagItem
		var ipTag v1alpha1api20201201storage.VirtualMachineScaleSetIpTag
		err := ipTagItem.AssignPropertiesToVirtualMachineScaleSetIpTag(&ipTag)
		if err != nil {
			return errors.Wrap(err, "populating IpTags from IpTags, calling AssignPropertiesToVirtualMachineScaleSetIpTag()")
		}
		ipTagList[ipTagIndex] = ipTag
	}
	destination.IpTags = ipTagList

	// Name
	name := virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.Name
	destination.Name = &name

	// PublicIPAddressVersion
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPAddressVersion != nil {
		publicIPAddressVersion := string(*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPAddressVersion)
		destination.PublicIPAddressVersion = &publicIPAddressVersion
	} else {
		destination.PublicIPAddressVersion = nil
	}

	// PublicIPPrefix
	if virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPPrefix != nil {
		var publicIPPrefix v1alpha1api20201201storage.SubResource
		err := (*virtualMachineScaleSetsSpecPropertiesVirtualMachineProfileNetworkProfileNetworkInterfaceConfigurationsPropertiesIpConfigurationsPropertiesPublicIPAddressConfiguration.PublicIPPrefix).AssignPropertiesToSubResource(&publicIPPrefix)
		if err != nil {
			return errors.Wrap(err, "populating PublicIPPrefix from PublicIPPrefix, calling AssignPropertiesToSubResource()")
		}
		destination.PublicIPPrefix = &publicIPPrefix
	} else {
		destination.PublicIPPrefix = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/WinRMListener
type WinRMListener struct {
	//CertificateUrl: This is the URL of a certificate that has been uploaded to Key
	//Vault as a secret. For adding a secret to the Key Vault, see [Add a key or
	//secret to the key
	//vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
	//In this case, your certificate needs to be It is the Base64 encoding of the
	//following JSON Object which is encoded in UTF-8:
	//{
	//"data":"<Base64-encoded-certificate>",
	//"dataType":"pfx",
	//"password":"<pfx-file-password>"
	//}
	CertificateUrl *string `json:"certificateUrl,omitempty"`

	//Protocol: Specifies the protocol of WinRM listener.
	//Possible values are:
	//http
	//https.
	Protocol *WinRMListenerProtocol `json:"protocol,omitempty"`
}

var _ genruntime.ARMTransformer = &WinRMListener{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (winRMListener *WinRMListener) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if winRMListener == nil {
		return nil, nil
	}
	var result WinRMListenerARM

	// Set property ‘CertificateUrl’:
	if winRMListener.CertificateUrl != nil {
		certificateUrl := *winRMListener.CertificateUrl
		result.CertificateUrl = &certificateUrl
	}

	// Set property ‘Protocol’:
	if winRMListener.Protocol != nil {
		protocol := *winRMListener.Protocol
		result.Protocol = &protocol
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (winRMListener *WinRMListener) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &WinRMListenerARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (winRMListener *WinRMListener) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WinRMListenerARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WinRMListenerARM, got %T", armInput)
	}

	// Set property ‘CertificateUrl’:
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		winRMListener.CertificateUrl = &certificateUrl
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		winRMListener.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignPropertiesFromWinRMListener populates our WinRMListener from the provided source WinRMListener
func (winRMListener *WinRMListener) AssignPropertiesFromWinRMListener(source *v1alpha1api20201201storage.WinRMListener) error {

	// CertificateUrl
	if source.CertificateUrl != nil {
		certificateUrl := *source.CertificateUrl
		winRMListener.CertificateUrl = &certificateUrl
	} else {
		winRMListener.CertificateUrl = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := WinRMListenerProtocol(*source.Protocol)
		winRMListener.Protocol = &protocol
	} else {
		winRMListener.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWinRMListener populates the provided destination WinRMListener from our WinRMListener
func (winRMListener *WinRMListener) AssignPropertiesToWinRMListener(destination *v1alpha1api20201201storage.WinRMListener) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateUrl
	if winRMListener.CertificateUrl != nil {
		certificateUrl := *winRMListener.CertificateUrl
		destination.CertificateUrl = &certificateUrl
	} else {
		destination.CertificateUrl = nil
	}

	// Protocol
	if winRMListener.Protocol != nil {
		protocol := string(*winRMListener.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type WinRMListener_Status struct {
	//CertificateUrl: This is the URL of a certificate that has been uploaded to Key
	//Vault as a secret. For adding a secret to the Key Vault, see [Add a key or
	//secret to the key
	//vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add).
	//In this case, your certificate needs to be It is the Base64 encoding of the
	//following JSON Object which is encoded in UTF-8:
	//{
	//"data":"<Base64-encoded-certificate>",
	//"dataType":"pfx",
	//"password":"<pfx-file-password>"
	//}
	CertificateUrl *string `json:"certificateUrl,omitempty"`

	//Protocol: Specifies the protocol of WinRM listener.
	//Possible values are:
	//http
	//https
	Protocol *WinRMListenerStatusProtocol `json:"protocol,omitempty"`
}

var _ genruntime.FromARMConverter = &WinRMListener_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (winRMListenerStatus *WinRMListener_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &WinRMListener_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (winRMListenerStatus *WinRMListener_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(WinRMListener_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected WinRMListener_StatusARM, got %T", armInput)
	}

	// Set property ‘CertificateUrl’:
	if typedInput.CertificateUrl != nil {
		certificateUrl := *typedInput.CertificateUrl
		winRMListenerStatus.CertificateUrl = &certificateUrl
	}

	// Set property ‘Protocol’:
	if typedInput.Protocol != nil {
		protocol := *typedInput.Protocol
		winRMListenerStatus.Protocol = &protocol
	}

	// No error
	return nil
}

// AssignPropertiesFromWinRMListenerStatus populates our WinRMListener_Status from the provided source WinRMListener_Status
func (winRMListenerStatus *WinRMListener_Status) AssignPropertiesFromWinRMListenerStatus(source *v1alpha1api20201201storage.WinRMListener_Status) error {

	// CertificateUrl
	if source.CertificateUrl != nil {
		certificateUrl := *source.CertificateUrl
		winRMListenerStatus.CertificateUrl = &certificateUrl
	} else {
		winRMListenerStatus.CertificateUrl = nil
	}

	// Protocol
	if source.Protocol != nil {
		protocol := WinRMListenerStatusProtocol(*source.Protocol)
		winRMListenerStatus.Protocol = &protocol
	} else {
		winRMListenerStatus.Protocol = nil
	}

	// No error
	return nil
}

// AssignPropertiesToWinRMListenerStatus populates the provided destination WinRMListener_Status from our WinRMListener_Status
func (winRMListenerStatus *WinRMListener_Status) AssignPropertiesToWinRMListenerStatus(destination *v1alpha1api20201201storage.WinRMListener_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateUrl
	if winRMListenerStatus.CertificateUrl != nil {
		certificateUrl := *winRMListenerStatus.CertificateUrl
		destination.CertificateUrl = &certificateUrl
	} else {
		destination.CertificateUrl = nil
	}

	// Protocol
	if winRMListenerStatus.Protocol != nil {
		protocol := string(*winRMListenerStatus.Protocol)
		destination.Protocol = &protocol
	} else {
		destination.Protocol = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VirtualMachineScaleSetIpTag
type VirtualMachineScaleSetIpTag struct {
	//IpTagType: IP tag type. Example: FirstPartyUsage.
	IpTagType *string `json:"ipTagType,omitempty"`

	//Tag: IP tag associated with the public IP. Example: SQL, Storage etc.
	Tag *string `json:"tag,omitempty"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetIpTag{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetIpTag *VirtualMachineScaleSetIpTag) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetIpTag == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetIpTagARM

	// Set property ‘IpTagType’:
	if virtualMachineScaleSetIpTag.IpTagType != nil {
		ipTagType := *virtualMachineScaleSetIpTag.IpTagType
		result.IpTagType = &ipTagType
	}

	// Set property ‘Tag’:
	if virtualMachineScaleSetIpTag.Tag != nil {
		tag := *virtualMachineScaleSetIpTag.Tag
		result.Tag = &tag
	}
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetIpTag *VirtualMachineScaleSetIpTag) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIpTagARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetIpTag *VirtualMachineScaleSetIpTag) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIpTagARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIpTagARM, got %T", armInput)
	}

	// Set property ‘IpTagType’:
	if typedInput.IpTagType != nil {
		ipTagType := *typedInput.IpTagType
		virtualMachineScaleSetIpTag.IpTagType = &ipTagType
	}

	// Set property ‘Tag’:
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		virtualMachineScaleSetIpTag.Tag = &tag
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIpTag populates our VirtualMachineScaleSetIpTag from the provided source VirtualMachineScaleSetIpTag
func (virtualMachineScaleSetIpTag *VirtualMachineScaleSetIpTag) AssignPropertiesFromVirtualMachineScaleSetIpTag(source *v1alpha1api20201201storage.VirtualMachineScaleSetIpTag) error {

	// IpTagType
	if source.IpTagType != nil {
		ipTagType := *source.IpTagType
		virtualMachineScaleSetIpTag.IpTagType = &ipTagType
	} else {
		virtualMachineScaleSetIpTag.IpTagType = nil
	}

	// Tag
	if source.Tag != nil {
		tag := *source.Tag
		virtualMachineScaleSetIpTag.Tag = &tag
	} else {
		virtualMachineScaleSetIpTag.Tag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIpTag populates the provided destination VirtualMachineScaleSetIpTag from our VirtualMachineScaleSetIpTag
func (virtualMachineScaleSetIpTag *VirtualMachineScaleSetIpTag) AssignPropertiesToVirtualMachineScaleSetIpTag(destination *v1alpha1api20201201storage.VirtualMachineScaleSetIpTag) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpTagType
	if virtualMachineScaleSetIpTag.IpTagType != nil {
		ipTagType := *virtualMachineScaleSetIpTag.IpTagType
		destination.IpTagType = &ipTagType
	} else {
		destination.IpTagType = nil
	}

	// Tag
	if virtualMachineScaleSetIpTag.Tag != nil {
		tag := *virtualMachineScaleSetIpTag.Tag
		destination.Tag = &tag
	} else {
		destination.Tag = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VirtualMachineScaleSetIpTag_Status struct {
	//IpTagType: IP tag type. Example: FirstPartyUsage.
	IpTagType *string `json:"ipTagType,omitempty"`

	//Tag: IP tag associated with the public IP. Example: SQL, Storage etc.
	Tag *string `json:"tag,omitempty"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetIpTag_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetIpTagStatus *VirtualMachineScaleSetIpTag_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetIpTag_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetIpTagStatus *VirtualMachineScaleSetIpTag_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetIpTag_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetIpTag_StatusARM, got %T", armInput)
	}

	// Set property ‘IpTagType’:
	if typedInput.IpTagType != nil {
		ipTagType := *typedInput.IpTagType
		virtualMachineScaleSetIpTagStatus.IpTagType = &ipTagType
	}

	// Set property ‘Tag’:
	if typedInput.Tag != nil {
		tag := *typedInput.Tag
		virtualMachineScaleSetIpTagStatus.Tag = &tag
	}

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetIpTagStatus populates our VirtualMachineScaleSetIpTag_Status from the provided source VirtualMachineScaleSetIpTag_Status
func (virtualMachineScaleSetIpTagStatus *VirtualMachineScaleSetIpTag_Status) AssignPropertiesFromVirtualMachineScaleSetIpTagStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Status) error {

	// IpTagType
	if source.IpTagType != nil {
		ipTagType := *source.IpTagType
		virtualMachineScaleSetIpTagStatus.IpTagType = &ipTagType
	} else {
		virtualMachineScaleSetIpTagStatus.IpTagType = nil
	}

	// Tag
	if source.Tag != nil {
		tag := *source.Tag
		virtualMachineScaleSetIpTagStatus.Tag = &tag
	} else {
		virtualMachineScaleSetIpTagStatus.Tag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetIpTagStatus populates the provided destination VirtualMachineScaleSetIpTag_Status from our VirtualMachineScaleSetIpTag_Status
func (virtualMachineScaleSetIpTagStatus *VirtualMachineScaleSetIpTag_Status) AssignPropertiesToVirtualMachineScaleSetIpTagStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetIpTag_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpTagType
	if virtualMachineScaleSetIpTagStatus.IpTagType != nil {
		ipTagType := *virtualMachineScaleSetIpTagStatus.IpTagType
		destination.IpTagType = &ipTagType
	} else {
		destination.IpTagType = nil
	}

	// Tag
	if virtualMachineScaleSetIpTagStatus.Tag != nil {
		tag := *virtualMachineScaleSetIpTagStatus.Tag
		destination.Tag = &tag
	} else {
		destination.Tag = nil
	}

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from: https://schema.management.azure.com/schemas/2020-12-01/Microsoft.Compute.json#/definitions/VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
type VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings struct {
	// +kubebuilder:validation:Required
	//DomainNameLabel: The Domain name label.The concatenation of the domain name
	//label and vm index will be the domain name labels of the PublicIPAddress
	//resources that will be created
	DomainNameLabel string `json:"domainNameLabel"`
}

var _ genruntime.ARMTransformer = &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings == nil {
		return nil, nil
	}
	var result VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsARM

	// Set property ‘DomainNameLabel’:
	result.DomainNameLabel = virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings.DomainNameLabel
	return result, nil
}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsARM, got %T", armInput)
	}

	// Set property ‘DomainNameLabel’:
	virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings.DomainNameLabel = typedInput.DomainNameLabel

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings populates our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings from the provided source VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
func (virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(source *v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) error {

	// DomainNameLabel
	if source.DomainNameLabel != nil {
		virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings.DomainNameLabel = *source.DomainNameLabel
	} else {
		virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings.DomainNameLabel = ""
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings populates the provided destination VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings from our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings
func (virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings(destination *v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DomainNameLabel
	domainNameLabel := virtualMachineScaleSetPublicIPAddressConfigurationDnsSettings.DomainNameLabel
	destination.DomainNameLabel = &domainNameLabel

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

//Generated from:
type VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status struct {
	// +kubebuilder:validation:Required
	//DomainNameLabel: The Domain name label.The concatenation of the domain name
	//label and vm index will be the domain name labels of the PublicIPAddress
	//resources that will be created
	DomainNameLabel string `json:"domainNameLabel"`
}

var _ genruntime.FromARMConverter = &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status{}

// CreateEmptyARMValue returns an empty ARM value suitable for deserializing into
func (virtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) CreateEmptyARMValue() genruntime.ARMResourceStatus {
	return &VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (virtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_StatusARM, got %T", armInput)
	}

	// Set property ‘DomainNameLabel’:
	virtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus.DomainNameLabel = typedInput.DomainNameLabel

	// No error
	return nil
}

// AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus populates our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status from the provided source VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
func (virtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) AssignPropertiesFromVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus(source *v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) error {

	// DomainNameLabel
	if source.DomainNameLabel != nil {
		virtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus.DomainNameLabel = *source.DomainNameLabel
	} else {
		virtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus.DomainNameLabel = ""
	}

	// No error
	return nil
}

// AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus populates the provided destination VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status from our VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status
func (virtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus *VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) AssignPropertiesToVirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus(destination *v1alpha1api20201201storage.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettings_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DomainNameLabel
	domainNameLabel := virtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsStatus.DomainNameLabel
	destination.DomainNameLabel = &domainNameLabel

	// Update the property bag
	destination.PropertyBag = propertyBag

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"IPv4","IPv6"}
type VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesPublicIPAddressVersion string

const (
	VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesPublicIPAddressVersionIPv4 = VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesPublicIPAddressVersion("IPv4")
	VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesPublicIPAddressVersionIPv6 = VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesPublicIPAddressVersion("IPv6")
)

type VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesStatusPublicIPAddressVersion string

const (
	VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesStatusPublicIPAddressVersionIPv4 = VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesStatusPublicIPAddressVersion("IPv4")
	VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesStatusPublicIPAddressVersionIPv6 = VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesStatusPublicIPAddressVersion("IPv6")
)

// +kubebuilder:validation:Enum={"Http","Https"}
type WinRMListenerProtocol string

const (
	WinRMListenerProtocolHttp  = WinRMListenerProtocol("Http")
	WinRMListenerProtocolHttps = WinRMListenerProtocol("Https")
)

type WinRMListenerStatusProtocol string

const (
	WinRMListenerStatusProtocolHttp  = WinRMListenerStatusProtocol("Http")
	WinRMListenerStatusProtocolHttps = WinRMListenerStatusProtocol("Https")
)

func init() {
	SchemeBuilder.Register(&VirtualMachineScaleSet{}, &VirtualMachineScaleSetList{})
}
