// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230501preview

import (
	"encoding/json"
	v20220801s "github.com/Azure/azure-service-operator/v2/api/apimanagement/v1api20220801/storage"
	v20230501ps "github.com/Azure/azure-service-operator/v2/api/apimanagement/v1api20230501preview/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AdditionalLocation_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdditionalLocation to AdditionalLocation via AssignProperties_To_AdditionalLocation & AssignProperties_From_AdditionalLocation returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdditionalLocation, AdditionalLocationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdditionalLocation tests if a specific instance of AdditionalLocation can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAdditionalLocation(subject AdditionalLocation) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.AdditionalLocation
	err := copied.AssignProperties_To_AdditionalLocation(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdditionalLocation
	err = actual.AssignProperties_From_AdditionalLocation(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdditionalLocation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalLocation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalLocation, AdditionalLocationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalLocation runs a test to see if a specific instance of AdditionalLocation round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalLocation(subject AdditionalLocation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalLocation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalLocation instances for property testing - lazily instantiated by AdditionalLocationGenerator()
var additionalLocationGenerator gopter.Gen

// AdditionalLocationGenerator returns a generator of AdditionalLocation instances for property testing.
// We first initialize additionalLocationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AdditionalLocationGenerator() gopter.Gen {
	if additionalLocationGenerator != nil {
		return additionalLocationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalLocation(generators)
	additionalLocationGenerator = gen.Struct(reflect.TypeOf(AdditionalLocation{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalLocation(generators)
	AddRelatedPropertyGeneratorsForAdditionalLocation(generators)
	additionalLocationGenerator = gen.Struct(reflect.TypeOf(AdditionalLocation{}), generators)

	return additionalLocationGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalLocation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalLocation(gens map[string]gopter.Gen) {
	gens["DisableGateway"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NatGatewayState"] = gen.PtrOf(gen.OneConstOf(AdditionalLocation_NatGatewayState_Disabled, AdditionalLocation_NatGatewayState_Enabled))
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAdditionalLocation is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdditionalLocation(gens map[string]gopter.Gen) {
	gens["Sku"] = gen.PtrOf(ApiManagementServiceSkuPropertiesGenerator())
	gens["VirtualNetworkConfiguration"] = gen.PtrOf(VirtualNetworkConfigurationGenerator())
}

func Test_AdditionalLocation_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdditionalLocation_STATUS to AdditionalLocation_STATUS via AssignProperties_To_AdditionalLocation_STATUS & AssignProperties_From_AdditionalLocation_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdditionalLocation_STATUS, AdditionalLocation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdditionalLocation_STATUS tests if a specific instance of AdditionalLocation_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAdditionalLocation_STATUS(subject AdditionalLocation_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.AdditionalLocation_STATUS
	err := copied.AssignProperties_To_AdditionalLocation_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdditionalLocation_STATUS
	err = actual.AssignProperties_From_AdditionalLocation_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdditionalLocation_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalLocation_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalLocation_STATUS, AdditionalLocation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalLocation_STATUS runs a test to see if a specific instance of AdditionalLocation_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalLocation_STATUS(subject AdditionalLocation_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalLocation_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalLocation_STATUS instances for property testing - lazily instantiated by
// AdditionalLocation_STATUSGenerator()
var additionalLocation_STATUSGenerator gopter.Gen

// AdditionalLocation_STATUSGenerator returns a generator of AdditionalLocation_STATUS instances for property testing.
// We first initialize additionalLocation_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AdditionalLocation_STATUSGenerator() gopter.Gen {
	if additionalLocation_STATUSGenerator != nil {
		return additionalLocation_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalLocation_STATUS(generators)
	additionalLocation_STATUSGenerator = gen.Struct(reflect.TypeOf(AdditionalLocation_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalLocation_STATUS(generators)
	AddRelatedPropertyGeneratorsForAdditionalLocation_STATUS(generators)
	additionalLocation_STATUSGenerator = gen.Struct(reflect.TypeOf(AdditionalLocation_STATUS{}), generators)

	return additionalLocation_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalLocation_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalLocation_STATUS(gens map[string]gopter.Gen) {
	gens["DisableGateway"] = gen.PtrOf(gen.Bool())
	gens["GatewayRegionalUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NatGatewayState"] = gen.PtrOf(gen.OneConstOf(AdditionalLocation_NatGatewayState_STATUS_Disabled, AdditionalLocation_NatGatewayState_STATUS_Enabled))
	gens["OutboundPublicIPAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["PlatformVersion"] = gen.PtrOf(gen.OneConstOf(
		AdditionalLocation_PlatformVersion_STATUS_Mtv1,
		AdditionalLocation_PlatformVersion_STATUS_Stv1,
		AdditionalLocation_PlatformVersion_STATUS_Stv2,
		AdditionalLocation_PlatformVersion_STATUS_Stv21,
		AdditionalLocation_PlatformVersion_STATUS_Undetermined))
	gens["PrivateIPAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["PublicIPAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["PublicIpAddressId"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAdditionalLocation_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdditionalLocation_STATUS(gens map[string]gopter.Gen) {
	gens["Sku"] = gen.PtrOf(ApiManagementServiceSkuProperties_STATUSGenerator())
	gens["VirtualNetworkConfiguration"] = gen.PtrOf(VirtualNetworkConfiguration_STATUSGenerator())
}

func Test_ApiManagementServiceIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiManagementServiceIdentity to ApiManagementServiceIdentity via AssignProperties_To_ApiManagementServiceIdentity & AssignProperties_From_ApiManagementServiceIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiManagementServiceIdentity, ApiManagementServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiManagementServiceIdentity tests if a specific instance of ApiManagementServiceIdentity can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApiManagementServiceIdentity(subject ApiManagementServiceIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.ApiManagementServiceIdentity
	err := copied.AssignProperties_To_ApiManagementServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiManagementServiceIdentity
	err = actual.AssignProperties_From_ApiManagementServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiManagementServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementServiceIdentity, ApiManagementServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementServiceIdentity runs a test to see if a specific instance of ApiManagementServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementServiceIdentity(subject ApiManagementServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementServiceIdentity instances for property testing - lazily instantiated by
// ApiManagementServiceIdentityGenerator()
var apiManagementServiceIdentityGenerator gopter.Gen

// ApiManagementServiceIdentityGenerator returns a generator of ApiManagementServiceIdentity instances for property testing.
// We first initialize apiManagementServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiManagementServiceIdentityGenerator() gopter.Gen {
	if apiManagementServiceIdentityGenerator != nil {
		return apiManagementServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceIdentity(generators)
	apiManagementServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForApiManagementServiceIdentity(generators)
	apiManagementServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceIdentity{}), generators)

	return apiManagementServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ApiManagementServiceIdentity_Type_None,
		ApiManagementServiceIdentity_Type_SystemAssigned,
		ApiManagementServiceIdentity_Type_SystemAssignedUserAssigned,
		ApiManagementServiceIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForApiManagementServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiManagementServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_ApiManagementServiceIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiManagementServiceIdentity_STATUS to ApiManagementServiceIdentity_STATUS via AssignProperties_To_ApiManagementServiceIdentity_STATUS & AssignProperties_From_ApiManagementServiceIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiManagementServiceIdentity_STATUS, ApiManagementServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiManagementServiceIdentity_STATUS tests if a specific instance of ApiManagementServiceIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApiManagementServiceIdentity_STATUS(subject ApiManagementServiceIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.ApiManagementServiceIdentity_STATUS
	err := copied.AssignProperties_To_ApiManagementServiceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiManagementServiceIdentity_STATUS
	err = actual.AssignProperties_From_ApiManagementServiceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiManagementServiceIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementServiceIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementServiceIdentity_STATUS, ApiManagementServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementServiceIdentity_STATUS runs a test to see if a specific instance of ApiManagementServiceIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementServiceIdentity_STATUS(subject ApiManagementServiceIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementServiceIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementServiceIdentity_STATUS instances for property testing - lazily instantiated by
// ApiManagementServiceIdentity_STATUSGenerator()
var apiManagementServiceIdentity_STATUSGenerator gopter.Gen

// ApiManagementServiceIdentity_STATUSGenerator returns a generator of ApiManagementServiceIdentity_STATUS instances for property testing.
// We first initialize apiManagementServiceIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiManagementServiceIdentity_STATUSGenerator() gopter.Gen {
	if apiManagementServiceIdentity_STATUSGenerator != nil {
		return apiManagementServiceIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceIdentity_STATUS(generators)
	apiManagementServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForApiManagementServiceIdentity_STATUS(generators)
	apiManagementServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceIdentity_STATUS{}), generators)

	return apiManagementServiceIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementServiceIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ApiManagementServiceIdentity_Type_STATUS_None,
		ApiManagementServiceIdentity_Type_STATUS_SystemAssigned,
		ApiManagementServiceIdentity_Type_STATUS_SystemAssignedUserAssigned,
		ApiManagementServiceIdentity_Type_STATUS_UserAssigned))
}

// AddRelatedPropertyGeneratorsForApiManagementServiceIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiManagementServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserIdentityProperties_STATUSGenerator())
}

func Test_ApiManagementServiceSkuProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiManagementServiceSkuProperties to ApiManagementServiceSkuProperties via AssignProperties_To_ApiManagementServiceSkuProperties & AssignProperties_From_ApiManagementServiceSkuProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiManagementServiceSkuProperties, ApiManagementServiceSkuPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiManagementServiceSkuProperties tests if a specific instance of ApiManagementServiceSkuProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApiManagementServiceSkuProperties(subject ApiManagementServiceSkuProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.ApiManagementServiceSkuProperties
	err := copied.AssignProperties_To_ApiManagementServiceSkuProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiManagementServiceSkuProperties
	err = actual.AssignProperties_From_ApiManagementServiceSkuProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiManagementServiceSkuProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementServiceSkuProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementServiceSkuProperties, ApiManagementServiceSkuPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementServiceSkuProperties runs a test to see if a specific instance of ApiManagementServiceSkuProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementServiceSkuProperties(subject ApiManagementServiceSkuProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementServiceSkuProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementServiceSkuProperties instances for property testing - lazily instantiated by
// ApiManagementServiceSkuPropertiesGenerator()
var apiManagementServiceSkuPropertiesGenerator gopter.Gen

// ApiManagementServiceSkuPropertiesGenerator returns a generator of ApiManagementServiceSkuProperties instances for property testing.
func ApiManagementServiceSkuPropertiesGenerator() gopter.Gen {
	if apiManagementServiceSkuPropertiesGenerator != nil {
		return apiManagementServiceSkuPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties(generators)
	apiManagementServiceSkuPropertiesGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceSkuProperties{}), generators)

	return apiManagementServiceSkuPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		ApiManagementServiceSkuProperties_Name_Basic,
		ApiManagementServiceSkuProperties_Name_BasicV2,
		ApiManagementServiceSkuProperties_Name_Consumption,
		ApiManagementServiceSkuProperties_Name_Developer,
		ApiManagementServiceSkuProperties_Name_Isolated,
		ApiManagementServiceSkuProperties_Name_Premium,
		ApiManagementServiceSkuProperties_Name_Standard,
		ApiManagementServiceSkuProperties_Name_StandardV2))
}

func Test_ApiManagementServiceSkuProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiManagementServiceSkuProperties_STATUS to ApiManagementServiceSkuProperties_STATUS via AssignProperties_To_ApiManagementServiceSkuProperties_STATUS & AssignProperties_From_ApiManagementServiceSkuProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiManagementServiceSkuProperties_STATUS, ApiManagementServiceSkuProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiManagementServiceSkuProperties_STATUS tests if a specific instance of ApiManagementServiceSkuProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApiManagementServiceSkuProperties_STATUS(subject ApiManagementServiceSkuProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.ApiManagementServiceSkuProperties_STATUS
	err := copied.AssignProperties_To_ApiManagementServiceSkuProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiManagementServiceSkuProperties_STATUS
	err = actual.AssignProperties_From_ApiManagementServiceSkuProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiManagementServiceSkuProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementServiceSkuProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementServiceSkuProperties_STATUS, ApiManagementServiceSkuProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementServiceSkuProperties_STATUS runs a test to see if a specific instance of ApiManagementServiceSkuProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementServiceSkuProperties_STATUS(subject ApiManagementServiceSkuProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementServiceSkuProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementServiceSkuProperties_STATUS instances for property testing - lazily instantiated by
// ApiManagementServiceSkuProperties_STATUSGenerator()
var apiManagementServiceSkuProperties_STATUSGenerator gopter.Gen

// ApiManagementServiceSkuProperties_STATUSGenerator returns a generator of ApiManagementServiceSkuProperties_STATUS instances for property testing.
func ApiManagementServiceSkuProperties_STATUSGenerator() gopter.Gen {
	if apiManagementServiceSkuProperties_STATUSGenerator != nil {
		return apiManagementServiceSkuProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties_STATUS(generators)
	apiManagementServiceSkuProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceSkuProperties_STATUS{}), generators)

	return apiManagementServiceSkuProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		ApiManagementServiceSkuProperties_Name_STATUS_Basic,
		ApiManagementServiceSkuProperties_Name_STATUS_BasicV2,
		ApiManagementServiceSkuProperties_Name_STATUS_Consumption,
		ApiManagementServiceSkuProperties_Name_STATUS_Developer,
		ApiManagementServiceSkuProperties_Name_STATUS_Isolated,
		ApiManagementServiceSkuProperties_Name_STATUS_Premium,
		ApiManagementServiceSkuProperties_Name_STATUS_Standard,
		ApiManagementServiceSkuProperties_Name_STATUS_StandardV2))
}

func Test_ApiVersionConstraint_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiVersionConstraint to ApiVersionConstraint via AssignProperties_To_ApiVersionConstraint & AssignProperties_From_ApiVersionConstraint returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiVersionConstraint, ApiVersionConstraintGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiVersionConstraint tests if a specific instance of ApiVersionConstraint can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApiVersionConstraint(subject ApiVersionConstraint) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.ApiVersionConstraint
	err := copied.AssignProperties_To_ApiVersionConstraint(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiVersionConstraint
	err = actual.AssignProperties_From_ApiVersionConstraint(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiVersionConstraint_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiVersionConstraint via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiVersionConstraint, ApiVersionConstraintGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiVersionConstraint runs a test to see if a specific instance of ApiVersionConstraint round trips to JSON and back losslessly
func RunJSONSerializationTestForApiVersionConstraint(subject ApiVersionConstraint) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiVersionConstraint
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiVersionConstraint instances for property testing - lazily instantiated by
// ApiVersionConstraintGenerator()
var apiVersionConstraintGenerator gopter.Gen

// ApiVersionConstraintGenerator returns a generator of ApiVersionConstraint instances for property testing.
func ApiVersionConstraintGenerator() gopter.Gen {
	if apiVersionConstraintGenerator != nil {
		return apiVersionConstraintGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiVersionConstraint(generators)
	apiVersionConstraintGenerator = gen.Struct(reflect.TypeOf(ApiVersionConstraint{}), generators)

	return apiVersionConstraintGenerator
}

// AddIndependentPropertyGeneratorsForApiVersionConstraint is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiVersionConstraint(gens map[string]gopter.Gen) {
	gens["MinApiVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiVersionConstraint_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiVersionConstraint_STATUS to ApiVersionConstraint_STATUS via AssignProperties_To_ApiVersionConstraint_STATUS & AssignProperties_From_ApiVersionConstraint_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiVersionConstraint_STATUS, ApiVersionConstraint_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiVersionConstraint_STATUS tests if a specific instance of ApiVersionConstraint_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApiVersionConstraint_STATUS(subject ApiVersionConstraint_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.ApiVersionConstraint_STATUS
	err := copied.AssignProperties_To_ApiVersionConstraint_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiVersionConstraint_STATUS
	err = actual.AssignProperties_From_ApiVersionConstraint_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiVersionConstraint_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiVersionConstraint_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiVersionConstraint_STATUS, ApiVersionConstraint_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiVersionConstraint_STATUS runs a test to see if a specific instance of ApiVersionConstraint_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApiVersionConstraint_STATUS(subject ApiVersionConstraint_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiVersionConstraint_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiVersionConstraint_STATUS instances for property testing - lazily instantiated by
// ApiVersionConstraint_STATUSGenerator()
var apiVersionConstraint_STATUSGenerator gopter.Gen

// ApiVersionConstraint_STATUSGenerator returns a generator of ApiVersionConstraint_STATUS instances for property testing.
func ApiVersionConstraint_STATUSGenerator() gopter.Gen {
	if apiVersionConstraint_STATUSGenerator != nil {
		return apiVersionConstraint_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiVersionConstraint_STATUS(generators)
	apiVersionConstraint_STATUSGenerator = gen.Struct(reflect.TypeOf(ApiVersionConstraint_STATUS{}), generators)

	return apiVersionConstraint_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForApiVersionConstraint_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiVersionConstraint_STATUS(gens map[string]gopter.Gen) {
	gens["MinApiVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_ArmIdWrapper_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ArmIdWrapper_STATUS to ArmIdWrapper_STATUS via AssignProperties_To_ArmIdWrapper_STATUS & AssignProperties_From_ArmIdWrapper_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForArmIdWrapper_STATUS, ArmIdWrapper_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForArmIdWrapper_STATUS tests if a specific instance of ArmIdWrapper_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForArmIdWrapper_STATUS(subject ArmIdWrapper_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.ArmIdWrapper_STATUS
	err := copied.AssignProperties_To_ArmIdWrapper_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ArmIdWrapper_STATUS
	err = actual.AssignProperties_From_ArmIdWrapper_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ArmIdWrapper_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ArmIdWrapper_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForArmIdWrapper_STATUS, ArmIdWrapper_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForArmIdWrapper_STATUS runs a test to see if a specific instance of ArmIdWrapper_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForArmIdWrapper_STATUS(subject ArmIdWrapper_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ArmIdWrapper_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ArmIdWrapper_STATUS instances for property testing - lazily instantiated by
// ArmIdWrapper_STATUSGenerator()
var armIdWrapper_STATUSGenerator gopter.Gen

// ArmIdWrapper_STATUSGenerator returns a generator of ArmIdWrapper_STATUS instances for property testing.
func ArmIdWrapper_STATUSGenerator() gopter.Gen {
	if armIdWrapper_STATUSGenerator != nil {
		return armIdWrapper_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmIdWrapper_STATUS(generators)
	armIdWrapper_STATUSGenerator = gen.Struct(reflect.TypeOf(ArmIdWrapper_STATUS{}), generators)

	return armIdWrapper_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForArmIdWrapper_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForArmIdWrapper_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_CertificateConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CertificateConfiguration to CertificateConfiguration via AssignProperties_To_CertificateConfiguration & AssignProperties_From_CertificateConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForCertificateConfiguration, CertificateConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCertificateConfiguration tests if a specific instance of CertificateConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCertificateConfiguration(subject CertificateConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.CertificateConfiguration
	err := copied.AssignProperties_To_CertificateConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CertificateConfiguration
	err = actual.AssignProperties_From_CertificateConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CertificateConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CertificateConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCertificateConfiguration, CertificateConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCertificateConfiguration runs a test to see if a specific instance of CertificateConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForCertificateConfiguration(subject CertificateConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CertificateConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CertificateConfiguration instances for property testing - lazily instantiated by
// CertificateConfigurationGenerator()
var certificateConfigurationGenerator gopter.Gen

// CertificateConfigurationGenerator returns a generator of CertificateConfiguration instances for property testing.
// We first initialize certificateConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CertificateConfigurationGenerator() gopter.Gen {
	if certificateConfigurationGenerator != nil {
		return certificateConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateConfiguration(generators)
	certificateConfigurationGenerator = gen.Struct(reflect.TypeOf(CertificateConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateConfiguration(generators)
	AddRelatedPropertyGeneratorsForCertificateConfiguration(generators)
	certificateConfigurationGenerator = gen.Struct(reflect.TypeOf(CertificateConfiguration{}), generators)

	return certificateConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForCertificateConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCertificateConfiguration(gens map[string]gopter.Gen) {
	gens["EncodedCertificate"] = gen.PtrOf(gen.AlphaString())
	gens["StoreName"] = gen.PtrOf(gen.OneConstOf(CertificateConfiguration_StoreName_CertificateAuthority, CertificateConfiguration_StoreName_Root))
}

// AddRelatedPropertyGeneratorsForCertificateConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCertificateConfiguration(gens map[string]gopter.Gen) {
	gens["Certificate"] = gen.PtrOf(CertificateInformationGenerator())
}

func Test_CertificateConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CertificateConfiguration_STATUS to CertificateConfiguration_STATUS via AssignProperties_To_CertificateConfiguration_STATUS & AssignProperties_From_CertificateConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCertificateConfiguration_STATUS, CertificateConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCertificateConfiguration_STATUS tests if a specific instance of CertificateConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCertificateConfiguration_STATUS(subject CertificateConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.CertificateConfiguration_STATUS
	err := copied.AssignProperties_To_CertificateConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CertificateConfiguration_STATUS
	err = actual.AssignProperties_From_CertificateConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CertificateConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CertificateConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCertificateConfiguration_STATUS, CertificateConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCertificateConfiguration_STATUS runs a test to see if a specific instance of CertificateConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCertificateConfiguration_STATUS(subject CertificateConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CertificateConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CertificateConfiguration_STATUS instances for property testing - lazily instantiated by
// CertificateConfiguration_STATUSGenerator()
var certificateConfiguration_STATUSGenerator gopter.Gen

// CertificateConfiguration_STATUSGenerator returns a generator of CertificateConfiguration_STATUS instances for property testing.
// We first initialize certificateConfiguration_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CertificateConfiguration_STATUSGenerator() gopter.Gen {
	if certificateConfiguration_STATUSGenerator != nil {
		return certificateConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateConfiguration_STATUS(generators)
	certificateConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(CertificateConfiguration_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateConfiguration_STATUS(generators)
	AddRelatedPropertyGeneratorsForCertificateConfiguration_STATUS(generators)
	certificateConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(CertificateConfiguration_STATUS{}), generators)

	return certificateConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCertificateConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCertificateConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["EncodedCertificate"] = gen.PtrOf(gen.AlphaString())
	gens["StoreName"] = gen.PtrOf(gen.OneConstOf(CertificateConfiguration_StoreName_STATUS_CertificateAuthority, CertificateConfiguration_StoreName_STATUS_Root))
}

// AddRelatedPropertyGeneratorsForCertificateConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCertificateConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["Certificate"] = gen.PtrOf(CertificateInformation_STATUSGenerator())
}

func Test_CertificateInformation_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CertificateInformation to CertificateInformation via AssignProperties_To_CertificateInformation & AssignProperties_From_CertificateInformation returns original",
		prop.ForAll(RunPropertyAssignmentTestForCertificateInformation, CertificateInformationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCertificateInformation tests if a specific instance of CertificateInformation can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCertificateInformation(subject CertificateInformation) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.CertificateInformation
	err := copied.AssignProperties_To_CertificateInformation(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CertificateInformation
	err = actual.AssignProperties_From_CertificateInformation(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CertificateInformation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CertificateInformation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCertificateInformation, CertificateInformationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCertificateInformation runs a test to see if a specific instance of CertificateInformation round trips to JSON and back losslessly
func RunJSONSerializationTestForCertificateInformation(subject CertificateInformation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CertificateInformation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CertificateInformation instances for property testing - lazily instantiated by
// CertificateInformationGenerator()
var certificateInformationGenerator gopter.Gen

// CertificateInformationGenerator returns a generator of CertificateInformation instances for property testing.
func CertificateInformationGenerator() gopter.Gen {
	if certificateInformationGenerator != nil {
		return certificateInformationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateInformation(generators)
	certificateInformationGenerator = gen.Struct(reflect.TypeOf(CertificateInformation{}), generators)

	return certificateInformationGenerator
}

// AddIndependentPropertyGeneratorsForCertificateInformation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCertificateInformation(gens map[string]gopter.Gen) {
	gens["Expiry"] = gen.PtrOf(gen.AlphaString())
	gens["Subject"] = gen.PtrOf(gen.AlphaString())
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
}

func Test_CertificateInformation_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CertificateInformation_STATUS to CertificateInformation_STATUS via AssignProperties_To_CertificateInformation_STATUS & AssignProperties_From_CertificateInformation_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCertificateInformation_STATUS, CertificateInformation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCertificateInformation_STATUS tests if a specific instance of CertificateInformation_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCertificateInformation_STATUS(subject CertificateInformation_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.CertificateInformation_STATUS
	err := copied.AssignProperties_To_CertificateInformation_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CertificateInformation_STATUS
	err = actual.AssignProperties_From_CertificateInformation_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CertificateInformation_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CertificateInformation_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCertificateInformation_STATUS, CertificateInformation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCertificateInformation_STATUS runs a test to see if a specific instance of CertificateInformation_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCertificateInformation_STATUS(subject CertificateInformation_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CertificateInformation_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CertificateInformation_STATUS instances for property testing - lazily instantiated by
// CertificateInformation_STATUSGenerator()
var certificateInformation_STATUSGenerator gopter.Gen

// CertificateInformation_STATUSGenerator returns a generator of CertificateInformation_STATUS instances for property testing.
func CertificateInformation_STATUSGenerator() gopter.Gen {
	if certificateInformation_STATUSGenerator != nil {
		return certificateInformation_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateInformation_STATUS(generators)
	certificateInformation_STATUSGenerator = gen.Struct(reflect.TypeOf(CertificateInformation_STATUS{}), generators)

	return certificateInformation_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCertificateInformation_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCertificateInformation_STATUS(gens map[string]gopter.Gen) {
	gens["Expiry"] = gen.PtrOf(gen.AlphaString())
	gens["Subject"] = gen.PtrOf(gen.AlphaString())
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
}

func Test_ConfigurationApi_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConfigurationApi to ConfigurationApi via AssignProperties_To_ConfigurationApi & AssignProperties_From_ConfigurationApi returns original",
		prop.ForAll(RunPropertyAssignmentTestForConfigurationApi, ConfigurationApiGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConfigurationApi tests if a specific instance of ConfigurationApi can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForConfigurationApi(subject ConfigurationApi) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.ConfigurationApi
	err := copied.AssignProperties_To_ConfigurationApi(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConfigurationApi
	err = actual.AssignProperties_From_ConfigurationApi(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConfigurationApi_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConfigurationApi via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConfigurationApi, ConfigurationApiGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConfigurationApi runs a test to see if a specific instance of ConfigurationApi round trips to JSON and back losslessly
func RunJSONSerializationTestForConfigurationApi(subject ConfigurationApi) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConfigurationApi
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConfigurationApi instances for property testing - lazily instantiated by ConfigurationApiGenerator()
var configurationApiGenerator gopter.Gen

// ConfigurationApiGenerator returns a generator of ConfigurationApi instances for property testing.
func ConfigurationApiGenerator() gopter.Gen {
	if configurationApiGenerator != nil {
		return configurationApiGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConfigurationApi(generators)
	configurationApiGenerator = gen.Struct(reflect.TypeOf(ConfigurationApi{}), generators)

	return configurationApiGenerator
}

// AddIndependentPropertyGeneratorsForConfigurationApi is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConfigurationApi(gens map[string]gopter.Gen) {
	gens["LegacyApi"] = gen.PtrOf(gen.OneConstOf(ConfigurationApi_LegacyApi_Disabled, ConfigurationApi_LegacyApi_Enabled))
}

func Test_ConfigurationApi_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConfigurationApi_STATUS to ConfigurationApi_STATUS via AssignProperties_To_ConfigurationApi_STATUS & AssignProperties_From_ConfigurationApi_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForConfigurationApi_STATUS, ConfigurationApi_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConfigurationApi_STATUS tests if a specific instance of ConfigurationApi_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForConfigurationApi_STATUS(subject ConfigurationApi_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.ConfigurationApi_STATUS
	err := copied.AssignProperties_To_ConfigurationApi_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConfigurationApi_STATUS
	err = actual.AssignProperties_From_ConfigurationApi_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConfigurationApi_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConfigurationApi_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConfigurationApi_STATUS, ConfigurationApi_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConfigurationApi_STATUS runs a test to see if a specific instance of ConfigurationApi_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForConfigurationApi_STATUS(subject ConfigurationApi_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConfigurationApi_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConfigurationApi_STATUS instances for property testing - lazily instantiated by
// ConfigurationApi_STATUSGenerator()
var configurationApi_STATUSGenerator gopter.Gen

// ConfigurationApi_STATUSGenerator returns a generator of ConfigurationApi_STATUS instances for property testing.
func ConfigurationApi_STATUSGenerator() gopter.Gen {
	if configurationApi_STATUSGenerator != nil {
		return configurationApi_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConfigurationApi_STATUS(generators)
	configurationApi_STATUSGenerator = gen.Struct(reflect.TypeOf(ConfigurationApi_STATUS{}), generators)

	return configurationApi_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForConfigurationApi_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConfigurationApi_STATUS(gens map[string]gopter.Gen) {
	gens["LegacyApi"] = gen.PtrOf(gen.OneConstOf(ConfigurationApi_LegacyApi_STATUS_Disabled, ConfigurationApi_LegacyApi_STATUS_Enabled))
}

func Test_HostnameConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HostnameConfiguration to HostnameConfiguration via AssignProperties_To_HostnameConfiguration & AssignProperties_From_HostnameConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForHostnameConfiguration, HostnameConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHostnameConfiguration tests if a specific instance of HostnameConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHostnameConfiguration(subject HostnameConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.HostnameConfiguration
	err := copied.AssignProperties_To_HostnameConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HostnameConfiguration
	err = actual.AssignProperties_From_HostnameConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HostnameConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostnameConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostnameConfiguration, HostnameConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostnameConfiguration runs a test to see if a specific instance of HostnameConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForHostnameConfiguration(subject HostnameConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostnameConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostnameConfiguration instances for property testing - lazily instantiated by
// HostnameConfigurationGenerator()
var hostnameConfigurationGenerator gopter.Gen

// HostnameConfigurationGenerator returns a generator of HostnameConfiguration instances for property testing.
// We first initialize hostnameConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HostnameConfigurationGenerator() gopter.Gen {
	if hostnameConfigurationGenerator != nil {
		return hostnameConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostnameConfiguration(generators)
	hostnameConfigurationGenerator = gen.Struct(reflect.TypeOf(HostnameConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostnameConfiguration(generators)
	AddRelatedPropertyGeneratorsForHostnameConfiguration(generators)
	hostnameConfigurationGenerator = gen.Struct(reflect.TypeOf(HostnameConfiguration{}), generators)

	return hostnameConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForHostnameConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostnameConfiguration(gens map[string]gopter.Gen) {
	gens["CertificateSource"] = gen.PtrOf(gen.OneConstOf(
		HostnameConfiguration_CertificateSource_BuiltIn,
		HostnameConfiguration_CertificateSource_Custom,
		HostnameConfiguration_CertificateSource_KeyVault,
		HostnameConfiguration_CertificateSource_Managed))
	gens["CertificateStatus"] = gen.PtrOf(gen.OneConstOf(HostnameConfiguration_CertificateStatus_Completed, HostnameConfiguration_CertificateStatus_Failed, HostnameConfiguration_CertificateStatus_InProgress))
	gens["DefaultSslBinding"] = gen.PtrOf(gen.Bool())
	gens["EncodedCertificate"] = gen.PtrOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultId"] = gen.PtrOf(gen.AlphaString())
	gens["NegotiateClientCertificate"] = gen.PtrOf(gen.Bool())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		HostnameConfiguration_Type_ConfigurationApi,
		HostnameConfiguration_Type_DeveloperPortal,
		HostnameConfiguration_Type_Management,
		HostnameConfiguration_Type_Portal,
		HostnameConfiguration_Type_Proxy,
		HostnameConfiguration_Type_Scm))
}

// AddRelatedPropertyGeneratorsForHostnameConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHostnameConfiguration(gens map[string]gopter.Gen) {
	gens["Certificate"] = gen.PtrOf(CertificateInformationGenerator())
}

func Test_HostnameConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HostnameConfiguration_STATUS to HostnameConfiguration_STATUS via AssignProperties_To_HostnameConfiguration_STATUS & AssignProperties_From_HostnameConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHostnameConfiguration_STATUS, HostnameConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHostnameConfiguration_STATUS tests if a specific instance of HostnameConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHostnameConfiguration_STATUS(subject HostnameConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.HostnameConfiguration_STATUS
	err := copied.AssignProperties_To_HostnameConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HostnameConfiguration_STATUS
	err = actual.AssignProperties_From_HostnameConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HostnameConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostnameConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostnameConfiguration_STATUS, HostnameConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostnameConfiguration_STATUS runs a test to see if a specific instance of HostnameConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHostnameConfiguration_STATUS(subject HostnameConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostnameConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostnameConfiguration_STATUS instances for property testing - lazily instantiated by
// HostnameConfiguration_STATUSGenerator()
var hostnameConfiguration_STATUSGenerator gopter.Gen

// HostnameConfiguration_STATUSGenerator returns a generator of HostnameConfiguration_STATUS instances for property testing.
// We first initialize hostnameConfiguration_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HostnameConfiguration_STATUSGenerator() gopter.Gen {
	if hostnameConfiguration_STATUSGenerator != nil {
		return hostnameConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostnameConfiguration_STATUS(generators)
	hostnameConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(HostnameConfiguration_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostnameConfiguration_STATUS(generators)
	AddRelatedPropertyGeneratorsForHostnameConfiguration_STATUS(generators)
	hostnameConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(HostnameConfiguration_STATUS{}), generators)

	return hostnameConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHostnameConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostnameConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["CertificateSource"] = gen.PtrOf(gen.OneConstOf(
		HostnameConfiguration_CertificateSource_STATUS_BuiltIn,
		HostnameConfiguration_CertificateSource_STATUS_Custom,
		HostnameConfiguration_CertificateSource_STATUS_KeyVault,
		HostnameConfiguration_CertificateSource_STATUS_Managed))
	gens["CertificateStatus"] = gen.PtrOf(gen.OneConstOf(HostnameConfiguration_CertificateStatus_STATUS_Completed, HostnameConfiguration_CertificateStatus_STATUS_Failed, HostnameConfiguration_CertificateStatus_STATUS_InProgress))
	gens["DefaultSslBinding"] = gen.PtrOf(gen.Bool())
	gens["EncodedCertificate"] = gen.PtrOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultId"] = gen.PtrOf(gen.AlphaString())
	gens["NegotiateClientCertificate"] = gen.PtrOf(gen.Bool())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		HostnameConfiguration_Type_STATUS_ConfigurationApi,
		HostnameConfiguration_Type_STATUS_DeveloperPortal,
		HostnameConfiguration_Type_STATUS_Management,
		HostnameConfiguration_Type_STATUS_Portal,
		HostnameConfiguration_Type_STATUS_Proxy,
		HostnameConfiguration_Type_STATUS_Scm))
}

// AddRelatedPropertyGeneratorsForHostnameConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHostnameConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["Certificate"] = gen.PtrOf(CertificateInformation_STATUSGenerator())
}

func Test_PrivateLinkServiceConnectionState_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateLinkServiceConnectionState_STATUS to PrivateLinkServiceConnectionState_STATUS via AssignProperties_To_PrivateLinkServiceConnectionState_STATUS & AssignProperties_From_PrivateLinkServiceConnectionState_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateLinkServiceConnectionState_STATUS, PrivateLinkServiceConnectionState_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateLinkServiceConnectionState_STATUS tests if a specific instance of PrivateLinkServiceConnectionState_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPrivateLinkServiceConnectionState_STATUS(subject PrivateLinkServiceConnectionState_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.PrivateLinkServiceConnectionState_STATUS
	err := copied.AssignProperties_To_PrivateLinkServiceConnectionState_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateLinkServiceConnectionState_STATUS
	err = actual.AssignProperties_From_PrivateLinkServiceConnectionState_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateLinkServiceConnectionState_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceConnectionState_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceConnectionState_STATUS, PrivateLinkServiceConnectionState_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceConnectionState_STATUS runs a test to see if a specific instance of PrivateLinkServiceConnectionState_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceConnectionState_STATUS(subject PrivateLinkServiceConnectionState_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceConnectionState_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceConnectionState_STATUS instances for property testing - lazily instantiated by
// PrivateLinkServiceConnectionState_STATUSGenerator()
var privateLinkServiceConnectionState_STATUSGenerator gopter.Gen

// PrivateLinkServiceConnectionState_STATUSGenerator returns a generator of PrivateLinkServiceConnectionState_STATUS instances for property testing.
func PrivateLinkServiceConnectionState_STATUSGenerator() gopter.Gen {
	if privateLinkServiceConnectionState_STATUSGenerator != nil {
		return privateLinkServiceConnectionState_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionState_STATUS(generators)
	privateLinkServiceConnectionState_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceConnectionState_STATUS{}), generators)

	return privateLinkServiceConnectionState_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionState_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionState_STATUS(gens map[string]gopter.Gen) {
	gens["ActionsRequired"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(PrivateEndpointServiceConnectionStatus_STATUS_Approved, PrivateEndpointServiceConnectionStatus_STATUS_Pending, PrivateEndpointServiceConnectionStatus_STATUS_Rejected))
}

func Test_RemotePrivateEndpointConnectionWrapper_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RemotePrivateEndpointConnectionWrapper_STATUS to RemotePrivateEndpointConnectionWrapper_STATUS via AssignProperties_To_RemotePrivateEndpointConnectionWrapper_STATUS & AssignProperties_From_RemotePrivateEndpointConnectionWrapper_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRemotePrivateEndpointConnectionWrapper_STATUS, RemotePrivateEndpointConnectionWrapper_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRemotePrivateEndpointConnectionWrapper_STATUS tests if a specific instance of RemotePrivateEndpointConnectionWrapper_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForRemotePrivateEndpointConnectionWrapper_STATUS(subject RemotePrivateEndpointConnectionWrapper_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.RemotePrivateEndpointConnectionWrapper_STATUS
	err := copied.AssignProperties_To_RemotePrivateEndpointConnectionWrapper_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RemotePrivateEndpointConnectionWrapper_STATUS
	err = actual.AssignProperties_From_RemotePrivateEndpointConnectionWrapper_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RemotePrivateEndpointConnectionWrapper_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RemotePrivateEndpointConnectionWrapper_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRemotePrivateEndpointConnectionWrapper_STATUS, RemotePrivateEndpointConnectionWrapper_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRemotePrivateEndpointConnectionWrapper_STATUS runs a test to see if a specific instance of RemotePrivateEndpointConnectionWrapper_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRemotePrivateEndpointConnectionWrapper_STATUS(subject RemotePrivateEndpointConnectionWrapper_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RemotePrivateEndpointConnectionWrapper_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RemotePrivateEndpointConnectionWrapper_STATUS instances for property testing - lazily instantiated by
// RemotePrivateEndpointConnectionWrapper_STATUSGenerator()
var remotePrivateEndpointConnectionWrapper_STATUSGenerator gopter.Gen

// RemotePrivateEndpointConnectionWrapper_STATUSGenerator returns a generator of RemotePrivateEndpointConnectionWrapper_STATUS instances for property testing.
// We first initialize remotePrivateEndpointConnectionWrapper_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RemotePrivateEndpointConnectionWrapper_STATUSGenerator() gopter.Gen {
	if remotePrivateEndpointConnectionWrapper_STATUSGenerator != nil {
		return remotePrivateEndpointConnectionWrapper_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRemotePrivateEndpointConnectionWrapper_STATUS(generators)
	remotePrivateEndpointConnectionWrapper_STATUSGenerator = gen.Struct(reflect.TypeOf(RemotePrivateEndpointConnectionWrapper_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRemotePrivateEndpointConnectionWrapper_STATUS(generators)
	AddRelatedPropertyGeneratorsForRemotePrivateEndpointConnectionWrapper_STATUS(generators)
	remotePrivateEndpointConnectionWrapper_STATUSGenerator = gen.Struct(reflect.TypeOf(RemotePrivateEndpointConnectionWrapper_STATUS{}), generators)

	return remotePrivateEndpointConnectionWrapper_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRemotePrivateEndpointConnectionWrapper_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRemotePrivateEndpointConnectionWrapper_STATUS(gens map[string]gopter.Gen) {
	gens["GroupIds"] = gen.SliceOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRemotePrivateEndpointConnectionWrapper_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRemotePrivateEndpointConnectionWrapper_STATUS(gens map[string]gopter.Gen) {
	gens["PrivateEndpoint"] = gen.PtrOf(ArmIdWrapper_STATUSGenerator())
	gens["PrivateLinkServiceConnectionState"] = gen.PtrOf(PrivateLinkServiceConnectionState_STATUSGenerator())
}

func Test_Service_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Service to hub returns original",
		prop.ForAll(RunResourceConversionTestForService, ServiceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForService tests if a specific instance of Service round trips to the hub storage version and back losslessly
func RunResourceConversionTestForService(subject Service) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20220801s.Service
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual Service
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Service_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Service to Service via AssignProperties_To_Service & AssignProperties_From_Service returns original",
		prop.ForAll(RunPropertyAssignmentTestForService, ServiceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForService tests if a specific instance of Service can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForService(subject Service) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.Service
	err := copied.AssignProperties_To_Service(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Service
	err = actual.AssignProperties_From_Service(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Service_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Service via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForService, ServiceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForService runs a test to see if a specific instance of Service round trips to JSON and back losslessly
func RunJSONSerializationTestForService(subject Service) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Service
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Service instances for property testing - lazily instantiated by ServiceGenerator()
var serviceGenerator gopter.Gen

// ServiceGenerator returns a generator of Service instances for property testing.
func ServiceGenerator() gopter.Gen {
	if serviceGenerator != nil {
		return serviceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForService(generators)
	serviceGenerator = gen.Struct(reflect.TypeOf(Service{}), generators)

	return serviceGenerator
}

// AddRelatedPropertyGeneratorsForService is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForService(gens map[string]gopter.Gen) {
	gens["Spec"] = Service_SpecGenerator()
	gens["Status"] = Service_STATUSGenerator()
}

func Test_ServiceOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServiceOperatorSpec to ServiceOperatorSpec via AssignProperties_To_ServiceOperatorSpec & AssignProperties_From_ServiceOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceOperatorSpec, ServiceOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceOperatorSpec tests if a specific instance of ServiceOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServiceOperatorSpec(subject ServiceOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.ServiceOperatorSpec
	err := copied.AssignProperties_To_ServiceOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceOperatorSpec
	err = actual.AssignProperties_From_ServiceOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceOperatorSpec, ServiceOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceOperatorSpec runs a test to see if a specific instance of ServiceOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceOperatorSpec(subject ServiceOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceOperatorSpec instances for property testing - lazily instantiated by
// ServiceOperatorSpecGenerator()
var serviceOperatorSpecGenerator gopter.Gen

// ServiceOperatorSpecGenerator returns a generator of ServiceOperatorSpec instances for property testing.
func ServiceOperatorSpecGenerator() gopter.Gen {
	if serviceOperatorSpecGenerator != nil {
		return serviceOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	serviceOperatorSpecGenerator = gen.Struct(reflect.TypeOf(ServiceOperatorSpec{}), generators)

	return serviceOperatorSpecGenerator
}

func Test_Service_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Service_STATUS to Service_STATUS via AssignProperties_To_Service_STATUS & AssignProperties_From_Service_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForService_STATUS, Service_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForService_STATUS tests if a specific instance of Service_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForService_STATUS(subject Service_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.Service_STATUS
	err := copied.AssignProperties_To_Service_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Service_STATUS
	err = actual.AssignProperties_From_Service_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Service_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Service_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForService_STATUS, Service_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForService_STATUS runs a test to see if a specific instance of Service_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForService_STATUS(subject Service_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Service_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Service_STATUS instances for property testing - lazily instantiated by Service_STATUSGenerator()
var service_STATUSGenerator gopter.Gen

// Service_STATUSGenerator returns a generator of Service_STATUS instances for property testing.
// We first initialize service_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Service_STATUSGenerator() gopter.Gen {
	if service_STATUSGenerator != nil {
		return service_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService_STATUS(generators)
	service_STATUSGenerator = gen.Struct(reflect.TypeOf(Service_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService_STATUS(generators)
	AddRelatedPropertyGeneratorsForService_STATUS(generators)
	service_STATUSGenerator = gen.Struct(reflect.TypeOf(Service_STATUS{}), generators)

	return service_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForService_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForService_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAtUtc"] = gen.PtrOf(gen.AlphaString())
	gens["CustomProperties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["DeveloperPortalStatus"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_DeveloperPortalStatus_STATUS_Disabled, ApiManagementServiceProperties_DeveloperPortalStatus_STATUS_Enabled))
	gens["DeveloperPortalUrl"] = gen.PtrOf(gen.AlphaString())
	gens["DisableGateway"] = gen.PtrOf(gen.Bool())
	gens["EnableClientCertificate"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["GatewayRegionalUrl"] = gen.PtrOf(gen.AlphaString())
	gens["GatewayUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["LegacyPortalStatus"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_LegacyPortalStatus_STATUS_Disabled, ApiManagementServiceProperties_LegacyPortalStatus_STATUS_Enabled))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagementApiUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NatGatewayState"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_NatGatewayState_STATUS_Disabled, ApiManagementServiceProperties_NatGatewayState_STATUS_Enabled))
	gens["NotificationSenderEmail"] = gen.PtrOf(gen.AlphaString())
	gens["OutboundPublicIPAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["PlatformVersion"] = gen.PtrOf(gen.OneConstOf(
		ApiManagementServiceProperties_PlatformVersion_STATUS_Mtv1,
		ApiManagementServiceProperties_PlatformVersion_STATUS_Stv1,
		ApiManagementServiceProperties_PlatformVersion_STATUS_Stv2,
		ApiManagementServiceProperties_PlatformVersion_STATUS_Stv21,
		ApiManagementServiceProperties_PlatformVersion_STATUS_Undetermined))
	gens["PortalUrl"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["PublicIPAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["PublicIpAddressId"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_PublicNetworkAccess_STATUS_Disabled, ApiManagementServiceProperties_PublicNetworkAccess_STATUS_Enabled))
	gens["PublisherEmail"] = gen.PtrOf(gen.AlphaString())
	gens["PublisherName"] = gen.PtrOf(gen.AlphaString())
	gens["Restore"] = gen.PtrOf(gen.Bool())
	gens["ScmUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["TargetProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["VirtualNetworkType"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_VirtualNetworkType_STATUS_External, ApiManagementServiceProperties_VirtualNetworkType_STATUS_Internal, ApiManagementServiceProperties_VirtualNetworkType_STATUS_None))
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForService_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForService_STATUS(gens map[string]gopter.Gen) {
	gens["AdditionalLocations"] = gen.SliceOf(AdditionalLocation_STATUSGenerator())
	gens["ApiVersionConstraint"] = gen.PtrOf(ApiVersionConstraint_STATUSGenerator())
	gens["Certificates"] = gen.SliceOf(CertificateConfiguration_STATUSGenerator())
	gens["ConfigurationApi"] = gen.PtrOf(ConfigurationApi_STATUSGenerator())
	gens["HostnameConfigurations"] = gen.SliceOf(HostnameConfiguration_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(ApiManagementServiceIdentity_STATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(RemotePrivateEndpointConnectionWrapper_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(ApiManagementServiceSkuProperties_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
	gens["VirtualNetworkConfiguration"] = gen.PtrOf(VirtualNetworkConfiguration_STATUSGenerator())
}

func Test_Service_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Service_Spec to Service_Spec via AssignProperties_To_Service_Spec & AssignProperties_From_Service_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForService_Spec, Service_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForService_Spec tests if a specific instance of Service_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForService_Spec(subject Service_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.Service_Spec
	err := copied.AssignProperties_To_Service_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Service_Spec
	err = actual.AssignProperties_From_Service_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Service_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Service_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForService_Spec, Service_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForService_Spec runs a test to see if a specific instance of Service_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForService_Spec(subject Service_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Service_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Service_Spec instances for property testing - lazily instantiated by Service_SpecGenerator()
var service_SpecGenerator gopter.Gen

// Service_SpecGenerator returns a generator of Service_Spec instances for property testing.
// We first initialize service_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Service_SpecGenerator() gopter.Gen {
	if service_SpecGenerator != nil {
		return service_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService_Spec(generators)
	service_SpecGenerator = gen.Struct(reflect.TypeOf(Service_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService_Spec(generators)
	AddRelatedPropertyGeneratorsForService_Spec(generators)
	service_SpecGenerator = gen.Struct(reflect.TypeOf(Service_Spec{}), generators)

	return service_SpecGenerator
}

// AddIndependentPropertyGeneratorsForService_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForService_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["CustomProperties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["DeveloperPortalStatus"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_DeveloperPortalStatus_Disabled, ApiManagementServiceProperties_DeveloperPortalStatus_Enabled))
	gens["DisableGateway"] = gen.PtrOf(gen.Bool())
	gens["EnableClientCertificate"] = gen.PtrOf(gen.Bool())
	gens["LegacyPortalStatus"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_LegacyPortalStatus_Disabled, ApiManagementServiceProperties_LegacyPortalStatus_Enabled))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NatGatewayState"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_NatGatewayState_Disabled, ApiManagementServiceProperties_NatGatewayState_Enabled))
	gens["NotificationSenderEmail"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_PublicNetworkAccess_Disabled, ApiManagementServiceProperties_PublicNetworkAccess_Enabled))
	gens["PublisherEmail"] = gen.PtrOf(gen.AlphaString())
	gens["PublisherName"] = gen.PtrOf(gen.AlphaString())
	gens["Restore"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["VirtualNetworkType"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_VirtualNetworkType_External, ApiManagementServiceProperties_VirtualNetworkType_Internal, ApiManagementServiceProperties_VirtualNetworkType_None))
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForService_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForService_Spec(gens map[string]gopter.Gen) {
	gens["AdditionalLocations"] = gen.SliceOf(AdditionalLocationGenerator())
	gens["ApiVersionConstraint"] = gen.PtrOf(ApiVersionConstraintGenerator())
	gens["Certificates"] = gen.SliceOf(CertificateConfigurationGenerator())
	gens["ConfigurationApi"] = gen.PtrOf(ConfigurationApiGenerator())
	gens["HostnameConfigurations"] = gen.SliceOf(HostnameConfigurationGenerator())
	gens["Identity"] = gen.PtrOf(ApiManagementServiceIdentityGenerator())
	gens["OperatorSpec"] = gen.PtrOf(ServiceOperatorSpecGenerator())
	gens["Sku"] = gen.PtrOf(ApiManagementServiceSkuPropertiesGenerator())
	gens["VirtualNetworkConfiguration"] = gen.PtrOf(VirtualNetworkConfigurationGenerator())
}

func Test_SystemData_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignProperties_To_SystemData_STATUS & AssignProperties_From_SystemData_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData_STATUS tests if a specific instance of SystemData_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.SystemData_STATUS
	err := copied.AssignProperties_To_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_STATUS
	err = actual.AssignProperties_From_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_STATUS_Application,
		SystemData_CreatedByType_STATUS_Key,
		SystemData_CreatedByType_STATUS_ManagedIdentity,
		SystemData_CreatedByType_STATUS_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_STATUS_Application,
		SystemData_LastModifiedByType_STATUS_Key,
		SystemData_LastModifiedByType_STATUS_ManagedIdentity,
		SystemData_LastModifiedByType_STATUS_User))
}

func Test_UserAssignedIdentityDetails_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentityDetails to UserAssignedIdentityDetails via AssignProperties_To_UserAssignedIdentityDetails & AssignProperties_From_UserAssignedIdentityDetails returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentityDetails tests if a specific instance of UserAssignedIdentityDetails can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.UserAssignedIdentityDetails
	err := copied.AssignProperties_To_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentityDetails
	err = actual.AssignProperties_From_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_UserIdentityProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserIdentityProperties_STATUS to UserIdentityProperties_STATUS via AssignProperties_To_UserIdentityProperties_STATUS & AssignProperties_From_UserIdentityProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserIdentityProperties_STATUS, UserIdentityProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserIdentityProperties_STATUS tests if a specific instance of UserIdentityProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserIdentityProperties_STATUS(subject UserIdentityProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.UserIdentityProperties_STATUS
	err := copied.AssignProperties_To_UserIdentityProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserIdentityProperties_STATUS
	err = actual.AssignProperties_From_UserIdentityProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserIdentityProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserIdentityProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserIdentityProperties_STATUS, UserIdentityProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserIdentityProperties_STATUS runs a test to see if a specific instance of UserIdentityProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserIdentityProperties_STATUS(subject UserIdentityProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserIdentityProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserIdentityProperties_STATUS instances for property testing - lazily instantiated by
// UserIdentityProperties_STATUSGenerator()
var userIdentityProperties_STATUSGenerator gopter.Gen

// UserIdentityProperties_STATUSGenerator returns a generator of UserIdentityProperties_STATUS instances for property testing.
func UserIdentityProperties_STATUSGenerator() gopter.Gen {
	if userIdentityProperties_STATUSGenerator != nil {
		return userIdentityProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserIdentityProperties_STATUS(generators)
	userIdentityProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(UserIdentityProperties_STATUS{}), generators)

	return userIdentityProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserIdentityProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserIdentityProperties_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkConfiguration to VirtualNetworkConfiguration via AssignProperties_To_VirtualNetworkConfiguration & AssignProperties_From_VirtualNetworkConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkConfiguration, VirtualNetworkConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkConfiguration tests if a specific instance of VirtualNetworkConfiguration can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkConfiguration(subject VirtualNetworkConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.VirtualNetworkConfiguration
	err := copied.AssignProperties_To_VirtualNetworkConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkConfiguration
	err = actual.AssignProperties_From_VirtualNetworkConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkConfiguration, VirtualNetworkConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkConfiguration runs a test to see if a specific instance of VirtualNetworkConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkConfiguration(subject VirtualNetworkConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkConfiguration instances for property testing - lazily instantiated by
// VirtualNetworkConfigurationGenerator()
var virtualNetworkConfigurationGenerator gopter.Gen

// VirtualNetworkConfigurationGenerator returns a generator of VirtualNetworkConfiguration instances for property testing.
func VirtualNetworkConfigurationGenerator() gopter.Gen {
	if virtualNetworkConfigurationGenerator != nil {
		return virtualNetworkConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	virtualNetworkConfigurationGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkConfiguration{}), generators)

	return virtualNetworkConfigurationGenerator
}

func Test_VirtualNetworkConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkConfiguration_STATUS to VirtualNetworkConfiguration_STATUS via AssignProperties_To_VirtualNetworkConfiguration_STATUS & AssignProperties_From_VirtualNetworkConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkConfiguration_STATUS, VirtualNetworkConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkConfiguration_STATUS tests if a specific instance of VirtualNetworkConfiguration_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkConfiguration_STATUS(subject VirtualNetworkConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20230501ps.VirtualNetworkConfiguration_STATUS
	err := copied.AssignProperties_To_VirtualNetworkConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkConfiguration_STATUS
	err = actual.AssignProperties_From_VirtualNetworkConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkConfiguration_STATUS, VirtualNetworkConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkConfiguration_STATUS runs a test to see if a specific instance of VirtualNetworkConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkConfiguration_STATUS(subject VirtualNetworkConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkConfiguration_STATUS instances for property testing - lazily instantiated by
// VirtualNetworkConfiguration_STATUSGenerator()
var virtualNetworkConfiguration_STATUSGenerator gopter.Gen

// VirtualNetworkConfiguration_STATUSGenerator returns a generator of VirtualNetworkConfiguration_STATUS instances for property testing.
func VirtualNetworkConfiguration_STATUSGenerator() gopter.Gen {
	if virtualNetworkConfiguration_STATUSGenerator != nil {
		return virtualNetworkConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkConfiguration_STATUS(generators)
	virtualNetworkConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkConfiguration_STATUS{}), generators)

	return virtualNetworkConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["SubnetResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Subnetname"] = gen.PtrOf(gen.AlphaString())
	gens["Vnetid"] = gen.PtrOf(gen.AlphaString())
}
