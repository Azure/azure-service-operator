// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package compat

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/apimanagement/v1api20240501/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_BackendCircuitBreaker_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackendCircuitBreaker to BackendCircuitBreaker via AssignProperties_To_BackendCircuitBreaker & AssignProperties_From_BackendCircuitBreaker returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackendCircuitBreaker, BackendCircuitBreakerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackendCircuitBreaker tests if a specific instance of BackendCircuitBreaker can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForBackendCircuitBreaker(subject BackendCircuitBreaker) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.BackendCircuitBreaker
	err := copied.AssignProperties_To_BackendCircuitBreaker(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackendCircuitBreaker
	err = actual.AssignProperties_From_BackendCircuitBreaker(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackendCircuitBreaker_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackendCircuitBreaker via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackendCircuitBreaker, BackendCircuitBreakerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackendCircuitBreaker runs a test to see if a specific instance of BackendCircuitBreaker round trips to JSON and back losslessly
func RunJSONSerializationTestForBackendCircuitBreaker(subject BackendCircuitBreaker) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackendCircuitBreaker
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackendCircuitBreaker instances for property testing - lazily instantiated by
// BackendCircuitBreakerGenerator()
var backendCircuitBreakerGenerator gopter.Gen

// BackendCircuitBreakerGenerator returns a generator of BackendCircuitBreaker instances for property testing.
func BackendCircuitBreakerGenerator() gopter.Gen {
	if backendCircuitBreakerGenerator != nil {
		return backendCircuitBreakerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForBackendCircuitBreaker(generators)
	backendCircuitBreakerGenerator = gen.Struct(reflect.TypeOf(BackendCircuitBreaker{}), generators)

	return backendCircuitBreakerGenerator
}

// AddRelatedPropertyGeneratorsForBackendCircuitBreaker is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForBackendCircuitBreaker(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(CircuitBreakerRuleGenerator())
}

func Test_CircuitBreakerFailureCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CircuitBreakerFailureCondition to CircuitBreakerFailureCondition via AssignProperties_To_CircuitBreakerFailureCondition & AssignProperties_From_CircuitBreakerFailureCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForCircuitBreakerFailureCondition, CircuitBreakerFailureConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCircuitBreakerFailureCondition tests if a specific instance of CircuitBreakerFailureCondition can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCircuitBreakerFailureCondition(subject CircuitBreakerFailureCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CircuitBreakerFailureCondition
	err := copied.AssignProperties_To_CircuitBreakerFailureCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CircuitBreakerFailureCondition
	err = actual.AssignProperties_From_CircuitBreakerFailureCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CircuitBreakerFailureCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CircuitBreakerFailureCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCircuitBreakerFailureCondition, CircuitBreakerFailureConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCircuitBreakerFailureCondition runs a test to see if a specific instance of CircuitBreakerFailureCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForCircuitBreakerFailureCondition(subject CircuitBreakerFailureCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CircuitBreakerFailureCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CircuitBreakerFailureCondition instances for property testing - lazily instantiated by
// CircuitBreakerFailureConditionGenerator()
var circuitBreakerFailureConditionGenerator gopter.Gen

// CircuitBreakerFailureConditionGenerator returns a generator of CircuitBreakerFailureCondition instances for property testing.
// We first initialize circuitBreakerFailureConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CircuitBreakerFailureConditionGenerator() gopter.Gen {
	if circuitBreakerFailureConditionGenerator != nil {
		return circuitBreakerFailureConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCircuitBreakerFailureCondition(generators)
	circuitBreakerFailureConditionGenerator = gen.Struct(reflect.TypeOf(CircuitBreakerFailureCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCircuitBreakerFailureCondition(generators)
	AddRelatedPropertyGeneratorsForCircuitBreakerFailureCondition(generators)
	circuitBreakerFailureConditionGenerator = gen.Struct(reflect.TypeOf(CircuitBreakerFailureCondition{}), generators)

	return circuitBreakerFailureConditionGenerator
}

// AddIndependentPropertyGeneratorsForCircuitBreakerFailureCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCircuitBreakerFailureCondition(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["ErrorReasons"] = gen.SliceOf(gen.AlphaString())
	gens["Interval"] = gen.PtrOf(gen.AlphaString())
	gens["Percentage"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCircuitBreakerFailureCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCircuitBreakerFailureCondition(gens map[string]gopter.Gen) {
	gens["StatusCodeRanges"] = gen.SliceOf(FailureStatusCodeRangeGenerator())
}

func Test_CircuitBreakerRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CircuitBreakerRule to CircuitBreakerRule via AssignProperties_To_CircuitBreakerRule & AssignProperties_From_CircuitBreakerRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForCircuitBreakerRule, CircuitBreakerRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCircuitBreakerRule tests if a specific instance of CircuitBreakerRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCircuitBreakerRule(subject CircuitBreakerRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CircuitBreakerRule
	err := copied.AssignProperties_To_CircuitBreakerRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CircuitBreakerRule
	err = actual.AssignProperties_From_CircuitBreakerRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CircuitBreakerRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CircuitBreakerRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCircuitBreakerRule, CircuitBreakerRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCircuitBreakerRule runs a test to see if a specific instance of CircuitBreakerRule round trips to JSON and back losslessly
func RunJSONSerializationTestForCircuitBreakerRule(subject CircuitBreakerRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CircuitBreakerRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CircuitBreakerRule instances for property testing - lazily instantiated by CircuitBreakerRuleGenerator()
var circuitBreakerRuleGenerator gopter.Gen

// CircuitBreakerRuleGenerator returns a generator of CircuitBreakerRule instances for property testing.
// We first initialize circuitBreakerRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CircuitBreakerRuleGenerator() gopter.Gen {
	if circuitBreakerRuleGenerator != nil {
		return circuitBreakerRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCircuitBreakerRule(generators)
	circuitBreakerRuleGenerator = gen.Struct(reflect.TypeOf(CircuitBreakerRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCircuitBreakerRule(generators)
	AddRelatedPropertyGeneratorsForCircuitBreakerRule(generators)
	circuitBreakerRuleGenerator = gen.Struct(reflect.TypeOf(CircuitBreakerRule{}), generators)

	return circuitBreakerRuleGenerator
}

// AddIndependentPropertyGeneratorsForCircuitBreakerRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCircuitBreakerRule(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TripDuration"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCircuitBreakerRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCircuitBreakerRule(gens map[string]gopter.Gen) {
	gens["FailureCondition"] = gen.PtrOf(CircuitBreakerFailureConditionGenerator())
}

func Test_FailureStatusCodeRange_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from FailureStatusCodeRange to FailureStatusCodeRange via AssignProperties_To_FailureStatusCodeRange & AssignProperties_From_FailureStatusCodeRange returns original",
		prop.ForAll(RunPropertyAssignmentTestForFailureStatusCodeRange, FailureStatusCodeRangeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForFailureStatusCodeRange tests if a specific instance of FailureStatusCodeRange can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForFailureStatusCodeRange(subject FailureStatusCodeRange) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.FailureStatusCodeRange
	err := copied.AssignProperties_To_FailureStatusCodeRange(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual FailureStatusCodeRange
	err = actual.AssignProperties_From_FailureStatusCodeRange(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_FailureStatusCodeRange_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FailureStatusCodeRange via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFailureStatusCodeRange, FailureStatusCodeRangeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFailureStatusCodeRange runs a test to see if a specific instance of FailureStatusCodeRange round trips to JSON and back losslessly
func RunJSONSerializationTestForFailureStatusCodeRange(subject FailureStatusCodeRange) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FailureStatusCodeRange
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FailureStatusCodeRange instances for property testing - lazily instantiated by
// FailureStatusCodeRangeGenerator()
var failureStatusCodeRangeGenerator gopter.Gen

// FailureStatusCodeRangeGenerator returns a generator of FailureStatusCodeRange instances for property testing.
func FailureStatusCodeRangeGenerator() gopter.Gen {
	if failureStatusCodeRangeGenerator != nil {
		return failureStatusCodeRangeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFailureStatusCodeRange(generators)
	failureStatusCodeRangeGenerator = gen.Struct(reflect.TypeOf(FailureStatusCodeRange{}), generators)

	return failureStatusCodeRangeGenerator
}

// AddIndependentPropertyGeneratorsForFailureStatusCodeRange is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFailureStatusCodeRange(gens map[string]gopter.Gen) {
	gens["Max"] = gen.PtrOf(gen.Int())
	gens["Min"] = gen.PtrOf(gen.Int())
}
