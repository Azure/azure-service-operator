// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package compat

import (
	storage "github.com/Azure/azure-service-operator/v2/api/apimanagement/v1api20240501/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/rotisserie/eris"
)

// Storage version of v1api20230501preview.BackendCircuitBreaker_STATUS
// The configuration of the backend circuit breaker
type BackendCircuitBreaker_STATUS struct {
	PropertyBag genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	Rules       []CircuitBreakerRule_STATUS `json:"rules,omitempty"`
}

// AssignProperties_From_BackendCircuitBreaker_STATUS populates our BackendCircuitBreaker_STATUS from the provided source BackendCircuitBreaker_STATUS
func (breaker *BackendCircuitBreaker_STATUS) AssignProperties_From_BackendCircuitBreaker_STATUS(source *storage.BackendCircuitBreaker_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Rules
	if source.Rules != nil {
		ruleList := make([]CircuitBreakerRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule CircuitBreakerRule_STATUS
			err := rule.AssignProperties_From_CircuitBreakerRule_STATUS(&ruleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_CircuitBreakerRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		breaker.Rules = ruleList
	} else {
		breaker.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		breaker.PropertyBag = propertyBag
	} else {
		breaker.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackendCircuitBreaker_STATUS interface (if implemented) to customize the conversion
	var breakerAsAny any = breaker
	if augmentedBreaker, ok := breakerAsAny.(augmentConversionForBackendCircuitBreaker_STATUS); ok {
		err := augmentedBreaker.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_BackendCircuitBreaker_STATUS populates the provided destination BackendCircuitBreaker_STATUS from our BackendCircuitBreaker_STATUS
func (breaker *BackendCircuitBreaker_STATUS) AssignProperties_To_BackendCircuitBreaker_STATUS(destination *storage.BackendCircuitBreaker_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(breaker.PropertyBag)

	// Rules
	if breaker.Rules != nil {
		ruleList := make([]storage.CircuitBreakerRule_STATUS, len(breaker.Rules))
		for ruleIndex, ruleItem := range breaker.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule storage.CircuitBreakerRule_STATUS
			err := ruleItem.AssignProperties_To_CircuitBreakerRule_STATUS(&rule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_CircuitBreakerRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForBackendCircuitBreaker_STATUS interface (if implemented) to customize the conversion
	var breakerAsAny any = breaker
	if augmentedBreaker, ok := breakerAsAny.(augmentConversionForBackendCircuitBreaker_STATUS); ok {
		err := augmentedBreaker.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForBackendCircuitBreaker_STATUS interface {
	AssignPropertiesFrom(src *storage.BackendCircuitBreaker_STATUS) error
	AssignPropertiesTo(dst *storage.BackendCircuitBreaker_STATUS) error
}

// Storage version of v1api20230501preview.CircuitBreakerRule_STATUS
// Rule configuration to trip the backend.
type CircuitBreakerRule_STATUS struct {
	FailureCondition *CircuitBreakerFailureCondition_STATUS `json:"failureCondition,omitempty"`
	Name             *string                                `json:"name,omitempty"`
	PropertyBag      genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	TripDuration     *string                                `json:"tripDuration,omitempty"`
}

// AssignProperties_From_CircuitBreakerRule_STATUS populates our CircuitBreakerRule_STATUS from the provided source CircuitBreakerRule_STATUS
func (rule *CircuitBreakerRule_STATUS) AssignProperties_From_CircuitBreakerRule_STATUS(source *storage.CircuitBreakerRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AcceptRetryAfter
	if source.AcceptRetryAfter != nil {
		propertyBag.Add("AcceptRetryAfter", *source.AcceptRetryAfter)
	} else {
		propertyBag.Remove("AcceptRetryAfter")
	}

	// FailureCondition
	if source.FailureCondition != nil {
		var failureCondition CircuitBreakerFailureCondition_STATUS
		err := failureCondition.AssignProperties_From_CircuitBreakerFailureCondition_STATUS(source.FailureCondition)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CircuitBreakerFailureCondition_STATUS() to populate field FailureCondition")
		}
		rule.FailureCondition = &failureCondition
	} else {
		rule.FailureCondition = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// TripDuration
	rule.TripDuration = genruntime.ClonePointerToString(source.TripDuration)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForCircuitBreakerRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForCircuitBreakerRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CircuitBreakerRule_STATUS populates the provided destination CircuitBreakerRule_STATUS from our CircuitBreakerRule_STATUS
func (rule *CircuitBreakerRule_STATUS) AssignProperties_To_CircuitBreakerRule_STATUS(destination *storage.CircuitBreakerRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// AcceptRetryAfter
	if propertyBag.Contains("AcceptRetryAfter") {
		var acceptRetryAfter bool
		err := propertyBag.Pull("AcceptRetryAfter", &acceptRetryAfter)
		if err != nil {
			return eris.Wrap(err, "pulling 'AcceptRetryAfter' from propertyBag")
		}

		destination.AcceptRetryAfter = &acceptRetryAfter
	} else {
		destination.AcceptRetryAfter = nil
	}

	// FailureCondition
	if rule.FailureCondition != nil {
		var failureCondition storage.CircuitBreakerFailureCondition_STATUS
		err := rule.FailureCondition.AssignProperties_To_CircuitBreakerFailureCondition_STATUS(&failureCondition)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CircuitBreakerFailureCondition_STATUS() to populate field FailureCondition")
		}
		destination.FailureCondition = &failureCondition
	} else {
		destination.FailureCondition = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// TripDuration
	destination.TripDuration = genruntime.ClonePointerToString(rule.TripDuration)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCircuitBreakerRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForCircuitBreakerRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForCircuitBreakerRule_STATUS interface {
	AssignPropertiesFrom(src *storage.CircuitBreakerRule_STATUS) error
	AssignPropertiesTo(dst *storage.CircuitBreakerRule_STATUS) error
}

// Storage version of v1api20230501preview.CircuitBreakerFailureCondition_STATUS
// The trip conditions of the circuit breaker
type CircuitBreakerFailureCondition_STATUS struct {
	Count            *int                            `json:"count,omitempty"`
	ErrorReasons     []string                        `json:"errorReasons,omitempty"`
	Interval         *string                         `json:"interval,omitempty"`
	Percentage       *int                            `json:"percentage,omitempty"`
	PropertyBag      genruntime.PropertyBag          `json:"$propertyBag,omitempty"`
	StatusCodeRanges []FailureStatusCodeRange_STATUS `json:"statusCodeRanges,omitempty"`
}

// AssignProperties_From_CircuitBreakerFailureCondition_STATUS populates our CircuitBreakerFailureCondition_STATUS from the provided source CircuitBreakerFailureCondition_STATUS
func (condition *CircuitBreakerFailureCondition_STATUS) AssignProperties_From_CircuitBreakerFailureCondition_STATUS(source *storage.CircuitBreakerFailureCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Count
	condition.Count = genruntime.ClonePointerToInt(source.Count)

	// ErrorReasons
	condition.ErrorReasons = genruntime.CloneSliceOfString(source.ErrorReasons)

	// Interval
	condition.Interval = genruntime.ClonePointerToString(source.Interval)

	// Percentage
	condition.Percentage = genruntime.ClonePointerToInt(source.Percentage)

	// StatusCodeRanges
	if source.StatusCodeRanges != nil {
		statusCodeRangeList := make([]FailureStatusCodeRange_STATUS, len(source.StatusCodeRanges))
		for statusCodeRangeIndex, statusCodeRangeItem := range source.StatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			statusCodeRangeItem := statusCodeRangeItem
			var statusCodeRange FailureStatusCodeRange_STATUS
			err := statusCodeRange.AssignProperties_From_FailureStatusCodeRange_STATUS(&statusCodeRangeItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_FailureStatusCodeRange_STATUS() to populate field StatusCodeRanges")
			}
			statusCodeRangeList[statusCodeRangeIndex] = statusCodeRange
		}
		condition.StatusCodeRanges = statusCodeRangeList
	} else {
		condition.StatusCodeRanges = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForCircuitBreakerFailureCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForCircuitBreakerFailureCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CircuitBreakerFailureCondition_STATUS populates the provided destination CircuitBreakerFailureCondition_STATUS from our CircuitBreakerFailureCondition_STATUS
func (condition *CircuitBreakerFailureCondition_STATUS) AssignProperties_To_CircuitBreakerFailureCondition_STATUS(destination *storage.CircuitBreakerFailureCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Count
	destination.Count = genruntime.ClonePointerToInt(condition.Count)

	// ErrorReasons
	destination.ErrorReasons = genruntime.CloneSliceOfString(condition.ErrorReasons)

	// Interval
	destination.Interval = genruntime.ClonePointerToString(condition.Interval)

	// Percentage
	destination.Percentage = genruntime.ClonePointerToInt(condition.Percentage)

	// StatusCodeRanges
	if condition.StatusCodeRanges != nil {
		statusCodeRangeList := make([]storage.FailureStatusCodeRange_STATUS, len(condition.StatusCodeRanges))
		for statusCodeRangeIndex, statusCodeRangeItem := range condition.StatusCodeRanges {
			// Shadow the loop variable to avoid aliasing
			statusCodeRangeItem := statusCodeRangeItem
			var statusCodeRange storage.FailureStatusCodeRange_STATUS
			err := statusCodeRangeItem.AssignProperties_To_FailureStatusCodeRange_STATUS(&statusCodeRange)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_FailureStatusCodeRange_STATUS() to populate field StatusCodeRanges")
			}
			statusCodeRangeList[statusCodeRangeIndex] = statusCodeRange
		}
		destination.StatusCodeRanges = statusCodeRangeList
	} else {
		destination.StatusCodeRanges = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCircuitBreakerFailureCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForCircuitBreakerFailureCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForCircuitBreakerFailureCondition_STATUS interface {
	AssignPropertiesFrom(src *storage.CircuitBreakerFailureCondition_STATUS) error
	AssignPropertiesTo(dst *storage.CircuitBreakerFailureCondition_STATUS) error
}

// Storage version of v1api20230501preview.FailureStatusCodeRange_STATUS
// The failure http status code range
type FailureStatusCodeRange_STATUS struct {
	Max         *int                   `json:"max,omitempty"`
	Min         *int                   `json:"min,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_FailureStatusCodeRange_STATUS populates our FailureStatusCodeRange_STATUS from the provided source FailureStatusCodeRange_STATUS
func (codeRange *FailureStatusCodeRange_STATUS) AssignProperties_From_FailureStatusCodeRange_STATUS(source *storage.FailureStatusCodeRange_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Max
	codeRange.Max = genruntime.ClonePointerToInt(source.Max)

	// Min
	codeRange.Min = genruntime.ClonePointerToInt(source.Min)

	// Update the property bag
	if len(propertyBag) > 0 {
		codeRange.PropertyBag = propertyBag
	} else {
		codeRange.PropertyBag = nil
	}

	// Invoke the augmentConversionForFailureStatusCodeRange_STATUS interface (if implemented) to customize the conversion
	var codeRangeAsAny any = codeRange
	if augmentedCodeRange, ok := codeRangeAsAny.(augmentConversionForFailureStatusCodeRange_STATUS); ok {
		err := augmentedCodeRange.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_FailureStatusCodeRange_STATUS populates the provided destination FailureStatusCodeRange_STATUS from our FailureStatusCodeRange_STATUS
func (codeRange *FailureStatusCodeRange_STATUS) AssignProperties_To_FailureStatusCodeRange_STATUS(destination *storage.FailureStatusCodeRange_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(codeRange.PropertyBag)

	// Max
	destination.Max = genruntime.ClonePointerToInt(codeRange.Max)

	// Min
	destination.Min = genruntime.ClonePointerToInt(codeRange.Min)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForFailureStatusCodeRange_STATUS interface (if implemented) to customize the conversion
	var codeRangeAsAny any = codeRange
	if augmentedCodeRange, ok := codeRangeAsAny.(augmentConversionForFailureStatusCodeRange_STATUS); ok {
		err := augmentedCodeRange.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForFailureStatusCodeRange_STATUS interface {
	AssignPropertiesFrom(src *storage.FailureStatusCodeRange_STATUS) error
	AssignPropertiesTo(dst *storage.FailureStatusCodeRange_STATUS) error
}
