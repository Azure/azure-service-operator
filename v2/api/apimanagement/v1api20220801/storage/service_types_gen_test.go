// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Service_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Service via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForService, ServiceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForService runs a test to see if a specific instance of Service round trips to JSON and back losslessly
func RunJSONSerializationTestForService(subject Service) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Service
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Service instances for property testing - lazily instantiated by ServiceGenerator()
var serviceGenerator gopter.Gen

// ServiceGenerator returns a generator of Service instances for property testing.
func ServiceGenerator() gopter.Gen {
	if serviceGenerator != nil {
		return serviceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForService(generators)
	serviceGenerator = gen.Struct(reflect.TypeOf(Service{}), generators)

	return serviceGenerator
}

// AddRelatedPropertyGeneratorsForService is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForService(gens map[string]gopter.Gen) {
	gens["Spec"] = Service_SpecGenerator()
	gens["Status"] = Service_STATUSGenerator()
}

func Test_Service_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Service_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForService_Spec, Service_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForService_Spec runs a test to see if a specific instance of Service_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForService_Spec(subject Service_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Service_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Service_Spec instances for property testing - lazily instantiated by Service_SpecGenerator()
var service_SpecGenerator gopter.Gen

// Service_SpecGenerator returns a generator of Service_Spec instances for property testing.
// We first initialize service_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Service_SpecGenerator() gopter.Gen {
	if service_SpecGenerator != nil {
		return service_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService_Spec(generators)
	service_SpecGenerator = gen.Struct(reflect.TypeOf(Service_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService_Spec(generators)
	AddRelatedPropertyGeneratorsForService_Spec(generators)
	service_SpecGenerator = gen.Struct(reflect.TypeOf(Service_Spec{}), generators)

	return service_SpecGenerator
}

// AddIndependentPropertyGeneratorsForService_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForService_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["CustomProperties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["DisableGateway"] = gen.PtrOf(gen.Bool())
	gens["EnableClientCertificate"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NatGatewayState"] = gen.PtrOf(gen.AlphaString())
	gens["NotificationSenderEmail"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["PublisherEmail"] = gen.PtrOf(gen.AlphaString())
	gens["PublisherName"] = gen.PtrOf(gen.AlphaString())
	gens["Restore"] = gen.PtrOf(gen.Bool())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["VirtualNetworkType"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForService_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForService_Spec(gens map[string]gopter.Gen) {
	gens["AdditionalLocations"] = gen.SliceOf(AdditionalLocationGenerator())
	gens["ApiVersionConstraint"] = gen.PtrOf(ApiVersionConstraintGenerator())
	gens["Certificates"] = gen.SliceOf(CertificateConfigurationGenerator())
	gens["HostnameConfigurations"] = gen.SliceOf(HostnameConfigurationGenerator())
	gens["Identity"] = gen.PtrOf(ApiManagementServiceIdentityGenerator())
	gens["Sku"] = gen.PtrOf(ApiManagementServiceSkuPropertiesGenerator())
	gens["VirtualNetworkConfiguration"] = gen.PtrOf(VirtualNetworkConfigurationGenerator())
}

func Test_Service_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Service_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForService_STATUS, Service_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForService_STATUS runs a test to see if a specific instance of Service_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForService_STATUS(subject Service_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Service_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Service_STATUS instances for property testing - lazily instantiated by Service_STATUSGenerator()
var service_STATUSGenerator gopter.Gen

// Service_STATUSGenerator returns a generator of Service_STATUS instances for property testing.
// We first initialize service_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Service_STATUSGenerator() gopter.Gen {
	if service_STATUSGenerator != nil {
		return service_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService_STATUS(generators)
	service_STATUSGenerator = gen.Struct(reflect.TypeOf(Service_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService_STATUS(generators)
	AddRelatedPropertyGeneratorsForService_STATUS(generators)
	service_STATUSGenerator = gen.Struct(reflect.TypeOf(Service_STATUS{}), generators)

	return service_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForService_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForService_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAtUtc"] = gen.PtrOf(gen.AlphaString())
	gens["CustomProperties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["DeveloperPortalUrl"] = gen.PtrOf(gen.AlphaString())
	gens["DisableGateway"] = gen.PtrOf(gen.Bool())
	gens["EnableClientCertificate"] = gen.PtrOf(gen.Bool())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["GatewayRegionalUrl"] = gen.PtrOf(gen.AlphaString())
	gens["GatewayUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagementApiUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NatGatewayState"] = gen.PtrOf(gen.AlphaString())
	gens["NotificationSenderEmail"] = gen.PtrOf(gen.AlphaString())
	gens["OutboundPublicIPAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["PlatformVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PortalUrl"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["PublicIPAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["PublicIpAddressId"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["PublisherEmail"] = gen.PtrOf(gen.AlphaString())
	gens["PublisherName"] = gen.PtrOf(gen.AlphaString())
	gens["Restore"] = gen.PtrOf(gen.Bool())
	gens["ScmUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["TargetProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["VirtualNetworkType"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForService_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForService_STATUS(gens map[string]gopter.Gen) {
	gens["AdditionalLocations"] = gen.SliceOf(AdditionalLocation_STATUSGenerator())
	gens["ApiVersionConstraint"] = gen.PtrOf(ApiVersionConstraint_STATUSGenerator())
	gens["Certificates"] = gen.SliceOf(CertificateConfiguration_STATUSGenerator())
	gens["HostnameConfigurations"] = gen.SliceOf(HostnameConfiguration_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(ApiManagementServiceIdentity_STATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(RemotePrivateEndpointConnectionWrapper_STATUSGenerator())
	gens["Sku"] = gen.PtrOf(ApiManagementServiceSkuProperties_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
	gens["VirtualNetworkConfiguration"] = gen.PtrOf(VirtualNetworkConfiguration_STATUSGenerator())
}

func Test_AdditionalLocation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalLocation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalLocation, AdditionalLocationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalLocation runs a test to see if a specific instance of AdditionalLocation round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalLocation(subject AdditionalLocation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalLocation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalLocation instances for property testing - lazily instantiated by AdditionalLocationGenerator()
var additionalLocationGenerator gopter.Gen

// AdditionalLocationGenerator returns a generator of AdditionalLocation instances for property testing.
// We first initialize additionalLocationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AdditionalLocationGenerator() gopter.Gen {
	if additionalLocationGenerator != nil {
		return additionalLocationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalLocation(generators)
	additionalLocationGenerator = gen.Struct(reflect.TypeOf(AdditionalLocation{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalLocation(generators)
	AddRelatedPropertyGeneratorsForAdditionalLocation(generators)
	additionalLocationGenerator = gen.Struct(reflect.TypeOf(AdditionalLocation{}), generators)

	return additionalLocationGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalLocation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalLocation(gens map[string]gopter.Gen) {
	gens["DisableGateway"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NatGatewayState"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAdditionalLocation is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdditionalLocation(gens map[string]gopter.Gen) {
	gens["Sku"] = gen.PtrOf(ApiManagementServiceSkuPropertiesGenerator())
	gens["VirtualNetworkConfiguration"] = gen.PtrOf(VirtualNetworkConfigurationGenerator())
}

func Test_AdditionalLocation_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalLocation_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalLocation_STATUS, AdditionalLocation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalLocation_STATUS runs a test to see if a specific instance of AdditionalLocation_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalLocation_STATUS(subject AdditionalLocation_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalLocation_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalLocation_STATUS instances for property testing - lazily instantiated by
// AdditionalLocation_STATUSGenerator()
var additionalLocation_STATUSGenerator gopter.Gen

// AdditionalLocation_STATUSGenerator returns a generator of AdditionalLocation_STATUS instances for property testing.
// We first initialize additionalLocation_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AdditionalLocation_STATUSGenerator() gopter.Gen {
	if additionalLocation_STATUSGenerator != nil {
		return additionalLocation_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalLocation_STATUS(generators)
	additionalLocation_STATUSGenerator = gen.Struct(reflect.TypeOf(AdditionalLocation_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalLocation_STATUS(generators)
	AddRelatedPropertyGeneratorsForAdditionalLocation_STATUS(generators)
	additionalLocation_STATUSGenerator = gen.Struct(reflect.TypeOf(AdditionalLocation_STATUS{}), generators)

	return additionalLocation_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalLocation_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalLocation_STATUS(gens map[string]gopter.Gen) {
	gens["DisableGateway"] = gen.PtrOf(gen.Bool())
	gens["GatewayRegionalUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NatGatewayState"] = gen.PtrOf(gen.AlphaString())
	gens["OutboundPublicIPAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["PlatformVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateIPAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["PublicIPAddresses"] = gen.SliceOf(gen.AlphaString())
	gens["PublicIpAddressId"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAdditionalLocation_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdditionalLocation_STATUS(gens map[string]gopter.Gen) {
	gens["Sku"] = gen.PtrOf(ApiManagementServiceSkuProperties_STATUSGenerator())
	gens["VirtualNetworkConfiguration"] = gen.PtrOf(VirtualNetworkConfiguration_STATUSGenerator())
}

func Test_ApiManagementServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementServiceIdentity, ApiManagementServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementServiceIdentity runs a test to see if a specific instance of ApiManagementServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementServiceIdentity(subject ApiManagementServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementServiceIdentity instances for property testing - lazily instantiated by
// ApiManagementServiceIdentityGenerator()
var apiManagementServiceIdentityGenerator gopter.Gen

// ApiManagementServiceIdentityGenerator returns a generator of ApiManagementServiceIdentity instances for property testing.
// We first initialize apiManagementServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiManagementServiceIdentityGenerator() gopter.Gen {
	if apiManagementServiceIdentityGenerator != nil {
		return apiManagementServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceIdentity(generators)
	apiManagementServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForApiManagementServiceIdentity(generators)
	apiManagementServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceIdentity{}), generators)

	return apiManagementServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApiManagementServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiManagementServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_ApiManagementServiceIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementServiceIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementServiceIdentity_STATUS, ApiManagementServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementServiceIdentity_STATUS runs a test to see if a specific instance of ApiManagementServiceIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementServiceIdentity_STATUS(subject ApiManagementServiceIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementServiceIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementServiceIdentity_STATUS instances for property testing - lazily instantiated by
// ApiManagementServiceIdentity_STATUSGenerator()
var apiManagementServiceIdentity_STATUSGenerator gopter.Gen

// ApiManagementServiceIdentity_STATUSGenerator returns a generator of ApiManagementServiceIdentity_STATUS instances for property testing.
// We first initialize apiManagementServiceIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiManagementServiceIdentity_STATUSGenerator() gopter.Gen {
	if apiManagementServiceIdentity_STATUSGenerator != nil {
		return apiManagementServiceIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceIdentity_STATUS(generators)
	apiManagementServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForApiManagementServiceIdentity_STATUS(generators)
	apiManagementServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceIdentity_STATUS{}), generators)

	return apiManagementServiceIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementServiceIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForApiManagementServiceIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiManagementServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserIdentityProperties_STATUSGenerator())
}

func Test_ApiManagementServiceSkuProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementServiceSkuProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementServiceSkuProperties, ApiManagementServiceSkuPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementServiceSkuProperties runs a test to see if a specific instance of ApiManagementServiceSkuProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementServiceSkuProperties(subject ApiManagementServiceSkuProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementServiceSkuProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementServiceSkuProperties instances for property testing - lazily instantiated by
// ApiManagementServiceSkuPropertiesGenerator()
var apiManagementServiceSkuPropertiesGenerator gopter.Gen

// ApiManagementServiceSkuPropertiesGenerator returns a generator of ApiManagementServiceSkuProperties instances for property testing.
func ApiManagementServiceSkuPropertiesGenerator() gopter.Gen {
	if apiManagementServiceSkuPropertiesGenerator != nil {
		return apiManagementServiceSkuPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties(generators)
	apiManagementServiceSkuPropertiesGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceSkuProperties{}), generators)

	return apiManagementServiceSkuPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiManagementServiceSkuProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementServiceSkuProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementServiceSkuProperties_STATUS, ApiManagementServiceSkuProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementServiceSkuProperties_STATUS runs a test to see if a specific instance of ApiManagementServiceSkuProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementServiceSkuProperties_STATUS(subject ApiManagementServiceSkuProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementServiceSkuProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementServiceSkuProperties_STATUS instances for property testing - lazily instantiated by
// ApiManagementServiceSkuProperties_STATUSGenerator()
var apiManagementServiceSkuProperties_STATUSGenerator gopter.Gen

// ApiManagementServiceSkuProperties_STATUSGenerator returns a generator of ApiManagementServiceSkuProperties_STATUS instances for property testing.
func ApiManagementServiceSkuProperties_STATUSGenerator() gopter.Gen {
	if apiManagementServiceSkuProperties_STATUSGenerator != nil {
		return apiManagementServiceSkuProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties_STATUS(generators)
	apiManagementServiceSkuProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceSkuProperties_STATUS{}), generators)

	return apiManagementServiceSkuProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiVersionConstraint_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiVersionConstraint via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiVersionConstraint, ApiVersionConstraintGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiVersionConstraint runs a test to see if a specific instance of ApiVersionConstraint round trips to JSON and back losslessly
func RunJSONSerializationTestForApiVersionConstraint(subject ApiVersionConstraint) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiVersionConstraint
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiVersionConstraint instances for property testing - lazily instantiated by
// ApiVersionConstraintGenerator()
var apiVersionConstraintGenerator gopter.Gen

// ApiVersionConstraintGenerator returns a generator of ApiVersionConstraint instances for property testing.
func ApiVersionConstraintGenerator() gopter.Gen {
	if apiVersionConstraintGenerator != nil {
		return apiVersionConstraintGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiVersionConstraint(generators)
	apiVersionConstraintGenerator = gen.Struct(reflect.TypeOf(ApiVersionConstraint{}), generators)

	return apiVersionConstraintGenerator
}

// AddIndependentPropertyGeneratorsForApiVersionConstraint is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiVersionConstraint(gens map[string]gopter.Gen) {
	gens["MinApiVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiVersionConstraint_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiVersionConstraint_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiVersionConstraint_STATUS, ApiVersionConstraint_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiVersionConstraint_STATUS runs a test to see if a specific instance of ApiVersionConstraint_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApiVersionConstraint_STATUS(subject ApiVersionConstraint_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiVersionConstraint_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiVersionConstraint_STATUS instances for property testing - lazily instantiated by
// ApiVersionConstraint_STATUSGenerator()
var apiVersionConstraint_STATUSGenerator gopter.Gen

// ApiVersionConstraint_STATUSGenerator returns a generator of ApiVersionConstraint_STATUS instances for property testing.
func ApiVersionConstraint_STATUSGenerator() gopter.Gen {
	if apiVersionConstraint_STATUSGenerator != nil {
		return apiVersionConstraint_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiVersionConstraint_STATUS(generators)
	apiVersionConstraint_STATUSGenerator = gen.Struct(reflect.TypeOf(ApiVersionConstraint_STATUS{}), generators)

	return apiVersionConstraint_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForApiVersionConstraint_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiVersionConstraint_STATUS(gens map[string]gopter.Gen) {
	gens["MinApiVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_CertificateConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CertificateConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCertificateConfiguration, CertificateConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCertificateConfiguration runs a test to see if a specific instance of CertificateConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForCertificateConfiguration(subject CertificateConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CertificateConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CertificateConfiguration instances for property testing - lazily instantiated by
// CertificateConfigurationGenerator()
var certificateConfigurationGenerator gopter.Gen

// CertificateConfigurationGenerator returns a generator of CertificateConfiguration instances for property testing.
// We first initialize certificateConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CertificateConfigurationGenerator() gopter.Gen {
	if certificateConfigurationGenerator != nil {
		return certificateConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateConfiguration(generators)
	certificateConfigurationGenerator = gen.Struct(reflect.TypeOf(CertificateConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateConfiguration(generators)
	AddRelatedPropertyGeneratorsForCertificateConfiguration(generators)
	certificateConfigurationGenerator = gen.Struct(reflect.TypeOf(CertificateConfiguration{}), generators)

	return certificateConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForCertificateConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCertificateConfiguration(gens map[string]gopter.Gen) {
	gens["EncodedCertificate"] = gen.PtrOf(gen.AlphaString())
	gens["StoreName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCertificateConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCertificateConfiguration(gens map[string]gopter.Gen) {
	gens["Certificate"] = gen.PtrOf(CertificateInformationGenerator())
}

func Test_CertificateConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CertificateConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCertificateConfiguration_STATUS, CertificateConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCertificateConfiguration_STATUS runs a test to see if a specific instance of CertificateConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCertificateConfiguration_STATUS(subject CertificateConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CertificateConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CertificateConfiguration_STATUS instances for property testing - lazily instantiated by
// CertificateConfiguration_STATUSGenerator()
var certificateConfiguration_STATUSGenerator gopter.Gen

// CertificateConfiguration_STATUSGenerator returns a generator of CertificateConfiguration_STATUS instances for property testing.
// We first initialize certificateConfiguration_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CertificateConfiguration_STATUSGenerator() gopter.Gen {
	if certificateConfiguration_STATUSGenerator != nil {
		return certificateConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateConfiguration_STATUS(generators)
	certificateConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(CertificateConfiguration_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateConfiguration_STATUS(generators)
	AddRelatedPropertyGeneratorsForCertificateConfiguration_STATUS(generators)
	certificateConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(CertificateConfiguration_STATUS{}), generators)

	return certificateConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCertificateConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCertificateConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["EncodedCertificate"] = gen.PtrOf(gen.AlphaString())
	gens["StoreName"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCertificateConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCertificateConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["Certificate"] = gen.PtrOf(CertificateInformation_STATUSGenerator())
}

func Test_HostnameConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostnameConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostnameConfiguration, HostnameConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostnameConfiguration runs a test to see if a specific instance of HostnameConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForHostnameConfiguration(subject HostnameConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostnameConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostnameConfiguration instances for property testing - lazily instantiated by
// HostnameConfigurationGenerator()
var hostnameConfigurationGenerator gopter.Gen

// HostnameConfigurationGenerator returns a generator of HostnameConfiguration instances for property testing.
// We first initialize hostnameConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HostnameConfigurationGenerator() gopter.Gen {
	if hostnameConfigurationGenerator != nil {
		return hostnameConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostnameConfiguration(generators)
	hostnameConfigurationGenerator = gen.Struct(reflect.TypeOf(HostnameConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostnameConfiguration(generators)
	AddRelatedPropertyGeneratorsForHostnameConfiguration(generators)
	hostnameConfigurationGenerator = gen.Struct(reflect.TypeOf(HostnameConfiguration{}), generators)

	return hostnameConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForHostnameConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostnameConfiguration(gens map[string]gopter.Gen) {
	gens["CertificateSource"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateStatus"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultSslBinding"] = gen.PtrOf(gen.Bool())
	gens["EncodedCertificate"] = gen.PtrOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultId"] = gen.PtrOf(gen.AlphaString())
	gens["NegotiateClientCertificate"] = gen.PtrOf(gen.Bool())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHostnameConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHostnameConfiguration(gens map[string]gopter.Gen) {
	gens["Certificate"] = gen.PtrOf(CertificateInformationGenerator())
}

func Test_HostnameConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostnameConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostnameConfiguration_STATUS, HostnameConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostnameConfiguration_STATUS runs a test to see if a specific instance of HostnameConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHostnameConfiguration_STATUS(subject HostnameConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostnameConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostnameConfiguration_STATUS instances for property testing - lazily instantiated by
// HostnameConfiguration_STATUSGenerator()
var hostnameConfiguration_STATUSGenerator gopter.Gen

// HostnameConfiguration_STATUSGenerator returns a generator of HostnameConfiguration_STATUS instances for property testing.
// We first initialize hostnameConfiguration_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HostnameConfiguration_STATUSGenerator() gopter.Gen {
	if hostnameConfiguration_STATUSGenerator != nil {
		return hostnameConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostnameConfiguration_STATUS(generators)
	hostnameConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(HostnameConfiguration_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostnameConfiguration_STATUS(generators)
	AddRelatedPropertyGeneratorsForHostnameConfiguration_STATUS(generators)
	hostnameConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(HostnameConfiguration_STATUS{}), generators)

	return hostnameConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHostnameConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostnameConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["CertificateSource"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateStatus"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultSslBinding"] = gen.PtrOf(gen.Bool())
	gens["EncodedCertificate"] = gen.PtrOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultId"] = gen.PtrOf(gen.AlphaString())
	gens["NegotiateClientCertificate"] = gen.PtrOf(gen.Bool())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHostnameConfiguration_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHostnameConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["Certificate"] = gen.PtrOf(CertificateInformation_STATUSGenerator())
}

func Test_RemotePrivateEndpointConnectionWrapper_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RemotePrivateEndpointConnectionWrapper_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRemotePrivateEndpointConnectionWrapper_STATUS, RemotePrivateEndpointConnectionWrapper_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRemotePrivateEndpointConnectionWrapper_STATUS runs a test to see if a specific instance of RemotePrivateEndpointConnectionWrapper_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRemotePrivateEndpointConnectionWrapper_STATUS(subject RemotePrivateEndpointConnectionWrapper_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RemotePrivateEndpointConnectionWrapper_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RemotePrivateEndpointConnectionWrapper_STATUS instances for property testing - lazily instantiated by
// RemotePrivateEndpointConnectionWrapper_STATUSGenerator()
var remotePrivateEndpointConnectionWrapper_STATUSGenerator gopter.Gen

// RemotePrivateEndpointConnectionWrapper_STATUSGenerator returns a generator of RemotePrivateEndpointConnectionWrapper_STATUS instances for property testing.
// We first initialize remotePrivateEndpointConnectionWrapper_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RemotePrivateEndpointConnectionWrapper_STATUSGenerator() gopter.Gen {
	if remotePrivateEndpointConnectionWrapper_STATUSGenerator != nil {
		return remotePrivateEndpointConnectionWrapper_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRemotePrivateEndpointConnectionWrapper_STATUS(generators)
	remotePrivateEndpointConnectionWrapper_STATUSGenerator = gen.Struct(reflect.TypeOf(RemotePrivateEndpointConnectionWrapper_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRemotePrivateEndpointConnectionWrapper_STATUS(generators)
	AddRelatedPropertyGeneratorsForRemotePrivateEndpointConnectionWrapper_STATUS(generators)
	remotePrivateEndpointConnectionWrapper_STATUSGenerator = gen.Struct(reflect.TypeOf(RemotePrivateEndpointConnectionWrapper_STATUS{}), generators)

	return remotePrivateEndpointConnectionWrapper_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRemotePrivateEndpointConnectionWrapper_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRemotePrivateEndpointConnectionWrapper_STATUS(gens map[string]gopter.Gen) {
	gens["GroupIds"] = gen.SliceOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForRemotePrivateEndpointConnectionWrapper_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRemotePrivateEndpointConnectionWrapper_STATUS(gens map[string]gopter.Gen) {
	gens["PrivateEndpoint"] = gen.PtrOf(ArmIdWrapper_STATUSGenerator())
	gens["PrivateLinkServiceConnectionState"] = gen.PtrOf(PrivateLinkServiceConnectionState_STATUSGenerator())
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkConfiguration, VirtualNetworkConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkConfiguration runs a test to see if a specific instance of VirtualNetworkConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkConfiguration(subject VirtualNetworkConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkConfiguration instances for property testing - lazily instantiated by
// VirtualNetworkConfigurationGenerator()
var virtualNetworkConfigurationGenerator gopter.Gen

// VirtualNetworkConfigurationGenerator returns a generator of VirtualNetworkConfiguration instances for property testing.
func VirtualNetworkConfigurationGenerator() gopter.Gen {
	if virtualNetworkConfigurationGenerator != nil {
		return virtualNetworkConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	virtualNetworkConfigurationGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkConfiguration{}), generators)

	return virtualNetworkConfigurationGenerator
}

func Test_VirtualNetworkConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkConfiguration_STATUS, VirtualNetworkConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkConfiguration_STATUS runs a test to see if a specific instance of VirtualNetworkConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkConfiguration_STATUS(subject VirtualNetworkConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkConfiguration_STATUS instances for property testing - lazily instantiated by
// VirtualNetworkConfiguration_STATUSGenerator()
var virtualNetworkConfiguration_STATUSGenerator gopter.Gen

// VirtualNetworkConfiguration_STATUSGenerator returns a generator of VirtualNetworkConfiguration_STATUS instances for property testing.
func VirtualNetworkConfiguration_STATUSGenerator() gopter.Gen {
	if virtualNetworkConfiguration_STATUSGenerator != nil {
		return virtualNetworkConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkConfiguration_STATUS(generators)
	virtualNetworkConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkConfiguration_STATUS{}), generators)

	return virtualNetworkConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["SubnetResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Subnetname"] = gen.PtrOf(gen.AlphaString())
	gens["Vnetid"] = gen.PtrOf(gen.AlphaString())
}

func Test_ArmIdWrapper_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ArmIdWrapper_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForArmIdWrapper_STATUS, ArmIdWrapper_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForArmIdWrapper_STATUS runs a test to see if a specific instance of ArmIdWrapper_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForArmIdWrapper_STATUS(subject ArmIdWrapper_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ArmIdWrapper_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ArmIdWrapper_STATUS instances for property testing - lazily instantiated by
// ArmIdWrapper_STATUSGenerator()
var armIdWrapper_STATUSGenerator gopter.Gen

// ArmIdWrapper_STATUSGenerator returns a generator of ArmIdWrapper_STATUS instances for property testing.
func ArmIdWrapper_STATUSGenerator() gopter.Gen {
	if armIdWrapper_STATUSGenerator != nil {
		return armIdWrapper_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForArmIdWrapper_STATUS(generators)
	armIdWrapper_STATUSGenerator = gen.Struct(reflect.TypeOf(ArmIdWrapper_STATUS{}), generators)

	return armIdWrapper_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForArmIdWrapper_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForArmIdWrapper_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_CertificateInformation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CertificateInformation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCertificateInformation, CertificateInformationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCertificateInformation runs a test to see if a specific instance of CertificateInformation round trips to JSON and back losslessly
func RunJSONSerializationTestForCertificateInformation(subject CertificateInformation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CertificateInformation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CertificateInformation instances for property testing - lazily instantiated by
// CertificateInformationGenerator()
var certificateInformationGenerator gopter.Gen

// CertificateInformationGenerator returns a generator of CertificateInformation instances for property testing.
func CertificateInformationGenerator() gopter.Gen {
	if certificateInformationGenerator != nil {
		return certificateInformationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateInformation(generators)
	certificateInformationGenerator = gen.Struct(reflect.TypeOf(CertificateInformation{}), generators)

	return certificateInformationGenerator
}

// AddIndependentPropertyGeneratorsForCertificateInformation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCertificateInformation(gens map[string]gopter.Gen) {
	gens["Expiry"] = gen.PtrOf(gen.AlphaString())
	gens["Subject"] = gen.PtrOf(gen.AlphaString())
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
}

func Test_CertificateInformation_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CertificateInformation_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCertificateInformation_STATUS, CertificateInformation_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCertificateInformation_STATUS runs a test to see if a specific instance of CertificateInformation_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCertificateInformation_STATUS(subject CertificateInformation_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CertificateInformation_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CertificateInformation_STATUS instances for property testing - lazily instantiated by
// CertificateInformation_STATUSGenerator()
var certificateInformation_STATUSGenerator gopter.Gen

// CertificateInformation_STATUSGenerator returns a generator of CertificateInformation_STATUS instances for property testing.
func CertificateInformation_STATUSGenerator() gopter.Gen {
	if certificateInformation_STATUSGenerator != nil {
		return certificateInformation_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateInformation_STATUS(generators)
	certificateInformation_STATUSGenerator = gen.Struct(reflect.TypeOf(CertificateInformation_STATUS{}), generators)

	return certificateInformation_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCertificateInformation_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCertificateInformation_STATUS(gens map[string]gopter.Gen) {
	gens["Expiry"] = gen.PtrOf(gen.AlphaString())
	gens["Subject"] = gen.PtrOf(gen.AlphaString())
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateLinkServiceConnectionState_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkServiceConnectionState_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkServiceConnectionState_STATUS, PrivateLinkServiceConnectionState_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkServiceConnectionState_STATUS runs a test to see if a specific instance of PrivateLinkServiceConnectionState_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkServiceConnectionState_STATUS(subject PrivateLinkServiceConnectionState_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkServiceConnectionState_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkServiceConnectionState_STATUS instances for property testing - lazily instantiated by
// PrivateLinkServiceConnectionState_STATUSGenerator()
var privateLinkServiceConnectionState_STATUSGenerator gopter.Gen

// PrivateLinkServiceConnectionState_STATUSGenerator returns a generator of PrivateLinkServiceConnectionState_STATUS instances for property testing.
func PrivateLinkServiceConnectionState_STATUSGenerator() gopter.Gen {
	if privateLinkServiceConnectionState_STATUSGenerator != nil {
		return privateLinkServiceConnectionState_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionState_STATUS(generators)
	privateLinkServiceConnectionState_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateLinkServiceConnectionState_STATUS{}), generators)

	return privateLinkServiceConnectionState_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionState_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkServiceConnectionState_STATUS(gens map[string]gopter.Gen) {
	gens["ActionsRequired"] = gen.PtrOf(gen.AlphaString())
	gens["Description"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_UserIdentityProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserIdentityProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserIdentityProperties_STATUS, UserIdentityProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserIdentityProperties_STATUS runs a test to see if a specific instance of UserIdentityProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserIdentityProperties_STATUS(subject UserIdentityProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserIdentityProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserIdentityProperties_STATUS instances for property testing - lazily instantiated by
// UserIdentityProperties_STATUSGenerator()
var userIdentityProperties_STATUSGenerator gopter.Gen

// UserIdentityProperties_STATUSGenerator returns a generator of UserIdentityProperties_STATUS instances for property testing.
func UserIdentityProperties_STATUSGenerator() gopter.Gen {
	if userIdentityProperties_STATUSGenerator != nil {
		return userIdentityProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserIdentityProperties_STATUS(generators)
	userIdentityProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(UserIdentityProperties_STATUS{}), generators)

	return userIdentityProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserIdentityProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserIdentityProperties_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}
