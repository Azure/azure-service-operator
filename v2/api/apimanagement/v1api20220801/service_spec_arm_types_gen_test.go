// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220801

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AdditionalLocation_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalLocation_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalLocation_ARM, AdditionalLocation_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalLocation_ARM runs a test to see if a specific instance of AdditionalLocation_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalLocation_ARM(subject AdditionalLocation_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalLocation_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalLocation_ARM instances for property testing - lazily instantiated by
// AdditionalLocation_ARMGenerator()
var additionalLocation_ARMGenerator gopter.Gen

// AdditionalLocation_ARMGenerator returns a generator of AdditionalLocation_ARM instances for property testing.
// We first initialize additionalLocation_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AdditionalLocation_ARMGenerator() gopter.Gen {
	if additionalLocation_ARMGenerator != nil {
		return additionalLocation_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalLocation_ARM(generators)
	additionalLocation_ARMGenerator = gen.Struct(reflect.TypeOf(AdditionalLocation_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalLocation_ARM(generators)
	AddRelatedPropertyGeneratorsForAdditionalLocation_ARM(generators)
	additionalLocation_ARMGenerator = gen.Struct(reflect.TypeOf(AdditionalLocation_ARM{}), generators)

	return additionalLocation_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalLocation_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalLocation_ARM(gens map[string]gopter.Gen) {
	gens["DisableGateway"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NatGatewayState"] = gen.PtrOf(gen.OneConstOf(AdditionalLocation_NatGatewayState_Disabled, AdditionalLocation_NatGatewayState_Enabled))
	gens["PublicIpAddressId"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAdditionalLocation_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdditionalLocation_ARM(gens map[string]gopter.Gen) {
	gens["Sku"] = gen.PtrOf(ApiManagementServiceSkuProperties_ARMGenerator())
	gens["VirtualNetworkConfiguration"] = gen.PtrOf(VirtualNetworkConfiguration_ARMGenerator())
}

func Test_ApiManagementServiceIdentity_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementServiceIdentity_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementServiceIdentity_ARM, ApiManagementServiceIdentity_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementServiceIdentity_ARM runs a test to see if a specific instance of ApiManagementServiceIdentity_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementServiceIdentity_ARM(subject ApiManagementServiceIdentity_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementServiceIdentity_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementServiceIdentity_ARM instances for property testing - lazily instantiated by
// ApiManagementServiceIdentity_ARMGenerator()
var apiManagementServiceIdentity_ARMGenerator gopter.Gen

// ApiManagementServiceIdentity_ARMGenerator returns a generator of ApiManagementServiceIdentity_ARM instances for property testing.
// We first initialize apiManagementServiceIdentity_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiManagementServiceIdentity_ARMGenerator() gopter.Gen {
	if apiManagementServiceIdentity_ARMGenerator != nil {
		return apiManagementServiceIdentity_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceIdentity_ARM(generators)
	apiManagementServiceIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceIdentity_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceIdentity_ARM(generators)
	AddRelatedPropertyGeneratorsForApiManagementServiceIdentity_ARM(generators)
	apiManagementServiceIdentity_ARMGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceIdentity_ARM{}), generators)

	return apiManagementServiceIdentity_ARMGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementServiceIdentity_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementServiceIdentity_ARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ApiManagementServiceIdentity_Type_None,
		ApiManagementServiceIdentity_Type_SystemAssigned,
		ApiManagementServiceIdentity_Type_SystemAssignedUserAssigned,
		ApiManagementServiceIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForApiManagementServiceIdentity_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiManagementServiceIdentity_ARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentityDetails_ARMGenerator())
}

func Test_ApiManagementServiceProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementServiceProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementServiceProperties_ARM, ApiManagementServiceProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementServiceProperties_ARM runs a test to see if a specific instance of ApiManagementServiceProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementServiceProperties_ARM(subject ApiManagementServiceProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementServiceProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementServiceProperties_ARM instances for property testing - lazily instantiated by
// ApiManagementServiceProperties_ARMGenerator()
var apiManagementServiceProperties_ARMGenerator gopter.Gen

// ApiManagementServiceProperties_ARMGenerator returns a generator of ApiManagementServiceProperties_ARM instances for property testing.
// We first initialize apiManagementServiceProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiManagementServiceProperties_ARMGenerator() gopter.Gen {
	if apiManagementServiceProperties_ARMGenerator != nil {
		return apiManagementServiceProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceProperties_ARM(generators)
	apiManagementServiceProperties_ARMGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForApiManagementServiceProperties_ARM(generators)
	apiManagementServiceProperties_ARMGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceProperties_ARM{}), generators)

	return apiManagementServiceProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementServiceProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementServiceProperties_ARM(gens map[string]gopter.Gen) {
	gens["CustomProperties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["DisableGateway"] = gen.PtrOf(gen.Bool())
	gens["EnableClientCertificate"] = gen.PtrOf(gen.Bool())
	gens["NatGatewayState"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_NatGatewayState_Disabled, ApiManagementServiceProperties_NatGatewayState_Enabled))
	gens["NotificationSenderEmail"] = gen.PtrOf(gen.AlphaString())
	gens["PublicIpAddressId"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_PublicNetworkAccess_Disabled, ApiManagementServiceProperties_PublicNetworkAccess_Enabled))
	gens["PublisherEmail"] = gen.PtrOf(gen.AlphaString())
	gens["PublisherName"] = gen.PtrOf(gen.AlphaString())
	gens["Restore"] = gen.PtrOf(gen.Bool())
	gens["VirtualNetworkType"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_VirtualNetworkType_External, ApiManagementServiceProperties_VirtualNetworkType_Internal, ApiManagementServiceProperties_VirtualNetworkType_None))
}

// AddRelatedPropertyGeneratorsForApiManagementServiceProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiManagementServiceProperties_ARM(gens map[string]gopter.Gen) {
	gens["AdditionalLocations"] = gen.SliceOf(AdditionalLocation_ARMGenerator())
	gens["ApiVersionConstraint"] = gen.PtrOf(ApiVersionConstraint_ARMGenerator())
	gens["Certificates"] = gen.SliceOf(CertificateConfiguration_ARMGenerator())
	gens["HostnameConfigurations"] = gen.SliceOf(HostnameConfiguration_ARMGenerator())
	gens["VirtualNetworkConfiguration"] = gen.PtrOf(VirtualNetworkConfiguration_ARMGenerator())
}

func Test_ApiManagementServiceSkuProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementServiceSkuProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementServiceSkuProperties_ARM, ApiManagementServiceSkuProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementServiceSkuProperties_ARM runs a test to see if a specific instance of ApiManagementServiceSkuProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementServiceSkuProperties_ARM(subject ApiManagementServiceSkuProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementServiceSkuProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementServiceSkuProperties_ARM instances for property testing - lazily instantiated by
// ApiManagementServiceSkuProperties_ARMGenerator()
var apiManagementServiceSkuProperties_ARMGenerator gopter.Gen

// ApiManagementServiceSkuProperties_ARMGenerator returns a generator of ApiManagementServiceSkuProperties_ARM instances for property testing.
func ApiManagementServiceSkuProperties_ARMGenerator() gopter.Gen {
	if apiManagementServiceSkuProperties_ARMGenerator != nil {
		return apiManagementServiceSkuProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties_ARM(generators)
	apiManagementServiceSkuProperties_ARMGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceSkuProperties_ARM{}), generators)

	return apiManagementServiceSkuProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties_ARM(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		ApiManagementServiceSkuProperties_Name_Basic,
		ApiManagementServiceSkuProperties_Name_Consumption,
		ApiManagementServiceSkuProperties_Name_Developer,
		ApiManagementServiceSkuProperties_Name_Isolated,
		ApiManagementServiceSkuProperties_Name_Premium,
		ApiManagementServiceSkuProperties_Name_Standard))
}

func Test_ApiVersionConstraint_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiVersionConstraint_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiVersionConstraint_ARM, ApiVersionConstraint_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiVersionConstraint_ARM runs a test to see if a specific instance of ApiVersionConstraint_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiVersionConstraint_ARM(subject ApiVersionConstraint_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiVersionConstraint_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiVersionConstraint_ARM instances for property testing - lazily instantiated by
// ApiVersionConstraint_ARMGenerator()
var apiVersionConstraint_ARMGenerator gopter.Gen

// ApiVersionConstraint_ARMGenerator returns a generator of ApiVersionConstraint_ARM instances for property testing.
func ApiVersionConstraint_ARMGenerator() gopter.Gen {
	if apiVersionConstraint_ARMGenerator != nil {
		return apiVersionConstraint_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiVersionConstraint_ARM(generators)
	apiVersionConstraint_ARMGenerator = gen.Struct(reflect.TypeOf(ApiVersionConstraint_ARM{}), generators)

	return apiVersionConstraint_ARMGenerator
}

// AddIndependentPropertyGeneratorsForApiVersionConstraint_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiVersionConstraint_ARM(gens map[string]gopter.Gen) {
	gens["MinApiVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_CertificateConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CertificateConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCertificateConfiguration_ARM, CertificateConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCertificateConfiguration_ARM runs a test to see if a specific instance of CertificateConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCertificateConfiguration_ARM(subject CertificateConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CertificateConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CertificateConfiguration_ARM instances for property testing - lazily instantiated by
// CertificateConfiguration_ARMGenerator()
var certificateConfiguration_ARMGenerator gopter.Gen

// CertificateConfiguration_ARMGenerator returns a generator of CertificateConfiguration_ARM instances for property testing.
// We first initialize certificateConfiguration_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CertificateConfiguration_ARMGenerator() gopter.Gen {
	if certificateConfiguration_ARMGenerator != nil {
		return certificateConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateConfiguration_ARM(generators)
	certificateConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(CertificateConfiguration_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateConfiguration_ARM(generators)
	AddRelatedPropertyGeneratorsForCertificateConfiguration_ARM(generators)
	certificateConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(CertificateConfiguration_ARM{}), generators)

	return certificateConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCertificateConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCertificateConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["CertificatePassword"] = gen.PtrOf(gen.AlphaString())
	gens["EncodedCertificate"] = gen.PtrOf(gen.AlphaString())
	gens["StoreName"] = gen.PtrOf(gen.OneConstOf(CertificateConfiguration_StoreName_CertificateAuthority, CertificateConfiguration_StoreName_Root))
}

// AddRelatedPropertyGeneratorsForCertificateConfiguration_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCertificateConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["Certificate"] = gen.PtrOf(CertificateInformation_ARMGenerator())
}

func Test_CertificateInformation_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CertificateInformation_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCertificateInformation_ARM, CertificateInformation_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCertificateInformation_ARM runs a test to see if a specific instance of CertificateInformation_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCertificateInformation_ARM(subject CertificateInformation_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CertificateInformation_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CertificateInformation_ARM instances for property testing - lazily instantiated by
// CertificateInformation_ARMGenerator()
var certificateInformation_ARMGenerator gopter.Gen

// CertificateInformation_ARMGenerator returns a generator of CertificateInformation_ARM instances for property testing.
func CertificateInformation_ARMGenerator() gopter.Gen {
	if certificateInformation_ARMGenerator != nil {
		return certificateInformation_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateInformation_ARM(generators)
	certificateInformation_ARMGenerator = gen.Struct(reflect.TypeOf(CertificateInformation_ARM{}), generators)

	return certificateInformation_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCertificateInformation_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCertificateInformation_ARM(gens map[string]gopter.Gen) {
	gens["Expiry"] = gen.PtrOf(gen.AlphaString())
	gens["Subject"] = gen.PtrOf(gen.AlphaString())
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
}

func Test_HostnameConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostnameConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostnameConfiguration_ARM, HostnameConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostnameConfiguration_ARM runs a test to see if a specific instance of HostnameConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHostnameConfiguration_ARM(subject HostnameConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostnameConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostnameConfiguration_ARM instances for property testing - lazily instantiated by
// HostnameConfiguration_ARMGenerator()
var hostnameConfiguration_ARMGenerator gopter.Gen

// HostnameConfiguration_ARMGenerator returns a generator of HostnameConfiguration_ARM instances for property testing.
// We first initialize hostnameConfiguration_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HostnameConfiguration_ARMGenerator() gopter.Gen {
	if hostnameConfiguration_ARMGenerator != nil {
		return hostnameConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostnameConfiguration_ARM(generators)
	hostnameConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(HostnameConfiguration_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostnameConfiguration_ARM(generators)
	AddRelatedPropertyGeneratorsForHostnameConfiguration_ARM(generators)
	hostnameConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(HostnameConfiguration_ARM{}), generators)

	return hostnameConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHostnameConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostnameConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["CertificatePassword"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateSource"] = gen.PtrOf(gen.OneConstOf(
		HostnameConfiguration_CertificateSource_BuiltIn,
		HostnameConfiguration_CertificateSource_Custom,
		HostnameConfiguration_CertificateSource_KeyVault,
		HostnameConfiguration_CertificateSource_Managed))
	gens["CertificateStatus"] = gen.PtrOf(gen.OneConstOf(HostnameConfiguration_CertificateStatus_Completed, HostnameConfiguration_CertificateStatus_Failed, HostnameConfiguration_CertificateStatus_InProgress))
	gens["DefaultSslBinding"] = gen.PtrOf(gen.Bool())
	gens["EncodedCertificate"] = gen.PtrOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultId"] = gen.PtrOf(gen.AlphaString())
	gens["NegotiateClientCertificate"] = gen.PtrOf(gen.Bool())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		HostnameConfiguration_Type_DeveloperPortal,
		HostnameConfiguration_Type_Management,
		HostnameConfiguration_Type_Portal,
		HostnameConfiguration_Type_Proxy,
		HostnameConfiguration_Type_Scm))
}

// AddRelatedPropertyGeneratorsForHostnameConfiguration_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHostnameConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["Certificate"] = gen.PtrOf(CertificateInformation_ARMGenerator())
}

func Test_Service_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Service_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForService_Spec_ARM, Service_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForService_Spec_ARM runs a test to see if a specific instance of Service_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForService_Spec_ARM(subject Service_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Service_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Service_Spec_ARM instances for property testing - lazily instantiated by Service_Spec_ARMGenerator()
var service_Spec_ARMGenerator gopter.Gen

// Service_Spec_ARMGenerator returns a generator of Service_Spec_ARM instances for property testing.
// We first initialize service_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Service_Spec_ARMGenerator() gopter.Gen {
	if service_Spec_ARMGenerator != nil {
		return service_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService_Spec_ARM(generators)
	service_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Service_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForService_Spec_ARM(generators)
	service_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Service_Spec_ARM{}), generators)

	return service_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForService_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForService_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForService_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForService_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ApiManagementServiceIdentity_ARMGenerator())
	gens["Properties"] = gen.PtrOf(ApiManagementServiceProperties_ARMGenerator())
	gens["Sku"] = gen.PtrOf(ApiManagementServiceSkuProperties_ARMGenerator())
}

func Test_UserAssignedIdentityDetails_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails_ARM, UserAssignedIdentityDetails_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails_ARM runs a test to see if a specific instance of UserAssignedIdentityDetails_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails_ARM(subject UserAssignedIdentityDetails_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails_ARM instances for property testing - lazily instantiated by
// UserAssignedIdentityDetails_ARMGenerator()
var userAssignedIdentityDetails_ARMGenerator gopter.Gen

// UserAssignedIdentityDetails_ARMGenerator returns a generator of UserAssignedIdentityDetails_ARM instances for property testing.
func UserAssignedIdentityDetails_ARMGenerator() gopter.Gen {
	if userAssignedIdentityDetails_ARMGenerator != nil {
		return userAssignedIdentityDetails_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetails_ARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails_ARM{}), generators)

	return userAssignedIdentityDetails_ARMGenerator
}

func Test_VirtualNetworkConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkConfiguration_ARM, VirtualNetworkConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkConfiguration_ARM runs a test to see if a specific instance of VirtualNetworkConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkConfiguration_ARM(subject VirtualNetworkConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkConfiguration_ARM instances for property testing - lazily instantiated by
// VirtualNetworkConfiguration_ARMGenerator()
var virtualNetworkConfiguration_ARMGenerator gopter.Gen

// VirtualNetworkConfiguration_ARMGenerator returns a generator of VirtualNetworkConfiguration_ARM instances for property testing.
func VirtualNetworkConfiguration_ARMGenerator() gopter.Gen {
	if virtualNetworkConfiguration_ARMGenerator != nil {
		return virtualNetworkConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkConfiguration_ARM(generators)
	virtualNetworkConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkConfiguration_ARM{}), generators)

	return virtualNetworkConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["SubnetResourceId"] = gen.PtrOf(gen.AlphaString())
}
