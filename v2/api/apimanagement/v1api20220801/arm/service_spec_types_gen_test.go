// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AdditionalLocation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdditionalLocation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdditionalLocation, AdditionalLocationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdditionalLocation runs a test to see if a specific instance of AdditionalLocation round trips to JSON and back losslessly
func RunJSONSerializationTestForAdditionalLocation(subject AdditionalLocation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdditionalLocation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdditionalLocation instances for property testing - lazily instantiated by AdditionalLocationGenerator()
var additionalLocationGenerator gopter.Gen

// AdditionalLocationGenerator returns a generator of AdditionalLocation instances for property testing.
// We first initialize additionalLocationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AdditionalLocationGenerator() gopter.Gen {
	if additionalLocationGenerator != nil {
		return additionalLocationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalLocation(generators)
	additionalLocationGenerator = gen.Struct(reflect.TypeOf(AdditionalLocation{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdditionalLocation(generators)
	AddRelatedPropertyGeneratorsForAdditionalLocation(generators)
	additionalLocationGenerator = gen.Struct(reflect.TypeOf(AdditionalLocation{}), generators)

	return additionalLocationGenerator
}

// AddIndependentPropertyGeneratorsForAdditionalLocation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdditionalLocation(gens map[string]gopter.Gen) {
	gens["DisableGateway"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NatGatewayState"] = gen.PtrOf(gen.OneConstOf(AdditionalLocation_NatGatewayState_Disabled, AdditionalLocation_NatGatewayState_Enabled))
	gens["PublicIpAddressId"] = gen.PtrOf(gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAdditionalLocation is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdditionalLocation(gens map[string]gopter.Gen) {
	gens["Sku"] = gen.PtrOf(ApiManagementServiceSkuPropertiesGenerator())
	gens["VirtualNetworkConfiguration"] = gen.PtrOf(VirtualNetworkConfigurationGenerator())
}

func Test_ApiManagementServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementServiceIdentity, ApiManagementServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementServiceIdentity runs a test to see if a specific instance of ApiManagementServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementServiceIdentity(subject ApiManagementServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementServiceIdentity instances for property testing - lazily instantiated by
// ApiManagementServiceIdentityGenerator()
var apiManagementServiceIdentityGenerator gopter.Gen

// ApiManagementServiceIdentityGenerator returns a generator of ApiManagementServiceIdentity instances for property testing.
// We first initialize apiManagementServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiManagementServiceIdentityGenerator() gopter.Gen {
	if apiManagementServiceIdentityGenerator != nil {
		return apiManagementServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceIdentity(generators)
	apiManagementServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForApiManagementServiceIdentity(generators)
	apiManagementServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceIdentity{}), generators)

	return apiManagementServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ApiManagementServiceIdentity_Type_None,
		ApiManagementServiceIdentity_Type_SystemAssigned,
		ApiManagementServiceIdentity_Type_SystemAssignedUserAssigned,
		ApiManagementServiceIdentity_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForApiManagementServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiManagementServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentityDetailsGenerator())
}

func Test_ApiManagementServiceProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementServiceProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementServiceProperties, ApiManagementServicePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementServiceProperties runs a test to see if a specific instance of ApiManagementServiceProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementServiceProperties(subject ApiManagementServiceProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementServiceProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementServiceProperties instances for property testing - lazily instantiated by
// ApiManagementServicePropertiesGenerator()
var apiManagementServicePropertiesGenerator gopter.Gen

// ApiManagementServicePropertiesGenerator returns a generator of ApiManagementServiceProperties instances for property testing.
// We first initialize apiManagementServicePropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ApiManagementServicePropertiesGenerator() gopter.Gen {
	if apiManagementServicePropertiesGenerator != nil {
		return apiManagementServicePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceProperties(generators)
	apiManagementServicePropertiesGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceProperties(generators)
	AddRelatedPropertyGeneratorsForApiManagementServiceProperties(generators)
	apiManagementServicePropertiesGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceProperties{}), generators)

	return apiManagementServicePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementServiceProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementServiceProperties(gens map[string]gopter.Gen) {
	gens["CustomProperties"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["DisableGateway"] = gen.PtrOf(gen.Bool())
	gens["EnableClientCertificate"] = gen.PtrOf(gen.Bool())
	gens["NatGatewayState"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_NatGatewayState_Disabled, ApiManagementServiceProperties_NatGatewayState_Enabled))
	gens["NotificationSenderEmail"] = gen.PtrOf(gen.AlphaString())
	gens["PublicIpAddressId"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_PublicNetworkAccess_Disabled, ApiManagementServiceProperties_PublicNetworkAccess_Enabled))
	gens["PublisherEmail"] = gen.PtrOf(gen.AlphaString())
	gens["PublisherName"] = gen.PtrOf(gen.AlphaString())
	gens["Restore"] = gen.PtrOf(gen.Bool())
	gens["VirtualNetworkType"] = gen.PtrOf(gen.OneConstOf(ApiManagementServiceProperties_VirtualNetworkType_External, ApiManagementServiceProperties_VirtualNetworkType_Internal, ApiManagementServiceProperties_VirtualNetworkType_None))
}

// AddRelatedPropertyGeneratorsForApiManagementServiceProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForApiManagementServiceProperties(gens map[string]gopter.Gen) {
	gens["AdditionalLocations"] = gen.SliceOf(AdditionalLocationGenerator())
	gens["ApiVersionConstraint"] = gen.PtrOf(ApiVersionConstraintGenerator())
	gens["Certificates"] = gen.SliceOf(CertificateConfigurationGenerator())
	gens["HostnameConfigurations"] = gen.SliceOf(HostnameConfigurationGenerator())
	gens["VirtualNetworkConfiguration"] = gen.PtrOf(VirtualNetworkConfigurationGenerator())
}

func Test_ApiManagementServiceSkuProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiManagementServiceSkuProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiManagementServiceSkuProperties, ApiManagementServiceSkuPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiManagementServiceSkuProperties runs a test to see if a specific instance of ApiManagementServiceSkuProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForApiManagementServiceSkuProperties(subject ApiManagementServiceSkuProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiManagementServiceSkuProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiManagementServiceSkuProperties instances for property testing - lazily instantiated by
// ApiManagementServiceSkuPropertiesGenerator()
var apiManagementServiceSkuPropertiesGenerator gopter.Gen

// ApiManagementServiceSkuPropertiesGenerator returns a generator of ApiManagementServiceSkuProperties instances for property testing.
func ApiManagementServiceSkuPropertiesGenerator() gopter.Gen {
	if apiManagementServiceSkuPropertiesGenerator != nil {
		return apiManagementServiceSkuPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties(generators)
	apiManagementServiceSkuPropertiesGenerator = gen.Struct(reflect.TypeOf(ApiManagementServiceSkuProperties{}), generators)

	return apiManagementServiceSkuPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiManagementServiceSkuProperties(gens map[string]gopter.Gen) {
	gens["Capacity"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		ApiManagementServiceSkuProperties_Name_Basic,
		ApiManagementServiceSkuProperties_Name_Consumption,
		ApiManagementServiceSkuProperties_Name_Developer,
		ApiManagementServiceSkuProperties_Name_Isolated,
		ApiManagementServiceSkuProperties_Name_Premium,
		ApiManagementServiceSkuProperties_Name_Standard))
}

func Test_ApiVersionConstraint_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiVersionConstraint via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiVersionConstraint, ApiVersionConstraintGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiVersionConstraint runs a test to see if a specific instance of ApiVersionConstraint round trips to JSON and back losslessly
func RunJSONSerializationTestForApiVersionConstraint(subject ApiVersionConstraint) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiVersionConstraint
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiVersionConstraint instances for property testing - lazily instantiated by
// ApiVersionConstraintGenerator()
var apiVersionConstraintGenerator gopter.Gen

// ApiVersionConstraintGenerator returns a generator of ApiVersionConstraint instances for property testing.
func ApiVersionConstraintGenerator() gopter.Gen {
	if apiVersionConstraintGenerator != nil {
		return apiVersionConstraintGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiVersionConstraint(generators)
	apiVersionConstraintGenerator = gen.Struct(reflect.TypeOf(ApiVersionConstraint{}), generators)

	return apiVersionConstraintGenerator
}

// AddIndependentPropertyGeneratorsForApiVersionConstraint is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiVersionConstraint(gens map[string]gopter.Gen) {
	gens["MinApiVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_CertificateConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CertificateConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCertificateConfiguration, CertificateConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCertificateConfiguration runs a test to see if a specific instance of CertificateConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForCertificateConfiguration(subject CertificateConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CertificateConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CertificateConfiguration instances for property testing - lazily instantiated by
// CertificateConfigurationGenerator()
var certificateConfigurationGenerator gopter.Gen

// CertificateConfigurationGenerator returns a generator of CertificateConfiguration instances for property testing.
// We first initialize certificateConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CertificateConfigurationGenerator() gopter.Gen {
	if certificateConfigurationGenerator != nil {
		return certificateConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateConfiguration(generators)
	certificateConfigurationGenerator = gen.Struct(reflect.TypeOf(CertificateConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateConfiguration(generators)
	AddRelatedPropertyGeneratorsForCertificateConfiguration(generators)
	certificateConfigurationGenerator = gen.Struct(reflect.TypeOf(CertificateConfiguration{}), generators)

	return certificateConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForCertificateConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCertificateConfiguration(gens map[string]gopter.Gen) {
	gens["CertificatePassword"] = gen.PtrOf(gen.AlphaString())
	gens["EncodedCertificate"] = gen.PtrOf(gen.AlphaString())
	gens["StoreName"] = gen.PtrOf(gen.OneConstOf(CertificateConfiguration_StoreName_CertificateAuthority, CertificateConfiguration_StoreName_Root))
}

// AddRelatedPropertyGeneratorsForCertificateConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCertificateConfiguration(gens map[string]gopter.Gen) {
	gens["Certificate"] = gen.PtrOf(CertificateInformationGenerator())
}

func Test_CertificateInformation_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CertificateInformation via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCertificateInformation, CertificateInformationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCertificateInformation runs a test to see if a specific instance of CertificateInformation round trips to JSON and back losslessly
func RunJSONSerializationTestForCertificateInformation(subject CertificateInformation) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CertificateInformation
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CertificateInformation instances for property testing - lazily instantiated by
// CertificateInformationGenerator()
var certificateInformationGenerator gopter.Gen

// CertificateInformationGenerator returns a generator of CertificateInformation instances for property testing.
func CertificateInformationGenerator() gopter.Gen {
	if certificateInformationGenerator != nil {
		return certificateInformationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCertificateInformation(generators)
	certificateInformationGenerator = gen.Struct(reflect.TypeOf(CertificateInformation{}), generators)

	return certificateInformationGenerator
}

// AddIndependentPropertyGeneratorsForCertificateInformation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCertificateInformation(gens map[string]gopter.Gen) {
	gens["Expiry"] = gen.PtrOf(gen.AlphaString())
	gens["Subject"] = gen.PtrOf(gen.AlphaString())
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
}

func Test_HostnameConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostnameConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostnameConfiguration, HostnameConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostnameConfiguration runs a test to see if a specific instance of HostnameConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForHostnameConfiguration(subject HostnameConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostnameConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostnameConfiguration instances for property testing - lazily instantiated by
// HostnameConfigurationGenerator()
var hostnameConfigurationGenerator gopter.Gen

// HostnameConfigurationGenerator returns a generator of HostnameConfiguration instances for property testing.
// We first initialize hostnameConfigurationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HostnameConfigurationGenerator() gopter.Gen {
	if hostnameConfigurationGenerator != nil {
		return hostnameConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostnameConfiguration(generators)
	hostnameConfigurationGenerator = gen.Struct(reflect.TypeOf(HostnameConfiguration{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostnameConfiguration(generators)
	AddRelatedPropertyGeneratorsForHostnameConfiguration(generators)
	hostnameConfigurationGenerator = gen.Struct(reflect.TypeOf(HostnameConfiguration{}), generators)

	return hostnameConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForHostnameConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostnameConfiguration(gens map[string]gopter.Gen) {
	gens["CertificatePassword"] = gen.PtrOf(gen.AlphaString())
	gens["CertificateSource"] = gen.PtrOf(gen.OneConstOf(
		HostnameConfiguration_CertificateSource_BuiltIn,
		HostnameConfiguration_CertificateSource_Custom,
		HostnameConfiguration_CertificateSource_KeyVault,
		HostnameConfiguration_CertificateSource_Managed))
	gens["CertificateStatus"] = gen.PtrOf(gen.OneConstOf(HostnameConfiguration_CertificateStatus_Completed, HostnameConfiguration_CertificateStatus_Failed, HostnameConfiguration_CertificateStatus_InProgress))
	gens["DefaultSslBinding"] = gen.PtrOf(gen.Bool())
	gens["EncodedCertificate"] = gen.PtrOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["IdentityClientId"] = gen.PtrOf(gen.AlphaString())
	gens["KeyVaultId"] = gen.PtrOf(gen.AlphaString())
	gens["NegotiateClientCertificate"] = gen.PtrOf(gen.Bool())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		HostnameConfiguration_Type_DeveloperPortal,
		HostnameConfiguration_Type_Management,
		HostnameConfiguration_Type_Portal,
		HostnameConfiguration_Type_Proxy,
		HostnameConfiguration_Type_Scm))
}

// AddRelatedPropertyGeneratorsForHostnameConfiguration is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHostnameConfiguration(gens map[string]gopter.Gen) {
	gens["Certificate"] = gen.PtrOf(CertificateInformationGenerator())
}

func Test_Service_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Service_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForService_Spec, Service_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForService_Spec runs a test to see if a specific instance of Service_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForService_Spec(subject Service_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Service_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Service_Spec instances for property testing - lazily instantiated by Service_SpecGenerator()
var service_SpecGenerator gopter.Gen

// Service_SpecGenerator returns a generator of Service_Spec instances for property testing.
// We first initialize service_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Service_SpecGenerator() gopter.Gen {
	if service_SpecGenerator != nil {
		return service_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService_Spec(generators)
	service_SpecGenerator = gen.Struct(reflect.TypeOf(Service_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForService_Spec(generators)
	AddRelatedPropertyGeneratorsForService_Spec(generators)
	service_SpecGenerator = gen.Struct(reflect.TypeOf(Service_Spec{}), generators)

	return service_SpecGenerator
}

// AddIndependentPropertyGeneratorsForService_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForService_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Zones"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForService_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForService_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ApiManagementServiceIdentityGenerator())
	gens["Properties"] = gen.PtrOf(ApiManagementServicePropertiesGenerator())
	gens["Sku"] = gen.PtrOf(ApiManagementServiceSkuPropertiesGenerator())
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_VirtualNetworkConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkConfiguration, VirtualNetworkConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkConfiguration runs a test to see if a specific instance of VirtualNetworkConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkConfiguration(subject VirtualNetworkConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkConfiguration instances for property testing - lazily instantiated by
// VirtualNetworkConfigurationGenerator()
var virtualNetworkConfigurationGenerator gopter.Gen

// VirtualNetworkConfigurationGenerator returns a generator of VirtualNetworkConfiguration instances for property testing.
func VirtualNetworkConfigurationGenerator() gopter.Gen {
	if virtualNetworkConfigurationGenerator != nil {
		return virtualNetworkConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkConfiguration(generators)
	virtualNetworkConfigurationGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkConfiguration{}), generators)

	return virtualNetworkConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkConfiguration(gens map[string]gopter.Gen) {
	gens["SubnetResourceId"] = gen.PtrOf(gen.AlphaString())
}
