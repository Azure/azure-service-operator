// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20200601

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_EventSubscription_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscription_SpecARM, EventSubscription_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscription_SpecARM runs a test to see if a specific instance of EventSubscription_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscription_SpecARM(subject EventSubscription_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription_SpecARM instances for property testing - lazily instantiated by
// EventSubscription_SpecARMGenerator()
var eventSubscription_SpecARMGenerator gopter.Gen

// EventSubscription_SpecARMGenerator returns a generator of EventSubscription_SpecARM instances for property testing.
// We first initialize eventSubscription_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscription_SpecARMGenerator() gopter.Gen {
	if eventSubscription_SpecARMGenerator != nil {
		return eventSubscription_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_SpecARM(generators)
	eventSubscription_SpecARMGenerator = gen.Struct(reflect.TypeOf(EventSubscription_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_SpecARM(generators)
	AddRelatedPropertyGeneratorsForEventSubscription_SpecARM(generators)
	eventSubscription_SpecARMGenerator = gen.Struct(reflect.TypeOf(EventSubscription_SpecARM{}), generators)

	return eventSubscription_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscription_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscription_SpecARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscription_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscription_SpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(EventSubscriptionPropertiesARMGenerator())
}

func Test_EventSubscriptionPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionPropertiesARM, EventSubscriptionPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionPropertiesARM runs a test to see if a specific instance of EventSubscriptionPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionPropertiesARM(subject EventSubscriptionPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionPropertiesARM instances for property testing - lazily instantiated by
// EventSubscriptionPropertiesARMGenerator()
var eventSubscriptionPropertiesARMGenerator gopter.Gen

// EventSubscriptionPropertiesARMGenerator returns a generator of EventSubscriptionPropertiesARM instances for property testing.
// We first initialize eventSubscriptionPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionPropertiesARMGenerator() gopter.Gen {
	if eventSubscriptionPropertiesARMGenerator != nil {
		return eventSubscriptionPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionPropertiesARM(generators)
	eventSubscriptionPropertiesARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionPropertiesARM(generators)
	eventSubscriptionPropertiesARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionPropertiesARM{}), generators)

	return eventSubscriptionPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionPropertiesARM(gens map[string]gopter.Gen) {
	gens["EventDeliverySchema"] = gen.PtrOf(gen.OneConstOf(EventSubscriptionProperties_EventDeliverySchema_CloudEventSchemaV1_0, EventSubscriptionProperties_EventDeliverySchema_CustomInputSchema, EventSubscriptionProperties_EventDeliverySchema_EventGridSchema))
	gens["ExpirationTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Labels"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionPropertiesARM(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(StorageBlobDeadLetterDestinationARMGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestinationARMGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilterARMGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicyARMGenerator())
}

func Test_EventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestinationARM, EventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestinationARM runs a test to see if a specific instance of EventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestinationARM(subject EventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// EventSubscriptionDestinationARMGenerator()
var eventSubscriptionDestinationARMGenerator gopter.Gen

// EventSubscriptionDestinationARMGenerator returns a generator of EventSubscriptionDestinationARM instances for property testing.
func EventSubscriptionDestinationARMGenerator() gopter.Gen {
	if eventSubscriptionDestinationARMGenerator != nil {
		return eventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEventSubscriptionDestinationARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(EventSubscriptionDestinationARM{}), map[string]gopter.Gen{
			propName: propGen,
		}))
	}
	eventSubscriptionDestinationARMGenerator = gen.OneGenOf(gens...)

	return eventSubscriptionDestinationARMGenerator
}

// AddRelatedPropertyGeneratorsForEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["AzureFunction"] = AzureFunctionEventSubscriptionDestinationARMGenerator().Map(func(it AzureFunctionEventSubscriptionDestinationARM) *AzureFunctionEventSubscriptionDestinationARM {
		return &it
	}) // generate one case for OneOf type
	gens["EventHub"] = EventHubEventSubscriptionDestinationARMGenerator().Map(func(it EventHubEventSubscriptionDestinationARM) *EventHubEventSubscriptionDestinationARM {
		return &it
	}) // generate one case for OneOf type
	gens["HybridConnection"] = HybridConnectionEventSubscriptionDestinationARMGenerator().Map(func(it HybridConnectionEventSubscriptionDestinationARM) *HybridConnectionEventSubscriptionDestinationARM {
		return &it
	}) // generate one case for OneOf type
	gens["ServiceBusQueue"] = ServiceBusQueueEventSubscriptionDestinationARMGenerator().Map(func(it ServiceBusQueueEventSubscriptionDestinationARM) *ServiceBusQueueEventSubscriptionDestinationARM {
		return &it
	}) // generate one case for OneOf type
	gens["ServiceBusTopic"] = ServiceBusTopicEventSubscriptionDestinationARMGenerator().Map(func(it ServiceBusTopicEventSubscriptionDestinationARM) *ServiceBusTopicEventSubscriptionDestinationARM {
		return &it
	}) // generate one case for OneOf type
	gens["StorageQueue"] = StorageQueueEventSubscriptionDestinationARMGenerator().Map(func(it StorageQueueEventSubscriptionDestinationARM) *StorageQueueEventSubscriptionDestinationARM {
		return &it
	}) // generate one case for OneOf type
	gens["WebHook"] = WebHookEventSubscriptionDestinationARMGenerator().Map(func(it WebHookEventSubscriptionDestinationARM) *WebHookEventSubscriptionDestinationARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_EventSubscriptionFilterARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionFilterARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilterARM, EventSubscriptionFilterARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilterARM runs a test to see if a specific instance of EventSubscriptionFilterARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilterARM(subject EventSubscriptionFilterARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionFilterARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionFilterARM instances for property testing - lazily instantiated by
// EventSubscriptionFilterARMGenerator()
var eventSubscriptionFilterARMGenerator gopter.Gen

// EventSubscriptionFilterARMGenerator returns a generator of EventSubscriptionFilterARM instances for property testing.
// We first initialize eventSubscriptionFilterARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilterARMGenerator() gopter.Gen {
	if eventSubscriptionFilterARMGenerator != nil {
		return eventSubscriptionFilterARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterARM(generators)
	eventSubscriptionFilterARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilterARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterARM(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilterARM(generators)
	eventSubscriptionFilterARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilterARM{}), generators)

	return eventSubscriptionFilterARMGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilterARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilterARM(gens map[string]gopter.Gen) {
	gens["IncludedEventTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IsSubjectCaseSensitive"] = gen.PtrOf(gen.Bool())
	gens["SubjectBeginsWith"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectEndsWith"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionFilterARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilterARM(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilterARMGenerator())
}

func Test_RetryPolicyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicyARM, RetryPolicyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicyARM runs a test to see if a specific instance of RetryPolicyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicyARM(subject RetryPolicyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicyARM instances for property testing - lazily instantiated by RetryPolicyARMGenerator()
var retryPolicyARMGenerator gopter.Gen

// RetryPolicyARMGenerator returns a generator of RetryPolicyARM instances for property testing.
func RetryPolicyARMGenerator() gopter.Gen {
	if retryPolicyARMGenerator != nil {
		return retryPolicyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicyARM(generators)
	retryPolicyARMGenerator = gen.Struct(reflect.TypeOf(RetryPolicyARM{}), generators)

	return retryPolicyARMGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicyARM(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_StorageBlobDeadLetterDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlobDeadLetterDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlobDeadLetterDestinationARM, StorageBlobDeadLetterDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlobDeadLetterDestinationARM runs a test to see if a specific instance of StorageBlobDeadLetterDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlobDeadLetterDestinationARM(subject StorageBlobDeadLetterDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlobDeadLetterDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlobDeadLetterDestinationARM instances for property testing - lazily instantiated by
// StorageBlobDeadLetterDestinationARMGenerator()
var storageBlobDeadLetterDestinationARMGenerator gopter.Gen

// StorageBlobDeadLetterDestinationARMGenerator returns a generator of StorageBlobDeadLetterDestinationARM instances for property testing.
// We first initialize storageBlobDeadLetterDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageBlobDeadLetterDestinationARMGenerator() gopter.Gen {
	if storageBlobDeadLetterDestinationARMGenerator != nil {
		return storageBlobDeadLetterDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationARM(generators)
	storageBlobDeadLetterDestinationARMGenerator = gen.Struct(reflect.TypeOf(StorageBlobDeadLetterDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationARM(generators)
	AddRelatedPropertyGeneratorsForStorageBlobDeadLetterDestinationARM(generators)
	storageBlobDeadLetterDestinationARMGenerator = gen.Struct(reflect.TypeOf(StorageBlobDeadLetterDestinationARM{}), generators)

	return storageBlobDeadLetterDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.PtrOf(gen.OneConstOf(StorageBlobDeadLetterDestination_EndpointType_StorageBlob))
}

// AddRelatedPropertyGeneratorsForStorageBlobDeadLetterDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageBlobDeadLetterDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(StorageBlobDeadLetterDestinationPropertiesARMGenerator())
}

func Test_AdvancedFilterARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilterARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterARM, AdvancedFilterARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterARM runs a test to see if a specific instance of AdvancedFilterARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterARM(subject AdvancedFilterARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilterARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilterARM instances for property testing - lazily instantiated by AdvancedFilterARMGenerator()
var advancedFilterARMGenerator gopter.Gen

// AdvancedFilterARMGenerator returns a generator of AdvancedFilterARM instances for property testing.
func AdvancedFilterARMGenerator() gopter.Gen {
	if advancedFilterARMGenerator != nil {
		return advancedFilterARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAdvancedFilterARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(AdvancedFilterARM{}), map[string]gopter.Gen{
			propName: propGen,
		}))
	}
	advancedFilterARMGenerator = gen.OneGenOf(gens...)

	return advancedFilterARMGenerator
}

// AddRelatedPropertyGeneratorsForAdvancedFilterARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdvancedFilterARM(gens map[string]gopter.Gen) {
	gens["BoolEquals"] = AdvancedFilter_BoolEqualsARMGenerator().Map(func(it AdvancedFilter_BoolEqualsARM) *AdvancedFilter_BoolEqualsARM {
		return &it
	}) // generate one case for OneOf type
	gens["NumberGreaterThan"] = AdvancedFilter_NumberGreaterThanARMGenerator().Map(func(it AdvancedFilter_NumberGreaterThanARM) *AdvancedFilter_NumberGreaterThanARM {
		return &it
	}) // generate one case for OneOf type
	gens["NumberGreaterThanOrEquals"] = AdvancedFilter_NumberGreaterThanOrEqualsARMGenerator().Map(func(it AdvancedFilter_NumberGreaterThanOrEqualsARM) *AdvancedFilter_NumberGreaterThanOrEqualsARM {
		return &it
	}) // generate one case for OneOf type
	gens["NumberIn"] = AdvancedFilter_NumberInARMGenerator().Map(func(it AdvancedFilter_NumberInARM) *AdvancedFilter_NumberInARM {
		return &it
	}) // generate one case for OneOf type
	gens["NumberLessThan"] = AdvancedFilter_NumberLessThanARMGenerator().Map(func(it AdvancedFilter_NumberLessThanARM) *AdvancedFilter_NumberLessThanARM {
		return &it
	}) // generate one case for OneOf type
	gens["NumberLessThanOrEquals"] = AdvancedFilter_NumberLessThanOrEqualsARMGenerator().Map(func(it AdvancedFilter_NumberLessThanOrEqualsARM) *AdvancedFilter_NumberLessThanOrEqualsARM {
		return &it
	}) // generate one case for OneOf type
	gens["NumberNotIn"] = AdvancedFilter_NumberNotInARMGenerator().Map(func(it AdvancedFilter_NumberNotInARM) *AdvancedFilter_NumberNotInARM {
		return &it
	}) // generate one case for OneOf type
	gens["StringBeginsWith"] = AdvancedFilter_StringBeginsWithARMGenerator().Map(func(it AdvancedFilter_StringBeginsWithARM) *AdvancedFilter_StringBeginsWithARM {
		return &it
	}) // generate one case for OneOf type
	gens["StringContains"] = AdvancedFilter_StringContainsARMGenerator().Map(func(it AdvancedFilter_StringContainsARM) *AdvancedFilter_StringContainsARM {
		return &it
	}) // generate one case for OneOf type
	gens["StringEndsWith"] = AdvancedFilter_StringEndsWithARMGenerator().Map(func(it AdvancedFilter_StringEndsWithARM) *AdvancedFilter_StringEndsWithARM {
		return &it
	}) // generate one case for OneOf type
	gens["StringIn"] = AdvancedFilter_StringInARMGenerator().Map(func(it AdvancedFilter_StringInARM) *AdvancedFilter_StringInARM {
		return &it
	}) // generate one case for OneOf type
	gens["StringNotIn"] = AdvancedFilter_StringNotInARMGenerator().Map(func(it AdvancedFilter_StringNotInARM) *AdvancedFilter_StringNotInARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_AzureFunctionEventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFunctionEventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationARM, AzureFunctionEventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationARM runs a test to see if a specific instance of AzureFunctionEventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationARM(subject AzureFunctionEventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFunctionEventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFunctionEventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// AzureFunctionEventSubscriptionDestinationARMGenerator()
var azureFunctionEventSubscriptionDestinationARMGenerator gopter.Gen

// AzureFunctionEventSubscriptionDestinationARMGenerator returns a generator of AzureFunctionEventSubscriptionDestinationARM instances for property testing.
// We first initialize azureFunctionEventSubscriptionDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFunctionEventSubscriptionDestinationARMGenerator() gopter.Gen {
	if azureFunctionEventSubscriptionDestinationARMGenerator != nil {
		return azureFunctionEventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationARM(generators)
	azureFunctionEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(AzureFunctionEventSubscriptionDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationARM(generators)
	AddRelatedPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationARM(generators)
	azureFunctionEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(AzureFunctionEventSubscriptionDestinationARM{}), generators)

	return azureFunctionEventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(AzureFunctionEventSubscriptionDestination_EndpointType_AzureFunction)
}

// AddRelatedPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AzureFunctionEventSubscriptionDestinationPropertiesARMGenerator())
}

func Test_EventHubEventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubEventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubEventSubscriptionDestinationARM, EventHubEventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubEventSubscriptionDestinationARM runs a test to see if a specific instance of EventHubEventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubEventSubscriptionDestinationARM(subject EventHubEventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubEventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubEventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// EventHubEventSubscriptionDestinationARMGenerator()
var eventHubEventSubscriptionDestinationARMGenerator gopter.Gen

// EventHubEventSubscriptionDestinationARMGenerator returns a generator of EventHubEventSubscriptionDestinationARM instances for property testing.
// We first initialize eventHubEventSubscriptionDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventHubEventSubscriptionDestinationARMGenerator() gopter.Gen {
	if eventHubEventSubscriptionDestinationARMGenerator != nil {
		return eventHubEventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationARM(generators)
	eventHubEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(EventHubEventSubscriptionDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationARM(generators)
	AddRelatedPropertyGeneratorsForEventHubEventSubscriptionDestinationARM(generators)
	eventHubEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(EventHubEventSubscriptionDestinationARM{}), generators)

	return eventHubEventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(EventHubEventSubscriptionDestination_EndpointType_EventHub)
}

// AddRelatedPropertyGeneratorsForEventHubEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventHubEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(EventHubEventSubscriptionDestinationPropertiesARMGenerator())
}

func Test_HybridConnectionEventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HybridConnectionEventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationARM, HybridConnectionEventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationARM runs a test to see if a specific instance of HybridConnectionEventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationARM(subject HybridConnectionEventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HybridConnectionEventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HybridConnectionEventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// HybridConnectionEventSubscriptionDestinationARMGenerator()
var hybridConnectionEventSubscriptionDestinationARMGenerator gopter.Gen

// HybridConnectionEventSubscriptionDestinationARMGenerator returns a generator of HybridConnectionEventSubscriptionDestinationARM instances for property testing.
// We first initialize hybridConnectionEventSubscriptionDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HybridConnectionEventSubscriptionDestinationARMGenerator() gopter.Gen {
	if hybridConnectionEventSubscriptionDestinationARMGenerator != nil {
		return hybridConnectionEventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationARM(generators)
	hybridConnectionEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(HybridConnectionEventSubscriptionDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationARM(generators)
	AddRelatedPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationARM(generators)
	hybridConnectionEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(HybridConnectionEventSubscriptionDestinationARM{}), generators)

	return hybridConnectionEventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(HybridConnectionEventSubscriptionDestination_EndpointType_HybridConnection)
}

// AddRelatedPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(HybridConnectionEventSubscriptionDestinationPropertiesARMGenerator())
}

func Test_ServiceBusQueueEventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusQueueEventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationARM, ServiceBusQueueEventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationARM runs a test to see if a specific instance of ServiceBusQueueEventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationARM(subject ServiceBusQueueEventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusQueueEventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusQueueEventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// ServiceBusQueueEventSubscriptionDestinationARMGenerator()
var serviceBusQueueEventSubscriptionDestinationARMGenerator gopter.Gen

// ServiceBusQueueEventSubscriptionDestinationARMGenerator returns a generator of ServiceBusQueueEventSubscriptionDestinationARM instances for property testing.
// We first initialize serviceBusQueueEventSubscriptionDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServiceBusQueueEventSubscriptionDestinationARMGenerator() gopter.Gen {
	if serviceBusQueueEventSubscriptionDestinationARMGenerator != nil {
		return serviceBusQueueEventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationARM(generators)
	serviceBusQueueEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(ServiceBusQueueEventSubscriptionDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationARM(generators)
	AddRelatedPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationARM(generators)
	serviceBusQueueEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(ServiceBusQueueEventSubscriptionDestinationARM{}), generators)

	return serviceBusQueueEventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(ServiceBusQueueEventSubscriptionDestination_EndpointType_ServiceBusQueue)
}

// AddRelatedPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ServiceBusQueueEventSubscriptionDestinationPropertiesARMGenerator())
}

func Test_ServiceBusTopicEventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusTopicEventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationARM, ServiceBusTopicEventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationARM runs a test to see if a specific instance of ServiceBusTopicEventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationARM(subject ServiceBusTopicEventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusTopicEventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusTopicEventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// ServiceBusTopicEventSubscriptionDestinationARMGenerator()
var serviceBusTopicEventSubscriptionDestinationARMGenerator gopter.Gen

// ServiceBusTopicEventSubscriptionDestinationARMGenerator returns a generator of ServiceBusTopicEventSubscriptionDestinationARM instances for property testing.
// We first initialize serviceBusTopicEventSubscriptionDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServiceBusTopicEventSubscriptionDestinationARMGenerator() gopter.Gen {
	if serviceBusTopicEventSubscriptionDestinationARMGenerator != nil {
		return serviceBusTopicEventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationARM(generators)
	serviceBusTopicEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(ServiceBusTopicEventSubscriptionDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationARM(generators)
	AddRelatedPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationARM(generators)
	serviceBusTopicEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(ServiceBusTopicEventSubscriptionDestinationARM{}), generators)

	return serviceBusTopicEventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(ServiceBusTopicEventSubscriptionDestination_EndpointType_ServiceBusTopic)
}

// AddRelatedPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ServiceBusTopicEventSubscriptionDestinationPropertiesARMGenerator())
}

func Test_StorageBlobDeadLetterDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlobDeadLetterDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlobDeadLetterDestinationPropertiesARM, StorageBlobDeadLetterDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlobDeadLetterDestinationPropertiesARM runs a test to see if a specific instance of StorageBlobDeadLetterDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlobDeadLetterDestinationPropertiesARM(subject StorageBlobDeadLetterDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlobDeadLetterDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlobDeadLetterDestinationPropertiesARM instances for property testing - lazily instantiated by
// StorageBlobDeadLetterDestinationPropertiesARMGenerator()
var storageBlobDeadLetterDestinationPropertiesARMGenerator gopter.Gen

// StorageBlobDeadLetterDestinationPropertiesARMGenerator returns a generator of StorageBlobDeadLetterDestinationPropertiesARM instances for property testing.
func StorageBlobDeadLetterDestinationPropertiesARMGenerator() gopter.Gen {
	if storageBlobDeadLetterDestinationPropertiesARMGenerator != nil {
		return storageBlobDeadLetterDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationPropertiesARM(generators)
	storageBlobDeadLetterDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(StorageBlobDeadLetterDestinationPropertiesARM{}), generators)

	return storageBlobDeadLetterDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["BlobContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageQueueEventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageQueueEventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationARM, StorageQueueEventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationARM runs a test to see if a specific instance of StorageQueueEventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationARM(subject StorageQueueEventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageQueueEventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageQueueEventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// StorageQueueEventSubscriptionDestinationARMGenerator()
var storageQueueEventSubscriptionDestinationARMGenerator gopter.Gen

// StorageQueueEventSubscriptionDestinationARMGenerator returns a generator of StorageQueueEventSubscriptionDestinationARM instances for property testing.
// We first initialize storageQueueEventSubscriptionDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageQueueEventSubscriptionDestinationARMGenerator() gopter.Gen {
	if storageQueueEventSubscriptionDestinationARMGenerator != nil {
		return storageQueueEventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationARM(generators)
	storageQueueEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(StorageQueueEventSubscriptionDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationARM(generators)
	AddRelatedPropertyGeneratorsForStorageQueueEventSubscriptionDestinationARM(generators)
	storageQueueEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(StorageQueueEventSubscriptionDestinationARM{}), generators)

	return storageQueueEventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(StorageQueueEventSubscriptionDestination_EndpointType_StorageQueue)
}

// AddRelatedPropertyGeneratorsForStorageQueueEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageQueueEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(StorageQueueEventSubscriptionDestinationPropertiesARMGenerator())
}

func Test_WebHookEventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebHookEventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebHookEventSubscriptionDestinationARM, WebHookEventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebHookEventSubscriptionDestinationARM runs a test to see if a specific instance of WebHookEventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebHookEventSubscriptionDestinationARM(subject WebHookEventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebHookEventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebHookEventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// WebHookEventSubscriptionDestinationARMGenerator()
var webHookEventSubscriptionDestinationARMGenerator gopter.Gen

// WebHookEventSubscriptionDestinationARMGenerator returns a generator of WebHookEventSubscriptionDestinationARM instances for property testing.
// We first initialize webHookEventSubscriptionDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebHookEventSubscriptionDestinationARMGenerator() gopter.Gen {
	if webHookEventSubscriptionDestinationARMGenerator != nil {
		return webHookEventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationARM(generators)
	webHookEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(WebHookEventSubscriptionDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationARM(generators)
	AddRelatedPropertyGeneratorsForWebHookEventSubscriptionDestinationARM(generators)
	webHookEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(WebHookEventSubscriptionDestinationARM{}), generators)

	return webHookEventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(WebHookEventSubscriptionDestination_EndpointType_WebHook)
}

// AddRelatedPropertyGeneratorsForWebHookEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebHookEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(WebHookEventSubscriptionDestinationPropertiesARMGenerator())
}

func Test_AdvancedFilter_BoolEqualsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_BoolEqualsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_BoolEqualsARM, AdvancedFilter_BoolEqualsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_BoolEqualsARM runs a test to see if a specific instance of AdvancedFilter_BoolEqualsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_BoolEqualsARM(subject AdvancedFilter_BoolEqualsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_BoolEqualsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_BoolEqualsARM instances for property testing - lazily instantiated by
// AdvancedFilter_BoolEqualsARMGenerator()
var advancedFilter_BoolEqualsARMGenerator gopter.Gen

// AdvancedFilter_BoolEqualsARMGenerator returns a generator of AdvancedFilter_BoolEqualsARM instances for property testing.
func AdvancedFilter_BoolEqualsARMGenerator() gopter.Gen {
	if advancedFilter_BoolEqualsARMGenerator != nil {
		return advancedFilter_BoolEqualsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_BoolEqualsARM(generators)
	advancedFilter_BoolEqualsARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_BoolEqualsARM{}), generators)

	return advancedFilter_BoolEqualsARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_BoolEqualsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_BoolEqualsARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilter_BoolEquals_OperatorType_BoolEquals)
	gens["Value"] = gen.PtrOf(gen.Bool())
}

func Test_AdvancedFilter_NumberGreaterThanARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_NumberGreaterThanARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_NumberGreaterThanARM, AdvancedFilter_NumberGreaterThanARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_NumberGreaterThanARM runs a test to see if a specific instance of AdvancedFilter_NumberGreaterThanARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_NumberGreaterThanARM(subject AdvancedFilter_NumberGreaterThanARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_NumberGreaterThanARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_NumberGreaterThanARM instances for property testing - lazily instantiated by
// AdvancedFilter_NumberGreaterThanARMGenerator()
var advancedFilter_NumberGreaterThanARMGenerator gopter.Gen

// AdvancedFilter_NumberGreaterThanARMGenerator returns a generator of AdvancedFilter_NumberGreaterThanARM instances for property testing.
func AdvancedFilter_NumberGreaterThanARMGenerator() gopter.Gen {
	if advancedFilter_NumberGreaterThanARMGenerator != nil {
		return advancedFilter_NumberGreaterThanARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_NumberGreaterThanARM(generators)
	advancedFilter_NumberGreaterThanARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_NumberGreaterThanARM{}), generators)

	return advancedFilter_NumberGreaterThanARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_NumberGreaterThanARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_NumberGreaterThanARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilter_NumberGreaterThan_OperatorType_NumberGreaterThan)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_AdvancedFilter_NumberGreaterThanOrEqualsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_NumberGreaterThanOrEqualsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_NumberGreaterThanOrEqualsARM, AdvancedFilter_NumberGreaterThanOrEqualsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_NumberGreaterThanOrEqualsARM runs a test to see if a specific instance of AdvancedFilter_NumberGreaterThanOrEqualsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_NumberGreaterThanOrEqualsARM(subject AdvancedFilter_NumberGreaterThanOrEqualsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_NumberGreaterThanOrEqualsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_NumberGreaterThanOrEqualsARM instances for property testing - lazily instantiated by
// AdvancedFilter_NumberGreaterThanOrEqualsARMGenerator()
var advancedFilter_NumberGreaterThanOrEqualsARMGenerator gopter.Gen

// AdvancedFilter_NumberGreaterThanOrEqualsARMGenerator returns a generator of AdvancedFilter_NumberGreaterThanOrEqualsARM instances for property testing.
func AdvancedFilter_NumberGreaterThanOrEqualsARMGenerator() gopter.Gen {
	if advancedFilter_NumberGreaterThanOrEqualsARMGenerator != nil {
		return advancedFilter_NumberGreaterThanOrEqualsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_NumberGreaterThanOrEqualsARM(generators)
	advancedFilter_NumberGreaterThanOrEqualsARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_NumberGreaterThanOrEqualsARM{}), generators)

	return advancedFilter_NumberGreaterThanOrEqualsARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_NumberGreaterThanOrEqualsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_NumberGreaterThanOrEqualsARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilter_NumberGreaterThanOrEquals_OperatorType_NumberGreaterThanOrEquals)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_AdvancedFilter_NumberInARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_NumberInARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_NumberInARM, AdvancedFilter_NumberInARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_NumberInARM runs a test to see if a specific instance of AdvancedFilter_NumberInARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_NumberInARM(subject AdvancedFilter_NumberInARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_NumberInARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_NumberInARM instances for property testing - lazily instantiated by
// AdvancedFilter_NumberInARMGenerator()
var advancedFilter_NumberInARMGenerator gopter.Gen

// AdvancedFilter_NumberInARMGenerator returns a generator of AdvancedFilter_NumberInARM instances for property testing.
func AdvancedFilter_NumberInARMGenerator() gopter.Gen {
	if advancedFilter_NumberInARMGenerator != nil {
		return advancedFilter_NumberInARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_NumberInARM(generators)
	advancedFilter_NumberInARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_NumberInARM{}), generators)

	return advancedFilter_NumberInARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_NumberInARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_NumberInARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilter_NumberIn_OperatorType_NumberIn)
	gens["Values"] = gen.SliceOf(gen.Float64())
}

func Test_AdvancedFilter_NumberLessThanARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_NumberLessThanARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_NumberLessThanARM, AdvancedFilter_NumberLessThanARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_NumberLessThanARM runs a test to see if a specific instance of AdvancedFilter_NumberLessThanARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_NumberLessThanARM(subject AdvancedFilter_NumberLessThanARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_NumberLessThanARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_NumberLessThanARM instances for property testing - lazily instantiated by
// AdvancedFilter_NumberLessThanARMGenerator()
var advancedFilter_NumberLessThanARMGenerator gopter.Gen

// AdvancedFilter_NumberLessThanARMGenerator returns a generator of AdvancedFilter_NumberLessThanARM instances for property testing.
func AdvancedFilter_NumberLessThanARMGenerator() gopter.Gen {
	if advancedFilter_NumberLessThanARMGenerator != nil {
		return advancedFilter_NumberLessThanARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_NumberLessThanARM(generators)
	advancedFilter_NumberLessThanARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_NumberLessThanARM{}), generators)

	return advancedFilter_NumberLessThanARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_NumberLessThanARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_NumberLessThanARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilter_NumberLessThan_OperatorType_NumberLessThan)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_AdvancedFilter_NumberLessThanOrEqualsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_NumberLessThanOrEqualsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_NumberLessThanOrEqualsARM, AdvancedFilter_NumberLessThanOrEqualsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_NumberLessThanOrEqualsARM runs a test to see if a specific instance of AdvancedFilter_NumberLessThanOrEqualsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_NumberLessThanOrEqualsARM(subject AdvancedFilter_NumberLessThanOrEqualsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_NumberLessThanOrEqualsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_NumberLessThanOrEqualsARM instances for property testing - lazily instantiated by
// AdvancedFilter_NumberLessThanOrEqualsARMGenerator()
var advancedFilter_NumberLessThanOrEqualsARMGenerator gopter.Gen

// AdvancedFilter_NumberLessThanOrEqualsARMGenerator returns a generator of AdvancedFilter_NumberLessThanOrEqualsARM instances for property testing.
func AdvancedFilter_NumberLessThanOrEqualsARMGenerator() gopter.Gen {
	if advancedFilter_NumberLessThanOrEqualsARMGenerator != nil {
		return advancedFilter_NumberLessThanOrEqualsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_NumberLessThanOrEqualsARM(generators)
	advancedFilter_NumberLessThanOrEqualsARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_NumberLessThanOrEqualsARM{}), generators)

	return advancedFilter_NumberLessThanOrEqualsARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_NumberLessThanOrEqualsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_NumberLessThanOrEqualsARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilter_NumberLessThanOrEquals_OperatorType_NumberLessThanOrEquals)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_AdvancedFilter_NumberNotInARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_NumberNotInARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_NumberNotInARM, AdvancedFilter_NumberNotInARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_NumberNotInARM runs a test to see if a specific instance of AdvancedFilter_NumberNotInARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_NumberNotInARM(subject AdvancedFilter_NumberNotInARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_NumberNotInARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_NumberNotInARM instances for property testing - lazily instantiated by
// AdvancedFilter_NumberNotInARMGenerator()
var advancedFilter_NumberNotInARMGenerator gopter.Gen

// AdvancedFilter_NumberNotInARMGenerator returns a generator of AdvancedFilter_NumberNotInARM instances for property testing.
func AdvancedFilter_NumberNotInARMGenerator() gopter.Gen {
	if advancedFilter_NumberNotInARMGenerator != nil {
		return advancedFilter_NumberNotInARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_NumberNotInARM(generators)
	advancedFilter_NumberNotInARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_NumberNotInARM{}), generators)

	return advancedFilter_NumberNotInARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_NumberNotInARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_NumberNotInARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilter_NumberNotIn_OperatorType_NumberNotIn)
	gens["Values"] = gen.SliceOf(gen.Float64())
}

func Test_AdvancedFilter_StringBeginsWithARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_StringBeginsWithARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_StringBeginsWithARM, AdvancedFilter_StringBeginsWithARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_StringBeginsWithARM runs a test to see if a specific instance of AdvancedFilter_StringBeginsWithARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_StringBeginsWithARM(subject AdvancedFilter_StringBeginsWithARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_StringBeginsWithARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_StringBeginsWithARM instances for property testing - lazily instantiated by
// AdvancedFilter_StringBeginsWithARMGenerator()
var advancedFilter_StringBeginsWithARMGenerator gopter.Gen

// AdvancedFilter_StringBeginsWithARMGenerator returns a generator of AdvancedFilter_StringBeginsWithARM instances for property testing.
func AdvancedFilter_StringBeginsWithARMGenerator() gopter.Gen {
	if advancedFilter_StringBeginsWithARMGenerator != nil {
		return advancedFilter_StringBeginsWithARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_StringBeginsWithARM(generators)
	advancedFilter_StringBeginsWithARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_StringBeginsWithARM{}), generators)

	return advancedFilter_StringBeginsWithARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_StringBeginsWithARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_StringBeginsWithARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilter_StringBeginsWith_OperatorType_StringBeginsWith)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_AdvancedFilter_StringContainsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_StringContainsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_StringContainsARM, AdvancedFilter_StringContainsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_StringContainsARM runs a test to see if a specific instance of AdvancedFilter_StringContainsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_StringContainsARM(subject AdvancedFilter_StringContainsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_StringContainsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_StringContainsARM instances for property testing - lazily instantiated by
// AdvancedFilter_StringContainsARMGenerator()
var advancedFilter_StringContainsARMGenerator gopter.Gen

// AdvancedFilter_StringContainsARMGenerator returns a generator of AdvancedFilter_StringContainsARM instances for property testing.
func AdvancedFilter_StringContainsARMGenerator() gopter.Gen {
	if advancedFilter_StringContainsARMGenerator != nil {
		return advancedFilter_StringContainsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_StringContainsARM(generators)
	advancedFilter_StringContainsARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_StringContainsARM{}), generators)

	return advancedFilter_StringContainsARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_StringContainsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_StringContainsARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilter_StringContains_OperatorType_StringContains)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_AdvancedFilter_StringEndsWithARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_StringEndsWithARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_StringEndsWithARM, AdvancedFilter_StringEndsWithARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_StringEndsWithARM runs a test to see if a specific instance of AdvancedFilter_StringEndsWithARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_StringEndsWithARM(subject AdvancedFilter_StringEndsWithARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_StringEndsWithARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_StringEndsWithARM instances for property testing - lazily instantiated by
// AdvancedFilter_StringEndsWithARMGenerator()
var advancedFilter_StringEndsWithARMGenerator gopter.Gen

// AdvancedFilter_StringEndsWithARMGenerator returns a generator of AdvancedFilter_StringEndsWithARM instances for property testing.
func AdvancedFilter_StringEndsWithARMGenerator() gopter.Gen {
	if advancedFilter_StringEndsWithARMGenerator != nil {
		return advancedFilter_StringEndsWithARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_StringEndsWithARM(generators)
	advancedFilter_StringEndsWithARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_StringEndsWithARM{}), generators)

	return advancedFilter_StringEndsWithARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_StringEndsWithARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_StringEndsWithARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilter_StringEndsWith_OperatorType_StringEndsWith)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_AdvancedFilter_StringInARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_StringInARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_StringInARM, AdvancedFilter_StringInARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_StringInARM runs a test to see if a specific instance of AdvancedFilter_StringInARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_StringInARM(subject AdvancedFilter_StringInARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_StringInARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_StringInARM instances for property testing - lazily instantiated by
// AdvancedFilter_StringInARMGenerator()
var advancedFilter_StringInARMGenerator gopter.Gen

// AdvancedFilter_StringInARMGenerator returns a generator of AdvancedFilter_StringInARM instances for property testing.
func AdvancedFilter_StringInARMGenerator() gopter.Gen {
	if advancedFilter_StringInARMGenerator != nil {
		return advancedFilter_StringInARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_StringInARM(generators)
	advancedFilter_StringInARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_StringInARM{}), generators)

	return advancedFilter_StringInARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_StringInARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_StringInARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilter_StringIn_OperatorType_StringIn)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_AdvancedFilter_StringNotInARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_StringNotInARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_StringNotInARM, AdvancedFilter_StringNotInARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_StringNotInARM runs a test to see if a specific instance of AdvancedFilter_StringNotInARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_StringNotInARM(subject AdvancedFilter_StringNotInARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_StringNotInARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_StringNotInARM instances for property testing - lazily instantiated by
// AdvancedFilter_StringNotInARMGenerator()
var advancedFilter_StringNotInARMGenerator gopter.Gen

// AdvancedFilter_StringNotInARMGenerator returns a generator of AdvancedFilter_StringNotInARM instances for property testing.
func AdvancedFilter_StringNotInARMGenerator() gopter.Gen {
	if advancedFilter_StringNotInARMGenerator != nil {
		return advancedFilter_StringNotInARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_StringNotInARM(generators)
	advancedFilter_StringNotInARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_StringNotInARM{}), generators)

	return advancedFilter_StringNotInARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_StringNotInARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_StringNotInARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilter_StringNotIn_OperatorType_StringNotIn)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_AzureFunctionEventSubscriptionDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFunctionEventSubscriptionDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationPropertiesARM, AzureFunctionEventSubscriptionDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationPropertiesARM runs a test to see if a specific instance of AzureFunctionEventSubscriptionDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationPropertiesARM(subject AzureFunctionEventSubscriptionDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFunctionEventSubscriptionDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFunctionEventSubscriptionDestinationPropertiesARM instances for property testing - lazily
// instantiated by AzureFunctionEventSubscriptionDestinationPropertiesARMGenerator()
var azureFunctionEventSubscriptionDestinationPropertiesARMGenerator gopter.Gen

// AzureFunctionEventSubscriptionDestinationPropertiesARMGenerator returns a generator of AzureFunctionEventSubscriptionDestinationPropertiesARM instances for property testing.
func AzureFunctionEventSubscriptionDestinationPropertiesARMGenerator() gopter.Gen {
	if azureFunctionEventSubscriptionDestinationPropertiesARMGenerator != nil {
		return azureFunctionEventSubscriptionDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationPropertiesARM(generators)
	azureFunctionEventSubscriptionDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(AzureFunctionEventSubscriptionDestinationPropertiesARM{}), generators)

	return azureFunctionEventSubscriptionDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["MaxEventsPerBatch"] = gen.PtrOf(gen.Int())
	gens["PreferredBatchSizeInKilobytes"] = gen.PtrOf(gen.Int())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubEventSubscriptionDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubEventSubscriptionDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubEventSubscriptionDestinationPropertiesARM, EventHubEventSubscriptionDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubEventSubscriptionDestinationPropertiesARM runs a test to see if a specific instance of EventHubEventSubscriptionDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubEventSubscriptionDestinationPropertiesARM(subject EventHubEventSubscriptionDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubEventSubscriptionDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubEventSubscriptionDestinationPropertiesARM instances for property testing - lazily instantiated
// by EventHubEventSubscriptionDestinationPropertiesARMGenerator()
var eventHubEventSubscriptionDestinationPropertiesARMGenerator gopter.Gen

// EventHubEventSubscriptionDestinationPropertiesARMGenerator returns a generator of EventHubEventSubscriptionDestinationPropertiesARM instances for property testing.
func EventHubEventSubscriptionDestinationPropertiesARMGenerator() gopter.Gen {
	if eventHubEventSubscriptionDestinationPropertiesARMGenerator != nil {
		return eventHubEventSubscriptionDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationPropertiesARM(generators)
	eventHubEventSubscriptionDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(EventHubEventSubscriptionDestinationPropertiesARM{}), generators)

	return eventHubEventSubscriptionDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_HybridConnectionEventSubscriptionDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HybridConnectionEventSubscriptionDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationPropertiesARM, HybridConnectionEventSubscriptionDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationPropertiesARM runs a test to see if a specific instance of HybridConnectionEventSubscriptionDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationPropertiesARM(subject HybridConnectionEventSubscriptionDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HybridConnectionEventSubscriptionDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HybridConnectionEventSubscriptionDestinationPropertiesARM instances for property testing - lazily
// instantiated by HybridConnectionEventSubscriptionDestinationPropertiesARMGenerator()
var hybridConnectionEventSubscriptionDestinationPropertiesARMGenerator gopter.Gen

// HybridConnectionEventSubscriptionDestinationPropertiesARMGenerator returns a generator of HybridConnectionEventSubscriptionDestinationPropertiesARM instances for property testing.
func HybridConnectionEventSubscriptionDestinationPropertiesARMGenerator() gopter.Gen {
	if hybridConnectionEventSubscriptionDestinationPropertiesARMGenerator != nil {
		return hybridConnectionEventSubscriptionDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationPropertiesARM(generators)
	hybridConnectionEventSubscriptionDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(HybridConnectionEventSubscriptionDestinationPropertiesARM{}), generators)

	return hybridConnectionEventSubscriptionDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceBusQueueEventSubscriptionDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusQueueEventSubscriptionDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationPropertiesARM, ServiceBusQueueEventSubscriptionDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationPropertiesARM runs a test to see if a specific instance of ServiceBusQueueEventSubscriptionDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationPropertiesARM(subject ServiceBusQueueEventSubscriptionDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusQueueEventSubscriptionDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusQueueEventSubscriptionDestinationPropertiesARM instances for property testing - lazily
// instantiated by ServiceBusQueueEventSubscriptionDestinationPropertiesARMGenerator()
var serviceBusQueueEventSubscriptionDestinationPropertiesARMGenerator gopter.Gen

// ServiceBusQueueEventSubscriptionDestinationPropertiesARMGenerator returns a generator of ServiceBusQueueEventSubscriptionDestinationPropertiesARM instances for property testing.
func ServiceBusQueueEventSubscriptionDestinationPropertiesARMGenerator() gopter.Gen {
	if serviceBusQueueEventSubscriptionDestinationPropertiesARMGenerator != nil {
		return serviceBusQueueEventSubscriptionDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationPropertiesARM(generators)
	serviceBusQueueEventSubscriptionDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(ServiceBusQueueEventSubscriptionDestinationPropertiesARM{}), generators)

	return serviceBusQueueEventSubscriptionDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceBusTopicEventSubscriptionDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusTopicEventSubscriptionDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationPropertiesARM, ServiceBusTopicEventSubscriptionDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationPropertiesARM runs a test to see if a specific instance of ServiceBusTopicEventSubscriptionDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationPropertiesARM(subject ServiceBusTopicEventSubscriptionDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusTopicEventSubscriptionDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusTopicEventSubscriptionDestinationPropertiesARM instances for property testing - lazily
// instantiated by ServiceBusTopicEventSubscriptionDestinationPropertiesARMGenerator()
var serviceBusTopicEventSubscriptionDestinationPropertiesARMGenerator gopter.Gen

// ServiceBusTopicEventSubscriptionDestinationPropertiesARMGenerator returns a generator of ServiceBusTopicEventSubscriptionDestinationPropertiesARM instances for property testing.
func ServiceBusTopicEventSubscriptionDestinationPropertiesARMGenerator() gopter.Gen {
	if serviceBusTopicEventSubscriptionDestinationPropertiesARMGenerator != nil {
		return serviceBusTopicEventSubscriptionDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationPropertiesARM(generators)
	serviceBusTopicEventSubscriptionDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(ServiceBusTopicEventSubscriptionDestinationPropertiesARM{}), generators)

	return serviceBusTopicEventSubscriptionDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageQueueEventSubscriptionDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageQueueEventSubscriptionDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationPropertiesARM, StorageQueueEventSubscriptionDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationPropertiesARM runs a test to see if a specific instance of StorageQueueEventSubscriptionDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationPropertiesARM(subject StorageQueueEventSubscriptionDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageQueueEventSubscriptionDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageQueueEventSubscriptionDestinationPropertiesARM instances for property testing - lazily
// instantiated by StorageQueueEventSubscriptionDestinationPropertiesARMGenerator()
var storageQueueEventSubscriptionDestinationPropertiesARMGenerator gopter.Gen

// StorageQueueEventSubscriptionDestinationPropertiesARMGenerator returns a generator of StorageQueueEventSubscriptionDestinationPropertiesARM instances for property testing.
func StorageQueueEventSubscriptionDestinationPropertiesARMGenerator() gopter.Gen {
	if storageQueueEventSubscriptionDestinationPropertiesARMGenerator != nil {
		return storageQueueEventSubscriptionDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationPropertiesARM(generators)
	storageQueueEventSubscriptionDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(StorageQueueEventSubscriptionDestinationPropertiesARM{}), generators)

	return storageQueueEventSubscriptionDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["QueueName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebHookEventSubscriptionDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebHookEventSubscriptionDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebHookEventSubscriptionDestinationPropertiesARM, WebHookEventSubscriptionDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebHookEventSubscriptionDestinationPropertiesARM runs a test to see if a specific instance of WebHookEventSubscriptionDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebHookEventSubscriptionDestinationPropertiesARM(subject WebHookEventSubscriptionDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebHookEventSubscriptionDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebHookEventSubscriptionDestinationPropertiesARM instances for property testing - lazily instantiated by
// WebHookEventSubscriptionDestinationPropertiesARMGenerator()
var webHookEventSubscriptionDestinationPropertiesARMGenerator gopter.Gen

// WebHookEventSubscriptionDestinationPropertiesARMGenerator returns a generator of WebHookEventSubscriptionDestinationPropertiesARM instances for property testing.
func WebHookEventSubscriptionDestinationPropertiesARMGenerator() gopter.Gen {
	if webHookEventSubscriptionDestinationPropertiesARMGenerator != nil {
		return webHookEventSubscriptionDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationPropertiesARM(generators)
	webHookEventSubscriptionDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(WebHookEventSubscriptionDestinationPropertiesARM{}), generators)

	return webHookEventSubscriptionDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["AzureActiveDirectoryApplicationIdOrUri"] = gen.PtrOf(gen.AlphaString())
	gens["AzureActiveDirectoryTenantId"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUrl"] = gen.PtrOf(gen.AlphaString())
	gens["MaxEventsPerBatch"] = gen.PtrOf(gen.Int())
	gens["PreferredBatchSizeInKilobytes"] = gen.PtrOf(gen.Int())
}
