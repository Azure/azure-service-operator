// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20200601

import (
	"encoding/json"
	v20200601s "github.com/Azure/azure-service-operator/v2/api/eventgrid/v1beta20200601storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_EventSubscription_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscription to hub returns original",
		prop.ForAll(RunResourceConversionTestForEventSubscription, EventSubscriptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForEventSubscription tests if a specific instance of EventSubscription round trips to the hub storage version and back losslessly
func RunResourceConversionTestForEventSubscription(subject EventSubscription) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20200601s.EventSubscription
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual EventSubscription
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscription_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscription to EventSubscription via AssignPropertiesToEventSubscription & AssignPropertiesFromEventSubscription returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscription, EventSubscriptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscription tests if a specific instance of EventSubscription can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscription(subject EventSubscription) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20200601s.EventSubscription
	err := copied.AssignPropertiesToEventSubscription(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscription
	err = actual.AssignPropertiesFromEventSubscription(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscription_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscription, EventSubscriptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscription runs a test to see if a specific instance of EventSubscription round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscription(subject EventSubscription) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription instances for property testing - lazily instantiated by EventSubscriptionGenerator()
var eventSubscriptionGenerator gopter.Gen

// EventSubscriptionGenerator returns a generator of EventSubscription instances for property testing.
func EventSubscriptionGenerator() gopter.Gen {
	if eventSubscriptionGenerator != nil {
		return eventSubscriptionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEventSubscription(generators)
	eventSubscriptionGenerator = gen.Struct(reflect.TypeOf(EventSubscription{}), generators)

	return eventSubscriptionGenerator
}

// AddRelatedPropertyGeneratorsForEventSubscription is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscription(gens map[string]gopter.Gen) {
<<<<<<< HEAD
	gens["Spec"] = EventSubscription_SpecGenerator()
	gens["Status"] = EventSubscription_STATUSGenerator()
=======
	gens["Spec"] = EventSubscriptionsSpecGenerator()
	gens["Status"] = EventSubscriptionSTATUSGenerator()
>>>>>>> main
}

func Test_EventSubscription_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from EventSubscription_STATUS to EventSubscription_STATUS via AssignPropertiesToEventSubscription_STATUS & AssignPropertiesFromEventSubscription_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscription_STATUS, EventSubscription_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscription_STATUS tests if a specific instance of EventSubscription_STATUS can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscription_STATUS(subject EventSubscription_STATUS) string {
=======
		"Round trip from EventSubscription_STATUS to EventSubscription_STATUS via AssignPropertiesToEventSubscriptionSTATUS & AssignPropertiesFromEventSubscriptionSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionSTATUS, EventSubscriptionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionSTATUS tests if a specific instance of EventSubscription_STATUS can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionSTATUS(subject EventSubscription_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20200601s.EventSubscription_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToEventSubscription_STATUS(&other)
=======
	err := copied.AssignPropertiesToEventSubscriptionSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscription_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromEventSubscription_STATUS(&other)
=======
	err = actual.AssignPropertiesFromEventSubscriptionSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscription_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForEventSubscription_STATUS, EventSubscription_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscription_STATUS runs a test to see if a specific instance of EventSubscription_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscription_STATUS(subject EventSubscription_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionSTATUS, EventSubscriptionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionSTATUS runs a test to see if a specific instance of EventSubscription_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionSTATUS(subject EventSubscription_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// EventSubscription_STATUSGenerator()
var eventSubscription_STATUSGenerator gopter.Gen

// EventSubscription_STATUSGenerator returns a generator of EventSubscription_STATUS instances for property testing.
// We first initialize eventSubscription_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscription_STATUSGenerator() gopter.Gen {
	if eventSubscription_STATUSGenerator != nil {
		return eventSubscription_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_STATUS(generators)
	eventSubscription_STATUSGenerator = gen.Struct(reflect.TypeOf(EventSubscription_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_STATUS(generators)
	AddRelatedPropertyGeneratorsForEventSubscription_STATUS(generators)
	eventSubscription_STATUSGenerator = gen.Struct(reflect.TypeOf(EventSubscription_STATUS{}), generators)

	return eventSubscription_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscription_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscription_STATUS(gens map[string]gopter.Gen) {
	gens["EventDeliverySchema"] = gen.PtrOf(gen.OneConstOf(EventSubscriptionProperties_EventDeliverySchema_CloudEventSchemaV1_0_STATUS, EventSubscriptionProperties_EventDeliverySchema_CustomInputSchema_STATUS, EventSubscriptionProperties_EventDeliverySchema_EventGridSchema_STATUS))
=======
// EventSubscriptionSTATUSGenerator()
var eventSubscriptionSTATUSGenerator gopter.Gen

// EventSubscriptionSTATUSGenerator returns a generator of EventSubscription_STATUS instances for property testing.
// We first initialize eventSubscriptionSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionSTATUSGenerator() gopter.Gen {
	if eventSubscriptionSTATUSGenerator != nil {
		return eventSubscriptionSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionSTATUS(generators)
	eventSubscriptionSTATUSGenerator = gen.Struct(reflect.TypeOf(EventSubscription_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionSTATUS(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionSTATUS(generators)
	eventSubscriptionSTATUSGenerator = gen.Struct(reflect.TypeOf(EventSubscription_STATUS{}), generators)

	return eventSubscriptionSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionSTATUS(gens map[string]gopter.Gen) {
	gens["EventDeliverySchema"] = gen.PtrOf(gen.OneConstOf(EventSubscriptionPropertiesSTATUSEventDeliverySchema_CloudEventSchemaV10, EventSubscriptionPropertiesSTATUSEventDeliverySchema_CustomInputSchema, EventSubscriptionPropertiesSTATUSEventDeliverySchema_EventGridSchema))
>>>>>>> main
	gens["ExpirationTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Labels"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
<<<<<<< HEAD
		EventSubscriptionProperties_ProvisioningState_AwaitingManualAction_STATUS,
		EventSubscriptionProperties_ProvisioningState_Canceled_STATUS,
		EventSubscriptionProperties_ProvisioningState_Creating_STATUS,
		EventSubscriptionProperties_ProvisioningState_Deleting_STATUS,
		EventSubscriptionProperties_ProvisioningState_Failed_STATUS,
		EventSubscriptionProperties_ProvisioningState_Succeeded_STATUS,
		EventSubscriptionProperties_ProvisioningState_Updating_STATUS))
=======
		EventSubscriptionPropertiesSTATUSProvisioningState_AwaitingManualAction,
		EventSubscriptionPropertiesSTATUSProvisioningState_Canceled,
		EventSubscriptionPropertiesSTATUSProvisioningState_Creating,
		EventSubscriptionPropertiesSTATUSProvisioningState_Deleting,
		EventSubscriptionPropertiesSTATUSProvisioningState_Failed,
		EventSubscriptionPropertiesSTATUSProvisioningState_Succeeded,
		EventSubscriptionPropertiesSTATUSProvisioningState_Updating))
>>>>>>> main
	gens["Topic"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

<<<<<<< HEAD
// AddRelatedPropertyGeneratorsForEventSubscription_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscription_STATUS(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(DeadLetterDestination_STATUSGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestination_STATUSGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilter_STATUSGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicy_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
=======
// AddRelatedPropertyGeneratorsForEventSubscriptionSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionSTATUS(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(DeadLetterDestinationSTATUSGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestinationSTATUSGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilterSTATUSGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicySTATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSGenerator())
>>>>>>> main
}

func Test_EventSubscription_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscription_Spec to EventSubscription_Spec via AssignPropertiesToEventSubscription_Spec & AssignPropertiesFromEventSubscription_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscription_Spec, EventSubscription_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscription_Spec tests if a specific instance of EventSubscription_Spec can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscription_Spec(subject EventSubscription_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20200601s.EventSubscription_Spec
	err := copied.AssignPropertiesToEventSubscription_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscription_Spec
	err = actual.AssignPropertiesFromEventSubscription_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscription_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscription_Spec, EventSubscription_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscription_Spec runs a test to see if a specific instance of EventSubscription_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscription_Spec(subject EventSubscription_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription_Spec instances for property testing - lazily instantiated by
// EventSubscription_SpecGenerator()
var eventSubscription_SpecGenerator gopter.Gen

// EventSubscription_SpecGenerator returns a generator of EventSubscription_Spec instances for property testing.
// We first initialize eventSubscription_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscription_SpecGenerator() gopter.Gen {
	if eventSubscription_SpecGenerator != nil {
		return eventSubscription_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_Spec(generators)
	eventSubscription_SpecGenerator = gen.Struct(reflect.TypeOf(EventSubscription_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_Spec(generators)
	AddRelatedPropertyGeneratorsForEventSubscription_Spec(generators)
	eventSubscription_SpecGenerator = gen.Struct(reflect.TypeOf(EventSubscription_Spec{}), generators)

	return eventSubscription_SpecGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscription_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscription_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EventDeliverySchema"] = gen.PtrOf(gen.OneConstOf(EventSubscriptionProperties_EventDeliverySchema_CloudEventSchemaV1_0, EventSubscriptionProperties_EventDeliverySchema_CustomInputSchema, EventSubscriptionProperties_EventDeliverySchema_EventGridSchema))
	gens["ExpirationTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Labels"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscription_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscription_Spec(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(DeadLetterDestinationGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestinationGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilterGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicyGenerator())
}

<<<<<<< HEAD
func Test_DeadLetterDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
=======
func Test_DeadLetterDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
>>>>>>> main
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from DeadLetterDestination to DeadLetterDestination via AssignPropertiesToDeadLetterDestination & AssignPropertiesFromDeadLetterDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeadLetterDestination, DeadLetterDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeadLetterDestination tests if a specific instance of DeadLetterDestination can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForDeadLetterDestination(subject DeadLetterDestination) string {
=======
		"Round trip from DeadLetterDestination_STATUS to DeadLetterDestination_STATUS via AssignPropertiesToDeadLetterDestinationSTATUS & AssignPropertiesFromDeadLetterDestinationSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeadLetterDestinationSTATUS, DeadLetterDestinationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeadLetterDestinationSTATUS tests if a specific instance of DeadLetterDestination_STATUS can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForDeadLetterDestinationSTATUS(subject DeadLetterDestination_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
<<<<<<< HEAD
	var other v20200601s.DeadLetterDestination
	err := copied.AssignPropertiesToDeadLetterDestination(&other)
=======
	var other v20200601s.DeadLetterDestination_STATUS
	err := copied.AssignPropertiesToDeadLetterDestinationSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
<<<<<<< HEAD
	var actual DeadLetterDestination
	err = actual.AssignPropertiesFromDeadLetterDestination(&other)
=======
	var actual DeadLetterDestination_STATUS
	err = actual.AssignPropertiesFromDeadLetterDestinationSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
func Test_DeadLetterDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
=======
func Test_DeadLetterDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
>>>>>>> main
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip of DeadLetterDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeadLetterDestination, DeadLetterDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeadLetterDestination runs a test to see if a specific instance of DeadLetterDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForDeadLetterDestination(subject DeadLetterDestination) string {
=======
		"Round trip of DeadLetterDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeadLetterDestinationSTATUS, DeadLetterDestinationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeadLetterDestinationSTATUS runs a test to see if a specific instance of DeadLetterDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeadLetterDestinationSTATUS(subject DeadLetterDestination_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
<<<<<<< HEAD
	var actual DeadLetterDestination
=======
	var actual DeadLetterDestination_STATUS
>>>>>>> main
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

<<<<<<< HEAD
// Generator of DeadLetterDestination instances for property testing - lazily instantiated by
// DeadLetterDestinationGenerator()
var deadLetterDestinationGenerator gopter.Gen

// DeadLetterDestinationGenerator returns a generator of DeadLetterDestination instances for property testing.
func DeadLetterDestinationGenerator() gopter.Gen {
	if deadLetterDestinationGenerator != nil {
		return deadLetterDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeadLetterDestination(generators)
	deadLetterDestinationGenerator = gen.Struct(reflect.TypeOf(DeadLetterDestination{}), generators)

	return deadLetterDestinationGenerator
}

// AddIndependentPropertyGeneratorsForDeadLetterDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeadLetterDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.PtrOf(gen.OneConstOf(DeadLetterDestination_EndpointType_StorageBlob))
}

func Test_DeadLetterDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeadLetterDestination_STATUS to DeadLetterDestination_STATUS via AssignPropertiesToDeadLetterDestination_STATUS & AssignPropertiesFromDeadLetterDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeadLetterDestination_STATUS, DeadLetterDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeadLetterDestination_STATUS tests if a specific instance of DeadLetterDestination_STATUS can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForDeadLetterDestination_STATUS(subject DeadLetterDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20200601s.DeadLetterDestination_STATUS
	err := copied.AssignPropertiesToDeadLetterDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeadLetterDestination_STATUS
	err = actual.AssignPropertiesFromDeadLetterDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeadLetterDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeadLetterDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeadLetterDestination_STATUS, DeadLetterDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeadLetterDestination_STATUS runs a test to see if a specific instance of DeadLetterDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeadLetterDestination_STATUS(subject DeadLetterDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeadLetterDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeadLetterDestination_STATUS instances for property testing - lazily instantiated by
// DeadLetterDestination_STATUSGenerator()
var deadLetterDestination_STATUSGenerator gopter.Gen

// DeadLetterDestination_STATUSGenerator returns a generator of DeadLetterDestination_STATUS instances for property testing.
func DeadLetterDestination_STATUSGenerator() gopter.Gen {
	if deadLetterDestination_STATUSGenerator != nil {
		return deadLetterDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeadLetterDestination_STATUS(generators)
	deadLetterDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(DeadLetterDestination_STATUS{}), generators)

	return deadLetterDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeadLetterDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeadLetterDestination_STATUS(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.PtrOf(gen.OneConstOf(DeadLetterDestination_EndpointType_StorageBlob_STATUS))
=======
// Generator of DeadLetterDestination_STATUS instances for property testing - lazily instantiated by
// DeadLetterDestinationSTATUSGenerator()
var deadLetterDestinationSTATUSGenerator gopter.Gen

// DeadLetterDestinationSTATUSGenerator returns a generator of DeadLetterDestination_STATUS instances for property testing.
func DeadLetterDestinationSTATUSGenerator() gopter.Gen {
	if deadLetterDestinationSTATUSGenerator != nil {
		return deadLetterDestinationSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeadLetterDestinationSTATUS(generators)
	deadLetterDestinationSTATUSGenerator = gen.Struct(reflect.TypeOf(DeadLetterDestination_STATUS{}), generators)

	return deadLetterDestinationSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeadLetterDestinationSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeadLetterDestinationSTATUS(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.PtrOf(gen.OneConstOf(DeadLetterDestinationSTATUSEndpointType_StorageBlob))
>>>>>>> main
}

func Test_EventSubscriptionDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptionDestination to EventSubscriptionDestination via AssignPropertiesToEventSubscriptionDestination & AssignPropertiesFromEventSubscriptionDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionDestination, EventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionDestination tests if a specific instance of EventSubscriptionDestination can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionDestination(subject EventSubscriptionDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20200601s.EventSubscriptionDestination
	err := copied.AssignPropertiesToEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionDestination
	err = actual.AssignPropertiesFromEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestination, EventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestination runs a test to see if a specific instance of EventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestination(subject EventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionDestination instances for property testing - lazily instantiated by
// EventSubscriptionDestinationGenerator()
var eventSubscriptionDestinationGenerator gopter.Gen

// EventSubscriptionDestinationGenerator returns a generator of EventSubscriptionDestination instances for property testing.
func EventSubscriptionDestinationGenerator() gopter.Gen {
	if eventSubscriptionDestinationGenerator != nil {
		return eventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionDestination(generators)
	eventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionDestination{}), generators)

	return eventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.PtrOf(gen.OneConstOf(
		EventSubscriptionDestination_EndpointType_AzureFunction,
		EventSubscriptionDestination_EndpointType_EventHub,
		EventSubscriptionDestination_EndpointType_HybridConnection,
		EventSubscriptionDestination_EndpointType_ServiceBusQueue,
		EventSubscriptionDestination_EndpointType_ServiceBusTopic,
		EventSubscriptionDestination_EndpointType_StorageQueue,
		EventSubscriptionDestination_EndpointType_WebHook))
}

func Test_EventSubscriptionDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from EventSubscriptionDestination_STATUS to EventSubscriptionDestination_STATUS via AssignPropertiesToEventSubscriptionDestination_STATUS & AssignPropertiesFromEventSubscriptionDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionDestination_STATUS, EventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionDestination_STATUS tests if a specific instance of EventSubscriptionDestination_STATUS can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionDestination_STATUS(subject EventSubscriptionDestination_STATUS) string {
=======
		"Round trip from EventSubscriptionDestination_STATUS to EventSubscriptionDestination_STATUS via AssignPropertiesToEventSubscriptionDestinationSTATUS & AssignPropertiesFromEventSubscriptionDestinationSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionDestinationSTATUS, EventSubscriptionDestinationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionDestinationSTATUS tests if a specific instance of EventSubscriptionDestination_STATUS can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionDestinationSTATUS(subject EventSubscriptionDestination_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20200601s.EventSubscriptionDestination_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToEventSubscriptionDestination_STATUS(&other)
=======
	err := copied.AssignPropertiesToEventSubscriptionDestinationSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionDestination_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromEventSubscriptionDestination_STATUS(&other)
=======
	err = actual.AssignPropertiesFromEventSubscriptionDestinationSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionDestination_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestination_STATUS, EventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestination_STATUS runs a test to see if a specific instance of EventSubscriptionDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestination_STATUS(subject EventSubscriptionDestination_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestinationSTATUS, EventSubscriptionDestinationSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestinationSTATUS runs a test to see if a specific instance of EventSubscriptionDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestinationSTATUS(subject EventSubscriptionDestination_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionDestination_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// EventSubscriptionDestination_STATUSGenerator()
var eventSubscriptionDestination_STATUSGenerator gopter.Gen

// EventSubscriptionDestination_STATUSGenerator returns a generator of EventSubscriptionDestination_STATUS instances for property testing.
func EventSubscriptionDestination_STATUSGenerator() gopter.Gen {
	if eventSubscriptionDestination_STATUSGenerator != nil {
		return eventSubscriptionDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionDestination_STATUS(generators)
	eventSubscriptionDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionDestination_STATUS{}), generators)

	return eventSubscriptionDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionDestination_STATUS(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.PtrOf(gen.OneConstOf(
		EventSubscriptionDestination_EndpointType_AzureFunction_STATUS,
		EventSubscriptionDestination_EndpointType_EventHub_STATUS,
		EventSubscriptionDestination_EndpointType_HybridConnection_STATUS,
		EventSubscriptionDestination_EndpointType_ServiceBusQueue_STATUS,
		EventSubscriptionDestination_EndpointType_ServiceBusTopic_STATUS,
		EventSubscriptionDestination_EndpointType_StorageQueue_STATUS,
		EventSubscriptionDestination_EndpointType_WebHook_STATUS))
=======
// EventSubscriptionDestinationSTATUSGenerator()
var eventSubscriptionDestinationSTATUSGenerator gopter.Gen

// EventSubscriptionDestinationSTATUSGenerator returns a generator of EventSubscriptionDestination_STATUS instances for property testing.
func EventSubscriptionDestinationSTATUSGenerator() gopter.Gen {
	if eventSubscriptionDestinationSTATUSGenerator != nil {
		return eventSubscriptionDestinationSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionDestinationSTATUS(generators)
	eventSubscriptionDestinationSTATUSGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionDestination_STATUS{}), generators)

	return eventSubscriptionDestinationSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionDestinationSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionDestinationSTATUS(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.PtrOf(gen.OneConstOf(
		EventSubscriptionDestinationSTATUSEndpointType_AzureFunction,
		EventSubscriptionDestinationSTATUSEndpointType_EventHub,
		EventSubscriptionDestinationSTATUSEndpointType_HybridConnection,
		EventSubscriptionDestinationSTATUSEndpointType_ServiceBusQueue,
		EventSubscriptionDestinationSTATUSEndpointType_ServiceBusTopic,
		EventSubscriptionDestinationSTATUSEndpointType_StorageQueue,
		EventSubscriptionDestinationSTATUSEndpointType_WebHook))
>>>>>>> main
}

func Test_EventSubscriptionFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptionFilter to EventSubscriptionFilter via AssignPropertiesToEventSubscriptionFilter & AssignPropertiesFromEventSubscriptionFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionFilter, EventSubscriptionFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionFilter tests if a specific instance of EventSubscriptionFilter can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionFilter(subject EventSubscriptionFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20200601s.EventSubscriptionFilter
	err := copied.AssignPropertiesToEventSubscriptionFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionFilter
	err = actual.AssignPropertiesFromEventSubscriptionFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilter, EventSubscriptionFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilter runs a test to see if a specific instance of EventSubscriptionFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilter(subject EventSubscriptionFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionFilter instances for property testing - lazily instantiated by
// EventSubscriptionFilterGenerator()
var eventSubscriptionFilterGenerator gopter.Gen

// EventSubscriptionFilterGenerator returns a generator of EventSubscriptionFilter instances for property testing.
// We first initialize eventSubscriptionFilterGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilterGenerator() gopter.Gen {
	if eventSubscriptionFilterGenerator != nil {
		return eventSubscriptionFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilter(generators)
	eventSubscriptionFilterGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilter(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilter(generators)
	eventSubscriptionFilterGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter{}), generators)

	return eventSubscriptionFilterGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilter(gens map[string]gopter.Gen) {
	gens["IncludedEventTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IsSubjectCaseSensitive"] = gen.PtrOf(gen.Bool())
	gens["SubjectBeginsWith"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectEndsWith"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionFilter is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilter(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilterGenerator())
}

func Test_EventSubscriptionFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from EventSubscriptionFilter_STATUS to EventSubscriptionFilter_STATUS via AssignPropertiesToEventSubscriptionFilter_STATUS & AssignPropertiesFromEventSubscriptionFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionFilter_STATUS, EventSubscriptionFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionFilter_STATUS tests if a specific instance of EventSubscriptionFilter_STATUS can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionFilter_STATUS(subject EventSubscriptionFilter_STATUS) string {
=======
		"Round trip from EventSubscriptionFilter_STATUS to EventSubscriptionFilter_STATUS via AssignPropertiesToEventSubscriptionFilterSTATUS & AssignPropertiesFromEventSubscriptionFilterSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionFilterSTATUS, EventSubscriptionFilterSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionFilterSTATUS tests if a specific instance of EventSubscriptionFilter_STATUS can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionFilterSTATUS(subject EventSubscriptionFilter_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20200601s.EventSubscriptionFilter_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToEventSubscriptionFilter_STATUS(&other)
=======
	err := copied.AssignPropertiesToEventSubscriptionFilterSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionFilter_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromEventSubscriptionFilter_STATUS(&other)
=======
	err = actual.AssignPropertiesFromEventSubscriptionFilterSTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionFilter_STATUS via JSON returns original",
<<<<<<< HEAD
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilter_STATUS, EventSubscriptionFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilter_STATUS runs a test to see if a specific instance of EventSubscriptionFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilter_STATUS(subject EventSubscriptionFilter_STATUS) string {
=======
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilterSTATUS, EventSubscriptionFilterSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilterSTATUS runs a test to see if a specific instance of EventSubscriptionFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilterSTATUS(subject EventSubscriptionFilter_STATUS) string {
>>>>>>> main
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionFilter_STATUS instances for property testing - lazily instantiated by
<<<<<<< HEAD
// EventSubscriptionFilter_STATUSGenerator()
var eventSubscriptionFilter_STATUSGenerator gopter.Gen

// EventSubscriptionFilter_STATUSGenerator returns a generator of EventSubscriptionFilter_STATUS instances for property testing.
// We first initialize eventSubscriptionFilter_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilter_STATUSGenerator() gopter.Gen {
	if eventSubscriptionFilter_STATUSGenerator != nil {
		return eventSubscriptionFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilter_STATUS(generators)
	eventSubscriptionFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilter_STATUS(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilter_STATUS(generators)
	eventSubscriptionFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_STATUS{}), generators)

	return eventSubscriptionFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilter_STATUS(gens map[string]gopter.Gen) {
=======
// EventSubscriptionFilterSTATUSGenerator()
var eventSubscriptionFilterSTATUSGenerator gopter.Gen

// EventSubscriptionFilterSTATUSGenerator returns a generator of EventSubscriptionFilter_STATUS instances for property testing.
// We first initialize eventSubscriptionFilterSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilterSTATUSGenerator() gopter.Gen {
	if eventSubscriptionFilterSTATUSGenerator != nil {
		return eventSubscriptionFilterSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterSTATUS(generators)
	eventSubscriptionFilterSTATUSGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterSTATUS(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilterSTATUS(generators)
	eventSubscriptionFilterSTATUSGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_STATUS{}), generators)

	return eventSubscriptionFilterSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilterSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilterSTATUS(gens map[string]gopter.Gen) {
>>>>>>> main
	gens["IncludedEventTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IsSubjectCaseSensitive"] = gen.PtrOf(gen.Bool())
	gens["SubjectBeginsWith"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectEndsWith"] = gen.PtrOf(gen.AlphaString())
}

<<<<<<< HEAD
// AddRelatedPropertyGeneratorsForEventSubscriptionFilter_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilter_STATUS(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilter_STATUSGenerator())
=======
// AddRelatedPropertyGeneratorsForEventSubscriptionFilterSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilterSTATUS(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilterSTATUSGenerator())
>>>>>>> main
}

func Test_RetryPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RetryPolicy to RetryPolicy via AssignPropertiesToRetryPolicy & AssignPropertiesFromRetryPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForRetryPolicy, RetryPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRetryPolicy tests if a specific instance of RetryPolicy can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForRetryPolicy(subject RetryPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20200601s.RetryPolicy
	err := copied.AssignPropertiesToRetryPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RetryPolicy
	err = actual.AssignPropertiesFromRetryPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RetryPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicy, RetryPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicy runs a test to see if a specific instance of RetryPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicy(subject RetryPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicy instances for property testing - lazily instantiated by RetryPolicyGenerator()
var retryPolicyGenerator gopter.Gen

// RetryPolicyGenerator returns a generator of RetryPolicy instances for property testing.
func RetryPolicyGenerator() gopter.Gen {
	if retryPolicyGenerator != nil {
		return retryPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicy(generators)
	retryPolicyGenerator = gen.Struct(reflect.TypeOf(RetryPolicy{}), generators)

	return retryPolicyGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicy(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_RetryPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
<<<<<<< HEAD
		"Round trip from RetryPolicy_STATUS to RetryPolicy_STATUS via AssignPropertiesToRetryPolicy_STATUS & AssignPropertiesFromRetryPolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRetryPolicy_STATUS, RetryPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRetryPolicy_STATUS tests if a specific instance of RetryPolicy_STATUS can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForRetryPolicy_STATUS(subject RetryPolicy_STATUS) string {
=======
		"Round trip from RetryPolicy_STATUS to RetryPolicy_STATUS via AssignPropertiesToRetryPolicySTATUS & AssignPropertiesFromRetryPolicySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRetryPolicySTATUS, RetryPolicySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRetryPolicySTATUS tests if a specific instance of RetryPolicy_STATUS can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForRetryPolicySTATUS(subject RetryPolicy_STATUS) string {
>>>>>>> main
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20200601s.RetryPolicy_STATUS
<<<<<<< HEAD
	err := copied.AssignPropertiesToRetryPolicy_STATUS(&other)
=======
	err := copied.AssignPropertiesToRetryPolicySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RetryPolicy_STATUS
<<<<<<< HEAD
	err = actual.AssignPropertiesFromRetryPolicy_STATUS(&other)
=======
	err = actual.AssignPropertiesFromRetryPolicySTATUS(&other)
>>>>>>> main
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RetryPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
<<<<<<< HEAD
=======
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicySTATUS, RetryPolicySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicySTATUS runs a test to see if a specific instance of RetryPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicySTATUS(subject RetryPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicy_STATUS instances for property testing - lazily instantiated by RetryPolicySTATUSGenerator()
var retryPolicySTATUSGenerator gopter.Gen

// RetryPolicySTATUSGenerator returns a generator of RetryPolicy_STATUS instances for property testing.
func RetryPolicySTATUSGenerator() gopter.Gen {
	if retryPolicySTATUSGenerator != nil {
		return retryPolicySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicySTATUS(generators)
	retryPolicySTATUSGenerator = gen.Struct(reflect.TypeOf(RetryPolicy_STATUS{}), generators)

	return retryPolicySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicySTATUS(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_StorageBlobDeadLetterDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageBlobDeadLetterDestination to StorageBlobDeadLetterDestination via AssignPropertiesToStorageBlobDeadLetterDestination & AssignPropertiesFromStorageBlobDeadLetterDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageBlobDeadLetterDestination, StorageBlobDeadLetterDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageBlobDeadLetterDestination tests if a specific instance of StorageBlobDeadLetterDestination can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForStorageBlobDeadLetterDestination(subject StorageBlobDeadLetterDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20200601s.StorageBlobDeadLetterDestination
	err := copied.AssignPropertiesToStorageBlobDeadLetterDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageBlobDeadLetterDestination
	err = actual.AssignPropertiesFromStorageBlobDeadLetterDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageBlobDeadLetterDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
>>>>>>> main
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicy_STATUS, RetryPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicy_STATUS runs a test to see if a specific instance of RetryPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicy_STATUS(subject RetryPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicy_STATUS instances for property testing - lazily instantiated by RetryPolicy_STATUSGenerator()
var retryPolicy_STATUSGenerator gopter.Gen

// RetryPolicy_STATUSGenerator returns a generator of RetryPolicy_STATUS instances for property testing.
func RetryPolicy_STATUSGenerator() gopter.Gen {
	if retryPolicy_STATUSGenerator != nil {
		return retryPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicy_STATUS(generators)
	retryPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(RetryPolicy_STATUS{}), generators)

	return retryPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_AdvancedFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdvancedFilter to AdvancedFilter via AssignPropertiesToAdvancedFilter & AssignPropertiesFromAdvancedFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdvancedFilter, AdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdvancedFilter tests if a specific instance of AdvancedFilter can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForAdvancedFilter(subject AdvancedFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20200601s.AdvancedFilter
	err := copied.AssignPropertiesToAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdvancedFilter
	err = actual.AssignPropertiesFromAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter, AdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter runs a test to see if a specific instance of AdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter(subject AdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter instances for property testing - lazily instantiated by AdvancedFilterGenerator()
var advancedFilterGenerator gopter.Gen

// AdvancedFilterGenerator returns a generator of AdvancedFilter instances for property testing.
func AdvancedFilterGenerator() gopter.Gen {
	if advancedFilterGenerator != nil {
		return advancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter(generators)
	advancedFilterGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter{}), generators)

	return advancedFilterGenerator
}

<<<<<<< HEAD
// AddIndependentPropertyGeneratorsForAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.PtrOf(gen.OneConstOf(
		AdvancedFilter_OperatorType_BoolEquals,
		AdvancedFilter_OperatorType_NumberGreaterThan,
		AdvancedFilter_OperatorType_NumberGreaterThanOrEquals,
		AdvancedFilter_OperatorType_NumberIn,
		AdvancedFilter_OperatorType_NumberLessThan,
		AdvancedFilter_OperatorType_NumberLessThanOrEquals,
		AdvancedFilter_OperatorType_NumberNotIn,
		AdvancedFilter_OperatorType_StringBeginsWith,
		AdvancedFilter_OperatorType_StringContains,
		AdvancedFilter_OperatorType_StringEndsWith,
		AdvancedFilter_OperatorType_StringIn,
		AdvancedFilter_OperatorType_StringNotIn))
=======
// AddRelatedPropertyGeneratorsForAdvancedFilter is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdvancedFilter(gens map[string]gopter.Gen) {
	gens["BoolEquals"] = AdvancedFilterBoolEqualsGenerator().Map(func(it AdvancedFilter_BoolEquals) *AdvancedFilter_BoolEquals {
		return &it
	}) // generate one case for OneOf type
	gens["NumberGreaterThan"] = AdvancedFilterNumberGreaterThanGenerator().Map(func(it AdvancedFilter_NumberGreaterThan) *AdvancedFilter_NumberGreaterThan {
		return &it
	}) // generate one case for OneOf type
	gens["NumberGreaterThanOrEquals"] = AdvancedFilterNumberGreaterThanOrEqualsGenerator().Map(func(it AdvancedFilter_NumberGreaterThanOrEquals) *AdvancedFilter_NumberGreaterThanOrEquals {
		return &it
	}) // generate one case for OneOf type
	gens["NumberIn"] = AdvancedFilterNumberInGenerator().Map(func(it AdvancedFilter_NumberIn) *AdvancedFilter_NumberIn {
		return &it
	}) // generate one case for OneOf type
	gens["NumberLessThan"] = AdvancedFilterNumberLessThanGenerator().Map(func(it AdvancedFilter_NumberLessThan) *AdvancedFilter_NumberLessThan {
		return &it
	}) // generate one case for OneOf type
	gens["NumberLessThanOrEquals"] = AdvancedFilterNumberLessThanOrEqualsGenerator().Map(func(it AdvancedFilter_NumberLessThanOrEquals) *AdvancedFilter_NumberLessThanOrEquals {
		return &it
	}) // generate one case for OneOf type
	gens["NumberNotIn"] = AdvancedFilterNumberNotInGenerator().Map(func(it AdvancedFilter_NumberNotIn) *AdvancedFilter_NumberNotIn {
		return &it
	}) // generate one case for OneOf type
	gens["StringBeginsWith"] = AdvancedFilterStringBeginsWithGenerator().Map(func(it AdvancedFilter_StringBeginsWith) *AdvancedFilter_StringBeginsWith {
		return &it
	}) // generate one case for OneOf type
	gens["StringContains"] = AdvancedFilterStringContainsGenerator().Map(func(it AdvancedFilter_StringContains) *AdvancedFilter_StringContains {
		return &it
	}) // generate one case for OneOf type
	gens["StringEndsWith"] = AdvancedFilterStringEndsWithGenerator().Map(func(it AdvancedFilter_StringEndsWith) *AdvancedFilter_StringEndsWith {
		return &it
	}) // generate one case for OneOf type
	gens["StringIn"] = AdvancedFilterStringInGenerator().Map(func(it AdvancedFilter_StringIn) *AdvancedFilter_StringIn {
		return &it
	}) // generate one case for OneOf type
	gens["StringNotIn"] = AdvancedFilterStringNotInGenerator().Map(func(it AdvancedFilter_StringNotIn) *AdvancedFilter_StringNotIn {
		return &it
	}) // generate one case for OneOf type
}

func Test_AdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdvancedFilter_STATUS to AdvancedFilter_STATUS via AssignPropertiesToAdvancedFilterSTATUS & AssignPropertiesFromAdvancedFilterSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdvancedFilterSTATUS, AdvancedFilterSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdvancedFilterSTATUS tests if a specific instance of AdvancedFilter_STATUS can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForAdvancedFilterSTATUS(subject AdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20200601s.AdvancedFilter_STATUS
	err := copied.AssignPropertiesToAdvancedFilterSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdvancedFilter_STATUS
	err = actual.AssignPropertiesFromAdvancedFilterSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterSTATUS, AdvancedFilterSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterSTATUS runs a test to see if a specific instance of AdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterSTATUS(subject AdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_STATUS instances for property testing - lazily instantiated by
// AdvancedFilterSTATUSGenerator()
var advancedFilterSTATUSGenerator gopter.Gen

// AdvancedFilterSTATUSGenerator returns a generator of AdvancedFilter_STATUS instances for property testing.
func AdvancedFilterSTATUSGenerator() gopter.Gen {
	if advancedFilterSTATUSGenerator != nil {
		return advancedFilterSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterSTATUS(generators)
	advancedFilterSTATUSGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_STATUS{}), generators)

	return advancedFilterSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterSTATUS(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.PtrOf(gen.OneConstOf(
		AdvancedFilterSTATUSOperatorType_BoolEquals,
		AdvancedFilterSTATUSOperatorType_NumberGreaterThan,
		AdvancedFilterSTATUSOperatorType_NumberGreaterThanOrEquals,
		AdvancedFilterSTATUSOperatorType_NumberIn,
		AdvancedFilterSTATUSOperatorType_NumberLessThan,
		AdvancedFilterSTATUSOperatorType_NumberLessThanOrEquals,
		AdvancedFilterSTATUSOperatorType_NumberNotIn,
		AdvancedFilterSTATUSOperatorType_StringBeginsWith,
		AdvancedFilterSTATUSOperatorType_StringContains,
		AdvancedFilterSTATUSOperatorType_StringEndsWith,
		AdvancedFilterSTATUSOperatorType_StringIn,
		AdvancedFilterSTATUSOperatorType_StringNotIn))
>>>>>>> main
}

func Test_AdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdvancedFilter_STATUS to AdvancedFilter_STATUS via AssignPropertiesToAdvancedFilter_STATUS & AssignPropertiesFromAdvancedFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdvancedFilter_STATUS, AdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdvancedFilter_STATUS tests if a specific instance of AdvancedFilter_STATUS can be assigned to v1beta20200601storage and back losslessly
func RunPropertyAssignmentTestForAdvancedFilter_STATUS(subject AdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20200601s.AdvancedFilter_STATUS
	err := copied.AssignPropertiesToAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdvancedFilter_STATUS
	err = actual.AssignPropertiesFromAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_STATUS, AdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_STATUS runs a test to see if a specific instance of AdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_STATUS(subject AdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_STATUS instances for property testing - lazily instantiated by
// AdvancedFilter_STATUSGenerator()
var advancedFilter_STATUSGenerator gopter.Gen

// AdvancedFilter_STATUSGenerator returns a generator of AdvancedFilter_STATUS instances for property testing.
func AdvancedFilter_STATUSGenerator() gopter.Gen {
	if advancedFilter_STATUSGenerator != nil {
		return advancedFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_STATUS(generators)
	advancedFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_STATUS{}), generators)

	return advancedFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.PtrOf(gen.OneConstOf(
		AdvancedFilter_OperatorType_BoolEquals_STATUS,
		AdvancedFilter_OperatorType_NumberGreaterThan_STATUS,
		AdvancedFilter_OperatorType_NumberGreaterThanOrEquals_STATUS,
		AdvancedFilter_OperatorType_NumberIn_STATUS,
		AdvancedFilter_OperatorType_NumberLessThan_STATUS,
		AdvancedFilter_OperatorType_NumberLessThanOrEquals_STATUS,
		AdvancedFilter_OperatorType_NumberNotIn_STATUS,
		AdvancedFilter_OperatorType_StringBeginsWith_STATUS,
		AdvancedFilter_OperatorType_StringContains_STATUS,
		AdvancedFilter_OperatorType_StringEndsWith_STATUS,
		AdvancedFilter_OperatorType_StringIn_STATUS,
		AdvancedFilter_OperatorType_StringNotIn_STATUS))
}
