// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20200601storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_EventSubscription_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscription, EventSubscriptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscription runs a test to see if a specific instance of EventSubscription round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscription(subject EventSubscription) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription instances for property testing - lazily instantiated by EventSubscriptionGenerator()
var eventSubscriptionGenerator gopter.Gen

// EventSubscriptionGenerator returns a generator of EventSubscription instances for property testing.
func EventSubscriptionGenerator() gopter.Gen {
	if eventSubscriptionGenerator != nil {
		return eventSubscriptionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEventSubscription(generators)
	eventSubscriptionGenerator = gen.Struct(reflect.TypeOf(EventSubscription{}), generators)

	return eventSubscriptionGenerator
}

// AddRelatedPropertyGeneratorsForEventSubscription is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscription(gens map[string]gopter.Gen) {
	gens["Spec"] = EventSubscriptionsSPECGenerator()
	gens["Status"] = EventSubscriptionStatusGenerator()
}

func Test_EventSubscription_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionStatus, EventSubscriptionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionStatus runs a test to see if a specific instance of EventSubscription_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionStatus(subject EventSubscription_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription_Status instances for property testing - lazily instantiated by
//EventSubscriptionStatusGenerator()
var eventSubscriptionStatusGenerator gopter.Gen

// EventSubscriptionStatusGenerator returns a generator of EventSubscription_Status instances for property testing.
// We first initialize eventSubscriptionStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionStatusGenerator() gopter.Gen {
	if eventSubscriptionStatusGenerator != nil {
		return eventSubscriptionStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionStatus(generators)
	eventSubscriptionStatusGenerator = gen.Struct(reflect.TypeOf(EventSubscription_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionStatus(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionStatus(generators)
	eventSubscriptionStatusGenerator = gen.Struct(reflect.TypeOf(EventSubscription_Status{}), generators)

	return eventSubscriptionStatusGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionStatus(gens map[string]gopter.Gen) {
	gens["EventDeliverySchema"] = gen.PtrOf(gen.AlphaString())
	gens["ExpirationTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Labels"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Topic"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionStatus(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(DeadLetterDestinationStatusGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestinationStatusGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilterStatusGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicyStatusGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataStatusGenerator())
}

func Test_EventSubscriptions_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptions_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionsSPEC, EventSubscriptionsSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionsSPEC runs a test to see if a specific instance of EventSubscriptions_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionsSPEC(subject EventSubscriptions_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptions_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptions_SPEC instances for property testing - lazily instantiated by
//EventSubscriptionsSPECGenerator()
var eventSubscriptionsSPECGenerator gopter.Gen

// EventSubscriptionsSPECGenerator returns a generator of EventSubscriptions_SPEC instances for property testing.
// We first initialize eventSubscriptionsSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionsSPECGenerator() gopter.Gen {
	if eventSubscriptionsSPECGenerator != nil {
		return eventSubscriptionsSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionsSPEC(generators)
	eventSubscriptionsSPECGenerator = gen.Struct(reflect.TypeOf(EventSubscriptions_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionsSPEC(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionsSPEC(generators)
	eventSubscriptionsSPECGenerator = gen.Struct(reflect.TypeOf(EventSubscriptions_SPEC{}), generators)

	return eventSubscriptionsSPECGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionsSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionsSPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EventDeliverySchema"] = gen.PtrOf(gen.AlphaString())
	gens["ExpirationTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Labels"] = gen.SliceOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForEventSubscriptionsSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionsSPEC(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(DeadLetterDestinationSpecGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestinationSpecGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilterSpecGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicySpecGenerator())
}

func Test_DeadLetterDestination_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeadLetterDestination_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeadLetterDestinationSpec, DeadLetterDestinationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeadLetterDestinationSpec runs a test to see if a specific instance of DeadLetterDestination_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDeadLetterDestinationSpec(subject DeadLetterDestination_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeadLetterDestination_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeadLetterDestination_Spec instances for property testing - lazily instantiated by
//DeadLetterDestinationSpecGenerator()
var deadLetterDestinationSpecGenerator gopter.Gen

// DeadLetterDestinationSpecGenerator returns a generator of DeadLetterDestination_Spec instances for property testing.
func DeadLetterDestinationSpecGenerator() gopter.Gen {
	if deadLetterDestinationSpecGenerator != nil {
		return deadLetterDestinationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeadLetterDestinationSpec(generators)
	deadLetterDestinationSpecGenerator = gen.Struct(reflect.TypeOf(DeadLetterDestination_Spec{}), generators)

	return deadLetterDestinationSpecGenerator
}

// AddIndependentPropertyGeneratorsForDeadLetterDestinationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeadLetterDestinationSpec(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.PtrOf(gen.AlphaString())
}

func Test_DeadLetterDestination_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeadLetterDestination_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeadLetterDestinationStatus, DeadLetterDestinationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeadLetterDestinationStatus runs a test to see if a specific instance of DeadLetterDestination_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDeadLetterDestinationStatus(subject DeadLetterDestination_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeadLetterDestination_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeadLetterDestination_Status instances for property testing - lazily instantiated by
//DeadLetterDestinationStatusGenerator()
var deadLetterDestinationStatusGenerator gopter.Gen

// DeadLetterDestinationStatusGenerator returns a generator of DeadLetterDestination_Status instances for property testing.
func DeadLetterDestinationStatusGenerator() gopter.Gen {
	if deadLetterDestinationStatusGenerator != nil {
		return deadLetterDestinationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeadLetterDestinationStatus(generators)
	deadLetterDestinationStatusGenerator = gen.Struct(reflect.TypeOf(DeadLetterDestination_Status{}), generators)

	return deadLetterDestinationStatusGenerator
}

// AddIndependentPropertyGeneratorsForDeadLetterDestinationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeadLetterDestinationStatus(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventSubscriptionDestination_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionDestination_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestinationSpec, EventSubscriptionDestinationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestinationSpec runs a test to see if a specific instance of EventSubscriptionDestination_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestinationSpec(subject EventSubscriptionDestination_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionDestination_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionDestination_Spec instances for property testing - lazily instantiated by
//EventSubscriptionDestinationSpecGenerator()
var eventSubscriptionDestinationSpecGenerator gopter.Gen

// EventSubscriptionDestinationSpecGenerator returns a generator of EventSubscriptionDestination_Spec instances for property testing.
func EventSubscriptionDestinationSpecGenerator() gopter.Gen {
	if eventSubscriptionDestinationSpecGenerator != nil {
		return eventSubscriptionDestinationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionDestinationSpec(generators)
	eventSubscriptionDestinationSpecGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionDestination_Spec{}), generators)

	return eventSubscriptionDestinationSpecGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionDestinationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionDestinationSpec(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventSubscriptionDestination_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionDestination_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestinationStatus, EventSubscriptionDestinationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestinationStatus runs a test to see if a specific instance of EventSubscriptionDestination_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestinationStatus(subject EventSubscriptionDestination_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionDestination_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionDestination_Status instances for property testing - lazily instantiated by
//EventSubscriptionDestinationStatusGenerator()
var eventSubscriptionDestinationStatusGenerator gopter.Gen

// EventSubscriptionDestinationStatusGenerator returns a generator of EventSubscriptionDestination_Status instances for property testing.
func EventSubscriptionDestinationStatusGenerator() gopter.Gen {
	if eventSubscriptionDestinationStatusGenerator != nil {
		return eventSubscriptionDestinationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionDestinationStatus(generators)
	eventSubscriptionDestinationStatusGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionDestination_Status{}), generators)

	return eventSubscriptionDestinationStatusGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionDestinationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionDestinationStatus(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventSubscriptionFilter_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionFilter_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilterSpec, EventSubscriptionFilterSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilterSpec runs a test to see if a specific instance of EventSubscriptionFilter_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilterSpec(subject EventSubscriptionFilter_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionFilter_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionFilter_Spec instances for property testing - lazily instantiated by
//EventSubscriptionFilterSpecGenerator()
var eventSubscriptionFilterSpecGenerator gopter.Gen

// EventSubscriptionFilterSpecGenerator returns a generator of EventSubscriptionFilter_Spec instances for property testing.
// We first initialize eventSubscriptionFilterSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilterSpecGenerator() gopter.Gen {
	if eventSubscriptionFilterSpecGenerator != nil {
		return eventSubscriptionFilterSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterSpec(generators)
	eventSubscriptionFilterSpecGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterSpec(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilterSpec(generators)
	eventSubscriptionFilterSpecGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_Spec{}), generators)

	return eventSubscriptionFilterSpecGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilterSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilterSpec(gens map[string]gopter.Gen) {
	gens["IncludedEventTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IsSubjectCaseSensitive"] = gen.PtrOf(gen.Bool())
	gens["SubjectBeginsWith"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectEndsWith"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionFilterSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilterSpec(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilterSpecGenerator())
}

func Test_EventSubscriptionFilter_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionFilter_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilterStatus, EventSubscriptionFilterStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilterStatus runs a test to see if a specific instance of EventSubscriptionFilter_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilterStatus(subject EventSubscriptionFilter_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionFilter_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionFilter_Status instances for property testing - lazily instantiated by
//EventSubscriptionFilterStatusGenerator()
var eventSubscriptionFilterStatusGenerator gopter.Gen

// EventSubscriptionFilterStatusGenerator returns a generator of EventSubscriptionFilter_Status instances for property testing.
// We first initialize eventSubscriptionFilterStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilterStatusGenerator() gopter.Gen {
	if eventSubscriptionFilterStatusGenerator != nil {
		return eventSubscriptionFilterStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterStatus(generators)
	eventSubscriptionFilterStatusGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterStatus(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilterStatus(generators)
	eventSubscriptionFilterStatusGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_Status{}), generators)

	return eventSubscriptionFilterStatusGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilterStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilterStatus(gens map[string]gopter.Gen) {
	gens["IncludedEventTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IsSubjectCaseSensitive"] = gen.PtrOf(gen.Bool())
	gens["SubjectBeginsWith"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectEndsWith"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionFilterStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilterStatus(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilterStatusGenerator())
}

func Test_RetryPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicySpec, RetryPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicySpec runs a test to see if a specific instance of RetryPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicySpec(subject RetryPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicy_Spec instances for property testing - lazily instantiated by RetryPolicySpecGenerator()
var retryPolicySpecGenerator gopter.Gen

// RetryPolicySpecGenerator returns a generator of RetryPolicy_Spec instances for property testing.
func RetryPolicySpecGenerator() gopter.Gen {
	if retryPolicySpecGenerator != nil {
		return retryPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicySpec(generators)
	retryPolicySpecGenerator = gen.Struct(reflect.TypeOf(RetryPolicy_Spec{}), generators)

	return retryPolicySpecGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicySpec(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_RetryPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicyStatus, RetryPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicyStatus runs a test to see if a specific instance of RetryPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicyStatus(subject RetryPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicy_Status instances for property testing - lazily instantiated by RetryPolicyStatusGenerator()
var retryPolicyStatusGenerator gopter.Gen

// RetryPolicyStatusGenerator returns a generator of RetryPolicy_Status instances for property testing.
func RetryPolicyStatusGenerator() gopter.Gen {
	if retryPolicyStatusGenerator != nil {
		return retryPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicyStatus(generators)
	retryPolicyStatusGenerator = gen.Struct(reflect.TypeOf(RetryPolicy_Status{}), generators)

	return retryPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicyStatus(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_AdvancedFilter_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterSpec, AdvancedFilterSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterSpec runs a test to see if a specific instance of AdvancedFilter_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterSpec(subject AdvancedFilter_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_Spec instances for property testing - lazily instantiated by AdvancedFilterSpecGenerator()
var advancedFilterSpecGenerator gopter.Gen

// AdvancedFilterSpecGenerator returns a generator of AdvancedFilter_Spec instances for property testing.
func AdvancedFilterSpecGenerator() gopter.Gen {
	if advancedFilterSpecGenerator != nil {
		return advancedFilterSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterSpec(generators)
	advancedFilterSpecGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_Spec{}), generators)

	return advancedFilterSpecGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterSpec(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.PtrOf(gen.AlphaString())
}

func Test_AdvancedFilter_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterStatus, AdvancedFilterStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterStatus runs a test to see if a specific instance of AdvancedFilter_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterStatus(subject AdvancedFilter_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_Status instances for property testing - lazily instantiated by
//AdvancedFilterStatusGenerator()
var advancedFilterStatusGenerator gopter.Gen

// AdvancedFilterStatusGenerator returns a generator of AdvancedFilter_Status instances for property testing.
func AdvancedFilterStatusGenerator() gopter.Gen {
	if advancedFilterStatusGenerator != nil {
		return advancedFilterStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterStatus(generators)
	advancedFilterStatusGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_Status{}), generators)

	return advancedFilterStatusGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterStatus(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.PtrOf(gen.AlphaString())
}
