// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20200601

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_EventSubscription_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscription_SpecARM, EventSubscription_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscription_SpecARM runs a test to see if a specific instance of EventSubscription_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscription_SpecARM(subject EventSubscription_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription_SpecARM instances for property testing - lazily instantiated by
// EventSubscription_SpecARMGenerator()
var eventSubscription_SpecARMGenerator gopter.Gen

// EventSubscription_SpecARMGenerator returns a generator of EventSubscription_SpecARM instances for property testing.
// We first initialize eventSubscription_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscription_SpecARMGenerator() gopter.Gen {
	if eventSubscription_SpecARMGenerator != nil {
		return eventSubscription_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_SpecARM(generators)
	eventSubscription_SpecARMGenerator = gen.Struct(reflect.TypeOf(EventSubscription_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_SpecARM(generators)
	AddRelatedPropertyGeneratorsForEventSubscription_SpecARM(generators)
	eventSubscription_SpecARMGenerator = gen.Struct(reflect.TypeOf(EventSubscription_SpecARM{}), generators)

	return eventSubscription_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscription_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscription_SpecARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscription_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscription_SpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(EventSubscriptionPropertiesARMGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataARMGenerator())
}

func Test_EventSubscriptionPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionPropertiesARM, EventSubscriptionPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionPropertiesARM runs a test to see if a specific instance of EventSubscriptionPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionPropertiesARM(subject EventSubscriptionPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionPropertiesARM instances for property testing - lazily instantiated by
// EventSubscriptionPropertiesARMGenerator()
var eventSubscriptionPropertiesARMGenerator gopter.Gen

// EventSubscriptionPropertiesARMGenerator returns a generator of EventSubscriptionPropertiesARM instances for property testing.
// We first initialize eventSubscriptionPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionPropertiesARMGenerator() gopter.Gen {
	if eventSubscriptionPropertiesARMGenerator != nil {
		return eventSubscriptionPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionPropertiesARM(generators)
	eventSubscriptionPropertiesARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionPropertiesARM(generators)
	eventSubscriptionPropertiesARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionPropertiesARM{}), generators)

	return eventSubscriptionPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionPropertiesARM(gens map[string]gopter.Gen) {
	gens["EventDeliverySchema"] = gen.PtrOf(gen.OneConstOf(EventSubscriptionProperties_EventDeliverySchema_CloudEventSchemaV1_0, EventSubscriptionProperties_EventDeliverySchema_CustomInputSchema, EventSubscriptionProperties_EventDeliverySchema_EventGridSchema))
	gens["ExpirationTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Labels"] = gen.SliceOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		EventSubscriptionProperties_ProvisioningState_AwaitingManualAction,
		EventSubscriptionProperties_ProvisioningState_Canceled,
		EventSubscriptionProperties_ProvisioningState_Creating,
		EventSubscriptionProperties_ProvisioningState_Deleting,
		EventSubscriptionProperties_ProvisioningState_Failed,
		EventSubscriptionProperties_ProvisioningState_Succeeded,
		EventSubscriptionProperties_ProvisioningState_Updating))
	gens["Topic"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionPropertiesARM(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(DeadLetterDestinationARMGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestinationARMGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilterARMGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicyARMGenerator())
}

func Test_DeadLetterDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeadLetterDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeadLetterDestinationARM, DeadLetterDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeadLetterDestinationARM runs a test to see if a specific instance of DeadLetterDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeadLetterDestinationARM(subject DeadLetterDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeadLetterDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeadLetterDestinationARM instances for property testing - lazily instantiated by
// DeadLetterDestinationARMGenerator()
var deadLetterDestinationARMGenerator gopter.Gen

// DeadLetterDestinationARMGenerator returns a generator of DeadLetterDestinationARM instances for property testing.
func DeadLetterDestinationARMGenerator() gopter.Gen {
	if deadLetterDestinationARMGenerator != nil {
		return deadLetterDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeadLetterDestinationARM(generators)
	deadLetterDestinationARMGenerator = gen.Struct(reflect.TypeOf(DeadLetterDestinationARM{}), generators)

	return deadLetterDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForDeadLetterDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeadLetterDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.PtrOf(gen.OneConstOf(DeadLetterDestination_EndpointType_StorageBlob))
}

func Test_EventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestinationARM, EventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestinationARM runs a test to see if a specific instance of EventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestinationARM(subject EventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// EventSubscriptionDestinationARMGenerator()
var eventSubscriptionDestinationARMGenerator gopter.Gen

// EventSubscriptionDestinationARMGenerator returns a generator of EventSubscriptionDestinationARM instances for property testing.
func EventSubscriptionDestinationARMGenerator() gopter.Gen {
	if eventSubscriptionDestinationARMGenerator != nil {
		return eventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionDestinationARM(generators)
	eventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionDestinationARM{}), generators)

	return eventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.PtrOf(gen.OneConstOf(
		EventSubscriptionDestination_EndpointType_AzureFunction,
		EventSubscriptionDestination_EndpointType_EventHub,
		EventSubscriptionDestination_EndpointType_HybridConnection,
		EventSubscriptionDestination_EndpointType_ServiceBusQueue,
		EventSubscriptionDestination_EndpointType_ServiceBusTopic,
		EventSubscriptionDestination_EndpointType_StorageQueue,
		EventSubscriptionDestination_EndpointType_WebHook))
}

func Test_EventSubscriptionFilterARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionFilterARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilterARM, EventSubscriptionFilterARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilterARM runs a test to see if a specific instance of EventSubscriptionFilterARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilterARM(subject EventSubscriptionFilterARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionFilterARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionFilterARM instances for property testing - lazily instantiated by
// EventSubscriptionFilterARMGenerator()
var eventSubscriptionFilterARMGenerator gopter.Gen

// EventSubscriptionFilterARMGenerator returns a generator of EventSubscriptionFilterARM instances for property testing.
// We first initialize eventSubscriptionFilterARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilterARMGenerator() gopter.Gen {
	if eventSubscriptionFilterARMGenerator != nil {
		return eventSubscriptionFilterARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterARM(generators)
	eventSubscriptionFilterARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilterARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterARM(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilterARM(generators)
	eventSubscriptionFilterARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilterARM{}), generators)

	return eventSubscriptionFilterARMGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilterARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilterARM(gens map[string]gopter.Gen) {
	gens["IncludedEventTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IsSubjectCaseSensitive"] = gen.PtrOf(gen.Bool())
	gens["SubjectBeginsWith"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectEndsWith"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionFilterARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilterARM(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilterARMGenerator())
}

func Test_RetryPolicyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicyARM, RetryPolicyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicyARM runs a test to see if a specific instance of RetryPolicyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicyARM(subject RetryPolicyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicyARM instances for property testing - lazily instantiated by RetryPolicyARMGenerator()
var retryPolicyARMGenerator gopter.Gen

// RetryPolicyARMGenerator returns a generator of RetryPolicyARM instances for property testing.
func RetryPolicyARMGenerator() gopter.Gen {
	if retryPolicyARMGenerator != nil {
		return retryPolicyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicyARM(generators)
	retryPolicyARMGenerator = gen.Struct(reflect.TypeOf(RetryPolicyARM{}), generators)

	return retryPolicyARMGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicyARM(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_AdvancedFilterARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilterARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterARM, AdvancedFilterARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterARM runs a test to see if a specific instance of AdvancedFilterARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterARM(subject AdvancedFilterARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilterARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilterARM instances for property testing - lazily instantiated by AdvancedFilterARMGenerator()
var advancedFilterARMGenerator gopter.Gen

// AdvancedFilterARMGenerator returns a generator of AdvancedFilterARM instances for property testing.
func AdvancedFilterARMGenerator() gopter.Gen {
	if advancedFilterARMGenerator != nil {
		return advancedFilterARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterARM(generators)
	advancedFilterARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilterARM{}), generators)

	return advancedFilterARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.PtrOf(gen.OneConstOf(
		AdvancedFilter_OperatorType_BoolEquals,
		AdvancedFilter_OperatorType_NumberGreaterThan,
		AdvancedFilter_OperatorType_NumberGreaterThanOrEquals,
		AdvancedFilter_OperatorType_NumberIn,
		AdvancedFilter_OperatorType_NumberLessThan,
		AdvancedFilter_OperatorType_NumberLessThanOrEquals,
		AdvancedFilter_OperatorType_NumberNotIn,
		AdvancedFilter_OperatorType_StringBeginsWith,
		AdvancedFilter_OperatorType_StringContains,
		AdvancedFilter_OperatorType_StringEndsWith,
		AdvancedFilter_OperatorType_StringIn,
		AdvancedFilter_OperatorType_StringNotIn))
}
