// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20200601

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_EventSubscriptions_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptions_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionsSpecARM, EventSubscriptionsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionsSpecARM runs a test to see if a specific instance of EventSubscriptions_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionsSpecARM(subject EventSubscriptions_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptions_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptions_SpecARM instances for property testing - lazily instantiated by
// EventSubscriptionsSpecARMGenerator()
var eventSubscriptionsSpecARMGenerator gopter.Gen

// EventSubscriptionsSpecARMGenerator returns a generator of EventSubscriptions_SpecARM instances for property testing.
// We first initialize eventSubscriptionsSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionsSpecARMGenerator() gopter.Gen {
	if eventSubscriptionsSpecARMGenerator != nil {
		return eventSubscriptionsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionsSpecARM(generators)
	eventSubscriptionsSpecARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptions_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionsSpecARM(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionsSpecARM(generators)
	eventSubscriptionsSpecARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptions_SpecARM{}), generators)

	return eventSubscriptionsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionsSpecARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionsSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionsSpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(EventSubscriptionPropertiesARMGenerator())
}

func Test_EventSubscriptionPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionPropertiesARM, EventSubscriptionPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionPropertiesARM runs a test to see if a specific instance of EventSubscriptionPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionPropertiesARM(subject EventSubscriptionPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionPropertiesARM instances for property testing - lazily instantiated by
// EventSubscriptionPropertiesARMGenerator()
var eventSubscriptionPropertiesARMGenerator gopter.Gen

// EventSubscriptionPropertiesARMGenerator returns a generator of EventSubscriptionPropertiesARM instances for property testing.
// We first initialize eventSubscriptionPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionPropertiesARMGenerator() gopter.Gen {
	if eventSubscriptionPropertiesARMGenerator != nil {
		return eventSubscriptionPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionPropertiesARM(generators)
	eventSubscriptionPropertiesARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionPropertiesARM(generators)
	eventSubscriptionPropertiesARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionPropertiesARM{}), generators)

	return eventSubscriptionPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionPropertiesARM(gens map[string]gopter.Gen) {
	gens["EventDeliverySchema"] = gen.PtrOf(gen.OneConstOf(EventSubscriptionPropertiesEventDeliverySchemaCloudEventSchemaV10, EventSubscriptionPropertiesEventDeliverySchemaCustomInputSchema, EventSubscriptionPropertiesEventDeliverySchemaEventGridSchema))
	gens["ExpirationTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Labels"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionPropertiesARM(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(StorageBlobDeadLetterDestinationARMGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestinationARMGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilterARMGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicyARMGenerator())
}

func Test_EventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestinationARM, EventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestinationARM runs a test to see if a specific instance of EventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestinationARM(subject EventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// EventSubscriptionDestinationARMGenerator()
var eventSubscriptionDestinationARMGenerator gopter.Gen

// EventSubscriptionDestinationARMGenerator returns a generator of EventSubscriptionDestinationARM instances for property testing.
func EventSubscriptionDestinationARMGenerator() gopter.Gen {
	if eventSubscriptionDestinationARMGenerator != nil {
		return eventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEventSubscriptionDestinationARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(EventSubscriptionDestinationARM{}), map[string]gopter.Gen{
			propName: propGen,
		}))
	}
	eventSubscriptionDestinationARMGenerator = gen.OneGenOf(gens...)

	return eventSubscriptionDestinationARMGenerator
}

// AddRelatedPropertyGeneratorsForEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["AzureFunction"] = AzureFunctionEventSubscriptionDestinationARMGenerator().Map(func(it AzureFunctionEventSubscriptionDestinationARM) *AzureFunctionEventSubscriptionDestinationARM {
		return &it
	}) // generate one case for OneOf type
	gens["EventHub"] = EventHubEventSubscriptionDestinationARMGenerator().Map(func(it EventHubEventSubscriptionDestinationARM) *EventHubEventSubscriptionDestinationARM {
		return &it
	}) // generate one case for OneOf type
	gens["HybridConnection"] = HybridConnectionEventSubscriptionDestinationARMGenerator().Map(func(it HybridConnectionEventSubscriptionDestinationARM) *HybridConnectionEventSubscriptionDestinationARM {
		return &it
	}) // generate one case for OneOf type
	gens["ServiceBusQueue"] = ServiceBusQueueEventSubscriptionDestinationARMGenerator().Map(func(it ServiceBusQueueEventSubscriptionDestinationARM) *ServiceBusQueueEventSubscriptionDestinationARM {
		return &it
	}) // generate one case for OneOf type
	gens["ServiceBusTopic"] = ServiceBusTopicEventSubscriptionDestinationARMGenerator().Map(func(it ServiceBusTopicEventSubscriptionDestinationARM) *ServiceBusTopicEventSubscriptionDestinationARM {
		return &it
	}) // generate one case for OneOf type
	gens["StorageQueue"] = StorageQueueEventSubscriptionDestinationARMGenerator().Map(func(it StorageQueueEventSubscriptionDestinationARM) *StorageQueueEventSubscriptionDestinationARM {
		return &it
	}) // generate one case for OneOf type
	gens["WebHook"] = WebHookEventSubscriptionDestinationARMGenerator().Map(func(it WebHookEventSubscriptionDestinationARM) *WebHookEventSubscriptionDestinationARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_EventSubscriptionFilterARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionFilterARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilterARM, EventSubscriptionFilterARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilterARM runs a test to see if a specific instance of EventSubscriptionFilterARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilterARM(subject EventSubscriptionFilterARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionFilterARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionFilterARM instances for property testing - lazily instantiated by
// EventSubscriptionFilterARMGenerator()
var eventSubscriptionFilterARMGenerator gopter.Gen

// EventSubscriptionFilterARMGenerator returns a generator of EventSubscriptionFilterARM instances for property testing.
// We first initialize eventSubscriptionFilterARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilterARMGenerator() gopter.Gen {
	if eventSubscriptionFilterARMGenerator != nil {
		return eventSubscriptionFilterARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterARM(generators)
	eventSubscriptionFilterARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilterARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterARM(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilterARM(generators)
	eventSubscriptionFilterARMGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilterARM{}), generators)

	return eventSubscriptionFilterARMGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilterARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilterARM(gens map[string]gopter.Gen) {
	gens["IncludedEventTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IsSubjectCaseSensitive"] = gen.PtrOf(gen.Bool())
	gens["SubjectBeginsWith"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectEndsWith"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionFilterARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilterARM(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilterARMGenerator())
}

func Test_RetryPolicyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicyARM, RetryPolicyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicyARM runs a test to see if a specific instance of RetryPolicyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicyARM(subject RetryPolicyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicyARM instances for property testing - lazily instantiated by RetryPolicyARMGenerator()
var retryPolicyARMGenerator gopter.Gen

// RetryPolicyARMGenerator returns a generator of RetryPolicyARM instances for property testing.
func RetryPolicyARMGenerator() gopter.Gen {
	if retryPolicyARMGenerator != nil {
		return retryPolicyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicyARM(generators)
	retryPolicyARMGenerator = gen.Struct(reflect.TypeOf(RetryPolicyARM{}), generators)

	return retryPolicyARMGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicyARM(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_StorageBlobDeadLetterDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlobDeadLetterDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlobDeadLetterDestinationARM, StorageBlobDeadLetterDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlobDeadLetterDestinationARM runs a test to see if a specific instance of StorageBlobDeadLetterDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlobDeadLetterDestinationARM(subject StorageBlobDeadLetterDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlobDeadLetterDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlobDeadLetterDestinationARM instances for property testing - lazily instantiated by
// StorageBlobDeadLetterDestinationARMGenerator()
var storageBlobDeadLetterDestinationARMGenerator gopter.Gen

// StorageBlobDeadLetterDestinationARMGenerator returns a generator of StorageBlobDeadLetterDestinationARM instances for property testing.
// We first initialize storageBlobDeadLetterDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageBlobDeadLetterDestinationARMGenerator() gopter.Gen {
	if storageBlobDeadLetterDestinationARMGenerator != nil {
		return storageBlobDeadLetterDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationARM(generators)
	storageBlobDeadLetterDestinationARMGenerator = gen.Struct(reflect.TypeOf(StorageBlobDeadLetterDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationARM(generators)
	AddRelatedPropertyGeneratorsForStorageBlobDeadLetterDestinationARM(generators)
	storageBlobDeadLetterDestinationARMGenerator = gen.Struct(reflect.TypeOf(StorageBlobDeadLetterDestinationARM{}), generators)

	return storageBlobDeadLetterDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.PtrOf(gen.OneConstOf(StorageBlobDeadLetterDestinationEndpointTypeStorageBlob))
}

// AddRelatedPropertyGeneratorsForStorageBlobDeadLetterDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageBlobDeadLetterDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(StorageBlobDeadLetterDestinationPropertiesARMGenerator())
}

func Test_AdvancedFilterARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilterARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterARM, AdvancedFilterARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterARM runs a test to see if a specific instance of AdvancedFilterARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterARM(subject AdvancedFilterARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilterARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilterARM instances for property testing - lazily instantiated by AdvancedFilterARMGenerator()
var advancedFilterARMGenerator gopter.Gen

// AdvancedFilterARMGenerator returns a generator of AdvancedFilterARM instances for property testing.
func AdvancedFilterARMGenerator() gopter.Gen {
	if advancedFilterARMGenerator != nil {
		return advancedFilterARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAdvancedFilterARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(AdvancedFilterARM{}), map[string]gopter.Gen{
			propName: propGen,
		}))
	}
	advancedFilterARMGenerator = gen.OneGenOf(gens...)

	return advancedFilterARMGenerator
}

// AddRelatedPropertyGeneratorsForAdvancedFilterARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdvancedFilterARM(gens map[string]gopter.Gen) {
	gens["BoolEquals"] = AdvancedFilterBoolEqualsARMGenerator().Map(func(it AdvancedFilter_BoolEqualsARM) *AdvancedFilter_BoolEqualsARM {
		return &it
	}) // generate one case for OneOf type
	gens["NumberGreaterThan"] = AdvancedFilterNumberGreaterThanARMGenerator().Map(func(it AdvancedFilter_NumberGreaterThanARM) *AdvancedFilter_NumberGreaterThanARM {
		return &it
	}) // generate one case for OneOf type
	gens["NumberGreaterThanOrEquals"] = AdvancedFilterNumberGreaterThanOrEqualsARMGenerator().Map(func(it AdvancedFilter_NumberGreaterThanOrEqualsARM) *AdvancedFilter_NumberGreaterThanOrEqualsARM {
		return &it
	}) // generate one case for OneOf type
	gens["NumberIn"] = AdvancedFilterNumberInARMGenerator().Map(func(it AdvancedFilter_NumberInARM) *AdvancedFilter_NumberInARM {
		return &it
	}) // generate one case for OneOf type
	gens["NumberLessThan"] = AdvancedFilterNumberLessThanARMGenerator().Map(func(it AdvancedFilter_NumberLessThanARM) *AdvancedFilter_NumberLessThanARM {
		return &it
	}) // generate one case for OneOf type
	gens["NumberLessThanOrEquals"] = AdvancedFilterNumberLessThanOrEqualsARMGenerator().Map(func(it AdvancedFilter_NumberLessThanOrEqualsARM) *AdvancedFilter_NumberLessThanOrEqualsARM {
		return &it
	}) // generate one case for OneOf type
	gens["NumberNotIn"] = AdvancedFilterNumberNotInARMGenerator().Map(func(it AdvancedFilter_NumberNotInARM) *AdvancedFilter_NumberNotInARM {
		return &it
	}) // generate one case for OneOf type
	gens["StringBeginsWith"] = AdvancedFilterStringBeginsWithARMGenerator().Map(func(it AdvancedFilter_StringBeginsWithARM) *AdvancedFilter_StringBeginsWithARM {
		return &it
	}) // generate one case for OneOf type
	gens["StringContains"] = AdvancedFilterStringContainsARMGenerator().Map(func(it AdvancedFilter_StringContainsARM) *AdvancedFilter_StringContainsARM {
		return &it
	}) // generate one case for OneOf type
	gens["StringEndsWith"] = AdvancedFilterStringEndsWithARMGenerator().Map(func(it AdvancedFilter_StringEndsWithARM) *AdvancedFilter_StringEndsWithARM {
		return &it
	}) // generate one case for OneOf type
	gens["StringIn"] = AdvancedFilterStringInARMGenerator().Map(func(it AdvancedFilter_StringInARM) *AdvancedFilter_StringInARM {
		return &it
	}) // generate one case for OneOf type
	gens["StringNotIn"] = AdvancedFilterStringNotInARMGenerator().Map(func(it AdvancedFilter_StringNotInARM) *AdvancedFilter_StringNotInARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_AzureFunctionEventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFunctionEventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationARM, AzureFunctionEventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationARM runs a test to see if a specific instance of AzureFunctionEventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationARM(subject AzureFunctionEventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFunctionEventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFunctionEventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// AzureFunctionEventSubscriptionDestinationARMGenerator()
var azureFunctionEventSubscriptionDestinationARMGenerator gopter.Gen

// AzureFunctionEventSubscriptionDestinationARMGenerator returns a generator of AzureFunctionEventSubscriptionDestinationARM instances for property testing.
// We first initialize azureFunctionEventSubscriptionDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFunctionEventSubscriptionDestinationARMGenerator() gopter.Gen {
	if azureFunctionEventSubscriptionDestinationARMGenerator != nil {
		return azureFunctionEventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationARM(generators)
	azureFunctionEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(AzureFunctionEventSubscriptionDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationARM(generators)
	AddRelatedPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationARM(generators)
	azureFunctionEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(AzureFunctionEventSubscriptionDestinationARM{}), generators)

	return azureFunctionEventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(AzureFunctionEventSubscriptionDestinationEndpointTypeAzureFunction)
}

// AddRelatedPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AzureFunctionEventSubscriptionDestinationPropertiesARMGenerator())
}

func Test_EventHubEventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubEventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubEventSubscriptionDestinationARM, EventHubEventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubEventSubscriptionDestinationARM runs a test to see if a specific instance of EventHubEventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubEventSubscriptionDestinationARM(subject EventHubEventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubEventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubEventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// EventHubEventSubscriptionDestinationARMGenerator()
var eventHubEventSubscriptionDestinationARMGenerator gopter.Gen

// EventHubEventSubscriptionDestinationARMGenerator returns a generator of EventHubEventSubscriptionDestinationARM instances for property testing.
// We first initialize eventHubEventSubscriptionDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventHubEventSubscriptionDestinationARMGenerator() gopter.Gen {
	if eventHubEventSubscriptionDestinationARMGenerator != nil {
		return eventHubEventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationARM(generators)
	eventHubEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(EventHubEventSubscriptionDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationARM(generators)
	AddRelatedPropertyGeneratorsForEventHubEventSubscriptionDestinationARM(generators)
	eventHubEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(EventHubEventSubscriptionDestinationARM{}), generators)

	return eventHubEventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(EventHubEventSubscriptionDestinationEndpointTypeEventHub)
}

// AddRelatedPropertyGeneratorsForEventHubEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventHubEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(EventHubEventSubscriptionDestinationPropertiesARMGenerator())
}

func Test_HybridConnectionEventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HybridConnectionEventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationARM, HybridConnectionEventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationARM runs a test to see if a specific instance of HybridConnectionEventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationARM(subject HybridConnectionEventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HybridConnectionEventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HybridConnectionEventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// HybridConnectionEventSubscriptionDestinationARMGenerator()
var hybridConnectionEventSubscriptionDestinationARMGenerator gopter.Gen

// HybridConnectionEventSubscriptionDestinationARMGenerator returns a generator of HybridConnectionEventSubscriptionDestinationARM instances for property testing.
// We first initialize hybridConnectionEventSubscriptionDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HybridConnectionEventSubscriptionDestinationARMGenerator() gopter.Gen {
	if hybridConnectionEventSubscriptionDestinationARMGenerator != nil {
		return hybridConnectionEventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationARM(generators)
	hybridConnectionEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(HybridConnectionEventSubscriptionDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationARM(generators)
	AddRelatedPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationARM(generators)
	hybridConnectionEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(HybridConnectionEventSubscriptionDestinationARM{}), generators)

	return hybridConnectionEventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(HybridConnectionEventSubscriptionDestinationEndpointTypeHybridConnection)
}

// AddRelatedPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(HybridConnectionEventSubscriptionDestinationPropertiesARMGenerator())
}

func Test_ServiceBusQueueEventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusQueueEventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationARM, ServiceBusQueueEventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationARM runs a test to see if a specific instance of ServiceBusQueueEventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationARM(subject ServiceBusQueueEventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusQueueEventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusQueueEventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// ServiceBusQueueEventSubscriptionDestinationARMGenerator()
var serviceBusQueueEventSubscriptionDestinationARMGenerator gopter.Gen

// ServiceBusQueueEventSubscriptionDestinationARMGenerator returns a generator of ServiceBusQueueEventSubscriptionDestinationARM instances for property testing.
// We first initialize serviceBusQueueEventSubscriptionDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServiceBusQueueEventSubscriptionDestinationARMGenerator() gopter.Gen {
	if serviceBusQueueEventSubscriptionDestinationARMGenerator != nil {
		return serviceBusQueueEventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationARM(generators)
	serviceBusQueueEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(ServiceBusQueueEventSubscriptionDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationARM(generators)
	AddRelatedPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationARM(generators)
	serviceBusQueueEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(ServiceBusQueueEventSubscriptionDestinationARM{}), generators)

	return serviceBusQueueEventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(ServiceBusQueueEventSubscriptionDestinationEndpointTypeServiceBusQueue)
}

// AddRelatedPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ServiceBusQueueEventSubscriptionDestinationPropertiesARMGenerator())
}

func Test_ServiceBusTopicEventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusTopicEventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationARM, ServiceBusTopicEventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationARM runs a test to see if a specific instance of ServiceBusTopicEventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationARM(subject ServiceBusTopicEventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusTopicEventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusTopicEventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// ServiceBusTopicEventSubscriptionDestinationARMGenerator()
var serviceBusTopicEventSubscriptionDestinationARMGenerator gopter.Gen

// ServiceBusTopicEventSubscriptionDestinationARMGenerator returns a generator of ServiceBusTopicEventSubscriptionDestinationARM instances for property testing.
// We first initialize serviceBusTopicEventSubscriptionDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServiceBusTopicEventSubscriptionDestinationARMGenerator() gopter.Gen {
	if serviceBusTopicEventSubscriptionDestinationARMGenerator != nil {
		return serviceBusTopicEventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationARM(generators)
	serviceBusTopicEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(ServiceBusTopicEventSubscriptionDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationARM(generators)
	AddRelatedPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationARM(generators)
	serviceBusTopicEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(ServiceBusTopicEventSubscriptionDestinationARM{}), generators)

	return serviceBusTopicEventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(ServiceBusTopicEventSubscriptionDestinationEndpointTypeServiceBusTopic)
}

// AddRelatedPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ServiceBusTopicEventSubscriptionDestinationPropertiesARMGenerator())
}

func Test_StorageBlobDeadLetterDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlobDeadLetterDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlobDeadLetterDestinationPropertiesARM, StorageBlobDeadLetterDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlobDeadLetterDestinationPropertiesARM runs a test to see if a specific instance of StorageBlobDeadLetterDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlobDeadLetterDestinationPropertiesARM(subject StorageBlobDeadLetterDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlobDeadLetterDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlobDeadLetterDestinationPropertiesARM instances for property testing - lazily instantiated by
// StorageBlobDeadLetterDestinationPropertiesARMGenerator()
var storageBlobDeadLetterDestinationPropertiesARMGenerator gopter.Gen

// StorageBlobDeadLetterDestinationPropertiesARMGenerator returns a generator of StorageBlobDeadLetterDestinationPropertiesARM instances for property testing.
func StorageBlobDeadLetterDestinationPropertiesARMGenerator() gopter.Gen {
	if storageBlobDeadLetterDestinationPropertiesARMGenerator != nil {
		return storageBlobDeadLetterDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationPropertiesARM(generators)
	storageBlobDeadLetterDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(StorageBlobDeadLetterDestinationPropertiesARM{}), generators)

	return storageBlobDeadLetterDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["BlobContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageQueueEventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageQueueEventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationARM, StorageQueueEventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationARM runs a test to see if a specific instance of StorageQueueEventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationARM(subject StorageQueueEventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageQueueEventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageQueueEventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// StorageQueueEventSubscriptionDestinationARMGenerator()
var storageQueueEventSubscriptionDestinationARMGenerator gopter.Gen

// StorageQueueEventSubscriptionDestinationARMGenerator returns a generator of StorageQueueEventSubscriptionDestinationARM instances for property testing.
// We first initialize storageQueueEventSubscriptionDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageQueueEventSubscriptionDestinationARMGenerator() gopter.Gen {
	if storageQueueEventSubscriptionDestinationARMGenerator != nil {
		return storageQueueEventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationARM(generators)
	storageQueueEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(StorageQueueEventSubscriptionDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationARM(generators)
	AddRelatedPropertyGeneratorsForStorageQueueEventSubscriptionDestinationARM(generators)
	storageQueueEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(StorageQueueEventSubscriptionDestinationARM{}), generators)

	return storageQueueEventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(StorageQueueEventSubscriptionDestinationEndpointTypeStorageQueue)
}

// AddRelatedPropertyGeneratorsForStorageQueueEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageQueueEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(StorageQueueEventSubscriptionDestinationPropertiesARMGenerator())
}

func Test_WebHookEventSubscriptionDestinationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebHookEventSubscriptionDestinationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebHookEventSubscriptionDestinationARM, WebHookEventSubscriptionDestinationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebHookEventSubscriptionDestinationARM runs a test to see if a specific instance of WebHookEventSubscriptionDestinationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebHookEventSubscriptionDestinationARM(subject WebHookEventSubscriptionDestinationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebHookEventSubscriptionDestinationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebHookEventSubscriptionDestinationARM instances for property testing - lazily instantiated by
// WebHookEventSubscriptionDestinationARMGenerator()
var webHookEventSubscriptionDestinationARMGenerator gopter.Gen

// WebHookEventSubscriptionDestinationARMGenerator returns a generator of WebHookEventSubscriptionDestinationARM instances for property testing.
// We first initialize webHookEventSubscriptionDestinationARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebHookEventSubscriptionDestinationARMGenerator() gopter.Gen {
	if webHookEventSubscriptionDestinationARMGenerator != nil {
		return webHookEventSubscriptionDestinationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationARM(generators)
	webHookEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(WebHookEventSubscriptionDestinationARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationARM(generators)
	AddRelatedPropertyGeneratorsForWebHookEventSubscriptionDestinationARM(generators)
	webHookEventSubscriptionDestinationARMGenerator = gen.Struct(reflect.TypeOf(WebHookEventSubscriptionDestinationARM{}), generators)

	return webHookEventSubscriptionDestinationARMGenerator
}

// AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(WebHookEventSubscriptionDestinationEndpointTypeWebHook)
}

// AddRelatedPropertyGeneratorsForWebHookEventSubscriptionDestinationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebHookEventSubscriptionDestinationARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(WebHookEventSubscriptionDestinationPropertiesARMGenerator())
}

func Test_AdvancedFilter_BoolEqualsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_BoolEqualsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterBoolEqualsARM, AdvancedFilterBoolEqualsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterBoolEqualsARM runs a test to see if a specific instance of AdvancedFilter_BoolEqualsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterBoolEqualsARM(subject AdvancedFilter_BoolEqualsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_BoolEqualsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_BoolEqualsARM instances for property testing - lazily instantiated by
// AdvancedFilterBoolEqualsARMGenerator()
var advancedFilterBoolEqualsARMGenerator gopter.Gen

// AdvancedFilterBoolEqualsARMGenerator returns a generator of AdvancedFilter_BoolEqualsARM instances for property testing.
func AdvancedFilterBoolEqualsARMGenerator() gopter.Gen {
	if advancedFilterBoolEqualsARMGenerator != nil {
		return advancedFilterBoolEqualsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterBoolEqualsARM(generators)
	advancedFilterBoolEqualsARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_BoolEqualsARM{}), generators)

	return advancedFilterBoolEqualsARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterBoolEqualsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterBoolEqualsARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilterBoolEqualsOperatorTypeBoolEquals)
	gens["Value"] = gen.PtrOf(gen.Bool())
}

func Test_AdvancedFilter_NumberGreaterThanARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_NumberGreaterThanARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterNumberGreaterThanARM, AdvancedFilterNumberGreaterThanARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterNumberGreaterThanARM runs a test to see if a specific instance of AdvancedFilter_NumberGreaterThanARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterNumberGreaterThanARM(subject AdvancedFilter_NumberGreaterThanARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_NumberGreaterThanARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_NumberGreaterThanARM instances for property testing - lazily instantiated by
// AdvancedFilterNumberGreaterThanARMGenerator()
var advancedFilterNumberGreaterThanARMGenerator gopter.Gen

// AdvancedFilterNumberGreaterThanARMGenerator returns a generator of AdvancedFilter_NumberGreaterThanARM instances for property testing.
func AdvancedFilterNumberGreaterThanARMGenerator() gopter.Gen {
	if advancedFilterNumberGreaterThanARMGenerator != nil {
		return advancedFilterNumberGreaterThanARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterNumberGreaterThanARM(generators)
	advancedFilterNumberGreaterThanARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_NumberGreaterThanARM{}), generators)

	return advancedFilterNumberGreaterThanARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterNumberGreaterThanARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterNumberGreaterThanARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilterNumberGreaterThanOperatorTypeNumberGreaterThan)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_AdvancedFilter_NumberGreaterThanOrEqualsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_NumberGreaterThanOrEqualsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterNumberGreaterThanOrEqualsARM, AdvancedFilterNumberGreaterThanOrEqualsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterNumberGreaterThanOrEqualsARM runs a test to see if a specific instance of AdvancedFilter_NumberGreaterThanOrEqualsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterNumberGreaterThanOrEqualsARM(subject AdvancedFilter_NumberGreaterThanOrEqualsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_NumberGreaterThanOrEqualsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_NumberGreaterThanOrEqualsARM instances for property testing - lazily instantiated by
// AdvancedFilterNumberGreaterThanOrEqualsARMGenerator()
var advancedFilterNumberGreaterThanOrEqualsARMGenerator gopter.Gen

// AdvancedFilterNumberGreaterThanOrEqualsARMGenerator returns a generator of AdvancedFilter_NumberGreaterThanOrEqualsARM instances for property testing.
func AdvancedFilterNumberGreaterThanOrEqualsARMGenerator() gopter.Gen {
	if advancedFilterNumberGreaterThanOrEqualsARMGenerator != nil {
		return advancedFilterNumberGreaterThanOrEqualsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterNumberGreaterThanOrEqualsARM(generators)
	advancedFilterNumberGreaterThanOrEqualsARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_NumberGreaterThanOrEqualsARM{}), generators)

	return advancedFilterNumberGreaterThanOrEqualsARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterNumberGreaterThanOrEqualsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterNumberGreaterThanOrEqualsARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilterNumberGreaterThanOrEqualsOperatorTypeNumberGreaterThanOrEquals)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_AdvancedFilter_NumberInARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_NumberInARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterNumberInARM, AdvancedFilterNumberInARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterNumberInARM runs a test to see if a specific instance of AdvancedFilter_NumberInARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterNumberInARM(subject AdvancedFilter_NumberInARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_NumberInARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_NumberInARM instances for property testing - lazily instantiated by
// AdvancedFilterNumberInARMGenerator()
var advancedFilterNumberInARMGenerator gopter.Gen

// AdvancedFilterNumberInARMGenerator returns a generator of AdvancedFilter_NumberInARM instances for property testing.
func AdvancedFilterNumberInARMGenerator() gopter.Gen {
	if advancedFilterNumberInARMGenerator != nil {
		return advancedFilterNumberInARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterNumberInARM(generators)
	advancedFilterNumberInARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_NumberInARM{}), generators)

	return advancedFilterNumberInARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterNumberInARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterNumberInARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilterNumberInOperatorTypeNumberIn)
	gens["Values"] = gen.SliceOf(gen.Float64())
}

func Test_AdvancedFilter_NumberLessThanARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_NumberLessThanARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterNumberLessThanARM, AdvancedFilterNumberLessThanARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterNumberLessThanARM runs a test to see if a specific instance of AdvancedFilter_NumberLessThanARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterNumberLessThanARM(subject AdvancedFilter_NumberLessThanARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_NumberLessThanARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_NumberLessThanARM instances for property testing - lazily instantiated by
// AdvancedFilterNumberLessThanARMGenerator()
var advancedFilterNumberLessThanARMGenerator gopter.Gen

// AdvancedFilterNumberLessThanARMGenerator returns a generator of AdvancedFilter_NumberLessThanARM instances for property testing.
func AdvancedFilterNumberLessThanARMGenerator() gopter.Gen {
	if advancedFilterNumberLessThanARMGenerator != nil {
		return advancedFilterNumberLessThanARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterNumberLessThanARM(generators)
	advancedFilterNumberLessThanARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_NumberLessThanARM{}), generators)

	return advancedFilterNumberLessThanARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterNumberLessThanARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterNumberLessThanARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilterNumberLessThanOperatorTypeNumberLessThan)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_AdvancedFilter_NumberLessThanOrEqualsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_NumberLessThanOrEqualsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterNumberLessThanOrEqualsARM, AdvancedFilterNumberLessThanOrEqualsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterNumberLessThanOrEqualsARM runs a test to see if a specific instance of AdvancedFilter_NumberLessThanOrEqualsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterNumberLessThanOrEqualsARM(subject AdvancedFilter_NumberLessThanOrEqualsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_NumberLessThanOrEqualsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_NumberLessThanOrEqualsARM instances for property testing - lazily instantiated by
// AdvancedFilterNumberLessThanOrEqualsARMGenerator()
var advancedFilterNumberLessThanOrEqualsARMGenerator gopter.Gen

// AdvancedFilterNumberLessThanOrEqualsARMGenerator returns a generator of AdvancedFilter_NumberLessThanOrEqualsARM instances for property testing.
func AdvancedFilterNumberLessThanOrEqualsARMGenerator() gopter.Gen {
	if advancedFilterNumberLessThanOrEqualsARMGenerator != nil {
		return advancedFilterNumberLessThanOrEqualsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterNumberLessThanOrEqualsARM(generators)
	advancedFilterNumberLessThanOrEqualsARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_NumberLessThanOrEqualsARM{}), generators)

	return advancedFilterNumberLessThanOrEqualsARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterNumberLessThanOrEqualsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterNumberLessThanOrEqualsARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilterNumberLessThanOrEqualsOperatorTypeNumberLessThanOrEquals)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_AdvancedFilter_NumberNotInARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_NumberNotInARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterNumberNotInARM, AdvancedFilterNumberNotInARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterNumberNotInARM runs a test to see if a specific instance of AdvancedFilter_NumberNotInARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterNumberNotInARM(subject AdvancedFilter_NumberNotInARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_NumberNotInARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_NumberNotInARM instances for property testing - lazily instantiated by
// AdvancedFilterNumberNotInARMGenerator()
var advancedFilterNumberNotInARMGenerator gopter.Gen

// AdvancedFilterNumberNotInARMGenerator returns a generator of AdvancedFilter_NumberNotInARM instances for property testing.
func AdvancedFilterNumberNotInARMGenerator() gopter.Gen {
	if advancedFilterNumberNotInARMGenerator != nil {
		return advancedFilterNumberNotInARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterNumberNotInARM(generators)
	advancedFilterNumberNotInARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_NumberNotInARM{}), generators)

	return advancedFilterNumberNotInARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterNumberNotInARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterNumberNotInARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilterNumberNotInOperatorTypeNumberNotIn)
	gens["Values"] = gen.SliceOf(gen.Float64())
}

func Test_AdvancedFilter_StringBeginsWithARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_StringBeginsWithARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterStringBeginsWithARM, AdvancedFilterStringBeginsWithARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterStringBeginsWithARM runs a test to see if a specific instance of AdvancedFilter_StringBeginsWithARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterStringBeginsWithARM(subject AdvancedFilter_StringBeginsWithARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_StringBeginsWithARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_StringBeginsWithARM instances for property testing - lazily instantiated by
// AdvancedFilterStringBeginsWithARMGenerator()
var advancedFilterStringBeginsWithARMGenerator gopter.Gen

// AdvancedFilterStringBeginsWithARMGenerator returns a generator of AdvancedFilter_StringBeginsWithARM instances for property testing.
func AdvancedFilterStringBeginsWithARMGenerator() gopter.Gen {
	if advancedFilterStringBeginsWithARMGenerator != nil {
		return advancedFilterStringBeginsWithARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterStringBeginsWithARM(generators)
	advancedFilterStringBeginsWithARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_StringBeginsWithARM{}), generators)

	return advancedFilterStringBeginsWithARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterStringBeginsWithARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterStringBeginsWithARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilterStringBeginsWithOperatorTypeStringBeginsWith)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_AdvancedFilter_StringContainsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_StringContainsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterStringContainsARM, AdvancedFilterStringContainsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterStringContainsARM runs a test to see if a specific instance of AdvancedFilter_StringContainsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterStringContainsARM(subject AdvancedFilter_StringContainsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_StringContainsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_StringContainsARM instances for property testing - lazily instantiated by
// AdvancedFilterStringContainsARMGenerator()
var advancedFilterStringContainsARMGenerator gopter.Gen

// AdvancedFilterStringContainsARMGenerator returns a generator of AdvancedFilter_StringContainsARM instances for property testing.
func AdvancedFilterStringContainsARMGenerator() gopter.Gen {
	if advancedFilterStringContainsARMGenerator != nil {
		return advancedFilterStringContainsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterStringContainsARM(generators)
	advancedFilterStringContainsARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_StringContainsARM{}), generators)

	return advancedFilterStringContainsARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterStringContainsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterStringContainsARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilterStringContainsOperatorTypeStringContains)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_AdvancedFilter_StringEndsWithARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_StringEndsWithARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterStringEndsWithARM, AdvancedFilterStringEndsWithARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterStringEndsWithARM runs a test to see if a specific instance of AdvancedFilter_StringEndsWithARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterStringEndsWithARM(subject AdvancedFilter_StringEndsWithARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_StringEndsWithARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_StringEndsWithARM instances for property testing - lazily instantiated by
// AdvancedFilterStringEndsWithARMGenerator()
var advancedFilterStringEndsWithARMGenerator gopter.Gen

// AdvancedFilterStringEndsWithARMGenerator returns a generator of AdvancedFilter_StringEndsWithARM instances for property testing.
func AdvancedFilterStringEndsWithARMGenerator() gopter.Gen {
	if advancedFilterStringEndsWithARMGenerator != nil {
		return advancedFilterStringEndsWithARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterStringEndsWithARM(generators)
	advancedFilterStringEndsWithARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_StringEndsWithARM{}), generators)

	return advancedFilterStringEndsWithARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterStringEndsWithARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterStringEndsWithARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilterStringEndsWithOperatorTypeStringEndsWith)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_AdvancedFilter_StringInARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_StringInARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterStringInARM, AdvancedFilterStringInARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterStringInARM runs a test to see if a specific instance of AdvancedFilter_StringInARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterStringInARM(subject AdvancedFilter_StringInARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_StringInARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_StringInARM instances for property testing - lazily instantiated by
// AdvancedFilterStringInARMGenerator()
var advancedFilterStringInARMGenerator gopter.Gen

// AdvancedFilterStringInARMGenerator returns a generator of AdvancedFilter_StringInARM instances for property testing.
func AdvancedFilterStringInARMGenerator() gopter.Gen {
	if advancedFilterStringInARMGenerator != nil {
		return advancedFilterStringInARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterStringInARM(generators)
	advancedFilterStringInARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_StringInARM{}), generators)

	return advancedFilterStringInARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterStringInARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterStringInARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilterStringInOperatorTypeStringIn)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_AdvancedFilter_StringNotInARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_StringNotInARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterStringNotInARM, AdvancedFilterStringNotInARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterStringNotInARM runs a test to see if a specific instance of AdvancedFilter_StringNotInARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterStringNotInARM(subject AdvancedFilter_StringNotInARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_StringNotInARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_StringNotInARM instances for property testing - lazily instantiated by
// AdvancedFilterStringNotInARMGenerator()
var advancedFilterStringNotInARMGenerator gopter.Gen

// AdvancedFilterStringNotInARMGenerator returns a generator of AdvancedFilter_StringNotInARM instances for property testing.
func AdvancedFilterStringNotInARMGenerator() gopter.Gen {
	if advancedFilterStringNotInARMGenerator != nil {
		return advancedFilterStringNotInARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterStringNotInARM(generators)
	advancedFilterStringNotInARMGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_StringNotInARM{}), generators)

	return advancedFilterStringNotInARMGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterStringNotInARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterStringNotInARM(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(AdvancedFilterStringNotInOperatorTypeStringNotIn)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_AzureFunctionEventSubscriptionDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFunctionEventSubscriptionDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationPropertiesARM, AzureFunctionEventSubscriptionDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationPropertiesARM runs a test to see if a specific instance of AzureFunctionEventSubscriptionDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationPropertiesARM(subject AzureFunctionEventSubscriptionDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFunctionEventSubscriptionDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFunctionEventSubscriptionDestinationPropertiesARM instances for property testing - lazily
// instantiated by AzureFunctionEventSubscriptionDestinationPropertiesARMGenerator()
var azureFunctionEventSubscriptionDestinationPropertiesARMGenerator gopter.Gen

// AzureFunctionEventSubscriptionDestinationPropertiesARMGenerator returns a generator of AzureFunctionEventSubscriptionDestinationPropertiesARM instances for property testing.
func AzureFunctionEventSubscriptionDestinationPropertiesARMGenerator() gopter.Gen {
	if azureFunctionEventSubscriptionDestinationPropertiesARMGenerator != nil {
		return azureFunctionEventSubscriptionDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationPropertiesARM(generators)
	azureFunctionEventSubscriptionDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(AzureFunctionEventSubscriptionDestinationPropertiesARM{}), generators)

	return azureFunctionEventSubscriptionDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["MaxEventsPerBatch"] = gen.PtrOf(gen.Int())
	gens["PreferredBatchSizeInKilobytes"] = gen.PtrOf(gen.Int())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubEventSubscriptionDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubEventSubscriptionDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubEventSubscriptionDestinationPropertiesARM, EventHubEventSubscriptionDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubEventSubscriptionDestinationPropertiesARM runs a test to see if a specific instance of EventHubEventSubscriptionDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubEventSubscriptionDestinationPropertiesARM(subject EventHubEventSubscriptionDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubEventSubscriptionDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubEventSubscriptionDestinationPropertiesARM instances for property testing - lazily instantiated
// by EventHubEventSubscriptionDestinationPropertiesARMGenerator()
var eventHubEventSubscriptionDestinationPropertiesARMGenerator gopter.Gen

// EventHubEventSubscriptionDestinationPropertiesARMGenerator returns a generator of EventHubEventSubscriptionDestinationPropertiesARM instances for property testing.
func EventHubEventSubscriptionDestinationPropertiesARMGenerator() gopter.Gen {
	if eventHubEventSubscriptionDestinationPropertiesARMGenerator != nil {
		return eventHubEventSubscriptionDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationPropertiesARM(generators)
	eventHubEventSubscriptionDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(EventHubEventSubscriptionDestinationPropertiesARM{}), generators)

	return eventHubEventSubscriptionDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_HybridConnectionEventSubscriptionDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HybridConnectionEventSubscriptionDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationPropertiesARM, HybridConnectionEventSubscriptionDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationPropertiesARM runs a test to see if a specific instance of HybridConnectionEventSubscriptionDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationPropertiesARM(subject HybridConnectionEventSubscriptionDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HybridConnectionEventSubscriptionDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HybridConnectionEventSubscriptionDestinationPropertiesARM instances for property testing - lazily
// instantiated by HybridConnectionEventSubscriptionDestinationPropertiesARMGenerator()
var hybridConnectionEventSubscriptionDestinationPropertiesARMGenerator gopter.Gen

// HybridConnectionEventSubscriptionDestinationPropertiesARMGenerator returns a generator of HybridConnectionEventSubscriptionDestinationPropertiesARM instances for property testing.
func HybridConnectionEventSubscriptionDestinationPropertiesARMGenerator() gopter.Gen {
	if hybridConnectionEventSubscriptionDestinationPropertiesARMGenerator != nil {
		return hybridConnectionEventSubscriptionDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationPropertiesARM(generators)
	hybridConnectionEventSubscriptionDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(HybridConnectionEventSubscriptionDestinationPropertiesARM{}), generators)

	return hybridConnectionEventSubscriptionDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceBusQueueEventSubscriptionDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusQueueEventSubscriptionDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationPropertiesARM, ServiceBusQueueEventSubscriptionDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationPropertiesARM runs a test to see if a specific instance of ServiceBusQueueEventSubscriptionDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationPropertiesARM(subject ServiceBusQueueEventSubscriptionDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusQueueEventSubscriptionDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusQueueEventSubscriptionDestinationPropertiesARM instances for property testing - lazily
// instantiated by ServiceBusQueueEventSubscriptionDestinationPropertiesARMGenerator()
var serviceBusQueueEventSubscriptionDestinationPropertiesARMGenerator gopter.Gen

// ServiceBusQueueEventSubscriptionDestinationPropertiesARMGenerator returns a generator of ServiceBusQueueEventSubscriptionDestinationPropertiesARM instances for property testing.
func ServiceBusQueueEventSubscriptionDestinationPropertiesARMGenerator() gopter.Gen {
	if serviceBusQueueEventSubscriptionDestinationPropertiesARMGenerator != nil {
		return serviceBusQueueEventSubscriptionDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationPropertiesARM(generators)
	serviceBusQueueEventSubscriptionDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(ServiceBusQueueEventSubscriptionDestinationPropertiesARM{}), generators)

	return serviceBusQueueEventSubscriptionDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceBusTopicEventSubscriptionDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusTopicEventSubscriptionDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationPropertiesARM, ServiceBusTopicEventSubscriptionDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationPropertiesARM runs a test to see if a specific instance of ServiceBusTopicEventSubscriptionDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationPropertiesARM(subject ServiceBusTopicEventSubscriptionDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusTopicEventSubscriptionDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusTopicEventSubscriptionDestinationPropertiesARM instances for property testing - lazily
// instantiated by ServiceBusTopicEventSubscriptionDestinationPropertiesARMGenerator()
var serviceBusTopicEventSubscriptionDestinationPropertiesARMGenerator gopter.Gen

// ServiceBusTopicEventSubscriptionDestinationPropertiesARMGenerator returns a generator of ServiceBusTopicEventSubscriptionDestinationPropertiesARM instances for property testing.
func ServiceBusTopicEventSubscriptionDestinationPropertiesARMGenerator() gopter.Gen {
	if serviceBusTopicEventSubscriptionDestinationPropertiesARMGenerator != nil {
		return serviceBusTopicEventSubscriptionDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationPropertiesARM(generators)
	serviceBusTopicEventSubscriptionDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(ServiceBusTopicEventSubscriptionDestinationPropertiesARM{}), generators)

	return serviceBusTopicEventSubscriptionDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageQueueEventSubscriptionDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageQueueEventSubscriptionDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationPropertiesARM, StorageQueueEventSubscriptionDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationPropertiesARM runs a test to see if a specific instance of StorageQueueEventSubscriptionDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationPropertiesARM(subject StorageQueueEventSubscriptionDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageQueueEventSubscriptionDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageQueueEventSubscriptionDestinationPropertiesARM instances for property testing - lazily
// instantiated by StorageQueueEventSubscriptionDestinationPropertiesARMGenerator()
var storageQueueEventSubscriptionDestinationPropertiesARMGenerator gopter.Gen

// StorageQueueEventSubscriptionDestinationPropertiesARMGenerator returns a generator of StorageQueueEventSubscriptionDestinationPropertiesARM instances for property testing.
func StorageQueueEventSubscriptionDestinationPropertiesARMGenerator() gopter.Gen {
	if storageQueueEventSubscriptionDestinationPropertiesARMGenerator != nil {
		return storageQueueEventSubscriptionDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationPropertiesARM(generators)
	storageQueueEventSubscriptionDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(StorageQueueEventSubscriptionDestinationPropertiesARM{}), generators)

	return storageQueueEventSubscriptionDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["QueueName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebHookEventSubscriptionDestinationPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebHookEventSubscriptionDestinationPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebHookEventSubscriptionDestinationPropertiesARM, WebHookEventSubscriptionDestinationPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebHookEventSubscriptionDestinationPropertiesARM runs a test to see if a specific instance of WebHookEventSubscriptionDestinationPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWebHookEventSubscriptionDestinationPropertiesARM(subject WebHookEventSubscriptionDestinationPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebHookEventSubscriptionDestinationPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebHookEventSubscriptionDestinationPropertiesARM instances for property testing - lazily instantiated by
// WebHookEventSubscriptionDestinationPropertiesARMGenerator()
var webHookEventSubscriptionDestinationPropertiesARMGenerator gopter.Gen

// WebHookEventSubscriptionDestinationPropertiesARMGenerator returns a generator of WebHookEventSubscriptionDestinationPropertiesARM instances for property testing.
func WebHookEventSubscriptionDestinationPropertiesARMGenerator() gopter.Gen {
	if webHookEventSubscriptionDestinationPropertiesARMGenerator != nil {
		return webHookEventSubscriptionDestinationPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationPropertiesARM(generators)
	webHookEventSubscriptionDestinationPropertiesARMGenerator = gen.Struct(reflect.TypeOf(WebHookEventSubscriptionDestinationPropertiesARM{}), generators)

	return webHookEventSubscriptionDestinationPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationPropertiesARM(gens map[string]gopter.Gen) {
	gens["AzureActiveDirectoryApplicationIdOrUri"] = gen.PtrOf(gen.AlphaString())
	gens["AzureActiveDirectoryTenantId"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUrl"] = gen.PtrOf(gen.AlphaString())
	gens["MaxEventsPerBatch"] = gen.PtrOf(gen.Int())
	gens["PreferredBatchSizeInKilobytes"] = gen.PtrOf(gen.Int())
}
