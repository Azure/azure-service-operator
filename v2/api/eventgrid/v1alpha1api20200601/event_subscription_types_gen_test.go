// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20200601

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/eventgrid/v1alpha1api20200601storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_EventSubscription_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscription to hub returns original",
		prop.ForAll(RunResourceConversionTestForEventSubscription, EventSubscriptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForEventSubscription tests if a specific instance of EventSubscription round trips to the hub storage version and back losslessly
func RunResourceConversionTestForEventSubscription(subject EventSubscription) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20200601storage.EventSubscription
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual EventSubscription
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscription_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscription to EventSubscription via AssignPropertiesToEventSubscription & AssignPropertiesFromEventSubscription returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscription, EventSubscriptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscription tests if a specific instance of EventSubscription can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscription(subject EventSubscription) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.EventSubscription
	err := copied.AssignPropertiesToEventSubscription(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscription
	err = actual.AssignPropertiesFromEventSubscription(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscription_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscription, EventSubscriptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscription runs a test to see if a specific instance of EventSubscription round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscription(subject EventSubscription) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription instances for property testing - lazily instantiated by EventSubscriptionGenerator()
var eventSubscriptionGenerator gopter.Gen

// EventSubscriptionGenerator returns a generator of EventSubscription instances for property testing.
func EventSubscriptionGenerator() gopter.Gen {
	if eventSubscriptionGenerator != nil {
		return eventSubscriptionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEventSubscription(generators)
	eventSubscriptionGenerator = gen.Struct(reflect.TypeOf(EventSubscription{}), generators)

	return eventSubscriptionGenerator
}

// AddRelatedPropertyGeneratorsForEventSubscription is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscription(gens map[string]gopter.Gen) {
	gens["Spec"] = EventSubscriptionsSPECGenerator()
	gens["Status"] = EventSubscriptionStatusGenerator()
}

func Test_EventSubscription_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscription_Status to EventSubscription_Status via AssignPropertiesToEventSubscriptionStatus & AssignPropertiesFromEventSubscriptionStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionStatus, EventSubscriptionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionStatus tests if a specific instance of EventSubscription_Status can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionStatus(subject EventSubscription_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.EventSubscription_Status
	err := copied.AssignPropertiesToEventSubscriptionStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscription_Status
	err = actual.AssignPropertiesFromEventSubscriptionStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscription_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionStatus, EventSubscriptionStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionStatus runs a test to see if a specific instance of EventSubscription_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionStatus(subject EventSubscription_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription_Status instances for property testing - lazily instantiated by
//EventSubscriptionStatusGenerator()
var eventSubscriptionStatusGenerator gopter.Gen

// EventSubscriptionStatusGenerator returns a generator of EventSubscription_Status instances for property testing.
// We first initialize eventSubscriptionStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionStatusGenerator() gopter.Gen {
	if eventSubscriptionStatusGenerator != nil {
		return eventSubscriptionStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionStatus(generators)
	eventSubscriptionStatusGenerator = gen.Struct(reflect.TypeOf(EventSubscription_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionStatus(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionStatus(generators)
	eventSubscriptionStatusGenerator = gen.Struct(reflect.TypeOf(EventSubscription_Status{}), generators)

	return eventSubscriptionStatusGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionStatus(gens map[string]gopter.Gen) {
	gens["EventDeliverySchema"] = gen.PtrOf(gen.OneConstOf(EventSubscriptionPropertiesStatusEventDeliverySchemaCloudEventSchemaV10, EventSubscriptionPropertiesStatusEventDeliverySchemaCustomInputSchema, EventSubscriptionPropertiesStatusEventDeliverySchemaEventGridSchema))
	gens["ExpirationTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Labels"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		EventSubscriptionPropertiesStatusProvisioningStateAwaitingManualAction,
		EventSubscriptionPropertiesStatusProvisioningStateCanceled,
		EventSubscriptionPropertiesStatusProvisioningStateCreating,
		EventSubscriptionPropertiesStatusProvisioningStateDeleting,
		EventSubscriptionPropertiesStatusProvisioningStateFailed,
		EventSubscriptionPropertiesStatusProvisioningStateSucceeded,
		EventSubscriptionPropertiesStatusProvisioningStateUpdating))
	gens["Topic"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionStatus(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(DeadLetterDestinationStatusGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestinationStatusGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilterStatusGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicyStatusGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataStatusGenerator())
}

func Test_EventSubscriptions_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptions_SPEC to EventSubscriptions_SPEC via AssignPropertiesToEventSubscriptionsSPEC & AssignPropertiesFromEventSubscriptionsSPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionsSPEC, EventSubscriptionsSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionsSPEC tests if a specific instance of EventSubscriptions_SPEC can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionsSPEC(subject EventSubscriptions_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.EventSubscriptions_SPEC
	err := copied.AssignPropertiesToEventSubscriptionsSPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptions_SPEC
	err = actual.AssignPropertiesFromEventSubscriptionsSPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptions_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptions_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionsSPEC, EventSubscriptionsSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionsSPEC runs a test to see if a specific instance of EventSubscriptions_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionsSPEC(subject EventSubscriptions_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptions_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptions_SPEC instances for property testing - lazily instantiated by
//EventSubscriptionsSPECGenerator()
var eventSubscriptionsSPECGenerator gopter.Gen

// EventSubscriptionsSPECGenerator returns a generator of EventSubscriptions_SPEC instances for property testing.
// We first initialize eventSubscriptionsSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionsSPECGenerator() gopter.Gen {
	if eventSubscriptionsSPECGenerator != nil {
		return eventSubscriptionsSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionsSPEC(generators)
	eventSubscriptionsSPECGenerator = gen.Struct(reflect.TypeOf(EventSubscriptions_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionsSPEC(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionsSPEC(generators)
	eventSubscriptionsSPECGenerator = gen.Struct(reflect.TypeOf(EventSubscriptions_SPEC{}), generators)

	return eventSubscriptionsSPECGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionsSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionsSPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EventDeliverySchema"] = gen.PtrOf(gen.OneConstOf(EventSubscriptionPropertiesSpecEventDeliverySchemaCloudEventSchemaV10, EventSubscriptionPropertiesSpecEventDeliverySchemaCustomInputSchema, EventSubscriptionPropertiesSpecEventDeliverySchemaEventGridSchema))
	gens["ExpirationTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Labels"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionsSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionsSPEC(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(DeadLetterDestinationSpecGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestinationSpecGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilterSpecGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicySpecGenerator())
}

func Test_DeadLetterDestination_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeadLetterDestination_Spec to DeadLetterDestination_Spec via AssignPropertiesToDeadLetterDestinationSpec & AssignPropertiesFromDeadLetterDestinationSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeadLetterDestinationSpec, DeadLetterDestinationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeadLetterDestinationSpec tests if a specific instance of DeadLetterDestination_Spec can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForDeadLetterDestinationSpec(subject DeadLetterDestination_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.DeadLetterDestination_Spec
	err := copied.AssignPropertiesToDeadLetterDestinationSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeadLetterDestination_Spec
	err = actual.AssignPropertiesFromDeadLetterDestinationSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeadLetterDestination_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeadLetterDestination_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeadLetterDestinationSpec, DeadLetterDestinationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeadLetterDestinationSpec runs a test to see if a specific instance of DeadLetterDestination_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDeadLetterDestinationSpec(subject DeadLetterDestination_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeadLetterDestination_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeadLetterDestination_Spec instances for property testing - lazily instantiated by
//DeadLetterDestinationSpecGenerator()
var deadLetterDestinationSpecGenerator gopter.Gen

// DeadLetterDestinationSpecGenerator returns a generator of DeadLetterDestination_Spec instances for property testing.
func DeadLetterDestinationSpecGenerator() gopter.Gen {
	if deadLetterDestinationSpecGenerator != nil {
		return deadLetterDestinationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeadLetterDestinationSpec(generators)
	deadLetterDestinationSpecGenerator = gen.Struct(reflect.TypeOf(DeadLetterDestination_Spec{}), generators)

	return deadLetterDestinationSpecGenerator
}

// AddIndependentPropertyGeneratorsForDeadLetterDestinationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeadLetterDestinationSpec(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(DeadLetterDestinationSpecEndpointTypeStorageBlob)
}

func Test_DeadLetterDestination_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeadLetterDestination_Status to DeadLetterDestination_Status via AssignPropertiesToDeadLetterDestinationStatus & AssignPropertiesFromDeadLetterDestinationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeadLetterDestinationStatus, DeadLetterDestinationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeadLetterDestinationStatus tests if a specific instance of DeadLetterDestination_Status can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForDeadLetterDestinationStatus(subject DeadLetterDestination_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.DeadLetterDestination_Status
	err := copied.AssignPropertiesToDeadLetterDestinationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeadLetterDestination_Status
	err = actual.AssignPropertiesFromDeadLetterDestinationStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeadLetterDestination_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeadLetterDestination_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeadLetterDestinationStatus, DeadLetterDestinationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeadLetterDestinationStatus runs a test to see if a specific instance of DeadLetterDestination_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDeadLetterDestinationStatus(subject DeadLetterDestination_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeadLetterDestination_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeadLetterDestination_Status instances for property testing - lazily instantiated by
//DeadLetterDestinationStatusGenerator()
var deadLetterDestinationStatusGenerator gopter.Gen

// DeadLetterDestinationStatusGenerator returns a generator of DeadLetterDestination_Status instances for property testing.
func DeadLetterDestinationStatusGenerator() gopter.Gen {
	if deadLetterDestinationStatusGenerator != nil {
		return deadLetterDestinationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeadLetterDestinationStatus(generators)
	deadLetterDestinationStatusGenerator = gen.Struct(reflect.TypeOf(DeadLetterDestination_Status{}), generators)

	return deadLetterDestinationStatusGenerator
}

// AddIndependentPropertyGeneratorsForDeadLetterDestinationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeadLetterDestinationStatus(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(DeadLetterDestinationStatusEndpointTypeStorageBlob)
}

func Test_EventSubscriptionDestination_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptionDestination_Spec to EventSubscriptionDestination_Spec via AssignPropertiesToEventSubscriptionDestinationSpec & AssignPropertiesFromEventSubscriptionDestinationSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionDestinationSpec, EventSubscriptionDestinationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionDestinationSpec tests if a specific instance of EventSubscriptionDestination_Spec can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionDestinationSpec(subject EventSubscriptionDestination_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.EventSubscriptionDestination_Spec
	err := copied.AssignPropertiesToEventSubscriptionDestinationSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionDestination_Spec
	err = actual.AssignPropertiesFromEventSubscriptionDestinationSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionDestination_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionDestination_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestinationSpec, EventSubscriptionDestinationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestinationSpec runs a test to see if a specific instance of EventSubscriptionDestination_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestinationSpec(subject EventSubscriptionDestination_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionDestination_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionDestination_Spec instances for property testing - lazily instantiated by
//EventSubscriptionDestinationSpecGenerator()
var eventSubscriptionDestinationSpecGenerator gopter.Gen

// EventSubscriptionDestinationSpecGenerator returns a generator of EventSubscriptionDestination_Spec instances for property testing.
func EventSubscriptionDestinationSpecGenerator() gopter.Gen {
	if eventSubscriptionDestinationSpecGenerator != nil {
		return eventSubscriptionDestinationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionDestinationSpec(generators)
	eventSubscriptionDestinationSpecGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionDestination_Spec{}), generators)

	return eventSubscriptionDestinationSpecGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionDestinationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionDestinationSpec(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(
		EventSubscriptionDestinationSpecEndpointTypeAzureFunction,
		EventSubscriptionDestinationSpecEndpointTypeEventHub,
		EventSubscriptionDestinationSpecEndpointTypeHybridConnection,
		EventSubscriptionDestinationSpecEndpointTypeServiceBusQueue,
		EventSubscriptionDestinationSpecEndpointTypeServiceBusTopic,
		EventSubscriptionDestinationSpecEndpointTypeStorageQueue,
		EventSubscriptionDestinationSpecEndpointTypeWebHook)
}

func Test_EventSubscriptionDestination_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptionDestination_Status to EventSubscriptionDestination_Status via AssignPropertiesToEventSubscriptionDestinationStatus & AssignPropertiesFromEventSubscriptionDestinationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionDestinationStatus, EventSubscriptionDestinationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionDestinationStatus tests if a specific instance of EventSubscriptionDestination_Status can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionDestinationStatus(subject EventSubscriptionDestination_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.EventSubscriptionDestination_Status
	err := copied.AssignPropertiesToEventSubscriptionDestinationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionDestination_Status
	err = actual.AssignPropertiesFromEventSubscriptionDestinationStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionDestination_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionDestination_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestinationStatus, EventSubscriptionDestinationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestinationStatus runs a test to see if a specific instance of EventSubscriptionDestination_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestinationStatus(subject EventSubscriptionDestination_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionDestination_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionDestination_Status instances for property testing - lazily instantiated by
//EventSubscriptionDestinationStatusGenerator()
var eventSubscriptionDestinationStatusGenerator gopter.Gen

// EventSubscriptionDestinationStatusGenerator returns a generator of EventSubscriptionDestination_Status instances for property testing.
func EventSubscriptionDestinationStatusGenerator() gopter.Gen {
	if eventSubscriptionDestinationStatusGenerator != nil {
		return eventSubscriptionDestinationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionDestinationStatus(generators)
	eventSubscriptionDestinationStatusGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionDestination_Status{}), generators)

	return eventSubscriptionDestinationStatusGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionDestinationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionDestinationStatus(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(
		EventSubscriptionDestinationStatusEndpointTypeAzureFunction,
		EventSubscriptionDestinationStatusEndpointTypeEventHub,
		EventSubscriptionDestinationStatusEndpointTypeHybridConnection,
		EventSubscriptionDestinationStatusEndpointTypeServiceBusQueue,
		EventSubscriptionDestinationStatusEndpointTypeServiceBusTopic,
		EventSubscriptionDestinationStatusEndpointTypeStorageQueue,
		EventSubscriptionDestinationStatusEndpointTypeWebHook)
}

func Test_EventSubscriptionFilter_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptionFilter_Spec to EventSubscriptionFilter_Spec via AssignPropertiesToEventSubscriptionFilterSpec & AssignPropertiesFromEventSubscriptionFilterSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionFilterSpec, EventSubscriptionFilterSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionFilterSpec tests if a specific instance of EventSubscriptionFilter_Spec can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionFilterSpec(subject EventSubscriptionFilter_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.EventSubscriptionFilter_Spec
	err := copied.AssignPropertiesToEventSubscriptionFilterSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionFilter_Spec
	err = actual.AssignPropertiesFromEventSubscriptionFilterSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionFilter_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionFilter_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilterSpec, EventSubscriptionFilterSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilterSpec runs a test to see if a specific instance of EventSubscriptionFilter_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilterSpec(subject EventSubscriptionFilter_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionFilter_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionFilter_Spec instances for property testing - lazily instantiated by
//EventSubscriptionFilterSpecGenerator()
var eventSubscriptionFilterSpecGenerator gopter.Gen

// EventSubscriptionFilterSpecGenerator returns a generator of EventSubscriptionFilter_Spec instances for property testing.
// We first initialize eventSubscriptionFilterSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilterSpecGenerator() gopter.Gen {
	if eventSubscriptionFilterSpecGenerator != nil {
		return eventSubscriptionFilterSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterSpec(generators)
	eventSubscriptionFilterSpecGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterSpec(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilterSpec(generators)
	eventSubscriptionFilterSpecGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_Spec{}), generators)

	return eventSubscriptionFilterSpecGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilterSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilterSpec(gens map[string]gopter.Gen) {
	gens["IncludedEventTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IsSubjectCaseSensitive"] = gen.PtrOf(gen.Bool())
	gens["SubjectBeginsWith"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectEndsWith"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionFilterSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilterSpec(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilterSpecGenerator())
}

func Test_EventSubscriptionFilter_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptionFilter_Status to EventSubscriptionFilter_Status via AssignPropertiesToEventSubscriptionFilterStatus & AssignPropertiesFromEventSubscriptionFilterStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionFilterStatus, EventSubscriptionFilterStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionFilterStatus tests if a specific instance of EventSubscriptionFilter_Status can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionFilterStatus(subject EventSubscriptionFilter_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.EventSubscriptionFilter_Status
	err := copied.AssignPropertiesToEventSubscriptionFilterStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionFilter_Status
	err = actual.AssignPropertiesFromEventSubscriptionFilterStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionFilter_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionFilter_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilterStatus, EventSubscriptionFilterStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilterStatus runs a test to see if a specific instance of EventSubscriptionFilter_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilterStatus(subject EventSubscriptionFilter_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionFilter_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionFilter_Status instances for property testing - lazily instantiated by
//EventSubscriptionFilterStatusGenerator()
var eventSubscriptionFilterStatusGenerator gopter.Gen

// EventSubscriptionFilterStatusGenerator returns a generator of EventSubscriptionFilter_Status instances for property testing.
// We first initialize eventSubscriptionFilterStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilterStatusGenerator() gopter.Gen {
	if eventSubscriptionFilterStatusGenerator != nil {
		return eventSubscriptionFilterStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterStatus(generators)
	eventSubscriptionFilterStatusGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilterStatus(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilterStatus(generators)
	eventSubscriptionFilterStatusGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_Status{}), generators)

	return eventSubscriptionFilterStatusGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilterStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilterStatus(gens map[string]gopter.Gen) {
	gens["IncludedEventTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IsSubjectCaseSensitive"] = gen.PtrOf(gen.Bool())
	gens["SubjectBeginsWith"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectEndsWith"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionFilterStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilterStatus(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilterStatusGenerator())
}

func Test_RetryPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RetryPolicy_Spec to RetryPolicy_Spec via AssignPropertiesToRetryPolicySpec & AssignPropertiesFromRetryPolicySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForRetryPolicySpec, RetryPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRetryPolicySpec tests if a specific instance of RetryPolicy_Spec can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForRetryPolicySpec(subject RetryPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.RetryPolicy_Spec
	err := copied.AssignPropertiesToRetryPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RetryPolicy_Spec
	err = actual.AssignPropertiesFromRetryPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RetryPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicySpec, RetryPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicySpec runs a test to see if a specific instance of RetryPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicySpec(subject RetryPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicy_Spec instances for property testing - lazily instantiated by RetryPolicySpecGenerator()
var retryPolicySpecGenerator gopter.Gen

// RetryPolicySpecGenerator returns a generator of RetryPolicy_Spec instances for property testing.
func RetryPolicySpecGenerator() gopter.Gen {
	if retryPolicySpecGenerator != nil {
		return retryPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicySpec(generators)
	retryPolicySpecGenerator = gen.Struct(reflect.TypeOf(RetryPolicy_Spec{}), generators)

	return retryPolicySpecGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicySpec(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_RetryPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RetryPolicy_Status to RetryPolicy_Status via AssignPropertiesToRetryPolicyStatus & AssignPropertiesFromRetryPolicyStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForRetryPolicyStatus, RetryPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRetryPolicyStatus tests if a specific instance of RetryPolicy_Status can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForRetryPolicyStatus(subject RetryPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.RetryPolicy_Status
	err := copied.AssignPropertiesToRetryPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RetryPolicy_Status
	err = actual.AssignPropertiesFromRetryPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RetryPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicyStatus, RetryPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicyStatus runs a test to see if a specific instance of RetryPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicyStatus(subject RetryPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicy_Status instances for property testing - lazily instantiated by RetryPolicyStatusGenerator()
var retryPolicyStatusGenerator gopter.Gen

// RetryPolicyStatusGenerator returns a generator of RetryPolicy_Status instances for property testing.
func RetryPolicyStatusGenerator() gopter.Gen {
	if retryPolicyStatusGenerator != nil {
		return retryPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicyStatus(generators)
	retryPolicyStatusGenerator = gen.Struct(reflect.TypeOf(RetryPolicy_Status{}), generators)

	return retryPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicyStatus(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_AdvancedFilter_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdvancedFilter_Spec to AdvancedFilter_Spec via AssignPropertiesToAdvancedFilterSpec & AssignPropertiesFromAdvancedFilterSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdvancedFilterSpec, AdvancedFilterSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdvancedFilterSpec tests if a specific instance of AdvancedFilter_Spec can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForAdvancedFilterSpec(subject AdvancedFilter_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.AdvancedFilter_Spec
	err := copied.AssignPropertiesToAdvancedFilterSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdvancedFilter_Spec
	err = actual.AssignPropertiesFromAdvancedFilterSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdvancedFilter_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterSpec, AdvancedFilterSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterSpec runs a test to see if a specific instance of AdvancedFilter_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterSpec(subject AdvancedFilter_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_Spec instances for property testing - lazily instantiated by AdvancedFilterSpecGenerator()
var advancedFilterSpecGenerator gopter.Gen

// AdvancedFilterSpecGenerator returns a generator of AdvancedFilter_Spec instances for property testing.
func AdvancedFilterSpecGenerator() gopter.Gen {
	if advancedFilterSpecGenerator != nil {
		return advancedFilterSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterSpec(generators)
	advancedFilterSpecGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_Spec{}), generators)

	return advancedFilterSpecGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterSpec(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(
		AdvancedFilterSpecOperatorTypeBoolEquals,
		AdvancedFilterSpecOperatorTypeNumberGreaterThan,
		AdvancedFilterSpecOperatorTypeNumberGreaterThanOrEquals,
		AdvancedFilterSpecOperatorTypeNumberIn,
		AdvancedFilterSpecOperatorTypeNumberLessThan,
		AdvancedFilterSpecOperatorTypeNumberLessThanOrEquals,
		AdvancedFilterSpecOperatorTypeNumberNotIn,
		AdvancedFilterSpecOperatorTypeStringBeginsWith,
		AdvancedFilterSpecOperatorTypeStringContains,
		AdvancedFilterSpecOperatorTypeStringEndsWith,
		AdvancedFilterSpecOperatorTypeStringIn,
		AdvancedFilterSpecOperatorTypeStringNotIn)
}

func Test_AdvancedFilter_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdvancedFilter_Status to AdvancedFilter_Status via AssignPropertiesToAdvancedFilterStatus & AssignPropertiesFromAdvancedFilterStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdvancedFilterStatus, AdvancedFilterStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdvancedFilterStatus tests if a specific instance of AdvancedFilter_Status can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForAdvancedFilterStatus(subject AdvancedFilter_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.AdvancedFilter_Status
	err := copied.AssignPropertiesToAdvancedFilterStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdvancedFilter_Status
	err = actual.AssignPropertiesFromAdvancedFilterStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdvancedFilter_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilterStatus, AdvancedFilterStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilterStatus runs a test to see if a specific instance of AdvancedFilter_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilterStatus(subject AdvancedFilter_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_Status instances for property testing - lazily instantiated by
//AdvancedFilterStatusGenerator()
var advancedFilterStatusGenerator gopter.Gen

// AdvancedFilterStatusGenerator returns a generator of AdvancedFilter_Status instances for property testing.
func AdvancedFilterStatusGenerator() gopter.Gen {
	if advancedFilterStatusGenerator != nil {
		return advancedFilterStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilterStatus(generators)
	advancedFilterStatusGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_Status{}), generators)

	return advancedFilterStatusGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilterStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilterStatus(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(
		AdvancedFilterStatusOperatorTypeBoolEquals,
		AdvancedFilterStatusOperatorTypeNumberGreaterThan,
		AdvancedFilterStatusOperatorTypeNumberGreaterThanOrEquals,
		AdvancedFilterStatusOperatorTypeNumberIn,
		AdvancedFilterStatusOperatorTypeNumberLessThan,
		AdvancedFilterStatusOperatorTypeNumberLessThanOrEquals,
		AdvancedFilterStatusOperatorTypeNumberNotIn,
		AdvancedFilterStatusOperatorTypeStringBeginsWith,
		AdvancedFilterStatusOperatorTypeStringContains,
		AdvancedFilterStatusOperatorTypeStringEndsWith,
		AdvancedFilterStatusOperatorTypeStringIn,
		AdvancedFilterStatusOperatorTypeStringNotIn)
}
