// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20200601

import (
	"encoding/json"
	alpha20200601s "github.com/Azure/azure-service-operator/v2/api/eventgrid/v1alpha1api20200601storage"
	v20200601s "github.com/Azure/azure-service-operator/v2/api/eventgrid/v1beta20200601storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_EventSubscription_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscription to hub returns original",
		prop.ForAll(RunResourceConversionTestForEventSubscription, EventSubscriptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForEventSubscription tests if a specific instance of EventSubscription round trips to the hub storage version and back losslessly
func RunResourceConversionTestForEventSubscription(subject EventSubscription) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20200601s.EventSubscription
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual EventSubscription
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscription_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscription to EventSubscription via AssignProperties_To_EventSubscription & AssignProperties_From_EventSubscription returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscription, EventSubscriptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscription tests if a specific instance of EventSubscription can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscription(subject EventSubscription) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.EventSubscription
	err := copied.AssignProperties_To_EventSubscription(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscription
	err = actual.AssignProperties_From_EventSubscription(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscription_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscription, EventSubscriptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscription runs a test to see if a specific instance of EventSubscription round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscription(subject EventSubscription) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription instances for property testing - lazily instantiated by EventSubscriptionGenerator()
var eventSubscriptionGenerator gopter.Gen

// EventSubscriptionGenerator returns a generator of EventSubscription instances for property testing.
func EventSubscriptionGenerator() gopter.Gen {
	if eventSubscriptionGenerator != nil {
		return eventSubscriptionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEventSubscription(generators)
	eventSubscriptionGenerator = gen.Struct(reflect.TypeOf(EventSubscription{}), generators)

	return eventSubscriptionGenerator
}

// AddRelatedPropertyGeneratorsForEventSubscription is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscription(gens map[string]gopter.Gen) {
	gens["Spec"] = EventSubscription_SpecGenerator()
	gens["Status"] = EventSubscription_STATUSGenerator()
}

func Test_EventSubscription_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscription_Spec to EventSubscription_Spec via AssignProperties_To_EventSubscription_Spec & AssignProperties_From_EventSubscription_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscription_Spec, EventSubscription_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscription_Spec tests if a specific instance of EventSubscription_Spec can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscription_Spec(subject EventSubscription_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.EventSubscription_Spec
	err := copied.AssignProperties_To_EventSubscription_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscription_Spec
	err = actual.AssignProperties_From_EventSubscription_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscription_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscription_Spec, EventSubscription_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscription_Spec runs a test to see if a specific instance of EventSubscription_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscription_Spec(subject EventSubscription_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription_Spec instances for property testing - lazily instantiated by
// EventSubscription_SpecGenerator()
var eventSubscription_SpecGenerator gopter.Gen

// EventSubscription_SpecGenerator returns a generator of EventSubscription_Spec instances for property testing.
// We first initialize eventSubscription_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscription_SpecGenerator() gopter.Gen {
	if eventSubscription_SpecGenerator != nil {
		return eventSubscription_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_Spec(generators)
	eventSubscription_SpecGenerator = gen.Struct(reflect.TypeOf(EventSubscription_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_Spec(generators)
	AddRelatedPropertyGeneratorsForEventSubscription_Spec(generators)
	eventSubscription_SpecGenerator = gen.Struct(reflect.TypeOf(EventSubscription_Spec{}), generators)

	return eventSubscription_SpecGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscription_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscription_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EventDeliverySchema"] = gen.PtrOf(gen.OneConstOf(EventSubscriptionProperties_EventDeliverySchema_CloudEventSchemaV1_0, EventSubscriptionProperties_EventDeliverySchema_CustomInputSchema, EventSubscriptionProperties_EventDeliverySchema_EventGridSchema))
	gens["ExpirationTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Labels"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscription_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscription_Spec(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(DeadLetterDestinationGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestinationGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilterGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicyGenerator())
}

func Test_EventSubscription_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscription_STATUS to EventSubscription_STATUS via AssignProperties_To_EventSubscription_STATUS & AssignProperties_From_EventSubscription_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscription_STATUS, EventSubscription_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscription_STATUS tests if a specific instance of EventSubscription_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscription_STATUS(subject EventSubscription_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.EventSubscription_STATUS
	err := copied.AssignProperties_To_EventSubscription_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscription_STATUS
	err = actual.AssignProperties_From_EventSubscription_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscription_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscription_STATUS, EventSubscription_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscription_STATUS runs a test to see if a specific instance of EventSubscription_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscription_STATUS(subject EventSubscription_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription_STATUS instances for property testing - lazily instantiated by
// EventSubscription_STATUSGenerator()
var eventSubscription_STATUSGenerator gopter.Gen

// EventSubscription_STATUSGenerator returns a generator of EventSubscription_STATUS instances for property testing.
// We first initialize eventSubscription_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscription_STATUSGenerator() gopter.Gen {
	if eventSubscription_STATUSGenerator != nil {
		return eventSubscription_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_STATUS(generators)
	eventSubscription_STATUSGenerator = gen.Struct(reflect.TypeOf(EventSubscription_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_STATUS(generators)
	AddRelatedPropertyGeneratorsForEventSubscription_STATUS(generators)
	eventSubscription_STATUSGenerator = gen.Struct(reflect.TypeOf(EventSubscription_STATUS{}), generators)

	return eventSubscription_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscription_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscription_STATUS(gens map[string]gopter.Gen) {
	gens["EventDeliverySchema"] = gen.PtrOf(gen.OneConstOf(EventSubscriptionProperties_EventDeliverySchema_STATUS_CloudEventSchemaV1_0, EventSubscriptionProperties_EventDeliverySchema_STATUS_CustomInputSchema, EventSubscriptionProperties_EventDeliverySchema_STATUS_EventGridSchema))
	gens["ExpirationTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Labels"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		EventSubscriptionProperties_ProvisioningState_STATUS_AwaitingManualAction,
		EventSubscriptionProperties_ProvisioningState_STATUS_Canceled,
		EventSubscriptionProperties_ProvisioningState_STATUS_Creating,
		EventSubscriptionProperties_ProvisioningState_STATUS_Deleting,
		EventSubscriptionProperties_ProvisioningState_STATUS_Failed,
		EventSubscriptionProperties_ProvisioningState_STATUS_Succeeded,
		EventSubscriptionProperties_ProvisioningState_STATUS_Updating))
	gens["Topic"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscription_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscription_STATUS(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(DeadLetterDestination_STATUSGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestination_STATUSGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilter_STATUSGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicy_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_DeadLetterDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeadLetterDestination to DeadLetterDestination via AssignProperties_To_DeadLetterDestination & AssignProperties_From_DeadLetterDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeadLetterDestination, DeadLetterDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeadLetterDestination tests if a specific instance of DeadLetterDestination can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForDeadLetterDestination(subject DeadLetterDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.DeadLetterDestination
	err := copied.AssignProperties_To_DeadLetterDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeadLetterDestination
	err = actual.AssignProperties_From_DeadLetterDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeadLetterDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeadLetterDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeadLetterDestination, DeadLetterDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeadLetterDestination runs a test to see if a specific instance of DeadLetterDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForDeadLetterDestination(subject DeadLetterDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeadLetterDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeadLetterDestination instances for property testing - lazily instantiated by
// DeadLetterDestinationGenerator()
var deadLetterDestinationGenerator gopter.Gen

// DeadLetterDestinationGenerator returns a generator of DeadLetterDestination instances for property testing.
func DeadLetterDestinationGenerator() gopter.Gen {
	if deadLetterDestinationGenerator != nil {
		return deadLetterDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeadLetterDestination(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeadLetterDestination{}), map[string]gopter.Gen{propName: propGen}))
	}
	deadLetterDestinationGenerator = gen.OneGenOf(gens...)

	return deadLetterDestinationGenerator
}

// AddRelatedPropertyGeneratorsForDeadLetterDestination is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeadLetterDestination(gens map[string]gopter.Gen) {
	gens["StorageBlob"] = StorageBlobDeadLetterDestinationGenerator().Map(func(it StorageBlobDeadLetterDestination) *StorageBlobDeadLetterDestination {
		return &it
	}) // generate one case for OneOf type
}

func Test_DeadLetterDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeadLetterDestination_STATUS to DeadLetterDestination_STATUS via AssignProperties_To_DeadLetterDestination_STATUS & AssignProperties_From_DeadLetterDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeadLetterDestination_STATUS, DeadLetterDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeadLetterDestination_STATUS tests if a specific instance of DeadLetterDestination_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForDeadLetterDestination_STATUS(subject DeadLetterDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.DeadLetterDestination_STATUS
	err := copied.AssignProperties_To_DeadLetterDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeadLetterDestination_STATUS
	err = actual.AssignProperties_From_DeadLetterDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeadLetterDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeadLetterDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeadLetterDestination_STATUS, DeadLetterDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeadLetterDestination_STATUS runs a test to see if a specific instance of DeadLetterDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeadLetterDestination_STATUS(subject DeadLetterDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeadLetterDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeadLetterDestination_STATUS instances for property testing - lazily instantiated by
// DeadLetterDestination_STATUSGenerator()
var deadLetterDestination_STATUSGenerator gopter.Gen

// DeadLetterDestination_STATUSGenerator returns a generator of DeadLetterDestination_STATUS instances for property testing.
func DeadLetterDestination_STATUSGenerator() gopter.Gen {
	if deadLetterDestination_STATUSGenerator != nil {
		return deadLetterDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeadLetterDestination_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeadLetterDestination_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	deadLetterDestination_STATUSGenerator = gen.OneGenOf(gens...)

	return deadLetterDestination_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForDeadLetterDestination_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeadLetterDestination_STATUS(gens map[string]gopter.Gen) {
	gens["StorageBlob"] = StorageBlobDeadLetterDestination_STATUSGenerator().Map(func(it StorageBlobDeadLetterDestination_STATUS) *StorageBlobDeadLetterDestination_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_EventSubscriptionDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptionDestination to EventSubscriptionDestination via AssignProperties_To_EventSubscriptionDestination & AssignProperties_From_EventSubscriptionDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionDestination, EventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionDestination tests if a specific instance of EventSubscriptionDestination can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionDestination(subject EventSubscriptionDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.EventSubscriptionDestination
	err := copied.AssignProperties_To_EventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionDestination
	err = actual.AssignProperties_From_EventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestination, EventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestination runs a test to see if a specific instance of EventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestination(subject EventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionDestination instances for property testing - lazily instantiated by
// EventSubscriptionDestinationGenerator()
var eventSubscriptionDestinationGenerator gopter.Gen

// EventSubscriptionDestinationGenerator returns a generator of EventSubscriptionDestination instances for property testing.
func EventSubscriptionDestinationGenerator() gopter.Gen {
	if eventSubscriptionDestinationGenerator != nil {
		return eventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEventSubscriptionDestination(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(EventSubscriptionDestination{}), map[string]gopter.Gen{propName: propGen}))
	}
	eventSubscriptionDestinationGenerator = gen.OneGenOf(gens...)

	return eventSubscriptionDestinationGenerator
}

// AddRelatedPropertyGeneratorsForEventSubscriptionDestination is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["AzureFunction"] = AzureFunctionEventSubscriptionDestinationGenerator().Map(func(it AzureFunctionEventSubscriptionDestination) *AzureFunctionEventSubscriptionDestination {
		return &it
	}) // generate one case for OneOf type
	gens["EventHub"] = EventHubEventSubscriptionDestinationGenerator().Map(func(it EventHubEventSubscriptionDestination) *EventHubEventSubscriptionDestination {
		return &it
	}) // generate one case for OneOf type
	gens["HybridConnection"] = HybridConnectionEventSubscriptionDestinationGenerator().Map(func(it HybridConnectionEventSubscriptionDestination) *HybridConnectionEventSubscriptionDestination {
		return &it
	}) // generate one case for OneOf type
	gens["ServiceBusQueue"] = ServiceBusQueueEventSubscriptionDestinationGenerator().Map(func(it ServiceBusQueueEventSubscriptionDestination) *ServiceBusQueueEventSubscriptionDestination {
		return &it
	}) // generate one case for OneOf type
	gens["ServiceBusTopic"] = ServiceBusTopicEventSubscriptionDestinationGenerator().Map(func(it ServiceBusTopicEventSubscriptionDestination) *ServiceBusTopicEventSubscriptionDestination {
		return &it
	}) // generate one case for OneOf type
	gens["StorageQueue"] = StorageQueueEventSubscriptionDestinationGenerator().Map(func(it StorageQueueEventSubscriptionDestination) *StorageQueueEventSubscriptionDestination {
		return &it
	}) // generate one case for OneOf type
	gens["WebHook"] = WebHookEventSubscriptionDestinationGenerator().Map(func(it WebHookEventSubscriptionDestination) *WebHookEventSubscriptionDestination {
		return &it
	}) // generate one case for OneOf type
}

func Test_EventSubscriptionDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptionDestination_STATUS to EventSubscriptionDestination_STATUS via AssignProperties_To_EventSubscriptionDestination_STATUS & AssignProperties_From_EventSubscriptionDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionDestination_STATUS, EventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionDestination_STATUS tests if a specific instance of EventSubscriptionDestination_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionDestination_STATUS(subject EventSubscriptionDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.EventSubscriptionDestination_STATUS
	err := copied.AssignProperties_To_EventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionDestination_STATUS
	err = actual.AssignProperties_From_EventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestination_STATUS, EventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestination_STATUS runs a test to see if a specific instance of EventSubscriptionDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestination_STATUS(subject EventSubscriptionDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionDestination_STATUS instances for property testing - lazily instantiated by
// EventSubscriptionDestination_STATUSGenerator()
var eventSubscriptionDestination_STATUSGenerator gopter.Gen

// EventSubscriptionDestination_STATUSGenerator returns a generator of EventSubscriptionDestination_STATUS instances for property testing.
func EventSubscriptionDestination_STATUSGenerator() gopter.Gen {
	if eventSubscriptionDestination_STATUSGenerator != nil {
		return eventSubscriptionDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEventSubscriptionDestination_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(EventSubscriptionDestination_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	eventSubscriptionDestination_STATUSGenerator = gen.OneGenOf(gens...)

	return eventSubscriptionDestination_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForEventSubscriptionDestination_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionDestination_STATUS(gens map[string]gopter.Gen) {
	gens["AzureFunction"] = AzureFunctionEventSubscriptionDestination_STATUSGenerator().Map(func(it AzureFunctionEventSubscriptionDestination_STATUS) *AzureFunctionEventSubscriptionDestination_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["EventHub"] = EventHubEventSubscriptionDestination_STATUSGenerator().Map(func(it EventHubEventSubscriptionDestination_STATUS) *EventHubEventSubscriptionDestination_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["HybridConnection"] = HybridConnectionEventSubscriptionDestination_STATUSGenerator().Map(func(it HybridConnectionEventSubscriptionDestination_STATUS) *HybridConnectionEventSubscriptionDestination_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["ServiceBusQueue"] = ServiceBusQueueEventSubscriptionDestination_STATUSGenerator().Map(func(it ServiceBusQueueEventSubscriptionDestination_STATUS) *ServiceBusQueueEventSubscriptionDestination_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["ServiceBusTopic"] = ServiceBusTopicEventSubscriptionDestination_STATUSGenerator().Map(func(it ServiceBusTopicEventSubscriptionDestination_STATUS) *ServiceBusTopicEventSubscriptionDestination_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["StorageQueue"] = StorageQueueEventSubscriptionDestination_STATUSGenerator().Map(func(it StorageQueueEventSubscriptionDestination_STATUS) *StorageQueueEventSubscriptionDestination_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["WebHook"] = WebHookEventSubscriptionDestination_STATUSGenerator().Map(func(it WebHookEventSubscriptionDestination_STATUS) *WebHookEventSubscriptionDestination_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_EventSubscriptionFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptionFilter to EventSubscriptionFilter via AssignProperties_To_EventSubscriptionFilter & AssignProperties_From_EventSubscriptionFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionFilter, EventSubscriptionFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionFilter tests if a specific instance of EventSubscriptionFilter can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionFilter(subject EventSubscriptionFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.EventSubscriptionFilter
	err := copied.AssignProperties_To_EventSubscriptionFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionFilter
	err = actual.AssignProperties_From_EventSubscriptionFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilter, EventSubscriptionFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilter runs a test to see if a specific instance of EventSubscriptionFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilter(subject EventSubscriptionFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionFilter instances for property testing - lazily instantiated by
// EventSubscriptionFilterGenerator()
var eventSubscriptionFilterGenerator gopter.Gen

// EventSubscriptionFilterGenerator returns a generator of EventSubscriptionFilter instances for property testing.
// We first initialize eventSubscriptionFilterGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilterGenerator() gopter.Gen {
	if eventSubscriptionFilterGenerator != nil {
		return eventSubscriptionFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilter(generators)
	eventSubscriptionFilterGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilter(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilter(generators)
	eventSubscriptionFilterGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter{}), generators)

	return eventSubscriptionFilterGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilter(gens map[string]gopter.Gen) {
	gens["IncludedEventTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IsSubjectCaseSensitive"] = gen.PtrOf(gen.Bool())
	gens["SubjectBeginsWith"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectEndsWith"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionFilter is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilter(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilterGenerator())
}

func Test_EventSubscriptionFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptionFilter_STATUS to EventSubscriptionFilter_STATUS via AssignProperties_To_EventSubscriptionFilter_STATUS & AssignProperties_From_EventSubscriptionFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionFilter_STATUS, EventSubscriptionFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionFilter_STATUS tests if a specific instance of EventSubscriptionFilter_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionFilter_STATUS(subject EventSubscriptionFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.EventSubscriptionFilter_STATUS
	err := copied.AssignProperties_To_EventSubscriptionFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionFilter_STATUS
	err = actual.AssignProperties_From_EventSubscriptionFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilter_STATUS, EventSubscriptionFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilter_STATUS runs a test to see if a specific instance of EventSubscriptionFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilter_STATUS(subject EventSubscriptionFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionFilter_STATUS instances for property testing - lazily instantiated by
// EventSubscriptionFilter_STATUSGenerator()
var eventSubscriptionFilter_STATUSGenerator gopter.Gen

// EventSubscriptionFilter_STATUSGenerator returns a generator of EventSubscriptionFilter_STATUS instances for property testing.
// We first initialize eventSubscriptionFilter_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilter_STATUSGenerator() gopter.Gen {
	if eventSubscriptionFilter_STATUSGenerator != nil {
		return eventSubscriptionFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilter_STATUS(generators)
	eventSubscriptionFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilter_STATUS(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilter_STATUS(generators)
	eventSubscriptionFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_STATUS{}), generators)

	return eventSubscriptionFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilter_STATUS(gens map[string]gopter.Gen) {
	gens["IncludedEventTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IsSubjectCaseSensitive"] = gen.PtrOf(gen.Bool())
	gens["SubjectBeginsWith"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectEndsWith"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionFilter_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilter_STATUS(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilter_STATUSGenerator())
}

func Test_RetryPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RetryPolicy to RetryPolicy via AssignProperties_To_RetryPolicy & AssignProperties_From_RetryPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForRetryPolicy, RetryPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRetryPolicy tests if a specific instance of RetryPolicy can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForRetryPolicy(subject RetryPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.RetryPolicy
	err := copied.AssignProperties_To_RetryPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RetryPolicy
	err = actual.AssignProperties_From_RetryPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RetryPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicy, RetryPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicy runs a test to see if a specific instance of RetryPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicy(subject RetryPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicy instances for property testing - lazily instantiated by RetryPolicyGenerator()
var retryPolicyGenerator gopter.Gen

// RetryPolicyGenerator returns a generator of RetryPolicy instances for property testing.
func RetryPolicyGenerator() gopter.Gen {
	if retryPolicyGenerator != nil {
		return retryPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicy(generators)
	retryPolicyGenerator = gen.Struct(reflect.TypeOf(RetryPolicy{}), generators)

	return retryPolicyGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicy(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_RetryPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RetryPolicy_STATUS to RetryPolicy_STATUS via AssignProperties_To_RetryPolicy_STATUS & AssignProperties_From_RetryPolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRetryPolicy_STATUS, RetryPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRetryPolicy_STATUS tests if a specific instance of RetryPolicy_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForRetryPolicy_STATUS(subject RetryPolicy_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.RetryPolicy_STATUS
	err := copied.AssignProperties_To_RetryPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RetryPolicy_STATUS
	err = actual.AssignProperties_From_RetryPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RetryPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicy_STATUS, RetryPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicy_STATUS runs a test to see if a specific instance of RetryPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicy_STATUS(subject RetryPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicy_STATUS instances for property testing - lazily instantiated by RetryPolicy_STATUSGenerator()
var retryPolicy_STATUSGenerator gopter.Gen

// RetryPolicy_STATUSGenerator returns a generator of RetryPolicy_STATUS instances for property testing.
func RetryPolicy_STATUSGenerator() gopter.Gen {
	if retryPolicy_STATUSGenerator != nil {
		return retryPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicy_STATUS(generators)
	retryPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(RetryPolicy_STATUS{}), generators)

	return retryPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_AdvancedFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdvancedFilter to AdvancedFilter via AssignProperties_To_AdvancedFilter & AssignProperties_From_AdvancedFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdvancedFilter, AdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdvancedFilter tests if a specific instance of AdvancedFilter can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForAdvancedFilter(subject AdvancedFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.AdvancedFilter
	err := copied.AssignProperties_To_AdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdvancedFilter
	err = actual.AssignProperties_From_AdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter, AdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter runs a test to see if a specific instance of AdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter(subject AdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter instances for property testing - lazily instantiated by AdvancedFilterGenerator()
var advancedFilterGenerator gopter.Gen

// AdvancedFilterGenerator returns a generator of AdvancedFilter instances for property testing.
func AdvancedFilterGenerator() gopter.Gen {
	if advancedFilterGenerator != nil {
		return advancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAdvancedFilter(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(AdvancedFilter{}), map[string]gopter.Gen{propName: propGen}))
	}
	advancedFilterGenerator = gen.OneGenOf(gens...)

	return advancedFilterGenerator
}

// AddRelatedPropertyGeneratorsForAdvancedFilter is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdvancedFilter(gens map[string]gopter.Gen) {
	gens["BoolEquals"] = BoolEqualsAdvancedFilterGenerator().Map(func(it BoolEqualsAdvancedFilter) *BoolEqualsAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["NumberGreaterThan"] = NumberGreaterThanAdvancedFilterGenerator().Map(func(it NumberGreaterThanAdvancedFilter) *NumberGreaterThanAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["NumberGreaterThanOrEquals"] = NumberGreaterThanOrEqualsAdvancedFilterGenerator().Map(func(it NumberGreaterThanOrEqualsAdvancedFilter) *NumberGreaterThanOrEqualsAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["NumberIn"] = NumberInAdvancedFilterGenerator().Map(func(it NumberInAdvancedFilter) *NumberInAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["NumberLessThan"] = NumberLessThanAdvancedFilterGenerator().Map(func(it NumberLessThanAdvancedFilter) *NumberLessThanAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["NumberLessThanOrEquals"] = NumberLessThanOrEqualsAdvancedFilterGenerator().Map(func(it NumberLessThanOrEqualsAdvancedFilter) *NumberLessThanOrEqualsAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["NumberNotIn"] = NumberNotInAdvancedFilterGenerator().Map(func(it NumberNotInAdvancedFilter) *NumberNotInAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["StringBeginsWith"] = StringBeginsWithAdvancedFilterGenerator().Map(func(it StringBeginsWithAdvancedFilter) *StringBeginsWithAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["StringContains"] = StringContainsAdvancedFilterGenerator().Map(func(it StringContainsAdvancedFilter) *StringContainsAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["StringEndsWith"] = StringEndsWithAdvancedFilterGenerator().Map(func(it StringEndsWithAdvancedFilter) *StringEndsWithAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["StringIn"] = StringInAdvancedFilterGenerator().Map(func(it StringInAdvancedFilter) *StringInAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["StringNotIn"] = StringNotInAdvancedFilterGenerator().Map(func(it StringNotInAdvancedFilter) *StringNotInAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
}

func Test_AdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdvancedFilter_STATUS to AdvancedFilter_STATUS via AssignProperties_To_AdvancedFilter_STATUS & AssignProperties_From_AdvancedFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdvancedFilter_STATUS, AdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdvancedFilter_STATUS tests if a specific instance of AdvancedFilter_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForAdvancedFilter_STATUS(subject AdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.AdvancedFilter_STATUS
	err := copied.AssignProperties_To_AdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdvancedFilter_STATUS
	err = actual.AssignProperties_From_AdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_STATUS, AdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_STATUS runs a test to see if a specific instance of AdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_STATUS(subject AdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_STATUS instances for property testing - lazily instantiated by
// AdvancedFilter_STATUSGenerator()
var advancedFilter_STATUSGenerator gopter.Gen

// AdvancedFilter_STATUSGenerator returns a generator of AdvancedFilter_STATUS instances for property testing.
func AdvancedFilter_STATUSGenerator() gopter.Gen {
	if advancedFilter_STATUSGenerator != nil {
		return advancedFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAdvancedFilter_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(AdvancedFilter_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	advancedFilter_STATUSGenerator = gen.OneGenOf(gens...)

	return advancedFilter_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForAdvancedFilter_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdvancedFilter_STATUS(gens map[string]gopter.Gen) {
	gens["BoolEquals"] = BoolEqualsAdvancedFilter_STATUSGenerator().Map(func(it BoolEqualsAdvancedFilter_STATUS) *BoolEqualsAdvancedFilter_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["NumberGreaterThan"] = NumberGreaterThanAdvancedFilter_STATUSGenerator().Map(func(it NumberGreaterThanAdvancedFilter_STATUS) *NumberGreaterThanAdvancedFilter_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["NumberGreaterThanOrEquals"] = NumberGreaterThanOrEqualsAdvancedFilter_STATUSGenerator().Map(func(it NumberGreaterThanOrEqualsAdvancedFilter_STATUS) *NumberGreaterThanOrEqualsAdvancedFilter_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["NumberIn"] = NumberInAdvancedFilter_STATUSGenerator().Map(func(it NumberInAdvancedFilter_STATUS) *NumberInAdvancedFilter_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["NumberLessThan"] = NumberLessThanAdvancedFilter_STATUSGenerator().Map(func(it NumberLessThanAdvancedFilter_STATUS) *NumberLessThanAdvancedFilter_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["NumberLessThanOrEquals"] = NumberLessThanOrEqualsAdvancedFilter_STATUSGenerator().Map(func(it NumberLessThanOrEqualsAdvancedFilter_STATUS) *NumberLessThanOrEqualsAdvancedFilter_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["NumberNotIn"] = NumberNotInAdvancedFilter_STATUSGenerator().Map(func(it NumberNotInAdvancedFilter_STATUS) *NumberNotInAdvancedFilter_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["StringBeginsWith"] = StringBeginsWithAdvancedFilter_STATUSGenerator().Map(func(it StringBeginsWithAdvancedFilter_STATUS) *StringBeginsWithAdvancedFilter_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["StringContains"] = StringContainsAdvancedFilter_STATUSGenerator().Map(func(it StringContainsAdvancedFilter_STATUS) *StringContainsAdvancedFilter_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["StringEndsWith"] = StringEndsWithAdvancedFilter_STATUSGenerator().Map(func(it StringEndsWithAdvancedFilter_STATUS) *StringEndsWithAdvancedFilter_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["StringIn"] = StringInAdvancedFilter_STATUSGenerator().Map(func(it StringInAdvancedFilter_STATUS) *StringInAdvancedFilter_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["StringNotIn"] = StringNotInAdvancedFilter_STATUSGenerator().Map(func(it StringNotInAdvancedFilter_STATUS) *StringNotInAdvancedFilter_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_AzureFunctionEventSubscriptionDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFunctionEventSubscriptionDestination to AzureFunctionEventSubscriptionDestination via AssignProperties_To_AzureFunctionEventSubscriptionDestination & AssignProperties_From_AzureFunctionEventSubscriptionDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFunctionEventSubscriptionDestination, AzureFunctionEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFunctionEventSubscriptionDestination tests if a specific instance of AzureFunctionEventSubscriptionDestination can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForAzureFunctionEventSubscriptionDestination(subject AzureFunctionEventSubscriptionDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.AzureFunctionEventSubscriptionDestination
	err := copied.AssignProperties_To_AzureFunctionEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFunctionEventSubscriptionDestination
	err = actual.AssignProperties_From_AzureFunctionEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFunctionEventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFunctionEventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFunctionEventSubscriptionDestination, AzureFunctionEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFunctionEventSubscriptionDestination runs a test to see if a specific instance of AzureFunctionEventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFunctionEventSubscriptionDestination(subject AzureFunctionEventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFunctionEventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFunctionEventSubscriptionDestination instances for property testing - lazily instantiated by
// AzureFunctionEventSubscriptionDestinationGenerator()
var azureFunctionEventSubscriptionDestinationGenerator gopter.Gen

// AzureFunctionEventSubscriptionDestinationGenerator returns a generator of AzureFunctionEventSubscriptionDestination instances for property testing.
func AzureFunctionEventSubscriptionDestinationGenerator() gopter.Gen {
	if azureFunctionEventSubscriptionDestinationGenerator != nil {
		return azureFunctionEventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestination(generators)
	azureFunctionEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(AzureFunctionEventSubscriptionDestination{}), generators)

	return azureFunctionEventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(AzureFunctionEventSubscriptionDestination_EndpointType_AzureFunction)
	gens["MaxEventsPerBatch"] = gen.PtrOf(gen.Int())
	gens["PreferredBatchSizeInKilobytes"] = gen.PtrOf(gen.Int())
}

func Test_AzureFunctionEventSubscriptionDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AzureFunctionEventSubscriptionDestination_STATUS to AzureFunctionEventSubscriptionDestination_STATUS via AssignProperties_To_AzureFunctionEventSubscriptionDestination_STATUS & AssignProperties_From_AzureFunctionEventSubscriptionDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAzureFunctionEventSubscriptionDestination_STATUS, AzureFunctionEventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAzureFunctionEventSubscriptionDestination_STATUS tests if a specific instance of AzureFunctionEventSubscriptionDestination_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForAzureFunctionEventSubscriptionDestination_STATUS(subject AzureFunctionEventSubscriptionDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.AzureFunctionEventSubscriptionDestination_STATUS
	err := copied.AssignProperties_To_AzureFunctionEventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AzureFunctionEventSubscriptionDestination_STATUS
	err = actual.AssignProperties_From_AzureFunctionEventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AzureFunctionEventSubscriptionDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFunctionEventSubscriptionDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFunctionEventSubscriptionDestination_STATUS, AzureFunctionEventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFunctionEventSubscriptionDestination_STATUS runs a test to see if a specific instance of AzureFunctionEventSubscriptionDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFunctionEventSubscriptionDestination_STATUS(subject AzureFunctionEventSubscriptionDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFunctionEventSubscriptionDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFunctionEventSubscriptionDestination_STATUS instances for property testing - lazily instantiated by
// AzureFunctionEventSubscriptionDestination_STATUSGenerator()
var azureFunctionEventSubscriptionDestination_STATUSGenerator gopter.Gen

// AzureFunctionEventSubscriptionDestination_STATUSGenerator returns a generator of AzureFunctionEventSubscriptionDestination_STATUS instances for property testing.
func AzureFunctionEventSubscriptionDestination_STATUSGenerator() gopter.Gen {
	if azureFunctionEventSubscriptionDestination_STATUSGenerator != nil {
		return azureFunctionEventSubscriptionDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestination_STATUS(generators)
	azureFunctionEventSubscriptionDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFunctionEventSubscriptionDestination_STATUS{}), generators)

	return azureFunctionEventSubscriptionDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestination_STATUS(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(AzureFunctionEventSubscriptionDestination_EndpointType_STATUS_AzureFunction)
	gens["MaxEventsPerBatch"] = gen.PtrOf(gen.Int())
	gens["PreferredBatchSizeInKilobytes"] = gen.PtrOf(gen.Int())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventHubEventSubscriptionDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventHubEventSubscriptionDestination to EventHubEventSubscriptionDestination via AssignProperties_To_EventHubEventSubscriptionDestination & AssignProperties_From_EventHubEventSubscriptionDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventHubEventSubscriptionDestination, EventHubEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventHubEventSubscriptionDestination tests if a specific instance of EventHubEventSubscriptionDestination can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventHubEventSubscriptionDestination(subject EventHubEventSubscriptionDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.EventHubEventSubscriptionDestination
	err := copied.AssignProperties_To_EventHubEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventHubEventSubscriptionDestination
	err = actual.AssignProperties_From_EventHubEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventHubEventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubEventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubEventSubscriptionDestination, EventHubEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubEventSubscriptionDestination runs a test to see if a specific instance of EventHubEventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubEventSubscriptionDestination(subject EventHubEventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubEventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubEventSubscriptionDestination instances for property testing - lazily instantiated by
// EventHubEventSubscriptionDestinationGenerator()
var eventHubEventSubscriptionDestinationGenerator gopter.Gen

// EventHubEventSubscriptionDestinationGenerator returns a generator of EventHubEventSubscriptionDestination instances for property testing.
func EventHubEventSubscriptionDestinationGenerator() gopter.Gen {
	if eventHubEventSubscriptionDestinationGenerator != nil {
		return eventHubEventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestination(generators)
	eventHubEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(EventHubEventSubscriptionDestination{}), generators)

	return eventHubEventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(EventHubEventSubscriptionDestination_EndpointType_EventHub)
}

func Test_EventHubEventSubscriptionDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventHubEventSubscriptionDestination_STATUS to EventHubEventSubscriptionDestination_STATUS via AssignProperties_To_EventHubEventSubscriptionDestination_STATUS & AssignProperties_From_EventHubEventSubscriptionDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventHubEventSubscriptionDestination_STATUS, EventHubEventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventHubEventSubscriptionDestination_STATUS tests if a specific instance of EventHubEventSubscriptionDestination_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventHubEventSubscriptionDestination_STATUS(subject EventHubEventSubscriptionDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.EventHubEventSubscriptionDestination_STATUS
	err := copied.AssignProperties_To_EventHubEventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventHubEventSubscriptionDestination_STATUS
	err = actual.AssignProperties_From_EventHubEventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventHubEventSubscriptionDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubEventSubscriptionDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubEventSubscriptionDestination_STATUS, EventHubEventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubEventSubscriptionDestination_STATUS runs a test to see if a specific instance of EventHubEventSubscriptionDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubEventSubscriptionDestination_STATUS(subject EventHubEventSubscriptionDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubEventSubscriptionDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubEventSubscriptionDestination_STATUS instances for property testing - lazily instantiated by
// EventHubEventSubscriptionDestination_STATUSGenerator()
var eventHubEventSubscriptionDestination_STATUSGenerator gopter.Gen

// EventHubEventSubscriptionDestination_STATUSGenerator returns a generator of EventHubEventSubscriptionDestination_STATUS instances for property testing.
func EventHubEventSubscriptionDestination_STATUSGenerator() gopter.Gen {
	if eventHubEventSubscriptionDestination_STATUSGenerator != nil {
		return eventHubEventSubscriptionDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestination_STATUS(generators)
	eventHubEventSubscriptionDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(EventHubEventSubscriptionDestination_STATUS{}), generators)

	return eventHubEventSubscriptionDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestination_STATUS(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(EventHubEventSubscriptionDestination_EndpointType_STATUS_EventHub)
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_HybridConnectionEventSubscriptionDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HybridConnectionEventSubscriptionDestination to HybridConnectionEventSubscriptionDestination via AssignProperties_To_HybridConnectionEventSubscriptionDestination & AssignProperties_From_HybridConnectionEventSubscriptionDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForHybridConnectionEventSubscriptionDestination, HybridConnectionEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHybridConnectionEventSubscriptionDestination tests if a specific instance of HybridConnectionEventSubscriptionDestination can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForHybridConnectionEventSubscriptionDestination(subject HybridConnectionEventSubscriptionDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.HybridConnectionEventSubscriptionDestination
	err := copied.AssignProperties_To_HybridConnectionEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HybridConnectionEventSubscriptionDestination
	err = actual.AssignProperties_From_HybridConnectionEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HybridConnectionEventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HybridConnectionEventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHybridConnectionEventSubscriptionDestination, HybridConnectionEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHybridConnectionEventSubscriptionDestination runs a test to see if a specific instance of HybridConnectionEventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForHybridConnectionEventSubscriptionDestination(subject HybridConnectionEventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HybridConnectionEventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HybridConnectionEventSubscriptionDestination instances for property testing - lazily instantiated by
// HybridConnectionEventSubscriptionDestinationGenerator()
var hybridConnectionEventSubscriptionDestinationGenerator gopter.Gen

// HybridConnectionEventSubscriptionDestinationGenerator returns a generator of HybridConnectionEventSubscriptionDestination instances for property testing.
func HybridConnectionEventSubscriptionDestinationGenerator() gopter.Gen {
	if hybridConnectionEventSubscriptionDestinationGenerator != nil {
		return hybridConnectionEventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestination(generators)
	hybridConnectionEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(HybridConnectionEventSubscriptionDestination{}), generators)

	return hybridConnectionEventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(HybridConnectionEventSubscriptionDestination_EndpointType_HybridConnection)
}

func Test_HybridConnectionEventSubscriptionDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HybridConnectionEventSubscriptionDestination_STATUS to HybridConnectionEventSubscriptionDestination_STATUS via AssignProperties_To_HybridConnectionEventSubscriptionDestination_STATUS & AssignProperties_From_HybridConnectionEventSubscriptionDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHybridConnectionEventSubscriptionDestination_STATUS, HybridConnectionEventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHybridConnectionEventSubscriptionDestination_STATUS tests if a specific instance of HybridConnectionEventSubscriptionDestination_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForHybridConnectionEventSubscriptionDestination_STATUS(subject HybridConnectionEventSubscriptionDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.HybridConnectionEventSubscriptionDestination_STATUS
	err := copied.AssignProperties_To_HybridConnectionEventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HybridConnectionEventSubscriptionDestination_STATUS
	err = actual.AssignProperties_From_HybridConnectionEventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HybridConnectionEventSubscriptionDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HybridConnectionEventSubscriptionDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHybridConnectionEventSubscriptionDestination_STATUS, HybridConnectionEventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHybridConnectionEventSubscriptionDestination_STATUS runs a test to see if a specific instance of HybridConnectionEventSubscriptionDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHybridConnectionEventSubscriptionDestination_STATUS(subject HybridConnectionEventSubscriptionDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HybridConnectionEventSubscriptionDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HybridConnectionEventSubscriptionDestination_STATUS instances for property testing - lazily instantiated
// by HybridConnectionEventSubscriptionDestination_STATUSGenerator()
var hybridConnectionEventSubscriptionDestination_STATUSGenerator gopter.Gen

// HybridConnectionEventSubscriptionDestination_STATUSGenerator returns a generator of HybridConnectionEventSubscriptionDestination_STATUS instances for property testing.
func HybridConnectionEventSubscriptionDestination_STATUSGenerator() gopter.Gen {
	if hybridConnectionEventSubscriptionDestination_STATUSGenerator != nil {
		return hybridConnectionEventSubscriptionDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestination_STATUS(generators)
	hybridConnectionEventSubscriptionDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(HybridConnectionEventSubscriptionDestination_STATUS{}), generators)

	return hybridConnectionEventSubscriptionDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestination_STATUS(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(HybridConnectionEventSubscriptionDestination_EndpointType_STATUS_HybridConnection)
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceBusQueueEventSubscriptionDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServiceBusQueueEventSubscriptionDestination to ServiceBusQueueEventSubscriptionDestination via AssignProperties_To_ServiceBusQueueEventSubscriptionDestination & AssignProperties_From_ServiceBusQueueEventSubscriptionDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceBusQueueEventSubscriptionDestination, ServiceBusQueueEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceBusQueueEventSubscriptionDestination tests if a specific instance of ServiceBusQueueEventSubscriptionDestination can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForServiceBusQueueEventSubscriptionDestination(subject ServiceBusQueueEventSubscriptionDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.ServiceBusQueueEventSubscriptionDestination
	err := copied.AssignProperties_To_ServiceBusQueueEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceBusQueueEventSubscriptionDestination
	err = actual.AssignProperties_From_ServiceBusQueueEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceBusQueueEventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusQueueEventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestination, ServiceBusQueueEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestination runs a test to see if a specific instance of ServiceBusQueueEventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestination(subject ServiceBusQueueEventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusQueueEventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusQueueEventSubscriptionDestination instances for property testing - lazily instantiated by
// ServiceBusQueueEventSubscriptionDestinationGenerator()
var serviceBusQueueEventSubscriptionDestinationGenerator gopter.Gen

// ServiceBusQueueEventSubscriptionDestinationGenerator returns a generator of ServiceBusQueueEventSubscriptionDestination instances for property testing.
func ServiceBusQueueEventSubscriptionDestinationGenerator() gopter.Gen {
	if serviceBusQueueEventSubscriptionDestinationGenerator != nil {
		return serviceBusQueueEventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestination(generators)
	serviceBusQueueEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(ServiceBusQueueEventSubscriptionDestination{}), generators)

	return serviceBusQueueEventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(ServiceBusQueueEventSubscriptionDestination_EndpointType_ServiceBusQueue)
}

func Test_ServiceBusQueueEventSubscriptionDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServiceBusQueueEventSubscriptionDestination_STATUS to ServiceBusQueueEventSubscriptionDestination_STATUS via AssignProperties_To_ServiceBusQueueEventSubscriptionDestination_STATUS & AssignProperties_From_ServiceBusQueueEventSubscriptionDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceBusQueueEventSubscriptionDestination_STATUS, ServiceBusQueueEventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceBusQueueEventSubscriptionDestination_STATUS tests if a specific instance of ServiceBusQueueEventSubscriptionDestination_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForServiceBusQueueEventSubscriptionDestination_STATUS(subject ServiceBusQueueEventSubscriptionDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.ServiceBusQueueEventSubscriptionDestination_STATUS
	err := copied.AssignProperties_To_ServiceBusQueueEventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceBusQueueEventSubscriptionDestination_STATUS
	err = actual.AssignProperties_From_ServiceBusQueueEventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceBusQueueEventSubscriptionDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusQueueEventSubscriptionDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestination_STATUS, ServiceBusQueueEventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestination_STATUS runs a test to see if a specific instance of ServiceBusQueueEventSubscriptionDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestination_STATUS(subject ServiceBusQueueEventSubscriptionDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusQueueEventSubscriptionDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusQueueEventSubscriptionDestination_STATUS instances for property testing - lazily instantiated
// by ServiceBusQueueEventSubscriptionDestination_STATUSGenerator()
var serviceBusQueueEventSubscriptionDestination_STATUSGenerator gopter.Gen

// ServiceBusQueueEventSubscriptionDestination_STATUSGenerator returns a generator of ServiceBusQueueEventSubscriptionDestination_STATUS instances for property testing.
func ServiceBusQueueEventSubscriptionDestination_STATUSGenerator() gopter.Gen {
	if serviceBusQueueEventSubscriptionDestination_STATUSGenerator != nil {
		return serviceBusQueueEventSubscriptionDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestination_STATUS(generators)
	serviceBusQueueEventSubscriptionDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(ServiceBusQueueEventSubscriptionDestination_STATUS{}), generators)

	return serviceBusQueueEventSubscriptionDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestination_STATUS(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(ServiceBusQueueEventSubscriptionDestination_EndpointType_STATUS_ServiceBusQueue)
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceBusTopicEventSubscriptionDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServiceBusTopicEventSubscriptionDestination to ServiceBusTopicEventSubscriptionDestination via AssignProperties_To_ServiceBusTopicEventSubscriptionDestination & AssignProperties_From_ServiceBusTopicEventSubscriptionDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceBusTopicEventSubscriptionDestination, ServiceBusTopicEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceBusTopicEventSubscriptionDestination tests if a specific instance of ServiceBusTopicEventSubscriptionDestination can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForServiceBusTopicEventSubscriptionDestination(subject ServiceBusTopicEventSubscriptionDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.ServiceBusTopicEventSubscriptionDestination
	err := copied.AssignProperties_To_ServiceBusTopicEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceBusTopicEventSubscriptionDestination
	err = actual.AssignProperties_From_ServiceBusTopicEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceBusTopicEventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusTopicEventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestination, ServiceBusTopicEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestination runs a test to see if a specific instance of ServiceBusTopicEventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestination(subject ServiceBusTopicEventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusTopicEventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusTopicEventSubscriptionDestination instances for property testing - lazily instantiated by
// ServiceBusTopicEventSubscriptionDestinationGenerator()
var serviceBusTopicEventSubscriptionDestinationGenerator gopter.Gen

// ServiceBusTopicEventSubscriptionDestinationGenerator returns a generator of ServiceBusTopicEventSubscriptionDestination instances for property testing.
func ServiceBusTopicEventSubscriptionDestinationGenerator() gopter.Gen {
	if serviceBusTopicEventSubscriptionDestinationGenerator != nil {
		return serviceBusTopicEventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestination(generators)
	serviceBusTopicEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(ServiceBusTopicEventSubscriptionDestination{}), generators)

	return serviceBusTopicEventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(ServiceBusTopicEventSubscriptionDestination_EndpointType_ServiceBusTopic)
}

func Test_ServiceBusTopicEventSubscriptionDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServiceBusTopicEventSubscriptionDestination_STATUS to ServiceBusTopicEventSubscriptionDestination_STATUS via AssignProperties_To_ServiceBusTopicEventSubscriptionDestination_STATUS & AssignProperties_From_ServiceBusTopicEventSubscriptionDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServiceBusTopicEventSubscriptionDestination_STATUS, ServiceBusTopicEventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServiceBusTopicEventSubscriptionDestination_STATUS tests if a specific instance of ServiceBusTopicEventSubscriptionDestination_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForServiceBusTopicEventSubscriptionDestination_STATUS(subject ServiceBusTopicEventSubscriptionDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.ServiceBusTopicEventSubscriptionDestination_STATUS
	err := copied.AssignProperties_To_ServiceBusTopicEventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServiceBusTopicEventSubscriptionDestination_STATUS
	err = actual.AssignProperties_From_ServiceBusTopicEventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServiceBusTopicEventSubscriptionDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusTopicEventSubscriptionDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestination_STATUS, ServiceBusTopicEventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestination_STATUS runs a test to see if a specific instance of ServiceBusTopicEventSubscriptionDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestination_STATUS(subject ServiceBusTopicEventSubscriptionDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusTopicEventSubscriptionDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusTopicEventSubscriptionDestination_STATUS instances for property testing - lazily instantiated
// by ServiceBusTopicEventSubscriptionDestination_STATUSGenerator()
var serviceBusTopicEventSubscriptionDestination_STATUSGenerator gopter.Gen

// ServiceBusTopicEventSubscriptionDestination_STATUSGenerator returns a generator of ServiceBusTopicEventSubscriptionDestination_STATUS instances for property testing.
func ServiceBusTopicEventSubscriptionDestination_STATUSGenerator() gopter.Gen {
	if serviceBusTopicEventSubscriptionDestination_STATUSGenerator != nil {
		return serviceBusTopicEventSubscriptionDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestination_STATUS(generators)
	serviceBusTopicEventSubscriptionDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(ServiceBusTopicEventSubscriptionDestination_STATUS{}), generators)

	return serviceBusTopicEventSubscriptionDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestination_STATUS(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(ServiceBusTopicEventSubscriptionDestination_EndpointType_STATUS_ServiceBusTopic)
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageBlobDeadLetterDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageBlobDeadLetterDestination to StorageBlobDeadLetterDestination via AssignProperties_To_StorageBlobDeadLetterDestination & AssignProperties_From_StorageBlobDeadLetterDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageBlobDeadLetterDestination, StorageBlobDeadLetterDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageBlobDeadLetterDestination tests if a specific instance of StorageBlobDeadLetterDestination can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForStorageBlobDeadLetterDestination(subject StorageBlobDeadLetterDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.StorageBlobDeadLetterDestination
	err := copied.AssignProperties_To_StorageBlobDeadLetterDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageBlobDeadLetterDestination
	err = actual.AssignProperties_From_StorageBlobDeadLetterDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageBlobDeadLetterDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlobDeadLetterDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlobDeadLetterDestination, StorageBlobDeadLetterDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlobDeadLetterDestination runs a test to see if a specific instance of StorageBlobDeadLetterDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlobDeadLetterDestination(subject StorageBlobDeadLetterDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlobDeadLetterDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlobDeadLetterDestination instances for property testing - lazily instantiated by
// StorageBlobDeadLetterDestinationGenerator()
var storageBlobDeadLetterDestinationGenerator gopter.Gen

// StorageBlobDeadLetterDestinationGenerator returns a generator of StorageBlobDeadLetterDestination instances for property testing.
func StorageBlobDeadLetterDestinationGenerator() gopter.Gen {
	if storageBlobDeadLetterDestinationGenerator != nil {
		return storageBlobDeadLetterDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestination(generators)
	storageBlobDeadLetterDestinationGenerator = gen.Struct(reflect.TypeOf(StorageBlobDeadLetterDestination{}), generators)

	return storageBlobDeadLetterDestinationGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestination(gens map[string]gopter.Gen) {
	gens["BlobContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointType"] = gen.OneConstOf(StorageBlobDeadLetterDestination_EndpointType_StorageBlob)
}

func Test_StorageBlobDeadLetterDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageBlobDeadLetterDestination_STATUS to StorageBlobDeadLetterDestination_STATUS via AssignProperties_To_StorageBlobDeadLetterDestination_STATUS & AssignProperties_From_StorageBlobDeadLetterDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageBlobDeadLetterDestination_STATUS, StorageBlobDeadLetterDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageBlobDeadLetterDestination_STATUS tests if a specific instance of StorageBlobDeadLetterDestination_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForStorageBlobDeadLetterDestination_STATUS(subject StorageBlobDeadLetterDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.StorageBlobDeadLetterDestination_STATUS
	err := copied.AssignProperties_To_StorageBlobDeadLetterDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageBlobDeadLetterDestination_STATUS
	err = actual.AssignProperties_From_StorageBlobDeadLetterDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageBlobDeadLetterDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlobDeadLetterDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlobDeadLetterDestination_STATUS, StorageBlobDeadLetterDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlobDeadLetterDestination_STATUS runs a test to see if a specific instance of StorageBlobDeadLetterDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlobDeadLetterDestination_STATUS(subject StorageBlobDeadLetterDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlobDeadLetterDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlobDeadLetterDestination_STATUS instances for property testing - lazily instantiated by
// StorageBlobDeadLetterDestination_STATUSGenerator()
var storageBlobDeadLetterDestination_STATUSGenerator gopter.Gen

// StorageBlobDeadLetterDestination_STATUSGenerator returns a generator of StorageBlobDeadLetterDestination_STATUS instances for property testing.
func StorageBlobDeadLetterDestination_STATUSGenerator() gopter.Gen {
	if storageBlobDeadLetterDestination_STATUSGenerator != nil {
		return storageBlobDeadLetterDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestination_STATUS(generators)
	storageBlobDeadLetterDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageBlobDeadLetterDestination_STATUS{}), generators)

	return storageBlobDeadLetterDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestination_STATUS(gens map[string]gopter.Gen) {
	gens["BlobContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointType"] = gen.OneConstOf(StorageBlobDeadLetterDestination_EndpointType_STATUS_StorageBlob)
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageQueueEventSubscriptionDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageQueueEventSubscriptionDestination to StorageQueueEventSubscriptionDestination via AssignProperties_To_StorageQueueEventSubscriptionDestination & AssignProperties_From_StorageQueueEventSubscriptionDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageQueueEventSubscriptionDestination, StorageQueueEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageQueueEventSubscriptionDestination tests if a specific instance of StorageQueueEventSubscriptionDestination can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForStorageQueueEventSubscriptionDestination(subject StorageQueueEventSubscriptionDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.StorageQueueEventSubscriptionDestination
	err := copied.AssignProperties_To_StorageQueueEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageQueueEventSubscriptionDestination
	err = actual.AssignProperties_From_StorageQueueEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageQueueEventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageQueueEventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageQueueEventSubscriptionDestination, StorageQueueEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageQueueEventSubscriptionDestination runs a test to see if a specific instance of StorageQueueEventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageQueueEventSubscriptionDestination(subject StorageQueueEventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageQueueEventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageQueueEventSubscriptionDestination instances for property testing - lazily instantiated by
// StorageQueueEventSubscriptionDestinationGenerator()
var storageQueueEventSubscriptionDestinationGenerator gopter.Gen

// StorageQueueEventSubscriptionDestinationGenerator returns a generator of StorageQueueEventSubscriptionDestination instances for property testing.
func StorageQueueEventSubscriptionDestinationGenerator() gopter.Gen {
	if storageQueueEventSubscriptionDestinationGenerator != nil {
		return storageQueueEventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestination(generators)
	storageQueueEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(StorageQueueEventSubscriptionDestination{}), generators)

	return storageQueueEventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(StorageQueueEventSubscriptionDestination_EndpointType_StorageQueue)
	gens["QueueName"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageQueueEventSubscriptionDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StorageQueueEventSubscriptionDestination_STATUS to StorageQueueEventSubscriptionDestination_STATUS via AssignProperties_To_StorageQueueEventSubscriptionDestination_STATUS & AssignProperties_From_StorageQueueEventSubscriptionDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStorageQueueEventSubscriptionDestination_STATUS, StorageQueueEventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStorageQueueEventSubscriptionDestination_STATUS tests if a specific instance of StorageQueueEventSubscriptionDestination_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForStorageQueueEventSubscriptionDestination_STATUS(subject StorageQueueEventSubscriptionDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.StorageQueueEventSubscriptionDestination_STATUS
	err := copied.AssignProperties_To_StorageQueueEventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StorageQueueEventSubscriptionDestination_STATUS
	err = actual.AssignProperties_From_StorageQueueEventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StorageQueueEventSubscriptionDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageQueueEventSubscriptionDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageQueueEventSubscriptionDestination_STATUS, StorageQueueEventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageQueueEventSubscriptionDestination_STATUS runs a test to see if a specific instance of StorageQueueEventSubscriptionDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageQueueEventSubscriptionDestination_STATUS(subject StorageQueueEventSubscriptionDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageQueueEventSubscriptionDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageQueueEventSubscriptionDestination_STATUS instances for property testing - lazily instantiated by
// StorageQueueEventSubscriptionDestination_STATUSGenerator()
var storageQueueEventSubscriptionDestination_STATUSGenerator gopter.Gen

// StorageQueueEventSubscriptionDestination_STATUSGenerator returns a generator of StorageQueueEventSubscriptionDestination_STATUS instances for property testing.
func StorageQueueEventSubscriptionDestination_STATUSGenerator() gopter.Gen {
	if storageQueueEventSubscriptionDestination_STATUSGenerator != nil {
		return storageQueueEventSubscriptionDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestination_STATUS(generators)
	storageQueueEventSubscriptionDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageQueueEventSubscriptionDestination_STATUS{}), generators)

	return storageQueueEventSubscriptionDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestination_STATUS(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(StorageQueueEventSubscriptionDestination_EndpointType_STATUS_StorageQueue)
	gens["QueueName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WebHookEventSubscriptionDestination_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebHookEventSubscriptionDestination to WebHookEventSubscriptionDestination via AssignProperties_To_WebHookEventSubscriptionDestination & AssignProperties_From_WebHookEventSubscriptionDestination returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebHookEventSubscriptionDestination, WebHookEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebHookEventSubscriptionDestination tests if a specific instance of WebHookEventSubscriptionDestination can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForWebHookEventSubscriptionDestination(subject WebHookEventSubscriptionDestination) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.WebHookEventSubscriptionDestination
	err := copied.AssignProperties_To_WebHookEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebHookEventSubscriptionDestination
	err = actual.AssignProperties_From_WebHookEventSubscriptionDestination(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebHookEventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebHookEventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebHookEventSubscriptionDestination, WebHookEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebHookEventSubscriptionDestination runs a test to see if a specific instance of WebHookEventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForWebHookEventSubscriptionDestination(subject WebHookEventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebHookEventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebHookEventSubscriptionDestination instances for property testing - lazily instantiated by
// WebHookEventSubscriptionDestinationGenerator()
var webHookEventSubscriptionDestinationGenerator gopter.Gen

// WebHookEventSubscriptionDestinationGenerator returns a generator of WebHookEventSubscriptionDestination instances for property testing.
func WebHookEventSubscriptionDestinationGenerator() gopter.Gen {
	if webHookEventSubscriptionDestinationGenerator != nil {
		return webHookEventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestination(generators)
	webHookEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(WebHookEventSubscriptionDestination{}), generators)

	return webHookEventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["AzureActiveDirectoryApplicationIdOrUri"] = gen.PtrOf(gen.AlphaString())
	gens["AzureActiveDirectoryTenantId"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointType"] = gen.OneConstOf(WebHookEventSubscriptionDestination_EndpointType_WebHook)
	gens["MaxEventsPerBatch"] = gen.PtrOf(gen.Int())
	gens["PreferredBatchSizeInKilobytes"] = gen.PtrOf(gen.Int())
}

func Test_WebHookEventSubscriptionDestination_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WebHookEventSubscriptionDestination_STATUS to WebHookEventSubscriptionDestination_STATUS via AssignProperties_To_WebHookEventSubscriptionDestination_STATUS & AssignProperties_From_WebHookEventSubscriptionDestination_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWebHookEventSubscriptionDestination_STATUS, WebHookEventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWebHookEventSubscriptionDestination_STATUS tests if a specific instance of WebHookEventSubscriptionDestination_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForWebHookEventSubscriptionDestination_STATUS(subject WebHookEventSubscriptionDestination_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.WebHookEventSubscriptionDestination_STATUS
	err := copied.AssignProperties_To_WebHookEventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WebHookEventSubscriptionDestination_STATUS
	err = actual.AssignProperties_From_WebHookEventSubscriptionDestination_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WebHookEventSubscriptionDestination_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebHookEventSubscriptionDestination_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebHookEventSubscriptionDestination_STATUS, WebHookEventSubscriptionDestination_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebHookEventSubscriptionDestination_STATUS runs a test to see if a specific instance of WebHookEventSubscriptionDestination_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWebHookEventSubscriptionDestination_STATUS(subject WebHookEventSubscriptionDestination_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebHookEventSubscriptionDestination_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebHookEventSubscriptionDestination_STATUS instances for property testing - lazily instantiated by
// WebHookEventSubscriptionDestination_STATUSGenerator()
var webHookEventSubscriptionDestination_STATUSGenerator gopter.Gen

// WebHookEventSubscriptionDestination_STATUSGenerator returns a generator of WebHookEventSubscriptionDestination_STATUS instances for property testing.
func WebHookEventSubscriptionDestination_STATUSGenerator() gopter.Gen {
	if webHookEventSubscriptionDestination_STATUSGenerator != nil {
		return webHookEventSubscriptionDestination_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestination_STATUS(generators)
	webHookEventSubscriptionDestination_STATUSGenerator = gen.Struct(reflect.TypeOf(WebHookEventSubscriptionDestination_STATUS{}), generators)

	return webHookEventSubscriptionDestination_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestination_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestination_STATUS(gens map[string]gopter.Gen) {
	gens["AzureActiveDirectoryApplicationIdOrUri"] = gen.PtrOf(gen.AlphaString())
	gens["AzureActiveDirectoryTenantId"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointBaseUrl"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointType"] = gen.OneConstOf(WebHookEventSubscriptionDestination_EndpointType_STATUS_WebHook)
	gens["MaxEventsPerBatch"] = gen.PtrOf(gen.Int())
	gens["PreferredBatchSizeInKilobytes"] = gen.PtrOf(gen.Int())
}

func Test_BoolEqualsAdvancedFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BoolEqualsAdvancedFilter to BoolEqualsAdvancedFilter via AssignProperties_To_BoolEqualsAdvancedFilter & AssignProperties_From_BoolEqualsAdvancedFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForBoolEqualsAdvancedFilter, BoolEqualsAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBoolEqualsAdvancedFilter tests if a specific instance of BoolEqualsAdvancedFilter can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForBoolEqualsAdvancedFilter(subject BoolEqualsAdvancedFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.BoolEqualsAdvancedFilter
	err := copied.AssignProperties_To_BoolEqualsAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BoolEqualsAdvancedFilter
	err = actual.AssignProperties_From_BoolEqualsAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BoolEqualsAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BoolEqualsAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBoolEqualsAdvancedFilter, BoolEqualsAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBoolEqualsAdvancedFilter runs a test to see if a specific instance of BoolEqualsAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForBoolEqualsAdvancedFilter(subject BoolEqualsAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BoolEqualsAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BoolEqualsAdvancedFilter instances for property testing - lazily instantiated by
// BoolEqualsAdvancedFilterGenerator()
var boolEqualsAdvancedFilterGenerator gopter.Gen

// BoolEqualsAdvancedFilterGenerator returns a generator of BoolEqualsAdvancedFilter instances for property testing.
func BoolEqualsAdvancedFilterGenerator() gopter.Gen {
	if boolEqualsAdvancedFilterGenerator != nil {
		return boolEqualsAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBoolEqualsAdvancedFilter(generators)
	boolEqualsAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(BoolEqualsAdvancedFilter{}), generators)

	return boolEqualsAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForBoolEqualsAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBoolEqualsAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(BoolEqualsAdvancedFilter_OperatorType_BoolEquals)
	gens["Value"] = gen.PtrOf(gen.Bool())
}

func Test_BoolEqualsAdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BoolEqualsAdvancedFilter_STATUS to BoolEqualsAdvancedFilter_STATUS via AssignProperties_To_BoolEqualsAdvancedFilter_STATUS & AssignProperties_From_BoolEqualsAdvancedFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForBoolEqualsAdvancedFilter_STATUS, BoolEqualsAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBoolEqualsAdvancedFilter_STATUS tests if a specific instance of BoolEqualsAdvancedFilter_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForBoolEqualsAdvancedFilter_STATUS(subject BoolEqualsAdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.BoolEqualsAdvancedFilter_STATUS
	err := copied.AssignProperties_To_BoolEqualsAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BoolEqualsAdvancedFilter_STATUS
	err = actual.AssignProperties_From_BoolEqualsAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BoolEqualsAdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BoolEqualsAdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBoolEqualsAdvancedFilter_STATUS, BoolEqualsAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBoolEqualsAdvancedFilter_STATUS runs a test to see if a specific instance of BoolEqualsAdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBoolEqualsAdvancedFilter_STATUS(subject BoolEqualsAdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BoolEqualsAdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BoolEqualsAdvancedFilter_STATUS instances for property testing - lazily instantiated by
// BoolEqualsAdvancedFilter_STATUSGenerator()
var boolEqualsAdvancedFilter_STATUSGenerator gopter.Gen

// BoolEqualsAdvancedFilter_STATUSGenerator returns a generator of BoolEqualsAdvancedFilter_STATUS instances for property testing.
func BoolEqualsAdvancedFilter_STATUSGenerator() gopter.Gen {
	if boolEqualsAdvancedFilter_STATUSGenerator != nil {
		return boolEqualsAdvancedFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBoolEqualsAdvancedFilter_STATUS(generators)
	boolEqualsAdvancedFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(BoolEqualsAdvancedFilter_STATUS{}), generators)

	return boolEqualsAdvancedFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBoolEqualsAdvancedFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBoolEqualsAdvancedFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(BoolEqualsAdvancedFilter_OperatorType_STATUS_BoolEquals)
	gens["Value"] = gen.PtrOf(gen.Bool())
}

func Test_NumberGreaterThanAdvancedFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NumberGreaterThanAdvancedFilter to NumberGreaterThanAdvancedFilter via AssignProperties_To_NumberGreaterThanAdvancedFilter & AssignProperties_From_NumberGreaterThanAdvancedFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForNumberGreaterThanAdvancedFilter, NumberGreaterThanAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNumberGreaterThanAdvancedFilter tests if a specific instance of NumberGreaterThanAdvancedFilter can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForNumberGreaterThanAdvancedFilter(subject NumberGreaterThanAdvancedFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.NumberGreaterThanAdvancedFilter
	err := copied.AssignProperties_To_NumberGreaterThanAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NumberGreaterThanAdvancedFilter
	err = actual.AssignProperties_From_NumberGreaterThanAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NumberGreaterThanAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberGreaterThanAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberGreaterThanAdvancedFilter, NumberGreaterThanAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberGreaterThanAdvancedFilter runs a test to see if a specific instance of NumberGreaterThanAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberGreaterThanAdvancedFilter(subject NumberGreaterThanAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberGreaterThanAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberGreaterThanAdvancedFilter instances for property testing - lazily instantiated by
// NumberGreaterThanAdvancedFilterGenerator()
var numberGreaterThanAdvancedFilterGenerator gopter.Gen

// NumberGreaterThanAdvancedFilterGenerator returns a generator of NumberGreaterThanAdvancedFilter instances for property testing.
func NumberGreaterThanAdvancedFilterGenerator() gopter.Gen {
	if numberGreaterThanAdvancedFilterGenerator != nil {
		return numberGreaterThanAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberGreaterThanAdvancedFilter(generators)
	numberGreaterThanAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(NumberGreaterThanAdvancedFilter{}), generators)

	return numberGreaterThanAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForNumberGreaterThanAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberGreaterThanAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberGreaterThanAdvancedFilter_OperatorType_NumberGreaterThan)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_NumberGreaterThanAdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NumberGreaterThanAdvancedFilter_STATUS to NumberGreaterThanAdvancedFilter_STATUS via AssignProperties_To_NumberGreaterThanAdvancedFilter_STATUS & AssignProperties_From_NumberGreaterThanAdvancedFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNumberGreaterThanAdvancedFilter_STATUS, NumberGreaterThanAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNumberGreaterThanAdvancedFilter_STATUS tests if a specific instance of NumberGreaterThanAdvancedFilter_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForNumberGreaterThanAdvancedFilter_STATUS(subject NumberGreaterThanAdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.NumberGreaterThanAdvancedFilter_STATUS
	err := copied.AssignProperties_To_NumberGreaterThanAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NumberGreaterThanAdvancedFilter_STATUS
	err = actual.AssignProperties_From_NumberGreaterThanAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NumberGreaterThanAdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberGreaterThanAdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberGreaterThanAdvancedFilter_STATUS, NumberGreaterThanAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberGreaterThanAdvancedFilter_STATUS runs a test to see if a specific instance of NumberGreaterThanAdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberGreaterThanAdvancedFilter_STATUS(subject NumberGreaterThanAdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberGreaterThanAdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberGreaterThanAdvancedFilter_STATUS instances for property testing - lazily instantiated by
// NumberGreaterThanAdvancedFilter_STATUSGenerator()
var numberGreaterThanAdvancedFilter_STATUSGenerator gopter.Gen

// NumberGreaterThanAdvancedFilter_STATUSGenerator returns a generator of NumberGreaterThanAdvancedFilter_STATUS instances for property testing.
func NumberGreaterThanAdvancedFilter_STATUSGenerator() gopter.Gen {
	if numberGreaterThanAdvancedFilter_STATUSGenerator != nil {
		return numberGreaterThanAdvancedFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberGreaterThanAdvancedFilter_STATUS(generators)
	numberGreaterThanAdvancedFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(NumberGreaterThanAdvancedFilter_STATUS{}), generators)

	return numberGreaterThanAdvancedFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNumberGreaterThanAdvancedFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberGreaterThanAdvancedFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberGreaterThanAdvancedFilter_OperatorType_STATUS_NumberGreaterThan)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_NumberGreaterThanOrEqualsAdvancedFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NumberGreaterThanOrEqualsAdvancedFilter to NumberGreaterThanOrEqualsAdvancedFilter via AssignProperties_To_NumberGreaterThanOrEqualsAdvancedFilter & AssignProperties_From_NumberGreaterThanOrEqualsAdvancedFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForNumberGreaterThanOrEqualsAdvancedFilter, NumberGreaterThanOrEqualsAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNumberGreaterThanOrEqualsAdvancedFilter tests if a specific instance of NumberGreaterThanOrEqualsAdvancedFilter can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForNumberGreaterThanOrEqualsAdvancedFilter(subject NumberGreaterThanOrEqualsAdvancedFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.NumberGreaterThanOrEqualsAdvancedFilter
	err := copied.AssignProperties_To_NumberGreaterThanOrEqualsAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NumberGreaterThanOrEqualsAdvancedFilter
	err = actual.AssignProperties_From_NumberGreaterThanOrEqualsAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NumberGreaterThanOrEqualsAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberGreaterThanOrEqualsAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberGreaterThanOrEqualsAdvancedFilter, NumberGreaterThanOrEqualsAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberGreaterThanOrEqualsAdvancedFilter runs a test to see if a specific instance of NumberGreaterThanOrEqualsAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberGreaterThanOrEqualsAdvancedFilter(subject NumberGreaterThanOrEqualsAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberGreaterThanOrEqualsAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberGreaterThanOrEqualsAdvancedFilter instances for property testing - lazily instantiated by
// NumberGreaterThanOrEqualsAdvancedFilterGenerator()
var numberGreaterThanOrEqualsAdvancedFilterGenerator gopter.Gen

// NumberGreaterThanOrEqualsAdvancedFilterGenerator returns a generator of NumberGreaterThanOrEqualsAdvancedFilter instances for property testing.
func NumberGreaterThanOrEqualsAdvancedFilterGenerator() gopter.Gen {
	if numberGreaterThanOrEqualsAdvancedFilterGenerator != nil {
		return numberGreaterThanOrEqualsAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberGreaterThanOrEqualsAdvancedFilter(generators)
	numberGreaterThanOrEqualsAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(NumberGreaterThanOrEqualsAdvancedFilter{}), generators)

	return numberGreaterThanOrEqualsAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForNumberGreaterThanOrEqualsAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberGreaterThanOrEqualsAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberGreaterThanOrEqualsAdvancedFilter_OperatorType_NumberGreaterThanOrEquals)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_NumberGreaterThanOrEqualsAdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NumberGreaterThanOrEqualsAdvancedFilter_STATUS to NumberGreaterThanOrEqualsAdvancedFilter_STATUS via AssignProperties_To_NumberGreaterThanOrEqualsAdvancedFilter_STATUS & AssignProperties_From_NumberGreaterThanOrEqualsAdvancedFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNumberGreaterThanOrEqualsAdvancedFilter_STATUS, NumberGreaterThanOrEqualsAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNumberGreaterThanOrEqualsAdvancedFilter_STATUS tests if a specific instance of NumberGreaterThanOrEqualsAdvancedFilter_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForNumberGreaterThanOrEqualsAdvancedFilter_STATUS(subject NumberGreaterThanOrEqualsAdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.NumberGreaterThanOrEqualsAdvancedFilter_STATUS
	err := copied.AssignProperties_To_NumberGreaterThanOrEqualsAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NumberGreaterThanOrEqualsAdvancedFilter_STATUS
	err = actual.AssignProperties_From_NumberGreaterThanOrEqualsAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NumberGreaterThanOrEqualsAdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberGreaterThanOrEqualsAdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberGreaterThanOrEqualsAdvancedFilter_STATUS, NumberGreaterThanOrEqualsAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberGreaterThanOrEqualsAdvancedFilter_STATUS runs a test to see if a specific instance of NumberGreaterThanOrEqualsAdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberGreaterThanOrEqualsAdvancedFilter_STATUS(subject NumberGreaterThanOrEqualsAdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberGreaterThanOrEqualsAdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberGreaterThanOrEqualsAdvancedFilter_STATUS instances for property testing - lazily instantiated by
// NumberGreaterThanOrEqualsAdvancedFilter_STATUSGenerator()
var numberGreaterThanOrEqualsAdvancedFilter_STATUSGenerator gopter.Gen

// NumberGreaterThanOrEqualsAdvancedFilter_STATUSGenerator returns a generator of NumberGreaterThanOrEqualsAdvancedFilter_STATUS instances for property testing.
func NumberGreaterThanOrEqualsAdvancedFilter_STATUSGenerator() gopter.Gen {
	if numberGreaterThanOrEqualsAdvancedFilter_STATUSGenerator != nil {
		return numberGreaterThanOrEqualsAdvancedFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberGreaterThanOrEqualsAdvancedFilter_STATUS(generators)
	numberGreaterThanOrEqualsAdvancedFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(NumberGreaterThanOrEqualsAdvancedFilter_STATUS{}), generators)

	return numberGreaterThanOrEqualsAdvancedFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNumberGreaterThanOrEqualsAdvancedFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberGreaterThanOrEqualsAdvancedFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberGreaterThanOrEqualsAdvancedFilter_OperatorType_STATUS_NumberGreaterThanOrEquals)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_NumberInAdvancedFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NumberInAdvancedFilter to NumberInAdvancedFilter via AssignProperties_To_NumberInAdvancedFilter & AssignProperties_From_NumberInAdvancedFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForNumberInAdvancedFilter, NumberInAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNumberInAdvancedFilter tests if a specific instance of NumberInAdvancedFilter can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForNumberInAdvancedFilter(subject NumberInAdvancedFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.NumberInAdvancedFilter
	err := copied.AssignProperties_To_NumberInAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NumberInAdvancedFilter
	err = actual.AssignProperties_From_NumberInAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NumberInAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberInAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberInAdvancedFilter, NumberInAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberInAdvancedFilter runs a test to see if a specific instance of NumberInAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberInAdvancedFilter(subject NumberInAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberInAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberInAdvancedFilter instances for property testing - lazily instantiated by
// NumberInAdvancedFilterGenerator()
var numberInAdvancedFilterGenerator gopter.Gen

// NumberInAdvancedFilterGenerator returns a generator of NumberInAdvancedFilter instances for property testing.
func NumberInAdvancedFilterGenerator() gopter.Gen {
	if numberInAdvancedFilterGenerator != nil {
		return numberInAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberInAdvancedFilter(generators)
	numberInAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(NumberInAdvancedFilter{}), generators)

	return numberInAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForNumberInAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberInAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberInAdvancedFilter_OperatorType_NumberIn)
	gens["Values"] = gen.SliceOf(gen.Float64())
}

func Test_NumberInAdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NumberInAdvancedFilter_STATUS to NumberInAdvancedFilter_STATUS via AssignProperties_To_NumberInAdvancedFilter_STATUS & AssignProperties_From_NumberInAdvancedFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNumberInAdvancedFilter_STATUS, NumberInAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNumberInAdvancedFilter_STATUS tests if a specific instance of NumberInAdvancedFilter_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForNumberInAdvancedFilter_STATUS(subject NumberInAdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.NumberInAdvancedFilter_STATUS
	err := copied.AssignProperties_To_NumberInAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NumberInAdvancedFilter_STATUS
	err = actual.AssignProperties_From_NumberInAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NumberInAdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberInAdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberInAdvancedFilter_STATUS, NumberInAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberInAdvancedFilter_STATUS runs a test to see if a specific instance of NumberInAdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberInAdvancedFilter_STATUS(subject NumberInAdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberInAdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberInAdvancedFilter_STATUS instances for property testing - lazily instantiated by
// NumberInAdvancedFilter_STATUSGenerator()
var numberInAdvancedFilter_STATUSGenerator gopter.Gen

// NumberInAdvancedFilter_STATUSGenerator returns a generator of NumberInAdvancedFilter_STATUS instances for property testing.
func NumberInAdvancedFilter_STATUSGenerator() gopter.Gen {
	if numberInAdvancedFilter_STATUSGenerator != nil {
		return numberInAdvancedFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberInAdvancedFilter_STATUS(generators)
	numberInAdvancedFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(NumberInAdvancedFilter_STATUS{}), generators)

	return numberInAdvancedFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNumberInAdvancedFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberInAdvancedFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberInAdvancedFilter_OperatorType_STATUS_NumberIn)
	gens["Values"] = gen.SliceOf(gen.Float64())
}

func Test_NumberLessThanAdvancedFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NumberLessThanAdvancedFilter to NumberLessThanAdvancedFilter via AssignProperties_To_NumberLessThanAdvancedFilter & AssignProperties_From_NumberLessThanAdvancedFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForNumberLessThanAdvancedFilter, NumberLessThanAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNumberLessThanAdvancedFilter tests if a specific instance of NumberLessThanAdvancedFilter can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForNumberLessThanAdvancedFilter(subject NumberLessThanAdvancedFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.NumberLessThanAdvancedFilter
	err := copied.AssignProperties_To_NumberLessThanAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NumberLessThanAdvancedFilter
	err = actual.AssignProperties_From_NumberLessThanAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NumberLessThanAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberLessThanAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberLessThanAdvancedFilter, NumberLessThanAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberLessThanAdvancedFilter runs a test to see if a specific instance of NumberLessThanAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberLessThanAdvancedFilter(subject NumberLessThanAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberLessThanAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberLessThanAdvancedFilter instances for property testing - lazily instantiated by
// NumberLessThanAdvancedFilterGenerator()
var numberLessThanAdvancedFilterGenerator gopter.Gen

// NumberLessThanAdvancedFilterGenerator returns a generator of NumberLessThanAdvancedFilter instances for property testing.
func NumberLessThanAdvancedFilterGenerator() gopter.Gen {
	if numberLessThanAdvancedFilterGenerator != nil {
		return numberLessThanAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberLessThanAdvancedFilter(generators)
	numberLessThanAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(NumberLessThanAdvancedFilter{}), generators)

	return numberLessThanAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForNumberLessThanAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberLessThanAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberLessThanAdvancedFilter_OperatorType_NumberLessThan)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_NumberLessThanAdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NumberLessThanAdvancedFilter_STATUS to NumberLessThanAdvancedFilter_STATUS via AssignProperties_To_NumberLessThanAdvancedFilter_STATUS & AssignProperties_From_NumberLessThanAdvancedFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNumberLessThanAdvancedFilter_STATUS, NumberLessThanAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNumberLessThanAdvancedFilter_STATUS tests if a specific instance of NumberLessThanAdvancedFilter_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForNumberLessThanAdvancedFilter_STATUS(subject NumberLessThanAdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.NumberLessThanAdvancedFilter_STATUS
	err := copied.AssignProperties_To_NumberLessThanAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NumberLessThanAdvancedFilter_STATUS
	err = actual.AssignProperties_From_NumberLessThanAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NumberLessThanAdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberLessThanAdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberLessThanAdvancedFilter_STATUS, NumberLessThanAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberLessThanAdvancedFilter_STATUS runs a test to see if a specific instance of NumberLessThanAdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberLessThanAdvancedFilter_STATUS(subject NumberLessThanAdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberLessThanAdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberLessThanAdvancedFilter_STATUS instances for property testing - lazily instantiated by
// NumberLessThanAdvancedFilter_STATUSGenerator()
var numberLessThanAdvancedFilter_STATUSGenerator gopter.Gen

// NumberLessThanAdvancedFilter_STATUSGenerator returns a generator of NumberLessThanAdvancedFilter_STATUS instances for property testing.
func NumberLessThanAdvancedFilter_STATUSGenerator() gopter.Gen {
	if numberLessThanAdvancedFilter_STATUSGenerator != nil {
		return numberLessThanAdvancedFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberLessThanAdvancedFilter_STATUS(generators)
	numberLessThanAdvancedFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(NumberLessThanAdvancedFilter_STATUS{}), generators)

	return numberLessThanAdvancedFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNumberLessThanAdvancedFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberLessThanAdvancedFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberLessThanAdvancedFilter_OperatorType_STATUS_NumberLessThan)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_NumberLessThanOrEqualsAdvancedFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NumberLessThanOrEqualsAdvancedFilter to NumberLessThanOrEqualsAdvancedFilter via AssignProperties_To_NumberLessThanOrEqualsAdvancedFilter & AssignProperties_From_NumberLessThanOrEqualsAdvancedFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForNumberLessThanOrEqualsAdvancedFilter, NumberLessThanOrEqualsAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNumberLessThanOrEqualsAdvancedFilter tests if a specific instance of NumberLessThanOrEqualsAdvancedFilter can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForNumberLessThanOrEqualsAdvancedFilter(subject NumberLessThanOrEqualsAdvancedFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.NumberLessThanOrEqualsAdvancedFilter
	err := copied.AssignProperties_To_NumberLessThanOrEqualsAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NumberLessThanOrEqualsAdvancedFilter
	err = actual.AssignProperties_From_NumberLessThanOrEqualsAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NumberLessThanOrEqualsAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberLessThanOrEqualsAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberLessThanOrEqualsAdvancedFilter, NumberLessThanOrEqualsAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberLessThanOrEqualsAdvancedFilter runs a test to see if a specific instance of NumberLessThanOrEqualsAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberLessThanOrEqualsAdvancedFilter(subject NumberLessThanOrEqualsAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberLessThanOrEqualsAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberLessThanOrEqualsAdvancedFilter instances for property testing - lazily instantiated by
// NumberLessThanOrEqualsAdvancedFilterGenerator()
var numberLessThanOrEqualsAdvancedFilterGenerator gopter.Gen

// NumberLessThanOrEqualsAdvancedFilterGenerator returns a generator of NumberLessThanOrEqualsAdvancedFilter instances for property testing.
func NumberLessThanOrEqualsAdvancedFilterGenerator() gopter.Gen {
	if numberLessThanOrEqualsAdvancedFilterGenerator != nil {
		return numberLessThanOrEqualsAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberLessThanOrEqualsAdvancedFilter(generators)
	numberLessThanOrEqualsAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(NumberLessThanOrEqualsAdvancedFilter{}), generators)

	return numberLessThanOrEqualsAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForNumberLessThanOrEqualsAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberLessThanOrEqualsAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberLessThanOrEqualsAdvancedFilter_OperatorType_NumberLessThanOrEquals)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_NumberLessThanOrEqualsAdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NumberLessThanOrEqualsAdvancedFilter_STATUS to NumberLessThanOrEqualsAdvancedFilter_STATUS via AssignProperties_To_NumberLessThanOrEqualsAdvancedFilter_STATUS & AssignProperties_From_NumberLessThanOrEqualsAdvancedFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNumberLessThanOrEqualsAdvancedFilter_STATUS, NumberLessThanOrEqualsAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNumberLessThanOrEqualsAdvancedFilter_STATUS tests if a specific instance of NumberLessThanOrEqualsAdvancedFilter_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForNumberLessThanOrEqualsAdvancedFilter_STATUS(subject NumberLessThanOrEqualsAdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.NumberLessThanOrEqualsAdvancedFilter_STATUS
	err := copied.AssignProperties_To_NumberLessThanOrEqualsAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NumberLessThanOrEqualsAdvancedFilter_STATUS
	err = actual.AssignProperties_From_NumberLessThanOrEqualsAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NumberLessThanOrEqualsAdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberLessThanOrEqualsAdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberLessThanOrEqualsAdvancedFilter_STATUS, NumberLessThanOrEqualsAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberLessThanOrEqualsAdvancedFilter_STATUS runs a test to see if a specific instance of NumberLessThanOrEqualsAdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberLessThanOrEqualsAdvancedFilter_STATUS(subject NumberLessThanOrEqualsAdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberLessThanOrEqualsAdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberLessThanOrEqualsAdvancedFilter_STATUS instances for property testing - lazily instantiated by
// NumberLessThanOrEqualsAdvancedFilter_STATUSGenerator()
var numberLessThanOrEqualsAdvancedFilter_STATUSGenerator gopter.Gen

// NumberLessThanOrEqualsAdvancedFilter_STATUSGenerator returns a generator of NumberLessThanOrEqualsAdvancedFilter_STATUS instances for property testing.
func NumberLessThanOrEqualsAdvancedFilter_STATUSGenerator() gopter.Gen {
	if numberLessThanOrEqualsAdvancedFilter_STATUSGenerator != nil {
		return numberLessThanOrEqualsAdvancedFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberLessThanOrEqualsAdvancedFilter_STATUS(generators)
	numberLessThanOrEqualsAdvancedFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(NumberLessThanOrEqualsAdvancedFilter_STATUS{}), generators)

	return numberLessThanOrEqualsAdvancedFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNumberLessThanOrEqualsAdvancedFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberLessThanOrEqualsAdvancedFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberLessThanOrEqualsAdvancedFilter_OperatorType_STATUS_NumberLessThanOrEquals)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_NumberNotInAdvancedFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NumberNotInAdvancedFilter to NumberNotInAdvancedFilter via AssignProperties_To_NumberNotInAdvancedFilter & AssignProperties_From_NumberNotInAdvancedFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForNumberNotInAdvancedFilter, NumberNotInAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNumberNotInAdvancedFilter tests if a specific instance of NumberNotInAdvancedFilter can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForNumberNotInAdvancedFilter(subject NumberNotInAdvancedFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.NumberNotInAdvancedFilter
	err := copied.AssignProperties_To_NumberNotInAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NumberNotInAdvancedFilter
	err = actual.AssignProperties_From_NumberNotInAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NumberNotInAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberNotInAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberNotInAdvancedFilter, NumberNotInAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberNotInAdvancedFilter runs a test to see if a specific instance of NumberNotInAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberNotInAdvancedFilter(subject NumberNotInAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberNotInAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberNotInAdvancedFilter instances for property testing - lazily instantiated by
// NumberNotInAdvancedFilterGenerator()
var numberNotInAdvancedFilterGenerator gopter.Gen

// NumberNotInAdvancedFilterGenerator returns a generator of NumberNotInAdvancedFilter instances for property testing.
func NumberNotInAdvancedFilterGenerator() gopter.Gen {
	if numberNotInAdvancedFilterGenerator != nil {
		return numberNotInAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberNotInAdvancedFilter(generators)
	numberNotInAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(NumberNotInAdvancedFilter{}), generators)

	return numberNotInAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForNumberNotInAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberNotInAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberNotInAdvancedFilter_OperatorType_NumberNotIn)
	gens["Values"] = gen.SliceOf(gen.Float64())
}

func Test_NumberNotInAdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NumberNotInAdvancedFilter_STATUS to NumberNotInAdvancedFilter_STATUS via AssignProperties_To_NumberNotInAdvancedFilter_STATUS & AssignProperties_From_NumberNotInAdvancedFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNumberNotInAdvancedFilter_STATUS, NumberNotInAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNumberNotInAdvancedFilter_STATUS tests if a specific instance of NumberNotInAdvancedFilter_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForNumberNotInAdvancedFilter_STATUS(subject NumberNotInAdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.NumberNotInAdvancedFilter_STATUS
	err := copied.AssignProperties_To_NumberNotInAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NumberNotInAdvancedFilter_STATUS
	err = actual.AssignProperties_From_NumberNotInAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NumberNotInAdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberNotInAdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberNotInAdvancedFilter_STATUS, NumberNotInAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberNotInAdvancedFilter_STATUS runs a test to see if a specific instance of NumberNotInAdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberNotInAdvancedFilter_STATUS(subject NumberNotInAdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberNotInAdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberNotInAdvancedFilter_STATUS instances for property testing - lazily instantiated by
// NumberNotInAdvancedFilter_STATUSGenerator()
var numberNotInAdvancedFilter_STATUSGenerator gopter.Gen

// NumberNotInAdvancedFilter_STATUSGenerator returns a generator of NumberNotInAdvancedFilter_STATUS instances for property testing.
func NumberNotInAdvancedFilter_STATUSGenerator() gopter.Gen {
	if numberNotInAdvancedFilter_STATUSGenerator != nil {
		return numberNotInAdvancedFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberNotInAdvancedFilter_STATUS(generators)
	numberNotInAdvancedFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(NumberNotInAdvancedFilter_STATUS{}), generators)

	return numberNotInAdvancedFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNumberNotInAdvancedFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberNotInAdvancedFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberNotInAdvancedFilter_OperatorType_STATUS_NumberNotIn)
	gens["Values"] = gen.SliceOf(gen.Float64())
}

func Test_StringBeginsWithAdvancedFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StringBeginsWithAdvancedFilter to StringBeginsWithAdvancedFilter via AssignProperties_To_StringBeginsWithAdvancedFilter & AssignProperties_From_StringBeginsWithAdvancedFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForStringBeginsWithAdvancedFilter, StringBeginsWithAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStringBeginsWithAdvancedFilter tests if a specific instance of StringBeginsWithAdvancedFilter can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForStringBeginsWithAdvancedFilter(subject StringBeginsWithAdvancedFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.StringBeginsWithAdvancedFilter
	err := copied.AssignProperties_To_StringBeginsWithAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StringBeginsWithAdvancedFilter
	err = actual.AssignProperties_From_StringBeginsWithAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StringBeginsWithAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringBeginsWithAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringBeginsWithAdvancedFilter, StringBeginsWithAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringBeginsWithAdvancedFilter runs a test to see if a specific instance of StringBeginsWithAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForStringBeginsWithAdvancedFilter(subject StringBeginsWithAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringBeginsWithAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringBeginsWithAdvancedFilter instances for property testing - lazily instantiated by
// StringBeginsWithAdvancedFilterGenerator()
var stringBeginsWithAdvancedFilterGenerator gopter.Gen

// StringBeginsWithAdvancedFilterGenerator returns a generator of StringBeginsWithAdvancedFilter instances for property testing.
func StringBeginsWithAdvancedFilterGenerator() gopter.Gen {
	if stringBeginsWithAdvancedFilterGenerator != nil {
		return stringBeginsWithAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringBeginsWithAdvancedFilter(generators)
	stringBeginsWithAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(StringBeginsWithAdvancedFilter{}), generators)

	return stringBeginsWithAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForStringBeginsWithAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringBeginsWithAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringBeginsWithAdvancedFilter_OperatorType_StringBeginsWith)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_StringBeginsWithAdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StringBeginsWithAdvancedFilter_STATUS to StringBeginsWithAdvancedFilter_STATUS via AssignProperties_To_StringBeginsWithAdvancedFilter_STATUS & AssignProperties_From_StringBeginsWithAdvancedFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStringBeginsWithAdvancedFilter_STATUS, StringBeginsWithAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStringBeginsWithAdvancedFilter_STATUS tests if a specific instance of StringBeginsWithAdvancedFilter_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForStringBeginsWithAdvancedFilter_STATUS(subject StringBeginsWithAdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.StringBeginsWithAdvancedFilter_STATUS
	err := copied.AssignProperties_To_StringBeginsWithAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StringBeginsWithAdvancedFilter_STATUS
	err = actual.AssignProperties_From_StringBeginsWithAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StringBeginsWithAdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringBeginsWithAdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringBeginsWithAdvancedFilter_STATUS, StringBeginsWithAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringBeginsWithAdvancedFilter_STATUS runs a test to see if a specific instance of StringBeginsWithAdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStringBeginsWithAdvancedFilter_STATUS(subject StringBeginsWithAdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringBeginsWithAdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringBeginsWithAdvancedFilter_STATUS instances for property testing - lazily instantiated by
// StringBeginsWithAdvancedFilter_STATUSGenerator()
var stringBeginsWithAdvancedFilter_STATUSGenerator gopter.Gen

// StringBeginsWithAdvancedFilter_STATUSGenerator returns a generator of StringBeginsWithAdvancedFilter_STATUS instances for property testing.
func StringBeginsWithAdvancedFilter_STATUSGenerator() gopter.Gen {
	if stringBeginsWithAdvancedFilter_STATUSGenerator != nil {
		return stringBeginsWithAdvancedFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringBeginsWithAdvancedFilter_STATUS(generators)
	stringBeginsWithAdvancedFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(StringBeginsWithAdvancedFilter_STATUS{}), generators)

	return stringBeginsWithAdvancedFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStringBeginsWithAdvancedFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringBeginsWithAdvancedFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringBeginsWithAdvancedFilter_OperatorType_STATUS_StringBeginsWith)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_StringContainsAdvancedFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StringContainsAdvancedFilter to StringContainsAdvancedFilter via AssignProperties_To_StringContainsAdvancedFilter & AssignProperties_From_StringContainsAdvancedFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForStringContainsAdvancedFilter, StringContainsAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStringContainsAdvancedFilter tests if a specific instance of StringContainsAdvancedFilter can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForStringContainsAdvancedFilter(subject StringContainsAdvancedFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.StringContainsAdvancedFilter
	err := copied.AssignProperties_To_StringContainsAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StringContainsAdvancedFilter
	err = actual.AssignProperties_From_StringContainsAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StringContainsAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringContainsAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringContainsAdvancedFilter, StringContainsAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringContainsAdvancedFilter runs a test to see if a specific instance of StringContainsAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForStringContainsAdvancedFilter(subject StringContainsAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringContainsAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringContainsAdvancedFilter instances for property testing - lazily instantiated by
// StringContainsAdvancedFilterGenerator()
var stringContainsAdvancedFilterGenerator gopter.Gen

// StringContainsAdvancedFilterGenerator returns a generator of StringContainsAdvancedFilter instances for property testing.
func StringContainsAdvancedFilterGenerator() gopter.Gen {
	if stringContainsAdvancedFilterGenerator != nil {
		return stringContainsAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringContainsAdvancedFilter(generators)
	stringContainsAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(StringContainsAdvancedFilter{}), generators)

	return stringContainsAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForStringContainsAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringContainsAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringContainsAdvancedFilter_OperatorType_StringContains)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_StringContainsAdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StringContainsAdvancedFilter_STATUS to StringContainsAdvancedFilter_STATUS via AssignProperties_To_StringContainsAdvancedFilter_STATUS & AssignProperties_From_StringContainsAdvancedFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStringContainsAdvancedFilter_STATUS, StringContainsAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStringContainsAdvancedFilter_STATUS tests if a specific instance of StringContainsAdvancedFilter_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForStringContainsAdvancedFilter_STATUS(subject StringContainsAdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.StringContainsAdvancedFilter_STATUS
	err := copied.AssignProperties_To_StringContainsAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StringContainsAdvancedFilter_STATUS
	err = actual.AssignProperties_From_StringContainsAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StringContainsAdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringContainsAdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringContainsAdvancedFilter_STATUS, StringContainsAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringContainsAdvancedFilter_STATUS runs a test to see if a specific instance of StringContainsAdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStringContainsAdvancedFilter_STATUS(subject StringContainsAdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringContainsAdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringContainsAdvancedFilter_STATUS instances for property testing - lazily instantiated by
// StringContainsAdvancedFilter_STATUSGenerator()
var stringContainsAdvancedFilter_STATUSGenerator gopter.Gen

// StringContainsAdvancedFilter_STATUSGenerator returns a generator of StringContainsAdvancedFilter_STATUS instances for property testing.
func StringContainsAdvancedFilter_STATUSGenerator() gopter.Gen {
	if stringContainsAdvancedFilter_STATUSGenerator != nil {
		return stringContainsAdvancedFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringContainsAdvancedFilter_STATUS(generators)
	stringContainsAdvancedFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(StringContainsAdvancedFilter_STATUS{}), generators)

	return stringContainsAdvancedFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStringContainsAdvancedFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringContainsAdvancedFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringContainsAdvancedFilter_OperatorType_STATUS_StringContains)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_StringEndsWithAdvancedFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StringEndsWithAdvancedFilter to StringEndsWithAdvancedFilter via AssignProperties_To_StringEndsWithAdvancedFilter & AssignProperties_From_StringEndsWithAdvancedFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForStringEndsWithAdvancedFilter, StringEndsWithAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStringEndsWithAdvancedFilter tests if a specific instance of StringEndsWithAdvancedFilter can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForStringEndsWithAdvancedFilter(subject StringEndsWithAdvancedFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.StringEndsWithAdvancedFilter
	err := copied.AssignProperties_To_StringEndsWithAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StringEndsWithAdvancedFilter
	err = actual.AssignProperties_From_StringEndsWithAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StringEndsWithAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringEndsWithAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringEndsWithAdvancedFilter, StringEndsWithAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringEndsWithAdvancedFilter runs a test to see if a specific instance of StringEndsWithAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForStringEndsWithAdvancedFilter(subject StringEndsWithAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringEndsWithAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringEndsWithAdvancedFilter instances for property testing - lazily instantiated by
// StringEndsWithAdvancedFilterGenerator()
var stringEndsWithAdvancedFilterGenerator gopter.Gen

// StringEndsWithAdvancedFilterGenerator returns a generator of StringEndsWithAdvancedFilter instances for property testing.
func StringEndsWithAdvancedFilterGenerator() gopter.Gen {
	if stringEndsWithAdvancedFilterGenerator != nil {
		return stringEndsWithAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringEndsWithAdvancedFilter(generators)
	stringEndsWithAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(StringEndsWithAdvancedFilter{}), generators)

	return stringEndsWithAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForStringEndsWithAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringEndsWithAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringEndsWithAdvancedFilter_OperatorType_StringEndsWith)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_StringEndsWithAdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StringEndsWithAdvancedFilter_STATUS to StringEndsWithAdvancedFilter_STATUS via AssignProperties_To_StringEndsWithAdvancedFilter_STATUS & AssignProperties_From_StringEndsWithAdvancedFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStringEndsWithAdvancedFilter_STATUS, StringEndsWithAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStringEndsWithAdvancedFilter_STATUS tests if a specific instance of StringEndsWithAdvancedFilter_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForStringEndsWithAdvancedFilter_STATUS(subject StringEndsWithAdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.StringEndsWithAdvancedFilter_STATUS
	err := copied.AssignProperties_To_StringEndsWithAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StringEndsWithAdvancedFilter_STATUS
	err = actual.AssignProperties_From_StringEndsWithAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StringEndsWithAdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringEndsWithAdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringEndsWithAdvancedFilter_STATUS, StringEndsWithAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringEndsWithAdvancedFilter_STATUS runs a test to see if a specific instance of StringEndsWithAdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStringEndsWithAdvancedFilter_STATUS(subject StringEndsWithAdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringEndsWithAdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringEndsWithAdvancedFilter_STATUS instances for property testing - lazily instantiated by
// StringEndsWithAdvancedFilter_STATUSGenerator()
var stringEndsWithAdvancedFilter_STATUSGenerator gopter.Gen

// StringEndsWithAdvancedFilter_STATUSGenerator returns a generator of StringEndsWithAdvancedFilter_STATUS instances for property testing.
func StringEndsWithAdvancedFilter_STATUSGenerator() gopter.Gen {
	if stringEndsWithAdvancedFilter_STATUSGenerator != nil {
		return stringEndsWithAdvancedFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringEndsWithAdvancedFilter_STATUS(generators)
	stringEndsWithAdvancedFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(StringEndsWithAdvancedFilter_STATUS{}), generators)

	return stringEndsWithAdvancedFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStringEndsWithAdvancedFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringEndsWithAdvancedFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringEndsWithAdvancedFilter_OperatorType_STATUS_StringEndsWith)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_StringInAdvancedFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StringInAdvancedFilter to StringInAdvancedFilter via AssignProperties_To_StringInAdvancedFilter & AssignProperties_From_StringInAdvancedFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForStringInAdvancedFilter, StringInAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStringInAdvancedFilter tests if a specific instance of StringInAdvancedFilter can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForStringInAdvancedFilter(subject StringInAdvancedFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.StringInAdvancedFilter
	err := copied.AssignProperties_To_StringInAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StringInAdvancedFilter
	err = actual.AssignProperties_From_StringInAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StringInAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringInAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringInAdvancedFilter, StringInAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringInAdvancedFilter runs a test to see if a specific instance of StringInAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForStringInAdvancedFilter(subject StringInAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringInAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringInAdvancedFilter instances for property testing - lazily instantiated by
// StringInAdvancedFilterGenerator()
var stringInAdvancedFilterGenerator gopter.Gen

// StringInAdvancedFilterGenerator returns a generator of StringInAdvancedFilter instances for property testing.
func StringInAdvancedFilterGenerator() gopter.Gen {
	if stringInAdvancedFilterGenerator != nil {
		return stringInAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringInAdvancedFilter(generators)
	stringInAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(StringInAdvancedFilter{}), generators)

	return stringInAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForStringInAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringInAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringInAdvancedFilter_OperatorType_StringIn)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_StringInAdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StringInAdvancedFilter_STATUS to StringInAdvancedFilter_STATUS via AssignProperties_To_StringInAdvancedFilter_STATUS & AssignProperties_From_StringInAdvancedFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStringInAdvancedFilter_STATUS, StringInAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStringInAdvancedFilter_STATUS tests if a specific instance of StringInAdvancedFilter_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForStringInAdvancedFilter_STATUS(subject StringInAdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.StringInAdvancedFilter_STATUS
	err := copied.AssignProperties_To_StringInAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StringInAdvancedFilter_STATUS
	err = actual.AssignProperties_From_StringInAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StringInAdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringInAdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringInAdvancedFilter_STATUS, StringInAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringInAdvancedFilter_STATUS runs a test to see if a specific instance of StringInAdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStringInAdvancedFilter_STATUS(subject StringInAdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringInAdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringInAdvancedFilter_STATUS instances for property testing - lazily instantiated by
// StringInAdvancedFilter_STATUSGenerator()
var stringInAdvancedFilter_STATUSGenerator gopter.Gen

// StringInAdvancedFilter_STATUSGenerator returns a generator of StringInAdvancedFilter_STATUS instances for property testing.
func StringInAdvancedFilter_STATUSGenerator() gopter.Gen {
	if stringInAdvancedFilter_STATUSGenerator != nil {
		return stringInAdvancedFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringInAdvancedFilter_STATUS(generators)
	stringInAdvancedFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(StringInAdvancedFilter_STATUS{}), generators)

	return stringInAdvancedFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStringInAdvancedFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringInAdvancedFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringInAdvancedFilter_OperatorType_STATUS_StringIn)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_StringNotInAdvancedFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StringNotInAdvancedFilter to StringNotInAdvancedFilter via AssignProperties_To_StringNotInAdvancedFilter & AssignProperties_From_StringNotInAdvancedFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForStringNotInAdvancedFilter, StringNotInAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStringNotInAdvancedFilter tests if a specific instance of StringNotInAdvancedFilter can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForStringNotInAdvancedFilter(subject StringNotInAdvancedFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.StringNotInAdvancedFilter
	err := copied.AssignProperties_To_StringNotInAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StringNotInAdvancedFilter
	err = actual.AssignProperties_From_StringNotInAdvancedFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StringNotInAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringNotInAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringNotInAdvancedFilter, StringNotInAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringNotInAdvancedFilter runs a test to see if a specific instance of StringNotInAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForStringNotInAdvancedFilter(subject StringNotInAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringNotInAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringNotInAdvancedFilter instances for property testing - lazily instantiated by
// StringNotInAdvancedFilterGenerator()
var stringNotInAdvancedFilterGenerator gopter.Gen

// StringNotInAdvancedFilterGenerator returns a generator of StringNotInAdvancedFilter instances for property testing.
func StringNotInAdvancedFilterGenerator() gopter.Gen {
	if stringNotInAdvancedFilterGenerator != nil {
		return stringNotInAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringNotInAdvancedFilter(generators)
	stringNotInAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(StringNotInAdvancedFilter{}), generators)

	return stringNotInAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForStringNotInAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringNotInAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringNotInAdvancedFilter_OperatorType_StringNotIn)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_StringNotInAdvancedFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from StringNotInAdvancedFilter_STATUS to StringNotInAdvancedFilter_STATUS via AssignProperties_To_StringNotInAdvancedFilter_STATUS & AssignProperties_From_StringNotInAdvancedFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForStringNotInAdvancedFilter_STATUS, StringNotInAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForStringNotInAdvancedFilter_STATUS tests if a specific instance of StringNotInAdvancedFilter_STATUS can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForStringNotInAdvancedFilter_STATUS(subject StringNotInAdvancedFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other alpha20200601s.StringNotInAdvancedFilter_STATUS
	err := copied.AssignProperties_To_StringNotInAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual StringNotInAdvancedFilter_STATUS
	err = actual.AssignProperties_From_StringNotInAdvancedFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_StringNotInAdvancedFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringNotInAdvancedFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringNotInAdvancedFilter_STATUS, StringNotInAdvancedFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringNotInAdvancedFilter_STATUS runs a test to see if a specific instance of StringNotInAdvancedFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStringNotInAdvancedFilter_STATUS(subject StringNotInAdvancedFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringNotInAdvancedFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringNotInAdvancedFilter_STATUS instances for property testing - lazily instantiated by
// StringNotInAdvancedFilter_STATUSGenerator()
var stringNotInAdvancedFilter_STATUSGenerator gopter.Gen

// StringNotInAdvancedFilter_STATUSGenerator returns a generator of StringNotInAdvancedFilter_STATUS instances for property testing.
func StringNotInAdvancedFilter_STATUSGenerator() gopter.Gen {
	if stringNotInAdvancedFilter_STATUSGenerator != nil {
		return stringNotInAdvancedFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringNotInAdvancedFilter_STATUS(generators)
	stringNotInAdvancedFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(StringNotInAdvancedFilter_STATUS{}), generators)

	return stringNotInAdvancedFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStringNotInAdvancedFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringNotInAdvancedFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringNotInAdvancedFilter_OperatorType_STATUS_StringNotIn)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}
