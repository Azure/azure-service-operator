// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20200601

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/eventgrid/v1alpha1api20200601storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_EventSubscription_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscription to hub returns original",
		prop.ForAll(RunResourceConversionTestForEventSubscription, EventSubscriptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForEventSubscription tests if a specific instance of EventSubscription round trips to the hub storage version and back losslessly
func RunResourceConversionTestForEventSubscription(subject EventSubscription) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20200601storage.EventSubscription
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual EventSubscription
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscription_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscription to EventSubscription via AssignPropertiesToEventSubscription & AssignPropertiesFromEventSubscription returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscription, EventSubscriptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscription tests if a specific instance of EventSubscription can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscription(subject EventSubscription) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.EventSubscription
	err := copied.AssignPropertiesToEventSubscription(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscription
	err = actual.AssignPropertiesFromEventSubscription(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscription_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscription, EventSubscriptionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscription runs a test to see if a specific instance of EventSubscription round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscription(subject EventSubscription) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription instances for property testing - lazily instantiated by EventSubscriptionGenerator()
var eventSubscriptionGenerator gopter.Gen

// EventSubscriptionGenerator returns a generator of EventSubscription instances for property testing.
func EventSubscriptionGenerator() gopter.Gen {
	if eventSubscriptionGenerator != nil {
		return eventSubscriptionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEventSubscription(generators)
	eventSubscriptionGenerator = gen.Struct(reflect.TypeOf(EventSubscription{}), generators)

	return eventSubscriptionGenerator
}

// AddRelatedPropertyGeneratorsForEventSubscription is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscription(gens map[string]gopter.Gen) {
	gens["Spec"] = EventSubscriptions_SPECGenerator()
	gens["Status"] = EventSubscription_StatusGenerator()
}

func Test_EventSubscription_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscription_Status to EventSubscription_Status via AssignPropertiesToEventSubscription_Status & AssignPropertiesFromEventSubscription_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscription_Status, EventSubscription_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscription_Status tests if a specific instance of EventSubscription_Status can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscription_Status(subject EventSubscription_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.EventSubscription_Status
	err := copied.AssignPropertiesToEventSubscription_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscription_Status
	err = actual.AssignPropertiesFromEventSubscription_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscription_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscription_Status, EventSubscription_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscription_Status runs a test to see if a specific instance of EventSubscription_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscription_Status(subject EventSubscription_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription_Status instances for property testing - lazily instantiated by
//EventSubscription_StatusGenerator()
var eventSubscription_statusGenerator gopter.Gen

// EventSubscription_StatusGenerator returns a generator of EventSubscription_Status instances for property testing.
// We first initialize eventSubscription_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscription_StatusGenerator() gopter.Gen {
	if eventSubscription_statusGenerator != nil {
		return eventSubscription_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_Status(generators)
	eventSubscription_statusGenerator = gen.Struct(reflect.TypeOf(EventSubscription_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_Status(generators)
	AddRelatedPropertyGeneratorsForEventSubscription_Status(generators)
	eventSubscription_statusGenerator = gen.Struct(reflect.TypeOf(EventSubscription_Status{}), generators)

	return eventSubscription_statusGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscription_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscription_Status(gens map[string]gopter.Gen) {
	gens["EventDeliverySchema"] = gen.PtrOf(gen.OneConstOf(EventSubscriptionProperties_EventDeliverySchema_StatusCloudEventSchemaV1_0, EventSubscriptionProperties_EventDeliverySchema_StatusCustomInputSchema, EventSubscriptionProperties_EventDeliverySchema_StatusEventGridSchema))
	gens["ExpirationTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Labels"] = gen.SliceOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		EventSubscriptionProperties_ProvisioningState_StatusAwaitingManualAction,
		EventSubscriptionProperties_ProvisioningState_StatusCanceled,
		EventSubscriptionProperties_ProvisioningState_StatusCreating,
		EventSubscriptionProperties_ProvisioningState_StatusDeleting,
		EventSubscriptionProperties_ProvisioningState_StatusFailed,
		EventSubscriptionProperties_ProvisioningState_StatusSucceeded,
		EventSubscriptionProperties_ProvisioningState_StatusUpdating))
	gens["Topic"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscription_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscription_Status(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(DeadLetterDestination_StatusGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestination_StatusGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilter_StatusGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicy_StatusGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_StatusGenerator())
}

func Test_EventSubscriptions_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptions_SPEC to EventSubscriptions_SPEC via AssignPropertiesToEventSubscriptions_SPEC & AssignPropertiesFromEventSubscriptions_SPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptions_SPEC, EventSubscriptions_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptions_SPEC tests if a specific instance of EventSubscriptions_SPEC can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptions_SPEC(subject EventSubscriptions_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.EventSubscriptions_SPEC
	err := copied.AssignPropertiesToEventSubscriptions_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptions_SPEC
	err = actual.AssignPropertiesFromEventSubscriptions_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptions_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptions_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptions_SPEC, EventSubscriptions_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptions_SPEC runs a test to see if a specific instance of EventSubscriptions_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptions_SPEC(subject EventSubscriptions_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptions_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptions_SPEC instances for property testing - lazily instantiated by
//EventSubscriptions_SPECGenerator()
var eventSubscriptions_specGenerator gopter.Gen

// EventSubscriptions_SPECGenerator returns a generator of EventSubscriptions_SPEC instances for property testing.
// We first initialize eventSubscriptions_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptions_SPECGenerator() gopter.Gen {
	if eventSubscriptions_specGenerator != nil {
		return eventSubscriptions_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptions_SPEC(generators)
	eventSubscriptions_specGenerator = gen.Struct(reflect.TypeOf(EventSubscriptions_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptions_SPEC(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptions_SPEC(generators)
	eventSubscriptions_specGenerator = gen.Struct(reflect.TypeOf(EventSubscriptions_SPEC{}), generators)

	return eventSubscriptions_specGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptions_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptions_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["EventDeliverySchema"] = gen.PtrOf(gen.OneConstOf(EventSubscriptionProperties_EventDeliverySchema_SpecCloudEventSchemaV1_0, EventSubscriptionProperties_EventDeliverySchema_SpecCustomInputSchema, EventSubscriptionProperties_EventDeliverySchema_SpecEventGridSchema))
	gens["ExpirationTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Labels"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptions_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptions_SPEC(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(DeadLetterDestination_SpecGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestination_SpecGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilter_SpecGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicy_SpecGenerator())
}

func Test_DeadLetterDestination_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeadLetterDestination_Spec to DeadLetterDestination_Spec via AssignPropertiesToDeadLetterDestination_Spec & AssignPropertiesFromDeadLetterDestination_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeadLetterDestination_Spec, DeadLetterDestination_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeadLetterDestination_Spec tests if a specific instance of DeadLetterDestination_Spec can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForDeadLetterDestination_Spec(subject DeadLetterDestination_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.DeadLetterDestination_Spec
	err := copied.AssignPropertiesToDeadLetterDestination_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeadLetterDestination_Spec
	err = actual.AssignPropertiesFromDeadLetterDestination_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeadLetterDestination_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeadLetterDestination_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeadLetterDestination_Spec, DeadLetterDestination_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeadLetterDestination_Spec runs a test to see if a specific instance of DeadLetterDestination_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDeadLetterDestination_Spec(subject DeadLetterDestination_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeadLetterDestination_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeadLetterDestination_Spec instances for property testing - lazily instantiated by
//DeadLetterDestination_SpecGenerator()
var deadLetterDestination_specGenerator gopter.Gen

// DeadLetterDestination_SpecGenerator returns a generator of DeadLetterDestination_Spec instances for property testing.
func DeadLetterDestination_SpecGenerator() gopter.Gen {
	if deadLetterDestination_specGenerator != nil {
		return deadLetterDestination_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeadLetterDestination_Spec(generators)
	deadLetterDestination_specGenerator = gen.Struct(reflect.TypeOf(DeadLetterDestination_Spec{}), generators)

	return deadLetterDestination_specGenerator
}

// AddIndependentPropertyGeneratorsForDeadLetterDestination_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeadLetterDestination_Spec(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(DeadLetterDestination_EndpointType_SpecStorageBlob)
}

func Test_DeadLetterDestination_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeadLetterDestination_Status to DeadLetterDestination_Status via AssignPropertiesToDeadLetterDestination_Status & AssignPropertiesFromDeadLetterDestination_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeadLetterDestination_Status, DeadLetterDestination_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeadLetterDestination_Status tests if a specific instance of DeadLetterDestination_Status can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForDeadLetterDestination_Status(subject DeadLetterDestination_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.DeadLetterDestination_Status
	err := copied.AssignPropertiesToDeadLetterDestination_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeadLetterDestination_Status
	err = actual.AssignPropertiesFromDeadLetterDestination_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeadLetterDestination_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeadLetterDestination_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeadLetterDestination_Status, DeadLetterDestination_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeadLetterDestination_Status runs a test to see if a specific instance of DeadLetterDestination_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDeadLetterDestination_Status(subject DeadLetterDestination_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeadLetterDestination_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeadLetterDestination_Status instances for property testing - lazily instantiated by
//DeadLetterDestination_StatusGenerator()
var deadLetterDestination_statusGenerator gopter.Gen

// DeadLetterDestination_StatusGenerator returns a generator of DeadLetterDestination_Status instances for property testing.
func DeadLetterDestination_StatusGenerator() gopter.Gen {
	if deadLetterDestination_statusGenerator != nil {
		return deadLetterDestination_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeadLetterDestination_Status(generators)
	deadLetterDestination_statusGenerator = gen.Struct(reflect.TypeOf(DeadLetterDestination_Status{}), generators)

	return deadLetterDestination_statusGenerator
}

// AddIndependentPropertyGeneratorsForDeadLetterDestination_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeadLetterDestination_Status(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(DeadLetterDestination_EndpointType_StatusStorageBlob)
}

func Test_EventSubscriptionDestination_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptionDestination_Spec to EventSubscriptionDestination_Spec via AssignPropertiesToEventSubscriptionDestination_Spec & AssignPropertiesFromEventSubscriptionDestination_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionDestination_Spec, EventSubscriptionDestination_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionDestination_Spec tests if a specific instance of EventSubscriptionDestination_Spec can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionDestination_Spec(subject EventSubscriptionDestination_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.EventSubscriptionDestination_Spec
	err := copied.AssignPropertiesToEventSubscriptionDestination_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionDestination_Spec
	err = actual.AssignPropertiesFromEventSubscriptionDestination_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionDestination_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionDestination_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestination_Spec, EventSubscriptionDestination_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestination_Spec runs a test to see if a specific instance of EventSubscriptionDestination_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestination_Spec(subject EventSubscriptionDestination_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionDestination_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionDestination_Spec instances for property testing - lazily instantiated by
//EventSubscriptionDestination_SpecGenerator()
var eventSubscriptionDestination_specGenerator gopter.Gen

// EventSubscriptionDestination_SpecGenerator returns a generator of EventSubscriptionDestination_Spec instances for property testing.
func EventSubscriptionDestination_SpecGenerator() gopter.Gen {
	if eventSubscriptionDestination_specGenerator != nil {
		return eventSubscriptionDestination_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionDestination_Spec(generators)
	eventSubscriptionDestination_specGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionDestination_Spec{}), generators)

	return eventSubscriptionDestination_specGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionDestination_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionDestination_Spec(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(
		EventSubscriptionDestination_EndpointType_SpecAzureFunction,
		EventSubscriptionDestination_EndpointType_SpecEventHub,
		EventSubscriptionDestination_EndpointType_SpecHybridConnection,
		EventSubscriptionDestination_EndpointType_SpecServiceBusQueue,
		EventSubscriptionDestination_EndpointType_SpecServiceBusTopic,
		EventSubscriptionDestination_EndpointType_SpecStorageQueue,
		EventSubscriptionDestination_EndpointType_SpecWebHook)
}

func Test_EventSubscriptionDestination_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptionDestination_Status to EventSubscriptionDestination_Status via AssignPropertiesToEventSubscriptionDestination_Status & AssignPropertiesFromEventSubscriptionDestination_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionDestination_Status, EventSubscriptionDestination_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionDestination_Status tests if a specific instance of EventSubscriptionDestination_Status can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionDestination_Status(subject EventSubscriptionDestination_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.EventSubscriptionDestination_Status
	err := copied.AssignPropertiesToEventSubscriptionDestination_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionDestination_Status
	err = actual.AssignPropertiesFromEventSubscriptionDestination_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionDestination_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionDestination_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestination_Status, EventSubscriptionDestination_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestination_Status runs a test to see if a specific instance of EventSubscriptionDestination_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestination_Status(subject EventSubscriptionDestination_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionDestination_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionDestination_Status instances for property testing - lazily instantiated by
//EventSubscriptionDestination_StatusGenerator()
var eventSubscriptionDestination_statusGenerator gopter.Gen

// EventSubscriptionDestination_StatusGenerator returns a generator of EventSubscriptionDestination_Status instances for property testing.
func EventSubscriptionDestination_StatusGenerator() gopter.Gen {
	if eventSubscriptionDestination_statusGenerator != nil {
		return eventSubscriptionDestination_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionDestination_Status(generators)
	eventSubscriptionDestination_statusGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionDestination_Status{}), generators)

	return eventSubscriptionDestination_statusGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionDestination_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionDestination_Status(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(
		EventSubscriptionDestination_EndpointType_StatusAzureFunction,
		EventSubscriptionDestination_EndpointType_StatusEventHub,
		EventSubscriptionDestination_EndpointType_StatusHybridConnection,
		EventSubscriptionDestination_EndpointType_StatusServiceBusQueue,
		EventSubscriptionDestination_EndpointType_StatusServiceBusTopic,
		EventSubscriptionDestination_EndpointType_StatusStorageQueue,
		EventSubscriptionDestination_EndpointType_StatusWebHook)
}

func Test_EventSubscriptionFilter_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptionFilter_Spec to EventSubscriptionFilter_Spec via AssignPropertiesToEventSubscriptionFilter_Spec & AssignPropertiesFromEventSubscriptionFilter_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionFilter_Spec, EventSubscriptionFilter_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionFilter_Spec tests if a specific instance of EventSubscriptionFilter_Spec can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionFilter_Spec(subject EventSubscriptionFilter_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.EventSubscriptionFilter_Spec
	err := copied.AssignPropertiesToEventSubscriptionFilter_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionFilter_Spec
	err = actual.AssignPropertiesFromEventSubscriptionFilter_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionFilter_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionFilter_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilter_Spec, EventSubscriptionFilter_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilter_Spec runs a test to see if a specific instance of EventSubscriptionFilter_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilter_Spec(subject EventSubscriptionFilter_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionFilter_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionFilter_Spec instances for property testing - lazily instantiated by
//EventSubscriptionFilter_SpecGenerator()
var eventSubscriptionFilter_specGenerator gopter.Gen

// EventSubscriptionFilter_SpecGenerator returns a generator of EventSubscriptionFilter_Spec instances for property testing.
// We first initialize eventSubscriptionFilter_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilter_SpecGenerator() gopter.Gen {
	if eventSubscriptionFilter_specGenerator != nil {
		return eventSubscriptionFilter_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilter_Spec(generators)
	eventSubscriptionFilter_specGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilter_Spec(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilter_Spec(generators)
	eventSubscriptionFilter_specGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_Spec{}), generators)

	return eventSubscriptionFilter_specGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilter_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilter_Spec(gens map[string]gopter.Gen) {
	gens["IncludedEventTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IsSubjectCaseSensitive"] = gen.PtrOf(gen.Bool())
	gens["SubjectBeginsWith"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectEndsWith"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionFilter_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilter_Spec(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilter_SpecGenerator())
}

func Test_EventSubscriptionFilter_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EventSubscriptionFilter_Status to EventSubscriptionFilter_Status via AssignPropertiesToEventSubscriptionFilter_Status & AssignPropertiesFromEventSubscriptionFilter_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForEventSubscriptionFilter_Status, EventSubscriptionFilter_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEventSubscriptionFilter_Status tests if a specific instance of EventSubscriptionFilter_Status can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForEventSubscriptionFilter_Status(subject EventSubscriptionFilter_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.EventSubscriptionFilter_Status
	err := copied.AssignPropertiesToEventSubscriptionFilter_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EventSubscriptionFilter_Status
	err = actual.AssignPropertiesFromEventSubscriptionFilter_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EventSubscriptionFilter_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionFilter_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilter_Status, EventSubscriptionFilter_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilter_Status runs a test to see if a specific instance of EventSubscriptionFilter_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilter_Status(subject EventSubscriptionFilter_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionFilter_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionFilter_Status instances for property testing - lazily instantiated by
//EventSubscriptionFilter_StatusGenerator()
var eventSubscriptionFilter_statusGenerator gopter.Gen

// EventSubscriptionFilter_StatusGenerator returns a generator of EventSubscriptionFilter_Status instances for property testing.
// We first initialize eventSubscriptionFilter_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilter_StatusGenerator() gopter.Gen {
	if eventSubscriptionFilter_statusGenerator != nil {
		return eventSubscriptionFilter_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilter_Status(generators)
	eventSubscriptionFilter_statusGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilter_Status(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilter_Status(generators)
	eventSubscriptionFilter_statusGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter_Status{}), generators)

	return eventSubscriptionFilter_statusGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilter_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilter_Status(gens map[string]gopter.Gen) {
	gens["IncludedEventTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IsSubjectCaseSensitive"] = gen.PtrOf(gen.Bool())
	gens["SubjectBeginsWith"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectEndsWith"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionFilter_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilter_Status(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilter_StatusGenerator())
}

func Test_RetryPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RetryPolicy_Spec to RetryPolicy_Spec via AssignPropertiesToRetryPolicy_Spec & AssignPropertiesFromRetryPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForRetryPolicy_Spec, RetryPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRetryPolicy_Spec tests if a specific instance of RetryPolicy_Spec can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForRetryPolicy_Spec(subject RetryPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.RetryPolicy_Spec
	err := copied.AssignPropertiesToRetryPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RetryPolicy_Spec
	err = actual.AssignPropertiesFromRetryPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RetryPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicy_Spec, RetryPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicy_Spec runs a test to see if a specific instance of RetryPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicy_Spec(subject RetryPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicy_Spec instances for property testing - lazily instantiated by RetryPolicy_SpecGenerator()
var retryPolicy_specGenerator gopter.Gen

// RetryPolicy_SpecGenerator returns a generator of RetryPolicy_Spec instances for property testing.
func RetryPolicy_SpecGenerator() gopter.Gen {
	if retryPolicy_specGenerator != nil {
		return retryPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicy_Spec(generators)
	retryPolicy_specGenerator = gen.Struct(reflect.TypeOf(RetryPolicy_Spec{}), generators)

	return retryPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicy_Spec(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_RetryPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RetryPolicy_Status to RetryPolicy_Status via AssignPropertiesToRetryPolicy_Status & AssignPropertiesFromRetryPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForRetryPolicy_Status, RetryPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRetryPolicy_Status tests if a specific instance of RetryPolicy_Status can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForRetryPolicy_Status(subject RetryPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.RetryPolicy_Status
	err := copied.AssignPropertiesToRetryPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RetryPolicy_Status
	err = actual.AssignPropertiesFromRetryPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RetryPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicy_Status, RetryPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicy_Status runs a test to see if a specific instance of RetryPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicy_Status(subject RetryPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicy_Status instances for property testing - lazily instantiated by RetryPolicy_StatusGenerator()
var retryPolicy_statusGenerator gopter.Gen

// RetryPolicy_StatusGenerator returns a generator of RetryPolicy_Status instances for property testing.
func RetryPolicy_StatusGenerator() gopter.Gen {
	if retryPolicy_statusGenerator != nil {
		return retryPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicy_Status(generators)
	retryPolicy_statusGenerator = gen.Struct(reflect.TypeOf(RetryPolicy_Status{}), generators)

	return retryPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicy_Status(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_AdvancedFilter_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdvancedFilter_Spec to AdvancedFilter_Spec via AssignPropertiesToAdvancedFilter_Spec & AssignPropertiesFromAdvancedFilter_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdvancedFilter_Spec, AdvancedFilter_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdvancedFilter_Spec tests if a specific instance of AdvancedFilter_Spec can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForAdvancedFilter_Spec(subject AdvancedFilter_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.AdvancedFilter_Spec
	err := copied.AssignPropertiesToAdvancedFilter_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdvancedFilter_Spec
	err = actual.AssignPropertiesFromAdvancedFilter_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdvancedFilter_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_Spec, AdvancedFilter_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_Spec runs a test to see if a specific instance of AdvancedFilter_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_Spec(subject AdvancedFilter_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_Spec instances for property testing - lazily instantiated by
//AdvancedFilter_SpecGenerator()
var advancedFilter_specGenerator gopter.Gen

// AdvancedFilter_SpecGenerator returns a generator of AdvancedFilter_Spec instances for property testing.
func AdvancedFilter_SpecGenerator() gopter.Gen {
	if advancedFilter_specGenerator != nil {
		return advancedFilter_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_Spec(generators)
	advancedFilter_specGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_Spec{}), generators)

	return advancedFilter_specGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_Spec(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(
		AdvancedFilter_OperatorType_SpecBoolEquals,
		AdvancedFilter_OperatorType_SpecNumberGreaterThan,
		AdvancedFilter_OperatorType_SpecNumberGreaterThanOrEquals,
		AdvancedFilter_OperatorType_SpecNumberIn,
		AdvancedFilter_OperatorType_SpecNumberLessThan,
		AdvancedFilter_OperatorType_SpecNumberLessThanOrEquals,
		AdvancedFilter_OperatorType_SpecNumberNotIn,
		AdvancedFilter_OperatorType_SpecStringBeginsWith,
		AdvancedFilter_OperatorType_SpecStringContains,
		AdvancedFilter_OperatorType_SpecStringEndsWith,
		AdvancedFilter_OperatorType_SpecStringIn,
		AdvancedFilter_OperatorType_SpecStringNotIn)
}

func Test_AdvancedFilter_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AdvancedFilter_Status to AdvancedFilter_Status via AssignPropertiesToAdvancedFilter_Status & AssignPropertiesFromAdvancedFilter_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAdvancedFilter_Status, AdvancedFilter_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAdvancedFilter_Status tests if a specific instance of AdvancedFilter_Status can be assigned to v1alpha1api20200601storage and back losslessly
func RunPropertyAssignmentTestForAdvancedFilter_Status(subject AdvancedFilter_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20200601storage.AdvancedFilter_Status
	err := copied.AssignPropertiesToAdvancedFilter_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AdvancedFilter_Status
	err = actual.AssignPropertiesFromAdvancedFilter_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AdvancedFilter_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter_Status, AdvancedFilter_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter_Status runs a test to see if a specific instance of AdvancedFilter_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter_Status(subject AdvancedFilter_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter_Status instances for property testing - lazily instantiated by
//AdvancedFilter_StatusGenerator()
var advancedFilter_statusGenerator gopter.Gen

// AdvancedFilter_StatusGenerator returns a generator of AdvancedFilter_Status instances for property testing.
func AdvancedFilter_StatusGenerator() gopter.Gen {
	if advancedFilter_statusGenerator != nil {
		return advancedFilter_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdvancedFilter_Status(generators)
	advancedFilter_statusGenerator = gen.Struct(reflect.TypeOf(AdvancedFilter_Status{}), generators)

	return advancedFilter_statusGenerator
}

// AddIndependentPropertyGeneratorsForAdvancedFilter_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdvancedFilter_Status(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(
		AdvancedFilter_OperatorType_StatusBoolEquals,
		AdvancedFilter_OperatorType_StatusNumberGreaterThan,
		AdvancedFilter_OperatorType_StatusNumberGreaterThanOrEquals,
		AdvancedFilter_OperatorType_StatusNumberIn,
		AdvancedFilter_OperatorType_StatusNumberLessThan,
		AdvancedFilter_OperatorType_StatusNumberLessThanOrEquals,
		AdvancedFilter_OperatorType_StatusNumberNotIn,
		AdvancedFilter_OperatorType_StatusStringBeginsWith,
		AdvancedFilter_OperatorType_StatusStringContains,
		AdvancedFilter_OperatorType_StatusStringEndsWith,
		AdvancedFilter_OperatorType_StatusStringIn,
		AdvancedFilter_OperatorType_StatusStringNotIn)
}
