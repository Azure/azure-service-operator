// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdvancedFilter, AdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdvancedFilter runs a test to see if a specific instance of AdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForAdvancedFilter(subject AdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdvancedFilter instances for property testing - lazily instantiated by AdvancedFilterGenerator()
var advancedFilterGenerator gopter.Gen

// AdvancedFilterGenerator returns a generator of AdvancedFilter instances for property testing.
func AdvancedFilterGenerator() gopter.Gen {
	if advancedFilterGenerator != nil {
		return advancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForAdvancedFilter(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(AdvancedFilter{}), map[string]gopter.Gen{propName: propGen}))
	}
	advancedFilterGenerator = gen.OneGenOf(gens...)

	return advancedFilterGenerator
}

// AddRelatedPropertyGeneratorsForAdvancedFilter is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAdvancedFilter(gens map[string]gopter.Gen) {
	gens["BoolEquals"] = BoolEqualsAdvancedFilterGenerator().Map(func(it BoolEqualsAdvancedFilter) *BoolEqualsAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["NumberGreaterThan"] = NumberGreaterThanAdvancedFilterGenerator().Map(func(it NumberGreaterThanAdvancedFilter) *NumberGreaterThanAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["NumberGreaterThanOrEquals"] = NumberGreaterThanOrEqualsAdvancedFilterGenerator().Map(func(it NumberGreaterThanOrEqualsAdvancedFilter) *NumberGreaterThanOrEqualsAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["NumberIn"] = NumberInAdvancedFilterGenerator().Map(func(it NumberInAdvancedFilter) *NumberInAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["NumberLessThan"] = NumberLessThanAdvancedFilterGenerator().Map(func(it NumberLessThanAdvancedFilter) *NumberLessThanAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["NumberLessThanOrEquals"] = NumberLessThanOrEqualsAdvancedFilterGenerator().Map(func(it NumberLessThanOrEqualsAdvancedFilter) *NumberLessThanOrEqualsAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["NumberNotIn"] = NumberNotInAdvancedFilterGenerator().Map(func(it NumberNotInAdvancedFilter) *NumberNotInAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["StringBeginsWith"] = StringBeginsWithAdvancedFilterGenerator().Map(func(it StringBeginsWithAdvancedFilter) *StringBeginsWithAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["StringContains"] = StringContainsAdvancedFilterGenerator().Map(func(it StringContainsAdvancedFilter) *StringContainsAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["StringEndsWith"] = StringEndsWithAdvancedFilterGenerator().Map(func(it StringEndsWithAdvancedFilter) *StringEndsWithAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["StringIn"] = StringInAdvancedFilterGenerator().Map(func(it StringInAdvancedFilter) *StringInAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
	gens["StringNotIn"] = StringNotInAdvancedFilterGenerator().Map(func(it StringNotInAdvancedFilter) *StringNotInAdvancedFilter {
		return &it
	}) // generate one case for OneOf type
}

func Test_AzureFunctionEventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFunctionEventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFunctionEventSubscriptionDestination, AzureFunctionEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFunctionEventSubscriptionDestination runs a test to see if a specific instance of AzureFunctionEventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFunctionEventSubscriptionDestination(subject AzureFunctionEventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFunctionEventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFunctionEventSubscriptionDestination instances for property testing - lazily instantiated by
// AzureFunctionEventSubscriptionDestinationGenerator()
var azureFunctionEventSubscriptionDestinationGenerator gopter.Gen

// AzureFunctionEventSubscriptionDestinationGenerator returns a generator of AzureFunctionEventSubscriptionDestination instances for property testing.
// We first initialize azureFunctionEventSubscriptionDestinationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFunctionEventSubscriptionDestinationGenerator() gopter.Gen {
	if azureFunctionEventSubscriptionDestinationGenerator != nil {
		return azureFunctionEventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestination(generators)
	azureFunctionEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(AzureFunctionEventSubscriptionDestination{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestination(generators)
	AddRelatedPropertyGeneratorsForAzureFunctionEventSubscriptionDestination(generators)
	azureFunctionEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(AzureFunctionEventSubscriptionDestination{}), generators)

	return azureFunctionEventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(AzureFunctionEventSubscriptionDestination_EndpointType_AzureFunction)
}

// AddRelatedPropertyGeneratorsForAzureFunctionEventSubscriptionDestination is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFunctionEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(AzureFunctionEventSubscriptionDestinationPropertiesGenerator())
}

func Test_AzureFunctionEventSubscriptionDestinationProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFunctionEventSubscriptionDestinationProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationProperties, AzureFunctionEventSubscriptionDestinationPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationProperties runs a test to see if a specific instance of AzureFunctionEventSubscriptionDestinationProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFunctionEventSubscriptionDestinationProperties(subject AzureFunctionEventSubscriptionDestinationProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFunctionEventSubscriptionDestinationProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFunctionEventSubscriptionDestinationProperties instances for property testing - lazily instantiated
// by AzureFunctionEventSubscriptionDestinationPropertiesGenerator()
var azureFunctionEventSubscriptionDestinationPropertiesGenerator gopter.Gen

// AzureFunctionEventSubscriptionDestinationPropertiesGenerator returns a generator of AzureFunctionEventSubscriptionDestinationProperties instances for property testing.
func AzureFunctionEventSubscriptionDestinationPropertiesGenerator() gopter.Gen {
	if azureFunctionEventSubscriptionDestinationPropertiesGenerator != nil {
		return azureFunctionEventSubscriptionDestinationPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationProperties(generators)
	azureFunctionEventSubscriptionDestinationPropertiesGenerator = gen.Struct(reflect.TypeOf(AzureFunctionEventSubscriptionDestinationProperties{}), generators)

	return azureFunctionEventSubscriptionDestinationPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFunctionEventSubscriptionDestinationProperties(gens map[string]gopter.Gen) {
	gens["MaxEventsPerBatch"] = gen.PtrOf(gen.Int())
	gens["PreferredBatchSizeInKilobytes"] = gen.PtrOf(gen.Int())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_BoolEqualsAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BoolEqualsAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBoolEqualsAdvancedFilter, BoolEqualsAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBoolEqualsAdvancedFilter runs a test to see if a specific instance of BoolEqualsAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForBoolEqualsAdvancedFilter(subject BoolEqualsAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BoolEqualsAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BoolEqualsAdvancedFilter instances for property testing - lazily instantiated by
// BoolEqualsAdvancedFilterGenerator()
var boolEqualsAdvancedFilterGenerator gopter.Gen

// BoolEqualsAdvancedFilterGenerator returns a generator of BoolEqualsAdvancedFilter instances for property testing.
func BoolEqualsAdvancedFilterGenerator() gopter.Gen {
	if boolEqualsAdvancedFilterGenerator != nil {
		return boolEqualsAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBoolEqualsAdvancedFilter(generators)
	boolEqualsAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(BoolEqualsAdvancedFilter{}), generators)

	return boolEqualsAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForBoolEqualsAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBoolEqualsAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(BoolEqualsAdvancedFilter_OperatorType_BoolEquals)
	gens["Value"] = gen.PtrOf(gen.Bool())
}

func Test_DeadLetterDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeadLetterDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeadLetterDestination, DeadLetterDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeadLetterDestination runs a test to see if a specific instance of DeadLetterDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForDeadLetterDestination(subject DeadLetterDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeadLetterDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeadLetterDestination instances for property testing - lazily instantiated by
// DeadLetterDestinationGenerator()
var deadLetterDestinationGenerator gopter.Gen

// DeadLetterDestinationGenerator returns a generator of DeadLetterDestination instances for property testing.
func DeadLetterDestinationGenerator() gopter.Gen {
	if deadLetterDestinationGenerator != nil {
		return deadLetterDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeadLetterDestination(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeadLetterDestination{}), map[string]gopter.Gen{propName: propGen}))
	}
	deadLetterDestinationGenerator = gen.OneGenOf(gens...)

	return deadLetterDestinationGenerator
}

// AddRelatedPropertyGeneratorsForDeadLetterDestination is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeadLetterDestination(gens map[string]gopter.Gen) {
	gens["StorageBlob"] = StorageBlobDeadLetterDestinationGenerator().Map(func(it StorageBlobDeadLetterDestination) *StorageBlobDeadLetterDestination {
		return &it
	}) // generate one case for OneOf type
}

func Test_EventHubEventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubEventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubEventSubscriptionDestination, EventHubEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubEventSubscriptionDestination runs a test to see if a specific instance of EventHubEventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubEventSubscriptionDestination(subject EventHubEventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubEventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubEventSubscriptionDestination instances for property testing - lazily instantiated by
// EventHubEventSubscriptionDestinationGenerator()
var eventHubEventSubscriptionDestinationGenerator gopter.Gen

// EventHubEventSubscriptionDestinationGenerator returns a generator of EventHubEventSubscriptionDestination instances for property testing.
// We first initialize eventHubEventSubscriptionDestinationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventHubEventSubscriptionDestinationGenerator() gopter.Gen {
	if eventHubEventSubscriptionDestinationGenerator != nil {
		return eventHubEventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestination(generators)
	eventHubEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(EventHubEventSubscriptionDestination{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestination(generators)
	AddRelatedPropertyGeneratorsForEventHubEventSubscriptionDestination(generators)
	eventHubEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(EventHubEventSubscriptionDestination{}), generators)

	return eventHubEventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(EventHubEventSubscriptionDestination_EndpointType_EventHub)
}

// AddRelatedPropertyGeneratorsForEventHubEventSubscriptionDestination is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventHubEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(EventHubEventSubscriptionDestinationPropertiesGenerator())
}

func Test_EventHubEventSubscriptionDestinationProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventHubEventSubscriptionDestinationProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventHubEventSubscriptionDestinationProperties, EventHubEventSubscriptionDestinationPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventHubEventSubscriptionDestinationProperties runs a test to see if a specific instance of EventHubEventSubscriptionDestinationProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEventHubEventSubscriptionDestinationProperties(subject EventHubEventSubscriptionDestinationProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventHubEventSubscriptionDestinationProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventHubEventSubscriptionDestinationProperties instances for property testing - lazily instantiated by
// EventHubEventSubscriptionDestinationPropertiesGenerator()
var eventHubEventSubscriptionDestinationPropertiesGenerator gopter.Gen

// EventHubEventSubscriptionDestinationPropertiesGenerator returns a generator of EventHubEventSubscriptionDestinationProperties instances for property testing.
func EventHubEventSubscriptionDestinationPropertiesGenerator() gopter.Gen {
	if eventHubEventSubscriptionDestinationPropertiesGenerator != nil {
		return eventHubEventSubscriptionDestinationPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationProperties(generators)
	eventHubEventSubscriptionDestinationPropertiesGenerator = gen.Struct(reflect.TypeOf(EventHubEventSubscriptionDestinationProperties{}), generators)

	return eventHubEventSubscriptionDestinationPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventHubEventSubscriptionDestinationProperties(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_EventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionDestination, EventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionDestination runs a test to see if a specific instance of EventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionDestination(subject EventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionDestination instances for property testing - lazily instantiated by
// EventSubscriptionDestinationGenerator()
var eventSubscriptionDestinationGenerator gopter.Gen

// EventSubscriptionDestinationGenerator returns a generator of EventSubscriptionDestination instances for property testing.
func EventSubscriptionDestinationGenerator() gopter.Gen {
	if eventSubscriptionDestinationGenerator != nil {
		return eventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEventSubscriptionDestination(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(EventSubscriptionDestination{}), map[string]gopter.Gen{propName: propGen}))
	}
	eventSubscriptionDestinationGenerator = gen.OneGenOf(gens...)

	return eventSubscriptionDestinationGenerator
}

// AddRelatedPropertyGeneratorsForEventSubscriptionDestination is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["AzureFunction"] = AzureFunctionEventSubscriptionDestinationGenerator().Map(func(it AzureFunctionEventSubscriptionDestination) *AzureFunctionEventSubscriptionDestination {
		return &it
	}) // generate one case for OneOf type
	gens["EventHub"] = EventHubEventSubscriptionDestinationGenerator().Map(func(it EventHubEventSubscriptionDestination) *EventHubEventSubscriptionDestination {
		return &it
	}) // generate one case for OneOf type
	gens["HybridConnection"] = HybridConnectionEventSubscriptionDestinationGenerator().Map(func(it HybridConnectionEventSubscriptionDestination) *HybridConnectionEventSubscriptionDestination {
		return &it
	}) // generate one case for OneOf type
	gens["ServiceBusQueue"] = ServiceBusQueueEventSubscriptionDestinationGenerator().Map(func(it ServiceBusQueueEventSubscriptionDestination) *ServiceBusQueueEventSubscriptionDestination {
		return &it
	}) // generate one case for OneOf type
	gens["ServiceBusTopic"] = ServiceBusTopicEventSubscriptionDestinationGenerator().Map(func(it ServiceBusTopicEventSubscriptionDestination) *ServiceBusTopicEventSubscriptionDestination {
		return &it
	}) // generate one case for OneOf type
	gens["StorageQueue"] = StorageQueueEventSubscriptionDestinationGenerator().Map(func(it StorageQueueEventSubscriptionDestination) *StorageQueueEventSubscriptionDestination {
		return &it
	}) // generate one case for OneOf type
	gens["WebHook"] = WebHookEventSubscriptionDestinationGenerator().Map(func(it WebHookEventSubscriptionDestination) *WebHookEventSubscriptionDestination {
		return &it
	}) // generate one case for OneOf type
}

func Test_EventSubscriptionFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionFilter, EventSubscriptionFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionFilter runs a test to see if a specific instance of EventSubscriptionFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionFilter(subject EventSubscriptionFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionFilter instances for property testing - lazily instantiated by
// EventSubscriptionFilterGenerator()
var eventSubscriptionFilterGenerator gopter.Gen

// EventSubscriptionFilterGenerator returns a generator of EventSubscriptionFilter instances for property testing.
// We first initialize eventSubscriptionFilterGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionFilterGenerator() gopter.Gen {
	if eventSubscriptionFilterGenerator != nil {
		return eventSubscriptionFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilter(generators)
	eventSubscriptionFilterGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionFilter(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionFilter(generators)
	eventSubscriptionFilterGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionFilter{}), generators)

	return eventSubscriptionFilterGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionFilter(gens map[string]gopter.Gen) {
	gens["IncludedEventTypes"] = gen.SliceOf(gen.AlphaString())
	gens["IsSubjectCaseSensitive"] = gen.PtrOf(gen.Bool())
	gens["SubjectBeginsWith"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectEndsWith"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionFilter is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionFilter(gens map[string]gopter.Gen) {
	gens["AdvancedFilters"] = gen.SliceOf(AdvancedFilterGenerator())
}

func Test_EventSubscriptionProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscriptionProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscriptionProperties, EventSubscriptionPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscriptionProperties runs a test to see if a specific instance of EventSubscriptionProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscriptionProperties(subject EventSubscriptionProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscriptionProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscriptionProperties instances for property testing - lazily instantiated by
// EventSubscriptionPropertiesGenerator()
var eventSubscriptionPropertiesGenerator gopter.Gen

// EventSubscriptionPropertiesGenerator returns a generator of EventSubscriptionProperties instances for property testing.
// We first initialize eventSubscriptionPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscriptionPropertiesGenerator() gopter.Gen {
	if eventSubscriptionPropertiesGenerator != nil {
		return eventSubscriptionPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionProperties(generators)
	eventSubscriptionPropertiesGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscriptionProperties(generators)
	AddRelatedPropertyGeneratorsForEventSubscriptionProperties(generators)
	eventSubscriptionPropertiesGenerator = gen.Struct(reflect.TypeOf(EventSubscriptionProperties{}), generators)

	return eventSubscriptionPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscriptionProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscriptionProperties(gens map[string]gopter.Gen) {
	gens["EventDeliverySchema"] = gen.PtrOf(gen.OneConstOf(EventSubscriptionProperties_EventDeliverySchema_CloudEventSchemaV1_0, EventSubscriptionProperties_EventDeliverySchema_CustomInputSchema, EventSubscriptionProperties_EventDeliverySchema_EventGridSchema))
	gens["ExpirationTimeUtc"] = gen.PtrOf(gen.AlphaString())
	gens["Labels"] = gen.SliceOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEventSubscriptionProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscriptionProperties(gens map[string]gopter.Gen) {
	gens["DeadLetterDestination"] = gen.PtrOf(DeadLetterDestinationGenerator())
	gens["Destination"] = gen.PtrOf(EventSubscriptionDestinationGenerator())
	gens["Filter"] = gen.PtrOf(EventSubscriptionFilterGenerator())
	gens["RetryPolicy"] = gen.PtrOf(RetryPolicyGenerator())
}

func Test_EventSubscription_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EventSubscription_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEventSubscription_Spec, EventSubscription_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEventSubscription_Spec runs a test to see if a specific instance of EventSubscription_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForEventSubscription_Spec(subject EventSubscription_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EventSubscription_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EventSubscription_Spec instances for property testing - lazily instantiated by
// EventSubscription_SpecGenerator()
var eventSubscription_SpecGenerator gopter.Gen

// EventSubscription_SpecGenerator returns a generator of EventSubscription_Spec instances for property testing.
// We first initialize eventSubscription_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EventSubscription_SpecGenerator() gopter.Gen {
	if eventSubscription_SpecGenerator != nil {
		return eventSubscription_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_Spec(generators)
	eventSubscription_SpecGenerator = gen.Struct(reflect.TypeOf(EventSubscription_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEventSubscription_Spec(generators)
	AddRelatedPropertyGeneratorsForEventSubscription_Spec(generators)
	eventSubscription_SpecGenerator = gen.Struct(reflect.TypeOf(EventSubscription_Spec{}), generators)

	return eventSubscription_SpecGenerator
}

// AddIndependentPropertyGeneratorsForEventSubscription_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEventSubscription_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForEventSubscription_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEventSubscription_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(EventSubscriptionPropertiesGenerator())
}

func Test_HybridConnectionEventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HybridConnectionEventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHybridConnectionEventSubscriptionDestination, HybridConnectionEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHybridConnectionEventSubscriptionDestination runs a test to see if a specific instance of HybridConnectionEventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForHybridConnectionEventSubscriptionDestination(subject HybridConnectionEventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HybridConnectionEventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HybridConnectionEventSubscriptionDestination instances for property testing - lazily instantiated by
// HybridConnectionEventSubscriptionDestinationGenerator()
var hybridConnectionEventSubscriptionDestinationGenerator gopter.Gen

// HybridConnectionEventSubscriptionDestinationGenerator returns a generator of HybridConnectionEventSubscriptionDestination instances for property testing.
// We first initialize hybridConnectionEventSubscriptionDestinationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HybridConnectionEventSubscriptionDestinationGenerator() gopter.Gen {
	if hybridConnectionEventSubscriptionDestinationGenerator != nil {
		return hybridConnectionEventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestination(generators)
	hybridConnectionEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(HybridConnectionEventSubscriptionDestination{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestination(generators)
	AddRelatedPropertyGeneratorsForHybridConnectionEventSubscriptionDestination(generators)
	hybridConnectionEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(HybridConnectionEventSubscriptionDestination{}), generators)

	return hybridConnectionEventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(HybridConnectionEventSubscriptionDestination_EndpointType_HybridConnection)
}

// AddRelatedPropertyGeneratorsForHybridConnectionEventSubscriptionDestination is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHybridConnectionEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(HybridConnectionEventSubscriptionDestinationPropertiesGenerator())
}

func Test_HybridConnectionEventSubscriptionDestinationProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HybridConnectionEventSubscriptionDestinationProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationProperties, HybridConnectionEventSubscriptionDestinationPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationProperties runs a test to see if a specific instance of HybridConnectionEventSubscriptionDestinationProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForHybridConnectionEventSubscriptionDestinationProperties(subject HybridConnectionEventSubscriptionDestinationProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HybridConnectionEventSubscriptionDestinationProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HybridConnectionEventSubscriptionDestinationProperties instances for property testing - lazily
// instantiated by HybridConnectionEventSubscriptionDestinationPropertiesGenerator()
var hybridConnectionEventSubscriptionDestinationPropertiesGenerator gopter.Gen

// HybridConnectionEventSubscriptionDestinationPropertiesGenerator returns a generator of HybridConnectionEventSubscriptionDestinationProperties instances for property testing.
func HybridConnectionEventSubscriptionDestinationPropertiesGenerator() gopter.Gen {
	if hybridConnectionEventSubscriptionDestinationPropertiesGenerator != nil {
		return hybridConnectionEventSubscriptionDestinationPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationProperties(generators)
	hybridConnectionEventSubscriptionDestinationPropertiesGenerator = gen.Struct(reflect.TypeOf(HybridConnectionEventSubscriptionDestinationProperties{}), generators)

	return hybridConnectionEventSubscriptionDestinationPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHybridConnectionEventSubscriptionDestinationProperties(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_NumberGreaterThanAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberGreaterThanAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberGreaterThanAdvancedFilter, NumberGreaterThanAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberGreaterThanAdvancedFilter runs a test to see if a specific instance of NumberGreaterThanAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberGreaterThanAdvancedFilter(subject NumberGreaterThanAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberGreaterThanAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberGreaterThanAdvancedFilter instances for property testing - lazily instantiated by
// NumberGreaterThanAdvancedFilterGenerator()
var numberGreaterThanAdvancedFilterGenerator gopter.Gen

// NumberGreaterThanAdvancedFilterGenerator returns a generator of NumberGreaterThanAdvancedFilter instances for property testing.
func NumberGreaterThanAdvancedFilterGenerator() gopter.Gen {
	if numberGreaterThanAdvancedFilterGenerator != nil {
		return numberGreaterThanAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberGreaterThanAdvancedFilter(generators)
	numberGreaterThanAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(NumberGreaterThanAdvancedFilter{}), generators)

	return numberGreaterThanAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForNumberGreaterThanAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberGreaterThanAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberGreaterThanAdvancedFilter_OperatorType_NumberGreaterThan)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_NumberGreaterThanOrEqualsAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberGreaterThanOrEqualsAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberGreaterThanOrEqualsAdvancedFilter, NumberGreaterThanOrEqualsAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberGreaterThanOrEqualsAdvancedFilter runs a test to see if a specific instance of NumberGreaterThanOrEqualsAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberGreaterThanOrEqualsAdvancedFilter(subject NumberGreaterThanOrEqualsAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberGreaterThanOrEqualsAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberGreaterThanOrEqualsAdvancedFilter instances for property testing - lazily instantiated by
// NumberGreaterThanOrEqualsAdvancedFilterGenerator()
var numberGreaterThanOrEqualsAdvancedFilterGenerator gopter.Gen

// NumberGreaterThanOrEqualsAdvancedFilterGenerator returns a generator of NumberGreaterThanOrEqualsAdvancedFilter instances for property testing.
func NumberGreaterThanOrEqualsAdvancedFilterGenerator() gopter.Gen {
	if numberGreaterThanOrEqualsAdvancedFilterGenerator != nil {
		return numberGreaterThanOrEqualsAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberGreaterThanOrEqualsAdvancedFilter(generators)
	numberGreaterThanOrEqualsAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(NumberGreaterThanOrEqualsAdvancedFilter{}), generators)

	return numberGreaterThanOrEqualsAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForNumberGreaterThanOrEqualsAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberGreaterThanOrEqualsAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberGreaterThanOrEqualsAdvancedFilter_OperatorType_NumberGreaterThanOrEquals)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_NumberInAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberInAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberInAdvancedFilter, NumberInAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberInAdvancedFilter runs a test to see if a specific instance of NumberInAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberInAdvancedFilter(subject NumberInAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberInAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberInAdvancedFilter instances for property testing - lazily instantiated by
// NumberInAdvancedFilterGenerator()
var numberInAdvancedFilterGenerator gopter.Gen

// NumberInAdvancedFilterGenerator returns a generator of NumberInAdvancedFilter instances for property testing.
func NumberInAdvancedFilterGenerator() gopter.Gen {
	if numberInAdvancedFilterGenerator != nil {
		return numberInAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberInAdvancedFilter(generators)
	numberInAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(NumberInAdvancedFilter{}), generators)

	return numberInAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForNumberInAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberInAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberInAdvancedFilter_OperatorType_NumberIn)
	gens["Values"] = gen.SliceOf(gen.Float64())
}

func Test_NumberLessThanAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberLessThanAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberLessThanAdvancedFilter, NumberLessThanAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberLessThanAdvancedFilter runs a test to see if a specific instance of NumberLessThanAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberLessThanAdvancedFilter(subject NumberLessThanAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberLessThanAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberLessThanAdvancedFilter instances for property testing - lazily instantiated by
// NumberLessThanAdvancedFilterGenerator()
var numberLessThanAdvancedFilterGenerator gopter.Gen

// NumberLessThanAdvancedFilterGenerator returns a generator of NumberLessThanAdvancedFilter instances for property testing.
func NumberLessThanAdvancedFilterGenerator() gopter.Gen {
	if numberLessThanAdvancedFilterGenerator != nil {
		return numberLessThanAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberLessThanAdvancedFilter(generators)
	numberLessThanAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(NumberLessThanAdvancedFilter{}), generators)

	return numberLessThanAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForNumberLessThanAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberLessThanAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberLessThanAdvancedFilter_OperatorType_NumberLessThan)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_NumberLessThanOrEqualsAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberLessThanOrEqualsAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberLessThanOrEqualsAdvancedFilter, NumberLessThanOrEqualsAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberLessThanOrEqualsAdvancedFilter runs a test to see if a specific instance of NumberLessThanOrEqualsAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberLessThanOrEqualsAdvancedFilter(subject NumberLessThanOrEqualsAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberLessThanOrEqualsAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberLessThanOrEqualsAdvancedFilter instances for property testing - lazily instantiated by
// NumberLessThanOrEqualsAdvancedFilterGenerator()
var numberLessThanOrEqualsAdvancedFilterGenerator gopter.Gen

// NumberLessThanOrEqualsAdvancedFilterGenerator returns a generator of NumberLessThanOrEqualsAdvancedFilter instances for property testing.
func NumberLessThanOrEqualsAdvancedFilterGenerator() gopter.Gen {
	if numberLessThanOrEqualsAdvancedFilterGenerator != nil {
		return numberLessThanOrEqualsAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberLessThanOrEqualsAdvancedFilter(generators)
	numberLessThanOrEqualsAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(NumberLessThanOrEqualsAdvancedFilter{}), generators)

	return numberLessThanOrEqualsAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForNumberLessThanOrEqualsAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberLessThanOrEqualsAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberLessThanOrEqualsAdvancedFilter_OperatorType_NumberLessThanOrEquals)
	gens["Value"] = gen.PtrOf(gen.Float64())
}

func Test_NumberNotInAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NumberNotInAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNumberNotInAdvancedFilter, NumberNotInAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNumberNotInAdvancedFilter runs a test to see if a specific instance of NumberNotInAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForNumberNotInAdvancedFilter(subject NumberNotInAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NumberNotInAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NumberNotInAdvancedFilter instances for property testing - lazily instantiated by
// NumberNotInAdvancedFilterGenerator()
var numberNotInAdvancedFilterGenerator gopter.Gen

// NumberNotInAdvancedFilterGenerator returns a generator of NumberNotInAdvancedFilter instances for property testing.
func NumberNotInAdvancedFilterGenerator() gopter.Gen {
	if numberNotInAdvancedFilterGenerator != nil {
		return numberNotInAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNumberNotInAdvancedFilter(generators)
	numberNotInAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(NumberNotInAdvancedFilter{}), generators)

	return numberNotInAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForNumberNotInAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNumberNotInAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(NumberNotInAdvancedFilter_OperatorType_NumberNotIn)
	gens["Values"] = gen.SliceOf(gen.Float64())
}

func Test_RetryPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RetryPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRetryPolicy, RetryPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRetryPolicy runs a test to see if a specific instance of RetryPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForRetryPolicy(subject RetryPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RetryPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RetryPolicy instances for property testing - lazily instantiated by RetryPolicyGenerator()
var retryPolicyGenerator gopter.Gen

// RetryPolicyGenerator returns a generator of RetryPolicy instances for property testing.
func RetryPolicyGenerator() gopter.Gen {
	if retryPolicyGenerator != nil {
		return retryPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRetryPolicy(generators)
	retryPolicyGenerator = gen.Struct(reflect.TypeOf(RetryPolicy{}), generators)

	return retryPolicyGenerator
}

// AddIndependentPropertyGeneratorsForRetryPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRetryPolicy(gens map[string]gopter.Gen) {
	gens["EventTimeToLiveInMinutes"] = gen.PtrOf(gen.Int())
	gens["MaxDeliveryAttempts"] = gen.PtrOf(gen.Int())
}

func Test_ServiceBusQueueEventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusQueueEventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestination, ServiceBusQueueEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestination runs a test to see if a specific instance of ServiceBusQueueEventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestination(subject ServiceBusQueueEventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusQueueEventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusQueueEventSubscriptionDestination instances for property testing - lazily instantiated by
// ServiceBusQueueEventSubscriptionDestinationGenerator()
var serviceBusQueueEventSubscriptionDestinationGenerator gopter.Gen

// ServiceBusQueueEventSubscriptionDestinationGenerator returns a generator of ServiceBusQueueEventSubscriptionDestination instances for property testing.
// We first initialize serviceBusQueueEventSubscriptionDestinationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServiceBusQueueEventSubscriptionDestinationGenerator() gopter.Gen {
	if serviceBusQueueEventSubscriptionDestinationGenerator != nil {
		return serviceBusQueueEventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestination(generators)
	serviceBusQueueEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(ServiceBusQueueEventSubscriptionDestination{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestination(generators)
	AddRelatedPropertyGeneratorsForServiceBusQueueEventSubscriptionDestination(generators)
	serviceBusQueueEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(ServiceBusQueueEventSubscriptionDestination{}), generators)

	return serviceBusQueueEventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(ServiceBusQueueEventSubscriptionDestination_EndpointType_ServiceBusQueue)
}

// AddRelatedPropertyGeneratorsForServiceBusQueueEventSubscriptionDestination is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceBusQueueEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ServiceBusQueueEventSubscriptionDestinationPropertiesGenerator())
}

func Test_ServiceBusQueueEventSubscriptionDestinationProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusQueueEventSubscriptionDestinationProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationProperties, ServiceBusQueueEventSubscriptionDestinationPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationProperties runs a test to see if a specific instance of ServiceBusQueueEventSubscriptionDestinationProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusQueueEventSubscriptionDestinationProperties(subject ServiceBusQueueEventSubscriptionDestinationProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusQueueEventSubscriptionDestinationProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusQueueEventSubscriptionDestinationProperties instances for property testing - lazily
// instantiated by ServiceBusQueueEventSubscriptionDestinationPropertiesGenerator()
var serviceBusQueueEventSubscriptionDestinationPropertiesGenerator gopter.Gen

// ServiceBusQueueEventSubscriptionDestinationPropertiesGenerator returns a generator of ServiceBusQueueEventSubscriptionDestinationProperties instances for property testing.
func ServiceBusQueueEventSubscriptionDestinationPropertiesGenerator() gopter.Gen {
	if serviceBusQueueEventSubscriptionDestinationPropertiesGenerator != nil {
		return serviceBusQueueEventSubscriptionDestinationPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationProperties(generators)
	serviceBusQueueEventSubscriptionDestinationPropertiesGenerator = gen.Struct(reflect.TypeOf(ServiceBusQueueEventSubscriptionDestinationProperties{}), generators)

	return serviceBusQueueEventSubscriptionDestinationPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusQueueEventSubscriptionDestinationProperties(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServiceBusTopicEventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusTopicEventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestination, ServiceBusTopicEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestination runs a test to see if a specific instance of ServiceBusTopicEventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestination(subject ServiceBusTopicEventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusTopicEventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusTopicEventSubscriptionDestination instances for property testing - lazily instantiated by
// ServiceBusTopicEventSubscriptionDestinationGenerator()
var serviceBusTopicEventSubscriptionDestinationGenerator gopter.Gen

// ServiceBusTopicEventSubscriptionDestinationGenerator returns a generator of ServiceBusTopicEventSubscriptionDestination instances for property testing.
// We first initialize serviceBusTopicEventSubscriptionDestinationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServiceBusTopicEventSubscriptionDestinationGenerator() gopter.Gen {
	if serviceBusTopicEventSubscriptionDestinationGenerator != nil {
		return serviceBusTopicEventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestination(generators)
	serviceBusTopicEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(ServiceBusTopicEventSubscriptionDestination{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestination(generators)
	AddRelatedPropertyGeneratorsForServiceBusTopicEventSubscriptionDestination(generators)
	serviceBusTopicEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(ServiceBusTopicEventSubscriptionDestination{}), generators)

	return serviceBusTopicEventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(ServiceBusTopicEventSubscriptionDestination_EndpointType_ServiceBusTopic)
}

// AddRelatedPropertyGeneratorsForServiceBusTopicEventSubscriptionDestination is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServiceBusTopicEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ServiceBusTopicEventSubscriptionDestinationPropertiesGenerator())
}

func Test_ServiceBusTopicEventSubscriptionDestinationProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServiceBusTopicEventSubscriptionDestinationProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationProperties, ServiceBusTopicEventSubscriptionDestinationPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationProperties runs a test to see if a specific instance of ServiceBusTopicEventSubscriptionDestinationProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForServiceBusTopicEventSubscriptionDestinationProperties(subject ServiceBusTopicEventSubscriptionDestinationProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServiceBusTopicEventSubscriptionDestinationProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServiceBusTopicEventSubscriptionDestinationProperties instances for property testing - lazily
// instantiated by ServiceBusTopicEventSubscriptionDestinationPropertiesGenerator()
var serviceBusTopicEventSubscriptionDestinationPropertiesGenerator gopter.Gen

// ServiceBusTopicEventSubscriptionDestinationPropertiesGenerator returns a generator of ServiceBusTopicEventSubscriptionDestinationProperties instances for property testing.
func ServiceBusTopicEventSubscriptionDestinationPropertiesGenerator() gopter.Gen {
	if serviceBusTopicEventSubscriptionDestinationPropertiesGenerator != nil {
		return serviceBusTopicEventSubscriptionDestinationPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationProperties(generators)
	serviceBusTopicEventSubscriptionDestinationPropertiesGenerator = gen.Struct(reflect.TypeOf(ServiceBusTopicEventSubscriptionDestinationProperties{}), generators)

	return serviceBusTopicEventSubscriptionDestinationPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServiceBusTopicEventSubscriptionDestinationProperties(gens map[string]gopter.Gen) {
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageBlobDeadLetterDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlobDeadLetterDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlobDeadLetterDestination, StorageBlobDeadLetterDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlobDeadLetterDestination runs a test to see if a specific instance of StorageBlobDeadLetterDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlobDeadLetterDestination(subject StorageBlobDeadLetterDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlobDeadLetterDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlobDeadLetterDestination instances for property testing - lazily instantiated by
// StorageBlobDeadLetterDestinationGenerator()
var storageBlobDeadLetterDestinationGenerator gopter.Gen

// StorageBlobDeadLetterDestinationGenerator returns a generator of StorageBlobDeadLetterDestination instances for property testing.
// We first initialize storageBlobDeadLetterDestinationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageBlobDeadLetterDestinationGenerator() gopter.Gen {
	if storageBlobDeadLetterDestinationGenerator != nil {
		return storageBlobDeadLetterDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestination(generators)
	storageBlobDeadLetterDestinationGenerator = gen.Struct(reflect.TypeOf(StorageBlobDeadLetterDestination{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestination(generators)
	AddRelatedPropertyGeneratorsForStorageBlobDeadLetterDestination(generators)
	storageBlobDeadLetterDestinationGenerator = gen.Struct(reflect.TypeOf(StorageBlobDeadLetterDestination{}), generators)

	return storageBlobDeadLetterDestinationGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(StorageBlobDeadLetterDestination_EndpointType_StorageBlob)
}

// AddRelatedPropertyGeneratorsForStorageBlobDeadLetterDestination is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageBlobDeadLetterDestination(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(StorageBlobDeadLetterDestinationPropertiesGenerator())
}

func Test_StorageBlobDeadLetterDestinationProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageBlobDeadLetterDestinationProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageBlobDeadLetterDestinationProperties, StorageBlobDeadLetterDestinationPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageBlobDeadLetterDestinationProperties runs a test to see if a specific instance of StorageBlobDeadLetterDestinationProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageBlobDeadLetterDestinationProperties(subject StorageBlobDeadLetterDestinationProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageBlobDeadLetterDestinationProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageBlobDeadLetterDestinationProperties instances for property testing - lazily instantiated by
// StorageBlobDeadLetterDestinationPropertiesGenerator()
var storageBlobDeadLetterDestinationPropertiesGenerator gopter.Gen

// StorageBlobDeadLetterDestinationPropertiesGenerator returns a generator of StorageBlobDeadLetterDestinationProperties instances for property testing.
func StorageBlobDeadLetterDestinationPropertiesGenerator() gopter.Gen {
	if storageBlobDeadLetterDestinationPropertiesGenerator != nil {
		return storageBlobDeadLetterDestinationPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationProperties(generators)
	storageBlobDeadLetterDestinationPropertiesGenerator = gen.Struct(reflect.TypeOf(StorageBlobDeadLetterDestinationProperties{}), generators)

	return storageBlobDeadLetterDestinationPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageBlobDeadLetterDestinationProperties(gens map[string]gopter.Gen) {
	gens["BlobContainerName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StorageQueueEventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageQueueEventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageQueueEventSubscriptionDestination, StorageQueueEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageQueueEventSubscriptionDestination runs a test to see if a specific instance of StorageQueueEventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageQueueEventSubscriptionDestination(subject StorageQueueEventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageQueueEventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageQueueEventSubscriptionDestination instances for property testing - lazily instantiated by
// StorageQueueEventSubscriptionDestinationGenerator()
var storageQueueEventSubscriptionDestinationGenerator gopter.Gen

// StorageQueueEventSubscriptionDestinationGenerator returns a generator of StorageQueueEventSubscriptionDestination instances for property testing.
// We first initialize storageQueueEventSubscriptionDestinationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func StorageQueueEventSubscriptionDestinationGenerator() gopter.Gen {
	if storageQueueEventSubscriptionDestinationGenerator != nil {
		return storageQueueEventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestination(generators)
	storageQueueEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(StorageQueueEventSubscriptionDestination{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestination(generators)
	AddRelatedPropertyGeneratorsForStorageQueueEventSubscriptionDestination(generators)
	storageQueueEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(StorageQueueEventSubscriptionDestination{}), generators)

	return storageQueueEventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(StorageQueueEventSubscriptionDestination_EndpointType_StorageQueue)
}

// AddRelatedPropertyGeneratorsForStorageQueueEventSubscriptionDestination is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForStorageQueueEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(StorageQueueEventSubscriptionDestinationPropertiesGenerator())
}

func Test_StorageQueueEventSubscriptionDestinationProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageQueueEventSubscriptionDestinationProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationProperties, StorageQueueEventSubscriptionDestinationPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationProperties runs a test to see if a specific instance of StorageQueueEventSubscriptionDestinationProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageQueueEventSubscriptionDestinationProperties(subject StorageQueueEventSubscriptionDestinationProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageQueueEventSubscriptionDestinationProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageQueueEventSubscriptionDestinationProperties instances for property testing - lazily instantiated
// by StorageQueueEventSubscriptionDestinationPropertiesGenerator()
var storageQueueEventSubscriptionDestinationPropertiesGenerator gopter.Gen

// StorageQueueEventSubscriptionDestinationPropertiesGenerator returns a generator of StorageQueueEventSubscriptionDestinationProperties instances for property testing.
func StorageQueueEventSubscriptionDestinationPropertiesGenerator() gopter.Gen {
	if storageQueueEventSubscriptionDestinationPropertiesGenerator != nil {
		return storageQueueEventSubscriptionDestinationPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationProperties(generators)
	storageQueueEventSubscriptionDestinationPropertiesGenerator = gen.Struct(reflect.TypeOf(StorageQueueEventSubscriptionDestinationProperties{}), generators)

	return storageQueueEventSubscriptionDestinationPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageQueueEventSubscriptionDestinationProperties(gens map[string]gopter.Gen) {
	gens["QueueName"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_StringBeginsWithAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringBeginsWithAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringBeginsWithAdvancedFilter, StringBeginsWithAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringBeginsWithAdvancedFilter runs a test to see if a specific instance of StringBeginsWithAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForStringBeginsWithAdvancedFilter(subject StringBeginsWithAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringBeginsWithAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringBeginsWithAdvancedFilter instances for property testing - lazily instantiated by
// StringBeginsWithAdvancedFilterGenerator()
var stringBeginsWithAdvancedFilterGenerator gopter.Gen

// StringBeginsWithAdvancedFilterGenerator returns a generator of StringBeginsWithAdvancedFilter instances for property testing.
func StringBeginsWithAdvancedFilterGenerator() gopter.Gen {
	if stringBeginsWithAdvancedFilterGenerator != nil {
		return stringBeginsWithAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringBeginsWithAdvancedFilter(generators)
	stringBeginsWithAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(StringBeginsWithAdvancedFilter{}), generators)

	return stringBeginsWithAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForStringBeginsWithAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringBeginsWithAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringBeginsWithAdvancedFilter_OperatorType_StringBeginsWith)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_StringContainsAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringContainsAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringContainsAdvancedFilter, StringContainsAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringContainsAdvancedFilter runs a test to see if a specific instance of StringContainsAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForStringContainsAdvancedFilter(subject StringContainsAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringContainsAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringContainsAdvancedFilter instances for property testing - lazily instantiated by
// StringContainsAdvancedFilterGenerator()
var stringContainsAdvancedFilterGenerator gopter.Gen

// StringContainsAdvancedFilterGenerator returns a generator of StringContainsAdvancedFilter instances for property testing.
func StringContainsAdvancedFilterGenerator() gopter.Gen {
	if stringContainsAdvancedFilterGenerator != nil {
		return stringContainsAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringContainsAdvancedFilter(generators)
	stringContainsAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(StringContainsAdvancedFilter{}), generators)

	return stringContainsAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForStringContainsAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringContainsAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringContainsAdvancedFilter_OperatorType_StringContains)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_StringEndsWithAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringEndsWithAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringEndsWithAdvancedFilter, StringEndsWithAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringEndsWithAdvancedFilter runs a test to see if a specific instance of StringEndsWithAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForStringEndsWithAdvancedFilter(subject StringEndsWithAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringEndsWithAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringEndsWithAdvancedFilter instances for property testing - lazily instantiated by
// StringEndsWithAdvancedFilterGenerator()
var stringEndsWithAdvancedFilterGenerator gopter.Gen

// StringEndsWithAdvancedFilterGenerator returns a generator of StringEndsWithAdvancedFilter instances for property testing.
func StringEndsWithAdvancedFilterGenerator() gopter.Gen {
	if stringEndsWithAdvancedFilterGenerator != nil {
		return stringEndsWithAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringEndsWithAdvancedFilter(generators)
	stringEndsWithAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(StringEndsWithAdvancedFilter{}), generators)

	return stringEndsWithAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForStringEndsWithAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringEndsWithAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringEndsWithAdvancedFilter_OperatorType_StringEndsWith)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_StringInAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringInAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringInAdvancedFilter, StringInAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringInAdvancedFilter runs a test to see if a specific instance of StringInAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForStringInAdvancedFilter(subject StringInAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringInAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringInAdvancedFilter instances for property testing - lazily instantiated by
// StringInAdvancedFilterGenerator()
var stringInAdvancedFilterGenerator gopter.Gen

// StringInAdvancedFilterGenerator returns a generator of StringInAdvancedFilter instances for property testing.
func StringInAdvancedFilterGenerator() gopter.Gen {
	if stringInAdvancedFilterGenerator != nil {
		return stringInAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringInAdvancedFilter(generators)
	stringInAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(StringInAdvancedFilter{}), generators)

	return stringInAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForStringInAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringInAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringInAdvancedFilter_OperatorType_StringIn)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_StringNotInAdvancedFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StringNotInAdvancedFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStringNotInAdvancedFilter, StringNotInAdvancedFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStringNotInAdvancedFilter runs a test to see if a specific instance of StringNotInAdvancedFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForStringNotInAdvancedFilter(subject StringNotInAdvancedFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StringNotInAdvancedFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StringNotInAdvancedFilter instances for property testing - lazily instantiated by
// StringNotInAdvancedFilterGenerator()
var stringNotInAdvancedFilterGenerator gopter.Gen

// StringNotInAdvancedFilterGenerator returns a generator of StringNotInAdvancedFilter instances for property testing.
func StringNotInAdvancedFilterGenerator() gopter.Gen {
	if stringNotInAdvancedFilterGenerator != nil {
		return stringNotInAdvancedFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStringNotInAdvancedFilter(generators)
	stringNotInAdvancedFilterGenerator = gen.Struct(reflect.TypeOf(StringNotInAdvancedFilter{}), generators)

	return stringNotInAdvancedFilterGenerator
}

// AddIndependentPropertyGeneratorsForStringNotInAdvancedFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStringNotInAdvancedFilter(gens map[string]gopter.Gen) {
	gens["Key"] = gen.PtrOf(gen.AlphaString())
	gens["OperatorType"] = gen.OneConstOf(StringNotInAdvancedFilter_OperatorType_StringNotIn)
	gens["Values"] = gen.SliceOf(gen.AlphaString())
}

func Test_WebHookEventSubscriptionDestination_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebHookEventSubscriptionDestination via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebHookEventSubscriptionDestination, WebHookEventSubscriptionDestinationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebHookEventSubscriptionDestination runs a test to see if a specific instance of WebHookEventSubscriptionDestination round trips to JSON and back losslessly
func RunJSONSerializationTestForWebHookEventSubscriptionDestination(subject WebHookEventSubscriptionDestination) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebHookEventSubscriptionDestination
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebHookEventSubscriptionDestination instances for property testing - lazily instantiated by
// WebHookEventSubscriptionDestinationGenerator()
var webHookEventSubscriptionDestinationGenerator gopter.Gen

// WebHookEventSubscriptionDestinationGenerator returns a generator of WebHookEventSubscriptionDestination instances for property testing.
// We first initialize webHookEventSubscriptionDestinationGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WebHookEventSubscriptionDestinationGenerator() gopter.Gen {
	if webHookEventSubscriptionDestinationGenerator != nil {
		return webHookEventSubscriptionDestinationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestination(generators)
	webHookEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(WebHookEventSubscriptionDestination{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestination(generators)
	AddRelatedPropertyGeneratorsForWebHookEventSubscriptionDestination(generators)
	webHookEventSubscriptionDestinationGenerator = gen.Struct(reflect.TypeOf(WebHookEventSubscriptionDestination{}), generators)

	return webHookEventSubscriptionDestinationGenerator
}

// AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestination is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["EndpointType"] = gen.OneConstOf(WebHookEventSubscriptionDestination_EndpointType_WebHook)
}

// AddRelatedPropertyGeneratorsForWebHookEventSubscriptionDestination is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWebHookEventSubscriptionDestination(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(WebHookEventSubscriptionDestinationPropertiesGenerator())
}

func Test_WebHookEventSubscriptionDestinationProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WebHookEventSubscriptionDestinationProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWebHookEventSubscriptionDestinationProperties, WebHookEventSubscriptionDestinationPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWebHookEventSubscriptionDestinationProperties runs a test to see if a specific instance of WebHookEventSubscriptionDestinationProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForWebHookEventSubscriptionDestinationProperties(subject WebHookEventSubscriptionDestinationProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WebHookEventSubscriptionDestinationProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WebHookEventSubscriptionDestinationProperties instances for property testing - lazily instantiated by
// WebHookEventSubscriptionDestinationPropertiesGenerator()
var webHookEventSubscriptionDestinationPropertiesGenerator gopter.Gen

// WebHookEventSubscriptionDestinationPropertiesGenerator returns a generator of WebHookEventSubscriptionDestinationProperties instances for property testing.
func WebHookEventSubscriptionDestinationPropertiesGenerator() gopter.Gen {
	if webHookEventSubscriptionDestinationPropertiesGenerator != nil {
		return webHookEventSubscriptionDestinationPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationProperties(generators)
	webHookEventSubscriptionDestinationPropertiesGenerator = gen.Struct(reflect.TypeOf(WebHookEventSubscriptionDestinationProperties{}), generators)

	return webHookEventSubscriptionDestinationPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWebHookEventSubscriptionDestinationProperties(gens map[string]gopter.Gen) {
	gens["AzureActiveDirectoryApplicationIdOrUri"] = gen.PtrOf(gen.AlphaString())
	gens["AzureActiveDirectoryTenantId"] = gen.PtrOf(gen.AlphaString())
	gens["EndpointUrl"] = gen.PtrOf(gen.AlphaString())
	gens["MaxEventsPerBatch"] = gen.PtrOf(gen.Int())
	gens["PreferredBatchSizeInKilobytes"] = gen.PtrOf(gen.Int())
}
