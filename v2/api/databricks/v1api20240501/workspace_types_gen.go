// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240501

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/databricks/v1api20240501/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/databricks/v1api20240501/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,databricks}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /databricks/resource-manager/Microsoft.Databricks/stable/2024-05-01/databricks.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}
type Workspace struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Workspace_Spec   `json:"spec,omitempty"`
	Status            Workspace_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Workspace{}

// GetConditions returns the conditions of the resource
func (workspace *Workspace) GetConditions() conditions.Conditions {
	return workspace.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (workspace *Workspace) SetConditions(conditions conditions.Conditions) {
	workspace.Status.Conditions = conditions
}

var _ conversion.Convertible = &Workspace{}

// ConvertFrom populates our Workspace from the provided hub Workspace
func (workspace *Workspace) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.Workspace)
	if !ok {
		return fmt.Errorf("expected databricks/v1api20240501/storage/Workspace but received %T instead", hub)
	}

	return workspace.AssignProperties_From_Workspace(source)
}

// ConvertTo populates the provided hub Workspace from our Workspace
func (workspace *Workspace) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.Workspace)
	if !ok {
		return fmt.Errorf("expected databricks/v1api20240501/storage/Workspace but received %T instead", hub)
	}

	return workspace.AssignProperties_To_Workspace(destination)
}

var _ configmaps.Exporter = &Workspace{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (workspace *Workspace) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if workspace.Spec.OperatorSpec == nil {
		return nil
	}
	return workspace.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &Workspace{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (workspace *Workspace) SecretDestinationExpressions() []*core.DestinationExpression {
	if workspace.Spec.OperatorSpec == nil {
		return nil
	}
	return workspace.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &Workspace{}

// InitializeSpec initializes the spec for this resource from the given status
func (workspace *Workspace) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Workspace_STATUS); ok {
		return workspace.Spec.Initialize_From_Workspace_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Workspace_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &Workspace{}

// AzureName returns the Azure name of the resource
func (workspace *Workspace) AzureName() string {
	return workspace.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-05-01"
func (workspace Workspace) GetAPIVersion() string {
	return "2024-05-01"
}

// GetResourceScope returns the scope of the resource
func (workspace *Workspace) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (workspace *Workspace) GetSpec() genruntime.ConvertibleSpec {
	return &workspace.Spec
}

// GetStatus returns the status of this resource
func (workspace *Workspace) GetStatus() genruntime.ConvertibleStatus {
	return &workspace.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (workspace *Workspace) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Databricks/workspaces"
func (workspace *Workspace) GetType() string {
	return "Microsoft.Databricks/workspaces"
}

// NewEmptyStatus returns a new empty (blank) status
func (workspace *Workspace) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Workspace_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (workspace *Workspace) Owner() *genruntime.ResourceReference {
	if workspace.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(workspace.Spec)
	return workspace.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (workspace *Workspace) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Workspace_STATUS); ok {
		workspace.Status = *st
		return nil
	}

	// Convert status to required version
	var st Workspace_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	workspace.Status = st
	return nil
}

// AssignProperties_From_Workspace populates our Workspace from the provided source Workspace
func (workspace *Workspace) AssignProperties_From_Workspace(source *storage.Workspace) error {

	// ObjectMeta
	workspace.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Workspace_Spec
	err := spec.AssignProperties_From_Workspace_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Workspace_Spec() to populate field Spec")
	}
	workspace.Spec = spec

	// Status
	var status Workspace_STATUS
	err = status.AssignProperties_From_Workspace_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_Workspace_STATUS() to populate field Status")
	}
	workspace.Status = status

	// No error
	return nil
}

// AssignProperties_To_Workspace populates the provided destination Workspace from our Workspace
func (workspace *Workspace) AssignProperties_To_Workspace(destination *storage.Workspace) error {

	// ObjectMeta
	destination.ObjectMeta = *workspace.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.Workspace_Spec
	err := workspace.Spec.AssignProperties_To_Workspace_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Workspace_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.Workspace_STATUS
	err = workspace.Status.AssignProperties_To_Workspace_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_Workspace_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (workspace *Workspace) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: workspace.Spec.OriginalVersion(),
		Kind:    "Workspace",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /databricks/resource-manager/Microsoft.Databricks/stable/2024-05-01/databricks.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Databricks/workspaces/{workspaceName}
type WorkspaceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Workspace `json:"items"`
}

type Workspace_Spec struct {
	// AccessConnector: Access Connector Resource that is going to be associated with Databricks Workspace
	AccessConnector *WorkspaceProperties_AccessConnector `json:"accessConnector,omitempty"`

	// Authorizations: The workspace provider authorizations.
	Authorizations []WorkspaceProviderAuthorization `json:"authorizations,omitempty"`

	// +kubebuilder:validation:MaxLength=64
	// +kubebuilder:validation:MinLength=3
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// CreatedDateTime: Specifies the date and time when the workspace is created.
	CreatedDateTime *string `json:"createdDateTime,omitempty"`

	// DefaultCatalog: Properties for Default Catalog configuration during workspace creation.
	DefaultCatalog *DefaultCatalogProperties `json:"defaultCatalog,omitempty"`

	// DefaultStorageFirewall: Gets or Sets Default Storage Firewall configuration information
	DefaultStorageFirewall *WorkspaceProperties_DefaultStorageFirewall `json:"defaultStorageFirewall,omitempty"`

	// Encryption: Encryption properties for databricks workspace
	Encryption *WorkspaceProperties_Encryption `json:"encryption,omitempty"`

	// EnhancedSecurityCompliance: Contains settings related to the Enhanced Security and Compliance Add-On.
	EnhancedSecurityCompliance *EnhancedSecurityComplianceDefinition `json:"enhancedSecurityCompliance,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// +kubebuilder:validation:Required
	// ManagedResourceGroupId: The managed resource group Id.
	ManagedResourceGroupId *string `json:"managedResourceGroupId,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *WorkspaceOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// Parameters: The workspace's custom parameters.
	Parameters *WorkspaceCustomParameters `json:"parameters,omitempty"`

	// PublicNetworkAccess: The network access type for accessing workspace. Set value to disabled to access workspace only via
	// private link.
	PublicNetworkAccess *WorkspaceProperties_PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// RequiredNsgRules: Gets or sets a value indicating whether data plane (clusters) to control plane communication happen
	// over private endpoint. Supported values are 'AllRules' and 'NoAzureDatabricksRules'. 'NoAzureServiceRules' value is for
	// internal use only.
	RequiredNsgRules *WorkspaceProperties_RequiredNsgRules `json:"requiredNsgRules,omitempty"`

	// Sku: The SKU of the resource.
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// UiDefinitionUri: The blob URI where the UI definition file is located.
	UiDefinitionUri *string `json:"uiDefinitionUri,omitempty"`
}

var _ genruntime.ARMTransformer = &Workspace_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (workspace *Workspace_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if workspace == nil {
		return nil, nil
	}
	result := &arm.Workspace_Spec{}

	// Set property "Location":
	if workspace.Location != nil {
		location := *workspace.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if workspace.AccessConnector != nil ||
		workspace.Authorizations != nil ||
		workspace.CreatedDateTime != nil ||
		workspace.DefaultCatalog != nil ||
		workspace.DefaultStorageFirewall != nil ||
		workspace.Encryption != nil ||
		workspace.EnhancedSecurityCompliance != nil ||
		workspace.ManagedResourceGroupId != nil ||
		workspace.Parameters != nil ||
		workspace.PublicNetworkAccess != nil ||
		workspace.RequiredNsgRules != nil ||
		workspace.UiDefinitionUri != nil {
		result.Properties = &arm.WorkspaceProperties{}
	}
	if workspace.AccessConnector != nil {
		accessConnector_ARM, err := workspace.AccessConnector.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		accessConnector := *accessConnector_ARM.(*arm.WorkspaceProperties_AccessConnector)
		result.Properties.AccessConnector = &accessConnector
	}
	for _, item := range workspace.Authorizations {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Authorizations = append(result.Properties.Authorizations, *item_ARM.(*arm.WorkspaceProviderAuthorization))
	}
	if workspace.CreatedDateTime != nil {
		createdDateTime := *workspace.CreatedDateTime
		result.Properties.CreatedDateTime = &createdDateTime
	}
	if workspace.DefaultCatalog != nil {
		defaultCatalog_ARM, err := workspace.DefaultCatalog.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		defaultCatalog := *defaultCatalog_ARM.(*arm.DefaultCatalogProperties)
		result.Properties.DefaultCatalog = &defaultCatalog
	}
	if workspace.DefaultStorageFirewall != nil {
		var temp string
		temp = string(*workspace.DefaultStorageFirewall)
		defaultStorageFirewall := arm.WorkspaceProperties_DefaultStorageFirewall(temp)
		result.Properties.DefaultStorageFirewall = &defaultStorageFirewall
	}
	if workspace.Encryption != nil {
		encryption_ARM, err := workspace.Encryption.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryption := *encryption_ARM.(*arm.WorkspaceProperties_Encryption)
		result.Properties.Encryption = &encryption
	}
	if workspace.EnhancedSecurityCompliance != nil {
		enhancedSecurityCompliance_ARM, err := workspace.EnhancedSecurityCompliance.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		enhancedSecurityCompliance := *enhancedSecurityCompliance_ARM.(*arm.EnhancedSecurityComplianceDefinition)
		result.Properties.EnhancedSecurityCompliance = &enhancedSecurityCompliance
	}
	if workspace.ManagedResourceGroupId != nil {
		managedResourceGroupId := *workspace.ManagedResourceGroupId
		result.Properties.ManagedResourceGroupId = &managedResourceGroupId
	}
	if workspace.Parameters != nil {
		parameters_ARM, err := workspace.Parameters.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*arm.WorkspaceCustomParameters)
		result.Properties.Parameters = &parameters
	}
	if workspace.PublicNetworkAccess != nil {
		var temp string
		temp = string(*workspace.PublicNetworkAccess)
		publicNetworkAccess := arm.WorkspaceProperties_PublicNetworkAccess(temp)
		result.Properties.PublicNetworkAccess = &publicNetworkAccess
	}
	if workspace.RequiredNsgRules != nil {
		var temp string
		temp = string(*workspace.RequiredNsgRules)
		requiredNsgRules := arm.WorkspaceProperties_RequiredNsgRules(temp)
		result.Properties.RequiredNsgRules = &requiredNsgRules
	}
	if workspace.UiDefinitionUri != nil {
		uiDefinitionUri := *workspace.UiDefinitionUri
		result.Properties.UiDefinitionUri = &uiDefinitionUri
	}

	// Set property "Sku":
	if workspace.Sku != nil {
		sku_ARM, err := workspace.Sku.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.Sku)
		result.Sku = &sku
	}

	// Set property "Tags":
	if workspace.Tags != nil {
		result.Tags = make(map[string]string, len(workspace.Tags))
		for key, value := range workspace.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (workspace *Workspace_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Workspace_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (workspace *Workspace_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Workspace_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Workspace_Spec, got %T", armInput)
	}

	// Set property "AccessConnector":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AccessConnector != nil {
			var accessConnector1 WorkspaceProperties_AccessConnector
			err := accessConnector1.PopulateFromARM(owner, *typedInput.Properties.AccessConnector)
			if err != nil {
				return err
			}
			accessConnector := accessConnector1
			workspace.AccessConnector = &accessConnector
		}
	}

	// Set property "Authorizations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Authorizations {
			var item1 WorkspaceProviderAuthorization
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			workspace.Authorizations = append(workspace.Authorizations, item1)
		}
	}

	// Set property "AzureName":
	workspace.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "CreatedDateTime":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CreatedDateTime != nil {
			createdDateTime := *typedInput.Properties.CreatedDateTime
			workspace.CreatedDateTime = &createdDateTime
		}
	}

	// Set property "DefaultCatalog":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultCatalog != nil {
			var defaultCatalog1 DefaultCatalogProperties
			err := defaultCatalog1.PopulateFromARM(owner, *typedInput.Properties.DefaultCatalog)
			if err != nil {
				return err
			}
			defaultCatalog := defaultCatalog1
			workspace.DefaultCatalog = &defaultCatalog
		}
	}

	// Set property "DefaultStorageFirewall":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultStorageFirewall != nil {
			var temp string
			temp = string(*typedInput.Properties.DefaultStorageFirewall)
			defaultStorageFirewall := WorkspaceProperties_DefaultStorageFirewall(temp)
			workspace.DefaultStorageFirewall = &defaultStorageFirewall
		}
	}

	// Set property "Encryption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Encryption != nil {
			var encryption1 WorkspaceProperties_Encryption
			err := encryption1.PopulateFromARM(owner, *typedInput.Properties.Encryption)
			if err != nil {
				return err
			}
			encryption := encryption1
			workspace.Encryption = &encryption
		}
	}

	// Set property "EnhancedSecurityCompliance":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnhancedSecurityCompliance != nil {
			var enhancedSecurityCompliance1 EnhancedSecurityComplianceDefinition
			err := enhancedSecurityCompliance1.PopulateFromARM(owner, *typedInput.Properties.EnhancedSecurityCompliance)
			if err != nil {
				return err
			}
			enhancedSecurityCompliance := enhancedSecurityCompliance1
			workspace.EnhancedSecurityCompliance = &enhancedSecurityCompliance
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		workspace.Location = &location
	}

	// Set property "ManagedResourceGroupId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedResourceGroupId != nil {
			managedResourceGroupId := *typedInput.Properties.ManagedResourceGroupId
			workspace.ManagedResourceGroupId = &managedResourceGroupId
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	workspace.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Parameters":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Parameters != nil {
			var parameters1 WorkspaceCustomParameters
			err := parameters1.PopulateFromARM(owner, *typedInput.Properties.Parameters)
			if err != nil {
				return err
			}
			parameters := parameters1
			workspace.Parameters = &parameters
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicNetworkAccess)
			publicNetworkAccess := WorkspaceProperties_PublicNetworkAccess(temp)
			workspace.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "RequiredNsgRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequiredNsgRules != nil {
			var temp string
			temp = string(*typedInput.Properties.RequiredNsgRules)
			requiredNsgRules := WorkspaceProperties_RequiredNsgRules(temp)
			workspace.RequiredNsgRules = &requiredNsgRules
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		workspace.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		workspace.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			workspace.Tags[key] = value
		}
	}

	// Set property "UiDefinitionUri":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UiDefinitionUri != nil {
			uiDefinitionUri := *typedInput.Properties.UiDefinitionUri
			workspace.UiDefinitionUri = &uiDefinitionUri
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Workspace_Spec{}

// ConvertSpecFrom populates our Workspace_Spec from the provided source
func (workspace *Workspace_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.Workspace_Spec)
	if ok {
		// Populate our instance from source
		return workspace.AssignProperties_From_Workspace_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.Workspace_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = workspace.AssignProperties_From_Workspace_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Workspace_Spec
func (workspace *Workspace_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.Workspace_Spec)
	if ok {
		// Populate destination from our instance
		return workspace.AssignProperties_To_Workspace_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Workspace_Spec{}
	err := workspace.AssignProperties_To_Workspace_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Workspace_Spec populates our Workspace_Spec from the provided source Workspace_Spec
func (workspace *Workspace_Spec) AssignProperties_From_Workspace_Spec(source *storage.Workspace_Spec) error {

	// AccessConnector
	if source.AccessConnector != nil {
		var accessConnector WorkspaceProperties_AccessConnector
		err := accessConnector.AssignProperties_From_WorkspaceProperties_AccessConnector(source.AccessConnector)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceProperties_AccessConnector() to populate field AccessConnector")
		}
		workspace.AccessConnector = &accessConnector
	} else {
		workspace.AccessConnector = nil
	}

	// Authorizations
	if source.Authorizations != nil {
		authorizationList := make([]WorkspaceProviderAuthorization, len(source.Authorizations))
		for authorizationIndex, authorizationItem := range source.Authorizations {
			var authorization WorkspaceProviderAuthorization
			err := authorization.AssignProperties_From_WorkspaceProviderAuthorization(&authorizationItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_WorkspaceProviderAuthorization() to populate field Authorizations")
			}
			authorizationList[authorizationIndex] = authorization
		}
		workspace.Authorizations = authorizationList
	} else {
		workspace.Authorizations = nil
	}

	// AzureName
	workspace.AzureName = source.AzureName

	// CreatedDateTime
	workspace.CreatedDateTime = genruntime.ClonePointerToString(source.CreatedDateTime)

	// DefaultCatalog
	if source.DefaultCatalog != nil {
		var defaultCatalog DefaultCatalogProperties
		err := defaultCatalog.AssignProperties_From_DefaultCatalogProperties(source.DefaultCatalog)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DefaultCatalogProperties() to populate field DefaultCatalog")
		}
		workspace.DefaultCatalog = &defaultCatalog
	} else {
		workspace.DefaultCatalog = nil
	}

	// DefaultStorageFirewall
	if source.DefaultStorageFirewall != nil {
		defaultStorageFirewall := *source.DefaultStorageFirewall
		defaultStorageFirewallTemp := genruntime.ToEnum(defaultStorageFirewall, workspaceProperties_DefaultStorageFirewall_Values)
		workspace.DefaultStorageFirewall = &defaultStorageFirewallTemp
	} else {
		workspace.DefaultStorageFirewall = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption WorkspaceProperties_Encryption
		err := encryption.AssignProperties_From_WorkspaceProperties_Encryption(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceProperties_Encryption() to populate field Encryption")
		}
		workspace.Encryption = &encryption
	} else {
		workspace.Encryption = nil
	}

	// EnhancedSecurityCompliance
	if source.EnhancedSecurityCompliance != nil {
		var enhancedSecurityCompliance EnhancedSecurityComplianceDefinition
		err := enhancedSecurityCompliance.AssignProperties_From_EnhancedSecurityComplianceDefinition(source.EnhancedSecurityCompliance)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EnhancedSecurityComplianceDefinition() to populate field EnhancedSecurityCompliance")
		}
		workspace.EnhancedSecurityCompliance = &enhancedSecurityCompliance
	} else {
		workspace.EnhancedSecurityCompliance = nil
	}

	// Location
	workspace.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedResourceGroupId
	workspace.ManagedResourceGroupId = genruntime.ClonePointerToString(source.ManagedResourceGroupId)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec WorkspaceOperatorSpec
		err := operatorSpec.AssignProperties_From_WorkspaceOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceOperatorSpec() to populate field OperatorSpec")
		}
		workspace.OperatorSpec = &operatorSpec
	} else {
		workspace.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		workspace.Owner = &owner
	} else {
		workspace.Owner = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter WorkspaceCustomParameters
		err := parameter.AssignProperties_From_WorkspaceCustomParameters(source.Parameters)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomParameters() to populate field Parameters")
		}
		workspace.Parameters = &parameter
	} else {
		workspace.Parameters = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, workspaceProperties_PublicNetworkAccess_Values)
		workspace.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		workspace.PublicNetworkAccess = nil
	}

	// RequiredNsgRules
	if source.RequiredNsgRules != nil {
		requiredNsgRule := *source.RequiredNsgRules
		requiredNsgRuleTemp := genruntime.ToEnum(requiredNsgRule, workspaceProperties_RequiredNsgRules_Values)
		workspace.RequiredNsgRules = &requiredNsgRuleTemp
	} else {
		workspace.RequiredNsgRules = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		workspace.Sku = &sku
	} else {
		workspace.Sku = nil
	}

	// Tags
	workspace.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UiDefinitionUri
	workspace.UiDefinitionUri = genruntime.ClonePointerToString(source.UiDefinitionUri)

	// No error
	return nil
}

// AssignProperties_To_Workspace_Spec populates the provided destination Workspace_Spec from our Workspace_Spec
func (workspace *Workspace_Spec) AssignProperties_To_Workspace_Spec(destination *storage.Workspace_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccessConnector
	if workspace.AccessConnector != nil {
		var accessConnector storage.WorkspaceProperties_AccessConnector
		err := workspace.AccessConnector.AssignProperties_To_WorkspaceProperties_AccessConnector(&accessConnector)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceProperties_AccessConnector() to populate field AccessConnector")
		}
		destination.AccessConnector = &accessConnector
	} else {
		destination.AccessConnector = nil
	}

	// Authorizations
	if workspace.Authorizations != nil {
		authorizationList := make([]storage.WorkspaceProviderAuthorization, len(workspace.Authorizations))
		for authorizationIndex, authorizationItem := range workspace.Authorizations {
			var authorization storage.WorkspaceProviderAuthorization
			err := authorizationItem.AssignProperties_To_WorkspaceProviderAuthorization(&authorization)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_WorkspaceProviderAuthorization() to populate field Authorizations")
			}
			authorizationList[authorizationIndex] = authorization
		}
		destination.Authorizations = authorizationList
	} else {
		destination.Authorizations = nil
	}

	// AzureName
	destination.AzureName = workspace.AzureName

	// CreatedDateTime
	destination.CreatedDateTime = genruntime.ClonePointerToString(workspace.CreatedDateTime)

	// DefaultCatalog
	if workspace.DefaultCatalog != nil {
		var defaultCatalog storage.DefaultCatalogProperties
		err := workspace.DefaultCatalog.AssignProperties_To_DefaultCatalogProperties(&defaultCatalog)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DefaultCatalogProperties() to populate field DefaultCatalog")
		}
		destination.DefaultCatalog = &defaultCatalog
	} else {
		destination.DefaultCatalog = nil
	}

	// DefaultStorageFirewall
	if workspace.DefaultStorageFirewall != nil {
		defaultStorageFirewall := string(*workspace.DefaultStorageFirewall)
		destination.DefaultStorageFirewall = &defaultStorageFirewall
	} else {
		destination.DefaultStorageFirewall = nil
	}

	// Encryption
	if workspace.Encryption != nil {
		var encryption storage.WorkspaceProperties_Encryption
		err := workspace.Encryption.AssignProperties_To_WorkspaceProperties_Encryption(&encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceProperties_Encryption() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// EnhancedSecurityCompliance
	if workspace.EnhancedSecurityCompliance != nil {
		var enhancedSecurityCompliance storage.EnhancedSecurityComplianceDefinition
		err := workspace.EnhancedSecurityCompliance.AssignProperties_To_EnhancedSecurityComplianceDefinition(&enhancedSecurityCompliance)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EnhancedSecurityComplianceDefinition() to populate field EnhancedSecurityCompliance")
		}
		destination.EnhancedSecurityCompliance = &enhancedSecurityCompliance
	} else {
		destination.EnhancedSecurityCompliance = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(workspace.Location)

	// ManagedResourceGroupId
	destination.ManagedResourceGroupId = genruntime.ClonePointerToString(workspace.ManagedResourceGroupId)

	// OperatorSpec
	if workspace.OperatorSpec != nil {
		var operatorSpec storage.WorkspaceOperatorSpec
		err := workspace.OperatorSpec.AssignProperties_To_WorkspaceOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = workspace.OriginalVersion()

	// Owner
	if workspace.Owner != nil {
		owner := workspace.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Parameters
	if workspace.Parameters != nil {
		var parameter storage.WorkspaceCustomParameters
		err := workspace.Parameters.AssignProperties_To_WorkspaceCustomParameters(&parameter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// PublicNetworkAccess
	if workspace.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*workspace.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// RequiredNsgRules
	if workspace.RequiredNsgRules != nil {
		requiredNsgRule := string(*workspace.RequiredNsgRules)
		destination.RequiredNsgRules = &requiredNsgRule
	} else {
		destination.RequiredNsgRules = nil
	}

	// Sku
	if workspace.Sku != nil {
		var sku storage.Sku
		err := workspace.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(workspace.Tags)

	// UiDefinitionUri
	destination.UiDefinitionUri = genruntime.ClonePointerToString(workspace.UiDefinitionUri)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Workspace_STATUS populates our Workspace_Spec from the provided source Workspace_STATUS
func (workspace *Workspace_Spec) Initialize_From_Workspace_STATUS(source *Workspace_STATUS) error {

	// AccessConnector
	if source.AccessConnector != nil {
		var accessConnector WorkspaceProperties_AccessConnector
		err := accessConnector.Initialize_From_WorkspaceProperties_AccessConnector_STATUS(source.AccessConnector)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceProperties_AccessConnector_STATUS() to populate field AccessConnector")
		}
		workspace.AccessConnector = &accessConnector
	} else {
		workspace.AccessConnector = nil
	}

	// Authorizations
	if source.Authorizations != nil {
		authorizationList := make([]WorkspaceProviderAuthorization, len(source.Authorizations))
		for authorizationIndex, authorizationItem := range source.Authorizations {
			var authorization WorkspaceProviderAuthorization
			err := authorization.Initialize_From_WorkspaceProviderAuthorization_STATUS(&authorizationItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_WorkspaceProviderAuthorization_STATUS() to populate field Authorizations")
			}
			authorizationList[authorizationIndex] = authorization
		}
		workspace.Authorizations = authorizationList
	} else {
		workspace.Authorizations = nil
	}

	// CreatedDateTime
	workspace.CreatedDateTime = genruntime.ClonePointerToString(source.CreatedDateTime)

	// DefaultCatalog
	if source.DefaultCatalog != nil {
		var defaultCatalog DefaultCatalogProperties
		err := defaultCatalog.Initialize_From_DefaultCatalogProperties_STATUS(source.DefaultCatalog)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DefaultCatalogProperties_STATUS() to populate field DefaultCatalog")
		}
		workspace.DefaultCatalog = &defaultCatalog
	} else {
		workspace.DefaultCatalog = nil
	}

	// DefaultStorageFirewall
	if source.DefaultStorageFirewall != nil {
		defaultStorageFirewall := genruntime.ToEnum(string(*source.DefaultStorageFirewall), workspaceProperties_DefaultStorageFirewall_Values)
		workspace.DefaultStorageFirewall = &defaultStorageFirewall
	} else {
		workspace.DefaultStorageFirewall = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption WorkspaceProperties_Encryption
		err := encryption.Initialize_From_WorkspaceProperties_Encryption_STATUS(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceProperties_Encryption_STATUS() to populate field Encryption")
		}
		workspace.Encryption = &encryption
	} else {
		workspace.Encryption = nil
	}

	// EnhancedSecurityCompliance
	if source.EnhancedSecurityCompliance != nil {
		var enhancedSecurityCompliance EnhancedSecurityComplianceDefinition
		err := enhancedSecurityCompliance.Initialize_From_EnhancedSecurityComplianceDefinition_STATUS(source.EnhancedSecurityCompliance)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EnhancedSecurityComplianceDefinition_STATUS() to populate field EnhancedSecurityCompliance")
		}
		workspace.EnhancedSecurityCompliance = &enhancedSecurityCompliance
	} else {
		workspace.EnhancedSecurityCompliance = nil
	}

	// Location
	workspace.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedResourceGroupId
	workspace.ManagedResourceGroupId = genruntime.ClonePointerToString(source.ManagedResourceGroupId)

	// Parameters
	if source.Parameters != nil {
		var parameter WorkspaceCustomParameters
		err := parameter.Initialize_From_WorkspaceCustomParameters_STATUS(source.Parameters)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceCustomParameters_STATUS() to populate field Parameters")
		}
		workspace.Parameters = &parameter
	} else {
		workspace.Parameters = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := genruntime.ToEnum(string(*source.PublicNetworkAccess), workspaceProperties_PublicNetworkAccess_Values)
		workspace.PublicNetworkAccess = &publicNetworkAccess
	} else {
		workspace.PublicNetworkAccess = nil
	}

	// RequiredNsgRules
	if source.RequiredNsgRules != nil {
		requiredNsgRule := genruntime.ToEnum(string(*source.RequiredNsgRules), workspaceProperties_RequiredNsgRules_Values)
		workspace.RequiredNsgRules = &requiredNsgRule
	} else {
		workspace.RequiredNsgRules = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		workspace.Sku = &sku
	} else {
		workspace.Sku = nil
	}

	// Tags
	workspace.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UiDefinitionUri
	workspace.UiDefinitionUri = genruntime.ClonePointerToString(source.UiDefinitionUri)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (workspace *Workspace_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (workspace *Workspace_Spec) SetAzureName(azureName string) { workspace.AzureName = azureName }

// Information about workspace.
type Workspace_STATUS struct {
	// AccessConnector: Access Connector Resource that is going to be associated with Databricks Workspace
	AccessConnector *WorkspaceProperties_AccessConnector_STATUS `json:"accessConnector,omitempty"`

	// Authorizations: The workspace provider authorizations.
	Authorizations []WorkspaceProviderAuthorization_STATUS `json:"authorizations,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// CreatedBy: Indicates the Object ID, PUID and Application ID of entity that created the workspace.
	CreatedBy *CreatedBy_STATUS `json:"createdBy,omitempty"`

	// CreatedDateTime: Specifies the date and time when the workspace is created.
	CreatedDateTime *string `json:"createdDateTime,omitempty"`

	// DefaultCatalog: Properties for Default Catalog configuration during workspace creation.
	DefaultCatalog *DefaultCatalogProperties_STATUS `json:"defaultCatalog,omitempty"`

	// DefaultStorageFirewall: Gets or Sets Default Storage Firewall configuration information
	DefaultStorageFirewall *WorkspaceProperties_DefaultStorageFirewall_STATUS `json:"defaultStorageFirewall,omitempty"`

	// DiskEncryptionSetId: The resource Id of the managed disk encryption set.
	DiskEncryptionSetId *string `json:"diskEncryptionSetId,omitempty"`

	// Encryption: Encryption properties for databricks workspace
	Encryption *WorkspaceProperties_Encryption_STATUS `json:"encryption,omitempty"`

	// EnhancedSecurityCompliance: Contains settings related to the Enhanced Security and Compliance Add-On.
	EnhancedSecurityCompliance *EnhancedSecurityComplianceDefinition_STATUS `json:"enhancedSecurityCompliance,omitempty"`

	// Id: Fully qualified resource Id for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// IsUcEnabled: Indicates whether unity catalog enabled for the workspace or not.
	IsUcEnabled *bool `json:"isUcEnabled,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// ManagedDiskIdentity: The details of Managed Identity of Disk Encryption Set used for Managed Disk Encryption
	ManagedDiskIdentity *ManagedIdentityConfiguration_STATUS `json:"managedDiskIdentity,omitempty"`

	// ManagedResourceGroupId: The managed resource group Id.
	ManagedResourceGroupId *string `json:"managedResourceGroupId,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Parameters: The workspace's custom parameters.
	Parameters *WorkspaceCustomParameters_STATUS `json:"parameters,omitempty"`

	// PrivateEndpointConnections: Private endpoint connections created on the workspace
	PrivateEndpointConnections []PrivateEndpointConnection_STATUS `json:"privateEndpointConnections,omitempty"`

	// ProvisioningState: The workspace provisioning state.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// PublicNetworkAccess: The network access type for accessing workspace. Set value to disabled to access workspace only via
	// private link.
	PublicNetworkAccess *WorkspaceProperties_PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`

	// RequiredNsgRules: Gets or sets a value indicating whether data plane (clusters) to control plane communication happen
	// over private endpoint. Supported values are 'AllRules' and 'NoAzureDatabricksRules'. 'NoAzureServiceRules' value is for
	// internal use only.
	RequiredNsgRules *WorkspaceProperties_RequiredNsgRules_STATUS `json:"requiredNsgRules,omitempty"`

	// Sku: The SKU of the resource.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// StorageAccountIdentity: The details of Managed Identity of Storage Account
	StorageAccountIdentity *ManagedIdentityConfiguration_STATUS `json:"storageAccountIdentity,omitempty"`

	// SystemData: The system metadata relating to this resource
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty"`

	// UiDefinitionUri: The blob URI where the UI definition file is located.
	UiDefinitionUri *string `json:"uiDefinitionUri,omitempty"`

	// UpdatedBy: Indicates the Object ID, PUID and Application ID of entity that last updated the workspace.
	UpdatedBy *CreatedBy_STATUS `json:"updatedBy,omitempty"`

	// WorkspaceId: The unique identifier of the databricks workspace in databricks control plane.
	WorkspaceId *string `json:"workspaceId,omitempty"`

	// WorkspaceUrl: The workspace URL which is of the format 'adb-{workspaceId}.{random}.azuredatabricks.net'
	WorkspaceUrl *string `json:"workspaceUrl,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Workspace_STATUS{}

// ConvertStatusFrom populates our Workspace_STATUS from the provided source
func (workspace *Workspace_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.Workspace_STATUS)
	if ok {
		// Populate our instance from source
		return workspace.AssignProperties_From_Workspace_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.Workspace_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = workspace.AssignProperties_From_Workspace_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Workspace_STATUS
func (workspace *Workspace_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.Workspace_STATUS)
	if ok {
		// Populate destination from our instance
		return workspace.AssignProperties_To_Workspace_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.Workspace_STATUS{}
	err := workspace.AssignProperties_To_Workspace_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Workspace_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (workspace *Workspace_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Workspace_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (workspace *Workspace_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Workspace_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Workspace_STATUS, got %T", armInput)
	}

	// Set property "AccessConnector":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AccessConnector != nil {
			var accessConnector1 WorkspaceProperties_AccessConnector_STATUS
			err := accessConnector1.PopulateFromARM(owner, *typedInput.Properties.AccessConnector)
			if err != nil {
				return err
			}
			accessConnector := accessConnector1
			workspace.AccessConnector = &accessConnector
		}
	}

	// Set property "Authorizations":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Authorizations {
			var item1 WorkspaceProviderAuthorization_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			workspace.Authorizations = append(workspace.Authorizations, item1)
		}
	}

	// no assignment for property "Conditions"

	// Set property "CreatedBy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CreatedBy != nil {
			var createdBy1 CreatedBy_STATUS
			err := createdBy1.PopulateFromARM(owner, *typedInput.Properties.CreatedBy)
			if err != nil {
				return err
			}
			createdBy := createdBy1
			workspace.CreatedBy = &createdBy
		}
	}

	// Set property "CreatedDateTime":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CreatedDateTime != nil {
			createdDateTime := *typedInput.Properties.CreatedDateTime
			workspace.CreatedDateTime = &createdDateTime
		}
	}

	// Set property "DefaultCatalog":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultCatalog != nil {
			var defaultCatalog1 DefaultCatalogProperties_STATUS
			err := defaultCatalog1.PopulateFromARM(owner, *typedInput.Properties.DefaultCatalog)
			if err != nil {
				return err
			}
			defaultCatalog := defaultCatalog1
			workspace.DefaultCatalog = &defaultCatalog
		}
	}

	// Set property "DefaultStorageFirewall":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultStorageFirewall != nil {
			var temp string
			temp = string(*typedInput.Properties.DefaultStorageFirewall)
			defaultStorageFirewall := WorkspaceProperties_DefaultStorageFirewall_STATUS(temp)
			workspace.DefaultStorageFirewall = &defaultStorageFirewall
		}
	}

	// Set property "DiskEncryptionSetId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DiskEncryptionSetId != nil {
			diskEncryptionSetId := *typedInput.Properties.DiskEncryptionSetId
			workspace.DiskEncryptionSetId = &diskEncryptionSetId
		}
	}

	// Set property "Encryption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Encryption != nil {
			var encryption1 WorkspaceProperties_Encryption_STATUS
			err := encryption1.PopulateFromARM(owner, *typedInput.Properties.Encryption)
			if err != nil {
				return err
			}
			encryption := encryption1
			workspace.Encryption = &encryption
		}
	}

	// Set property "EnhancedSecurityCompliance":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EnhancedSecurityCompliance != nil {
			var enhancedSecurityCompliance1 EnhancedSecurityComplianceDefinition_STATUS
			err := enhancedSecurityCompliance1.PopulateFromARM(owner, *typedInput.Properties.EnhancedSecurityCompliance)
			if err != nil {
				return err
			}
			enhancedSecurityCompliance := enhancedSecurityCompliance1
			workspace.EnhancedSecurityCompliance = &enhancedSecurityCompliance
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		workspace.Id = &id
	}

	// Set property "IsUcEnabled":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsUcEnabled != nil {
			isUcEnabled := *typedInput.Properties.IsUcEnabled
			workspace.IsUcEnabled = &isUcEnabled
		}
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		workspace.Location = &location
	}

	// Set property "ManagedDiskIdentity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedDiskIdentity != nil {
			var managedDiskIdentity1 ManagedIdentityConfiguration_STATUS
			err := managedDiskIdentity1.PopulateFromARM(owner, *typedInput.Properties.ManagedDiskIdentity)
			if err != nil {
				return err
			}
			managedDiskIdentity := managedDiskIdentity1
			workspace.ManagedDiskIdentity = &managedDiskIdentity
		}
	}

	// Set property "ManagedResourceGroupId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ManagedResourceGroupId != nil {
			managedResourceGroupId := *typedInput.Properties.ManagedResourceGroupId
			workspace.ManagedResourceGroupId = &managedResourceGroupId
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		workspace.Name = &name
	}

	// Set property "Parameters":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Parameters != nil {
			var parameters1 WorkspaceCustomParameters_STATUS
			err := parameters1.PopulateFromARM(owner, *typedInput.Properties.Parameters)
			if err != nil {
				return err
			}
			parameters := parameters1
			workspace.Parameters = &parameters
		}
	}

	// Set property "PrivateEndpointConnections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateEndpointConnections {
			var item1 PrivateEndpointConnection_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			workspace.PrivateEndpointConnections = append(workspace.PrivateEndpointConnections, item1)
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ProvisioningState_STATUS(temp)
			workspace.ProvisioningState = &provisioningState
		}
	}

	// Set property "PublicNetworkAccess":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			var temp string
			temp = string(*typedInput.Properties.PublicNetworkAccess)
			publicNetworkAccess := WorkspaceProperties_PublicNetworkAccess_STATUS(temp)
			workspace.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property "RequiredNsgRules":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RequiredNsgRules != nil {
			var temp string
			temp = string(*typedInput.Properties.RequiredNsgRules)
			requiredNsgRules := WorkspaceProperties_RequiredNsgRules_STATUS(temp)
			workspace.RequiredNsgRules = &requiredNsgRules
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		workspace.Sku = &sku
	}

	// Set property "StorageAccountIdentity":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageAccountIdentity != nil {
			var storageAccountIdentity1 ManagedIdentityConfiguration_STATUS
			err := storageAccountIdentity1.PopulateFromARM(owner, *typedInput.Properties.StorageAccountIdentity)
			if err != nil {
				return err
			}
			storageAccountIdentity := storageAccountIdentity1
			workspace.StorageAccountIdentity = &storageAccountIdentity
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		workspace.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		workspace.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			workspace.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		workspace.Type = &typeVar
	}

	// Set property "UiDefinitionUri":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UiDefinitionUri != nil {
			uiDefinitionUri := *typedInput.Properties.UiDefinitionUri
			workspace.UiDefinitionUri = &uiDefinitionUri
		}
	}

	// Set property "UpdatedBy":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UpdatedBy != nil {
			var updatedBy1 CreatedBy_STATUS
			err := updatedBy1.PopulateFromARM(owner, *typedInput.Properties.UpdatedBy)
			if err != nil {
				return err
			}
			updatedBy := updatedBy1
			workspace.UpdatedBy = &updatedBy
		}
	}

	// Set property "WorkspaceId":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WorkspaceId != nil {
			workspaceId := *typedInput.Properties.WorkspaceId
			workspace.WorkspaceId = &workspaceId
		}
	}

	// Set property "WorkspaceUrl":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WorkspaceUrl != nil {
			workspaceUrl := *typedInput.Properties.WorkspaceUrl
			workspace.WorkspaceUrl = &workspaceUrl
		}
	}

	// No error
	return nil
}

// AssignProperties_From_Workspace_STATUS populates our Workspace_STATUS from the provided source Workspace_STATUS
func (workspace *Workspace_STATUS) AssignProperties_From_Workspace_STATUS(source *storage.Workspace_STATUS) error {

	// AccessConnector
	if source.AccessConnector != nil {
		var accessConnector WorkspaceProperties_AccessConnector_STATUS
		err := accessConnector.AssignProperties_From_WorkspaceProperties_AccessConnector_STATUS(source.AccessConnector)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceProperties_AccessConnector_STATUS() to populate field AccessConnector")
		}
		workspace.AccessConnector = &accessConnector
	} else {
		workspace.AccessConnector = nil
	}

	// Authorizations
	if source.Authorizations != nil {
		authorizationList := make([]WorkspaceProviderAuthorization_STATUS, len(source.Authorizations))
		for authorizationIndex, authorizationItem := range source.Authorizations {
			var authorization WorkspaceProviderAuthorization_STATUS
			err := authorization.AssignProperties_From_WorkspaceProviderAuthorization_STATUS(&authorizationItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_WorkspaceProviderAuthorization_STATUS() to populate field Authorizations")
			}
			authorizationList[authorizationIndex] = authorization
		}
		workspace.Authorizations = authorizationList
	} else {
		workspace.Authorizations = nil
	}

	// Conditions
	workspace.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// CreatedBy
	if source.CreatedBy != nil {
		var createdBy CreatedBy_STATUS
		err := createdBy.AssignProperties_From_CreatedBy_STATUS(source.CreatedBy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CreatedBy_STATUS() to populate field CreatedBy")
		}
		workspace.CreatedBy = &createdBy
	} else {
		workspace.CreatedBy = nil
	}

	// CreatedDateTime
	workspace.CreatedDateTime = genruntime.ClonePointerToString(source.CreatedDateTime)

	// DefaultCatalog
	if source.DefaultCatalog != nil {
		var defaultCatalog DefaultCatalogProperties_STATUS
		err := defaultCatalog.AssignProperties_From_DefaultCatalogProperties_STATUS(source.DefaultCatalog)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DefaultCatalogProperties_STATUS() to populate field DefaultCatalog")
		}
		workspace.DefaultCatalog = &defaultCatalog
	} else {
		workspace.DefaultCatalog = nil
	}

	// DefaultStorageFirewall
	if source.DefaultStorageFirewall != nil {
		defaultStorageFirewall := *source.DefaultStorageFirewall
		defaultStorageFirewallTemp := genruntime.ToEnum(defaultStorageFirewall, workspaceProperties_DefaultStorageFirewall_STATUS_Values)
		workspace.DefaultStorageFirewall = &defaultStorageFirewallTemp
	} else {
		workspace.DefaultStorageFirewall = nil
	}

	// DiskEncryptionSetId
	workspace.DiskEncryptionSetId = genruntime.ClonePointerToString(source.DiskEncryptionSetId)

	// Encryption
	if source.Encryption != nil {
		var encryption WorkspaceProperties_Encryption_STATUS
		err := encryption.AssignProperties_From_WorkspaceProperties_Encryption_STATUS(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceProperties_Encryption_STATUS() to populate field Encryption")
		}
		workspace.Encryption = &encryption
	} else {
		workspace.Encryption = nil
	}

	// EnhancedSecurityCompliance
	if source.EnhancedSecurityCompliance != nil {
		var enhancedSecurityCompliance EnhancedSecurityComplianceDefinition_STATUS
		err := enhancedSecurityCompliance.AssignProperties_From_EnhancedSecurityComplianceDefinition_STATUS(source.EnhancedSecurityCompliance)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EnhancedSecurityComplianceDefinition_STATUS() to populate field EnhancedSecurityCompliance")
		}
		workspace.EnhancedSecurityCompliance = &enhancedSecurityCompliance
	} else {
		workspace.EnhancedSecurityCompliance = nil
	}

	// Id
	workspace.Id = genruntime.ClonePointerToString(source.Id)

	// IsUcEnabled
	if source.IsUcEnabled != nil {
		isUcEnabled := *source.IsUcEnabled
		workspace.IsUcEnabled = &isUcEnabled
	} else {
		workspace.IsUcEnabled = nil
	}

	// Location
	workspace.Location = genruntime.ClonePointerToString(source.Location)

	// ManagedDiskIdentity
	if source.ManagedDiskIdentity != nil {
		var managedDiskIdentity ManagedIdentityConfiguration_STATUS
		err := managedDiskIdentity.AssignProperties_From_ManagedIdentityConfiguration_STATUS(source.ManagedDiskIdentity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedIdentityConfiguration_STATUS() to populate field ManagedDiskIdentity")
		}
		workspace.ManagedDiskIdentity = &managedDiskIdentity
	} else {
		workspace.ManagedDiskIdentity = nil
	}

	// ManagedResourceGroupId
	workspace.ManagedResourceGroupId = genruntime.ClonePointerToString(source.ManagedResourceGroupId)

	// Name
	workspace.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter WorkspaceCustomParameters_STATUS
		err := parameter.AssignProperties_From_WorkspaceCustomParameters_STATUS(source.Parameters)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomParameters_STATUS() to populate field Parameters")
		}
		workspace.Parameters = &parameter
	} else {
		workspace.Parameters = nil
	}

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]PrivateEndpointConnection_STATUS, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			var privateEndpointConnection PrivateEndpointConnection_STATUS
			err := privateEndpointConnection.AssignProperties_From_PrivateEndpointConnection_STATUS(&privateEndpointConnectionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		workspace.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		workspace.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, provisioningState_STATUS_Values)
		workspace.ProvisioningState = &provisioningStateTemp
	} else {
		workspace.ProvisioningState = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := *source.PublicNetworkAccess
		publicNetworkAccessTemp := genruntime.ToEnum(publicNetworkAccess, workspaceProperties_PublicNetworkAccess_STATUS_Values)
		workspace.PublicNetworkAccess = &publicNetworkAccessTemp
	} else {
		workspace.PublicNetworkAccess = nil
	}

	// RequiredNsgRules
	if source.RequiredNsgRules != nil {
		requiredNsgRule := *source.RequiredNsgRules
		requiredNsgRuleTemp := genruntime.ToEnum(requiredNsgRule, workspaceProperties_RequiredNsgRules_STATUS_Values)
		workspace.RequiredNsgRules = &requiredNsgRuleTemp
	} else {
		workspace.RequiredNsgRules = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		workspace.Sku = &sku
	} else {
		workspace.Sku = nil
	}

	// StorageAccountIdentity
	if source.StorageAccountIdentity != nil {
		var storageAccountIdentity ManagedIdentityConfiguration_STATUS
		err := storageAccountIdentity.AssignProperties_From_ManagedIdentityConfiguration_STATUS(source.StorageAccountIdentity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedIdentityConfiguration_STATUS() to populate field StorageAccountIdentity")
		}
		workspace.StorageAccountIdentity = &storageAccountIdentity
	} else {
		workspace.StorageAccountIdentity = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		workspace.SystemData = &systemDatum
	} else {
		workspace.SystemData = nil
	}

	// Tags
	workspace.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	workspace.Type = genruntime.ClonePointerToString(source.Type)

	// UiDefinitionUri
	workspace.UiDefinitionUri = genruntime.ClonePointerToString(source.UiDefinitionUri)

	// UpdatedBy
	if source.UpdatedBy != nil {
		var updatedBy CreatedBy_STATUS
		err := updatedBy.AssignProperties_From_CreatedBy_STATUS(source.UpdatedBy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CreatedBy_STATUS() to populate field UpdatedBy")
		}
		workspace.UpdatedBy = &updatedBy
	} else {
		workspace.UpdatedBy = nil
	}

	// WorkspaceId
	workspace.WorkspaceId = genruntime.ClonePointerToString(source.WorkspaceId)

	// WorkspaceUrl
	workspace.WorkspaceUrl = genruntime.ClonePointerToString(source.WorkspaceUrl)

	// No error
	return nil
}

// AssignProperties_To_Workspace_STATUS populates the provided destination Workspace_STATUS from our Workspace_STATUS
func (workspace *Workspace_STATUS) AssignProperties_To_Workspace_STATUS(destination *storage.Workspace_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AccessConnector
	if workspace.AccessConnector != nil {
		var accessConnector storage.WorkspaceProperties_AccessConnector_STATUS
		err := workspace.AccessConnector.AssignProperties_To_WorkspaceProperties_AccessConnector_STATUS(&accessConnector)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceProperties_AccessConnector_STATUS() to populate field AccessConnector")
		}
		destination.AccessConnector = &accessConnector
	} else {
		destination.AccessConnector = nil
	}

	// Authorizations
	if workspace.Authorizations != nil {
		authorizationList := make([]storage.WorkspaceProviderAuthorization_STATUS, len(workspace.Authorizations))
		for authorizationIndex, authorizationItem := range workspace.Authorizations {
			var authorization storage.WorkspaceProviderAuthorization_STATUS
			err := authorizationItem.AssignProperties_To_WorkspaceProviderAuthorization_STATUS(&authorization)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_WorkspaceProviderAuthorization_STATUS() to populate field Authorizations")
			}
			authorizationList[authorizationIndex] = authorization
		}
		destination.Authorizations = authorizationList
	} else {
		destination.Authorizations = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(workspace.Conditions)

	// CreatedBy
	if workspace.CreatedBy != nil {
		var createdBy storage.CreatedBy_STATUS
		err := workspace.CreatedBy.AssignProperties_To_CreatedBy_STATUS(&createdBy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CreatedBy_STATUS() to populate field CreatedBy")
		}
		destination.CreatedBy = &createdBy
	} else {
		destination.CreatedBy = nil
	}

	// CreatedDateTime
	destination.CreatedDateTime = genruntime.ClonePointerToString(workspace.CreatedDateTime)

	// DefaultCatalog
	if workspace.DefaultCatalog != nil {
		var defaultCatalog storage.DefaultCatalogProperties_STATUS
		err := workspace.DefaultCatalog.AssignProperties_To_DefaultCatalogProperties_STATUS(&defaultCatalog)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DefaultCatalogProperties_STATUS() to populate field DefaultCatalog")
		}
		destination.DefaultCatalog = &defaultCatalog
	} else {
		destination.DefaultCatalog = nil
	}

	// DefaultStorageFirewall
	if workspace.DefaultStorageFirewall != nil {
		defaultStorageFirewall := string(*workspace.DefaultStorageFirewall)
		destination.DefaultStorageFirewall = &defaultStorageFirewall
	} else {
		destination.DefaultStorageFirewall = nil
	}

	// DiskEncryptionSetId
	destination.DiskEncryptionSetId = genruntime.ClonePointerToString(workspace.DiskEncryptionSetId)

	// Encryption
	if workspace.Encryption != nil {
		var encryption storage.WorkspaceProperties_Encryption_STATUS
		err := workspace.Encryption.AssignProperties_To_WorkspaceProperties_Encryption_STATUS(&encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceProperties_Encryption_STATUS() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// EnhancedSecurityCompliance
	if workspace.EnhancedSecurityCompliance != nil {
		var enhancedSecurityCompliance storage.EnhancedSecurityComplianceDefinition_STATUS
		err := workspace.EnhancedSecurityCompliance.AssignProperties_To_EnhancedSecurityComplianceDefinition_STATUS(&enhancedSecurityCompliance)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EnhancedSecurityComplianceDefinition_STATUS() to populate field EnhancedSecurityCompliance")
		}
		destination.EnhancedSecurityCompliance = &enhancedSecurityCompliance
	} else {
		destination.EnhancedSecurityCompliance = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(workspace.Id)

	// IsUcEnabled
	if workspace.IsUcEnabled != nil {
		isUcEnabled := *workspace.IsUcEnabled
		destination.IsUcEnabled = &isUcEnabled
	} else {
		destination.IsUcEnabled = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(workspace.Location)

	// ManagedDiskIdentity
	if workspace.ManagedDiskIdentity != nil {
		var managedDiskIdentity storage.ManagedIdentityConfiguration_STATUS
		err := workspace.ManagedDiskIdentity.AssignProperties_To_ManagedIdentityConfiguration_STATUS(&managedDiskIdentity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedIdentityConfiguration_STATUS() to populate field ManagedDiskIdentity")
		}
		destination.ManagedDiskIdentity = &managedDiskIdentity
	} else {
		destination.ManagedDiskIdentity = nil
	}

	// ManagedResourceGroupId
	destination.ManagedResourceGroupId = genruntime.ClonePointerToString(workspace.ManagedResourceGroupId)

	// Name
	destination.Name = genruntime.ClonePointerToString(workspace.Name)

	// Parameters
	if workspace.Parameters != nil {
		var parameter storage.WorkspaceCustomParameters_STATUS
		err := workspace.Parameters.AssignProperties_To_WorkspaceCustomParameters_STATUS(&parameter)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// PrivateEndpointConnections
	if workspace.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]storage.PrivateEndpointConnection_STATUS, len(workspace.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range workspace.PrivateEndpointConnections {
			var privateEndpointConnection storage.PrivateEndpointConnection_STATUS
			err := privateEndpointConnectionItem.AssignProperties_To_PrivateEndpointConnection_STATUS(&privateEndpointConnection)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if workspace.ProvisioningState != nil {
		provisioningState := string(*workspace.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicNetworkAccess
	if workspace.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*workspace.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// RequiredNsgRules
	if workspace.RequiredNsgRules != nil {
		requiredNsgRule := string(*workspace.RequiredNsgRules)
		destination.RequiredNsgRules = &requiredNsgRule
	} else {
		destination.RequiredNsgRules = nil
	}

	// Sku
	if workspace.Sku != nil {
		var sku storage.Sku_STATUS
		err := workspace.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// StorageAccountIdentity
	if workspace.StorageAccountIdentity != nil {
		var storageAccountIdentity storage.ManagedIdentityConfiguration_STATUS
		err := workspace.StorageAccountIdentity.AssignProperties_To_ManagedIdentityConfiguration_STATUS(&storageAccountIdentity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedIdentityConfiguration_STATUS() to populate field StorageAccountIdentity")
		}
		destination.StorageAccountIdentity = &storageAccountIdentity
	} else {
		destination.StorageAccountIdentity = nil
	}

	// SystemData
	if workspace.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := workspace.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(workspace.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(workspace.Type)

	// UiDefinitionUri
	destination.UiDefinitionUri = genruntime.ClonePointerToString(workspace.UiDefinitionUri)

	// UpdatedBy
	if workspace.UpdatedBy != nil {
		var updatedBy storage.CreatedBy_STATUS
		err := workspace.UpdatedBy.AssignProperties_To_CreatedBy_STATUS(&updatedBy)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CreatedBy_STATUS() to populate field UpdatedBy")
		}
		destination.UpdatedBy = &updatedBy
	} else {
		destination.UpdatedBy = nil
	}

	// WorkspaceId
	destination.WorkspaceId = genruntime.ClonePointerToString(workspace.WorkspaceId)

	// WorkspaceUrl
	destination.WorkspaceUrl = genruntime.ClonePointerToString(workspace.WorkspaceUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Provides details of the entity that created/updated the workspace.
type CreatedBy_STATUS struct {
	// ApplicationId: The application ID of the application that initiated the creation of the workspace. For example, Azure
	// Portal.
	ApplicationId *string `json:"applicationId,omitempty"`

	// Oid: The Object ID that created the workspace.
	Oid *string `json:"oid,omitempty"`

	// Puid: The Personal Object ID corresponding to the object ID above
	Puid *string `json:"puid,omitempty"`
}

var _ genruntime.FromARMConverter = &CreatedBy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (createdBy *CreatedBy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CreatedBy_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (createdBy *CreatedBy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CreatedBy_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CreatedBy_STATUS, got %T", armInput)
	}

	// Set property "ApplicationId":
	if typedInput.ApplicationId != nil {
		applicationId := *typedInput.ApplicationId
		createdBy.ApplicationId = &applicationId
	}

	// Set property "Oid":
	if typedInput.Oid != nil {
		oid := *typedInput.Oid
		createdBy.Oid = &oid
	}

	// Set property "Puid":
	if typedInput.Puid != nil {
		puid := *typedInput.Puid
		createdBy.Puid = &puid
	}

	// No error
	return nil
}

// AssignProperties_From_CreatedBy_STATUS populates our CreatedBy_STATUS from the provided source CreatedBy_STATUS
func (createdBy *CreatedBy_STATUS) AssignProperties_From_CreatedBy_STATUS(source *storage.CreatedBy_STATUS) error {

	// ApplicationId
	createdBy.ApplicationId = genruntime.ClonePointerToString(source.ApplicationId)

	// Oid
	createdBy.Oid = genruntime.ClonePointerToString(source.Oid)

	// Puid
	createdBy.Puid = genruntime.ClonePointerToString(source.Puid)

	// No error
	return nil
}

// AssignProperties_To_CreatedBy_STATUS populates the provided destination CreatedBy_STATUS from our CreatedBy_STATUS
func (createdBy *CreatedBy_STATUS) AssignProperties_To_CreatedBy_STATUS(destination *storage.CreatedBy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ApplicationId
	destination.ApplicationId = genruntime.ClonePointerToString(createdBy.ApplicationId)

	// Oid
	destination.Oid = genruntime.ClonePointerToString(createdBy.Oid)

	// Puid
	destination.Puid = genruntime.ClonePointerToString(createdBy.Puid)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// These properties lets user specify default catalog properties during workspace creation.
type DefaultCatalogProperties struct {
	// InitialName: Specifies the initial Name of default catalog. If not specified, the name of the workspace will be used.
	InitialName *string `json:"initialName,omitempty"`

	// InitialType: Defines the initial type of the default catalog. Possible values (case-insensitive):  HiveMetastore,
	// UnityCatalog
	InitialType *DefaultCatalogProperties_InitialType `json:"initialType,omitempty"`
}

var _ genruntime.ARMTransformer = &DefaultCatalogProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *DefaultCatalogProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.DefaultCatalogProperties{}

	// Set property "InitialName":
	if properties.InitialName != nil {
		initialName := *properties.InitialName
		result.InitialName = &initialName
	}

	// Set property "InitialType":
	if properties.InitialType != nil {
		var temp string
		temp = string(*properties.InitialType)
		initialType := arm.DefaultCatalogProperties_InitialType(temp)
		result.InitialType = &initialType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DefaultCatalogProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DefaultCatalogProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DefaultCatalogProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DefaultCatalogProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DefaultCatalogProperties, got %T", armInput)
	}

	// Set property "InitialName":
	if typedInput.InitialName != nil {
		initialName := *typedInput.InitialName
		properties.InitialName = &initialName
	}

	// Set property "InitialType":
	if typedInput.InitialType != nil {
		var temp string
		temp = string(*typedInput.InitialType)
		initialType := DefaultCatalogProperties_InitialType(temp)
		properties.InitialType = &initialType
	}

	// No error
	return nil
}

// AssignProperties_From_DefaultCatalogProperties populates our DefaultCatalogProperties from the provided source DefaultCatalogProperties
func (properties *DefaultCatalogProperties) AssignProperties_From_DefaultCatalogProperties(source *storage.DefaultCatalogProperties) error {

	// InitialName
	properties.InitialName = genruntime.ClonePointerToString(source.InitialName)

	// InitialType
	if source.InitialType != nil {
		initialType := *source.InitialType
		initialTypeTemp := genruntime.ToEnum(initialType, defaultCatalogProperties_InitialType_Values)
		properties.InitialType = &initialTypeTemp
	} else {
		properties.InitialType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DefaultCatalogProperties populates the provided destination DefaultCatalogProperties from our DefaultCatalogProperties
func (properties *DefaultCatalogProperties) AssignProperties_To_DefaultCatalogProperties(destination *storage.DefaultCatalogProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// InitialName
	destination.InitialName = genruntime.ClonePointerToString(properties.InitialName)

	// InitialType
	if properties.InitialType != nil {
		initialType := string(*properties.InitialType)
		destination.InitialType = &initialType
	} else {
		destination.InitialType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DefaultCatalogProperties_STATUS populates our DefaultCatalogProperties from the provided source DefaultCatalogProperties_STATUS
func (properties *DefaultCatalogProperties) Initialize_From_DefaultCatalogProperties_STATUS(source *DefaultCatalogProperties_STATUS) error {

	// InitialName
	properties.InitialName = genruntime.ClonePointerToString(source.InitialName)

	// InitialType
	if source.InitialType != nil {
		initialType := genruntime.ToEnum(string(*source.InitialType), defaultCatalogProperties_InitialType_Values)
		properties.InitialType = &initialType
	} else {
		properties.InitialType = nil
	}

	// No error
	return nil
}

// These properties lets user specify default catalog properties during workspace creation.
type DefaultCatalogProperties_STATUS struct {
	// InitialName: Specifies the initial Name of default catalog. If not specified, the name of the workspace will be used.
	InitialName *string `json:"initialName,omitempty"`

	// InitialType: Defines the initial type of the default catalog. Possible values (case-insensitive):  HiveMetastore,
	// UnityCatalog
	InitialType *DefaultCatalogProperties_InitialType_STATUS `json:"initialType,omitempty"`
}

var _ genruntime.FromARMConverter = &DefaultCatalogProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *DefaultCatalogProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DefaultCatalogProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *DefaultCatalogProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DefaultCatalogProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DefaultCatalogProperties_STATUS, got %T", armInput)
	}

	// Set property "InitialName":
	if typedInput.InitialName != nil {
		initialName := *typedInput.InitialName
		properties.InitialName = &initialName
	}

	// Set property "InitialType":
	if typedInput.InitialType != nil {
		var temp string
		temp = string(*typedInput.InitialType)
		initialType := DefaultCatalogProperties_InitialType_STATUS(temp)
		properties.InitialType = &initialType
	}

	// No error
	return nil
}

// AssignProperties_From_DefaultCatalogProperties_STATUS populates our DefaultCatalogProperties_STATUS from the provided source DefaultCatalogProperties_STATUS
func (properties *DefaultCatalogProperties_STATUS) AssignProperties_From_DefaultCatalogProperties_STATUS(source *storage.DefaultCatalogProperties_STATUS) error {

	// InitialName
	properties.InitialName = genruntime.ClonePointerToString(source.InitialName)

	// InitialType
	if source.InitialType != nil {
		initialType := *source.InitialType
		initialTypeTemp := genruntime.ToEnum(initialType, defaultCatalogProperties_InitialType_STATUS_Values)
		properties.InitialType = &initialTypeTemp
	} else {
		properties.InitialType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DefaultCatalogProperties_STATUS populates the provided destination DefaultCatalogProperties_STATUS from our DefaultCatalogProperties_STATUS
func (properties *DefaultCatalogProperties_STATUS) AssignProperties_To_DefaultCatalogProperties_STATUS(destination *storage.DefaultCatalogProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// InitialName
	destination.InitialName = genruntime.ClonePointerToString(properties.InitialName)

	// InitialType
	if properties.InitialType != nil {
		initialType := string(*properties.InitialType)
		destination.InitialType = &initialType
	} else {
		destination.InitialType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Status of settings related to the Enhanced Security and Compliance Add-On.
type EnhancedSecurityComplianceDefinition struct {
	// AutomaticClusterUpdate: Status of automated cluster updates feature.
	AutomaticClusterUpdate *AutomaticClusterUpdateDefinition `json:"automaticClusterUpdate,omitempty"`

	// ComplianceSecurityProfile: Status of Compliance Security Profile feature.
	ComplianceSecurityProfile *ComplianceSecurityProfileDefinition `json:"complianceSecurityProfile,omitempty"`

	// EnhancedSecurityMonitoring: Status of Enhanced Security Monitoring feature.
	EnhancedSecurityMonitoring *EnhancedSecurityMonitoringDefinition `json:"enhancedSecurityMonitoring,omitempty"`
}

var _ genruntime.ARMTransformer = &EnhancedSecurityComplianceDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *EnhancedSecurityComplianceDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.EnhancedSecurityComplianceDefinition{}

	// Set property "AutomaticClusterUpdate":
	if definition.AutomaticClusterUpdate != nil {
		automaticClusterUpdate_ARM, err := definition.AutomaticClusterUpdate.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		automaticClusterUpdate := *automaticClusterUpdate_ARM.(*arm.AutomaticClusterUpdateDefinition)
		result.AutomaticClusterUpdate = &automaticClusterUpdate
	}

	// Set property "ComplianceSecurityProfile":
	if definition.ComplianceSecurityProfile != nil {
		complianceSecurityProfile_ARM, err := definition.ComplianceSecurityProfile.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		complianceSecurityProfile := *complianceSecurityProfile_ARM.(*arm.ComplianceSecurityProfileDefinition)
		result.ComplianceSecurityProfile = &complianceSecurityProfile
	}

	// Set property "EnhancedSecurityMonitoring":
	if definition.EnhancedSecurityMonitoring != nil {
		enhancedSecurityMonitoring_ARM, err := definition.EnhancedSecurityMonitoring.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		enhancedSecurityMonitoring := *enhancedSecurityMonitoring_ARM.(*arm.EnhancedSecurityMonitoringDefinition)
		result.EnhancedSecurityMonitoring = &enhancedSecurityMonitoring
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *EnhancedSecurityComplianceDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EnhancedSecurityComplianceDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *EnhancedSecurityComplianceDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EnhancedSecurityComplianceDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EnhancedSecurityComplianceDefinition, got %T", armInput)
	}

	// Set property "AutomaticClusterUpdate":
	if typedInput.AutomaticClusterUpdate != nil {
		var automaticClusterUpdate1 AutomaticClusterUpdateDefinition
		err := automaticClusterUpdate1.PopulateFromARM(owner, *typedInput.AutomaticClusterUpdate)
		if err != nil {
			return err
		}
		automaticClusterUpdate := automaticClusterUpdate1
		definition.AutomaticClusterUpdate = &automaticClusterUpdate
	}

	// Set property "ComplianceSecurityProfile":
	if typedInput.ComplianceSecurityProfile != nil {
		var complianceSecurityProfile1 ComplianceSecurityProfileDefinition
		err := complianceSecurityProfile1.PopulateFromARM(owner, *typedInput.ComplianceSecurityProfile)
		if err != nil {
			return err
		}
		complianceSecurityProfile := complianceSecurityProfile1
		definition.ComplianceSecurityProfile = &complianceSecurityProfile
	}

	// Set property "EnhancedSecurityMonitoring":
	if typedInput.EnhancedSecurityMonitoring != nil {
		var enhancedSecurityMonitoring1 EnhancedSecurityMonitoringDefinition
		err := enhancedSecurityMonitoring1.PopulateFromARM(owner, *typedInput.EnhancedSecurityMonitoring)
		if err != nil {
			return err
		}
		enhancedSecurityMonitoring := enhancedSecurityMonitoring1
		definition.EnhancedSecurityMonitoring = &enhancedSecurityMonitoring
	}

	// No error
	return nil
}

// AssignProperties_From_EnhancedSecurityComplianceDefinition populates our EnhancedSecurityComplianceDefinition from the provided source EnhancedSecurityComplianceDefinition
func (definition *EnhancedSecurityComplianceDefinition) AssignProperties_From_EnhancedSecurityComplianceDefinition(source *storage.EnhancedSecurityComplianceDefinition) error {

	// AutomaticClusterUpdate
	if source.AutomaticClusterUpdate != nil {
		var automaticClusterUpdate AutomaticClusterUpdateDefinition
		err := automaticClusterUpdate.AssignProperties_From_AutomaticClusterUpdateDefinition(source.AutomaticClusterUpdate)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AutomaticClusterUpdateDefinition() to populate field AutomaticClusterUpdate")
		}
		definition.AutomaticClusterUpdate = &automaticClusterUpdate
	} else {
		definition.AutomaticClusterUpdate = nil
	}

	// ComplianceSecurityProfile
	if source.ComplianceSecurityProfile != nil {
		var complianceSecurityProfile ComplianceSecurityProfileDefinition
		err := complianceSecurityProfile.AssignProperties_From_ComplianceSecurityProfileDefinition(source.ComplianceSecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ComplianceSecurityProfileDefinition() to populate field ComplianceSecurityProfile")
		}
		definition.ComplianceSecurityProfile = &complianceSecurityProfile
	} else {
		definition.ComplianceSecurityProfile = nil
	}

	// EnhancedSecurityMonitoring
	if source.EnhancedSecurityMonitoring != nil {
		var enhancedSecurityMonitoring EnhancedSecurityMonitoringDefinition
		err := enhancedSecurityMonitoring.AssignProperties_From_EnhancedSecurityMonitoringDefinition(source.EnhancedSecurityMonitoring)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EnhancedSecurityMonitoringDefinition() to populate field EnhancedSecurityMonitoring")
		}
		definition.EnhancedSecurityMonitoring = &enhancedSecurityMonitoring
	} else {
		definition.EnhancedSecurityMonitoring = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EnhancedSecurityComplianceDefinition populates the provided destination EnhancedSecurityComplianceDefinition from our EnhancedSecurityComplianceDefinition
func (definition *EnhancedSecurityComplianceDefinition) AssignProperties_To_EnhancedSecurityComplianceDefinition(destination *storage.EnhancedSecurityComplianceDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutomaticClusterUpdate
	if definition.AutomaticClusterUpdate != nil {
		var automaticClusterUpdate storage.AutomaticClusterUpdateDefinition
		err := definition.AutomaticClusterUpdate.AssignProperties_To_AutomaticClusterUpdateDefinition(&automaticClusterUpdate)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AutomaticClusterUpdateDefinition() to populate field AutomaticClusterUpdate")
		}
		destination.AutomaticClusterUpdate = &automaticClusterUpdate
	} else {
		destination.AutomaticClusterUpdate = nil
	}

	// ComplianceSecurityProfile
	if definition.ComplianceSecurityProfile != nil {
		var complianceSecurityProfile storage.ComplianceSecurityProfileDefinition
		err := definition.ComplianceSecurityProfile.AssignProperties_To_ComplianceSecurityProfileDefinition(&complianceSecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ComplianceSecurityProfileDefinition() to populate field ComplianceSecurityProfile")
		}
		destination.ComplianceSecurityProfile = &complianceSecurityProfile
	} else {
		destination.ComplianceSecurityProfile = nil
	}

	// EnhancedSecurityMonitoring
	if definition.EnhancedSecurityMonitoring != nil {
		var enhancedSecurityMonitoring storage.EnhancedSecurityMonitoringDefinition
		err := definition.EnhancedSecurityMonitoring.AssignProperties_To_EnhancedSecurityMonitoringDefinition(&enhancedSecurityMonitoring)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EnhancedSecurityMonitoringDefinition() to populate field EnhancedSecurityMonitoring")
		}
		destination.EnhancedSecurityMonitoring = &enhancedSecurityMonitoring
	} else {
		destination.EnhancedSecurityMonitoring = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EnhancedSecurityComplianceDefinition_STATUS populates our EnhancedSecurityComplianceDefinition from the provided source EnhancedSecurityComplianceDefinition_STATUS
func (definition *EnhancedSecurityComplianceDefinition) Initialize_From_EnhancedSecurityComplianceDefinition_STATUS(source *EnhancedSecurityComplianceDefinition_STATUS) error {

	// AutomaticClusterUpdate
	if source.AutomaticClusterUpdate != nil {
		var automaticClusterUpdate AutomaticClusterUpdateDefinition
		err := automaticClusterUpdate.Initialize_From_AutomaticClusterUpdateDefinition_STATUS(source.AutomaticClusterUpdate)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_AutomaticClusterUpdateDefinition_STATUS() to populate field AutomaticClusterUpdate")
		}
		definition.AutomaticClusterUpdate = &automaticClusterUpdate
	} else {
		definition.AutomaticClusterUpdate = nil
	}

	// ComplianceSecurityProfile
	if source.ComplianceSecurityProfile != nil {
		var complianceSecurityProfile ComplianceSecurityProfileDefinition
		err := complianceSecurityProfile.Initialize_From_ComplianceSecurityProfileDefinition_STATUS(source.ComplianceSecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ComplianceSecurityProfileDefinition_STATUS() to populate field ComplianceSecurityProfile")
		}
		definition.ComplianceSecurityProfile = &complianceSecurityProfile
	} else {
		definition.ComplianceSecurityProfile = nil
	}

	// EnhancedSecurityMonitoring
	if source.EnhancedSecurityMonitoring != nil {
		var enhancedSecurityMonitoring EnhancedSecurityMonitoringDefinition
		err := enhancedSecurityMonitoring.Initialize_From_EnhancedSecurityMonitoringDefinition_STATUS(source.EnhancedSecurityMonitoring)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EnhancedSecurityMonitoringDefinition_STATUS() to populate field EnhancedSecurityMonitoring")
		}
		definition.EnhancedSecurityMonitoring = &enhancedSecurityMonitoring
	} else {
		definition.EnhancedSecurityMonitoring = nil
	}

	// No error
	return nil
}

// Status of settings related to the Enhanced Security and Compliance Add-On.
type EnhancedSecurityComplianceDefinition_STATUS struct {
	// AutomaticClusterUpdate: Status of automated cluster updates feature.
	AutomaticClusterUpdate *AutomaticClusterUpdateDefinition_STATUS `json:"automaticClusterUpdate,omitempty"`

	// ComplianceSecurityProfile: Status of Compliance Security Profile feature.
	ComplianceSecurityProfile *ComplianceSecurityProfileDefinition_STATUS `json:"complianceSecurityProfile,omitempty"`

	// EnhancedSecurityMonitoring: Status of Enhanced Security Monitoring feature.
	EnhancedSecurityMonitoring *EnhancedSecurityMonitoringDefinition_STATUS `json:"enhancedSecurityMonitoring,omitempty"`
}

var _ genruntime.FromARMConverter = &EnhancedSecurityComplianceDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *EnhancedSecurityComplianceDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EnhancedSecurityComplianceDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *EnhancedSecurityComplianceDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EnhancedSecurityComplianceDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EnhancedSecurityComplianceDefinition_STATUS, got %T", armInput)
	}

	// Set property "AutomaticClusterUpdate":
	if typedInput.AutomaticClusterUpdate != nil {
		var automaticClusterUpdate1 AutomaticClusterUpdateDefinition_STATUS
		err := automaticClusterUpdate1.PopulateFromARM(owner, *typedInput.AutomaticClusterUpdate)
		if err != nil {
			return err
		}
		automaticClusterUpdate := automaticClusterUpdate1
		definition.AutomaticClusterUpdate = &automaticClusterUpdate
	}

	// Set property "ComplianceSecurityProfile":
	if typedInput.ComplianceSecurityProfile != nil {
		var complianceSecurityProfile1 ComplianceSecurityProfileDefinition_STATUS
		err := complianceSecurityProfile1.PopulateFromARM(owner, *typedInput.ComplianceSecurityProfile)
		if err != nil {
			return err
		}
		complianceSecurityProfile := complianceSecurityProfile1
		definition.ComplianceSecurityProfile = &complianceSecurityProfile
	}

	// Set property "EnhancedSecurityMonitoring":
	if typedInput.EnhancedSecurityMonitoring != nil {
		var enhancedSecurityMonitoring1 EnhancedSecurityMonitoringDefinition_STATUS
		err := enhancedSecurityMonitoring1.PopulateFromARM(owner, *typedInput.EnhancedSecurityMonitoring)
		if err != nil {
			return err
		}
		enhancedSecurityMonitoring := enhancedSecurityMonitoring1
		definition.EnhancedSecurityMonitoring = &enhancedSecurityMonitoring
	}

	// No error
	return nil
}

// AssignProperties_From_EnhancedSecurityComplianceDefinition_STATUS populates our EnhancedSecurityComplianceDefinition_STATUS from the provided source EnhancedSecurityComplianceDefinition_STATUS
func (definition *EnhancedSecurityComplianceDefinition_STATUS) AssignProperties_From_EnhancedSecurityComplianceDefinition_STATUS(source *storage.EnhancedSecurityComplianceDefinition_STATUS) error {

	// AutomaticClusterUpdate
	if source.AutomaticClusterUpdate != nil {
		var automaticClusterUpdate AutomaticClusterUpdateDefinition_STATUS
		err := automaticClusterUpdate.AssignProperties_From_AutomaticClusterUpdateDefinition_STATUS(source.AutomaticClusterUpdate)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_AutomaticClusterUpdateDefinition_STATUS() to populate field AutomaticClusterUpdate")
		}
		definition.AutomaticClusterUpdate = &automaticClusterUpdate
	} else {
		definition.AutomaticClusterUpdate = nil
	}

	// ComplianceSecurityProfile
	if source.ComplianceSecurityProfile != nil {
		var complianceSecurityProfile ComplianceSecurityProfileDefinition_STATUS
		err := complianceSecurityProfile.AssignProperties_From_ComplianceSecurityProfileDefinition_STATUS(source.ComplianceSecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ComplianceSecurityProfileDefinition_STATUS() to populate field ComplianceSecurityProfile")
		}
		definition.ComplianceSecurityProfile = &complianceSecurityProfile
	} else {
		definition.ComplianceSecurityProfile = nil
	}

	// EnhancedSecurityMonitoring
	if source.EnhancedSecurityMonitoring != nil {
		var enhancedSecurityMonitoring EnhancedSecurityMonitoringDefinition_STATUS
		err := enhancedSecurityMonitoring.AssignProperties_From_EnhancedSecurityMonitoringDefinition_STATUS(source.EnhancedSecurityMonitoring)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EnhancedSecurityMonitoringDefinition_STATUS() to populate field EnhancedSecurityMonitoring")
		}
		definition.EnhancedSecurityMonitoring = &enhancedSecurityMonitoring
	} else {
		definition.EnhancedSecurityMonitoring = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EnhancedSecurityComplianceDefinition_STATUS populates the provided destination EnhancedSecurityComplianceDefinition_STATUS from our EnhancedSecurityComplianceDefinition_STATUS
func (definition *EnhancedSecurityComplianceDefinition_STATUS) AssignProperties_To_EnhancedSecurityComplianceDefinition_STATUS(destination *storage.EnhancedSecurityComplianceDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutomaticClusterUpdate
	if definition.AutomaticClusterUpdate != nil {
		var automaticClusterUpdate storage.AutomaticClusterUpdateDefinition_STATUS
		err := definition.AutomaticClusterUpdate.AssignProperties_To_AutomaticClusterUpdateDefinition_STATUS(&automaticClusterUpdate)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_AutomaticClusterUpdateDefinition_STATUS() to populate field AutomaticClusterUpdate")
		}
		destination.AutomaticClusterUpdate = &automaticClusterUpdate
	} else {
		destination.AutomaticClusterUpdate = nil
	}

	// ComplianceSecurityProfile
	if definition.ComplianceSecurityProfile != nil {
		var complianceSecurityProfile storage.ComplianceSecurityProfileDefinition_STATUS
		err := definition.ComplianceSecurityProfile.AssignProperties_To_ComplianceSecurityProfileDefinition_STATUS(&complianceSecurityProfile)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ComplianceSecurityProfileDefinition_STATUS() to populate field ComplianceSecurityProfile")
		}
		destination.ComplianceSecurityProfile = &complianceSecurityProfile
	} else {
		destination.ComplianceSecurityProfile = nil
	}

	// EnhancedSecurityMonitoring
	if definition.EnhancedSecurityMonitoring != nil {
		var enhancedSecurityMonitoring storage.EnhancedSecurityMonitoringDefinition_STATUS
		err := definition.EnhancedSecurityMonitoring.AssignProperties_To_EnhancedSecurityMonitoringDefinition_STATUS(&enhancedSecurityMonitoring)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EnhancedSecurityMonitoringDefinition_STATUS() to populate field EnhancedSecurityMonitoring")
		}
		destination.EnhancedSecurityMonitoring = &enhancedSecurityMonitoring
	} else {
		destination.EnhancedSecurityMonitoring = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The Managed Identity details for storage account.
type ManagedIdentityConfiguration_STATUS struct {
	// PrincipalId: The objectId of the Managed Identity that is linked to the Managed Storage account.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant Id where the Managed Identity is created.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The type of Identity created. It can be either SystemAssigned or UserAssigned.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedIdentityConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *ManagedIdentityConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedIdentityConfiguration_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *ManagedIdentityConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedIdentityConfiguration_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedIdentityConfiguration_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		configuration.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		configuration.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		configuration.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedIdentityConfiguration_STATUS populates our ManagedIdentityConfiguration_STATUS from the provided source ManagedIdentityConfiguration_STATUS
func (configuration *ManagedIdentityConfiguration_STATUS) AssignProperties_From_ManagedIdentityConfiguration_STATUS(source *storage.ManagedIdentityConfiguration_STATUS) error {

	// PrincipalId
	configuration.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	configuration.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	configuration.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_ManagedIdentityConfiguration_STATUS populates the provided destination ManagedIdentityConfiguration_STATUS from our ManagedIdentityConfiguration_STATUS
func (configuration *ManagedIdentityConfiguration_STATUS) AssignProperties_To_ManagedIdentityConfiguration_STATUS(destination *storage.ManagedIdentityConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(configuration.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(configuration.TenantId)

	// Type
	destination.Type = genruntime.ClonePointerToString(configuration.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The private endpoint connection of a workspace
type PrivateEndpointConnection_STATUS struct {
	// Id: The resource identifier.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *PrivateEndpointConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *PrivateEndpointConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateEndpointConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointConnection_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointConnection_STATUS populates our PrivateEndpointConnection_STATUS from the provided source PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_From_PrivateEndpointConnection_STATUS(source *storage.PrivateEndpointConnection_STATUS) error {

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointConnection_STATUS populates the provided destination PrivateEndpointConnection_STATUS from our PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_To_PrivateEndpointConnection_STATUS(destination *storage.PrivateEndpointConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Provisioning status of the workspace.
type ProvisioningState_STATUS string

const (
	ProvisioningState_STATUS_Accepted  = ProvisioningState_STATUS("Accepted")
	ProvisioningState_STATUS_Canceled  = ProvisioningState_STATUS("Canceled")
	ProvisioningState_STATUS_Created   = ProvisioningState_STATUS("Created")
	ProvisioningState_STATUS_Creating  = ProvisioningState_STATUS("Creating")
	ProvisioningState_STATUS_Deleted   = ProvisioningState_STATUS("Deleted")
	ProvisioningState_STATUS_Deleting  = ProvisioningState_STATUS("Deleting")
	ProvisioningState_STATUS_Failed    = ProvisioningState_STATUS("Failed")
	ProvisioningState_STATUS_Ready     = ProvisioningState_STATUS("Ready")
	ProvisioningState_STATUS_Running   = ProvisioningState_STATUS("Running")
	ProvisioningState_STATUS_Succeeded = ProvisioningState_STATUS("Succeeded")
	ProvisioningState_STATUS_Updating  = ProvisioningState_STATUS("Updating")
)

// Mapping from string to ProvisioningState_STATUS
var provisioningState_STATUS_Values = map[string]ProvisioningState_STATUS{
	"accepted":  ProvisioningState_STATUS_Accepted,
	"canceled":  ProvisioningState_STATUS_Canceled,
	"created":   ProvisioningState_STATUS_Created,
	"creating":  ProvisioningState_STATUS_Creating,
	"deleted":   ProvisioningState_STATUS_Deleted,
	"deleting":  ProvisioningState_STATUS_Deleting,
	"failed":    ProvisioningState_STATUS_Failed,
	"ready":     ProvisioningState_STATUS_Ready,
	"running":   ProvisioningState_STATUS_Running,
	"succeeded": ProvisioningState_STATUS_Succeeded,
	"updating":  ProvisioningState_STATUS_Updating,
}

// SKU for the resource.
type Sku struct {
	// +kubebuilder:validation:Required
	// Name: The SKU name.
	Name *string `json:"name,omitempty"`

	// Tier: The SKU tier.
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &arm.Sku{}

	// Set property "Name":
	if sku.Name != nil {
		name := *sku.Name
		result.Name = &name
	}

	// Set property "Tier":
	if sku.Tier != nil {
		tier := *sku.Tier
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku populates our Sku from the provided source Sku
func (sku *Sku) AssignProperties_From_Sku(source *storage.Sku) error {

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// AssignProperties_To_Sku populates the provided destination Sku from our Sku
func (sku *Sku) AssignProperties_To_Sku(destination *storage.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Sku_STATUS populates our Sku from the provided source Sku_STATUS
func (sku *Sku) Initialize_From_Sku_STATUS(source *Sku_STATUS) error {

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// SKU for the resource.
type Sku_STATUS struct {
	// Name: The SKU name.
	Name *string `json:"name,omitempty"`

	// Tier: The SKU tier.
	Tier *string `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property "Tier":
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignProperties_From_Sku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_From_Sku_STATUS(source *storage.Sku_STATUS) error {

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	sku.Tier = genruntime.ClonePointerToString(source.Tier)

	// No error
	return nil
}

// AssignProperties_To_Sku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_To_Sku_STATUS(destination *storage.Sku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(sku.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Custom Parameters used for Cluster Creation.
type WorkspaceCustomParameters struct {
	// AmlWorkspaceId: The ID of a Azure Machine Learning workspace to link with Databricks workspace
	AmlWorkspaceId *WorkspaceCustomStringParameter `json:"amlWorkspaceId,omitempty"`

	// CustomPrivateSubnetName: The name of the Private Subnet within the Virtual Network
	CustomPrivateSubnetName *WorkspaceCustomStringParameter `json:"customPrivateSubnetName,omitempty"`

	// CustomPublicSubnetName: The name of a Public Subnet within the Virtual Network
	CustomPublicSubnetName *WorkspaceCustomStringParameter `json:"customPublicSubnetName,omitempty"`

	// CustomVirtualNetworkId: The ID of a Virtual Network where this Databricks Cluster should be created
	CustomVirtualNetworkId *WorkspaceCustomStringParameter `json:"customVirtualNetworkId,omitempty"`

	// EnableNoPublicIp: Boolean indicating whether the public IP should be disabled. Default value is true
	EnableNoPublicIp *WorkspaceNoPublicIPBooleanParameter `json:"enableNoPublicIp,omitempty"`

	// Encryption: Contains the encryption details for Customer-Managed Key (CMK) enabled workspace.
	Encryption *WorkspaceEncryptionParameter `json:"encryption,omitempty"`

	// LoadBalancerBackendPoolName: Name of the outbound Load Balancer Backend Pool for Secure Cluster Connectivity (No Public
	// IP).
	LoadBalancerBackendPoolName *WorkspaceCustomStringParameter `json:"loadBalancerBackendPoolName,omitempty"`

	// LoadBalancerId: Resource URI of Outbound Load balancer for Secure Cluster Connectivity (No Public IP) workspace.
	LoadBalancerId *WorkspaceCustomStringParameter `json:"loadBalancerId,omitempty"`

	// NatGatewayName: Name of the NAT gateway for Secure Cluster Connectivity (No Public IP) workspace subnets.
	NatGatewayName *WorkspaceCustomStringParameter `json:"natGatewayName,omitempty"`

	// PrepareEncryption: Prepare the workspace for encryption. Enables the Managed Identity for managed storage account.
	PrepareEncryption *WorkspaceCustomBooleanParameter `json:"prepareEncryption,omitempty"`

	// PublicIpName: Name of the Public IP for No Public IP workspace with managed vNet.
	PublicIpName *WorkspaceCustomStringParameter `json:"publicIpName,omitempty"`

	// RequireInfrastructureEncryption: A boolean indicating whether or not the DBFS root file system will be enabled with
	// secondary layer of encryption with platform managed keys for data at rest.
	RequireInfrastructureEncryption *WorkspaceCustomBooleanParameter `json:"requireInfrastructureEncryption,omitempty"`

	// StorageAccountName: Default DBFS storage account name.
	StorageAccountName *WorkspaceCustomStringParameter `json:"storageAccountName,omitempty"`

	// StorageAccountSkuName: Storage account SKU name, ex: Standard_GRS, Standard_LRS. Refer https://aka.ms/storageskus for
	// valid inputs.
	StorageAccountSkuName *WorkspaceCustomStringParameter `json:"storageAccountSkuName,omitempty"`

	// VnetAddressPrefix: Address prefix for Managed virtual network. Default value for this input is 10.139.
	VnetAddressPrefix *WorkspaceCustomStringParameter `json:"vnetAddressPrefix,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceCustomParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *WorkspaceCustomParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &arm.WorkspaceCustomParameters{}

	// Set property "AmlWorkspaceId":
	if parameters.AmlWorkspaceId != nil {
		amlWorkspaceId_ARM, err := parameters.AmlWorkspaceId.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		amlWorkspaceId := *amlWorkspaceId_ARM.(*arm.WorkspaceCustomStringParameter)
		result.AmlWorkspaceId = &amlWorkspaceId
	}

	// Set property "CustomPrivateSubnetName":
	if parameters.CustomPrivateSubnetName != nil {
		customPrivateSubnetName_ARM, err := parameters.CustomPrivateSubnetName.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customPrivateSubnetName := *customPrivateSubnetName_ARM.(*arm.WorkspaceCustomStringParameter)
		result.CustomPrivateSubnetName = &customPrivateSubnetName
	}

	// Set property "CustomPublicSubnetName":
	if parameters.CustomPublicSubnetName != nil {
		customPublicSubnetName_ARM, err := parameters.CustomPublicSubnetName.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customPublicSubnetName := *customPublicSubnetName_ARM.(*arm.WorkspaceCustomStringParameter)
		result.CustomPublicSubnetName = &customPublicSubnetName
	}

	// Set property "CustomVirtualNetworkId":
	if parameters.CustomVirtualNetworkId != nil {
		customVirtualNetworkId_ARM, err := parameters.CustomVirtualNetworkId.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customVirtualNetworkId := *customVirtualNetworkId_ARM.(*arm.WorkspaceCustomStringParameter)
		result.CustomVirtualNetworkId = &customVirtualNetworkId
	}

	// Set property "EnableNoPublicIp":
	if parameters.EnableNoPublicIp != nil {
		enableNoPublicIp_ARM, err := parameters.EnableNoPublicIp.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		enableNoPublicIp := *enableNoPublicIp_ARM.(*arm.WorkspaceNoPublicIPBooleanParameter)
		result.EnableNoPublicIp = &enableNoPublicIp
	}

	// Set property "Encryption":
	if parameters.Encryption != nil {
		encryption_ARM, err := parameters.Encryption.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryption := *encryption_ARM.(*arm.WorkspaceEncryptionParameter)
		result.Encryption = &encryption
	}

	// Set property "LoadBalancerBackendPoolName":
	if parameters.LoadBalancerBackendPoolName != nil {
		loadBalancerBackendPoolName_ARM, err := parameters.LoadBalancerBackendPoolName.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		loadBalancerBackendPoolName := *loadBalancerBackendPoolName_ARM.(*arm.WorkspaceCustomStringParameter)
		result.LoadBalancerBackendPoolName = &loadBalancerBackendPoolName
	}

	// Set property "LoadBalancerId":
	if parameters.LoadBalancerId != nil {
		loadBalancerId_ARM, err := parameters.LoadBalancerId.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		loadBalancerId := *loadBalancerId_ARM.(*arm.WorkspaceCustomStringParameter)
		result.LoadBalancerId = &loadBalancerId
	}

	// Set property "NatGatewayName":
	if parameters.NatGatewayName != nil {
		natGatewayName_ARM, err := parameters.NatGatewayName.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		natGatewayName := *natGatewayName_ARM.(*arm.WorkspaceCustomStringParameter)
		result.NatGatewayName = &natGatewayName
	}

	// Set property "PrepareEncryption":
	if parameters.PrepareEncryption != nil {
		prepareEncryption_ARM, err := parameters.PrepareEncryption.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		prepareEncryption := *prepareEncryption_ARM.(*arm.WorkspaceCustomBooleanParameter)
		result.PrepareEncryption = &prepareEncryption
	}

	// Set property "PublicIpName":
	if parameters.PublicIpName != nil {
		publicIpName_ARM, err := parameters.PublicIpName.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		publicIpName := *publicIpName_ARM.(*arm.WorkspaceCustomStringParameter)
		result.PublicIpName = &publicIpName
	}

	// Set property "RequireInfrastructureEncryption":
	if parameters.RequireInfrastructureEncryption != nil {
		requireInfrastructureEncryption_ARM, err := parameters.RequireInfrastructureEncryption.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requireInfrastructureEncryption := *requireInfrastructureEncryption_ARM.(*arm.WorkspaceCustomBooleanParameter)
		result.RequireInfrastructureEncryption = &requireInfrastructureEncryption
	}

	// Set property "StorageAccountName":
	if parameters.StorageAccountName != nil {
		storageAccountName_ARM, err := parameters.StorageAccountName.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageAccountName := *storageAccountName_ARM.(*arm.WorkspaceCustomStringParameter)
		result.StorageAccountName = &storageAccountName
	}

	// Set property "StorageAccountSkuName":
	if parameters.StorageAccountSkuName != nil {
		storageAccountSkuName_ARM, err := parameters.StorageAccountSkuName.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageAccountSkuName := *storageAccountSkuName_ARM.(*arm.WorkspaceCustomStringParameter)
		result.StorageAccountSkuName = &storageAccountSkuName
	}

	// Set property "VnetAddressPrefix":
	if parameters.VnetAddressPrefix != nil {
		vnetAddressPrefix_ARM, err := parameters.VnetAddressPrefix.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		vnetAddressPrefix := *vnetAddressPrefix_ARM.(*arm.WorkspaceCustomStringParameter)
		result.VnetAddressPrefix = &vnetAddressPrefix
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *WorkspaceCustomParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceCustomParameters{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *WorkspaceCustomParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceCustomParameters)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceCustomParameters, got %T", armInput)
	}

	// Set property "AmlWorkspaceId":
	if typedInput.AmlWorkspaceId != nil {
		var amlWorkspaceId1 WorkspaceCustomStringParameter
		err := amlWorkspaceId1.PopulateFromARM(owner, *typedInput.AmlWorkspaceId)
		if err != nil {
			return err
		}
		amlWorkspaceId := amlWorkspaceId1
		parameters.AmlWorkspaceId = &amlWorkspaceId
	}

	// Set property "CustomPrivateSubnetName":
	if typedInput.CustomPrivateSubnetName != nil {
		var customPrivateSubnetName1 WorkspaceCustomStringParameter
		err := customPrivateSubnetName1.PopulateFromARM(owner, *typedInput.CustomPrivateSubnetName)
		if err != nil {
			return err
		}
		customPrivateSubnetName := customPrivateSubnetName1
		parameters.CustomPrivateSubnetName = &customPrivateSubnetName
	}

	// Set property "CustomPublicSubnetName":
	if typedInput.CustomPublicSubnetName != nil {
		var customPublicSubnetName1 WorkspaceCustomStringParameter
		err := customPublicSubnetName1.PopulateFromARM(owner, *typedInput.CustomPublicSubnetName)
		if err != nil {
			return err
		}
		customPublicSubnetName := customPublicSubnetName1
		parameters.CustomPublicSubnetName = &customPublicSubnetName
	}

	// Set property "CustomVirtualNetworkId":
	if typedInput.CustomVirtualNetworkId != nil {
		var customVirtualNetworkId1 WorkspaceCustomStringParameter
		err := customVirtualNetworkId1.PopulateFromARM(owner, *typedInput.CustomVirtualNetworkId)
		if err != nil {
			return err
		}
		customVirtualNetworkId := customVirtualNetworkId1
		parameters.CustomVirtualNetworkId = &customVirtualNetworkId
	}

	// Set property "EnableNoPublicIp":
	if typedInput.EnableNoPublicIp != nil {
		var enableNoPublicIp1 WorkspaceNoPublicIPBooleanParameter
		err := enableNoPublicIp1.PopulateFromARM(owner, *typedInput.EnableNoPublicIp)
		if err != nil {
			return err
		}
		enableNoPublicIp := enableNoPublicIp1
		parameters.EnableNoPublicIp = &enableNoPublicIp
	}

	// Set property "Encryption":
	if typedInput.Encryption != nil {
		var encryption1 WorkspaceEncryptionParameter
		err := encryption1.PopulateFromARM(owner, *typedInput.Encryption)
		if err != nil {
			return err
		}
		encryption := encryption1
		parameters.Encryption = &encryption
	}

	// Set property "LoadBalancerBackendPoolName":
	if typedInput.LoadBalancerBackendPoolName != nil {
		var loadBalancerBackendPoolName1 WorkspaceCustomStringParameter
		err := loadBalancerBackendPoolName1.PopulateFromARM(owner, *typedInput.LoadBalancerBackendPoolName)
		if err != nil {
			return err
		}
		loadBalancerBackendPoolName := loadBalancerBackendPoolName1
		parameters.LoadBalancerBackendPoolName = &loadBalancerBackendPoolName
	}

	// Set property "LoadBalancerId":
	if typedInput.LoadBalancerId != nil {
		var loadBalancerId1 WorkspaceCustomStringParameter
		err := loadBalancerId1.PopulateFromARM(owner, *typedInput.LoadBalancerId)
		if err != nil {
			return err
		}
		loadBalancerId := loadBalancerId1
		parameters.LoadBalancerId = &loadBalancerId
	}

	// Set property "NatGatewayName":
	if typedInput.NatGatewayName != nil {
		var natGatewayName1 WorkspaceCustomStringParameter
		err := natGatewayName1.PopulateFromARM(owner, *typedInput.NatGatewayName)
		if err != nil {
			return err
		}
		natGatewayName := natGatewayName1
		parameters.NatGatewayName = &natGatewayName
	}

	// Set property "PrepareEncryption":
	if typedInput.PrepareEncryption != nil {
		var prepareEncryption1 WorkspaceCustomBooleanParameter
		err := prepareEncryption1.PopulateFromARM(owner, *typedInput.PrepareEncryption)
		if err != nil {
			return err
		}
		prepareEncryption := prepareEncryption1
		parameters.PrepareEncryption = &prepareEncryption
	}

	// Set property "PublicIpName":
	if typedInput.PublicIpName != nil {
		var publicIpName1 WorkspaceCustomStringParameter
		err := publicIpName1.PopulateFromARM(owner, *typedInput.PublicIpName)
		if err != nil {
			return err
		}
		publicIpName := publicIpName1
		parameters.PublicIpName = &publicIpName
	}

	// Set property "RequireInfrastructureEncryption":
	if typedInput.RequireInfrastructureEncryption != nil {
		var requireInfrastructureEncryption1 WorkspaceCustomBooleanParameter
		err := requireInfrastructureEncryption1.PopulateFromARM(owner, *typedInput.RequireInfrastructureEncryption)
		if err != nil {
			return err
		}
		requireInfrastructureEncryption := requireInfrastructureEncryption1
		parameters.RequireInfrastructureEncryption = &requireInfrastructureEncryption
	}

	// Set property "StorageAccountName":
	if typedInput.StorageAccountName != nil {
		var storageAccountName1 WorkspaceCustomStringParameter
		err := storageAccountName1.PopulateFromARM(owner, *typedInput.StorageAccountName)
		if err != nil {
			return err
		}
		storageAccountName := storageAccountName1
		parameters.StorageAccountName = &storageAccountName
	}

	// Set property "StorageAccountSkuName":
	if typedInput.StorageAccountSkuName != nil {
		var storageAccountSkuName1 WorkspaceCustomStringParameter
		err := storageAccountSkuName1.PopulateFromARM(owner, *typedInput.StorageAccountSkuName)
		if err != nil {
			return err
		}
		storageAccountSkuName := storageAccountSkuName1
		parameters.StorageAccountSkuName = &storageAccountSkuName
	}

	// Set property "VnetAddressPrefix":
	if typedInput.VnetAddressPrefix != nil {
		var vnetAddressPrefix1 WorkspaceCustomStringParameter
		err := vnetAddressPrefix1.PopulateFromARM(owner, *typedInput.VnetAddressPrefix)
		if err != nil {
			return err
		}
		vnetAddressPrefix := vnetAddressPrefix1
		parameters.VnetAddressPrefix = &vnetAddressPrefix
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceCustomParameters populates our WorkspaceCustomParameters from the provided source WorkspaceCustomParameters
func (parameters *WorkspaceCustomParameters) AssignProperties_From_WorkspaceCustomParameters(source *storage.WorkspaceCustomParameters) error {

	// AmlWorkspaceId
	if source.AmlWorkspaceId != nil {
		var amlWorkspaceId WorkspaceCustomStringParameter
		err := amlWorkspaceId.AssignProperties_From_WorkspaceCustomStringParameter(source.AmlWorkspaceId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter() to populate field AmlWorkspaceId")
		}
		parameters.AmlWorkspaceId = &amlWorkspaceId
	} else {
		parameters.AmlWorkspaceId = nil
	}

	// CustomPrivateSubnetName
	if source.CustomPrivateSubnetName != nil {
		var customPrivateSubnetName WorkspaceCustomStringParameter
		err := customPrivateSubnetName.AssignProperties_From_WorkspaceCustomStringParameter(source.CustomPrivateSubnetName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter() to populate field CustomPrivateSubnetName")
		}
		parameters.CustomPrivateSubnetName = &customPrivateSubnetName
	} else {
		parameters.CustomPrivateSubnetName = nil
	}

	// CustomPublicSubnetName
	if source.CustomPublicSubnetName != nil {
		var customPublicSubnetName WorkspaceCustomStringParameter
		err := customPublicSubnetName.AssignProperties_From_WorkspaceCustomStringParameter(source.CustomPublicSubnetName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter() to populate field CustomPublicSubnetName")
		}
		parameters.CustomPublicSubnetName = &customPublicSubnetName
	} else {
		parameters.CustomPublicSubnetName = nil
	}

	// CustomVirtualNetworkId
	if source.CustomVirtualNetworkId != nil {
		var customVirtualNetworkId WorkspaceCustomStringParameter
		err := customVirtualNetworkId.AssignProperties_From_WorkspaceCustomStringParameter(source.CustomVirtualNetworkId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter() to populate field CustomVirtualNetworkId")
		}
		parameters.CustomVirtualNetworkId = &customVirtualNetworkId
	} else {
		parameters.CustomVirtualNetworkId = nil
	}

	// EnableNoPublicIp
	if source.EnableNoPublicIp != nil {
		var enableNoPublicIp WorkspaceNoPublicIPBooleanParameter
		err := enableNoPublicIp.AssignProperties_From_WorkspaceNoPublicIPBooleanParameter(source.EnableNoPublicIp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceNoPublicIPBooleanParameter() to populate field EnableNoPublicIp")
		}
		parameters.EnableNoPublicIp = &enableNoPublicIp
	} else {
		parameters.EnableNoPublicIp = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption WorkspaceEncryptionParameter
		err := encryption.AssignProperties_From_WorkspaceEncryptionParameter(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceEncryptionParameter() to populate field Encryption")
		}
		parameters.Encryption = &encryption
	} else {
		parameters.Encryption = nil
	}

	// LoadBalancerBackendPoolName
	if source.LoadBalancerBackendPoolName != nil {
		var loadBalancerBackendPoolName WorkspaceCustomStringParameter
		err := loadBalancerBackendPoolName.AssignProperties_From_WorkspaceCustomStringParameter(source.LoadBalancerBackendPoolName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter() to populate field LoadBalancerBackendPoolName")
		}
		parameters.LoadBalancerBackendPoolName = &loadBalancerBackendPoolName
	} else {
		parameters.LoadBalancerBackendPoolName = nil
	}

	// LoadBalancerId
	if source.LoadBalancerId != nil {
		var loadBalancerId WorkspaceCustomStringParameter
		err := loadBalancerId.AssignProperties_From_WorkspaceCustomStringParameter(source.LoadBalancerId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter() to populate field LoadBalancerId")
		}
		parameters.LoadBalancerId = &loadBalancerId
	} else {
		parameters.LoadBalancerId = nil
	}

	// NatGatewayName
	if source.NatGatewayName != nil {
		var natGatewayName WorkspaceCustomStringParameter
		err := natGatewayName.AssignProperties_From_WorkspaceCustomStringParameter(source.NatGatewayName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter() to populate field NatGatewayName")
		}
		parameters.NatGatewayName = &natGatewayName
	} else {
		parameters.NatGatewayName = nil
	}

	// PrepareEncryption
	if source.PrepareEncryption != nil {
		var prepareEncryption WorkspaceCustomBooleanParameter
		err := prepareEncryption.AssignProperties_From_WorkspaceCustomBooleanParameter(source.PrepareEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomBooleanParameter() to populate field PrepareEncryption")
		}
		parameters.PrepareEncryption = &prepareEncryption
	} else {
		parameters.PrepareEncryption = nil
	}

	// PublicIpName
	if source.PublicIpName != nil {
		var publicIpName WorkspaceCustomStringParameter
		err := publicIpName.AssignProperties_From_WorkspaceCustomStringParameter(source.PublicIpName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter() to populate field PublicIpName")
		}
		parameters.PublicIpName = &publicIpName
	} else {
		parameters.PublicIpName = nil
	}

	// RequireInfrastructureEncryption
	if source.RequireInfrastructureEncryption != nil {
		var requireInfrastructureEncryption WorkspaceCustomBooleanParameter
		err := requireInfrastructureEncryption.AssignProperties_From_WorkspaceCustomBooleanParameter(source.RequireInfrastructureEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomBooleanParameter() to populate field RequireInfrastructureEncryption")
		}
		parameters.RequireInfrastructureEncryption = &requireInfrastructureEncryption
	} else {
		parameters.RequireInfrastructureEncryption = nil
	}

	// StorageAccountName
	if source.StorageAccountName != nil {
		var storageAccountName WorkspaceCustomStringParameter
		err := storageAccountName.AssignProperties_From_WorkspaceCustomStringParameter(source.StorageAccountName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter() to populate field StorageAccountName")
		}
		parameters.StorageAccountName = &storageAccountName
	} else {
		parameters.StorageAccountName = nil
	}

	// StorageAccountSkuName
	if source.StorageAccountSkuName != nil {
		var storageAccountSkuName WorkspaceCustomStringParameter
		err := storageAccountSkuName.AssignProperties_From_WorkspaceCustomStringParameter(source.StorageAccountSkuName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter() to populate field StorageAccountSkuName")
		}
		parameters.StorageAccountSkuName = &storageAccountSkuName
	} else {
		parameters.StorageAccountSkuName = nil
	}

	// VnetAddressPrefix
	if source.VnetAddressPrefix != nil {
		var vnetAddressPrefix WorkspaceCustomStringParameter
		err := vnetAddressPrefix.AssignProperties_From_WorkspaceCustomStringParameter(source.VnetAddressPrefix)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter() to populate field VnetAddressPrefix")
		}
		parameters.VnetAddressPrefix = &vnetAddressPrefix
	} else {
		parameters.VnetAddressPrefix = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceCustomParameters populates the provided destination WorkspaceCustomParameters from our WorkspaceCustomParameters
func (parameters *WorkspaceCustomParameters) AssignProperties_To_WorkspaceCustomParameters(destination *storage.WorkspaceCustomParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AmlWorkspaceId
	if parameters.AmlWorkspaceId != nil {
		var amlWorkspaceId storage.WorkspaceCustomStringParameter
		err := parameters.AmlWorkspaceId.AssignProperties_To_WorkspaceCustomStringParameter(&amlWorkspaceId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter() to populate field AmlWorkspaceId")
		}
		destination.AmlWorkspaceId = &amlWorkspaceId
	} else {
		destination.AmlWorkspaceId = nil
	}

	// CustomPrivateSubnetName
	if parameters.CustomPrivateSubnetName != nil {
		var customPrivateSubnetName storage.WorkspaceCustomStringParameter
		err := parameters.CustomPrivateSubnetName.AssignProperties_To_WorkspaceCustomStringParameter(&customPrivateSubnetName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter() to populate field CustomPrivateSubnetName")
		}
		destination.CustomPrivateSubnetName = &customPrivateSubnetName
	} else {
		destination.CustomPrivateSubnetName = nil
	}

	// CustomPublicSubnetName
	if parameters.CustomPublicSubnetName != nil {
		var customPublicSubnetName storage.WorkspaceCustomStringParameter
		err := parameters.CustomPublicSubnetName.AssignProperties_To_WorkspaceCustomStringParameter(&customPublicSubnetName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter() to populate field CustomPublicSubnetName")
		}
		destination.CustomPublicSubnetName = &customPublicSubnetName
	} else {
		destination.CustomPublicSubnetName = nil
	}

	// CustomVirtualNetworkId
	if parameters.CustomVirtualNetworkId != nil {
		var customVirtualNetworkId storage.WorkspaceCustomStringParameter
		err := parameters.CustomVirtualNetworkId.AssignProperties_To_WorkspaceCustomStringParameter(&customVirtualNetworkId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter() to populate field CustomVirtualNetworkId")
		}
		destination.CustomVirtualNetworkId = &customVirtualNetworkId
	} else {
		destination.CustomVirtualNetworkId = nil
	}

	// EnableNoPublicIp
	if parameters.EnableNoPublicIp != nil {
		var enableNoPublicIp storage.WorkspaceNoPublicIPBooleanParameter
		err := parameters.EnableNoPublicIp.AssignProperties_To_WorkspaceNoPublicIPBooleanParameter(&enableNoPublicIp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceNoPublicIPBooleanParameter() to populate field EnableNoPublicIp")
		}
		destination.EnableNoPublicIp = &enableNoPublicIp
	} else {
		destination.EnableNoPublicIp = nil
	}

	// Encryption
	if parameters.Encryption != nil {
		var encryption storage.WorkspaceEncryptionParameter
		err := parameters.Encryption.AssignProperties_To_WorkspaceEncryptionParameter(&encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceEncryptionParameter() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// LoadBalancerBackendPoolName
	if parameters.LoadBalancerBackendPoolName != nil {
		var loadBalancerBackendPoolName storage.WorkspaceCustomStringParameter
		err := parameters.LoadBalancerBackendPoolName.AssignProperties_To_WorkspaceCustomStringParameter(&loadBalancerBackendPoolName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter() to populate field LoadBalancerBackendPoolName")
		}
		destination.LoadBalancerBackendPoolName = &loadBalancerBackendPoolName
	} else {
		destination.LoadBalancerBackendPoolName = nil
	}

	// LoadBalancerId
	if parameters.LoadBalancerId != nil {
		var loadBalancerId storage.WorkspaceCustomStringParameter
		err := parameters.LoadBalancerId.AssignProperties_To_WorkspaceCustomStringParameter(&loadBalancerId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter() to populate field LoadBalancerId")
		}
		destination.LoadBalancerId = &loadBalancerId
	} else {
		destination.LoadBalancerId = nil
	}

	// NatGatewayName
	if parameters.NatGatewayName != nil {
		var natGatewayName storage.WorkspaceCustomStringParameter
		err := parameters.NatGatewayName.AssignProperties_To_WorkspaceCustomStringParameter(&natGatewayName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter() to populate field NatGatewayName")
		}
		destination.NatGatewayName = &natGatewayName
	} else {
		destination.NatGatewayName = nil
	}

	// PrepareEncryption
	if parameters.PrepareEncryption != nil {
		var prepareEncryption storage.WorkspaceCustomBooleanParameter
		err := parameters.PrepareEncryption.AssignProperties_To_WorkspaceCustomBooleanParameter(&prepareEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomBooleanParameter() to populate field PrepareEncryption")
		}
		destination.PrepareEncryption = &prepareEncryption
	} else {
		destination.PrepareEncryption = nil
	}

	// PublicIpName
	if parameters.PublicIpName != nil {
		var publicIpName storage.WorkspaceCustomStringParameter
		err := parameters.PublicIpName.AssignProperties_To_WorkspaceCustomStringParameter(&publicIpName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter() to populate field PublicIpName")
		}
		destination.PublicIpName = &publicIpName
	} else {
		destination.PublicIpName = nil
	}

	// RequireInfrastructureEncryption
	if parameters.RequireInfrastructureEncryption != nil {
		var requireInfrastructureEncryption storage.WorkspaceCustomBooleanParameter
		err := parameters.RequireInfrastructureEncryption.AssignProperties_To_WorkspaceCustomBooleanParameter(&requireInfrastructureEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomBooleanParameter() to populate field RequireInfrastructureEncryption")
		}
		destination.RequireInfrastructureEncryption = &requireInfrastructureEncryption
	} else {
		destination.RequireInfrastructureEncryption = nil
	}

	// StorageAccountName
	if parameters.StorageAccountName != nil {
		var storageAccountName storage.WorkspaceCustomStringParameter
		err := parameters.StorageAccountName.AssignProperties_To_WorkspaceCustomStringParameter(&storageAccountName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter() to populate field StorageAccountName")
		}
		destination.StorageAccountName = &storageAccountName
	} else {
		destination.StorageAccountName = nil
	}

	// StorageAccountSkuName
	if parameters.StorageAccountSkuName != nil {
		var storageAccountSkuName storage.WorkspaceCustomStringParameter
		err := parameters.StorageAccountSkuName.AssignProperties_To_WorkspaceCustomStringParameter(&storageAccountSkuName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter() to populate field StorageAccountSkuName")
		}
		destination.StorageAccountSkuName = &storageAccountSkuName
	} else {
		destination.StorageAccountSkuName = nil
	}

	// VnetAddressPrefix
	if parameters.VnetAddressPrefix != nil {
		var vnetAddressPrefix storage.WorkspaceCustomStringParameter
		err := parameters.VnetAddressPrefix.AssignProperties_To_WorkspaceCustomStringParameter(&vnetAddressPrefix)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter() to populate field VnetAddressPrefix")
		}
		destination.VnetAddressPrefix = &vnetAddressPrefix
	} else {
		destination.VnetAddressPrefix = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceCustomParameters_STATUS populates our WorkspaceCustomParameters from the provided source WorkspaceCustomParameters_STATUS
func (parameters *WorkspaceCustomParameters) Initialize_From_WorkspaceCustomParameters_STATUS(source *WorkspaceCustomParameters_STATUS) error {

	// AmlWorkspaceId
	if source.AmlWorkspaceId != nil {
		var amlWorkspaceId WorkspaceCustomStringParameter
		err := amlWorkspaceId.Initialize_From_WorkspaceCustomStringParameter_STATUS(source.AmlWorkspaceId)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceCustomStringParameter_STATUS() to populate field AmlWorkspaceId")
		}
		parameters.AmlWorkspaceId = &amlWorkspaceId
	} else {
		parameters.AmlWorkspaceId = nil
	}

	// CustomPrivateSubnetName
	if source.CustomPrivateSubnetName != nil {
		var customPrivateSubnetName WorkspaceCustomStringParameter
		err := customPrivateSubnetName.Initialize_From_WorkspaceCustomStringParameter_STATUS(source.CustomPrivateSubnetName)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceCustomStringParameter_STATUS() to populate field CustomPrivateSubnetName")
		}
		parameters.CustomPrivateSubnetName = &customPrivateSubnetName
	} else {
		parameters.CustomPrivateSubnetName = nil
	}

	// CustomPublicSubnetName
	if source.CustomPublicSubnetName != nil {
		var customPublicSubnetName WorkspaceCustomStringParameter
		err := customPublicSubnetName.Initialize_From_WorkspaceCustomStringParameter_STATUS(source.CustomPublicSubnetName)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceCustomStringParameter_STATUS() to populate field CustomPublicSubnetName")
		}
		parameters.CustomPublicSubnetName = &customPublicSubnetName
	} else {
		parameters.CustomPublicSubnetName = nil
	}

	// CustomVirtualNetworkId
	if source.CustomVirtualNetworkId != nil {
		var customVirtualNetworkId WorkspaceCustomStringParameter
		err := customVirtualNetworkId.Initialize_From_WorkspaceCustomStringParameter_STATUS(source.CustomVirtualNetworkId)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceCustomStringParameter_STATUS() to populate field CustomVirtualNetworkId")
		}
		parameters.CustomVirtualNetworkId = &customVirtualNetworkId
	} else {
		parameters.CustomVirtualNetworkId = nil
	}

	// EnableNoPublicIp
	if source.EnableNoPublicIp != nil {
		var enableNoPublicIp WorkspaceNoPublicIPBooleanParameter
		err := enableNoPublicIp.Initialize_From_WorkspaceNoPublicIPBooleanParameter_STATUS(source.EnableNoPublicIp)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceNoPublicIPBooleanParameter_STATUS() to populate field EnableNoPublicIp")
		}
		parameters.EnableNoPublicIp = &enableNoPublicIp
	} else {
		parameters.EnableNoPublicIp = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption WorkspaceEncryptionParameter
		err := encryption.Initialize_From_WorkspaceEncryptionParameter_STATUS(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceEncryptionParameter_STATUS() to populate field Encryption")
		}
		parameters.Encryption = &encryption
	} else {
		parameters.Encryption = nil
	}

	// LoadBalancerBackendPoolName
	if source.LoadBalancerBackendPoolName != nil {
		var loadBalancerBackendPoolName WorkspaceCustomStringParameter
		err := loadBalancerBackendPoolName.Initialize_From_WorkspaceCustomStringParameter_STATUS(source.LoadBalancerBackendPoolName)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceCustomStringParameter_STATUS() to populate field LoadBalancerBackendPoolName")
		}
		parameters.LoadBalancerBackendPoolName = &loadBalancerBackendPoolName
	} else {
		parameters.LoadBalancerBackendPoolName = nil
	}

	// LoadBalancerId
	if source.LoadBalancerId != nil {
		var loadBalancerId WorkspaceCustomStringParameter
		err := loadBalancerId.Initialize_From_WorkspaceCustomStringParameter_STATUS(source.LoadBalancerId)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceCustomStringParameter_STATUS() to populate field LoadBalancerId")
		}
		parameters.LoadBalancerId = &loadBalancerId
	} else {
		parameters.LoadBalancerId = nil
	}

	// NatGatewayName
	if source.NatGatewayName != nil {
		var natGatewayName WorkspaceCustomStringParameter
		err := natGatewayName.Initialize_From_WorkspaceCustomStringParameter_STATUS(source.NatGatewayName)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceCustomStringParameter_STATUS() to populate field NatGatewayName")
		}
		parameters.NatGatewayName = &natGatewayName
	} else {
		parameters.NatGatewayName = nil
	}

	// PrepareEncryption
	if source.PrepareEncryption != nil {
		var prepareEncryption WorkspaceCustomBooleanParameter
		err := prepareEncryption.Initialize_From_WorkspaceCustomBooleanParameter_STATUS(source.PrepareEncryption)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceCustomBooleanParameter_STATUS() to populate field PrepareEncryption")
		}
		parameters.PrepareEncryption = &prepareEncryption
	} else {
		parameters.PrepareEncryption = nil
	}

	// PublicIpName
	if source.PublicIpName != nil {
		var publicIpName WorkspaceCustomStringParameter
		err := publicIpName.Initialize_From_WorkspaceCustomStringParameter_STATUS(source.PublicIpName)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceCustomStringParameter_STATUS() to populate field PublicIpName")
		}
		parameters.PublicIpName = &publicIpName
	} else {
		parameters.PublicIpName = nil
	}

	// RequireInfrastructureEncryption
	if source.RequireInfrastructureEncryption != nil {
		var requireInfrastructureEncryption WorkspaceCustomBooleanParameter
		err := requireInfrastructureEncryption.Initialize_From_WorkspaceCustomBooleanParameter_STATUS(source.RequireInfrastructureEncryption)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceCustomBooleanParameter_STATUS() to populate field RequireInfrastructureEncryption")
		}
		parameters.RequireInfrastructureEncryption = &requireInfrastructureEncryption
	} else {
		parameters.RequireInfrastructureEncryption = nil
	}

	// StorageAccountName
	if source.StorageAccountName != nil {
		var storageAccountName WorkspaceCustomStringParameter
		err := storageAccountName.Initialize_From_WorkspaceCustomStringParameter_STATUS(source.StorageAccountName)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceCustomStringParameter_STATUS() to populate field StorageAccountName")
		}
		parameters.StorageAccountName = &storageAccountName
	} else {
		parameters.StorageAccountName = nil
	}

	// StorageAccountSkuName
	if source.StorageAccountSkuName != nil {
		var storageAccountSkuName WorkspaceCustomStringParameter
		err := storageAccountSkuName.Initialize_From_WorkspaceCustomStringParameter_STATUS(source.StorageAccountSkuName)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceCustomStringParameter_STATUS() to populate field StorageAccountSkuName")
		}
		parameters.StorageAccountSkuName = &storageAccountSkuName
	} else {
		parameters.StorageAccountSkuName = nil
	}

	// VnetAddressPrefix
	if source.VnetAddressPrefix != nil {
		var vnetAddressPrefix WorkspaceCustomStringParameter
		err := vnetAddressPrefix.Initialize_From_WorkspaceCustomStringParameter_STATUS(source.VnetAddressPrefix)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_WorkspaceCustomStringParameter_STATUS() to populate field VnetAddressPrefix")
		}
		parameters.VnetAddressPrefix = &vnetAddressPrefix
	} else {
		parameters.VnetAddressPrefix = nil
	}

	// No error
	return nil
}

// Custom Parameters used for Cluster Creation.
type WorkspaceCustomParameters_STATUS struct {
	// AmlWorkspaceId: The ID of a Azure Machine Learning workspace to link with Databricks workspace
	AmlWorkspaceId *WorkspaceCustomStringParameter_STATUS `json:"amlWorkspaceId,omitempty"`

	// CustomPrivateSubnetName: The name of the Private Subnet within the Virtual Network
	CustomPrivateSubnetName *WorkspaceCustomStringParameter_STATUS `json:"customPrivateSubnetName,omitempty"`

	// CustomPublicSubnetName: The name of a Public Subnet within the Virtual Network
	CustomPublicSubnetName *WorkspaceCustomStringParameter_STATUS `json:"customPublicSubnetName,omitempty"`

	// CustomVirtualNetworkId: The ID of a Virtual Network where this Databricks Cluster should be created
	CustomVirtualNetworkId *WorkspaceCustomStringParameter_STATUS `json:"customVirtualNetworkId,omitempty"`

	// EnableNoPublicIp: Boolean indicating whether the public IP should be disabled. Default value is true
	EnableNoPublicIp *WorkspaceNoPublicIPBooleanParameter_STATUS `json:"enableNoPublicIp,omitempty"`

	// Encryption: Contains the encryption details for Customer-Managed Key (CMK) enabled workspace.
	Encryption *WorkspaceEncryptionParameter_STATUS `json:"encryption,omitempty"`

	// LoadBalancerBackendPoolName: Name of the outbound Load Balancer Backend Pool for Secure Cluster Connectivity (No Public
	// IP).
	LoadBalancerBackendPoolName *WorkspaceCustomStringParameter_STATUS `json:"loadBalancerBackendPoolName,omitempty"`

	// LoadBalancerId: Resource URI of Outbound Load balancer for Secure Cluster Connectivity (No Public IP) workspace.
	LoadBalancerId *WorkspaceCustomStringParameter_STATUS `json:"loadBalancerId,omitempty"`

	// NatGatewayName: Name of the NAT gateway for Secure Cluster Connectivity (No Public IP) workspace subnets.
	NatGatewayName *WorkspaceCustomStringParameter_STATUS `json:"natGatewayName,omitempty"`

	// PrepareEncryption: Prepare the workspace for encryption. Enables the Managed Identity for managed storage account.
	PrepareEncryption *WorkspaceCustomBooleanParameter_STATUS `json:"prepareEncryption,omitempty"`

	// PublicIpName: Name of the Public IP for No Public IP workspace with managed vNet.
	PublicIpName *WorkspaceCustomStringParameter_STATUS `json:"publicIpName,omitempty"`

	// RequireInfrastructureEncryption: A boolean indicating whether or not the DBFS root file system will be enabled with
	// secondary layer of encryption with platform managed keys for data at rest.
	RequireInfrastructureEncryption *WorkspaceCustomBooleanParameter_STATUS `json:"requireInfrastructureEncryption,omitempty"`

	// ResourceTags: Tags applied to resources under Managed resource group. These can be updated by updating tags at workspace
	// level.
	ResourceTags *WorkspaceCustomObjectParameter_STATUS `json:"resourceTags,omitempty"`

	// StorageAccountName: Default DBFS storage account name.
	StorageAccountName *WorkspaceCustomStringParameter_STATUS `json:"storageAccountName,omitempty"`

	// StorageAccountSkuName: Storage account SKU name, ex: Standard_GRS, Standard_LRS. Refer https://aka.ms/storageskus for
	// valid inputs.
	StorageAccountSkuName *WorkspaceCustomStringParameter_STATUS `json:"storageAccountSkuName,omitempty"`

	// VnetAddressPrefix: Address prefix for Managed virtual network. Default value for this input is 10.139.
	VnetAddressPrefix *WorkspaceCustomStringParameter_STATUS `json:"vnetAddressPrefix,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceCustomParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *WorkspaceCustomParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceCustomParameters_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *WorkspaceCustomParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceCustomParameters_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceCustomParameters_STATUS, got %T", armInput)
	}

	// Set property "AmlWorkspaceId":
	if typedInput.AmlWorkspaceId != nil {
		var amlWorkspaceId1 WorkspaceCustomStringParameter_STATUS
		err := amlWorkspaceId1.PopulateFromARM(owner, *typedInput.AmlWorkspaceId)
		if err != nil {
			return err
		}
		amlWorkspaceId := amlWorkspaceId1
		parameters.AmlWorkspaceId = &amlWorkspaceId
	}

	// Set property "CustomPrivateSubnetName":
	if typedInput.CustomPrivateSubnetName != nil {
		var customPrivateSubnetName1 WorkspaceCustomStringParameter_STATUS
		err := customPrivateSubnetName1.PopulateFromARM(owner, *typedInput.CustomPrivateSubnetName)
		if err != nil {
			return err
		}
		customPrivateSubnetName := customPrivateSubnetName1
		parameters.CustomPrivateSubnetName = &customPrivateSubnetName
	}

	// Set property "CustomPublicSubnetName":
	if typedInput.CustomPublicSubnetName != nil {
		var customPublicSubnetName1 WorkspaceCustomStringParameter_STATUS
		err := customPublicSubnetName1.PopulateFromARM(owner, *typedInput.CustomPublicSubnetName)
		if err != nil {
			return err
		}
		customPublicSubnetName := customPublicSubnetName1
		parameters.CustomPublicSubnetName = &customPublicSubnetName
	}

	// Set property "CustomVirtualNetworkId":
	if typedInput.CustomVirtualNetworkId != nil {
		var customVirtualNetworkId1 WorkspaceCustomStringParameter_STATUS
		err := customVirtualNetworkId1.PopulateFromARM(owner, *typedInput.CustomVirtualNetworkId)
		if err != nil {
			return err
		}
		customVirtualNetworkId := customVirtualNetworkId1
		parameters.CustomVirtualNetworkId = &customVirtualNetworkId
	}

	// Set property "EnableNoPublicIp":
	if typedInput.EnableNoPublicIp != nil {
		var enableNoPublicIp1 WorkspaceNoPublicIPBooleanParameter_STATUS
		err := enableNoPublicIp1.PopulateFromARM(owner, *typedInput.EnableNoPublicIp)
		if err != nil {
			return err
		}
		enableNoPublicIp := enableNoPublicIp1
		parameters.EnableNoPublicIp = &enableNoPublicIp
	}

	// Set property "Encryption":
	if typedInput.Encryption != nil {
		var encryption1 WorkspaceEncryptionParameter_STATUS
		err := encryption1.PopulateFromARM(owner, *typedInput.Encryption)
		if err != nil {
			return err
		}
		encryption := encryption1
		parameters.Encryption = &encryption
	}

	// Set property "LoadBalancerBackendPoolName":
	if typedInput.LoadBalancerBackendPoolName != nil {
		var loadBalancerBackendPoolName1 WorkspaceCustomStringParameter_STATUS
		err := loadBalancerBackendPoolName1.PopulateFromARM(owner, *typedInput.LoadBalancerBackendPoolName)
		if err != nil {
			return err
		}
		loadBalancerBackendPoolName := loadBalancerBackendPoolName1
		parameters.LoadBalancerBackendPoolName = &loadBalancerBackendPoolName
	}

	// Set property "LoadBalancerId":
	if typedInput.LoadBalancerId != nil {
		var loadBalancerId1 WorkspaceCustomStringParameter_STATUS
		err := loadBalancerId1.PopulateFromARM(owner, *typedInput.LoadBalancerId)
		if err != nil {
			return err
		}
		loadBalancerId := loadBalancerId1
		parameters.LoadBalancerId = &loadBalancerId
	}

	// Set property "NatGatewayName":
	if typedInput.NatGatewayName != nil {
		var natGatewayName1 WorkspaceCustomStringParameter_STATUS
		err := natGatewayName1.PopulateFromARM(owner, *typedInput.NatGatewayName)
		if err != nil {
			return err
		}
		natGatewayName := natGatewayName1
		parameters.NatGatewayName = &natGatewayName
	}

	// Set property "PrepareEncryption":
	if typedInput.PrepareEncryption != nil {
		var prepareEncryption1 WorkspaceCustomBooleanParameter_STATUS
		err := prepareEncryption1.PopulateFromARM(owner, *typedInput.PrepareEncryption)
		if err != nil {
			return err
		}
		prepareEncryption := prepareEncryption1
		parameters.PrepareEncryption = &prepareEncryption
	}

	// Set property "PublicIpName":
	if typedInput.PublicIpName != nil {
		var publicIpName1 WorkspaceCustomStringParameter_STATUS
		err := publicIpName1.PopulateFromARM(owner, *typedInput.PublicIpName)
		if err != nil {
			return err
		}
		publicIpName := publicIpName1
		parameters.PublicIpName = &publicIpName
	}

	// Set property "RequireInfrastructureEncryption":
	if typedInput.RequireInfrastructureEncryption != nil {
		var requireInfrastructureEncryption1 WorkspaceCustomBooleanParameter_STATUS
		err := requireInfrastructureEncryption1.PopulateFromARM(owner, *typedInput.RequireInfrastructureEncryption)
		if err != nil {
			return err
		}
		requireInfrastructureEncryption := requireInfrastructureEncryption1
		parameters.RequireInfrastructureEncryption = &requireInfrastructureEncryption
	}

	// Set property "ResourceTags":
	if typedInput.ResourceTags != nil {
		var resourceTags1 WorkspaceCustomObjectParameter_STATUS
		err := resourceTags1.PopulateFromARM(owner, *typedInput.ResourceTags)
		if err != nil {
			return err
		}
		resourceTags := resourceTags1
		parameters.ResourceTags = &resourceTags
	}

	// Set property "StorageAccountName":
	if typedInput.StorageAccountName != nil {
		var storageAccountName1 WorkspaceCustomStringParameter_STATUS
		err := storageAccountName1.PopulateFromARM(owner, *typedInput.StorageAccountName)
		if err != nil {
			return err
		}
		storageAccountName := storageAccountName1
		parameters.StorageAccountName = &storageAccountName
	}

	// Set property "StorageAccountSkuName":
	if typedInput.StorageAccountSkuName != nil {
		var storageAccountSkuName1 WorkspaceCustomStringParameter_STATUS
		err := storageAccountSkuName1.PopulateFromARM(owner, *typedInput.StorageAccountSkuName)
		if err != nil {
			return err
		}
		storageAccountSkuName := storageAccountSkuName1
		parameters.StorageAccountSkuName = &storageAccountSkuName
	}

	// Set property "VnetAddressPrefix":
	if typedInput.VnetAddressPrefix != nil {
		var vnetAddressPrefix1 WorkspaceCustomStringParameter_STATUS
		err := vnetAddressPrefix1.PopulateFromARM(owner, *typedInput.VnetAddressPrefix)
		if err != nil {
			return err
		}
		vnetAddressPrefix := vnetAddressPrefix1
		parameters.VnetAddressPrefix = &vnetAddressPrefix
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceCustomParameters_STATUS populates our WorkspaceCustomParameters_STATUS from the provided source WorkspaceCustomParameters_STATUS
func (parameters *WorkspaceCustomParameters_STATUS) AssignProperties_From_WorkspaceCustomParameters_STATUS(source *storage.WorkspaceCustomParameters_STATUS) error {

	// AmlWorkspaceId
	if source.AmlWorkspaceId != nil {
		var amlWorkspaceId WorkspaceCustomStringParameter_STATUS
		err := amlWorkspaceId.AssignProperties_From_WorkspaceCustomStringParameter_STATUS(source.AmlWorkspaceId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter_STATUS() to populate field AmlWorkspaceId")
		}
		parameters.AmlWorkspaceId = &amlWorkspaceId
	} else {
		parameters.AmlWorkspaceId = nil
	}

	// CustomPrivateSubnetName
	if source.CustomPrivateSubnetName != nil {
		var customPrivateSubnetName WorkspaceCustomStringParameter_STATUS
		err := customPrivateSubnetName.AssignProperties_From_WorkspaceCustomStringParameter_STATUS(source.CustomPrivateSubnetName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter_STATUS() to populate field CustomPrivateSubnetName")
		}
		parameters.CustomPrivateSubnetName = &customPrivateSubnetName
	} else {
		parameters.CustomPrivateSubnetName = nil
	}

	// CustomPublicSubnetName
	if source.CustomPublicSubnetName != nil {
		var customPublicSubnetName WorkspaceCustomStringParameter_STATUS
		err := customPublicSubnetName.AssignProperties_From_WorkspaceCustomStringParameter_STATUS(source.CustomPublicSubnetName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter_STATUS() to populate field CustomPublicSubnetName")
		}
		parameters.CustomPublicSubnetName = &customPublicSubnetName
	} else {
		parameters.CustomPublicSubnetName = nil
	}

	// CustomVirtualNetworkId
	if source.CustomVirtualNetworkId != nil {
		var customVirtualNetworkId WorkspaceCustomStringParameter_STATUS
		err := customVirtualNetworkId.AssignProperties_From_WorkspaceCustomStringParameter_STATUS(source.CustomVirtualNetworkId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter_STATUS() to populate field CustomVirtualNetworkId")
		}
		parameters.CustomVirtualNetworkId = &customVirtualNetworkId
	} else {
		parameters.CustomVirtualNetworkId = nil
	}

	// EnableNoPublicIp
	if source.EnableNoPublicIp != nil {
		var enableNoPublicIp WorkspaceNoPublicIPBooleanParameter_STATUS
		err := enableNoPublicIp.AssignProperties_From_WorkspaceNoPublicIPBooleanParameter_STATUS(source.EnableNoPublicIp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceNoPublicIPBooleanParameter_STATUS() to populate field EnableNoPublicIp")
		}
		parameters.EnableNoPublicIp = &enableNoPublicIp
	} else {
		parameters.EnableNoPublicIp = nil
	}

	// Encryption
	if source.Encryption != nil {
		var encryption WorkspaceEncryptionParameter_STATUS
		err := encryption.AssignProperties_From_WorkspaceEncryptionParameter_STATUS(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceEncryptionParameter_STATUS() to populate field Encryption")
		}
		parameters.Encryption = &encryption
	} else {
		parameters.Encryption = nil
	}

	// LoadBalancerBackendPoolName
	if source.LoadBalancerBackendPoolName != nil {
		var loadBalancerBackendPoolName WorkspaceCustomStringParameter_STATUS
		err := loadBalancerBackendPoolName.AssignProperties_From_WorkspaceCustomStringParameter_STATUS(source.LoadBalancerBackendPoolName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter_STATUS() to populate field LoadBalancerBackendPoolName")
		}
		parameters.LoadBalancerBackendPoolName = &loadBalancerBackendPoolName
	} else {
		parameters.LoadBalancerBackendPoolName = nil
	}

	// LoadBalancerId
	if source.LoadBalancerId != nil {
		var loadBalancerId WorkspaceCustomStringParameter_STATUS
		err := loadBalancerId.AssignProperties_From_WorkspaceCustomStringParameter_STATUS(source.LoadBalancerId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter_STATUS() to populate field LoadBalancerId")
		}
		parameters.LoadBalancerId = &loadBalancerId
	} else {
		parameters.LoadBalancerId = nil
	}

	// NatGatewayName
	if source.NatGatewayName != nil {
		var natGatewayName WorkspaceCustomStringParameter_STATUS
		err := natGatewayName.AssignProperties_From_WorkspaceCustomStringParameter_STATUS(source.NatGatewayName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter_STATUS() to populate field NatGatewayName")
		}
		parameters.NatGatewayName = &natGatewayName
	} else {
		parameters.NatGatewayName = nil
	}

	// PrepareEncryption
	if source.PrepareEncryption != nil {
		var prepareEncryption WorkspaceCustomBooleanParameter_STATUS
		err := prepareEncryption.AssignProperties_From_WorkspaceCustomBooleanParameter_STATUS(source.PrepareEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomBooleanParameter_STATUS() to populate field PrepareEncryption")
		}
		parameters.PrepareEncryption = &prepareEncryption
	} else {
		parameters.PrepareEncryption = nil
	}

	// PublicIpName
	if source.PublicIpName != nil {
		var publicIpName WorkspaceCustomStringParameter_STATUS
		err := publicIpName.AssignProperties_From_WorkspaceCustomStringParameter_STATUS(source.PublicIpName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter_STATUS() to populate field PublicIpName")
		}
		parameters.PublicIpName = &publicIpName
	} else {
		parameters.PublicIpName = nil
	}

	// RequireInfrastructureEncryption
	if source.RequireInfrastructureEncryption != nil {
		var requireInfrastructureEncryption WorkspaceCustomBooleanParameter_STATUS
		err := requireInfrastructureEncryption.AssignProperties_From_WorkspaceCustomBooleanParameter_STATUS(source.RequireInfrastructureEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomBooleanParameter_STATUS() to populate field RequireInfrastructureEncryption")
		}
		parameters.RequireInfrastructureEncryption = &requireInfrastructureEncryption
	} else {
		parameters.RequireInfrastructureEncryption = nil
	}

	// ResourceTags
	if source.ResourceTags != nil {
		var resourceTag WorkspaceCustomObjectParameter_STATUS
		err := resourceTag.AssignProperties_From_WorkspaceCustomObjectParameter_STATUS(source.ResourceTags)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomObjectParameter_STATUS() to populate field ResourceTags")
		}
		parameters.ResourceTags = &resourceTag
	} else {
		parameters.ResourceTags = nil
	}

	// StorageAccountName
	if source.StorageAccountName != nil {
		var storageAccountName WorkspaceCustomStringParameter_STATUS
		err := storageAccountName.AssignProperties_From_WorkspaceCustomStringParameter_STATUS(source.StorageAccountName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter_STATUS() to populate field StorageAccountName")
		}
		parameters.StorageAccountName = &storageAccountName
	} else {
		parameters.StorageAccountName = nil
	}

	// StorageAccountSkuName
	if source.StorageAccountSkuName != nil {
		var storageAccountSkuName WorkspaceCustomStringParameter_STATUS
		err := storageAccountSkuName.AssignProperties_From_WorkspaceCustomStringParameter_STATUS(source.StorageAccountSkuName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter_STATUS() to populate field StorageAccountSkuName")
		}
		parameters.StorageAccountSkuName = &storageAccountSkuName
	} else {
		parameters.StorageAccountSkuName = nil
	}

	// VnetAddressPrefix
	if source.VnetAddressPrefix != nil {
		var vnetAddressPrefix WorkspaceCustomStringParameter_STATUS
		err := vnetAddressPrefix.AssignProperties_From_WorkspaceCustomStringParameter_STATUS(source.VnetAddressPrefix)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_WorkspaceCustomStringParameter_STATUS() to populate field VnetAddressPrefix")
		}
		parameters.VnetAddressPrefix = &vnetAddressPrefix
	} else {
		parameters.VnetAddressPrefix = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceCustomParameters_STATUS populates the provided destination WorkspaceCustomParameters_STATUS from our WorkspaceCustomParameters_STATUS
func (parameters *WorkspaceCustomParameters_STATUS) AssignProperties_To_WorkspaceCustomParameters_STATUS(destination *storage.WorkspaceCustomParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AmlWorkspaceId
	if parameters.AmlWorkspaceId != nil {
		var amlWorkspaceId storage.WorkspaceCustomStringParameter_STATUS
		err := parameters.AmlWorkspaceId.AssignProperties_To_WorkspaceCustomStringParameter_STATUS(&amlWorkspaceId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter_STATUS() to populate field AmlWorkspaceId")
		}
		destination.AmlWorkspaceId = &amlWorkspaceId
	} else {
		destination.AmlWorkspaceId = nil
	}

	// CustomPrivateSubnetName
	if parameters.CustomPrivateSubnetName != nil {
		var customPrivateSubnetName storage.WorkspaceCustomStringParameter_STATUS
		err := parameters.CustomPrivateSubnetName.AssignProperties_To_WorkspaceCustomStringParameter_STATUS(&customPrivateSubnetName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter_STATUS() to populate field CustomPrivateSubnetName")
		}
		destination.CustomPrivateSubnetName = &customPrivateSubnetName
	} else {
		destination.CustomPrivateSubnetName = nil
	}

	// CustomPublicSubnetName
	if parameters.CustomPublicSubnetName != nil {
		var customPublicSubnetName storage.WorkspaceCustomStringParameter_STATUS
		err := parameters.CustomPublicSubnetName.AssignProperties_To_WorkspaceCustomStringParameter_STATUS(&customPublicSubnetName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter_STATUS() to populate field CustomPublicSubnetName")
		}
		destination.CustomPublicSubnetName = &customPublicSubnetName
	} else {
		destination.CustomPublicSubnetName = nil
	}

	// CustomVirtualNetworkId
	if parameters.CustomVirtualNetworkId != nil {
		var customVirtualNetworkId storage.WorkspaceCustomStringParameter_STATUS
		err := parameters.CustomVirtualNetworkId.AssignProperties_To_WorkspaceCustomStringParameter_STATUS(&customVirtualNetworkId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter_STATUS() to populate field CustomVirtualNetworkId")
		}
		destination.CustomVirtualNetworkId = &customVirtualNetworkId
	} else {
		destination.CustomVirtualNetworkId = nil
	}

	// EnableNoPublicIp
	if parameters.EnableNoPublicIp != nil {
		var enableNoPublicIp storage.WorkspaceNoPublicIPBooleanParameter_STATUS
		err := parameters.EnableNoPublicIp.AssignProperties_To_WorkspaceNoPublicIPBooleanParameter_STATUS(&enableNoPublicIp)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceNoPublicIPBooleanParameter_STATUS() to populate field EnableNoPublicIp")
		}
		destination.EnableNoPublicIp = &enableNoPublicIp
	} else {
		destination.EnableNoPublicIp = nil
	}

	// Encryption
	if parameters.Encryption != nil {
		var encryption storage.WorkspaceEncryptionParameter_STATUS
		err := parameters.Encryption.AssignProperties_To_WorkspaceEncryptionParameter_STATUS(&encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceEncryptionParameter_STATUS() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// LoadBalancerBackendPoolName
	if parameters.LoadBalancerBackendPoolName != nil {
		var loadBalancerBackendPoolName storage.WorkspaceCustomStringParameter_STATUS
		err := parameters.LoadBalancerBackendPoolName.AssignProperties_To_WorkspaceCustomStringParameter_STATUS(&loadBalancerBackendPoolName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter_STATUS() to populate field LoadBalancerBackendPoolName")
		}
		destination.LoadBalancerBackendPoolName = &loadBalancerBackendPoolName
	} else {
		destination.LoadBalancerBackendPoolName = nil
	}

	// LoadBalancerId
	if parameters.LoadBalancerId != nil {
		var loadBalancerId storage.WorkspaceCustomStringParameter_STATUS
		err := parameters.LoadBalancerId.AssignProperties_To_WorkspaceCustomStringParameter_STATUS(&loadBalancerId)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter_STATUS() to populate field LoadBalancerId")
		}
		destination.LoadBalancerId = &loadBalancerId
	} else {
		destination.LoadBalancerId = nil
	}

	// NatGatewayName
	if parameters.NatGatewayName != nil {
		var natGatewayName storage.WorkspaceCustomStringParameter_STATUS
		err := parameters.NatGatewayName.AssignProperties_To_WorkspaceCustomStringParameter_STATUS(&natGatewayName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter_STATUS() to populate field NatGatewayName")
		}
		destination.NatGatewayName = &natGatewayName
	} else {
		destination.NatGatewayName = nil
	}

	// PrepareEncryption
	if parameters.PrepareEncryption != nil {
		var prepareEncryption storage.WorkspaceCustomBooleanParameter_STATUS
		err := parameters.PrepareEncryption.AssignProperties_To_WorkspaceCustomBooleanParameter_STATUS(&prepareEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomBooleanParameter_STATUS() to populate field PrepareEncryption")
		}
		destination.PrepareEncryption = &prepareEncryption
	} else {
		destination.PrepareEncryption = nil
	}

	// PublicIpName
	if parameters.PublicIpName != nil {
		var publicIpName storage.WorkspaceCustomStringParameter_STATUS
		err := parameters.PublicIpName.AssignProperties_To_WorkspaceCustomStringParameter_STATUS(&publicIpName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter_STATUS() to populate field PublicIpName")
		}
		destination.PublicIpName = &publicIpName
	} else {
		destination.PublicIpName = nil
	}

	// RequireInfrastructureEncryption
	if parameters.RequireInfrastructureEncryption != nil {
		var requireInfrastructureEncryption storage.WorkspaceCustomBooleanParameter_STATUS
		err := parameters.RequireInfrastructureEncryption.AssignProperties_To_WorkspaceCustomBooleanParameter_STATUS(&requireInfrastructureEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomBooleanParameter_STATUS() to populate field RequireInfrastructureEncryption")
		}
		destination.RequireInfrastructureEncryption = &requireInfrastructureEncryption
	} else {
		destination.RequireInfrastructureEncryption = nil
	}

	// ResourceTags
	if parameters.ResourceTags != nil {
		var resourceTag storage.WorkspaceCustomObjectParameter_STATUS
		err := parameters.ResourceTags.AssignProperties_To_WorkspaceCustomObjectParameter_STATUS(&resourceTag)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomObjectParameter_STATUS() to populate field ResourceTags")
		}
		destination.ResourceTags = &resourceTag
	} else {
		destination.ResourceTags = nil
	}

	// StorageAccountName
	if parameters.StorageAccountName != nil {
		var storageAccountName storage.WorkspaceCustomStringParameter_STATUS
		err := parameters.StorageAccountName.AssignProperties_To_WorkspaceCustomStringParameter_STATUS(&storageAccountName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter_STATUS() to populate field StorageAccountName")
		}
		destination.StorageAccountName = &storageAccountName
	} else {
		destination.StorageAccountName = nil
	}

	// StorageAccountSkuName
	if parameters.StorageAccountSkuName != nil {
		var storageAccountSkuName storage.WorkspaceCustomStringParameter_STATUS
		err := parameters.StorageAccountSkuName.AssignProperties_To_WorkspaceCustomStringParameter_STATUS(&storageAccountSkuName)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter_STATUS() to populate field StorageAccountSkuName")
		}
		destination.StorageAccountSkuName = &storageAccountSkuName
	} else {
		destination.StorageAccountSkuName = nil
	}

	// VnetAddressPrefix
	if parameters.VnetAddressPrefix != nil {
		var vnetAddressPrefix storage.WorkspaceCustomStringParameter_STATUS
		err := parameters.VnetAddressPrefix.AssignProperties_To_WorkspaceCustomStringParameter_STATUS(&vnetAddressPrefix)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_WorkspaceCustomStringParameter_STATUS() to populate field VnetAddressPrefix")
		}
		destination.VnetAddressPrefix = &vnetAddressPrefix
	} else {
		destination.VnetAddressPrefix = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type WorkspaceOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_WorkspaceOperatorSpec populates our WorkspaceOperatorSpec from the provided source WorkspaceOperatorSpec
func (operator *WorkspaceOperatorSpec) AssignProperties_From_WorkspaceOperatorSpec(source *storage.WorkspaceOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceOperatorSpec populates the provided destination WorkspaceOperatorSpec from our WorkspaceOperatorSpec
func (operator *WorkspaceOperatorSpec) AssignProperties_To_WorkspaceOperatorSpec(destination *storage.WorkspaceOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type WorkspaceProperties_AccessConnector struct {
	// +kubebuilder:validation:Required
	// IdentityType: The identity type of the Access Connector Resource.
	IdentityType *WorkspaceProperties_AccessConnector_IdentityType `json:"identityType,omitempty"`

	// +kubebuilder:validation:Required
	// Reference: The resource ID of Azure Databricks Access Connector Resource.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`

	// UserAssignedIdentityReference: The resource ID of the User Assigned Identity associated with the Access Connector
	// Resource. This is required for type 'UserAssigned' and not valid for type 'SystemAssigned'.
	UserAssignedIdentityReference *genruntime.ResourceReference `armReference:"UserAssignedIdentityId" json:"userAssignedIdentityReference,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceProperties_AccessConnector{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (connector *WorkspaceProperties_AccessConnector) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if connector == nil {
		return nil, nil
	}
	result := &arm.WorkspaceProperties_AccessConnector{}

	// Set property "Id":
	if connector.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.Lookup(*connector.Reference)
		if err != nil {
			return nil, err
		}
		reference := referenceARMID
		result.Id = &reference
	}

	// Set property "IdentityType":
	if connector.IdentityType != nil {
		var temp string
		temp = string(*connector.IdentityType)
		identityType := arm.WorkspaceProperties_AccessConnector_IdentityType(temp)
		result.IdentityType = &identityType
	}

	// Set property "UserAssignedIdentityId":
	if connector.UserAssignedIdentityReference != nil {
		userAssignedIdentityReferenceARMID, err := resolved.ResolvedReferences.Lookup(*connector.UserAssignedIdentityReference)
		if err != nil {
			return nil, err
		}
		userAssignedIdentityReference := userAssignedIdentityReferenceARMID
		result.UserAssignedIdentityId = &userAssignedIdentityReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connector *WorkspaceProperties_AccessConnector) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceProperties_AccessConnector{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connector *WorkspaceProperties_AccessConnector) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceProperties_AccessConnector)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceProperties_AccessConnector, got %T", armInput)
	}

	// Set property "IdentityType":
	if typedInput.IdentityType != nil {
		var temp string
		temp = string(*typedInput.IdentityType)
		identityType := WorkspaceProperties_AccessConnector_IdentityType(temp)
		connector.IdentityType = &identityType
	}

	// no assignment for property "Reference"

	// no assignment for property "UserAssignedIdentityReference"

	// No error
	return nil
}

// AssignProperties_From_WorkspaceProperties_AccessConnector populates our WorkspaceProperties_AccessConnector from the provided source WorkspaceProperties_AccessConnector
func (connector *WorkspaceProperties_AccessConnector) AssignProperties_From_WorkspaceProperties_AccessConnector(source *storage.WorkspaceProperties_AccessConnector) error {

	// IdentityType
	if source.IdentityType != nil {
		identityType := *source.IdentityType
		identityTypeTemp := genruntime.ToEnum(identityType, workspaceProperties_AccessConnector_IdentityType_Values)
		connector.IdentityType = &identityTypeTemp
	} else {
		connector.IdentityType = nil
	}

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		connector.Reference = &reference
	} else {
		connector.Reference = nil
	}

	// UserAssignedIdentityReference
	if source.UserAssignedIdentityReference != nil {
		userAssignedIdentityReference := source.UserAssignedIdentityReference.Copy()
		connector.UserAssignedIdentityReference = &userAssignedIdentityReference
	} else {
		connector.UserAssignedIdentityReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceProperties_AccessConnector populates the provided destination WorkspaceProperties_AccessConnector from our WorkspaceProperties_AccessConnector
func (connector *WorkspaceProperties_AccessConnector) AssignProperties_To_WorkspaceProperties_AccessConnector(destination *storage.WorkspaceProperties_AccessConnector) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdentityType
	if connector.IdentityType != nil {
		identityType := string(*connector.IdentityType)
		destination.IdentityType = &identityType
	} else {
		destination.IdentityType = nil
	}

	// Reference
	if connector.Reference != nil {
		reference := connector.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// UserAssignedIdentityReference
	if connector.UserAssignedIdentityReference != nil {
		userAssignedIdentityReference := connector.UserAssignedIdentityReference.Copy()
		destination.UserAssignedIdentityReference = &userAssignedIdentityReference
	} else {
		destination.UserAssignedIdentityReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceProperties_AccessConnector_STATUS populates our WorkspaceProperties_AccessConnector from the provided source WorkspaceProperties_AccessConnector_STATUS
func (connector *WorkspaceProperties_AccessConnector) Initialize_From_WorkspaceProperties_AccessConnector_STATUS(source *WorkspaceProperties_AccessConnector_STATUS) error {

	// IdentityType
	if source.IdentityType != nil {
		identityType := genruntime.ToEnum(string(*source.IdentityType), workspaceProperties_AccessConnector_IdentityType_Values)
		connector.IdentityType = &identityType
	} else {
		connector.IdentityType = nil
	}

	// Reference
	if source.Id != nil {
		reference := genruntime.CreateResourceReferenceFromARMID(*source.Id)
		connector.Reference = &reference
	} else {
		connector.Reference = nil
	}

	// UserAssignedIdentityReference
	if source.UserAssignedIdentityId != nil {
		userAssignedIdentityReference := genruntime.CreateResourceReferenceFromARMID(*source.UserAssignedIdentityId)
		connector.UserAssignedIdentityReference = &userAssignedIdentityReference
	} else {
		connector.UserAssignedIdentityReference = nil
	}

	// No error
	return nil
}

type WorkspaceProperties_AccessConnector_STATUS struct {
	// Id: The resource ID of Azure Databricks Access Connector Resource.
	Id *string `json:"id,omitempty"`

	// IdentityType: The identity type of the Access Connector Resource.
	IdentityType *WorkspaceProperties_AccessConnector_IdentityType_STATUS `json:"identityType,omitempty"`

	// UserAssignedIdentityId: The resource ID of the User Assigned Identity associated with the Access Connector Resource.
	// This is required for type 'UserAssigned' and not valid for type 'SystemAssigned'.
	UserAssignedIdentityId *string `json:"userAssignedIdentityId,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceProperties_AccessConnector_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connector *WorkspaceProperties_AccessConnector_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceProperties_AccessConnector_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connector *WorkspaceProperties_AccessConnector_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceProperties_AccessConnector_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceProperties_AccessConnector_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connector.Id = &id
	}

	// Set property "IdentityType":
	if typedInput.IdentityType != nil {
		var temp string
		temp = string(*typedInput.IdentityType)
		identityType := WorkspaceProperties_AccessConnector_IdentityType_STATUS(temp)
		connector.IdentityType = &identityType
	}

	// Set property "UserAssignedIdentityId":
	if typedInput.UserAssignedIdentityId != nil {
		userAssignedIdentityId := *typedInput.UserAssignedIdentityId
		connector.UserAssignedIdentityId = &userAssignedIdentityId
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceProperties_AccessConnector_STATUS populates our WorkspaceProperties_AccessConnector_STATUS from the provided source WorkspaceProperties_AccessConnector_STATUS
func (connector *WorkspaceProperties_AccessConnector_STATUS) AssignProperties_From_WorkspaceProperties_AccessConnector_STATUS(source *storage.WorkspaceProperties_AccessConnector_STATUS) error {

	// Id
	connector.Id = genruntime.ClonePointerToString(source.Id)

	// IdentityType
	if source.IdentityType != nil {
		identityType := *source.IdentityType
		identityTypeTemp := genruntime.ToEnum(identityType, workspaceProperties_AccessConnector_IdentityType_STATUS_Values)
		connector.IdentityType = &identityTypeTemp
	} else {
		connector.IdentityType = nil
	}

	// UserAssignedIdentityId
	connector.UserAssignedIdentityId = genruntime.ClonePointerToString(source.UserAssignedIdentityId)

	// No error
	return nil
}

// AssignProperties_To_WorkspaceProperties_AccessConnector_STATUS populates the provided destination WorkspaceProperties_AccessConnector_STATUS from our WorkspaceProperties_AccessConnector_STATUS
func (connector *WorkspaceProperties_AccessConnector_STATUS) AssignProperties_To_WorkspaceProperties_AccessConnector_STATUS(destination *storage.WorkspaceProperties_AccessConnector_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(connector.Id)

	// IdentityType
	if connector.IdentityType != nil {
		identityType := string(*connector.IdentityType)
		destination.IdentityType = &identityType
	} else {
		destination.IdentityType = nil
	}

	// UserAssignedIdentityId
	destination.UserAssignedIdentityId = genruntime.ClonePointerToString(connector.UserAssignedIdentityId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type WorkspaceProperties_DefaultStorageFirewall string

const (
	WorkspaceProperties_DefaultStorageFirewall_Disabled = WorkspaceProperties_DefaultStorageFirewall("Disabled")
	WorkspaceProperties_DefaultStorageFirewall_Enabled  = WorkspaceProperties_DefaultStorageFirewall("Enabled")
)

// Mapping from string to WorkspaceProperties_DefaultStorageFirewall
var workspaceProperties_DefaultStorageFirewall_Values = map[string]WorkspaceProperties_DefaultStorageFirewall{
	"disabled": WorkspaceProperties_DefaultStorageFirewall_Disabled,
	"enabled":  WorkspaceProperties_DefaultStorageFirewall_Enabled,
}

type WorkspaceProperties_DefaultStorageFirewall_STATUS string

const (
	WorkspaceProperties_DefaultStorageFirewall_STATUS_Disabled = WorkspaceProperties_DefaultStorageFirewall_STATUS("Disabled")
	WorkspaceProperties_DefaultStorageFirewall_STATUS_Enabled  = WorkspaceProperties_DefaultStorageFirewall_STATUS("Enabled")
)

// Mapping from string to WorkspaceProperties_DefaultStorageFirewall_STATUS
var workspaceProperties_DefaultStorageFirewall_STATUS_Values = map[string]WorkspaceProperties_DefaultStorageFirewall_STATUS{
	"disabled": WorkspaceProperties_DefaultStorageFirewall_STATUS_Disabled,
	"enabled":  WorkspaceProperties_DefaultStorageFirewall_STATUS_Enabled,
}

type WorkspaceProperties_Encryption struct {
	// +kubebuilder:validation:Required
	// Entities: Encryption entities definition for the workspace.
	Entities *EncryptionEntitiesDefinition `json:"entities,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceProperties_Encryption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (encryption *WorkspaceProperties_Encryption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if encryption == nil {
		return nil, nil
	}
	result := &arm.WorkspaceProperties_Encryption{}

	// Set property "Entities":
	if encryption.Entities != nil {
		entities_ARM, err := encryption.Entities.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		entities := *entities_ARM.(*arm.EncryptionEntitiesDefinition)
		result.Entities = &entities
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *WorkspaceProperties_Encryption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceProperties_Encryption{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *WorkspaceProperties_Encryption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceProperties_Encryption)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceProperties_Encryption, got %T", armInput)
	}

	// Set property "Entities":
	if typedInput.Entities != nil {
		var entities1 EncryptionEntitiesDefinition
		err := entities1.PopulateFromARM(owner, *typedInput.Entities)
		if err != nil {
			return err
		}
		entities := entities1
		encryption.Entities = &entities
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceProperties_Encryption populates our WorkspaceProperties_Encryption from the provided source WorkspaceProperties_Encryption
func (encryption *WorkspaceProperties_Encryption) AssignProperties_From_WorkspaceProperties_Encryption(source *storage.WorkspaceProperties_Encryption) error {

	// Entities
	if source.Entities != nil {
		var entity EncryptionEntitiesDefinition
		err := entity.AssignProperties_From_EncryptionEntitiesDefinition(source.Entities)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EncryptionEntitiesDefinition() to populate field Entities")
		}
		encryption.Entities = &entity
	} else {
		encryption.Entities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceProperties_Encryption populates the provided destination WorkspaceProperties_Encryption from our WorkspaceProperties_Encryption
func (encryption *WorkspaceProperties_Encryption) AssignProperties_To_WorkspaceProperties_Encryption(destination *storage.WorkspaceProperties_Encryption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Entities
	if encryption.Entities != nil {
		var entity storage.EncryptionEntitiesDefinition
		err := encryption.Entities.AssignProperties_To_EncryptionEntitiesDefinition(&entity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EncryptionEntitiesDefinition() to populate field Entities")
		}
		destination.Entities = &entity
	} else {
		destination.Entities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceProperties_Encryption_STATUS populates our WorkspaceProperties_Encryption from the provided source WorkspaceProperties_Encryption_STATUS
func (encryption *WorkspaceProperties_Encryption) Initialize_From_WorkspaceProperties_Encryption_STATUS(source *WorkspaceProperties_Encryption_STATUS) error {

	// Entities
	if source.Entities != nil {
		var entity EncryptionEntitiesDefinition
		err := entity.Initialize_From_EncryptionEntitiesDefinition_STATUS(source.Entities)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EncryptionEntitiesDefinition_STATUS() to populate field Entities")
		}
		encryption.Entities = &entity
	} else {
		encryption.Entities = nil
	}

	// No error
	return nil
}

type WorkspaceProperties_Encryption_STATUS struct {
	// Entities: Encryption entities definition for the workspace.
	Entities *EncryptionEntitiesDefinition_STATUS `json:"entities,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceProperties_Encryption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *WorkspaceProperties_Encryption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceProperties_Encryption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *WorkspaceProperties_Encryption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceProperties_Encryption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceProperties_Encryption_STATUS, got %T", armInput)
	}

	// Set property "Entities":
	if typedInput.Entities != nil {
		var entities1 EncryptionEntitiesDefinition_STATUS
		err := entities1.PopulateFromARM(owner, *typedInput.Entities)
		if err != nil {
			return err
		}
		entities := entities1
		encryption.Entities = &entities
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceProperties_Encryption_STATUS populates our WorkspaceProperties_Encryption_STATUS from the provided source WorkspaceProperties_Encryption_STATUS
func (encryption *WorkspaceProperties_Encryption_STATUS) AssignProperties_From_WorkspaceProperties_Encryption_STATUS(source *storage.WorkspaceProperties_Encryption_STATUS) error {

	// Entities
	if source.Entities != nil {
		var entity EncryptionEntitiesDefinition_STATUS
		err := entity.AssignProperties_From_EncryptionEntitiesDefinition_STATUS(source.Entities)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EncryptionEntitiesDefinition_STATUS() to populate field Entities")
		}
		encryption.Entities = &entity
	} else {
		encryption.Entities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceProperties_Encryption_STATUS populates the provided destination WorkspaceProperties_Encryption_STATUS from our WorkspaceProperties_Encryption_STATUS
func (encryption *WorkspaceProperties_Encryption_STATUS) AssignProperties_To_WorkspaceProperties_Encryption_STATUS(destination *storage.WorkspaceProperties_Encryption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Entities
	if encryption.Entities != nil {
		var entity storage.EncryptionEntitiesDefinition_STATUS
		err := encryption.Entities.AssignProperties_To_EncryptionEntitiesDefinition_STATUS(&entity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EncryptionEntitiesDefinition_STATUS() to populate field Entities")
		}
		destination.Entities = &entity
	} else {
		destination.Entities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type WorkspaceProperties_PublicNetworkAccess string

const (
	WorkspaceProperties_PublicNetworkAccess_Disabled = WorkspaceProperties_PublicNetworkAccess("Disabled")
	WorkspaceProperties_PublicNetworkAccess_Enabled  = WorkspaceProperties_PublicNetworkAccess("Enabled")
)

// Mapping from string to WorkspaceProperties_PublicNetworkAccess
var workspaceProperties_PublicNetworkAccess_Values = map[string]WorkspaceProperties_PublicNetworkAccess{
	"disabled": WorkspaceProperties_PublicNetworkAccess_Disabled,
	"enabled":  WorkspaceProperties_PublicNetworkAccess_Enabled,
}

type WorkspaceProperties_PublicNetworkAccess_STATUS string

const (
	WorkspaceProperties_PublicNetworkAccess_STATUS_Disabled = WorkspaceProperties_PublicNetworkAccess_STATUS("Disabled")
	WorkspaceProperties_PublicNetworkAccess_STATUS_Enabled  = WorkspaceProperties_PublicNetworkAccess_STATUS("Enabled")
)

// Mapping from string to WorkspaceProperties_PublicNetworkAccess_STATUS
var workspaceProperties_PublicNetworkAccess_STATUS_Values = map[string]WorkspaceProperties_PublicNetworkAccess_STATUS{
	"disabled": WorkspaceProperties_PublicNetworkAccess_STATUS_Disabled,
	"enabled":  WorkspaceProperties_PublicNetworkAccess_STATUS_Enabled,
}

// +kubebuilder:validation:Enum={"AllRules","NoAzureDatabricksRules","NoAzureServiceRules"}
type WorkspaceProperties_RequiredNsgRules string

const (
	WorkspaceProperties_RequiredNsgRules_AllRules               = WorkspaceProperties_RequiredNsgRules("AllRules")
	WorkspaceProperties_RequiredNsgRules_NoAzureDatabricksRules = WorkspaceProperties_RequiredNsgRules("NoAzureDatabricksRules")
	WorkspaceProperties_RequiredNsgRules_NoAzureServiceRules    = WorkspaceProperties_RequiredNsgRules("NoAzureServiceRules")
)

// Mapping from string to WorkspaceProperties_RequiredNsgRules
var workspaceProperties_RequiredNsgRules_Values = map[string]WorkspaceProperties_RequiredNsgRules{
	"allrules":               WorkspaceProperties_RequiredNsgRules_AllRules,
	"noazuredatabricksrules": WorkspaceProperties_RequiredNsgRules_NoAzureDatabricksRules,
	"noazureservicerules":    WorkspaceProperties_RequiredNsgRules_NoAzureServiceRules,
}

type WorkspaceProperties_RequiredNsgRules_STATUS string

const (
	WorkspaceProperties_RequiredNsgRules_STATUS_AllRules               = WorkspaceProperties_RequiredNsgRules_STATUS("AllRules")
	WorkspaceProperties_RequiredNsgRules_STATUS_NoAzureDatabricksRules = WorkspaceProperties_RequiredNsgRules_STATUS("NoAzureDatabricksRules")
	WorkspaceProperties_RequiredNsgRules_STATUS_NoAzureServiceRules    = WorkspaceProperties_RequiredNsgRules_STATUS("NoAzureServiceRules")
)

// Mapping from string to WorkspaceProperties_RequiredNsgRules_STATUS
var workspaceProperties_RequiredNsgRules_STATUS_Values = map[string]WorkspaceProperties_RequiredNsgRules_STATUS{
	"allrules":               WorkspaceProperties_RequiredNsgRules_STATUS_AllRules,
	"noazuredatabricksrules": WorkspaceProperties_RequiredNsgRules_STATUS_NoAzureDatabricksRules,
	"noazureservicerules":    WorkspaceProperties_RequiredNsgRules_STATUS_NoAzureServiceRules,
}

// The workspace provider authorization.
type WorkspaceProviderAuthorization struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$"
	// PrincipalId: The provider's principal identifier. This is the identity that the provider will use to call ARM to manage
	// the workspace resources.
	PrincipalId *string `json:"principalId,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="^[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}$"
	// RoleDefinitionId: The provider's role definition identifier. This role will define all the permissions that the provider
	// must have on the workspace's container resource group. This role definition cannot have permission to delete the
	// resource group.
	RoleDefinitionId *string `json:"roleDefinitionId,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceProviderAuthorization{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (authorization *WorkspaceProviderAuthorization) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if authorization == nil {
		return nil, nil
	}
	result := &arm.WorkspaceProviderAuthorization{}

	// Set property "PrincipalId":
	if authorization.PrincipalId != nil {
		principalId := *authorization.PrincipalId
		result.PrincipalId = &principalId
	}

	// Set property "RoleDefinitionId":
	if authorization.RoleDefinitionId != nil {
		roleDefinitionId := *authorization.RoleDefinitionId
		result.RoleDefinitionId = &roleDefinitionId
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (authorization *WorkspaceProviderAuthorization) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceProviderAuthorization{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (authorization *WorkspaceProviderAuthorization) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceProviderAuthorization)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceProviderAuthorization, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		authorization.PrincipalId = &principalId
	}

	// Set property "RoleDefinitionId":
	if typedInput.RoleDefinitionId != nil {
		roleDefinitionId := *typedInput.RoleDefinitionId
		authorization.RoleDefinitionId = &roleDefinitionId
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceProviderAuthorization populates our WorkspaceProviderAuthorization from the provided source WorkspaceProviderAuthorization
func (authorization *WorkspaceProviderAuthorization) AssignProperties_From_WorkspaceProviderAuthorization(source *storage.WorkspaceProviderAuthorization) error {

	// PrincipalId
	authorization.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// RoleDefinitionId
	authorization.RoleDefinitionId = genruntime.ClonePointerToString(source.RoleDefinitionId)

	// No error
	return nil
}

// AssignProperties_To_WorkspaceProviderAuthorization populates the provided destination WorkspaceProviderAuthorization from our WorkspaceProviderAuthorization
func (authorization *WorkspaceProviderAuthorization) AssignProperties_To_WorkspaceProviderAuthorization(destination *storage.WorkspaceProviderAuthorization) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(authorization.PrincipalId)

	// RoleDefinitionId
	destination.RoleDefinitionId = genruntime.ClonePointerToString(authorization.RoleDefinitionId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceProviderAuthorization_STATUS populates our WorkspaceProviderAuthorization from the provided source WorkspaceProviderAuthorization_STATUS
func (authorization *WorkspaceProviderAuthorization) Initialize_From_WorkspaceProviderAuthorization_STATUS(source *WorkspaceProviderAuthorization_STATUS) error {

	// PrincipalId
	authorization.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// RoleDefinitionId
	authorization.RoleDefinitionId = genruntime.ClonePointerToString(source.RoleDefinitionId)

	// No error
	return nil
}

// The workspace provider authorization.
type WorkspaceProviderAuthorization_STATUS struct {
	// PrincipalId: The provider's principal identifier. This is the identity that the provider will use to call ARM to manage
	// the workspace resources.
	PrincipalId *string `json:"principalId,omitempty"`

	// RoleDefinitionId: The provider's role definition identifier. This role will define all the permissions that the provider
	// must have on the workspace's container resource group. This role definition cannot have permission to delete the
	// resource group.
	RoleDefinitionId *string `json:"roleDefinitionId,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceProviderAuthorization_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (authorization *WorkspaceProviderAuthorization_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceProviderAuthorization_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (authorization *WorkspaceProviderAuthorization_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceProviderAuthorization_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceProviderAuthorization_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		authorization.PrincipalId = &principalId
	}

	// Set property "RoleDefinitionId":
	if typedInput.RoleDefinitionId != nil {
		roleDefinitionId := *typedInput.RoleDefinitionId
		authorization.RoleDefinitionId = &roleDefinitionId
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceProviderAuthorization_STATUS populates our WorkspaceProviderAuthorization_STATUS from the provided source WorkspaceProviderAuthorization_STATUS
func (authorization *WorkspaceProviderAuthorization_STATUS) AssignProperties_From_WorkspaceProviderAuthorization_STATUS(source *storage.WorkspaceProviderAuthorization_STATUS) error {

	// PrincipalId
	authorization.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// RoleDefinitionId
	authorization.RoleDefinitionId = genruntime.ClonePointerToString(source.RoleDefinitionId)

	// No error
	return nil
}

// AssignProperties_To_WorkspaceProviderAuthorization_STATUS populates the provided destination WorkspaceProviderAuthorization_STATUS from our WorkspaceProviderAuthorization_STATUS
func (authorization *WorkspaceProviderAuthorization_STATUS) AssignProperties_To_WorkspaceProviderAuthorization_STATUS(destination *storage.WorkspaceProviderAuthorization_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(authorization.PrincipalId)

	// RoleDefinitionId
	destination.RoleDefinitionId = genruntime.ClonePointerToString(authorization.RoleDefinitionId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Status of automated cluster updates feature.
type AutomaticClusterUpdateDefinition struct {
	Value *AutomaticClusterUpdateDefinition_Value `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &AutomaticClusterUpdateDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *AutomaticClusterUpdateDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.AutomaticClusterUpdateDefinition{}

	// Set property "Value":
	if definition.Value != nil {
		var temp string
		temp = string(*definition.Value)
		value := arm.AutomaticClusterUpdateDefinition_Value(temp)
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *AutomaticClusterUpdateDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutomaticClusterUpdateDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *AutomaticClusterUpdateDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutomaticClusterUpdateDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutomaticClusterUpdateDefinition, got %T", armInput)
	}

	// Set property "Value":
	if typedInput.Value != nil {
		var temp string
		temp = string(*typedInput.Value)
		value := AutomaticClusterUpdateDefinition_Value(temp)
		definition.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_AutomaticClusterUpdateDefinition populates our AutomaticClusterUpdateDefinition from the provided source AutomaticClusterUpdateDefinition
func (definition *AutomaticClusterUpdateDefinition) AssignProperties_From_AutomaticClusterUpdateDefinition(source *storage.AutomaticClusterUpdateDefinition) error {

	// Value
	if source.Value != nil {
		value := *source.Value
		valueTemp := genruntime.ToEnum(value, automaticClusterUpdateDefinition_Value_Values)
		definition.Value = &valueTemp
	} else {
		definition.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutomaticClusterUpdateDefinition populates the provided destination AutomaticClusterUpdateDefinition from our AutomaticClusterUpdateDefinition
func (definition *AutomaticClusterUpdateDefinition) AssignProperties_To_AutomaticClusterUpdateDefinition(destination *storage.AutomaticClusterUpdateDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	if definition.Value != nil {
		value := string(*definition.Value)
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_AutomaticClusterUpdateDefinition_STATUS populates our AutomaticClusterUpdateDefinition from the provided source AutomaticClusterUpdateDefinition_STATUS
func (definition *AutomaticClusterUpdateDefinition) Initialize_From_AutomaticClusterUpdateDefinition_STATUS(source *AutomaticClusterUpdateDefinition_STATUS) error {

	// Value
	if source.Value != nil {
		value := genruntime.ToEnum(string(*source.Value), automaticClusterUpdateDefinition_Value_Values)
		definition.Value = &value
	} else {
		definition.Value = nil
	}

	// No error
	return nil
}

// Status of automated cluster updates feature.
type AutomaticClusterUpdateDefinition_STATUS struct {
	Value *AutomaticClusterUpdateDefinition_Value_STATUS `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &AutomaticClusterUpdateDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *AutomaticClusterUpdateDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.AutomaticClusterUpdateDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *AutomaticClusterUpdateDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.AutomaticClusterUpdateDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.AutomaticClusterUpdateDefinition_STATUS, got %T", armInput)
	}

	// Set property "Value":
	if typedInput.Value != nil {
		var temp string
		temp = string(*typedInput.Value)
		value := AutomaticClusterUpdateDefinition_Value_STATUS(temp)
		definition.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_AutomaticClusterUpdateDefinition_STATUS populates our AutomaticClusterUpdateDefinition_STATUS from the provided source AutomaticClusterUpdateDefinition_STATUS
func (definition *AutomaticClusterUpdateDefinition_STATUS) AssignProperties_From_AutomaticClusterUpdateDefinition_STATUS(source *storage.AutomaticClusterUpdateDefinition_STATUS) error {

	// Value
	if source.Value != nil {
		value := *source.Value
		valueTemp := genruntime.ToEnum(value, automaticClusterUpdateDefinition_Value_STATUS_Values)
		definition.Value = &valueTemp
	} else {
		definition.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_AutomaticClusterUpdateDefinition_STATUS populates the provided destination AutomaticClusterUpdateDefinition_STATUS from our AutomaticClusterUpdateDefinition_STATUS
func (definition *AutomaticClusterUpdateDefinition_STATUS) AssignProperties_To_AutomaticClusterUpdateDefinition_STATUS(destination *storage.AutomaticClusterUpdateDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	if definition.Value != nil {
		value := string(*definition.Value)
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Status of Compliance Security Profile feature.
type ComplianceSecurityProfileDefinition struct {
	// ComplianceStandards: Compliance standards associated with the workspace.
	ComplianceStandards []ComplianceStandardDefinition             `json:"complianceStandards,omitempty"`
	Value               *ComplianceSecurityProfileDefinition_Value `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &ComplianceSecurityProfileDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *ComplianceSecurityProfileDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.ComplianceSecurityProfileDefinition{}

	// Set property "ComplianceStandards":
	for _, item := range definition.ComplianceStandards {
		var temp string
		temp = string(item)
		result.ComplianceStandards = append(result.ComplianceStandards, arm.ComplianceStandardDefinition(temp))
	}

	// Set property "Value":
	if definition.Value != nil {
		var temp string
		temp = string(*definition.Value)
		value := arm.ComplianceSecurityProfileDefinition_Value(temp)
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *ComplianceSecurityProfileDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComplianceSecurityProfileDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *ComplianceSecurityProfileDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComplianceSecurityProfileDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComplianceSecurityProfileDefinition, got %T", armInput)
	}

	// Set property "ComplianceStandards":
	for _, item := range typedInput.ComplianceStandards {
		var temp string
		temp = string(item)
		definition.ComplianceStandards = append(definition.ComplianceStandards, ComplianceStandardDefinition(temp))
	}

	// Set property "Value":
	if typedInput.Value != nil {
		var temp string
		temp = string(*typedInput.Value)
		value := ComplianceSecurityProfileDefinition_Value(temp)
		definition.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_ComplianceSecurityProfileDefinition populates our ComplianceSecurityProfileDefinition from the provided source ComplianceSecurityProfileDefinition
func (definition *ComplianceSecurityProfileDefinition) AssignProperties_From_ComplianceSecurityProfileDefinition(source *storage.ComplianceSecurityProfileDefinition) error {

	// ComplianceStandards
	if source.ComplianceStandards != nil {
		complianceStandardList := make([]ComplianceStandardDefinition, len(source.ComplianceStandards))
		for complianceStandardIndex, complianceStandardItem := range source.ComplianceStandards {
			complianceStandardList[complianceStandardIndex] = genruntime.ToEnum(complianceStandardItem, complianceStandardDefinition_Values)
		}
		definition.ComplianceStandards = complianceStandardList
	} else {
		definition.ComplianceStandards = nil
	}

	// Value
	if source.Value != nil {
		value := *source.Value
		valueTemp := genruntime.ToEnum(value, complianceSecurityProfileDefinition_Value_Values)
		definition.Value = &valueTemp
	} else {
		definition.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComplianceSecurityProfileDefinition populates the provided destination ComplianceSecurityProfileDefinition from our ComplianceSecurityProfileDefinition
func (definition *ComplianceSecurityProfileDefinition) AssignProperties_To_ComplianceSecurityProfileDefinition(destination *storage.ComplianceSecurityProfileDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComplianceStandards
	if definition.ComplianceStandards != nil {
		complianceStandardList := make([]string, len(definition.ComplianceStandards))
		for complianceStandardIndex, complianceStandardItem := range definition.ComplianceStandards {
			complianceStandardList[complianceStandardIndex] = string(complianceStandardItem)
		}
		destination.ComplianceStandards = complianceStandardList
	} else {
		destination.ComplianceStandards = nil
	}

	// Value
	if definition.Value != nil {
		value := string(*definition.Value)
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ComplianceSecurityProfileDefinition_STATUS populates our ComplianceSecurityProfileDefinition from the provided source ComplianceSecurityProfileDefinition_STATUS
func (definition *ComplianceSecurityProfileDefinition) Initialize_From_ComplianceSecurityProfileDefinition_STATUS(source *ComplianceSecurityProfileDefinition_STATUS) error {

	// ComplianceStandards
	if source.ComplianceStandards != nil {
		complianceStandardList := make([]ComplianceStandardDefinition, len(source.ComplianceStandards))
		for complianceStandardIndex, complianceStandardItem := range source.ComplianceStandards {
			complianceStandard := genruntime.ToEnum(string(complianceStandardItem), complianceStandardDefinition_Values)
			complianceStandardList[complianceStandardIndex] = complianceStandard
		}
		definition.ComplianceStandards = complianceStandardList
	} else {
		definition.ComplianceStandards = nil
	}

	// Value
	if source.Value != nil {
		value := genruntime.ToEnum(string(*source.Value), complianceSecurityProfileDefinition_Value_Values)
		definition.Value = &value
	} else {
		definition.Value = nil
	}

	// No error
	return nil
}

// Status of Compliance Security Profile feature.
type ComplianceSecurityProfileDefinition_STATUS struct {
	// ComplianceStandards: Compliance standards associated with the workspace.
	ComplianceStandards []ComplianceStandardDefinition_STATUS             `json:"complianceStandards,omitempty"`
	Value               *ComplianceSecurityProfileDefinition_Value_STATUS `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &ComplianceSecurityProfileDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *ComplianceSecurityProfileDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ComplianceSecurityProfileDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *ComplianceSecurityProfileDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ComplianceSecurityProfileDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ComplianceSecurityProfileDefinition_STATUS, got %T", armInput)
	}

	// Set property "ComplianceStandards":
	for _, item := range typedInput.ComplianceStandards {
		var temp string
		temp = string(item)
		definition.ComplianceStandards = append(definition.ComplianceStandards, ComplianceStandardDefinition_STATUS(temp))
	}

	// Set property "Value":
	if typedInput.Value != nil {
		var temp string
		temp = string(*typedInput.Value)
		value := ComplianceSecurityProfileDefinition_Value_STATUS(temp)
		definition.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_ComplianceSecurityProfileDefinition_STATUS populates our ComplianceSecurityProfileDefinition_STATUS from the provided source ComplianceSecurityProfileDefinition_STATUS
func (definition *ComplianceSecurityProfileDefinition_STATUS) AssignProperties_From_ComplianceSecurityProfileDefinition_STATUS(source *storage.ComplianceSecurityProfileDefinition_STATUS) error {

	// ComplianceStandards
	if source.ComplianceStandards != nil {
		complianceStandardList := make([]ComplianceStandardDefinition_STATUS, len(source.ComplianceStandards))
		for complianceStandardIndex, complianceStandardItem := range source.ComplianceStandards {
			complianceStandardList[complianceStandardIndex] = genruntime.ToEnum(complianceStandardItem, complianceStandardDefinition_STATUS_Values)
		}
		definition.ComplianceStandards = complianceStandardList
	} else {
		definition.ComplianceStandards = nil
	}

	// Value
	if source.Value != nil {
		value := *source.Value
		valueTemp := genruntime.ToEnum(value, complianceSecurityProfileDefinition_Value_STATUS_Values)
		definition.Value = &valueTemp
	} else {
		definition.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ComplianceSecurityProfileDefinition_STATUS populates the provided destination ComplianceSecurityProfileDefinition_STATUS from our ComplianceSecurityProfileDefinition_STATUS
func (definition *ComplianceSecurityProfileDefinition_STATUS) AssignProperties_To_ComplianceSecurityProfileDefinition_STATUS(destination *storage.ComplianceSecurityProfileDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ComplianceStandards
	if definition.ComplianceStandards != nil {
		complianceStandardList := make([]string, len(definition.ComplianceStandards))
		for complianceStandardIndex, complianceStandardItem := range definition.ComplianceStandards {
			complianceStandardList[complianceStandardIndex] = string(complianceStandardItem)
		}
		destination.ComplianceStandards = complianceStandardList
	} else {
		destination.ComplianceStandards = nil
	}

	// Value
	if definition.Value != nil {
		value := string(*definition.Value)
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"HiveMetastore","UnityCatalog"}
type DefaultCatalogProperties_InitialType string

const (
	DefaultCatalogProperties_InitialType_HiveMetastore = DefaultCatalogProperties_InitialType("HiveMetastore")
	DefaultCatalogProperties_InitialType_UnityCatalog  = DefaultCatalogProperties_InitialType("UnityCatalog")
)

// Mapping from string to DefaultCatalogProperties_InitialType
var defaultCatalogProperties_InitialType_Values = map[string]DefaultCatalogProperties_InitialType{
	"hivemetastore": DefaultCatalogProperties_InitialType_HiveMetastore,
	"unitycatalog":  DefaultCatalogProperties_InitialType_UnityCatalog,
}

type DefaultCatalogProperties_InitialType_STATUS string

const (
	DefaultCatalogProperties_InitialType_STATUS_HiveMetastore = DefaultCatalogProperties_InitialType_STATUS("HiveMetastore")
	DefaultCatalogProperties_InitialType_STATUS_UnityCatalog  = DefaultCatalogProperties_InitialType_STATUS("UnityCatalog")
)

// Mapping from string to DefaultCatalogProperties_InitialType_STATUS
var defaultCatalogProperties_InitialType_STATUS_Values = map[string]DefaultCatalogProperties_InitialType_STATUS{
	"hivemetastore": DefaultCatalogProperties_InitialType_STATUS_HiveMetastore,
	"unitycatalog":  DefaultCatalogProperties_InitialType_STATUS_UnityCatalog,
}

// Encryption entities for databricks workspace resource.
type EncryptionEntitiesDefinition struct {
	// ManagedDisk: Encryption properties for the databricks managed disks.
	ManagedDisk *ManagedDiskEncryption `json:"managedDisk,omitempty"`

	// ManagedServices: Encryption properties for the databricks managed services.
	ManagedServices *EncryptionV2 `json:"managedServices,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionEntitiesDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *EncryptionEntitiesDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.EncryptionEntitiesDefinition{}

	// Set property "ManagedDisk":
	if definition.ManagedDisk != nil {
		managedDisk_ARM, err := definition.ManagedDisk.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedDisk := *managedDisk_ARM.(*arm.ManagedDiskEncryption)
		result.ManagedDisk = &managedDisk
	}

	// Set property "ManagedServices":
	if definition.ManagedServices != nil {
		managedServices_ARM, err := definition.ManagedServices.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		managedServices := *managedServices_ARM.(*arm.EncryptionV2)
		result.ManagedServices = &managedServices
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *EncryptionEntitiesDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionEntitiesDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *EncryptionEntitiesDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionEntitiesDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionEntitiesDefinition, got %T", armInput)
	}

	// Set property "ManagedDisk":
	if typedInput.ManagedDisk != nil {
		var managedDisk1 ManagedDiskEncryption
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		definition.ManagedDisk = &managedDisk
	}

	// Set property "ManagedServices":
	if typedInput.ManagedServices != nil {
		var managedServices1 EncryptionV2
		err := managedServices1.PopulateFromARM(owner, *typedInput.ManagedServices)
		if err != nil {
			return err
		}
		managedServices := managedServices1
		definition.ManagedServices = &managedServices
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionEntitiesDefinition populates our EncryptionEntitiesDefinition from the provided source EncryptionEntitiesDefinition
func (definition *EncryptionEntitiesDefinition) AssignProperties_From_EncryptionEntitiesDefinition(source *storage.EncryptionEntitiesDefinition) error {

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskEncryption
		err := managedDisk.AssignProperties_From_ManagedDiskEncryption(source.ManagedDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedDiskEncryption() to populate field ManagedDisk")
		}
		definition.ManagedDisk = &managedDisk
	} else {
		definition.ManagedDisk = nil
	}

	// ManagedServices
	if source.ManagedServices != nil {
		var managedService EncryptionV2
		err := managedService.AssignProperties_From_EncryptionV2(source.ManagedServices)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EncryptionV2() to populate field ManagedServices")
		}
		definition.ManagedServices = &managedService
	} else {
		definition.ManagedServices = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionEntitiesDefinition populates the provided destination EncryptionEntitiesDefinition from our EncryptionEntitiesDefinition
func (definition *EncryptionEntitiesDefinition) AssignProperties_To_EncryptionEntitiesDefinition(destination *storage.EncryptionEntitiesDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ManagedDisk
	if definition.ManagedDisk != nil {
		var managedDisk storage.ManagedDiskEncryption
		err := definition.ManagedDisk.AssignProperties_To_ManagedDiskEncryption(&managedDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedDiskEncryption() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// ManagedServices
	if definition.ManagedServices != nil {
		var managedService storage.EncryptionV2
		err := definition.ManagedServices.AssignProperties_To_EncryptionV2(&managedService)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EncryptionV2() to populate field ManagedServices")
		}
		destination.ManagedServices = &managedService
	} else {
		destination.ManagedServices = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EncryptionEntitiesDefinition_STATUS populates our EncryptionEntitiesDefinition from the provided source EncryptionEntitiesDefinition_STATUS
func (definition *EncryptionEntitiesDefinition) Initialize_From_EncryptionEntitiesDefinition_STATUS(source *EncryptionEntitiesDefinition_STATUS) error {

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskEncryption
		err := managedDisk.Initialize_From_ManagedDiskEncryption_STATUS(source.ManagedDisk)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedDiskEncryption_STATUS() to populate field ManagedDisk")
		}
		definition.ManagedDisk = &managedDisk
	} else {
		definition.ManagedDisk = nil
	}

	// ManagedServices
	if source.ManagedServices != nil {
		var managedService EncryptionV2
		err := managedService.Initialize_From_EncryptionV2_STATUS(source.ManagedServices)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EncryptionV2_STATUS() to populate field ManagedServices")
		}
		definition.ManagedServices = &managedService
	} else {
		definition.ManagedServices = nil
	}

	// No error
	return nil
}

// Encryption entities for databricks workspace resource.
type EncryptionEntitiesDefinition_STATUS struct {
	// ManagedDisk: Encryption properties for the databricks managed disks.
	ManagedDisk *ManagedDiskEncryption_STATUS `json:"managedDisk,omitempty"`

	// ManagedServices: Encryption properties for the databricks managed services.
	ManagedServices *EncryptionV2_STATUS `json:"managedServices,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionEntitiesDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *EncryptionEntitiesDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionEntitiesDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *EncryptionEntitiesDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionEntitiesDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionEntitiesDefinition_STATUS, got %T", armInput)
	}

	// Set property "ManagedDisk":
	if typedInput.ManagedDisk != nil {
		var managedDisk1 ManagedDiskEncryption_STATUS
		err := managedDisk1.PopulateFromARM(owner, *typedInput.ManagedDisk)
		if err != nil {
			return err
		}
		managedDisk := managedDisk1
		definition.ManagedDisk = &managedDisk
	}

	// Set property "ManagedServices":
	if typedInput.ManagedServices != nil {
		var managedServices1 EncryptionV2_STATUS
		err := managedServices1.PopulateFromARM(owner, *typedInput.ManagedServices)
		if err != nil {
			return err
		}
		managedServices := managedServices1
		definition.ManagedServices = &managedServices
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionEntitiesDefinition_STATUS populates our EncryptionEntitiesDefinition_STATUS from the provided source EncryptionEntitiesDefinition_STATUS
func (definition *EncryptionEntitiesDefinition_STATUS) AssignProperties_From_EncryptionEntitiesDefinition_STATUS(source *storage.EncryptionEntitiesDefinition_STATUS) error {

	// ManagedDisk
	if source.ManagedDisk != nil {
		var managedDisk ManagedDiskEncryption_STATUS
		err := managedDisk.AssignProperties_From_ManagedDiskEncryption_STATUS(source.ManagedDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedDiskEncryption_STATUS() to populate field ManagedDisk")
		}
		definition.ManagedDisk = &managedDisk
	} else {
		definition.ManagedDisk = nil
	}

	// ManagedServices
	if source.ManagedServices != nil {
		var managedService EncryptionV2_STATUS
		err := managedService.AssignProperties_From_EncryptionV2_STATUS(source.ManagedServices)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EncryptionV2_STATUS() to populate field ManagedServices")
		}
		definition.ManagedServices = &managedService
	} else {
		definition.ManagedServices = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionEntitiesDefinition_STATUS populates the provided destination EncryptionEntitiesDefinition_STATUS from our EncryptionEntitiesDefinition_STATUS
func (definition *EncryptionEntitiesDefinition_STATUS) AssignProperties_To_EncryptionEntitiesDefinition_STATUS(destination *storage.EncryptionEntitiesDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ManagedDisk
	if definition.ManagedDisk != nil {
		var managedDisk storage.ManagedDiskEncryption_STATUS
		err := definition.ManagedDisk.AssignProperties_To_ManagedDiskEncryption_STATUS(&managedDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedDiskEncryption_STATUS() to populate field ManagedDisk")
		}
		destination.ManagedDisk = &managedDisk
	} else {
		destination.ManagedDisk = nil
	}

	// ManagedServices
	if definition.ManagedServices != nil {
		var managedService storage.EncryptionV2_STATUS
		err := definition.ManagedServices.AssignProperties_To_EncryptionV2_STATUS(&managedService)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EncryptionV2_STATUS() to populate field ManagedServices")
		}
		destination.ManagedServices = &managedService
	} else {
		destination.ManagedServices = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Status of Enhanced Security Monitoring feature.
type EnhancedSecurityMonitoringDefinition struct {
	Value *EnhancedSecurityMonitoringDefinition_Value `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &EnhancedSecurityMonitoringDefinition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (definition *EnhancedSecurityMonitoringDefinition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if definition == nil {
		return nil, nil
	}
	result := &arm.EnhancedSecurityMonitoringDefinition{}

	// Set property "Value":
	if definition.Value != nil {
		var temp string
		temp = string(*definition.Value)
		value := arm.EnhancedSecurityMonitoringDefinition_Value(temp)
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *EnhancedSecurityMonitoringDefinition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EnhancedSecurityMonitoringDefinition{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *EnhancedSecurityMonitoringDefinition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EnhancedSecurityMonitoringDefinition)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EnhancedSecurityMonitoringDefinition, got %T", armInput)
	}

	// Set property "Value":
	if typedInput.Value != nil {
		var temp string
		temp = string(*typedInput.Value)
		value := EnhancedSecurityMonitoringDefinition_Value(temp)
		definition.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EnhancedSecurityMonitoringDefinition populates our EnhancedSecurityMonitoringDefinition from the provided source EnhancedSecurityMonitoringDefinition
func (definition *EnhancedSecurityMonitoringDefinition) AssignProperties_From_EnhancedSecurityMonitoringDefinition(source *storage.EnhancedSecurityMonitoringDefinition) error {

	// Value
	if source.Value != nil {
		value := *source.Value
		valueTemp := genruntime.ToEnum(value, enhancedSecurityMonitoringDefinition_Value_Values)
		definition.Value = &valueTemp
	} else {
		definition.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EnhancedSecurityMonitoringDefinition populates the provided destination EnhancedSecurityMonitoringDefinition from our EnhancedSecurityMonitoringDefinition
func (definition *EnhancedSecurityMonitoringDefinition) AssignProperties_To_EnhancedSecurityMonitoringDefinition(destination *storage.EnhancedSecurityMonitoringDefinition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	if definition.Value != nil {
		value := string(*definition.Value)
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EnhancedSecurityMonitoringDefinition_STATUS populates our EnhancedSecurityMonitoringDefinition from the provided source EnhancedSecurityMonitoringDefinition_STATUS
func (definition *EnhancedSecurityMonitoringDefinition) Initialize_From_EnhancedSecurityMonitoringDefinition_STATUS(source *EnhancedSecurityMonitoringDefinition_STATUS) error {

	// Value
	if source.Value != nil {
		value := genruntime.ToEnum(string(*source.Value), enhancedSecurityMonitoringDefinition_Value_Values)
		definition.Value = &value
	} else {
		definition.Value = nil
	}

	// No error
	return nil
}

// Status of Enhanced Security Monitoring feature.
type EnhancedSecurityMonitoringDefinition_STATUS struct {
	Value *EnhancedSecurityMonitoringDefinition_Value_STATUS `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &EnhancedSecurityMonitoringDefinition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (definition *EnhancedSecurityMonitoringDefinition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EnhancedSecurityMonitoringDefinition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (definition *EnhancedSecurityMonitoringDefinition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EnhancedSecurityMonitoringDefinition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EnhancedSecurityMonitoringDefinition_STATUS, got %T", armInput)
	}

	// Set property "Value":
	if typedInput.Value != nil {
		var temp string
		temp = string(*typedInput.Value)
		value := EnhancedSecurityMonitoringDefinition_Value_STATUS(temp)
		definition.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_EnhancedSecurityMonitoringDefinition_STATUS populates our EnhancedSecurityMonitoringDefinition_STATUS from the provided source EnhancedSecurityMonitoringDefinition_STATUS
func (definition *EnhancedSecurityMonitoringDefinition_STATUS) AssignProperties_From_EnhancedSecurityMonitoringDefinition_STATUS(source *storage.EnhancedSecurityMonitoringDefinition_STATUS) error {

	// Value
	if source.Value != nil {
		value := *source.Value
		valueTemp := genruntime.ToEnum(value, enhancedSecurityMonitoringDefinition_Value_STATUS_Values)
		definition.Value = &valueTemp
	} else {
		definition.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EnhancedSecurityMonitoringDefinition_STATUS populates the provided destination EnhancedSecurityMonitoringDefinition_STATUS from our EnhancedSecurityMonitoringDefinition_STATUS
func (definition *EnhancedSecurityMonitoringDefinition_STATUS) AssignProperties_To_EnhancedSecurityMonitoringDefinition_STATUS(destination *storage.EnhancedSecurityMonitoringDefinition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	if definition.Value != nil {
		value := string(*definition.Value)
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The value which should be used for this field.
type WorkspaceCustomBooleanParameter struct {
	// Type: The type of variable that this is
	Type *WorkspaceCustomParameterType `json:"type,omitempty"`

	// +kubebuilder:validation:Required
	// Value: The value which should be used for this field.
	Value *bool `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceCustomBooleanParameter{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameter *WorkspaceCustomBooleanParameter) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameter == nil {
		return nil, nil
	}
	result := &arm.WorkspaceCustomBooleanParameter{}

	// Set property "Type":
	if parameter.Type != nil {
		var temp string
		temp = string(*parameter.Type)
		typeVar := arm.WorkspaceCustomParameterType(temp)
		result.Type = &typeVar
	}

	// Set property "Value":
	if parameter.Value != nil {
		value := *parameter.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameter *WorkspaceCustomBooleanParameter) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceCustomBooleanParameter{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameter *WorkspaceCustomBooleanParameter) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceCustomBooleanParameter)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceCustomBooleanParameter, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := WorkspaceCustomParameterType(temp)
		parameter.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		parameter.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceCustomBooleanParameter populates our WorkspaceCustomBooleanParameter from the provided source WorkspaceCustomBooleanParameter
func (parameter *WorkspaceCustomBooleanParameter) AssignProperties_From_WorkspaceCustomBooleanParameter(source *storage.WorkspaceCustomBooleanParameter) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, workspaceCustomParameterType_Values)
		parameter.Type = &typeTemp
	} else {
		parameter.Type = nil
	}

	// Value
	if source.Value != nil {
		value := *source.Value
		parameter.Value = &value
	} else {
		parameter.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceCustomBooleanParameter populates the provided destination WorkspaceCustomBooleanParameter from our WorkspaceCustomBooleanParameter
func (parameter *WorkspaceCustomBooleanParameter) AssignProperties_To_WorkspaceCustomBooleanParameter(destination *storage.WorkspaceCustomBooleanParameter) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if parameter.Type != nil {
		typeVar := string(*parameter.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	if parameter.Value != nil {
		value := *parameter.Value
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceCustomBooleanParameter_STATUS populates our WorkspaceCustomBooleanParameter from the provided source WorkspaceCustomBooleanParameter_STATUS
func (parameter *WorkspaceCustomBooleanParameter) Initialize_From_WorkspaceCustomBooleanParameter_STATUS(source *WorkspaceCustomBooleanParameter_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), workspaceCustomParameterType_Values)
		parameter.Type = &typeVar
	} else {
		parameter.Type = nil
	}

	// Value
	if source.Value != nil {
		value := *source.Value
		parameter.Value = &value
	} else {
		parameter.Value = nil
	}

	// No error
	return nil
}

// The value which should be used for this field.
type WorkspaceCustomBooleanParameter_STATUS struct {
	// Type: The type of variable that this is
	Type *WorkspaceCustomParameterType_STATUS `json:"type,omitempty"`

	// Value: The value which should be used for this field.
	Value *bool `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceCustomBooleanParameter_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameter *WorkspaceCustomBooleanParameter_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceCustomBooleanParameter_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameter *WorkspaceCustomBooleanParameter_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceCustomBooleanParameter_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceCustomBooleanParameter_STATUS, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := WorkspaceCustomParameterType_STATUS(temp)
		parameter.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		parameter.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceCustomBooleanParameter_STATUS populates our WorkspaceCustomBooleanParameter_STATUS from the provided source WorkspaceCustomBooleanParameter_STATUS
func (parameter *WorkspaceCustomBooleanParameter_STATUS) AssignProperties_From_WorkspaceCustomBooleanParameter_STATUS(source *storage.WorkspaceCustomBooleanParameter_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, workspaceCustomParameterType_STATUS_Values)
		parameter.Type = &typeTemp
	} else {
		parameter.Type = nil
	}

	// Value
	if source.Value != nil {
		value := *source.Value
		parameter.Value = &value
	} else {
		parameter.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceCustomBooleanParameter_STATUS populates the provided destination WorkspaceCustomBooleanParameter_STATUS from our WorkspaceCustomBooleanParameter_STATUS
func (parameter *WorkspaceCustomBooleanParameter_STATUS) AssignProperties_To_WorkspaceCustomBooleanParameter_STATUS(destination *storage.WorkspaceCustomBooleanParameter_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if parameter.Type != nil {
		typeVar := string(*parameter.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	if parameter.Value != nil {
		value := *parameter.Value
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The value which should be used for this field.
type WorkspaceCustomObjectParameter_STATUS struct {
	// Type: The type of variable that this is
	Type *WorkspaceCustomParameterType_STATUS `json:"type,omitempty"`

	// Value: The value which should be used for this field.
	Value map[string]v1.JSON `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceCustomObjectParameter_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameter *WorkspaceCustomObjectParameter_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceCustomObjectParameter_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameter *WorkspaceCustomObjectParameter_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceCustomObjectParameter_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceCustomObjectParameter_STATUS, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := WorkspaceCustomParameterType_STATUS(temp)
		parameter.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		parameter.Value = make(map[string]v1.JSON, len(typedInput.Value))
		for key, value := range typedInput.Value {
			parameter.Value[key] = *value.DeepCopy()
		}
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceCustomObjectParameter_STATUS populates our WorkspaceCustomObjectParameter_STATUS from the provided source WorkspaceCustomObjectParameter_STATUS
func (parameter *WorkspaceCustomObjectParameter_STATUS) AssignProperties_From_WorkspaceCustomObjectParameter_STATUS(source *storage.WorkspaceCustomObjectParameter_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, workspaceCustomParameterType_STATUS_Values)
		parameter.Type = &typeTemp
	} else {
		parameter.Type = nil
	}

	// Value
	if source.Value != nil {
		valueMap := make(map[string]v1.JSON, len(source.Value))
		for valueKey, value := range source.Value {
			valueMap[valueKey] = *value.DeepCopy()
		}
		parameter.Value = valueMap
	} else {
		parameter.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceCustomObjectParameter_STATUS populates the provided destination WorkspaceCustomObjectParameter_STATUS from our WorkspaceCustomObjectParameter_STATUS
func (parameter *WorkspaceCustomObjectParameter_STATUS) AssignProperties_To_WorkspaceCustomObjectParameter_STATUS(destination *storage.WorkspaceCustomObjectParameter_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if parameter.Type != nil {
		typeVar := string(*parameter.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	if parameter.Value != nil {
		valueMap := make(map[string]v1.JSON, len(parameter.Value))
		for valueKey, value := range parameter.Value {
			valueMap[valueKey] = *value.DeepCopy()
		}
		destination.Value = valueMap
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The Value.
type WorkspaceCustomStringParameter struct {
	// Type: The type of variable that this is
	Type *WorkspaceCustomParameterType `json:"type,omitempty"`

	// +kubebuilder:validation:Required
	// Value: The value which should be used for this field.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceCustomStringParameter{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameter *WorkspaceCustomStringParameter) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameter == nil {
		return nil, nil
	}
	result := &arm.WorkspaceCustomStringParameter{}

	// Set property "Type":
	if parameter.Type != nil {
		var temp string
		temp = string(*parameter.Type)
		typeVar := arm.WorkspaceCustomParameterType(temp)
		result.Type = &typeVar
	}

	// Set property "Value":
	if parameter.Value != nil {
		value := *parameter.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameter *WorkspaceCustomStringParameter) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceCustomStringParameter{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameter *WorkspaceCustomStringParameter) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceCustomStringParameter)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceCustomStringParameter, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := WorkspaceCustomParameterType(temp)
		parameter.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		parameter.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceCustomStringParameter populates our WorkspaceCustomStringParameter from the provided source WorkspaceCustomStringParameter
func (parameter *WorkspaceCustomStringParameter) AssignProperties_From_WorkspaceCustomStringParameter(source *storage.WorkspaceCustomStringParameter) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, workspaceCustomParameterType_Values)
		parameter.Type = &typeTemp
	} else {
		parameter.Type = nil
	}

	// Value
	parameter.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_WorkspaceCustomStringParameter populates the provided destination WorkspaceCustomStringParameter from our WorkspaceCustomStringParameter
func (parameter *WorkspaceCustomStringParameter) AssignProperties_To_WorkspaceCustomStringParameter(destination *storage.WorkspaceCustomStringParameter) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if parameter.Type != nil {
		typeVar := string(*parameter.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(parameter.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceCustomStringParameter_STATUS populates our WorkspaceCustomStringParameter from the provided source WorkspaceCustomStringParameter_STATUS
func (parameter *WorkspaceCustomStringParameter) Initialize_From_WorkspaceCustomStringParameter_STATUS(source *WorkspaceCustomStringParameter_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), workspaceCustomParameterType_Values)
		parameter.Type = &typeVar
	} else {
		parameter.Type = nil
	}

	// Value
	parameter.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// The Value.
type WorkspaceCustomStringParameter_STATUS struct {
	// Type: The type of variable that this is
	Type *WorkspaceCustomParameterType_STATUS `json:"type,omitempty"`

	// Value: The value which should be used for this field.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceCustomStringParameter_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameter *WorkspaceCustomStringParameter_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceCustomStringParameter_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameter *WorkspaceCustomStringParameter_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceCustomStringParameter_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceCustomStringParameter_STATUS, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := WorkspaceCustomParameterType_STATUS(temp)
		parameter.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		parameter.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceCustomStringParameter_STATUS populates our WorkspaceCustomStringParameter_STATUS from the provided source WorkspaceCustomStringParameter_STATUS
func (parameter *WorkspaceCustomStringParameter_STATUS) AssignProperties_From_WorkspaceCustomStringParameter_STATUS(source *storage.WorkspaceCustomStringParameter_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, workspaceCustomParameterType_STATUS_Values)
		parameter.Type = &typeTemp
	} else {
		parameter.Type = nil
	}

	// Value
	parameter.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_WorkspaceCustomStringParameter_STATUS populates the provided destination WorkspaceCustomStringParameter_STATUS from our WorkspaceCustomStringParameter_STATUS
func (parameter *WorkspaceCustomStringParameter_STATUS) AssignProperties_To_WorkspaceCustomStringParameter_STATUS(destination *storage.WorkspaceCustomStringParameter_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if parameter.Type != nil {
		typeVar := string(*parameter.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(parameter.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The object that contains details of encryption used on the workspace.
type WorkspaceEncryptionParameter struct {
	// Type: The type of variable that this is
	Type *WorkspaceCustomParameterType `json:"type,omitempty"`

	// Value: The value which should be used for this field.
	Value *Encryption `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceEncryptionParameter{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameter *WorkspaceEncryptionParameter) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameter == nil {
		return nil, nil
	}
	result := &arm.WorkspaceEncryptionParameter{}

	// Set property "Type":
	if parameter.Type != nil {
		var temp string
		temp = string(*parameter.Type)
		typeVar := arm.WorkspaceCustomParameterType(temp)
		result.Type = &typeVar
	}

	// Set property "Value":
	if parameter.Value != nil {
		value_ARM, err := parameter.Value.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		value := *value_ARM.(*arm.Encryption)
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameter *WorkspaceEncryptionParameter) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceEncryptionParameter{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameter *WorkspaceEncryptionParameter) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceEncryptionParameter)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceEncryptionParameter, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := WorkspaceCustomParameterType(temp)
		parameter.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		var value1 Encryption
		err := value1.PopulateFromARM(owner, *typedInput.Value)
		if err != nil {
			return err
		}
		value := value1
		parameter.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceEncryptionParameter populates our WorkspaceEncryptionParameter from the provided source WorkspaceEncryptionParameter
func (parameter *WorkspaceEncryptionParameter) AssignProperties_From_WorkspaceEncryptionParameter(source *storage.WorkspaceEncryptionParameter) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, workspaceCustomParameterType_Values)
		parameter.Type = &typeTemp
	} else {
		parameter.Type = nil
	}

	// Value
	if source.Value != nil {
		var value Encryption
		err := value.AssignProperties_From_Encryption(source.Value)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Encryption() to populate field Value")
		}
		parameter.Value = &value
	} else {
		parameter.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceEncryptionParameter populates the provided destination WorkspaceEncryptionParameter from our WorkspaceEncryptionParameter
func (parameter *WorkspaceEncryptionParameter) AssignProperties_To_WorkspaceEncryptionParameter(destination *storage.WorkspaceEncryptionParameter) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if parameter.Type != nil {
		typeVar := string(*parameter.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	if parameter.Value != nil {
		var value storage.Encryption
		err := parameter.Value.AssignProperties_To_Encryption(&value)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Encryption() to populate field Value")
		}
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceEncryptionParameter_STATUS populates our WorkspaceEncryptionParameter from the provided source WorkspaceEncryptionParameter_STATUS
func (parameter *WorkspaceEncryptionParameter) Initialize_From_WorkspaceEncryptionParameter_STATUS(source *WorkspaceEncryptionParameter_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), workspaceCustomParameterType_Values)
		parameter.Type = &typeVar
	} else {
		parameter.Type = nil
	}

	// Value
	if source.Value != nil {
		var value Encryption
		err := value.Initialize_From_Encryption_STATUS(source.Value)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Encryption_STATUS() to populate field Value")
		}
		parameter.Value = &value
	} else {
		parameter.Value = nil
	}

	// No error
	return nil
}

// The object that contains details of encryption used on the workspace.
type WorkspaceEncryptionParameter_STATUS struct {
	// Type: The type of variable that this is
	Type *WorkspaceCustomParameterType_STATUS `json:"type,omitempty"`

	// Value: The value which should be used for this field.
	Value *Encryption_STATUS `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceEncryptionParameter_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameter *WorkspaceEncryptionParameter_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceEncryptionParameter_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameter *WorkspaceEncryptionParameter_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceEncryptionParameter_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceEncryptionParameter_STATUS, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := WorkspaceCustomParameterType_STATUS(temp)
		parameter.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		var value1 Encryption_STATUS
		err := value1.PopulateFromARM(owner, *typedInput.Value)
		if err != nil {
			return err
		}
		value := value1
		parameter.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceEncryptionParameter_STATUS populates our WorkspaceEncryptionParameter_STATUS from the provided source WorkspaceEncryptionParameter_STATUS
func (parameter *WorkspaceEncryptionParameter_STATUS) AssignProperties_From_WorkspaceEncryptionParameter_STATUS(source *storage.WorkspaceEncryptionParameter_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, workspaceCustomParameterType_STATUS_Values)
		parameter.Type = &typeTemp
	} else {
		parameter.Type = nil
	}

	// Value
	if source.Value != nil {
		var value Encryption_STATUS
		err := value.AssignProperties_From_Encryption_STATUS(source.Value)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Encryption_STATUS() to populate field Value")
		}
		parameter.Value = &value
	} else {
		parameter.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceEncryptionParameter_STATUS populates the provided destination WorkspaceEncryptionParameter_STATUS from our WorkspaceEncryptionParameter_STATUS
func (parameter *WorkspaceEncryptionParameter_STATUS) AssignProperties_To_WorkspaceEncryptionParameter_STATUS(destination *storage.WorkspaceEncryptionParameter_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if parameter.Type != nil {
		typeVar := string(*parameter.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	if parameter.Value != nil {
		var value storage.Encryption_STATUS
		err := parameter.Value.AssignProperties_To_Encryption_STATUS(&value)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Encryption_STATUS() to populate field Value")
		}
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The value which should be used for this field.
type WorkspaceNoPublicIPBooleanParameter struct {
	// Type: The type of variable that this is
	Type *WorkspaceCustomParameterType `json:"type,omitempty"`

	// +kubebuilder:validation:Required
	// Value: The value which should be used for this field.
	Value *bool `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &WorkspaceNoPublicIPBooleanParameter{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameter *WorkspaceNoPublicIPBooleanParameter) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameter == nil {
		return nil, nil
	}
	result := &arm.WorkspaceNoPublicIPBooleanParameter{}

	// Set property "Type":
	if parameter.Type != nil {
		var temp string
		temp = string(*parameter.Type)
		typeVar := arm.WorkspaceCustomParameterType(temp)
		result.Type = &typeVar
	}

	// Set property "Value":
	if parameter.Value != nil {
		value := *parameter.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameter *WorkspaceNoPublicIPBooleanParameter) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceNoPublicIPBooleanParameter{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameter *WorkspaceNoPublicIPBooleanParameter) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceNoPublicIPBooleanParameter)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceNoPublicIPBooleanParameter, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := WorkspaceCustomParameterType(temp)
		parameter.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		parameter.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceNoPublicIPBooleanParameter populates our WorkspaceNoPublicIPBooleanParameter from the provided source WorkspaceNoPublicIPBooleanParameter
func (parameter *WorkspaceNoPublicIPBooleanParameter) AssignProperties_From_WorkspaceNoPublicIPBooleanParameter(source *storage.WorkspaceNoPublicIPBooleanParameter) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, workspaceCustomParameterType_Values)
		parameter.Type = &typeTemp
	} else {
		parameter.Type = nil
	}

	// Value
	if source.Value != nil {
		value := *source.Value
		parameter.Value = &value
	} else {
		parameter.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceNoPublicIPBooleanParameter populates the provided destination WorkspaceNoPublicIPBooleanParameter from our WorkspaceNoPublicIPBooleanParameter
func (parameter *WorkspaceNoPublicIPBooleanParameter) AssignProperties_To_WorkspaceNoPublicIPBooleanParameter(destination *storage.WorkspaceNoPublicIPBooleanParameter) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if parameter.Type != nil {
		typeVar := string(*parameter.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	if parameter.Value != nil {
		value := *parameter.Value
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_WorkspaceNoPublicIPBooleanParameter_STATUS populates our WorkspaceNoPublicIPBooleanParameter from the provided source WorkspaceNoPublicIPBooleanParameter_STATUS
func (parameter *WorkspaceNoPublicIPBooleanParameter) Initialize_From_WorkspaceNoPublicIPBooleanParameter_STATUS(source *WorkspaceNoPublicIPBooleanParameter_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), workspaceCustomParameterType_Values)
		parameter.Type = &typeVar
	} else {
		parameter.Type = nil
	}

	// Value
	if source.Value != nil {
		value := *source.Value
		parameter.Value = &value
	} else {
		parameter.Value = nil
	}

	// No error
	return nil
}

// The value which should be used for this field.
type WorkspaceNoPublicIPBooleanParameter_STATUS struct {
	// Type: The type of variable that this is
	Type *WorkspaceCustomParameterType_STATUS `json:"type,omitempty"`

	// Value: The value which should be used for this field.
	Value *bool `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &WorkspaceNoPublicIPBooleanParameter_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameter *WorkspaceNoPublicIPBooleanParameter_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.WorkspaceNoPublicIPBooleanParameter_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameter *WorkspaceNoPublicIPBooleanParameter_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.WorkspaceNoPublicIPBooleanParameter_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.WorkspaceNoPublicIPBooleanParameter_STATUS, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := WorkspaceCustomParameterType_STATUS(temp)
		parameter.Type = &typeVar
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		parameter.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_WorkspaceNoPublicIPBooleanParameter_STATUS populates our WorkspaceNoPublicIPBooleanParameter_STATUS from the provided source WorkspaceNoPublicIPBooleanParameter_STATUS
func (parameter *WorkspaceNoPublicIPBooleanParameter_STATUS) AssignProperties_From_WorkspaceNoPublicIPBooleanParameter_STATUS(source *storage.WorkspaceNoPublicIPBooleanParameter_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, workspaceCustomParameterType_STATUS_Values)
		parameter.Type = &typeTemp
	} else {
		parameter.Type = nil
	}

	// Value
	if source.Value != nil {
		value := *source.Value
		parameter.Value = &value
	} else {
		parameter.Value = nil
	}

	// No error
	return nil
}

// AssignProperties_To_WorkspaceNoPublicIPBooleanParameter_STATUS populates the provided destination WorkspaceNoPublicIPBooleanParameter_STATUS from our WorkspaceNoPublicIPBooleanParameter_STATUS
func (parameter *WorkspaceNoPublicIPBooleanParameter_STATUS) AssignProperties_To_WorkspaceNoPublicIPBooleanParameter_STATUS(destination *storage.WorkspaceNoPublicIPBooleanParameter_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if parameter.Type != nil {
		typeVar := string(*parameter.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Value
	if parameter.Value != nil {
		value := *parameter.Value
		destination.Value = &value
	} else {
		destination.Value = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"SystemAssigned","UserAssigned"}
type WorkspaceProperties_AccessConnector_IdentityType string

const (
	WorkspaceProperties_AccessConnector_IdentityType_SystemAssigned = WorkspaceProperties_AccessConnector_IdentityType("SystemAssigned")
	WorkspaceProperties_AccessConnector_IdentityType_UserAssigned   = WorkspaceProperties_AccessConnector_IdentityType("UserAssigned")
)

// Mapping from string to WorkspaceProperties_AccessConnector_IdentityType
var workspaceProperties_AccessConnector_IdentityType_Values = map[string]WorkspaceProperties_AccessConnector_IdentityType{
	"systemassigned": WorkspaceProperties_AccessConnector_IdentityType_SystemAssigned,
	"userassigned":   WorkspaceProperties_AccessConnector_IdentityType_UserAssigned,
}

type WorkspaceProperties_AccessConnector_IdentityType_STATUS string

const (
	WorkspaceProperties_AccessConnector_IdentityType_STATUS_SystemAssigned = WorkspaceProperties_AccessConnector_IdentityType_STATUS("SystemAssigned")
	WorkspaceProperties_AccessConnector_IdentityType_STATUS_UserAssigned   = WorkspaceProperties_AccessConnector_IdentityType_STATUS("UserAssigned")
)

// Mapping from string to WorkspaceProperties_AccessConnector_IdentityType_STATUS
var workspaceProperties_AccessConnector_IdentityType_STATUS_Values = map[string]WorkspaceProperties_AccessConnector_IdentityType_STATUS{
	"systemassigned": WorkspaceProperties_AccessConnector_IdentityType_STATUS_SystemAssigned,
	"userassigned":   WorkspaceProperties_AccessConnector_IdentityType_STATUS_UserAssigned,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type AutomaticClusterUpdateDefinition_Value string

const (
	AutomaticClusterUpdateDefinition_Value_Disabled = AutomaticClusterUpdateDefinition_Value("Disabled")
	AutomaticClusterUpdateDefinition_Value_Enabled  = AutomaticClusterUpdateDefinition_Value("Enabled")
)

// Mapping from string to AutomaticClusterUpdateDefinition_Value
var automaticClusterUpdateDefinition_Value_Values = map[string]AutomaticClusterUpdateDefinition_Value{
	"disabled": AutomaticClusterUpdateDefinition_Value_Disabled,
	"enabled":  AutomaticClusterUpdateDefinition_Value_Enabled,
}

type AutomaticClusterUpdateDefinition_Value_STATUS string

const (
	AutomaticClusterUpdateDefinition_Value_STATUS_Disabled = AutomaticClusterUpdateDefinition_Value_STATUS("Disabled")
	AutomaticClusterUpdateDefinition_Value_STATUS_Enabled  = AutomaticClusterUpdateDefinition_Value_STATUS("Enabled")
)

// Mapping from string to AutomaticClusterUpdateDefinition_Value_STATUS
var automaticClusterUpdateDefinition_Value_STATUS_Values = map[string]AutomaticClusterUpdateDefinition_Value_STATUS{
	"disabled": AutomaticClusterUpdateDefinition_Value_STATUS_Disabled,
	"enabled":  AutomaticClusterUpdateDefinition_Value_STATUS_Enabled,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ComplianceSecurityProfileDefinition_Value string

const (
	ComplianceSecurityProfileDefinition_Value_Disabled = ComplianceSecurityProfileDefinition_Value("Disabled")
	ComplianceSecurityProfileDefinition_Value_Enabled  = ComplianceSecurityProfileDefinition_Value("Enabled")
)

// Mapping from string to ComplianceSecurityProfileDefinition_Value
var complianceSecurityProfileDefinition_Value_Values = map[string]ComplianceSecurityProfileDefinition_Value{
	"disabled": ComplianceSecurityProfileDefinition_Value_Disabled,
	"enabled":  ComplianceSecurityProfileDefinition_Value_Enabled,
}

type ComplianceSecurityProfileDefinition_Value_STATUS string

const (
	ComplianceSecurityProfileDefinition_Value_STATUS_Disabled = ComplianceSecurityProfileDefinition_Value_STATUS("Disabled")
	ComplianceSecurityProfileDefinition_Value_STATUS_Enabled  = ComplianceSecurityProfileDefinition_Value_STATUS("Enabled")
)

// Mapping from string to ComplianceSecurityProfileDefinition_Value_STATUS
var complianceSecurityProfileDefinition_Value_STATUS_Values = map[string]ComplianceSecurityProfileDefinition_Value_STATUS{
	"disabled": ComplianceSecurityProfileDefinition_Value_STATUS_Disabled,
	"enabled":  ComplianceSecurityProfileDefinition_Value_STATUS_Enabled,
}

// Compliance standard that can be associated with a workspace.
// +kubebuilder:validation:Enum={"HIPAA","NONE","PCI_DSS"}
type ComplianceStandardDefinition string

const (
	ComplianceStandardDefinition_HIPAA   = ComplianceStandardDefinition("HIPAA")
	ComplianceStandardDefinition_NONE    = ComplianceStandardDefinition("NONE")
	ComplianceStandardDefinition_PCI_DSS = ComplianceStandardDefinition("PCI_DSS")
)

// Mapping from string to ComplianceStandardDefinition
var complianceStandardDefinition_Values = map[string]ComplianceStandardDefinition{
	"hipaa":   ComplianceStandardDefinition_HIPAA,
	"none":    ComplianceStandardDefinition_NONE,
	"pci_dss": ComplianceStandardDefinition_PCI_DSS,
}

// Compliance standard that can be associated with a workspace.
type ComplianceStandardDefinition_STATUS string

const (
	ComplianceStandardDefinition_STATUS_HIPAA   = ComplianceStandardDefinition_STATUS("HIPAA")
	ComplianceStandardDefinition_STATUS_NONE    = ComplianceStandardDefinition_STATUS("NONE")
	ComplianceStandardDefinition_STATUS_PCI_DSS = ComplianceStandardDefinition_STATUS("PCI_DSS")
)

// Mapping from string to ComplianceStandardDefinition_STATUS
var complianceStandardDefinition_STATUS_Values = map[string]ComplianceStandardDefinition_STATUS{
	"hipaa":   ComplianceStandardDefinition_STATUS_HIPAA,
	"none":    ComplianceStandardDefinition_STATUS_NONE,
	"pci_dss": ComplianceStandardDefinition_STATUS_PCI_DSS,
}

// The object that contains details of encryption used on the workspace.
type Encryption struct {
	// KeyName: The name of KeyVault key.
	KeyName *string `json:"KeyName,omitempty"`

	// KeySource: The encryption keySource (provider). Possible values (case-insensitive):  Default, Microsoft.Keyvault
	KeySource *Encryption_KeySource `json:"keySource,omitempty"`

	// Keyvaulturi: The Uri of KeyVault.
	Keyvaulturi *string `json:"keyvaulturi,omitempty"`

	// Keyversion: The version of KeyVault key.
	Keyversion *string `json:"keyversion,omitempty"`
}

var _ genruntime.ARMTransformer = &Encryption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (encryption *Encryption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if encryption == nil {
		return nil, nil
	}
	result := &arm.Encryption{}

	// Set property "KeyName":
	if encryption.KeyName != nil {
		keyName := *encryption.KeyName
		result.KeyName = &keyName
	}

	// Set property "KeySource":
	if encryption.KeySource != nil {
		var temp string
		temp = string(*encryption.KeySource)
		keySource := arm.Encryption_KeySource(temp)
		result.KeySource = &keySource
	}

	// Set property "Keyvaulturi":
	if encryption.Keyvaulturi != nil {
		keyvaulturi := *encryption.Keyvaulturi
		result.Keyvaulturi = &keyvaulturi
	}

	// Set property "Keyversion":
	if encryption.Keyversion != nil {
		keyversion := *encryption.Keyversion
		result.Keyversion = &keyversion
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *Encryption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Encryption{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *Encryption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Encryption)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Encryption, got %T", armInput)
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		encryption.KeyName = &keyName
	}

	// Set property "KeySource":
	if typedInput.KeySource != nil {
		var temp string
		temp = string(*typedInput.KeySource)
		keySource := Encryption_KeySource(temp)
		encryption.KeySource = &keySource
	}

	// Set property "Keyvaulturi":
	if typedInput.Keyvaulturi != nil {
		keyvaulturi := *typedInput.Keyvaulturi
		encryption.Keyvaulturi = &keyvaulturi
	}

	// Set property "Keyversion":
	if typedInput.Keyversion != nil {
		keyversion := *typedInput.Keyversion
		encryption.Keyversion = &keyversion
	}

	// No error
	return nil
}

// AssignProperties_From_Encryption populates our Encryption from the provided source Encryption
func (encryption *Encryption) AssignProperties_From_Encryption(source *storage.Encryption) error {

	// KeyName
	encryption.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeySource
	if source.KeySource != nil {
		keySource := *source.KeySource
		keySourceTemp := genruntime.ToEnum(keySource, encryption_KeySource_Values)
		encryption.KeySource = &keySourceTemp
	} else {
		encryption.KeySource = nil
	}

	// Keyvaulturi
	encryption.Keyvaulturi = genruntime.ClonePointerToString(source.Keyvaulturi)

	// Keyversion
	encryption.Keyversion = genruntime.ClonePointerToString(source.Keyversion)

	// No error
	return nil
}

// AssignProperties_To_Encryption populates the provided destination Encryption from our Encryption
func (encryption *Encryption) AssignProperties_To_Encryption(destination *storage.Encryption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(encryption.KeyName)

	// KeySource
	if encryption.KeySource != nil {
		keySource := string(*encryption.KeySource)
		destination.KeySource = &keySource
	} else {
		destination.KeySource = nil
	}

	// Keyvaulturi
	destination.Keyvaulturi = genruntime.ClonePointerToString(encryption.Keyvaulturi)

	// Keyversion
	destination.Keyversion = genruntime.ClonePointerToString(encryption.Keyversion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Encryption_STATUS populates our Encryption from the provided source Encryption_STATUS
func (encryption *Encryption) Initialize_From_Encryption_STATUS(source *Encryption_STATUS) error {

	// KeyName
	encryption.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeySource
	if source.KeySource != nil {
		keySource := genruntime.ToEnum(string(*source.KeySource), encryption_KeySource_Values)
		encryption.KeySource = &keySource
	} else {
		encryption.KeySource = nil
	}

	// Keyvaulturi
	encryption.Keyvaulturi = genruntime.ClonePointerToString(source.Keyvaulturi)

	// Keyversion
	encryption.Keyversion = genruntime.ClonePointerToString(source.Keyversion)

	// No error
	return nil
}

// The object that contains details of encryption used on the workspace.
type Encryption_STATUS struct {
	// KeyName: The name of KeyVault key.
	KeyName *string `json:"KeyName,omitempty"`

	// KeySource: The encryption keySource (provider). Possible values (case-insensitive):  Default, Microsoft.Keyvault
	KeySource *Encryption_KeySource_STATUS `json:"keySource,omitempty"`

	// Keyvaulturi: The Uri of KeyVault.
	Keyvaulturi *string `json:"keyvaulturi,omitempty"`

	// Keyversion: The version of KeyVault key.
	Keyversion *string `json:"keyversion,omitempty"`
}

var _ genruntime.FromARMConverter = &Encryption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *Encryption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Encryption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *Encryption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Encryption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Encryption_STATUS, got %T", armInput)
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		encryption.KeyName = &keyName
	}

	// Set property "KeySource":
	if typedInput.KeySource != nil {
		var temp string
		temp = string(*typedInput.KeySource)
		keySource := Encryption_KeySource_STATUS(temp)
		encryption.KeySource = &keySource
	}

	// Set property "Keyvaulturi":
	if typedInput.Keyvaulturi != nil {
		keyvaulturi := *typedInput.Keyvaulturi
		encryption.Keyvaulturi = &keyvaulturi
	}

	// Set property "Keyversion":
	if typedInput.Keyversion != nil {
		keyversion := *typedInput.Keyversion
		encryption.Keyversion = &keyversion
	}

	// No error
	return nil
}

// AssignProperties_From_Encryption_STATUS populates our Encryption_STATUS from the provided source Encryption_STATUS
func (encryption *Encryption_STATUS) AssignProperties_From_Encryption_STATUS(source *storage.Encryption_STATUS) error {

	// KeyName
	encryption.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeySource
	if source.KeySource != nil {
		keySource := *source.KeySource
		keySourceTemp := genruntime.ToEnum(keySource, encryption_KeySource_STATUS_Values)
		encryption.KeySource = &keySourceTemp
	} else {
		encryption.KeySource = nil
	}

	// Keyvaulturi
	encryption.Keyvaulturi = genruntime.ClonePointerToString(source.Keyvaulturi)

	// Keyversion
	encryption.Keyversion = genruntime.ClonePointerToString(source.Keyversion)

	// No error
	return nil
}

// AssignProperties_To_Encryption_STATUS populates the provided destination Encryption_STATUS from our Encryption_STATUS
func (encryption *Encryption_STATUS) AssignProperties_To_Encryption_STATUS(destination *storage.Encryption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(encryption.KeyName)

	// KeySource
	if encryption.KeySource != nil {
		keySource := string(*encryption.KeySource)
		destination.KeySource = &keySource
	} else {
		destination.KeySource = nil
	}

	// Keyvaulturi
	destination.Keyvaulturi = genruntime.ClonePointerToString(encryption.Keyvaulturi)

	// Keyversion
	destination.Keyversion = genruntime.ClonePointerToString(encryption.Keyversion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The object that contains details of encryption used on the workspace.
type EncryptionV2 struct {
	// +kubebuilder:validation:Required
	// KeySource: The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Keyvault
	KeySource *EncryptionV2_KeySource `json:"keySource,omitempty"`

	// KeyVaultProperties: Key Vault input properties for encryption.
	KeyVaultProperties *EncryptionV2_KeyVaultProperties `json:"keyVaultProperties,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionV2{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (v2 *EncryptionV2) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if v2 == nil {
		return nil, nil
	}
	result := &arm.EncryptionV2{}

	// Set property "KeySource":
	if v2.KeySource != nil {
		var temp string
		temp = string(*v2.KeySource)
		keySource := arm.EncryptionV2_KeySource(temp)
		result.KeySource = &keySource
	}

	// Set property "KeyVaultProperties":
	if v2.KeyVaultProperties != nil {
		keyVaultProperties_ARM, err := v2.KeyVaultProperties.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keyVaultProperties := *keyVaultProperties_ARM.(*arm.EncryptionV2_KeyVaultProperties)
		result.KeyVaultProperties = &keyVaultProperties
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (v2 *EncryptionV2) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionV2{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (v2 *EncryptionV2) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionV2)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionV2, got %T", armInput)
	}

	// Set property "KeySource":
	if typedInput.KeySource != nil {
		var temp string
		temp = string(*typedInput.KeySource)
		keySource := EncryptionV2_KeySource(temp)
		v2.KeySource = &keySource
	}

	// Set property "KeyVaultProperties":
	if typedInput.KeyVaultProperties != nil {
		var keyVaultProperties1 EncryptionV2_KeyVaultProperties
		err := keyVaultProperties1.PopulateFromARM(owner, *typedInput.KeyVaultProperties)
		if err != nil {
			return err
		}
		keyVaultProperties := keyVaultProperties1
		v2.KeyVaultProperties = &keyVaultProperties
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionV2 populates our EncryptionV2 from the provided source EncryptionV2
func (v2 *EncryptionV2) AssignProperties_From_EncryptionV2(source *storage.EncryptionV2) error {

	// KeySource
	if source.KeySource != nil {
		keySource := *source.KeySource
		keySourceTemp := genruntime.ToEnum(keySource, encryptionV2_KeySource_Values)
		v2.KeySource = &keySourceTemp
	} else {
		v2.KeySource = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty EncryptionV2_KeyVaultProperties
		err := keyVaultProperty.AssignProperties_From_EncryptionV2_KeyVaultProperties(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EncryptionV2_KeyVaultProperties() to populate field KeyVaultProperties")
		}
		v2.KeyVaultProperties = &keyVaultProperty
	} else {
		v2.KeyVaultProperties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionV2 populates the provided destination EncryptionV2 from our EncryptionV2
func (v2 *EncryptionV2) AssignProperties_To_EncryptionV2(destination *storage.EncryptionV2) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeySource
	if v2.KeySource != nil {
		keySource := string(*v2.KeySource)
		destination.KeySource = &keySource
	} else {
		destination.KeySource = nil
	}

	// KeyVaultProperties
	if v2.KeyVaultProperties != nil {
		var keyVaultProperty storage.EncryptionV2_KeyVaultProperties
		err := v2.KeyVaultProperties.AssignProperties_To_EncryptionV2_KeyVaultProperties(&keyVaultProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EncryptionV2_KeyVaultProperties() to populate field KeyVaultProperties")
		}
		destination.KeyVaultProperties = &keyVaultProperty
	} else {
		destination.KeyVaultProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EncryptionV2_STATUS populates our EncryptionV2 from the provided source EncryptionV2_STATUS
func (v2 *EncryptionV2) Initialize_From_EncryptionV2_STATUS(source *EncryptionV2_STATUS) error {

	// KeySource
	if source.KeySource != nil {
		keySource := genruntime.ToEnum(string(*source.KeySource), encryptionV2_KeySource_Values)
		v2.KeySource = &keySource
	} else {
		v2.KeySource = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty EncryptionV2_KeyVaultProperties
		err := keyVaultProperty.Initialize_From_EncryptionV2_KeyVaultProperties_STATUS(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EncryptionV2_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		v2.KeyVaultProperties = &keyVaultProperty
	} else {
		v2.KeyVaultProperties = nil
	}

	// No error
	return nil
}

// The object that contains details of encryption used on the workspace.
type EncryptionV2_STATUS struct {
	// KeySource: The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Keyvault
	KeySource *EncryptionV2_KeySource_STATUS `json:"keySource,omitempty"`

	// KeyVaultProperties: Key Vault input properties for encryption.
	KeyVaultProperties *EncryptionV2_KeyVaultProperties_STATUS `json:"keyVaultProperties,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionV2_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (v2 *EncryptionV2_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionV2_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (v2 *EncryptionV2_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionV2_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionV2_STATUS, got %T", armInput)
	}

	// Set property "KeySource":
	if typedInput.KeySource != nil {
		var temp string
		temp = string(*typedInput.KeySource)
		keySource := EncryptionV2_KeySource_STATUS(temp)
		v2.KeySource = &keySource
	}

	// Set property "KeyVaultProperties":
	if typedInput.KeyVaultProperties != nil {
		var keyVaultProperties1 EncryptionV2_KeyVaultProperties_STATUS
		err := keyVaultProperties1.PopulateFromARM(owner, *typedInput.KeyVaultProperties)
		if err != nil {
			return err
		}
		keyVaultProperties := keyVaultProperties1
		v2.KeyVaultProperties = &keyVaultProperties
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionV2_STATUS populates our EncryptionV2_STATUS from the provided source EncryptionV2_STATUS
func (v2 *EncryptionV2_STATUS) AssignProperties_From_EncryptionV2_STATUS(source *storage.EncryptionV2_STATUS) error {

	// KeySource
	if source.KeySource != nil {
		keySource := *source.KeySource
		keySourceTemp := genruntime.ToEnum(keySource, encryptionV2_KeySource_STATUS_Values)
		v2.KeySource = &keySourceTemp
	} else {
		v2.KeySource = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty EncryptionV2_KeyVaultProperties_STATUS
		err := keyVaultProperty.AssignProperties_From_EncryptionV2_KeyVaultProperties_STATUS(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EncryptionV2_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		v2.KeyVaultProperties = &keyVaultProperty
	} else {
		v2.KeyVaultProperties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionV2_STATUS populates the provided destination EncryptionV2_STATUS from our EncryptionV2_STATUS
func (v2 *EncryptionV2_STATUS) AssignProperties_To_EncryptionV2_STATUS(destination *storage.EncryptionV2_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeySource
	if v2.KeySource != nil {
		keySource := string(*v2.KeySource)
		destination.KeySource = &keySource
	} else {
		destination.KeySource = nil
	}

	// KeyVaultProperties
	if v2.KeyVaultProperties != nil {
		var keyVaultProperty storage.EncryptionV2_KeyVaultProperties_STATUS
		err := v2.KeyVaultProperties.AssignProperties_To_EncryptionV2_KeyVaultProperties_STATUS(&keyVaultProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EncryptionV2_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		destination.KeyVaultProperties = &keyVaultProperty
	} else {
		destination.KeyVaultProperties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type EnhancedSecurityMonitoringDefinition_Value string

const (
	EnhancedSecurityMonitoringDefinition_Value_Disabled = EnhancedSecurityMonitoringDefinition_Value("Disabled")
	EnhancedSecurityMonitoringDefinition_Value_Enabled  = EnhancedSecurityMonitoringDefinition_Value("Enabled")
)

// Mapping from string to EnhancedSecurityMonitoringDefinition_Value
var enhancedSecurityMonitoringDefinition_Value_Values = map[string]EnhancedSecurityMonitoringDefinition_Value{
	"disabled": EnhancedSecurityMonitoringDefinition_Value_Disabled,
	"enabled":  EnhancedSecurityMonitoringDefinition_Value_Enabled,
}

type EnhancedSecurityMonitoringDefinition_Value_STATUS string

const (
	EnhancedSecurityMonitoringDefinition_Value_STATUS_Disabled = EnhancedSecurityMonitoringDefinition_Value_STATUS("Disabled")
	EnhancedSecurityMonitoringDefinition_Value_STATUS_Enabled  = EnhancedSecurityMonitoringDefinition_Value_STATUS("Enabled")
)

// Mapping from string to EnhancedSecurityMonitoringDefinition_Value_STATUS
var enhancedSecurityMonitoringDefinition_Value_STATUS_Values = map[string]EnhancedSecurityMonitoringDefinition_Value_STATUS{
	"disabled": EnhancedSecurityMonitoringDefinition_Value_STATUS_Disabled,
	"enabled":  EnhancedSecurityMonitoringDefinition_Value_STATUS_Enabled,
}

// The object that contains details of encryption used on the workspace.
type ManagedDiskEncryption struct {
	// +kubebuilder:validation:Required
	// KeySource: The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Keyvault
	KeySource *ManagedDiskEncryption_KeySource `json:"keySource,omitempty"`

	// +kubebuilder:validation:Required
	// KeyVaultProperties: Key Vault input properties for encryption.
	KeyVaultProperties *ManagedDiskEncryption_KeyVaultProperties `json:"keyVaultProperties,omitempty"`

	// RotationToLatestKeyVersionEnabled: Indicate whether the latest key version should be automatically used for Managed Disk
	// Encryption.
	RotationToLatestKeyVersionEnabled *bool `json:"rotationToLatestKeyVersionEnabled,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedDiskEncryption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (encryption *ManagedDiskEncryption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if encryption == nil {
		return nil, nil
	}
	result := &arm.ManagedDiskEncryption{}

	// Set property "KeySource":
	if encryption.KeySource != nil {
		var temp string
		temp = string(*encryption.KeySource)
		keySource := arm.ManagedDiskEncryption_KeySource(temp)
		result.KeySource = &keySource
	}

	// Set property "KeyVaultProperties":
	if encryption.KeyVaultProperties != nil {
		keyVaultProperties_ARM, err := encryption.KeyVaultProperties.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keyVaultProperties := *keyVaultProperties_ARM.(*arm.ManagedDiskEncryption_KeyVaultProperties)
		result.KeyVaultProperties = &keyVaultProperties
	}

	// Set property "RotationToLatestKeyVersionEnabled":
	if encryption.RotationToLatestKeyVersionEnabled != nil {
		rotationToLatestKeyVersionEnabled := *encryption.RotationToLatestKeyVersionEnabled
		result.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *ManagedDiskEncryption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedDiskEncryption{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *ManagedDiskEncryption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedDiskEncryption)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedDiskEncryption, got %T", armInput)
	}

	// Set property "KeySource":
	if typedInput.KeySource != nil {
		var temp string
		temp = string(*typedInput.KeySource)
		keySource := ManagedDiskEncryption_KeySource(temp)
		encryption.KeySource = &keySource
	}

	// Set property "KeyVaultProperties":
	if typedInput.KeyVaultProperties != nil {
		var keyVaultProperties1 ManagedDiskEncryption_KeyVaultProperties
		err := keyVaultProperties1.PopulateFromARM(owner, *typedInput.KeyVaultProperties)
		if err != nil {
			return err
		}
		keyVaultProperties := keyVaultProperties1
		encryption.KeyVaultProperties = &keyVaultProperties
	}

	// Set property "RotationToLatestKeyVersionEnabled":
	if typedInput.RotationToLatestKeyVersionEnabled != nil {
		rotationToLatestKeyVersionEnabled := *typedInput.RotationToLatestKeyVersionEnabled
		encryption.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedDiskEncryption populates our ManagedDiskEncryption from the provided source ManagedDiskEncryption
func (encryption *ManagedDiskEncryption) AssignProperties_From_ManagedDiskEncryption(source *storage.ManagedDiskEncryption) error {

	// KeySource
	if source.KeySource != nil {
		keySource := *source.KeySource
		keySourceTemp := genruntime.ToEnum(keySource, managedDiskEncryption_KeySource_Values)
		encryption.KeySource = &keySourceTemp
	} else {
		encryption.KeySource = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty ManagedDiskEncryption_KeyVaultProperties
		err := keyVaultProperty.AssignProperties_From_ManagedDiskEncryption_KeyVaultProperties(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedDiskEncryption_KeyVaultProperties() to populate field KeyVaultProperties")
		}
		encryption.KeyVaultProperties = &keyVaultProperty
	} else {
		encryption.KeyVaultProperties = nil
	}

	// RotationToLatestKeyVersionEnabled
	if source.RotationToLatestKeyVersionEnabled != nil {
		rotationToLatestKeyVersionEnabled := *source.RotationToLatestKeyVersionEnabled
		encryption.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
	} else {
		encryption.RotationToLatestKeyVersionEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedDiskEncryption populates the provided destination ManagedDiskEncryption from our ManagedDiskEncryption
func (encryption *ManagedDiskEncryption) AssignProperties_To_ManagedDiskEncryption(destination *storage.ManagedDiskEncryption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeySource
	if encryption.KeySource != nil {
		keySource := string(*encryption.KeySource)
		destination.KeySource = &keySource
	} else {
		destination.KeySource = nil
	}

	// KeyVaultProperties
	if encryption.KeyVaultProperties != nil {
		var keyVaultProperty storage.ManagedDiskEncryption_KeyVaultProperties
		err := encryption.KeyVaultProperties.AssignProperties_To_ManagedDiskEncryption_KeyVaultProperties(&keyVaultProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedDiskEncryption_KeyVaultProperties() to populate field KeyVaultProperties")
		}
		destination.KeyVaultProperties = &keyVaultProperty
	} else {
		destination.KeyVaultProperties = nil
	}

	// RotationToLatestKeyVersionEnabled
	if encryption.RotationToLatestKeyVersionEnabled != nil {
		rotationToLatestKeyVersionEnabled := *encryption.RotationToLatestKeyVersionEnabled
		destination.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
	} else {
		destination.RotationToLatestKeyVersionEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedDiskEncryption_STATUS populates our ManagedDiskEncryption from the provided source ManagedDiskEncryption_STATUS
func (encryption *ManagedDiskEncryption) Initialize_From_ManagedDiskEncryption_STATUS(source *ManagedDiskEncryption_STATUS) error {

	// KeySource
	if source.KeySource != nil {
		keySource := genruntime.ToEnum(string(*source.KeySource), managedDiskEncryption_KeySource_Values)
		encryption.KeySource = &keySource
	} else {
		encryption.KeySource = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty ManagedDiskEncryption_KeyVaultProperties
		err := keyVaultProperty.Initialize_From_ManagedDiskEncryption_KeyVaultProperties_STATUS(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedDiskEncryption_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		encryption.KeyVaultProperties = &keyVaultProperty
	} else {
		encryption.KeyVaultProperties = nil
	}

	// RotationToLatestKeyVersionEnabled
	if source.RotationToLatestKeyVersionEnabled != nil {
		rotationToLatestKeyVersionEnabled := *source.RotationToLatestKeyVersionEnabled
		encryption.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
	} else {
		encryption.RotationToLatestKeyVersionEnabled = nil
	}

	// No error
	return nil
}

// The object that contains details of encryption used on the workspace.
type ManagedDiskEncryption_STATUS struct {
	// KeySource: The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Keyvault
	KeySource *ManagedDiskEncryption_KeySource_STATUS `json:"keySource,omitempty"`

	// KeyVaultProperties: Key Vault input properties for encryption.
	KeyVaultProperties *ManagedDiskEncryption_KeyVaultProperties_STATUS `json:"keyVaultProperties,omitempty"`

	// RotationToLatestKeyVersionEnabled: Indicate whether the latest key version should be automatically used for Managed Disk
	// Encryption.
	RotationToLatestKeyVersionEnabled *bool `json:"rotationToLatestKeyVersionEnabled,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedDiskEncryption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *ManagedDiskEncryption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedDiskEncryption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *ManagedDiskEncryption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedDiskEncryption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedDiskEncryption_STATUS, got %T", armInput)
	}

	// Set property "KeySource":
	if typedInput.KeySource != nil {
		var temp string
		temp = string(*typedInput.KeySource)
		keySource := ManagedDiskEncryption_KeySource_STATUS(temp)
		encryption.KeySource = &keySource
	}

	// Set property "KeyVaultProperties":
	if typedInput.KeyVaultProperties != nil {
		var keyVaultProperties1 ManagedDiskEncryption_KeyVaultProperties_STATUS
		err := keyVaultProperties1.PopulateFromARM(owner, *typedInput.KeyVaultProperties)
		if err != nil {
			return err
		}
		keyVaultProperties := keyVaultProperties1
		encryption.KeyVaultProperties = &keyVaultProperties
	}

	// Set property "RotationToLatestKeyVersionEnabled":
	if typedInput.RotationToLatestKeyVersionEnabled != nil {
		rotationToLatestKeyVersionEnabled := *typedInput.RotationToLatestKeyVersionEnabled
		encryption.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedDiskEncryption_STATUS populates our ManagedDiskEncryption_STATUS from the provided source ManagedDiskEncryption_STATUS
func (encryption *ManagedDiskEncryption_STATUS) AssignProperties_From_ManagedDiskEncryption_STATUS(source *storage.ManagedDiskEncryption_STATUS) error {

	// KeySource
	if source.KeySource != nil {
		keySource := *source.KeySource
		keySourceTemp := genruntime.ToEnum(keySource, managedDiskEncryption_KeySource_STATUS_Values)
		encryption.KeySource = &keySourceTemp
	} else {
		encryption.KeySource = nil
	}

	// KeyVaultProperties
	if source.KeyVaultProperties != nil {
		var keyVaultProperty ManagedDiskEncryption_KeyVaultProperties_STATUS
		err := keyVaultProperty.AssignProperties_From_ManagedDiskEncryption_KeyVaultProperties_STATUS(source.KeyVaultProperties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedDiskEncryption_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		encryption.KeyVaultProperties = &keyVaultProperty
	} else {
		encryption.KeyVaultProperties = nil
	}

	// RotationToLatestKeyVersionEnabled
	if source.RotationToLatestKeyVersionEnabled != nil {
		rotationToLatestKeyVersionEnabled := *source.RotationToLatestKeyVersionEnabled
		encryption.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
	} else {
		encryption.RotationToLatestKeyVersionEnabled = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedDiskEncryption_STATUS populates the provided destination ManagedDiskEncryption_STATUS from our ManagedDiskEncryption_STATUS
func (encryption *ManagedDiskEncryption_STATUS) AssignProperties_To_ManagedDiskEncryption_STATUS(destination *storage.ManagedDiskEncryption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeySource
	if encryption.KeySource != nil {
		keySource := string(*encryption.KeySource)
		destination.KeySource = &keySource
	} else {
		destination.KeySource = nil
	}

	// KeyVaultProperties
	if encryption.KeyVaultProperties != nil {
		var keyVaultProperty storage.ManagedDiskEncryption_KeyVaultProperties_STATUS
		err := encryption.KeyVaultProperties.AssignProperties_To_ManagedDiskEncryption_KeyVaultProperties_STATUS(&keyVaultProperty)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedDiskEncryption_KeyVaultProperties_STATUS() to populate field KeyVaultProperties")
		}
		destination.KeyVaultProperties = &keyVaultProperty
	} else {
		destination.KeyVaultProperties = nil
	}

	// RotationToLatestKeyVersionEnabled
	if encryption.RotationToLatestKeyVersionEnabled != nil {
		rotationToLatestKeyVersionEnabled := *encryption.RotationToLatestKeyVersionEnabled
		destination.RotationToLatestKeyVersionEnabled = &rotationToLatestKeyVersionEnabled
	} else {
		destination.RotationToLatestKeyVersionEnabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Provisioning status of the workspace.
// +kubebuilder:validation:Enum={"Bool","Object","String"}
type WorkspaceCustomParameterType string

const (
	WorkspaceCustomParameterType_Bool   = WorkspaceCustomParameterType("Bool")
	WorkspaceCustomParameterType_Object = WorkspaceCustomParameterType("Object")
	WorkspaceCustomParameterType_String = WorkspaceCustomParameterType("String")
)

// Mapping from string to WorkspaceCustomParameterType
var workspaceCustomParameterType_Values = map[string]WorkspaceCustomParameterType{
	"bool":   WorkspaceCustomParameterType_Bool,
	"object": WorkspaceCustomParameterType_Object,
	"string": WorkspaceCustomParameterType_String,
}

// Provisioning status of the workspace.
type WorkspaceCustomParameterType_STATUS string

const (
	WorkspaceCustomParameterType_STATUS_Bool   = WorkspaceCustomParameterType_STATUS("Bool")
	WorkspaceCustomParameterType_STATUS_Object = WorkspaceCustomParameterType_STATUS("Object")
	WorkspaceCustomParameterType_STATUS_String = WorkspaceCustomParameterType_STATUS("String")
)

// Mapping from string to WorkspaceCustomParameterType_STATUS
var workspaceCustomParameterType_STATUS_Values = map[string]WorkspaceCustomParameterType_STATUS{
	"bool":   WorkspaceCustomParameterType_STATUS_Bool,
	"object": WorkspaceCustomParameterType_STATUS_Object,
	"string": WorkspaceCustomParameterType_STATUS_String,
}

// +kubebuilder:validation:Enum={"Default","Microsoft.Keyvault"}
type Encryption_KeySource string

const (
	Encryption_KeySource_Default           = Encryption_KeySource("Default")
	Encryption_KeySource_MicrosoftKeyvault = Encryption_KeySource("Microsoft.Keyvault")
)

// Mapping from string to Encryption_KeySource
var encryption_KeySource_Values = map[string]Encryption_KeySource{
	"default":            Encryption_KeySource_Default,
	"microsoft.keyvault": Encryption_KeySource_MicrosoftKeyvault,
}

type Encryption_KeySource_STATUS string

const (
	Encryption_KeySource_STATUS_Default           = Encryption_KeySource_STATUS("Default")
	Encryption_KeySource_STATUS_MicrosoftKeyvault = Encryption_KeySource_STATUS("Microsoft.Keyvault")
)

// Mapping from string to Encryption_KeySource_STATUS
var encryption_KeySource_STATUS_Values = map[string]Encryption_KeySource_STATUS{
	"default":            Encryption_KeySource_STATUS_Default,
	"microsoft.keyvault": Encryption_KeySource_STATUS_MicrosoftKeyvault,
}

// +kubebuilder:validation:Enum={"Microsoft.Keyvault"}
type EncryptionV2_KeySource string

const EncryptionV2_KeySource_MicrosoftKeyvault = EncryptionV2_KeySource("Microsoft.Keyvault")

// Mapping from string to EncryptionV2_KeySource
var encryptionV2_KeySource_Values = map[string]EncryptionV2_KeySource{
	"microsoft.keyvault": EncryptionV2_KeySource_MicrosoftKeyvault,
}

type EncryptionV2_KeySource_STATUS string

const EncryptionV2_KeySource_STATUS_MicrosoftKeyvault = EncryptionV2_KeySource_STATUS("Microsoft.Keyvault")

// Mapping from string to EncryptionV2_KeySource_STATUS
var encryptionV2_KeySource_STATUS_Values = map[string]EncryptionV2_KeySource_STATUS{
	"microsoft.keyvault": EncryptionV2_KeySource_STATUS_MicrosoftKeyvault,
}

type EncryptionV2_KeyVaultProperties struct {
	// +kubebuilder:validation:Required
	// KeyName: The name of KeyVault key.
	KeyName *string `json:"keyName,omitempty"`

	// +kubebuilder:validation:Required
	// KeyVaultUri: The Uri of KeyVault.
	KeyVaultUri *string `json:"keyVaultUri,omitempty"`

	// +kubebuilder:validation:Required
	// KeyVersion: The version of KeyVault key.
	KeyVersion *string `json:"keyVersion,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionV2_KeyVaultProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *EncryptionV2_KeyVaultProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.EncryptionV2_KeyVaultProperties{}

	// Set property "KeyName":
	if properties.KeyName != nil {
		keyName := *properties.KeyName
		result.KeyName = &keyName
	}

	// Set property "KeyVaultUri":
	if properties.KeyVaultUri != nil {
		keyVaultUri := *properties.KeyVaultUri
		result.KeyVaultUri = &keyVaultUri
	}

	// Set property "KeyVersion":
	if properties.KeyVersion != nil {
		keyVersion := *properties.KeyVersion
		result.KeyVersion = &keyVersion
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EncryptionV2_KeyVaultProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionV2_KeyVaultProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EncryptionV2_KeyVaultProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionV2_KeyVaultProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionV2_KeyVaultProperties, got %T", armInput)
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		properties.KeyName = &keyName
	}

	// Set property "KeyVaultUri":
	if typedInput.KeyVaultUri != nil {
		keyVaultUri := *typedInput.KeyVaultUri
		properties.KeyVaultUri = &keyVaultUri
	}

	// Set property "KeyVersion":
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		properties.KeyVersion = &keyVersion
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionV2_KeyVaultProperties populates our EncryptionV2_KeyVaultProperties from the provided source EncryptionV2_KeyVaultProperties
func (properties *EncryptionV2_KeyVaultProperties) AssignProperties_From_EncryptionV2_KeyVaultProperties(source *storage.EncryptionV2_KeyVaultProperties) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVaultUri
	properties.KeyVaultUri = genruntime.ClonePointerToString(source.KeyVaultUri)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// No error
	return nil
}

// AssignProperties_To_EncryptionV2_KeyVaultProperties populates the provided destination EncryptionV2_KeyVaultProperties from our EncryptionV2_KeyVaultProperties
func (properties *EncryptionV2_KeyVaultProperties) AssignProperties_To_EncryptionV2_KeyVaultProperties(destination *storage.EncryptionV2_KeyVaultProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(properties.KeyName)

	// KeyVaultUri
	destination.KeyVaultUri = genruntime.ClonePointerToString(properties.KeyVaultUri)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(properties.KeyVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EncryptionV2_KeyVaultProperties_STATUS populates our EncryptionV2_KeyVaultProperties from the provided source EncryptionV2_KeyVaultProperties_STATUS
func (properties *EncryptionV2_KeyVaultProperties) Initialize_From_EncryptionV2_KeyVaultProperties_STATUS(source *EncryptionV2_KeyVaultProperties_STATUS) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVaultUri
	properties.KeyVaultUri = genruntime.ClonePointerToString(source.KeyVaultUri)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// No error
	return nil
}

type EncryptionV2_KeyVaultProperties_STATUS struct {
	// KeyName: The name of KeyVault key.
	KeyName *string `json:"keyName,omitempty"`

	// KeyVaultUri: The Uri of KeyVault.
	KeyVaultUri *string `json:"keyVaultUri,omitempty"`

	// KeyVersion: The version of KeyVault key.
	KeyVersion *string `json:"keyVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionV2_KeyVaultProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *EncryptionV2_KeyVaultProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EncryptionV2_KeyVaultProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *EncryptionV2_KeyVaultProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EncryptionV2_KeyVaultProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EncryptionV2_KeyVaultProperties_STATUS, got %T", armInput)
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		properties.KeyName = &keyName
	}

	// Set property "KeyVaultUri":
	if typedInput.KeyVaultUri != nil {
		keyVaultUri := *typedInput.KeyVaultUri
		properties.KeyVaultUri = &keyVaultUri
	}

	// Set property "KeyVersion":
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		properties.KeyVersion = &keyVersion
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionV2_KeyVaultProperties_STATUS populates our EncryptionV2_KeyVaultProperties_STATUS from the provided source EncryptionV2_KeyVaultProperties_STATUS
func (properties *EncryptionV2_KeyVaultProperties_STATUS) AssignProperties_From_EncryptionV2_KeyVaultProperties_STATUS(source *storage.EncryptionV2_KeyVaultProperties_STATUS) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVaultUri
	properties.KeyVaultUri = genruntime.ClonePointerToString(source.KeyVaultUri)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// No error
	return nil
}

// AssignProperties_To_EncryptionV2_KeyVaultProperties_STATUS populates the provided destination EncryptionV2_KeyVaultProperties_STATUS from our EncryptionV2_KeyVaultProperties_STATUS
func (properties *EncryptionV2_KeyVaultProperties_STATUS) AssignProperties_To_EncryptionV2_KeyVaultProperties_STATUS(destination *storage.EncryptionV2_KeyVaultProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(properties.KeyName)

	// KeyVaultUri
	destination.KeyVaultUri = genruntime.ClonePointerToString(properties.KeyVaultUri)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(properties.KeyVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Microsoft.Keyvault"}
type ManagedDiskEncryption_KeySource string

const ManagedDiskEncryption_KeySource_MicrosoftKeyvault = ManagedDiskEncryption_KeySource("Microsoft.Keyvault")

// Mapping from string to ManagedDiskEncryption_KeySource
var managedDiskEncryption_KeySource_Values = map[string]ManagedDiskEncryption_KeySource{
	"microsoft.keyvault": ManagedDiskEncryption_KeySource_MicrosoftKeyvault,
}

type ManagedDiskEncryption_KeySource_STATUS string

const ManagedDiskEncryption_KeySource_STATUS_MicrosoftKeyvault = ManagedDiskEncryption_KeySource_STATUS("Microsoft.Keyvault")

// Mapping from string to ManagedDiskEncryption_KeySource_STATUS
var managedDiskEncryption_KeySource_STATUS_Values = map[string]ManagedDiskEncryption_KeySource_STATUS{
	"microsoft.keyvault": ManagedDiskEncryption_KeySource_STATUS_MicrosoftKeyvault,
}

type ManagedDiskEncryption_KeyVaultProperties struct {
	// +kubebuilder:validation:Required
	// KeyName: The name of KeyVault key.
	KeyName *string `json:"keyName,omitempty"`

	// +kubebuilder:validation:Required
	// KeyVaultUri: The URI of KeyVault.
	KeyVaultUri *string `json:"keyVaultUri,omitempty"`

	// +kubebuilder:validation:Required
	// KeyVersion: The version of KeyVault key.
	KeyVersion *string `json:"keyVersion,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedDiskEncryption_KeyVaultProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *ManagedDiskEncryption_KeyVaultProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.ManagedDiskEncryption_KeyVaultProperties{}

	// Set property "KeyName":
	if properties.KeyName != nil {
		keyName := *properties.KeyName
		result.KeyName = &keyName
	}

	// Set property "KeyVaultUri":
	if properties.KeyVaultUri != nil {
		keyVaultUri := *properties.KeyVaultUri
		result.KeyVaultUri = &keyVaultUri
	}

	// Set property "KeyVersion":
	if properties.KeyVersion != nil {
		keyVersion := *properties.KeyVersion
		result.KeyVersion = &keyVersion
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ManagedDiskEncryption_KeyVaultProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedDiskEncryption_KeyVaultProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ManagedDiskEncryption_KeyVaultProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedDiskEncryption_KeyVaultProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedDiskEncryption_KeyVaultProperties, got %T", armInput)
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		properties.KeyName = &keyName
	}

	// Set property "KeyVaultUri":
	if typedInput.KeyVaultUri != nil {
		keyVaultUri := *typedInput.KeyVaultUri
		properties.KeyVaultUri = &keyVaultUri
	}

	// Set property "KeyVersion":
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		properties.KeyVersion = &keyVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedDiskEncryption_KeyVaultProperties populates our ManagedDiskEncryption_KeyVaultProperties from the provided source ManagedDiskEncryption_KeyVaultProperties
func (properties *ManagedDiskEncryption_KeyVaultProperties) AssignProperties_From_ManagedDiskEncryption_KeyVaultProperties(source *storage.ManagedDiskEncryption_KeyVaultProperties) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVaultUri
	properties.KeyVaultUri = genruntime.ClonePointerToString(source.KeyVaultUri)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// No error
	return nil
}

// AssignProperties_To_ManagedDiskEncryption_KeyVaultProperties populates the provided destination ManagedDiskEncryption_KeyVaultProperties from our ManagedDiskEncryption_KeyVaultProperties
func (properties *ManagedDiskEncryption_KeyVaultProperties) AssignProperties_To_ManagedDiskEncryption_KeyVaultProperties(destination *storage.ManagedDiskEncryption_KeyVaultProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(properties.KeyName)

	// KeyVaultUri
	destination.KeyVaultUri = genruntime.ClonePointerToString(properties.KeyVaultUri)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(properties.KeyVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedDiskEncryption_KeyVaultProperties_STATUS populates our ManagedDiskEncryption_KeyVaultProperties from the provided source ManagedDiskEncryption_KeyVaultProperties_STATUS
func (properties *ManagedDiskEncryption_KeyVaultProperties) Initialize_From_ManagedDiskEncryption_KeyVaultProperties_STATUS(source *ManagedDiskEncryption_KeyVaultProperties_STATUS) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVaultUri
	properties.KeyVaultUri = genruntime.ClonePointerToString(source.KeyVaultUri)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// No error
	return nil
}

type ManagedDiskEncryption_KeyVaultProperties_STATUS struct {
	// KeyName: The name of KeyVault key.
	KeyName *string `json:"keyName,omitempty"`

	// KeyVaultUri: The URI of KeyVault.
	KeyVaultUri *string `json:"keyVaultUri,omitempty"`

	// KeyVersion: The version of KeyVault key.
	KeyVersion *string `json:"keyVersion,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedDiskEncryption_KeyVaultProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ManagedDiskEncryption_KeyVaultProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedDiskEncryption_KeyVaultProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ManagedDiskEncryption_KeyVaultProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedDiskEncryption_KeyVaultProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedDiskEncryption_KeyVaultProperties_STATUS, got %T", armInput)
	}

	// Set property "KeyName":
	if typedInput.KeyName != nil {
		keyName := *typedInput.KeyName
		properties.KeyName = &keyName
	}

	// Set property "KeyVaultUri":
	if typedInput.KeyVaultUri != nil {
		keyVaultUri := *typedInput.KeyVaultUri
		properties.KeyVaultUri = &keyVaultUri
	}

	// Set property "KeyVersion":
	if typedInput.KeyVersion != nil {
		keyVersion := *typedInput.KeyVersion
		properties.KeyVersion = &keyVersion
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedDiskEncryption_KeyVaultProperties_STATUS populates our ManagedDiskEncryption_KeyVaultProperties_STATUS from the provided source ManagedDiskEncryption_KeyVaultProperties_STATUS
func (properties *ManagedDiskEncryption_KeyVaultProperties_STATUS) AssignProperties_From_ManagedDiskEncryption_KeyVaultProperties_STATUS(source *storage.ManagedDiskEncryption_KeyVaultProperties_STATUS) error {

	// KeyName
	properties.KeyName = genruntime.ClonePointerToString(source.KeyName)

	// KeyVaultUri
	properties.KeyVaultUri = genruntime.ClonePointerToString(source.KeyVaultUri)

	// KeyVersion
	properties.KeyVersion = genruntime.ClonePointerToString(source.KeyVersion)

	// No error
	return nil
}

// AssignProperties_To_ManagedDiskEncryption_KeyVaultProperties_STATUS populates the provided destination ManagedDiskEncryption_KeyVaultProperties_STATUS from our ManagedDiskEncryption_KeyVaultProperties_STATUS
func (properties *ManagedDiskEncryption_KeyVaultProperties_STATUS) AssignProperties_To_ManagedDiskEncryption_KeyVaultProperties_STATUS(destination *storage.ManagedDiskEncryption_KeyVaultProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyName
	destination.KeyName = genruntime.ClonePointerToString(properties.KeyName)

	// KeyVaultUri
	destination.KeyVaultUri = genruntime.ClonePointerToString(properties.KeyVaultUri)

	// KeyVersion
	destination.KeyVersion = genruntime.ClonePointerToString(properties.KeyVersion)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Workspace{}, &WorkspaceList{})
}
