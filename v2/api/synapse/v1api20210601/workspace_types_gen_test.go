// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20210601

import (
	"encoding/json"
	v20210601s "github.com/Azure/azure-service-operator/v2/api/synapse/v1api20210601storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Workspace_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspace to hub returns original",
		prop.ForAll(RunResourceConversionTestForWorkspace, WorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForWorkspace tests if a specific instance of Workspace round trips to the hub storage version and back losslessly
func RunResourceConversionTestForWorkspace(subject Workspace) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20210601s.Workspace
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual Workspace
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspace_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspace to Workspace via AssignProperties_To_Workspace & AssignProperties_From_Workspace returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspace, WorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspace tests if a specific instance of Workspace can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForWorkspace(subject Workspace) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.Workspace
	err := copied.AssignProperties_To_Workspace(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Workspace
	err = actual.AssignProperties_From_Workspace(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspace_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspace via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspace, WorkspaceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspace runs a test to see if a specific instance of Workspace round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspace(subject Workspace) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspace
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspace instances for property testing - lazily instantiated by WorkspaceGenerator()
var workspaceGenerator gopter.Gen

// WorkspaceGenerator returns a generator of Workspace instances for property testing.
func WorkspaceGenerator() gopter.Gen {
	if workspaceGenerator != nil {
		return workspaceGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForWorkspace(generators)
	workspaceGenerator = gen.Struct(reflect.TypeOf(Workspace{}), generators)

	return workspaceGenerator
}

// AddRelatedPropertyGeneratorsForWorkspace is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspace(gens map[string]gopter.Gen) {
	gens["Spec"] = Workspace_SpecGenerator()
	gens["Status"] = Workspace_STATUSGenerator()
}

func Test_Workspace_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspace_Spec to Workspace_Spec via AssignProperties_To_Workspace_Spec & AssignProperties_From_Workspace_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspace_Spec, Workspace_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspace_Spec tests if a specific instance of Workspace_Spec can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForWorkspace_Spec(subject Workspace_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.Workspace_Spec
	err := copied.AssignProperties_To_Workspace_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Workspace_Spec
	err = actual.AssignProperties_From_Workspace_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspace_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspace_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspace_Spec, Workspace_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspace_Spec runs a test to see if a specific instance of Workspace_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspace_Spec(subject Workspace_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspace_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspace_Spec instances for property testing - lazily instantiated by Workspace_SpecGenerator()
var workspace_SpecGenerator gopter.Gen

// Workspace_SpecGenerator returns a generator of Workspace_Spec instances for property testing.
// We first initialize workspace_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Workspace_SpecGenerator() gopter.Gen {
	if workspace_SpecGenerator != nil {
		return workspace_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_Spec(generators)
	workspace_SpecGenerator = gen.Struct(reflect.TypeOf(Workspace_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_Spec(generators)
	AddRelatedPropertyGeneratorsForWorkspace_Spec(generators)
	workspace_SpecGenerator = gen.Struct(reflect.TypeOf(Workspace_Spec{}), generators)

	return workspace_SpecGenerator
}

// AddIndependentPropertyGeneratorsForWorkspace_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspace_Spec(gens map[string]gopter.Gen) {
	gens["AzureADOnlyAuthentication"] = gen.PtrOf(gen.Bool())
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedResourceGroupName"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedVirtualNetwork"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(WorkspaceProperties_PublicNetworkAccess_Disabled, WorkspaceProperties_PublicNetworkAccess_Enabled))
	gens["SqlAdministratorLogin"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["TrustedServiceBypassEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForWorkspace_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspace_Spec(gens map[string]gopter.Gen) {
	gens["CspWorkspaceAdminProperties"] = gen.PtrOf(CspWorkspaceAdminPropertiesGenerator())
	gens["DefaultDataLakeStorage"] = gen.PtrOf(DataLakeStorageAccountDetailsGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionDetailsGenerator())
	gens["Identity"] = gen.PtrOf(ManagedIdentityGenerator())
	gens["ManagedVirtualNetworkSettings"] = gen.PtrOf(ManagedVirtualNetworkSettingsGenerator())
	gens["PurviewConfiguration"] = gen.PtrOf(PurviewConfigurationGenerator())
	gens["VirtualNetworkProfile"] = gen.PtrOf(VirtualNetworkProfileGenerator())
	gens["WorkspaceRepositoryConfiguration"] = gen.PtrOf(WorkspaceRepositoryConfigurationGenerator())
}

func Test_Workspace_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Workspace_STATUS to Workspace_STATUS via AssignProperties_To_Workspace_STATUS & AssignProperties_From_Workspace_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspace_STATUS, Workspace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspace_STATUS tests if a specific instance of Workspace_STATUS can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForWorkspace_STATUS(subject Workspace_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.Workspace_STATUS
	err := copied.AssignProperties_To_Workspace_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Workspace_STATUS
	err = actual.AssignProperties_From_Workspace_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Workspace_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Workspace_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspace_STATUS, Workspace_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspace_STATUS runs a test to see if a specific instance of Workspace_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspace_STATUS(subject Workspace_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Workspace_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Workspace_STATUS instances for property testing - lazily instantiated by Workspace_STATUSGenerator()
var workspace_STATUSGenerator gopter.Gen

// Workspace_STATUSGenerator returns a generator of Workspace_STATUS instances for property testing.
// We first initialize workspace_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Workspace_STATUSGenerator() gopter.Gen {
	if workspace_STATUSGenerator != nil {
		return workspace_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_STATUS(generators)
	workspace_STATUSGenerator = gen.Struct(reflect.TypeOf(Workspace_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspace_STATUS(generators)
	AddRelatedPropertyGeneratorsForWorkspace_STATUS(generators)
	workspace_STATUSGenerator = gen.Struct(reflect.TypeOf(Workspace_STATUS{}), generators)

	return workspace_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkspace_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspace_STATUS(gens map[string]gopter.Gen) {
	gens["AdlaResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["AzureADOnlyAuthentication"] = gen.PtrOf(gen.Bool())
	gens["ConnectivityEndpoints"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedResourceGroupName"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedVirtualNetwork"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(WorkspaceProperties_PublicNetworkAccess_STATUS_Disabled, WorkspaceProperties_PublicNetworkAccess_STATUS_Enabled))
	gens["SqlAdministratorLogin"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["TrustedServiceBypassEnabled"] = gen.PtrOf(gen.Bool())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["WorkspaceUID"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForWorkspace_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWorkspace_STATUS(gens map[string]gopter.Gen) {
	gens["CspWorkspaceAdminProperties"] = gen.PtrOf(CspWorkspaceAdminProperties_STATUSGenerator())
	gens["DefaultDataLakeStorage"] = gen.PtrOf(DataLakeStorageAccountDetails_STATUSGenerator())
	gens["Encryption"] = gen.PtrOf(EncryptionDetails_STATUSGenerator())
	gens["Identity"] = gen.PtrOf(ManagedIdentity_STATUSGenerator())
	gens["ManagedVirtualNetworkSettings"] = gen.PtrOf(ManagedVirtualNetworkSettings_STATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_STATUSGenerator())
	gens["PurviewConfiguration"] = gen.PtrOf(PurviewConfiguration_STATUSGenerator())
	gens["VirtualNetworkProfile"] = gen.PtrOf(VirtualNetworkProfile_STATUSGenerator())
	gens["WorkspaceRepositoryConfiguration"] = gen.PtrOf(WorkspaceRepositoryConfiguration_STATUSGenerator())
}

func Test_CspWorkspaceAdminProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CspWorkspaceAdminProperties to CspWorkspaceAdminProperties via AssignProperties_To_CspWorkspaceAdminProperties & AssignProperties_From_CspWorkspaceAdminProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForCspWorkspaceAdminProperties, CspWorkspaceAdminPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCspWorkspaceAdminProperties tests if a specific instance of CspWorkspaceAdminProperties can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForCspWorkspaceAdminProperties(subject CspWorkspaceAdminProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CspWorkspaceAdminProperties
	err := copied.AssignProperties_To_CspWorkspaceAdminProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CspWorkspaceAdminProperties
	err = actual.AssignProperties_From_CspWorkspaceAdminProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CspWorkspaceAdminProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CspWorkspaceAdminProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCspWorkspaceAdminProperties, CspWorkspaceAdminPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCspWorkspaceAdminProperties runs a test to see if a specific instance of CspWorkspaceAdminProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForCspWorkspaceAdminProperties(subject CspWorkspaceAdminProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CspWorkspaceAdminProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CspWorkspaceAdminProperties instances for property testing - lazily instantiated by
// CspWorkspaceAdminPropertiesGenerator()
var cspWorkspaceAdminPropertiesGenerator gopter.Gen

// CspWorkspaceAdminPropertiesGenerator returns a generator of CspWorkspaceAdminProperties instances for property testing.
func CspWorkspaceAdminPropertiesGenerator() gopter.Gen {
	if cspWorkspaceAdminPropertiesGenerator != nil {
		return cspWorkspaceAdminPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCspWorkspaceAdminProperties(generators)
	cspWorkspaceAdminPropertiesGenerator = gen.Struct(reflect.TypeOf(CspWorkspaceAdminProperties{}), generators)

	return cspWorkspaceAdminPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForCspWorkspaceAdminProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCspWorkspaceAdminProperties(gens map[string]gopter.Gen) {
	gens["InitialWorkspaceAdminObjectId"] = gen.PtrOf(gen.AlphaString())
}

func Test_CspWorkspaceAdminProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CspWorkspaceAdminProperties_STATUS to CspWorkspaceAdminProperties_STATUS via AssignProperties_To_CspWorkspaceAdminProperties_STATUS & AssignProperties_From_CspWorkspaceAdminProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCspWorkspaceAdminProperties_STATUS, CspWorkspaceAdminProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCspWorkspaceAdminProperties_STATUS tests if a specific instance of CspWorkspaceAdminProperties_STATUS can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForCspWorkspaceAdminProperties_STATUS(subject CspWorkspaceAdminProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CspWorkspaceAdminProperties_STATUS
	err := copied.AssignProperties_To_CspWorkspaceAdminProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CspWorkspaceAdminProperties_STATUS
	err = actual.AssignProperties_From_CspWorkspaceAdminProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CspWorkspaceAdminProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CspWorkspaceAdminProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCspWorkspaceAdminProperties_STATUS, CspWorkspaceAdminProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCspWorkspaceAdminProperties_STATUS runs a test to see if a specific instance of CspWorkspaceAdminProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCspWorkspaceAdminProperties_STATUS(subject CspWorkspaceAdminProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CspWorkspaceAdminProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CspWorkspaceAdminProperties_STATUS instances for property testing - lazily instantiated by
// CspWorkspaceAdminProperties_STATUSGenerator()
var cspWorkspaceAdminProperties_STATUSGenerator gopter.Gen

// CspWorkspaceAdminProperties_STATUSGenerator returns a generator of CspWorkspaceAdminProperties_STATUS instances for property testing.
func CspWorkspaceAdminProperties_STATUSGenerator() gopter.Gen {
	if cspWorkspaceAdminProperties_STATUSGenerator != nil {
		return cspWorkspaceAdminProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCspWorkspaceAdminProperties_STATUS(generators)
	cspWorkspaceAdminProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(CspWorkspaceAdminProperties_STATUS{}), generators)

	return cspWorkspaceAdminProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCspWorkspaceAdminProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCspWorkspaceAdminProperties_STATUS(gens map[string]gopter.Gen) {
	gens["InitialWorkspaceAdminObjectId"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataLakeStorageAccountDetails_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataLakeStorageAccountDetails to DataLakeStorageAccountDetails via AssignProperties_To_DataLakeStorageAccountDetails & AssignProperties_From_DataLakeStorageAccountDetails returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataLakeStorageAccountDetails, DataLakeStorageAccountDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataLakeStorageAccountDetails tests if a specific instance of DataLakeStorageAccountDetails can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForDataLakeStorageAccountDetails(subject DataLakeStorageAccountDetails) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DataLakeStorageAccountDetails
	err := copied.AssignProperties_To_DataLakeStorageAccountDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataLakeStorageAccountDetails
	err = actual.AssignProperties_From_DataLakeStorageAccountDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataLakeStorageAccountDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataLakeStorageAccountDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataLakeStorageAccountDetails, DataLakeStorageAccountDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataLakeStorageAccountDetails runs a test to see if a specific instance of DataLakeStorageAccountDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForDataLakeStorageAccountDetails(subject DataLakeStorageAccountDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataLakeStorageAccountDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataLakeStorageAccountDetails instances for property testing - lazily instantiated by
// DataLakeStorageAccountDetailsGenerator()
var dataLakeStorageAccountDetailsGenerator gopter.Gen

// DataLakeStorageAccountDetailsGenerator returns a generator of DataLakeStorageAccountDetails instances for property testing.
func DataLakeStorageAccountDetailsGenerator() gopter.Gen {
	if dataLakeStorageAccountDetailsGenerator != nil {
		return dataLakeStorageAccountDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataLakeStorageAccountDetails(generators)
	dataLakeStorageAccountDetailsGenerator = gen.Struct(reflect.TypeOf(DataLakeStorageAccountDetails{}), generators)

	return dataLakeStorageAccountDetailsGenerator
}

// AddIndependentPropertyGeneratorsForDataLakeStorageAccountDetails is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataLakeStorageAccountDetails(gens map[string]gopter.Gen) {
	gens["AccountUrl"] = gen.PtrOf(gen.AlphaString())
	gens["CreateManagedPrivateEndpoint"] = gen.PtrOf(gen.Bool())
	gens["Filesystem"] = gen.PtrOf(gen.AlphaString())
}

func Test_DataLakeStorageAccountDetails_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DataLakeStorageAccountDetails_STATUS to DataLakeStorageAccountDetails_STATUS via AssignProperties_To_DataLakeStorageAccountDetails_STATUS & AssignProperties_From_DataLakeStorageAccountDetails_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDataLakeStorageAccountDetails_STATUS, DataLakeStorageAccountDetails_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDataLakeStorageAccountDetails_STATUS tests if a specific instance of DataLakeStorageAccountDetails_STATUS can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForDataLakeStorageAccountDetails_STATUS(subject DataLakeStorageAccountDetails_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DataLakeStorageAccountDetails_STATUS
	err := copied.AssignProperties_To_DataLakeStorageAccountDetails_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DataLakeStorageAccountDetails_STATUS
	err = actual.AssignProperties_From_DataLakeStorageAccountDetails_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DataLakeStorageAccountDetails_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DataLakeStorageAccountDetails_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDataLakeStorageAccountDetails_STATUS, DataLakeStorageAccountDetails_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDataLakeStorageAccountDetails_STATUS runs a test to see if a specific instance of DataLakeStorageAccountDetails_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDataLakeStorageAccountDetails_STATUS(subject DataLakeStorageAccountDetails_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DataLakeStorageAccountDetails_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DataLakeStorageAccountDetails_STATUS instances for property testing - lazily instantiated by
// DataLakeStorageAccountDetails_STATUSGenerator()
var dataLakeStorageAccountDetails_STATUSGenerator gopter.Gen

// DataLakeStorageAccountDetails_STATUSGenerator returns a generator of DataLakeStorageAccountDetails_STATUS instances for property testing.
func DataLakeStorageAccountDetails_STATUSGenerator() gopter.Gen {
	if dataLakeStorageAccountDetails_STATUSGenerator != nil {
		return dataLakeStorageAccountDetails_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDataLakeStorageAccountDetails_STATUS(generators)
	dataLakeStorageAccountDetails_STATUSGenerator = gen.Struct(reflect.TypeOf(DataLakeStorageAccountDetails_STATUS{}), generators)

	return dataLakeStorageAccountDetails_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDataLakeStorageAccountDetails_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDataLakeStorageAccountDetails_STATUS(gens map[string]gopter.Gen) {
	gens["AccountUrl"] = gen.PtrOf(gen.AlphaString())
	gens["CreateManagedPrivateEndpoint"] = gen.PtrOf(gen.Bool())
	gens["Filesystem"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_EncryptionDetails_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionDetails to EncryptionDetails via AssignProperties_To_EncryptionDetails & AssignProperties_From_EncryptionDetails returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionDetails, EncryptionDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionDetails tests if a specific instance of EncryptionDetails can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForEncryptionDetails(subject EncryptionDetails) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.EncryptionDetails
	err := copied.AssignProperties_To_EncryptionDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionDetails
	err = actual.AssignProperties_From_EncryptionDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionDetails, EncryptionDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionDetails runs a test to see if a specific instance of EncryptionDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionDetails(subject EncryptionDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionDetails instances for property testing - lazily instantiated by EncryptionDetailsGenerator()
var encryptionDetailsGenerator gopter.Gen

// EncryptionDetailsGenerator returns a generator of EncryptionDetails instances for property testing.
func EncryptionDetailsGenerator() gopter.Gen {
	if encryptionDetailsGenerator != nil {
		return encryptionDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEncryptionDetails(generators)
	encryptionDetailsGenerator = gen.Struct(reflect.TypeOf(EncryptionDetails{}), generators)

	return encryptionDetailsGenerator
}

// AddRelatedPropertyGeneratorsForEncryptionDetails is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionDetails(gens map[string]gopter.Gen) {
	gens["Cmk"] = gen.PtrOf(CustomerManagedKeyDetailsGenerator())
}

func Test_EncryptionDetails_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EncryptionDetails_STATUS to EncryptionDetails_STATUS via AssignProperties_To_EncryptionDetails_STATUS & AssignProperties_From_EncryptionDetails_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEncryptionDetails_STATUS, EncryptionDetails_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEncryptionDetails_STATUS tests if a specific instance of EncryptionDetails_STATUS can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForEncryptionDetails_STATUS(subject EncryptionDetails_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.EncryptionDetails_STATUS
	err := copied.AssignProperties_To_EncryptionDetails_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EncryptionDetails_STATUS
	err = actual.AssignProperties_From_EncryptionDetails_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EncryptionDetails_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EncryptionDetails_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEncryptionDetails_STATUS, EncryptionDetails_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEncryptionDetails_STATUS runs a test to see if a specific instance of EncryptionDetails_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEncryptionDetails_STATUS(subject EncryptionDetails_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EncryptionDetails_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EncryptionDetails_STATUS instances for property testing - lazily instantiated by
// EncryptionDetails_STATUSGenerator()
var encryptionDetails_STATUSGenerator gopter.Gen

// EncryptionDetails_STATUSGenerator returns a generator of EncryptionDetails_STATUS instances for property testing.
// We first initialize encryptionDetails_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EncryptionDetails_STATUSGenerator() gopter.Gen {
	if encryptionDetails_STATUSGenerator != nil {
		return encryptionDetails_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionDetails_STATUS(generators)
	encryptionDetails_STATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionDetails_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEncryptionDetails_STATUS(generators)
	AddRelatedPropertyGeneratorsForEncryptionDetails_STATUS(generators)
	encryptionDetails_STATUSGenerator = gen.Struct(reflect.TypeOf(EncryptionDetails_STATUS{}), generators)

	return encryptionDetails_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEncryptionDetails_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEncryptionDetails_STATUS(gens map[string]gopter.Gen) {
	gens["DoubleEncryptionEnabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForEncryptionDetails_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEncryptionDetails_STATUS(gens map[string]gopter.Gen) {
	gens["Cmk"] = gen.PtrOf(CustomerManagedKeyDetails_STATUSGenerator())
}

func Test_ManagedIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentity to ManagedIdentity via AssignProperties_To_ManagedIdentity & AssignProperties_From_ManagedIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentity, ManagedIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentity tests if a specific instance of ManagedIdentity can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentity(subject ManagedIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ManagedIdentity
	err := copied.AssignProperties_To_ManagedIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentity
	err = actual.AssignProperties_From_ManagedIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentity, ManagedIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentity runs a test to see if a specific instance of ManagedIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentity(subject ManagedIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity instances for property testing - lazily instantiated by ManagedIdentityGenerator()
var managedIdentityGenerator gopter.Gen

// ManagedIdentityGenerator returns a generator of ManagedIdentity instances for property testing.
// We first initialize managedIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedIdentityGenerator() gopter.Gen {
	if managedIdentityGenerator != nil {
		return managedIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity(generators)
	managedIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity(generators)
	AddRelatedPropertyGeneratorsForManagedIdentity(generators)
	managedIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity{}), generators)

	return managedIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedIdentity_Type_None, ManagedIdentity_Type_SystemAssigned, ManagedIdentity_Type_SystemAssignedUserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_ManagedIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedIdentity_STATUS to ManagedIdentity_STATUS via AssignProperties_To_ManagedIdentity_STATUS & AssignProperties_From_ManagedIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedIdentity_STATUS, ManagedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedIdentity_STATUS tests if a specific instance of ManagedIdentity_STATUS can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForManagedIdentity_STATUS(subject ManagedIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ManagedIdentity_STATUS
	err := copied.AssignProperties_To_ManagedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedIdentity_STATUS
	err = actual.AssignProperties_From_ManagedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedIdentity_STATUS, ManagedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedIdentity_STATUS runs a test to see if a specific instance of ManagedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedIdentity_STATUS(subject ManagedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedIdentity_STATUS instances for property testing - lazily instantiated by
// ManagedIdentity_STATUSGenerator()
var managedIdentity_STATUSGenerator gopter.Gen

// ManagedIdentity_STATUSGenerator returns a generator of ManagedIdentity_STATUS instances for property testing.
// We first initialize managedIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedIdentity_STATUSGenerator() gopter.Gen {
	if managedIdentity_STATUSGenerator != nil {
		return managedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity_STATUS(generators)
	managedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedIdentity_STATUS(generators)
	managedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedIdentity_STATUS{}), generators)

	return managedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedIdentity_Type_STATUS_None, ManagedIdentity_Type_STATUS_SystemAssigned, ManagedIdentity_Type_STATUS_SystemAssignedUserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), UserAssignedManagedIdentity_STATUSGenerator())
}

func Test_ManagedVirtualNetworkSettings_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedVirtualNetworkSettings to ManagedVirtualNetworkSettings via AssignProperties_To_ManagedVirtualNetworkSettings & AssignProperties_From_ManagedVirtualNetworkSettings returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedVirtualNetworkSettings, ManagedVirtualNetworkSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedVirtualNetworkSettings tests if a specific instance of ManagedVirtualNetworkSettings can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForManagedVirtualNetworkSettings(subject ManagedVirtualNetworkSettings) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ManagedVirtualNetworkSettings
	err := copied.AssignProperties_To_ManagedVirtualNetworkSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedVirtualNetworkSettings
	err = actual.AssignProperties_From_ManagedVirtualNetworkSettings(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedVirtualNetworkSettings_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedVirtualNetworkSettings via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedVirtualNetworkSettings, ManagedVirtualNetworkSettingsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedVirtualNetworkSettings runs a test to see if a specific instance of ManagedVirtualNetworkSettings round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedVirtualNetworkSettings(subject ManagedVirtualNetworkSettings) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedVirtualNetworkSettings
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedVirtualNetworkSettings instances for property testing - lazily instantiated by
// ManagedVirtualNetworkSettingsGenerator()
var managedVirtualNetworkSettingsGenerator gopter.Gen

// ManagedVirtualNetworkSettingsGenerator returns a generator of ManagedVirtualNetworkSettings instances for property testing.
func ManagedVirtualNetworkSettingsGenerator() gopter.Gen {
	if managedVirtualNetworkSettingsGenerator != nil {
		return managedVirtualNetworkSettingsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedVirtualNetworkSettings(generators)
	managedVirtualNetworkSettingsGenerator = gen.Struct(reflect.TypeOf(ManagedVirtualNetworkSettings{}), generators)

	return managedVirtualNetworkSettingsGenerator
}

// AddIndependentPropertyGeneratorsForManagedVirtualNetworkSettings is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedVirtualNetworkSettings(gens map[string]gopter.Gen) {
	gens["AllowedAadTenantIdsForLinking"] = gen.SliceOf(gen.AlphaString())
	gens["LinkedAccessCheckOnTargetResource"] = gen.PtrOf(gen.Bool())
	gens["PreventDataExfiltration"] = gen.PtrOf(gen.Bool())
}

func Test_ManagedVirtualNetworkSettings_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedVirtualNetworkSettings_STATUS to ManagedVirtualNetworkSettings_STATUS via AssignProperties_To_ManagedVirtualNetworkSettings_STATUS & AssignProperties_From_ManagedVirtualNetworkSettings_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedVirtualNetworkSettings_STATUS, ManagedVirtualNetworkSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedVirtualNetworkSettings_STATUS tests if a specific instance of ManagedVirtualNetworkSettings_STATUS can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForManagedVirtualNetworkSettings_STATUS(subject ManagedVirtualNetworkSettings_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ManagedVirtualNetworkSettings_STATUS
	err := copied.AssignProperties_To_ManagedVirtualNetworkSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedVirtualNetworkSettings_STATUS
	err = actual.AssignProperties_From_ManagedVirtualNetworkSettings_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedVirtualNetworkSettings_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedVirtualNetworkSettings_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedVirtualNetworkSettings_STATUS, ManagedVirtualNetworkSettings_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedVirtualNetworkSettings_STATUS runs a test to see if a specific instance of ManagedVirtualNetworkSettings_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedVirtualNetworkSettings_STATUS(subject ManagedVirtualNetworkSettings_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedVirtualNetworkSettings_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedVirtualNetworkSettings_STATUS instances for property testing - lazily instantiated by
// ManagedVirtualNetworkSettings_STATUSGenerator()
var managedVirtualNetworkSettings_STATUSGenerator gopter.Gen

// ManagedVirtualNetworkSettings_STATUSGenerator returns a generator of ManagedVirtualNetworkSettings_STATUS instances for property testing.
func ManagedVirtualNetworkSettings_STATUSGenerator() gopter.Gen {
	if managedVirtualNetworkSettings_STATUSGenerator != nil {
		return managedVirtualNetworkSettings_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedVirtualNetworkSettings_STATUS(generators)
	managedVirtualNetworkSettings_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedVirtualNetworkSettings_STATUS{}), generators)

	return managedVirtualNetworkSettings_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedVirtualNetworkSettings_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedVirtualNetworkSettings_STATUS(gens map[string]gopter.Gen) {
	gens["AllowedAadTenantIdsForLinking"] = gen.SliceOf(gen.AlphaString())
	gens["LinkedAccessCheckOnTargetResource"] = gen.PtrOf(gen.Bool())
	gens["PreventDataExfiltration"] = gen.PtrOf(gen.Bool())
}

func Test_PrivateEndpointConnection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointConnection_STATUS to PrivateEndpointConnection_STATUS via AssignProperties_To_PrivateEndpointConnection_STATUS & AssignProperties_From_PrivateEndpointConnection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS, PrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS tests if a specific instance of PrivateEndpointConnection_STATUS can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS(subject PrivateEndpointConnection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.PrivateEndpointConnection_STATUS
	err := copied.AssignProperties_To_PrivateEndpointConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointConnection_STATUS
	err = actual.AssignProperties_From_PrivateEndpointConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_STATUS, PrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_STATUS runs a test to see if a specific instance of PrivateEndpointConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_STATUS(subject PrivateEndpointConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointConnection_STATUSGenerator()
var privateEndpointConnection_STATUSGenerator gopter.Gen

// PrivateEndpointConnection_STATUSGenerator returns a generator of PrivateEndpointConnection_STATUS instances for property testing.
func PrivateEndpointConnection_STATUSGenerator() gopter.Gen {
	if privateEndpointConnection_STATUSGenerator != nil {
		return privateEndpointConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(generators)
	privateEndpointConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS{}), generators)

	return privateEndpointConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_PurviewConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PurviewConfiguration to PurviewConfiguration via AssignProperties_To_PurviewConfiguration & AssignProperties_From_PurviewConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForPurviewConfiguration, PurviewConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPurviewConfiguration tests if a specific instance of PurviewConfiguration can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForPurviewConfiguration(subject PurviewConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.PurviewConfiguration
	err := copied.AssignProperties_To_PurviewConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PurviewConfiguration
	err = actual.AssignProperties_From_PurviewConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PurviewConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PurviewConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPurviewConfiguration, PurviewConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPurviewConfiguration runs a test to see if a specific instance of PurviewConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForPurviewConfiguration(subject PurviewConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PurviewConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PurviewConfiguration instances for property testing - lazily instantiated by
// PurviewConfigurationGenerator()
var purviewConfigurationGenerator gopter.Gen

// PurviewConfigurationGenerator returns a generator of PurviewConfiguration instances for property testing.
func PurviewConfigurationGenerator() gopter.Gen {
	if purviewConfigurationGenerator != nil {
		return purviewConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	purviewConfigurationGenerator = gen.Struct(reflect.TypeOf(PurviewConfiguration{}), generators)

	return purviewConfigurationGenerator
}

func Test_PurviewConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PurviewConfiguration_STATUS to PurviewConfiguration_STATUS via AssignProperties_To_PurviewConfiguration_STATUS & AssignProperties_From_PurviewConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPurviewConfiguration_STATUS, PurviewConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPurviewConfiguration_STATUS tests if a specific instance of PurviewConfiguration_STATUS can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForPurviewConfiguration_STATUS(subject PurviewConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.PurviewConfiguration_STATUS
	err := copied.AssignProperties_To_PurviewConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PurviewConfiguration_STATUS
	err = actual.AssignProperties_From_PurviewConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PurviewConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PurviewConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPurviewConfiguration_STATUS, PurviewConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPurviewConfiguration_STATUS runs a test to see if a specific instance of PurviewConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPurviewConfiguration_STATUS(subject PurviewConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PurviewConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PurviewConfiguration_STATUS instances for property testing - lazily instantiated by
// PurviewConfiguration_STATUSGenerator()
var purviewConfiguration_STATUSGenerator gopter.Gen

// PurviewConfiguration_STATUSGenerator returns a generator of PurviewConfiguration_STATUS instances for property testing.
func PurviewConfiguration_STATUSGenerator() gopter.Gen {
	if purviewConfiguration_STATUSGenerator != nil {
		return purviewConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPurviewConfiguration_STATUS(generators)
	purviewConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(PurviewConfiguration_STATUS{}), generators)

	return purviewConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPurviewConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPurviewConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["PurviewResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkProfile to VirtualNetworkProfile via AssignProperties_To_VirtualNetworkProfile & AssignProperties_From_VirtualNetworkProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkProfile, VirtualNetworkProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkProfile tests if a specific instance of VirtualNetworkProfile can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkProfile(subject VirtualNetworkProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.VirtualNetworkProfile
	err := copied.AssignProperties_To_VirtualNetworkProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkProfile
	err = actual.AssignProperties_From_VirtualNetworkProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkProfile, VirtualNetworkProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkProfile runs a test to see if a specific instance of VirtualNetworkProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkProfile(subject VirtualNetworkProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkProfile instances for property testing - lazily instantiated by
// VirtualNetworkProfileGenerator()
var virtualNetworkProfileGenerator gopter.Gen

// VirtualNetworkProfileGenerator returns a generator of VirtualNetworkProfile instances for property testing.
func VirtualNetworkProfileGenerator() gopter.Gen {
	if virtualNetworkProfileGenerator != nil {
		return virtualNetworkProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkProfile(generators)
	virtualNetworkProfileGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkProfile{}), generators)

	return virtualNetworkProfileGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkProfile(gens map[string]gopter.Gen) {
	gens["ComputeSubnetId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkProfile_STATUS to VirtualNetworkProfile_STATUS via AssignProperties_To_VirtualNetworkProfile_STATUS & AssignProperties_From_VirtualNetworkProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkProfile_STATUS, VirtualNetworkProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkProfile_STATUS tests if a specific instance of VirtualNetworkProfile_STATUS can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkProfile_STATUS(subject VirtualNetworkProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.VirtualNetworkProfile_STATUS
	err := copied.AssignProperties_To_VirtualNetworkProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkProfile_STATUS
	err = actual.AssignProperties_From_VirtualNetworkProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkProfile_STATUS, VirtualNetworkProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkProfile_STATUS runs a test to see if a specific instance of VirtualNetworkProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkProfile_STATUS(subject VirtualNetworkProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkProfile_STATUS instances for property testing - lazily instantiated by
// VirtualNetworkProfile_STATUSGenerator()
var virtualNetworkProfile_STATUSGenerator gopter.Gen

// VirtualNetworkProfile_STATUSGenerator returns a generator of VirtualNetworkProfile_STATUS instances for property testing.
func VirtualNetworkProfile_STATUSGenerator() gopter.Gen {
	if virtualNetworkProfile_STATUSGenerator != nil {
		return virtualNetworkProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkProfile_STATUS(generators)
	virtualNetworkProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkProfile_STATUS{}), generators)

	return virtualNetworkProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkProfile_STATUS(gens map[string]gopter.Gen) {
	gens["ComputeSubnetId"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceRepositoryConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceRepositoryConfiguration to WorkspaceRepositoryConfiguration via AssignProperties_To_WorkspaceRepositoryConfiguration & AssignProperties_From_WorkspaceRepositoryConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceRepositoryConfiguration, WorkspaceRepositoryConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceRepositoryConfiguration tests if a specific instance of WorkspaceRepositoryConfiguration can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceRepositoryConfiguration(subject WorkspaceRepositoryConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.WorkspaceRepositoryConfiguration
	err := copied.AssignProperties_To_WorkspaceRepositoryConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceRepositoryConfiguration
	err = actual.AssignProperties_From_WorkspaceRepositoryConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceRepositoryConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceRepositoryConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceRepositoryConfiguration, WorkspaceRepositoryConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceRepositoryConfiguration runs a test to see if a specific instance of WorkspaceRepositoryConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceRepositoryConfiguration(subject WorkspaceRepositoryConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceRepositoryConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceRepositoryConfiguration instances for property testing - lazily instantiated by
// WorkspaceRepositoryConfigurationGenerator()
var workspaceRepositoryConfigurationGenerator gopter.Gen

// WorkspaceRepositoryConfigurationGenerator returns a generator of WorkspaceRepositoryConfiguration instances for property testing.
func WorkspaceRepositoryConfigurationGenerator() gopter.Gen {
	if workspaceRepositoryConfigurationGenerator != nil {
		return workspaceRepositoryConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceRepositoryConfiguration(generators)
	workspaceRepositoryConfigurationGenerator = gen.Struct(reflect.TypeOf(WorkspaceRepositoryConfiguration{}), generators)

	return workspaceRepositoryConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceRepositoryConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceRepositoryConfiguration(gens map[string]gopter.Gen) {
	gens["AccountName"] = gen.PtrOf(gen.AlphaString())
	gens["CollaborationBranch"] = gen.PtrOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["LastCommitId"] = gen.PtrOf(gen.AlphaString())
	gens["ProjectName"] = gen.PtrOf(gen.AlphaString())
	gens["RepositoryName"] = gen.PtrOf(gen.AlphaString())
	gens["RootFolder"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceRepositoryConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceRepositoryConfiguration_STATUS to WorkspaceRepositoryConfiguration_STATUS via AssignProperties_To_WorkspaceRepositoryConfiguration_STATUS & AssignProperties_From_WorkspaceRepositoryConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceRepositoryConfiguration_STATUS, WorkspaceRepositoryConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceRepositoryConfiguration_STATUS tests if a specific instance of WorkspaceRepositoryConfiguration_STATUS can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceRepositoryConfiguration_STATUS(subject WorkspaceRepositoryConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.WorkspaceRepositoryConfiguration_STATUS
	err := copied.AssignProperties_To_WorkspaceRepositoryConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceRepositoryConfiguration_STATUS
	err = actual.AssignProperties_From_WorkspaceRepositoryConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceRepositoryConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceRepositoryConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceRepositoryConfiguration_STATUS, WorkspaceRepositoryConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceRepositoryConfiguration_STATUS runs a test to see if a specific instance of WorkspaceRepositoryConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceRepositoryConfiguration_STATUS(subject WorkspaceRepositoryConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceRepositoryConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceRepositoryConfiguration_STATUS instances for property testing - lazily instantiated by
// WorkspaceRepositoryConfiguration_STATUSGenerator()
var workspaceRepositoryConfiguration_STATUSGenerator gopter.Gen

// WorkspaceRepositoryConfiguration_STATUSGenerator returns a generator of WorkspaceRepositoryConfiguration_STATUS instances for property testing.
func WorkspaceRepositoryConfiguration_STATUSGenerator() gopter.Gen {
	if workspaceRepositoryConfiguration_STATUSGenerator != nil {
		return workspaceRepositoryConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceRepositoryConfiguration_STATUS(generators)
	workspaceRepositoryConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(WorkspaceRepositoryConfiguration_STATUS{}), generators)

	return workspaceRepositoryConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceRepositoryConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceRepositoryConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["AccountName"] = gen.PtrOf(gen.AlphaString())
	gens["CollaborationBranch"] = gen.PtrOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["LastCommitId"] = gen.PtrOf(gen.AlphaString())
	gens["ProjectName"] = gen.PtrOf(gen.AlphaString())
	gens["RepositoryName"] = gen.PtrOf(gen.AlphaString())
	gens["RootFolder"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_CustomerManagedKeyDetails_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomerManagedKeyDetails to CustomerManagedKeyDetails via AssignProperties_To_CustomerManagedKeyDetails & AssignProperties_From_CustomerManagedKeyDetails returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomerManagedKeyDetails, CustomerManagedKeyDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomerManagedKeyDetails tests if a specific instance of CustomerManagedKeyDetails can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForCustomerManagedKeyDetails(subject CustomerManagedKeyDetails) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CustomerManagedKeyDetails
	err := copied.AssignProperties_To_CustomerManagedKeyDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomerManagedKeyDetails
	err = actual.AssignProperties_From_CustomerManagedKeyDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomerManagedKeyDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomerManagedKeyDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomerManagedKeyDetails, CustomerManagedKeyDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomerManagedKeyDetails runs a test to see if a specific instance of CustomerManagedKeyDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomerManagedKeyDetails(subject CustomerManagedKeyDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomerManagedKeyDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomerManagedKeyDetails instances for property testing - lazily instantiated by
// CustomerManagedKeyDetailsGenerator()
var customerManagedKeyDetailsGenerator gopter.Gen

// CustomerManagedKeyDetailsGenerator returns a generator of CustomerManagedKeyDetails instances for property testing.
func CustomerManagedKeyDetailsGenerator() gopter.Gen {
	if customerManagedKeyDetailsGenerator != nil {
		return customerManagedKeyDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForCustomerManagedKeyDetails(generators)
	customerManagedKeyDetailsGenerator = gen.Struct(reflect.TypeOf(CustomerManagedKeyDetails{}), generators)

	return customerManagedKeyDetailsGenerator
}

// AddRelatedPropertyGeneratorsForCustomerManagedKeyDetails is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomerManagedKeyDetails(gens map[string]gopter.Gen) {
	gens["KekIdentity"] = gen.PtrOf(KekIdentityPropertiesGenerator())
	gens["Key"] = gen.PtrOf(WorkspaceKeyDetailsGenerator())
}

func Test_CustomerManagedKeyDetails_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomerManagedKeyDetails_STATUS to CustomerManagedKeyDetails_STATUS via AssignProperties_To_CustomerManagedKeyDetails_STATUS & AssignProperties_From_CustomerManagedKeyDetails_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomerManagedKeyDetails_STATUS, CustomerManagedKeyDetails_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomerManagedKeyDetails_STATUS tests if a specific instance of CustomerManagedKeyDetails_STATUS can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForCustomerManagedKeyDetails_STATUS(subject CustomerManagedKeyDetails_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CustomerManagedKeyDetails_STATUS
	err := copied.AssignProperties_To_CustomerManagedKeyDetails_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomerManagedKeyDetails_STATUS
	err = actual.AssignProperties_From_CustomerManagedKeyDetails_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomerManagedKeyDetails_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomerManagedKeyDetails_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomerManagedKeyDetails_STATUS, CustomerManagedKeyDetails_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomerManagedKeyDetails_STATUS runs a test to see if a specific instance of CustomerManagedKeyDetails_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomerManagedKeyDetails_STATUS(subject CustomerManagedKeyDetails_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomerManagedKeyDetails_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomerManagedKeyDetails_STATUS instances for property testing - lazily instantiated by
// CustomerManagedKeyDetails_STATUSGenerator()
var customerManagedKeyDetails_STATUSGenerator gopter.Gen

// CustomerManagedKeyDetails_STATUSGenerator returns a generator of CustomerManagedKeyDetails_STATUS instances for property testing.
// We first initialize customerManagedKeyDetails_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomerManagedKeyDetails_STATUSGenerator() gopter.Gen {
	if customerManagedKeyDetails_STATUSGenerator != nil {
		return customerManagedKeyDetails_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomerManagedKeyDetails_STATUS(generators)
	customerManagedKeyDetails_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomerManagedKeyDetails_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomerManagedKeyDetails_STATUS(generators)
	AddRelatedPropertyGeneratorsForCustomerManagedKeyDetails_STATUS(generators)
	customerManagedKeyDetails_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomerManagedKeyDetails_STATUS{}), generators)

	return customerManagedKeyDetails_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCustomerManagedKeyDetails_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomerManagedKeyDetails_STATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCustomerManagedKeyDetails_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomerManagedKeyDetails_STATUS(gens map[string]gopter.Gen) {
	gens["KekIdentity"] = gen.PtrOf(KekIdentityProperties_STATUSGenerator())
	gens["Key"] = gen.PtrOf(WorkspaceKeyDetails_STATUSGenerator())
}

func Test_UserAssignedIdentityDetails_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentityDetails to UserAssignedIdentityDetails via AssignProperties_To_UserAssignedIdentityDetails & AssignProperties_From_UserAssignedIdentityDetails returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentityDetails tests if a specific instance of UserAssignedIdentityDetails can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UserAssignedIdentityDetails
	err := copied.AssignProperties_To_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentityDetails
	err = actual.AssignProperties_From_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_UserAssignedManagedIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedManagedIdentity_STATUS to UserAssignedManagedIdentity_STATUS via AssignProperties_To_UserAssignedManagedIdentity_STATUS & AssignProperties_From_UserAssignedManagedIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedManagedIdentity_STATUS, UserAssignedManagedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedManagedIdentity_STATUS tests if a specific instance of UserAssignedManagedIdentity_STATUS can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedManagedIdentity_STATUS(subject UserAssignedManagedIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UserAssignedManagedIdentity_STATUS
	err := copied.AssignProperties_To_UserAssignedManagedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedManagedIdentity_STATUS
	err = actual.AssignProperties_From_UserAssignedManagedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedManagedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedManagedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedManagedIdentity_STATUS, UserAssignedManagedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedManagedIdentity_STATUS runs a test to see if a specific instance of UserAssignedManagedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedManagedIdentity_STATUS(subject UserAssignedManagedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedManagedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedManagedIdentity_STATUS instances for property testing - lazily instantiated by
// UserAssignedManagedIdentity_STATUSGenerator()
var userAssignedManagedIdentity_STATUSGenerator gopter.Gen

// UserAssignedManagedIdentity_STATUSGenerator returns a generator of UserAssignedManagedIdentity_STATUS instances for property testing.
func UserAssignedManagedIdentity_STATUSGenerator() gopter.Gen {
	if userAssignedManagedIdentity_STATUSGenerator != nil {
		return userAssignedManagedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedManagedIdentity_STATUS(generators)
	userAssignedManagedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedManagedIdentity_STATUS{}), generators)

	return userAssignedManagedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedManagedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedManagedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_KekIdentityProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KekIdentityProperties to KekIdentityProperties via AssignProperties_To_KekIdentityProperties & AssignProperties_From_KekIdentityProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForKekIdentityProperties, KekIdentityPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKekIdentityProperties tests if a specific instance of KekIdentityProperties can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForKekIdentityProperties(subject KekIdentityProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.KekIdentityProperties
	err := copied.AssignProperties_To_KekIdentityProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KekIdentityProperties
	err = actual.AssignProperties_From_KekIdentityProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KekIdentityProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KekIdentityProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKekIdentityProperties, KekIdentityPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKekIdentityProperties runs a test to see if a specific instance of KekIdentityProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForKekIdentityProperties(subject KekIdentityProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KekIdentityProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KekIdentityProperties instances for property testing - lazily instantiated by
// KekIdentityPropertiesGenerator()
var kekIdentityPropertiesGenerator gopter.Gen

// KekIdentityPropertiesGenerator returns a generator of KekIdentityProperties instances for property testing.
func KekIdentityPropertiesGenerator() gopter.Gen {
	if kekIdentityPropertiesGenerator != nil {
		return kekIdentityPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	kekIdentityPropertiesGenerator = gen.Struct(reflect.TypeOf(KekIdentityProperties{}), generators)

	return kekIdentityPropertiesGenerator
}

func Test_KekIdentityProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KekIdentityProperties_STATUS to KekIdentityProperties_STATUS via AssignProperties_To_KekIdentityProperties_STATUS & AssignProperties_From_KekIdentityProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKekIdentityProperties_STATUS, KekIdentityProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKekIdentityProperties_STATUS tests if a specific instance of KekIdentityProperties_STATUS can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForKekIdentityProperties_STATUS(subject KekIdentityProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.KekIdentityProperties_STATUS
	err := copied.AssignProperties_To_KekIdentityProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KekIdentityProperties_STATUS
	err = actual.AssignProperties_From_KekIdentityProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KekIdentityProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KekIdentityProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKekIdentityProperties_STATUS, KekIdentityProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKekIdentityProperties_STATUS runs a test to see if a specific instance of KekIdentityProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKekIdentityProperties_STATUS(subject KekIdentityProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KekIdentityProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KekIdentityProperties_STATUS instances for property testing - lazily instantiated by
// KekIdentityProperties_STATUSGenerator()
var kekIdentityProperties_STATUSGenerator gopter.Gen

// KekIdentityProperties_STATUSGenerator returns a generator of KekIdentityProperties_STATUS instances for property testing.
func KekIdentityProperties_STATUSGenerator() gopter.Gen {
	if kekIdentityProperties_STATUSGenerator != nil {
		return kekIdentityProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKekIdentityProperties_STATUS(generators)
	kekIdentityProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(KekIdentityProperties_STATUS{}), generators)

	return kekIdentityProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKekIdentityProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKekIdentityProperties_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceKeyDetails_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceKeyDetails to WorkspaceKeyDetails via AssignProperties_To_WorkspaceKeyDetails & AssignProperties_From_WorkspaceKeyDetails returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceKeyDetails, WorkspaceKeyDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceKeyDetails tests if a specific instance of WorkspaceKeyDetails can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceKeyDetails(subject WorkspaceKeyDetails) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.WorkspaceKeyDetails
	err := copied.AssignProperties_To_WorkspaceKeyDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceKeyDetails
	err = actual.AssignProperties_From_WorkspaceKeyDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceKeyDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceKeyDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceKeyDetails, WorkspaceKeyDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceKeyDetails runs a test to see if a specific instance of WorkspaceKeyDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceKeyDetails(subject WorkspaceKeyDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceKeyDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceKeyDetails instances for property testing - lazily instantiated by
// WorkspaceKeyDetailsGenerator()
var workspaceKeyDetailsGenerator gopter.Gen

// WorkspaceKeyDetailsGenerator returns a generator of WorkspaceKeyDetails instances for property testing.
func WorkspaceKeyDetailsGenerator() gopter.Gen {
	if workspaceKeyDetailsGenerator != nil {
		return workspaceKeyDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceKeyDetails(generators)
	workspaceKeyDetailsGenerator = gen.Struct(reflect.TypeOf(WorkspaceKeyDetails{}), generators)

	return workspaceKeyDetailsGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceKeyDetails is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceKeyDetails(gens map[string]gopter.Gen) {
	gens["KeyVaultUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkspaceKeyDetails_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkspaceKeyDetails_STATUS to WorkspaceKeyDetails_STATUS via AssignProperties_To_WorkspaceKeyDetails_STATUS & AssignProperties_From_WorkspaceKeyDetails_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkspaceKeyDetails_STATUS, WorkspaceKeyDetails_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkspaceKeyDetails_STATUS tests if a specific instance of WorkspaceKeyDetails_STATUS can be assigned to v1api20210601storage and back losslessly
func RunPropertyAssignmentTestForWorkspaceKeyDetails_STATUS(subject WorkspaceKeyDetails_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.WorkspaceKeyDetails_STATUS
	err := copied.AssignProperties_To_WorkspaceKeyDetails_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkspaceKeyDetails_STATUS
	err = actual.AssignProperties_From_WorkspaceKeyDetails_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkspaceKeyDetails_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkspaceKeyDetails_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkspaceKeyDetails_STATUS, WorkspaceKeyDetails_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkspaceKeyDetails_STATUS runs a test to see if a specific instance of WorkspaceKeyDetails_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkspaceKeyDetails_STATUS(subject WorkspaceKeyDetails_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkspaceKeyDetails_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkspaceKeyDetails_STATUS instances for property testing - lazily instantiated by
// WorkspaceKeyDetails_STATUSGenerator()
var workspaceKeyDetails_STATUSGenerator gopter.Gen

// WorkspaceKeyDetails_STATUSGenerator returns a generator of WorkspaceKeyDetails_STATUS instances for property testing.
func WorkspaceKeyDetails_STATUSGenerator() gopter.Gen {
	if workspaceKeyDetails_STATUSGenerator != nil {
		return workspaceKeyDetails_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkspaceKeyDetails_STATUS(generators)
	workspaceKeyDetails_STATUSGenerator = gen.Struct(reflect.TypeOf(WorkspaceKeyDetails_STATUS{}), generators)

	return workspaceKeyDetails_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkspaceKeyDetails_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkspaceKeyDetails_STATUS(gens map[string]gopter.Gen) {
	gens["KeyVaultUrl"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}
