// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20231122

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/redhatopenshift/v1api20231122/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_APIServerProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from APIServerProfile to APIServerProfile via AssignProperties_To_APIServerProfile & AssignProperties_From_APIServerProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForAPIServerProfile, APIServerProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAPIServerProfile tests if a specific instance of APIServerProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAPIServerProfile(subject APIServerProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.APIServerProfile
	err := copied.AssignProperties_To_APIServerProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual APIServerProfile
	err = actual.AssignProperties_From_APIServerProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_APIServerProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of APIServerProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAPIServerProfile, APIServerProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAPIServerProfile runs a test to see if a specific instance of APIServerProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForAPIServerProfile(subject APIServerProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual APIServerProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of APIServerProfile instances for property testing - lazily instantiated by APIServerProfileGenerator()
var apiServerProfileGenerator gopter.Gen

// APIServerProfileGenerator returns a generator of APIServerProfile instances for property testing.
func APIServerProfileGenerator() gopter.Gen {
	if apiServerProfileGenerator != nil {
		return apiServerProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAPIServerProfile(generators)
	apiServerProfileGenerator = gen.Struct(reflect.TypeOf(APIServerProfile{}), generators)

	return apiServerProfileGenerator
}

// AddIndependentPropertyGeneratorsForAPIServerProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAPIServerProfile(gens map[string]gopter.Gen) {
	gens["Visibility"] = gen.PtrOf(gen.OneConstOf(Visibility_Private, Visibility_Public))
}

func Test_APIServerProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from APIServerProfile_STATUS to APIServerProfile_STATUS via AssignProperties_To_APIServerProfile_STATUS & AssignProperties_From_APIServerProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForAPIServerProfile_STATUS, APIServerProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAPIServerProfile_STATUS tests if a specific instance of APIServerProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForAPIServerProfile_STATUS(subject APIServerProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.APIServerProfile_STATUS
	err := copied.AssignProperties_To_APIServerProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual APIServerProfile_STATUS
	err = actual.AssignProperties_From_APIServerProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_APIServerProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of APIServerProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAPIServerProfile_STATUS, APIServerProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAPIServerProfile_STATUS runs a test to see if a specific instance of APIServerProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAPIServerProfile_STATUS(subject APIServerProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual APIServerProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of APIServerProfile_STATUS instances for property testing - lazily instantiated by
// APIServerProfile_STATUSGenerator()
var apiServerProfile_STATUSGenerator gopter.Gen

// APIServerProfile_STATUSGenerator returns a generator of APIServerProfile_STATUS instances for property testing.
func APIServerProfile_STATUSGenerator() gopter.Gen {
	if apiServerProfile_STATUSGenerator != nil {
		return apiServerProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAPIServerProfile_STATUS(generators)
	apiServerProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(APIServerProfile_STATUS{}), generators)

	return apiServerProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAPIServerProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAPIServerProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Ip"] = gen.PtrOf(gen.AlphaString())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
	gens["Visibility"] = gen.PtrOf(gen.OneConstOf(Visibility_STATUS_Private, Visibility_STATUS_Public))
}

func Test_ClusterProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ClusterProfile to ClusterProfile via AssignProperties_To_ClusterProfile & AssignProperties_From_ClusterProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForClusterProfile, ClusterProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForClusterProfile tests if a specific instance of ClusterProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForClusterProfile(subject ClusterProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ClusterProfile
	err := copied.AssignProperties_To_ClusterProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ClusterProfile
	err = actual.AssignProperties_From_ClusterProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ClusterProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClusterProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClusterProfile, ClusterProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClusterProfile runs a test to see if a specific instance of ClusterProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForClusterProfile(subject ClusterProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClusterProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClusterProfile instances for property testing - lazily instantiated by ClusterProfileGenerator()
var clusterProfileGenerator gopter.Gen

// ClusterProfileGenerator returns a generator of ClusterProfile instances for property testing.
func ClusterProfileGenerator() gopter.Gen {
	if clusterProfileGenerator != nil {
		return clusterProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClusterProfile(generators)
	clusterProfileGenerator = gen.Struct(reflect.TypeOf(ClusterProfile{}), generators)

	return clusterProfileGenerator
}

// AddIndependentPropertyGeneratorsForClusterProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClusterProfile(gens map[string]gopter.Gen) {
	gens["Domain"] = gen.PtrOf(gen.AlphaString())
	gens["FipsValidatedModules"] = gen.PtrOf(gen.OneConstOf(FipsValidatedModules_Disabled, FipsValidatedModules_Enabled))
	gens["ResourceGroupId"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_ClusterProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ClusterProfile_STATUS to ClusterProfile_STATUS via AssignProperties_To_ClusterProfile_STATUS & AssignProperties_From_ClusterProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForClusterProfile_STATUS, ClusterProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForClusterProfile_STATUS tests if a specific instance of ClusterProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForClusterProfile_STATUS(subject ClusterProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ClusterProfile_STATUS
	err := copied.AssignProperties_To_ClusterProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ClusterProfile_STATUS
	err = actual.AssignProperties_From_ClusterProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ClusterProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClusterProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClusterProfile_STATUS, ClusterProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClusterProfile_STATUS runs a test to see if a specific instance of ClusterProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForClusterProfile_STATUS(subject ClusterProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClusterProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClusterProfile_STATUS instances for property testing - lazily instantiated by
// ClusterProfile_STATUSGenerator()
var clusterProfile_STATUSGenerator gopter.Gen

// ClusterProfile_STATUSGenerator returns a generator of ClusterProfile_STATUS instances for property testing.
func ClusterProfile_STATUSGenerator() gopter.Gen {
	if clusterProfile_STATUSGenerator != nil {
		return clusterProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClusterProfile_STATUS(generators)
	clusterProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(ClusterProfile_STATUS{}), generators)

	return clusterProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForClusterProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClusterProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Domain"] = gen.PtrOf(gen.AlphaString())
	gens["FipsValidatedModules"] = gen.PtrOf(gen.OneConstOf(FipsValidatedModules_STATUS_Disabled, FipsValidatedModules_STATUS_Enabled))
	gens["ResourceGroupId"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_ConsoleProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConsoleProfile_STATUS to ConsoleProfile_STATUS via AssignProperties_To_ConsoleProfile_STATUS & AssignProperties_From_ConsoleProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForConsoleProfile_STATUS, ConsoleProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConsoleProfile_STATUS tests if a specific instance of ConsoleProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForConsoleProfile_STATUS(subject ConsoleProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ConsoleProfile_STATUS
	err := copied.AssignProperties_To_ConsoleProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConsoleProfile_STATUS
	err = actual.AssignProperties_From_ConsoleProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConsoleProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsoleProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsoleProfile_STATUS, ConsoleProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsoleProfile_STATUS runs a test to see if a specific instance of ConsoleProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForConsoleProfile_STATUS(subject ConsoleProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsoleProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsoleProfile_STATUS instances for property testing - lazily instantiated by
// ConsoleProfile_STATUSGenerator()
var consoleProfile_STATUSGenerator gopter.Gen

// ConsoleProfile_STATUSGenerator returns a generator of ConsoleProfile_STATUS instances for property testing.
func ConsoleProfile_STATUSGenerator() gopter.Gen {
	if consoleProfile_STATUSGenerator != nil {
		return consoleProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsoleProfile_STATUS(generators)
	consoleProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(ConsoleProfile_STATUS{}), generators)

	return consoleProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForConsoleProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsoleProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_EffectiveOutboundIP_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EffectiveOutboundIP_STATUS to EffectiveOutboundIP_STATUS via AssignProperties_To_EffectiveOutboundIP_STATUS & AssignProperties_From_EffectiveOutboundIP_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEffectiveOutboundIP_STATUS, EffectiveOutboundIP_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEffectiveOutboundIP_STATUS tests if a specific instance of EffectiveOutboundIP_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEffectiveOutboundIP_STATUS(subject EffectiveOutboundIP_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EffectiveOutboundIP_STATUS
	err := copied.AssignProperties_To_EffectiveOutboundIP_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EffectiveOutboundIP_STATUS
	err = actual.AssignProperties_From_EffectiveOutboundIP_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EffectiveOutboundIP_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EffectiveOutboundIP_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEffectiveOutboundIP_STATUS, EffectiveOutboundIP_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEffectiveOutboundIP_STATUS runs a test to see if a specific instance of EffectiveOutboundIP_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEffectiveOutboundIP_STATUS(subject EffectiveOutboundIP_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EffectiveOutboundIP_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EffectiveOutboundIP_STATUS instances for property testing - lazily instantiated by
// EffectiveOutboundIP_STATUSGenerator()
var effectiveOutboundIP_STATUSGenerator gopter.Gen

// EffectiveOutboundIP_STATUSGenerator returns a generator of EffectiveOutboundIP_STATUS instances for property testing.
func EffectiveOutboundIP_STATUSGenerator() gopter.Gen {
	if effectiveOutboundIP_STATUSGenerator != nil {
		return effectiveOutboundIP_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEffectiveOutboundIP_STATUS(generators)
	effectiveOutboundIP_STATUSGenerator = gen.Struct(reflect.TypeOf(EffectiveOutboundIP_STATUS{}), generators)

	return effectiveOutboundIP_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEffectiveOutboundIP_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEffectiveOutboundIP_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_IngressProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IngressProfile to IngressProfile via AssignProperties_To_IngressProfile & AssignProperties_From_IngressProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForIngressProfile, IngressProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIngressProfile tests if a specific instance of IngressProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIngressProfile(subject IngressProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IngressProfile
	err := copied.AssignProperties_To_IngressProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IngressProfile
	err = actual.AssignProperties_From_IngressProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IngressProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IngressProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIngressProfile, IngressProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIngressProfile runs a test to see if a specific instance of IngressProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForIngressProfile(subject IngressProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IngressProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IngressProfile instances for property testing - lazily instantiated by IngressProfileGenerator()
var ingressProfileGenerator gopter.Gen

// IngressProfileGenerator returns a generator of IngressProfile instances for property testing.
func IngressProfileGenerator() gopter.Gen {
	if ingressProfileGenerator != nil {
		return ingressProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngressProfile(generators)
	ingressProfileGenerator = gen.Struct(reflect.TypeOf(IngressProfile{}), generators)

	return ingressProfileGenerator
}

// AddIndependentPropertyGeneratorsForIngressProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIngressProfile(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Visibility"] = gen.PtrOf(gen.OneConstOf(Visibility_Private, Visibility_Public))
}

func Test_IngressProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IngressProfile_STATUS to IngressProfile_STATUS via AssignProperties_To_IngressProfile_STATUS & AssignProperties_From_IngressProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIngressProfile_STATUS, IngressProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIngressProfile_STATUS tests if a specific instance of IngressProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForIngressProfile_STATUS(subject IngressProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.IngressProfile_STATUS
	err := copied.AssignProperties_To_IngressProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IngressProfile_STATUS
	err = actual.AssignProperties_From_IngressProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IngressProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IngressProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIngressProfile_STATUS, IngressProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIngressProfile_STATUS runs a test to see if a specific instance of IngressProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIngressProfile_STATUS(subject IngressProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IngressProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IngressProfile_STATUS instances for property testing - lazily instantiated by
// IngressProfile_STATUSGenerator()
var ingressProfile_STATUSGenerator gopter.Gen

// IngressProfile_STATUSGenerator returns a generator of IngressProfile_STATUS instances for property testing.
func IngressProfile_STATUSGenerator() gopter.Gen {
	if ingressProfile_STATUSGenerator != nil {
		return ingressProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngressProfile_STATUS(generators)
	ingressProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(IngressProfile_STATUS{}), generators)

	return ingressProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIngressProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIngressProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Ip"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Visibility"] = gen.PtrOf(gen.OneConstOf(Visibility_STATUS_Private, Visibility_STATUS_Public))
}

func Test_LoadBalancerProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancerProfile to LoadBalancerProfile via AssignProperties_To_LoadBalancerProfile & AssignProperties_From_LoadBalancerProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancerProfile, LoadBalancerProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancerProfile tests if a specific instance of LoadBalancerProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancerProfile(subject LoadBalancerProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.LoadBalancerProfile
	err := copied.AssignProperties_To_LoadBalancerProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancerProfile
	err = actual.AssignProperties_From_LoadBalancerProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancerProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerProfile, LoadBalancerProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerProfile runs a test to see if a specific instance of LoadBalancerProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerProfile(subject LoadBalancerProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerProfile instances for property testing - lazily instantiated by
// LoadBalancerProfileGenerator()
var loadBalancerProfileGenerator gopter.Gen

// LoadBalancerProfileGenerator returns a generator of LoadBalancerProfile instances for property testing.
func LoadBalancerProfileGenerator() gopter.Gen {
	if loadBalancerProfileGenerator != nil {
		return loadBalancerProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLoadBalancerProfile(generators)
	loadBalancerProfileGenerator = gen.Struct(reflect.TypeOf(LoadBalancerProfile{}), generators)

	return loadBalancerProfileGenerator
}

// AddRelatedPropertyGeneratorsForLoadBalancerProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerProfile(gens map[string]gopter.Gen) {
	gens["ManagedOutboundIps"] = gen.PtrOf(ManagedOutboundIPsGenerator())
}

func Test_LoadBalancerProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from LoadBalancerProfile_STATUS to LoadBalancerProfile_STATUS via AssignProperties_To_LoadBalancerProfile_STATUS & AssignProperties_From_LoadBalancerProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForLoadBalancerProfile_STATUS, LoadBalancerProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLoadBalancerProfile_STATUS tests if a specific instance of LoadBalancerProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForLoadBalancerProfile_STATUS(subject LoadBalancerProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.LoadBalancerProfile_STATUS
	err := copied.AssignProperties_To_LoadBalancerProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual LoadBalancerProfile_STATUS
	err = actual.AssignProperties_From_LoadBalancerProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_LoadBalancerProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerProfile_STATUS, LoadBalancerProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerProfile_STATUS runs a test to see if a specific instance of LoadBalancerProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerProfile_STATUS(subject LoadBalancerProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerProfile_STATUS instances for property testing - lazily instantiated by
// LoadBalancerProfile_STATUSGenerator()
var loadBalancerProfile_STATUSGenerator gopter.Gen

// LoadBalancerProfile_STATUSGenerator returns a generator of LoadBalancerProfile_STATUS instances for property testing.
func LoadBalancerProfile_STATUSGenerator() gopter.Gen {
	if loadBalancerProfile_STATUSGenerator != nil {
		return loadBalancerProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLoadBalancerProfile_STATUS(generators)
	loadBalancerProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(LoadBalancerProfile_STATUS{}), generators)

	return loadBalancerProfile_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForLoadBalancerProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerProfile_STATUS(gens map[string]gopter.Gen) {
	gens["EffectiveOutboundIps"] = gen.SliceOf(EffectiveOutboundIP_STATUSGenerator())
	gens["ManagedOutboundIps"] = gen.PtrOf(ManagedOutboundIPs_STATUSGenerator())
}

func Test_ManagedOutboundIPs_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedOutboundIPs to ManagedOutboundIPs via AssignProperties_To_ManagedOutboundIPs & AssignProperties_From_ManagedOutboundIPs returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedOutboundIPs, ManagedOutboundIPsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedOutboundIPs tests if a specific instance of ManagedOutboundIPs can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedOutboundIPs(subject ManagedOutboundIPs) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedOutboundIPs
	err := copied.AssignProperties_To_ManagedOutboundIPs(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedOutboundIPs
	err = actual.AssignProperties_From_ManagedOutboundIPs(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedOutboundIPs_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedOutboundIPs via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedOutboundIPs, ManagedOutboundIPsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedOutboundIPs runs a test to see if a specific instance of ManagedOutboundIPs round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedOutboundIPs(subject ManagedOutboundIPs) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedOutboundIPs
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedOutboundIPs instances for property testing - lazily instantiated by ManagedOutboundIPsGenerator()
var managedOutboundIPsGenerator gopter.Gen

// ManagedOutboundIPsGenerator returns a generator of ManagedOutboundIPs instances for property testing.
func ManagedOutboundIPsGenerator() gopter.Gen {
	if managedOutboundIPsGenerator != nil {
		return managedOutboundIPsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedOutboundIPs(generators)
	managedOutboundIPsGenerator = gen.Struct(reflect.TypeOf(ManagedOutboundIPs{}), generators)

	return managedOutboundIPsGenerator
}

// AddIndependentPropertyGeneratorsForManagedOutboundIPs is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedOutboundIPs(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
}

func Test_ManagedOutboundIPs_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedOutboundIPs_STATUS to ManagedOutboundIPs_STATUS via AssignProperties_To_ManagedOutboundIPs_STATUS & AssignProperties_From_ManagedOutboundIPs_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedOutboundIPs_STATUS, ManagedOutboundIPs_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedOutboundIPs_STATUS tests if a specific instance of ManagedOutboundIPs_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedOutboundIPs_STATUS(subject ManagedOutboundIPs_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedOutboundIPs_STATUS
	err := copied.AssignProperties_To_ManagedOutboundIPs_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedOutboundIPs_STATUS
	err = actual.AssignProperties_From_ManagedOutboundIPs_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedOutboundIPs_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedOutboundIPs_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedOutboundIPs_STATUS, ManagedOutboundIPs_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedOutboundIPs_STATUS runs a test to see if a specific instance of ManagedOutboundIPs_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedOutboundIPs_STATUS(subject ManagedOutboundIPs_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedOutboundIPs_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedOutboundIPs_STATUS instances for property testing - lazily instantiated by
// ManagedOutboundIPs_STATUSGenerator()
var managedOutboundIPs_STATUSGenerator gopter.Gen

// ManagedOutboundIPs_STATUSGenerator returns a generator of ManagedOutboundIPs_STATUS instances for property testing.
func ManagedOutboundIPs_STATUSGenerator() gopter.Gen {
	if managedOutboundIPs_STATUSGenerator != nil {
		return managedOutboundIPs_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedOutboundIPs_STATUS(generators)
	managedOutboundIPs_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedOutboundIPs_STATUS{}), generators)

	return managedOutboundIPs_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedOutboundIPs_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedOutboundIPs_STATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
}

func Test_MasterProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MasterProfile to MasterProfile via AssignProperties_To_MasterProfile & AssignProperties_From_MasterProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForMasterProfile, MasterProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMasterProfile tests if a specific instance of MasterProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMasterProfile(subject MasterProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MasterProfile
	err := copied.AssignProperties_To_MasterProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MasterProfile
	err = actual.AssignProperties_From_MasterProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MasterProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MasterProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMasterProfile, MasterProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMasterProfile runs a test to see if a specific instance of MasterProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForMasterProfile(subject MasterProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MasterProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MasterProfile instances for property testing - lazily instantiated by MasterProfileGenerator()
var masterProfileGenerator gopter.Gen

// MasterProfileGenerator returns a generator of MasterProfile instances for property testing.
func MasterProfileGenerator() gopter.Gen {
	if masterProfileGenerator != nil {
		return masterProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMasterProfile(generators)
	masterProfileGenerator = gen.Struct(reflect.TypeOf(MasterProfile{}), generators)

	return masterProfileGenerator
}

// AddIndependentPropertyGeneratorsForMasterProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMasterProfile(gens map[string]gopter.Gen) {
	gens["EncryptionAtHost"] = gen.PtrOf(gen.OneConstOf(EncryptionAtHost_Disabled, EncryptionAtHost_Enabled))
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

func Test_MasterProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MasterProfile_STATUS to MasterProfile_STATUS via AssignProperties_To_MasterProfile_STATUS & AssignProperties_From_MasterProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForMasterProfile_STATUS, MasterProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMasterProfile_STATUS tests if a specific instance of MasterProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForMasterProfile_STATUS(subject MasterProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.MasterProfile_STATUS
	err := copied.AssignProperties_To_MasterProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MasterProfile_STATUS
	err = actual.AssignProperties_From_MasterProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MasterProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MasterProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMasterProfile_STATUS, MasterProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMasterProfile_STATUS runs a test to see if a specific instance of MasterProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMasterProfile_STATUS(subject MasterProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MasterProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MasterProfile_STATUS instances for property testing - lazily instantiated by
// MasterProfile_STATUSGenerator()
var masterProfile_STATUSGenerator gopter.Gen

// MasterProfile_STATUSGenerator returns a generator of MasterProfile_STATUS instances for property testing.
func MasterProfile_STATUSGenerator() gopter.Gen {
	if masterProfile_STATUSGenerator != nil {
		return masterProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMasterProfile_STATUS(generators)
	masterProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(MasterProfile_STATUS{}), generators)

	return masterProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMasterProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMasterProfile_STATUS(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["EncryptionAtHost"] = gen.PtrOf(gen.OneConstOf(EncryptionAtHost_STATUS_Disabled, EncryptionAtHost_STATUS_Enabled))
	gens["SubnetId"] = gen.PtrOf(gen.AlphaString())
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkProfile to NetworkProfile via AssignProperties_To_NetworkProfile & AssignProperties_From_NetworkProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkProfile, NetworkProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkProfile tests if a specific instance of NetworkProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNetworkProfile(subject NetworkProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NetworkProfile
	err := copied.AssignProperties_To_NetworkProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkProfile
	err = actual.AssignProperties_From_NetworkProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile, NetworkProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile runs a test to see if a specific instance of NetworkProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile(subject NetworkProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile instances for property testing - lazily instantiated by NetworkProfileGenerator()
var networkProfileGenerator gopter.Gen

// NetworkProfileGenerator returns a generator of NetworkProfile instances for property testing.
// We first initialize networkProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkProfileGenerator() gopter.Gen {
	if networkProfileGenerator != nil {
		return networkProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfile(generators)
	networkProfileGenerator = gen.Struct(reflect.TypeOf(NetworkProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfile(generators)
	AddRelatedPropertyGeneratorsForNetworkProfile(generators)
	networkProfileGenerator = gen.Struct(reflect.TypeOf(NetworkProfile{}), generators)

	return networkProfileGenerator
}

// AddIndependentPropertyGeneratorsForNetworkProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkProfile(gens map[string]gopter.Gen) {
	gens["OutboundType"] = gen.PtrOf(gen.OneConstOf(OutboundType_Loadbalancer, OutboundType_UserDefinedRouting))
	gens["PodCidr"] = gen.PtrOf(gen.AlphaString())
	gens["PreconfiguredNSG"] = gen.PtrOf(gen.OneConstOf(PreconfiguredNSG_Disabled, PreconfiguredNSG_Enabled))
	gens["ServiceCidr"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfile(gens map[string]gopter.Gen) {
	gens["LoadBalancerProfile"] = gen.PtrOf(LoadBalancerProfileGenerator())
}

func Test_NetworkProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkProfile_STATUS to NetworkProfile_STATUS via AssignProperties_To_NetworkProfile_STATUS & AssignProperties_From_NetworkProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkProfile_STATUS, NetworkProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkProfile_STATUS tests if a specific instance of NetworkProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNetworkProfile_STATUS(subject NetworkProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NetworkProfile_STATUS
	err := copied.AssignProperties_To_NetworkProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkProfile_STATUS
	err = actual.AssignProperties_From_NetworkProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile_STATUS, NetworkProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile_STATUS runs a test to see if a specific instance of NetworkProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile_STATUS(subject NetworkProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_STATUS instances for property testing - lazily instantiated by
// NetworkProfile_STATUSGenerator()
var networkProfile_STATUSGenerator gopter.Gen

// NetworkProfile_STATUSGenerator returns a generator of NetworkProfile_STATUS instances for property testing.
// We first initialize networkProfile_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkProfile_STATUSGenerator() gopter.Gen {
	if networkProfile_STATUSGenerator != nil {
		return networkProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfile_STATUS(generators)
	networkProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfile_STATUS(generators)
	AddRelatedPropertyGeneratorsForNetworkProfile_STATUS(generators)
	networkProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_STATUS{}), generators)

	return networkProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNetworkProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkProfile_STATUS(gens map[string]gopter.Gen) {
	gens["OutboundType"] = gen.PtrOf(gen.OneConstOf(OutboundType_STATUS_Loadbalancer, OutboundType_STATUS_UserDefinedRouting))
	gens["PodCidr"] = gen.PtrOf(gen.AlphaString())
	gens["PreconfiguredNSG"] = gen.PtrOf(gen.OneConstOf(PreconfiguredNSG_STATUS_Disabled, PreconfiguredNSG_STATUS_Enabled))
	gens["ServiceCidr"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfile_STATUS(gens map[string]gopter.Gen) {
	gens["LoadBalancerProfile"] = gen.PtrOf(LoadBalancerProfile_STATUSGenerator())
}

func Test_OpenShiftCluster_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OpenShiftCluster to hub returns original",
		prop.ForAll(RunResourceConversionTestForOpenShiftCluster, OpenShiftClusterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForOpenShiftCluster tests if a specific instance of OpenShiftCluster round trips to the hub storage version and back losslessly
func RunResourceConversionTestForOpenShiftCluster(subject OpenShiftCluster) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.OpenShiftCluster
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual OpenShiftCluster
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OpenShiftCluster_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OpenShiftCluster to OpenShiftCluster via AssignProperties_To_OpenShiftCluster & AssignProperties_From_OpenShiftCluster returns original",
		prop.ForAll(RunPropertyAssignmentTestForOpenShiftCluster, OpenShiftClusterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOpenShiftCluster tests if a specific instance of OpenShiftCluster can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForOpenShiftCluster(subject OpenShiftCluster) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.OpenShiftCluster
	err := copied.AssignProperties_To_OpenShiftCluster(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OpenShiftCluster
	err = actual.AssignProperties_From_OpenShiftCluster(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OpenShiftCluster_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenShiftCluster via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenShiftCluster, OpenShiftClusterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenShiftCluster runs a test to see if a specific instance of OpenShiftCluster round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenShiftCluster(subject OpenShiftCluster) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenShiftCluster
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenShiftCluster instances for property testing - lazily instantiated by OpenShiftClusterGenerator()
var openShiftClusterGenerator gopter.Gen

// OpenShiftClusterGenerator returns a generator of OpenShiftCluster instances for property testing.
func OpenShiftClusterGenerator() gopter.Gen {
	if openShiftClusterGenerator != nil {
		return openShiftClusterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForOpenShiftCluster(generators)
	openShiftClusterGenerator = gen.Struct(reflect.TypeOf(OpenShiftCluster{}), generators)

	return openShiftClusterGenerator
}

// AddRelatedPropertyGeneratorsForOpenShiftCluster is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOpenShiftCluster(gens map[string]gopter.Gen) {
	gens["Spec"] = OpenShiftCluster_SpecGenerator()
	gens["Status"] = OpenShiftCluster_STATUSGenerator()
}

func Test_OpenShiftClusterOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OpenShiftClusterOperatorSpec to OpenShiftClusterOperatorSpec via AssignProperties_To_OpenShiftClusterOperatorSpec & AssignProperties_From_OpenShiftClusterOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForOpenShiftClusterOperatorSpec, OpenShiftClusterOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOpenShiftClusterOperatorSpec tests if a specific instance of OpenShiftClusterOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForOpenShiftClusterOperatorSpec(subject OpenShiftClusterOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.OpenShiftClusterOperatorSpec
	err := copied.AssignProperties_To_OpenShiftClusterOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OpenShiftClusterOperatorSpec
	err = actual.AssignProperties_From_OpenShiftClusterOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OpenShiftClusterOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenShiftClusterOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenShiftClusterOperatorSpec, OpenShiftClusterOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenShiftClusterOperatorSpec runs a test to see if a specific instance of OpenShiftClusterOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenShiftClusterOperatorSpec(subject OpenShiftClusterOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenShiftClusterOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenShiftClusterOperatorSpec instances for property testing - lazily instantiated by
// OpenShiftClusterOperatorSpecGenerator()
var openShiftClusterOperatorSpecGenerator gopter.Gen

// OpenShiftClusterOperatorSpecGenerator returns a generator of OpenShiftClusterOperatorSpec instances for property testing.
func OpenShiftClusterOperatorSpecGenerator() gopter.Gen {
	if openShiftClusterOperatorSpecGenerator != nil {
		return openShiftClusterOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	openShiftClusterOperatorSpecGenerator = gen.Struct(reflect.TypeOf(OpenShiftClusterOperatorSpec{}), generators)

	return openShiftClusterOperatorSpecGenerator
}

func Test_OpenShiftCluster_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OpenShiftCluster_STATUS to OpenShiftCluster_STATUS via AssignProperties_To_OpenShiftCluster_STATUS & AssignProperties_From_OpenShiftCluster_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForOpenShiftCluster_STATUS, OpenShiftCluster_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOpenShiftCluster_STATUS tests if a specific instance of OpenShiftCluster_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForOpenShiftCluster_STATUS(subject OpenShiftCluster_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.OpenShiftCluster_STATUS
	err := copied.AssignProperties_To_OpenShiftCluster_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OpenShiftCluster_STATUS
	err = actual.AssignProperties_From_OpenShiftCluster_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OpenShiftCluster_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenShiftCluster_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenShiftCluster_STATUS, OpenShiftCluster_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenShiftCluster_STATUS runs a test to see if a specific instance of OpenShiftCluster_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenShiftCluster_STATUS(subject OpenShiftCluster_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenShiftCluster_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenShiftCluster_STATUS instances for property testing - lazily instantiated by
// OpenShiftCluster_STATUSGenerator()
var openShiftCluster_STATUSGenerator gopter.Gen

// OpenShiftCluster_STATUSGenerator returns a generator of OpenShiftCluster_STATUS instances for property testing.
// We first initialize openShiftCluster_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OpenShiftCluster_STATUSGenerator() gopter.Gen {
	if openShiftCluster_STATUSGenerator != nil {
		return openShiftCluster_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenShiftCluster_STATUS(generators)
	openShiftCluster_STATUSGenerator = gen.Struct(reflect.TypeOf(OpenShiftCluster_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenShiftCluster_STATUS(generators)
	AddRelatedPropertyGeneratorsForOpenShiftCluster_STATUS(generators)
	openShiftCluster_STATUSGenerator = gen.Struct(reflect.TypeOf(OpenShiftCluster_STATUS{}), generators)

	return openShiftCluster_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForOpenShiftCluster_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenShiftCluster_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_AdminUpdating,
		ProvisioningState_STATUS_Canceled,
		ProvisioningState_STATUS_Creating,
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOpenShiftCluster_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOpenShiftCluster_STATUS(gens map[string]gopter.Gen) {
	gens["ApiserverProfile"] = gen.PtrOf(APIServerProfile_STATUSGenerator())
	gens["ClusterProfile"] = gen.PtrOf(ClusterProfile_STATUSGenerator())
	gens["ConsoleProfile"] = gen.PtrOf(ConsoleProfile_STATUSGenerator())
	gens["IngressProfiles"] = gen.SliceOf(IngressProfile_STATUSGenerator())
	gens["MasterProfile"] = gen.PtrOf(MasterProfile_STATUSGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfile_STATUSGenerator())
	gens["ServicePrincipalProfile"] = gen.PtrOf(ServicePrincipalProfile_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
	gens["WorkerProfiles"] = gen.SliceOf(WorkerProfile_STATUSGenerator())
	gens["WorkerProfilesStatus"] = gen.SliceOf(WorkerProfile_STATUSGenerator())
}

func Test_OpenShiftCluster_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OpenShiftCluster_Spec to OpenShiftCluster_Spec via AssignProperties_To_OpenShiftCluster_Spec & AssignProperties_From_OpenShiftCluster_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForOpenShiftCluster_Spec, OpenShiftCluster_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOpenShiftCluster_Spec tests if a specific instance of OpenShiftCluster_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForOpenShiftCluster_Spec(subject OpenShiftCluster_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.OpenShiftCluster_Spec
	err := copied.AssignProperties_To_OpenShiftCluster_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OpenShiftCluster_Spec
	err = actual.AssignProperties_From_OpenShiftCluster_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OpenShiftCluster_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenShiftCluster_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenShiftCluster_Spec, OpenShiftCluster_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenShiftCluster_Spec runs a test to see if a specific instance of OpenShiftCluster_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenShiftCluster_Spec(subject OpenShiftCluster_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenShiftCluster_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenShiftCluster_Spec instances for property testing - lazily instantiated by
// OpenShiftCluster_SpecGenerator()
var openShiftCluster_SpecGenerator gopter.Gen

// OpenShiftCluster_SpecGenerator returns a generator of OpenShiftCluster_Spec instances for property testing.
// We first initialize openShiftCluster_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OpenShiftCluster_SpecGenerator() gopter.Gen {
	if openShiftCluster_SpecGenerator != nil {
		return openShiftCluster_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenShiftCluster_Spec(generators)
	openShiftCluster_SpecGenerator = gen.Struct(reflect.TypeOf(OpenShiftCluster_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenShiftCluster_Spec(generators)
	AddRelatedPropertyGeneratorsForOpenShiftCluster_Spec(generators)
	openShiftCluster_SpecGenerator = gen.Struct(reflect.TypeOf(OpenShiftCluster_Spec{}), generators)

	return openShiftCluster_SpecGenerator
}

// AddIndependentPropertyGeneratorsForOpenShiftCluster_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenShiftCluster_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOpenShiftCluster_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOpenShiftCluster_Spec(gens map[string]gopter.Gen) {
	gens["ApiserverProfile"] = gen.PtrOf(APIServerProfileGenerator())
	gens["ClusterProfile"] = gen.PtrOf(ClusterProfileGenerator())
	gens["IngressProfiles"] = gen.SliceOf(IngressProfileGenerator())
	gens["MasterProfile"] = gen.PtrOf(MasterProfileGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfileGenerator())
	gens["OperatorSpec"] = gen.PtrOf(OpenShiftClusterOperatorSpecGenerator())
	gens["ServicePrincipalProfile"] = gen.PtrOf(ServicePrincipalProfileGenerator())
	gens["WorkerProfiles"] = gen.SliceOf(WorkerProfileGenerator())
}

func Test_ServicePrincipalProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServicePrincipalProfile to ServicePrincipalProfile via AssignProperties_To_ServicePrincipalProfile & AssignProperties_From_ServicePrincipalProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForServicePrincipalProfile, ServicePrincipalProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServicePrincipalProfile tests if a specific instance of ServicePrincipalProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServicePrincipalProfile(subject ServicePrincipalProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServicePrincipalProfile
	err := copied.AssignProperties_To_ServicePrincipalProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServicePrincipalProfile
	err = actual.AssignProperties_From_ServicePrincipalProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServicePrincipalProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServicePrincipalProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServicePrincipalProfile, ServicePrincipalProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServicePrincipalProfile runs a test to see if a specific instance of ServicePrincipalProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForServicePrincipalProfile(subject ServicePrincipalProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServicePrincipalProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServicePrincipalProfile instances for property testing - lazily instantiated by
// ServicePrincipalProfileGenerator()
var servicePrincipalProfileGenerator gopter.Gen

// ServicePrincipalProfileGenerator returns a generator of ServicePrincipalProfile instances for property testing.
func ServicePrincipalProfileGenerator() gopter.Gen {
	if servicePrincipalProfileGenerator != nil {
		return servicePrincipalProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServicePrincipalProfile(generators)
	servicePrincipalProfileGenerator = gen.Struct(reflect.TypeOf(ServicePrincipalProfile{}), generators)

	return servicePrincipalProfileGenerator
}

// AddIndependentPropertyGeneratorsForServicePrincipalProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServicePrincipalProfile(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ServicePrincipalProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServicePrincipalProfile_STATUS to ServicePrincipalProfile_STATUS via AssignProperties_To_ServicePrincipalProfile_STATUS & AssignProperties_From_ServicePrincipalProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServicePrincipalProfile_STATUS, ServicePrincipalProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServicePrincipalProfile_STATUS tests if a specific instance of ServicePrincipalProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForServicePrincipalProfile_STATUS(subject ServicePrincipalProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ServicePrincipalProfile_STATUS
	err := copied.AssignProperties_To_ServicePrincipalProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServicePrincipalProfile_STATUS
	err = actual.AssignProperties_From_ServicePrincipalProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServicePrincipalProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServicePrincipalProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServicePrincipalProfile_STATUS, ServicePrincipalProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServicePrincipalProfile_STATUS runs a test to see if a specific instance of ServicePrincipalProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServicePrincipalProfile_STATUS(subject ServicePrincipalProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServicePrincipalProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServicePrincipalProfile_STATUS instances for property testing - lazily instantiated by
// ServicePrincipalProfile_STATUSGenerator()
var servicePrincipalProfile_STATUSGenerator gopter.Gen

// ServicePrincipalProfile_STATUSGenerator returns a generator of ServicePrincipalProfile_STATUS instances for property testing.
func ServicePrincipalProfile_STATUSGenerator() gopter.Gen {
	if servicePrincipalProfile_STATUSGenerator != nil {
		return servicePrincipalProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServicePrincipalProfile_STATUS(generators)
	servicePrincipalProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(ServicePrincipalProfile_STATUS{}), generators)

	return servicePrincipalProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForServicePrincipalProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServicePrincipalProfile_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
}

func Test_SystemData_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignProperties_To_SystemData_STATUS & AssignProperties_From_SystemData_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData_STATUS tests if a specific instance of SystemData_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SystemData_STATUS
	err := copied.AssignProperties_To_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_STATUS
	err = actual.AssignProperties_From_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_STATUS_Application,
		SystemData_CreatedByType_STATUS_Key,
		SystemData_CreatedByType_STATUS_ManagedIdentity,
		SystemData_CreatedByType_STATUS_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_STATUS_Application,
		SystemData_LastModifiedByType_STATUS_Key,
		SystemData_LastModifiedByType_STATUS_ManagedIdentity,
		SystemData_LastModifiedByType_STATUS_User))
}

func Test_WorkerProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkerProfile to WorkerProfile via AssignProperties_To_WorkerProfile & AssignProperties_From_WorkerProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkerProfile, WorkerProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkerProfile tests if a specific instance of WorkerProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkerProfile(subject WorkerProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkerProfile
	err := copied.AssignProperties_To_WorkerProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkerProfile
	err = actual.AssignProperties_From_WorkerProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkerProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkerProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkerProfile, WorkerProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkerProfile runs a test to see if a specific instance of WorkerProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkerProfile(subject WorkerProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkerProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkerProfile instances for property testing - lazily instantiated by WorkerProfileGenerator()
var workerProfileGenerator gopter.Gen

// WorkerProfileGenerator returns a generator of WorkerProfile instances for property testing.
func WorkerProfileGenerator() gopter.Gen {
	if workerProfileGenerator != nil {
		return workerProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkerProfile(generators)
	workerProfileGenerator = gen.Struct(reflect.TypeOf(WorkerProfile{}), generators)

	return workerProfileGenerator
}

// AddIndependentPropertyGeneratorsForWorkerProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkerProfile(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["EncryptionAtHost"] = gen.PtrOf(gen.OneConstOf(EncryptionAtHost_Disabled, EncryptionAtHost_Enabled))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkerProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from WorkerProfile_STATUS to WorkerProfile_STATUS via AssignProperties_To_WorkerProfile_STATUS & AssignProperties_From_WorkerProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForWorkerProfile_STATUS, WorkerProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForWorkerProfile_STATUS tests if a specific instance of WorkerProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForWorkerProfile_STATUS(subject WorkerProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.WorkerProfile_STATUS
	err := copied.AssignProperties_To_WorkerProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual WorkerProfile_STATUS
	err = actual.AssignProperties_From_WorkerProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_WorkerProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkerProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkerProfile_STATUS, WorkerProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkerProfile_STATUS runs a test to see if a specific instance of WorkerProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkerProfile_STATUS(subject WorkerProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkerProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkerProfile_STATUS instances for property testing - lazily instantiated by
// WorkerProfile_STATUSGenerator()
var workerProfile_STATUSGenerator gopter.Gen

// WorkerProfile_STATUSGenerator returns a generator of WorkerProfile_STATUS instances for property testing.
func WorkerProfile_STATUSGenerator() gopter.Gen {
	if workerProfile_STATUSGenerator != nil {
		return workerProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkerProfile_STATUS(generators)
	workerProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(WorkerProfile_STATUS{}), generators)

	return workerProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWorkerProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkerProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["EncryptionAtHost"] = gen.PtrOf(gen.OneConstOf(EncryptionAtHost_STATUS_Disabled, EncryptionAtHost_STATUS_Enabled))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetId"] = gen.PtrOf(gen.AlphaString())
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}
