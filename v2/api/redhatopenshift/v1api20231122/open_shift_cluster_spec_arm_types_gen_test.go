// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20231122

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_APIServerProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of APIServerProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAPIServerProfile_ARM, APIServerProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAPIServerProfile_ARM runs a test to see if a specific instance of APIServerProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAPIServerProfile_ARM(subject APIServerProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual APIServerProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of APIServerProfile_ARM instances for property testing - lazily instantiated by
// APIServerProfile_ARMGenerator()
var apiServerProfile_ARMGenerator gopter.Gen

// APIServerProfile_ARMGenerator returns a generator of APIServerProfile_ARM instances for property testing.
func APIServerProfile_ARMGenerator() gopter.Gen {
	if apiServerProfile_ARMGenerator != nil {
		return apiServerProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAPIServerProfile_ARM(generators)
	apiServerProfile_ARMGenerator = gen.Struct(reflect.TypeOf(APIServerProfile_ARM{}), generators)

	return apiServerProfile_ARMGenerator
}

// AddIndependentPropertyGeneratorsForAPIServerProfile_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAPIServerProfile_ARM(gens map[string]gopter.Gen) {
	gens["Visibility"] = gen.PtrOf(gen.OneConstOf(Visibility_ARM_Private, Visibility_ARM_Public))
}

func Test_ClusterProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClusterProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClusterProfile_ARM, ClusterProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClusterProfile_ARM runs a test to see if a specific instance of ClusterProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForClusterProfile_ARM(subject ClusterProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClusterProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClusterProfile_ARM instances for property testing - lazily instantiated by ClusterProfile_ARMGenerator()
var clusterProfile_ARMGenerator gopter.Gen

// ClusterProfile_ARMGenerator returns a generator of ClusterProfile_ARM instances for property testing.
func ClusterProfile_ARMGenerator() gopter.Gen {
	if clusterProfile_ARMGenerator != nil {
		return clusterProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClusterProfile_ARM(generators)
	clusterProfile_ARMGenerator = gen.Struct(reflect.TypeOf(ClusterProfile_ARM{}), generators)

	return clusterProfile_ARMGenerator
}

// AddIndependentPropertyGeneratorsForClusterProfile_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClusterProfile_ARM(gens map[string]gopter.Gen) {
	gens["Domain"] = gen.PtrOf(gen.AlphaString())
	gens["FipsValidatedModules"] = gen.PtrOf(gen.OneConstOf(FipsValidatedModules_ARM_Disabled, FipsValidatedModules_ARM_Enabled))
	gens["PullSecret"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroupId"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_IngressProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IngressProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIngressProfile_ARM, IngressProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIngressProfile_ARM runs a test to see if a specific instance of IngressProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIngressProfile_ARM(subject IngressProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IngressProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IngressProfile_ARM instances for property testing - lazily instantiated by IngressProfile_ARMGenerator()
var ingressProfile_ARMGenerator gopter.Gen

// IngressProfile_ARMGenerator returns a generator of IngressProfile_ARM instances for property testing.
func IngressProfile_ARMGenerator() gopter.Gen {
	if ingressProfile_ARMGenerator != nil {
		return ingressProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngressProfile_ARM(generators)
	ingressProfile_ARMGenerator = gen.Struct(reflect.TypeOf(IngressProfile_ARM{}), generators)

	return ingressProfile_ARMGenerator
}

// AddIndependentPropertyGeneratorsForIngressProfile_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIngressProfile_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Visibility"] = gen.PtrOf(gen.OneConstOf(Visibility_ARM_Private, Visibility_ARM_Public))
}

func Test_LoadBalancerProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerProfile_ARM, LoadBalancerProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerProfile_ARM runs a test to see if a specific instance of LoadBalancerProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerProfile_ARM(subject LoadBalancerProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerProfile_ARM instances for property testing - lazily instantiated by
// LoadBalancerProfile_ARMGenerator()
var loadBalancerProfile_ARMGenerator gopter.Gen

// LoadBalancerProfile_ARMGenerator returns a generator of LoadBalancerProfile_ARM instances for property testing.
func LoadBalancerProfile_ARMGenerator() gopter.Gen {
	if loadBalancerProfile_ARMGenerator != nil {
		return loadBalancerProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLoadBalancerProfile_ARM(generators)
	loadBalancerProfile_ARMGenerator = gen.Struct(reflect.TypeOf(LoadBalancerProfile_ARM{}), generators)

	return loadBalancerProfile_ARMGenerator
}

// AddRelatedPropertyGeneratorsForLoadBalancerProfile_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerProfile_ARM(gens map[string]gopter.Gen) {
	gens["ManagedOutboundIps"] = gen.PtrOf(ManagedOutboundIPs_ARMGenerator())
}

func Test_ManagedOutboundIPs_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedOutboundIPs_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedOutboundIPs_ARM, ManagedOutboundIPs_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedOutboundIPs_ARM runs a test to see if a specific instance of ManagedOutboundIPs_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedOutboundIPs_ARM(subject ManagedOutboundIPs_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedOutboundIPs_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedOutboundIPs_ARM instances for property testing - lazily instantiated by
// ManagedOutboundIPs_ARMGenerator()
var managedOutboundIPs_ARMGenerator gopter.Gen

// ManagedOutboundIPs_ARMGenerator returns a generator of ManagedOutboundIPs_ARM instances for property testing.
func ManagedOutboundIPs_ARMGenerator() gopter.Gen {
	if managedOutboundIPs_ARMGenerator != nil {
		return managedOutboundIPs_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedOutboundIPs_ARM(generators)
	managedOutboundIPs_ARMGenerator = gen.Struct(reflect.TypeOf(ManagedOutboundIPs_ARM{}), generators)

	return managedOutboundIPs_ARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedOutboundIPs_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedOutboundIPs_ARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
}

func Test_MasterProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MasterProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMasterProfile_ARM, MasterProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMasterProfile_ARM runs a test to see if a specific instance of MasterProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForMasterProfile_ARM(subject MasterProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MasterProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MasterProfile_ARM instances for property testing - lazily instantiated by MasterProfile_ARMGenerator()
var masterProfile_ARMGenerator gopter.Gen

// MasterProfile_ARMGenerator returns a generator of MasterProfile_ARM instances for property testing.
func MasterProfile_ARMGenerator() gopter.Gen {
	if masterProfile_ARMGenerator != nil {
		return masterProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMasterProfile_ARM(generators)
	masterProfile_ARMGenerator = gen.Struct(reflect.TypeOf(MasterProfile_ARM{}), generators)

	return masterProfile_ARMGenerator
}

// AddIndependentPropertyGeneratorsForMasterProfile_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMasterProfile_ARM(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["EncryptionAtHost"] = gen.PtrOf(gen.OneConstOf(EncryptionAtHost_ARM_Disabled, EncryptionAtHost_ARM_Enabled))
	gens["SubnetId"] = gen.PtrOf(gen.AlphaString())
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile_ARM, NetworkProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile_ARM runs a test to see if a specific instance of NetworkProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile_ARM(subject NetworkProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_ARM instances for property testing - lazily instantiated by NetworkProfile_ARMGenerator()
var networkProfile_ARMGenerator gopter.Gen

// NetworkProfile_ARMGenerator returns a generator of NetworkProfile_ARM instances for property testing.
// We first initialize networkProfile_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkProfile_ARMGenerator() gopter.Gen {
	if networkProfile_ARMGenerator != nil {
		return networkProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfile_ARM(generators)
	networkProfile_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfile_ARM(generators)
	AddRelatedPropertyGeneratorsForNetworkProfile_ARM(generators)
	networkProfile_ARMGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_ARM{}), generators)

	return networkProfile_ARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkProfile_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkProfile_ARM(gens map[string]gopter.Gen) {
	gens["OutboundType"] = gen.PtrOf(gen.OneConstOf(OutboundType_ARM_Loadbalancer, OutboundType_ARM_UserDefinedRouting))
	gens["PodCidr"] = gen.PtrOf(gen.AlphaString())
	gens["PreconfiguredNSG"] = gen.PtrOf(gen.OneConstOf(PreconfiguredNSG_ARM_Disabled, PreconfiguredNSG_ARM_Enabled))
	gens["ServiceCidr"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkProfile_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfile_ARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerProfile"] = gen.PtrOf(LoadBalancerProfile_ARMGenerator())
}

func Test_OpenShiftClusterProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenShiftClusterProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenShiftClusterProperties_ARM, OpenShiftClusterProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenShiftClusterProperties_ARM runs a test to see if a specific instance of OpenShiftClusterProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenShiftClusterProperties_ARM(subject OpenShiftClusterProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenShiftClusterProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenShiftClusterProperties_ARM instances for property testing - lazily instantiated by
// OpenShiftClusterProperties_ARMGenerator()
var openShiftClusterProperties_ARMGenerator gopter.Gen

// OpenShiftClusterProperties_ARMGenerator returns a generator of OpenShiftClusterProperties_ARM instances for property testing.
func OpenShiftClusterProperties_ARMGenerator() gopter.Gen {
	if openShiftClusterProperties_ARMGenerator != nil {
		return openShiftClusterProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForOpenShiftClusterProperties_ARM(generators)
	openShiftClusterProperties_ARMGenerator = gen.Struct(reflect.TypeOf(OpenShiftClusterProperties_ARM{}), generators)

	return openShiftClusterProperties_ARMGenerator
}

// AddRelatedPropertyGeneratorsForOpenShiftClusterProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOpenShiftClusterProperties_ARM(gens map[string]gopter.Gen) {
	gens["ApiserverProfile"] = gen.PtrOf(APIServerProfile_ARMGenerator())
	gens["ClusterProfile"] = gen.PtrOf(ClusterProfile_ARMGenerator())
	gens["IngressProfiles"] = gen.SliceOf(IngressProfile_ARMGenerator())
	gens["MasterProfile"] = gen.PtrOf(MasterProfile_ARMGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfile_ARMGenerator())
	gens["ServicePrincipalProfile"] = gen.PtrOf(ServicePrincipalProfile_ARMGenerator())
	gens["WorkerProfiles"] = gen.SliceOf(WorkerProfile_ARMGenerator())
}

func Test_OpenShiftCluster_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenShiftCluster_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenShiftCluster_Spec_ARM, OpenShiftCluster_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenShiftCluster_Spec_ARM runs a test to see if a specific instance of OpenShiftCluster_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenShiftCluster_Spec_ARM(subject OpenShiftCluster_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenShiftCluster_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenShiftCluster_Spec_ARM instances for property testing - lazily instantiated by
// OpenShiftCluster_Spec_ARMGenerator()
var openShiftCluster_Spec_ARMGenerator gopter.Gen

// OpenShiftCluster_Spec_ARMGenerator returns a generator of OpenShiftCluster_Spec_ARM instances for property testing.
// We first initialize openShiftCluster_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OpenShiftCluster_Spec_ARMGenerator() gopter.Gen {
	if openShiftCluster_Spec_ARMGenerator != nil {
		return openShiftCluster_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenShiftCluster_Spec_ARM(generators)
	openShiftCluster_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(OpenShiftCluster_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenShiftCluster_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForOpenShiftCluster_Spec_ARM(generators)
	openShiftCluster_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(OpenShiftCluster_Spec_ARM{}), generators)

	return openShiftCluster_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForOpenShiftCluster_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenShiftCluster_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOpenShiftCluster_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOpenShiftCluster_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(OpenShiftClusterProperties_ARMGenerator())
}

func Test_ServicePrincipalProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServicePrincipalProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServicePrincipalProfile_ARM, ServicePrincipalProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServicePrincipalProfile_ARM runs a test to see if a specific instance of ServicePrincipalProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServicePrincipalProfile_ARM(subject ServicePrincipalProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServicePrincipalProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServicePrincipalProfile_ARM instances for property testing - lazily instantiated by
// ServicePrincipalProfile_ARMGenerator()
var servicePrincipalProfile_ARMGenerator gopter.Gen

// ServicePrincipalProfile_ARMGenerator returns a generator of ServicePrincipalProfile_ARM instances for property testing.
func ServicePrincipalProfile_ARMGenerator() gopter.Gen {
	if servicePrincipalProfile_ARMGenerator != nil {
		return servicePrincipalProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServicePrincipalProfile_ARM(generators)
	servicePrincipalProfile_ARMGenerator = gen.Struct(reflect.TypeOf(ServicePrincipalProfile_ARM{}), generators)

	return servicePrincipalProfile_ARMGenerator
}

// AddIndependentPropertyGeneratorsForServicePrincipalProfile_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServicePrincipalProfile_ARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecret"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkerProfile_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkerProfile_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkerProfile_ARM, WorkerProfile_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkerProfile_ARM runs a test to see if a specific instance of WorkerProfile_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkerProfile_ARM(subject WorkerProfile_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkerProfile_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkerProfile_ARM instances for property testing - lazily instantiated by WorkerProfile_ARMGenerator()
var workerProfile_ARMGenerator gopter.Gen

// WorkerProfile_ARMGenerator returns a generator of WorkerProfile_ARM instances for property testing.
func WorkerProfile_ARMGenerator() gopter.Gen {
	if workerProfile_ARMGenerator != nil {
		return workerProfile_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkerProfile_ARM(generators)
	workerProfile_ARMGenerator = gen.Struct(reflect.TypeOf(WorkerProfile_ARM{}), generators)

	return workerProfile_ARMGenerator
}

// AddIndependentPropertyGeneratorsForWorkerProfile_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkerProfile_ARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["EncryptionAtHost"] = gen.PtrOf(gen.OneConstOf(EncryptionAtHost_ARM_Disabled, EncryptionAtHost_ARM_Enabled))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetId"] = gen.PtrOf(gen.AlphaString())
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}
