// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_APIServerProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of APIServerProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAPIServerProfile, APIServerProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAPIServerProfile runs a test to see if a specific instance of APIServerProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForAPIServerProfile(subject APIServerProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual APIServerProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of APIServerProfile instances for property testing - lazily instantiated by APIServerProfileGenerator()
var apiServerProfileGenerator gopter.Gen

// APIServerProfileGenerator returns a generator of APIServerProfile instances for property testing.
func APIServerProfileGenerator() gopter.Gen {
	if apiServerProfileGenerator != nil {
		return apiServerProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAPIServerProfile(generators)
	apiServerProfileGenerator = gen.Struct(reflect.TypeOf(APIServerProfile{}), generators)

	return apiServerProfileGenerator
}

// AddIndependentPropertyGeneratorsForAPIServerProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAPIServerProfile(gens map[string]gopter.Gen) {
	gens["Visibility"] = gen.PtrOf(gen.OneConstOf(Visibility_Private, Visibility_Public))
}

func Test_ClusterProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClusterProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClusterProfile, ClusterProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClusterProfile runs a test to see if a specific instance of ClusterProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForClusterProfile(subject ClusterProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClusterProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClusterProfile instances for property testing - lazily instantiated by ClusterProfileGenerator()
var clusterProfileGenerator gopter.Gen

// ClusterProfileGenerator returns a generator of ClusterProfile instances for property testing.
func ClusterProfileGenerator() gopter.Gen {
	if clusterProfileGenerator != nil {
		return clusterProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClusterProfile(generators)
	clusterProfileGenerator = gen.Struct(reflect.TypeOf(ClusterProfile{}), generators)

	return clusterProfileGenerator
}

// AddIndependentPropertyGeneratorsForClusterProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClusterProfile(gens map[string]gopter.Gen) {
	gens["Domain"] = gen.PtrOf(gen.AlphaString())
	gens["FipsValidatedModules"] = gen.PtrOf(gen.OneConstOf(FipsValidatedModules_Disabled, FipsValidatedModules_Enabled))
	gens["PullSecret"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceGroupId"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_IngressProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IngressProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIngressProfile, IngressProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIngressProfile runs a test to see if a specific instance of IngressProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForIngressProfile(subject IngressProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IngressProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IngressProfile instances for property testing - lazily instantiated by IngressProfileGenerator()
var ingressProfileGenerator gopter.Gen

// IngressProfileGenerator returns a generator of IngressProfile instances for property testing.
func IngressProfileGenerator() gopter.Gen {
	if ingressProfileGenerator != nil {
		return ingressProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIngressProfile(generators)
	ingressProfileGenerator = gen.Struct(reflect.TypeOf(IngressProfile{}), generators)

	return ingressProfileGenerator
}

// AddIndependentPropertyGeneratorsForIngressProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIngressProfile(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Visibility"] = gen.PtrOf(gen.OneConstOf(Visibility_Private, Visibility_Public))
}

func Test_LoadBalancerProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LoadBalancerProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLoadBalancerProfile, LoadBalancerProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLoadBalancerProfile runs a test to see if a specific instance of LoadBalancerProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForLoadBalancerProfile(subject LoadBalancerProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LoadBalancerProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LoadBalancerProfile instances for property testing - lazily instantiated by
// LoadBalancerProfileGenerator()
var loadBalancerProfileGenerator gopter.Gen

// LoadBalancerProfileGenerator returns a generator of LoadBalancerProfile instances for property testing.
func LoadBalancerProfileGenerator() gopter.Gen {
	if loadBalancerProfileGenerator != nil {
		return loadBalancerProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForLoadBalancerProfile(generators)
	loadBalancerProfileGenerator = gen.Struct(reflect.TypeOf(LoadBalancerProfile{}), generators)

	return loadBalancerProfileGenerator
}

// AddRelatedPropertyGeneratorsForLoadBalancerProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLoadBalancerProfile(gens map[string]gopter.Gen) {
	gens["ManagedOutboundIps"] = gen.PtrOf(ManagedOutboundIPsGenerator())
}

func Test_ManagedOutboundIPs_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedOutboundIPs via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedOutboundIPs, ManagedOutboundIPsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedOutboundIPs runs a test to see if a specific instance of ManagedOutboundIPs round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedOutboundIPs(subject ManagedOutboundIPs) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedOutboundIPs
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedOutboundIPs instances for property testing - lazily instantiated by ManagedOutboundIPsGenerator()
var managedOutboundIPsGenerator gopter.Gen

// ManagedOutboundIPsGenerator returns a generator of ManagedOutboundIPs instances for property testing.
func ManagedOutboundIPsGenerator() gopter.Gen {
	if managedOutboundIPsGenerator != nil {
		return managedOutboundIPsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedOutboundIPs(generators)
	managedOutboundIPsGenerator = gen.Struct(reflect.TypeOf(ManagedOutboundIPs{}), generators)

	return managedOutboundIPsGenerator
}

// AddIndependentPropertyGeneratorsForManagedOutboundIPs is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedOutboundIPs(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
}

func Test_MasterProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MasterProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMasterProfile, MasterProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMasterProfile runs a test to see if a specific instance of MasterProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForMasterProfile(subject MasterProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MasterProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MasterProfile instances for property testing - lazily instantiated by MasterProfileGenerator()
var masterProfileGenerator gopter.Gen

// MasterProfileGenerator returns a generator of MasterProfile instances for property testing.
func MasterProfileGenerator() gopter.Gen {
	if masterProfileGenerator != nil {
		return masterProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMasterProfile(generators)
	masterProfileGenerator = gen.Struct(reflect.TypeOf(MasterProfile{}), generators)

	return masterProfileGenerator
}

// AddIndependentPropertyGeneratorsForMasterProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMasterProfile(gens map[string]gopter.Gen) {
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["EncryptionAtHost"] = gen.PtrOf(gen.OneConstOf(EncryptionAtHost_Disabled, EncryptionAtHost_Enabled))
	gens["SubnetId"] = gen.PtrOf(gen.AlphaString())
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile, NetworkProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile runs a test to see if a specific instance of NetworkProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile(subject NetworkProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile instances for property testing - lazily instantiated by NetworkProfileGenerator()
var networkProfileGenerator gopter.Gen

// NetworkProfileGenerator returns a generator of NetworkProfile instances for property testing.
// We first initialize networkProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func NetworkProfileGenerator() gopter.Gen {
	if networkProfileGenerator != nil {
		return networkProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfile(generators)
	networkProfileGenerator = gen.Struct(reflect.TypeOf(NetworkProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfile(generators)
	AddRelatedPropertyGeneratorsForNetworkProfile(generators)
	networkProfileGenerator = gen.Struct(reflect.TypeOf(NetworkProfile{}), generators)

	return networkProfileGenerator
}

// AddIndependentPropertyGeneratorsForNetworkProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkProfile(gens map[string]gopter.Gen) {
	gens["OutboundType"] = gen.PtrOf(gen.OneConstOf(OutboundType_Loadbalancer, OutboundType_UserDefinedRouting))
	gens["PodCidr"] = gen.PtrOf(gen.AlphaString())
	gens["PreconfiguredNSG"] = gen.PtrOf(gen.OneConstOf(PreconfiguredNSG_Disabled, PreconfiguredNSG_Enabled))
	gens["ServiceCidr"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForNetworkProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForNetworkProfile(gens map[string]gopter.Gen) {
	gens["LoadBalancerProfile"] = gen.PtrOf(LoadBalancerProfileGenerator())
}

func Test_OpenShiftClusterProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenShiftClusterProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenShiftClusterProperties, OpenShiftClusterPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenShiftClusterProperties runs a test to see if a specific instance of OpenShiftClusterProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenShiftClusterProperties(subject OpenShiftClusterProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenShiftClusterProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenShiftClusterProperties instances for property testing - lazily instantiated by
// OpenShiftClusterPropertiesGenerator()
var openShiftClusterPropertiesGenerator gopter.Gen

// OpenShiftClusterPropertiesGenerator returns a generator of OpenShiftClusterProperties instances for property testing.
func OpenShiftClusterPropertiesGenerator() gopter.Gen {
	if openShiftClusterPropertiesGenerator != nil {
		return openShiftClusterPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForOpenShiftClusterProperties(generators)
	openShiftClusterPropertiesGenerator = gen.Struct(reflect.TypeOf(OpenShiftClusterProperties{}), generators)

	return openShiftClusterPropertiesGenerator
}

// AddRelatedPropertyGeneratorsForOpenShiftClusterProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOpenShiftClusterProperties(gens map[string]gopter.Gen) {
	gens["ApiserverProfile"] = gen.PtrOf(APIServerProfileGenerator())
	gens["ClusterProfile"] = gen.PtrOf(ClusterProfileGenerator())
	gens["IngressProfiles"] = gen.SliceOf(IngressProfileGenerator())
	gens["MasterProfile"] = gen.PtrOf(MasterProfileGenerator())
	gens["NetworkProfile"] = gen.PtrOf(NetworkProfileGenerator())
	gens["ServicePrincipalProfile"] = gen.PtrOf(ServicePrincipalProfileGenerator())
	gens["WorkerProfiles"] = gen.SliceOf(WorkerProfileGenerator())
}

func Test_OpenShiftCluster_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OpenShiftCluster_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOpenShiftCluster_Spec, OpenShiftCluster_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOpenShiftCluster_Spec runs a test to see if a specific instance of OpenShiftCluster_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForOpenShiftCluster_Spec(subject OpenShiftCluster_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OpenShiftCluster_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OpenShiftCluster_Spec instances for property testing - lazily instantiated by
// OpenShiftCluster_SpecGenerator()
var openShiftCluster_SpecGenerator gopter.Gen

// OpenShiftCluster_SpecGenerator returns a generator of OpenShiftCluster_Spec instances for property testing.
// We first initialize openShiftCluster_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OpenShiftCluster_SpecGenerator() gopter.Gen {
	if openShiftCluster_SpecGenerator != nil {
		return openShiftCluster_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenShiftCluster_Spec(generators)
	openShiftCluster_SpecGenerator = gen.Struct(reflect.TypeOf(OpenShiftCluster_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOpenShiftCluster_Spec(generators)
	AddRelatedPropertyGeneratorsForOpenShiftCluster_Spec(generators)
	openShiftCluster_SpecGenerator = gen.Struct(reflect.TypeOf(OpenShiftCluster_Spec{}), generators)

	return openShiftCluster_SpecGenerator
}

// AddIndependentPropertyGeneratorsForOpenShiftCluster_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOpenShiftCluster_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForOpenShiftCluster_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOpenShiftCluster_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(OpenShiftClusterPropertiesGenerator())
}

func Test_ServicePrincipalProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServicePrincipalProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServicePrincipalProfile, ServicePrincipalProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServicePrincipalProfile runs a test to see if a specific instance of ServicePrincipalProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForServicePrincipalProfile(subject ServicePrincipalProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServicePrincipalProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServicePrincipalProfile instances for property testing - lazily instantiated by
// ServicePrincipalProfileGenerator()
var servicePrincipalProfileGenerator gopter.Gen

// ServicePrincipalProfileGenerator returns a generator of ServicePrincipalProfile instances for property testing.
func ServicePrincipalProfileGenerator() gopter.Gen {
	if servicePrincipalProfileGenerator != nil {
		return servicePrincipalProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServicePrincipalProfile(generators)
	servicePrincipalProfileGenerator = gen.Struct(reflect.TypeOf(ServicePrincipalProfile{}), generators)

	return servicePrincipalProfileGenerator
}

// AddIndependentPropertyGeneratorsForServicePrincipalProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServicePrincipalProfile(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ClientSecret"] = gen.PtrOf(gen.AlphaString())
}

func Test_WorkerProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WorkerProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWorkerProfile, WorkerProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWorkerProfile runs a test to see if a specific instance of WorkerProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForWorkerProfile(subject WorkerProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WorkerProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WorkerProfile instances for property testing - lazily instantiated by WorkerProfileGenerator()
var workerProfileGenerator gopter.Gen

// WorkerProfileGenerator returns a generator of WorkerProfile instances for property testing.
func WorkerProfileGenerator() gopter.Gen {
	if workerProfileGenerator != nil {
		return workerProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWorkerProfile(generators)
	workerProfileGenerator = gen.Struct(reflect.TypeOf(WorkerProfile{}), generators)

	return workerProfileGenerator
}

// AddIndependentPropertyGeneratorsForWorkerProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWorkerProfile(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["DiskEncryptionSetId"] = gen.PtrOf(gen.AlphaString())
	gens["DiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["EncryptionAtHost"] = gen.PtrOf(gen.OneConstOf(EncryptionAtHost_Disabled, EncryptionAtHost_Enabled))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["SubnetId"] = gen.PtrOf(gen.AlphaString())
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}
