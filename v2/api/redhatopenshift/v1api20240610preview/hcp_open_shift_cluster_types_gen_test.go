// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240610preview

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/redhatopenshift/v1api20240610preview/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ApiProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiProfile to ApiProfile via AssignProperties_To_ApiProfile & AssignProperties_From_ApiProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiProfile, ApiProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiProfile tests if a specific instance of ApiProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApiProfile(subject ApiProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ApiProfile
	err := copied.AssignProperties_To_ApiProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiProfile
	err = actual.AssignProperties_From_ApiProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProfile, ApiProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProfile runs a test to see if a specific instance of ApiProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProfile(subject ApiProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProfile instances for property testing - lazily instantiated by ApiProfileGenerator()
var apiProfileGenerator gopter.Gen

// ApiProfileGenerator returns a generator of ApiProfile instances for property testing.
func ApiProfileGenerator() gopter.Gen {
	if apiProfileGenerator != nil {
		return apiProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProfile(generators)
	apiProfileGenerator = gen.Struct(reflect.TypeOf(ApiProfile{}), generators)

	return apiProfileGenerator
}

// AddIndependentPropertyGeneratorsForApiProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProfile(gens map[string]gopter.Gen) {
	gens["AuthorizedCidrs"] = gen.SliceOf(gen.AlphaString())
	gens["Visibility"] = gen.PtrOf(gen.OneConstOf(ApiProfile_Visibility_Private, ApiProfile_Visibility_Public))
}

func Test_ApiProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiProfile_STATUS to ApiProfile_STATUS via AssignProperties_To_ApiProfile_STATUS & AssignProperties_From_ApiProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiProfile_STATUS, ApiProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiProfile_STATUS tests if a specific instance of ApiProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForApiProfile_STATUS(subject ApiProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ApiProfile_STATUS
	err := copied.AssignProperties_To_ApiProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiProfile_STATUS
	err = actual.AssignProperties_From_ApiProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProfile_STATUS, ApiProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProfile_STATUS runs a test to see if a specific instance of ApiProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProfile_STATUS(subject ApiProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProfile_STATUS instances for property testing - lazily instantiated by ApiProfile_STATUSGenerator()
var apiProfile_STATUSGenerator gopter.Gen

// ApiProfile_STATUSGenerator returns a generator of ApiProfile_STATUS instances for property testing.
func ApiProfile_STATUSGenerator() gopter.Gen {
	if apiProfile_STATUSGenerator != nil {
		return apiProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProfile_STATUS(generators)
	apiProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(ApiProfile_STATUS{}), generators)

	return apiProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForApiProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProfile_STATUS(gens map[string]gopter.Gen) {
	gens["AuthorizedCidrs"] = gen.SliceOf(gen.AlphaString())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
	gens["Visibility"] = gen.PtrOf(gen.OneConstOf(ApiProfile_Visibility_STATUS_Private, ApiProfile_Visibility_STATUS_Public))
}

func Test_ClusterAutoscalingProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ClusterAutoscalingProfile to ClusterAutoscalingProfile via AssignProperties_To_ClusterAutoscalingProfile & AssignProperties_From_ClusterAutoscalingProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForClusterAutoscalingProfile, ClusterAutoscalingProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForClusterAutoscalingProfile tests if a specific instance of ClusterAutoscalingProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForClusterAutoscalingProfile(subject ClusterAutoscalingProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ClusterAutoscalingProfile
	err := copied.AssignProperties_To_ClusterAutoscalingProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ClusterAutoscalingProfile
	err = actual.AssignProperties_From_ClusterAutoscalingProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ClusterAutoscalingProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClusterAutoscalingProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClusterAutoscalingProfile, ClusterAutoscalingProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClusterAutoscalingProfile runs a test to see if a specific instance of ClusterAutoscalingProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForClusterAutoscalingProfile(subject ClusterAutoscalingProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClusterAutoscalingProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClusterAutoscalingProfile instances for property testing - lazily instantiated by
// ClusterAutoscalingProfileGenerator()
var clusterAutoscalingProfileGenerator gopter.Gen

// ClusterAutoscalingProfileGenerator returns a generator of ClusterAutoscalingProfile instances for property testing.
func ClusterAutoscalingProfileGenerator() gopter.Gen {
	if clusterAutoscalingProfileGenerator != nil {
		return clusterAutoscalingProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClusterAutoscalingProfile(generators)
	clusterAutoscalingProfileGenerator = gen.Struct(reflect.TypeOf(ClusterAutoscalingProfile{}), generators)

	return clusterAutoscalingProfileGenerator
}

// AddIndependentPropertyGeneratorsForClusterAutoscalingProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClusterAutoscalingProfile(gens map[string]gopter.Gen) {
	gens["MaxNodeProvisionTimeSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxNodesTotal"] = gen.PtrOf(gen.Int())
	gens["MaxPodGracePeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["PodPriorityThreshold"] = gen.PtrOf(gen.Int())
}

func Test_ClusterAutoscalingProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ClusterAutoscalingProfile_STATUS to ClusterAutoscalingProfile_STATUS via AssignProperties_To_ClusterAutoscalingProfile_STATUS & AssignProperties_From_ClusterAutoscalingProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForClusterAutoscalingProfile_STATUS, ClusterAutoscalingProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForClusterAutoscalingProfile_STATUS tests if a specific instance of ClusterAutoscalingProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForClusterAutoscalingProfile_STATUS(subject ClusterAutoscalingProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ClusterAutoscalingProfile_STATUS
	err := copied.AssignProperties_To_ClusterAutoscalingProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ClusterAutoscalingProfile_STATUS
	err = actual.AssignProperties_From_ClusterAutoscalingProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ClusterAutoscalingProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClusterAutoscalingProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClusterAutoscalingProfile_STATUS, ClusterAutoscalingProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClusterAutoscalingProfile_STATUS runs a test to see if a specific instance of ClusterAutoscalingProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForClusterAutoscalingProfile_STATUS(subject ClusterAutoscalingProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClusterAutoscalingProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClusterAutoscalingProfile_STATUS instances for property testing - lazily instantiated by
// ClusterAutoscalingProfile_STATUSGenerator()
var clusterAutoscalingProfile_STATUSGenerator gopter.Gen

// ClusterAutoscalingProfile_STATUSGenerator returns a generator of ClusterAutoscalingProfile_STATUS instances for property testing.
func ClusterAutoscalingProfile_STATUSGenerator() gopter.Gen {
	if clusterAutoscalingProfile_STATUSGenerator != nil {
		return clusterAutoscalingProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClusterAutoscalingProfile_STATUS(generators)
	clusterAutoscalingProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(ClusterAutoscalingProfile_STATUS{}), generators)

	return clusterAutoscalingProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForClusterAutoscalingProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClusterAutoscalingProfile_STATUS(gens map[string]gopter.Gen) {
	gens["MaxNodeProvisionTimeSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxNodesTotal"] = gen.PtrOf(gen.Int())
	gens["MaxPodGracePeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["PodPriorityThreshold"] = gen.PtrOf(gen.Int())
}

func Test_ClusterImageRegistryProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ClusterImageRegistryProfile to ClusterImageRegistryProfile via AssignProperties_To_ClusterImageRegistryProfile & AssignProperties_From_ClusterImageRegistryProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForClusterImageRegistryProfile, ClusterImageRegistryProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForClusterImageRegistryProfile tests if a specific instance of ClusterImageRegistryProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForClusterImageRegistryProfile(subject ClusterImageRegistryProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ClusterImageRegistryProfile
	err := copied.AssignProperties_To_ClusterImageRegistryProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ClusterImageRegistryProfile
	err = actual.AssignProperties_From_ClusterImageRegistryProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ClusterImageRegistryProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClusterImageRegistryProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClusterImageRegistryProfile, ClusterImageRegistryProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClusterImageRegistryProfile runs a test to see if a specific instance of ClusterImageRegistryProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForClusterImageRegistryProfile(subject ClusterImageRegistryProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClusterImageRegistryProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClusterImageRegistryProfile instances for property testing - lazily instantiated by
// ClusterImageRegistryProfileGenerator()
var clusterImageRegistryProfileGenerator gopter.Gen

// ClusterImageRegistryProfileGenerator returns a generator of ClusterImageRegistryProfile instances for property testing.
func ClusterImageRegistryProfileGenerator() gopter.Gen {
	if clusterImageRegistryProfileGenerator != nil {
		return clusterImageRegistryProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClusterImageRegistryProfile(generators)
	clusterImageRegistryProfileGenerator = gen.Struct(reflect.TypeOf(ClusterImageRegistryProfile{}), generators)

	return clusterImageRegistryProfileGenerator
}

// AddIndependentPropertyGeneratorsForClusterImageRegistryProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClusterImageRegistryProfile(gens map[string]gopter.Gen) {
	gens["State"] = gen.PtrOf(gen.OneConstOf(ClusterImageRegistryProfile_State_Disabled, ClusterImageRegistryProfile_State_Enabled))
}

func Test_ClusterImageRegistryProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ClusterImageRegistryProfile_STATUS to ClusterImageRegistryProfile_STATUS via AssignProperties_To_ClusterImageRegistryProfile_STATUS & AssignProperties_From_ClusterImageRegistryProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForClusterImageRegistryProfile_STATUS, ClusterImageRegistryProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForClusterImageRegistryProfile_STATUS tests if a specific instance of ClusterImageRegistryProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForClusterImageRegistryProfile_STATUS(subject ClusterImageRegistryProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ClusterImageRegistryProfile_STATUS
	err := copied.AssignProperties_To_ClusterImageRegistryProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ClusterImageRegistryProfile_STATUS
	err = actual.AssignProperties_From_ClusterImageRegistryProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ClusterImageRegistryProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClusterImageRegistryProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClusterImageRegistryProfile_STATUS, ClusterImageRegistryProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClusterImageRegistryProfile_STATUS runs a test to see if a specific instance of ClusterImageRegistryProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForClusterImageRegistryProfile_STATUS(subject ClusterImageRegistryProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClusterImageRegistryProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClusterImageRegistryProfile_STATUS instances for property testing - lazily instantiated by
// ClusterImageRegistryProfile_STATUSGenerator()
var clusterImageRegistryProfile_STATUSGenerator gopter.Gen

// ClusterImageRegistryProfile_STATUSGenerator returns a generator of ClusterImageRegistryProfile_STATUS instances for property testing.
func ClusterImageRegistryProfile_STATUSGenerator() gopter.Gen {
	if clusterImageRegistryProfile_STATUSGenerator != nil {
		return clusterImageRegistryProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClusterImageRegistryProfile_STATUS(generators)
	clusterImageRegistryProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(ClusterImageRegistryProfile_STATUS{}), generators)

	return clusterImageRegistryProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForClusterImageRegistryProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClusterImageRegistryProfile_STATUS(gens map[string]gopter.Gen) {
	gens["State"] = gen.PtrOf(gen.OneConstOf(ClusterImageRegistryProfile_State_STATUS_Disabled, ClusterImageRegistryProfile_State_STATUS_Enabled))
}

func Test_ConsoleProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConsoleProfile_STATUS to ConsoleProfile_STATUS via AssignProperties_To_ConsoleProfile_STATUS & AssignProperties_From_ConsoleProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForConsoleProfile_STATUS, ConsoleProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConsoleProfile_STATUS tests if a specific instance of ConsoleProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForConsoleProfile_STATUS(subject ConsoleProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ConsoleProfile_STATUS
	err := copied.AssignProperties_To_ConsoleProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConsoleProfile_STATUS
	err = actual.AssignProperties_From_ConsoleProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConsoleProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsoleProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsoleProfile_STATUS, ConsoleProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsoleProfile_STATUS runs a test to see if a specific instance of ConsoleProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForConsoleProfile_STATUS(subject ConsoleProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsoleProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsoleProfile_STATUS instances for property testing - lazily instantiated by
// ConsoleProfile_STATUSGenerator()
var consoleProfile_STATUSGenerator gopter.Gen

// ConsoleProfile_STATUSGenerator returns a generator of ConsoleProfile_STATUS instances for property testing.
func ConsoleProfile_STATUSGenerator() gopter.Gen {
	if consoleProfile_STATUSGenerator != nil {
		return consoleProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsoleProfile_STATUS(generators)
	consoleProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(ConsoleProfile_STATUS{}), generators)

	return consoleProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForConsoleProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsoleProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_CustomerManagedEncryptionProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomerManagedEncryptionProfile to CustomerManagedEncryptionProfile via AssignProperties_To_CustomerManagedEncryptionProfile & AssignProperties_From_CustomerManagedEncryptionProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomerManagedEncryptionProfile, CustomerManagedEncryptionProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomerManagedEncryptionProfile tests if a specific instance of CustomerManagedEncryptionProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomerManagedEncryptionProfile(subject CustomerManagedEncryptionProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CustomerManagedEncryptionProfile
	err := copied.AssignProperties_To_CustomerManagedEncryptionProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomerManagedEncryptionProfile
	err = actual.AssignProperties_From_CustomerManagedEncryptionProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomerManagedEncryptionProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomerManagedEncryptionProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomerManagedEncryptionProfile, CustomerManagedEncryptionProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomerManagedEncryptionProfile runs a test to see if a specific instance of CustomerManagedEncryptionProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomerManagedEncryptionProfile(subject CustomerManagedEncryptionProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomerManagedEncryptionProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomerManagedEncryptionProfile instances for property testing - lazily instantiated by
// CustomerManagedEncryptionProfileGenerator()
var customerManagedEncryptionProfileGenerator gopter.Gen

// CustomerManagedEncryptionProfileGenerator returns a generator of CustomerManagedEncryptionProfile instances for property testing.
// We first initialize customerManagedEncryptionProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomerManagedEncryptionProfileGenerator() gopter.Gen {
	if customerManagedEncryptionProfileGenerator != nil {
		return customerManagedEncryptionProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomerManagedEncryptionProfile(generators)
	customerManagedEncryptionProfileGenerator = gen.Struct(reflect.TypeOf(CustomerManagedEncryptionProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomerManagedEncryptionProfile(generators)
	AddRelatedPropertyGeneratorsForCustomerManagedEncryptionProfile(generators)
	customerManagedEncryptionProfileGenerator = gen.Struct(reflect.TypeOf(CustomerManagedEncryptionProfile{}), generators)

	return customerManagedEncryptionProfileGenerator
}

// AddIndependentPropertyGeneratorsForCustomerManagedEncryptionProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomerManagedEncryptionProfile(gens map[string]gopter.Gen) {
	gens["EncryptionType"] = gen.PtrOf(gen.OneConstOf(CustomerManagedEncryptionProfile_EncryptionType_KMS))
}

// AddRelatedPropertyGeneratorsForCustomerManagedEncryptionProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomerManagedEncryptionProfile(gens map[string]gopter.Gen) {
	gens["Kms"] = gen.PtrOf(KmsEncryptionProfileGenerator())
}

func Test_CustomerManagedEncryptionProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomerManagedEncryptionProfile_STATUS to CustomerManagedEncryptionProfile_STATUS via AssignProperties_To_CustomerManagedEncryptionProfile_STATUS & AssignProperties_From_CustomerManagedEncryptionProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomerManagedEncryptionProfile_STATUS, CustomerManagedEncryptionProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomerManagedEncryptionProfile_STATUS tests if a specific instance of CustomerManagedEncryptionProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForCustomerManagedEncryptionProfile_STATUS(subject CustomerManagedEncryptionProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.CustomerManagedEncryptionProfile_STATUS
	err := copied.AssignProperties_To_CustomerManagedEncryptionProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomerManagedEncryptionProfile_STATUS
	err = actual.AssignProperties_From_CustomerManagedEncryptionProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomerManagedEncryptionProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomerManagedEncryptionProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomerManagedEncryptionProfile_STATUS, CustomerManagedEncryptionProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomerManagedEncryptionProfile_STATUS runs a test to see if a specific instance of CustomerManagedEncryptionProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomerManagedEncryptionProfile_STATUS(subject CustomerManagedEncryptionProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomerManagedEncryptionProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomerManagedEncryptionProfile_STATUS instances for property testing - lazily instantiated by
// CustomerManagedEncryptionProfile_STATUSGenerator()
var customerManagedEncryptionProfile_STATUSGenerator gopter.Gen

// CustomerManagedEncryptionProfile_STATUSGenerator returns a generator of CustomerManagedEncryptionProfile_STATUS instances for property testing.
// We first initialize customerManagedEncryptionProfile_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomerManagedEncryptionProfile_STATUSGenerator() gopter.Gen {
	if customerManagedEncryptionProfile_STATUSGenerator != nil {
		return customerManagedEncryptionProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomerManagedEncryptionProfile_STATUS(generators)
	customerManagedEncryptionProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomerManagedEncryptionProfile_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomerManagedEncryptionProfile_STATUS(generators)
	AddRelatedPropertyGeneratorsForCustomerManagedEncryptionProfile_STATUS(generators)
	customerManagedEncryptionProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomerManagedEncryptionProfile_STATUS{}), generators)

	return customerManagedEncryptionProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCustomerManagedEncryptionProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomerManagedEncryptionProfile_STATUS(gens map[string]gopter.Gen) {
	gens["EncryptionType"] = gen.PtrOf(gen.OneConstOf(CustomerManagedEncryptionProfile_EncryptionType_STATUS_KMS))
}

// AddRelatedPropertyGeneratorsForCustomerManagedEncryptionProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomerManagedEncryptionProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Kms"] = gen.PtrOf(KmsEncryptionProfile_STATUSGenerator())
}

func Test_DnsProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DnsProfile to DnsProfile via AssignProperties_To_DnsProfile & AssignProperties_From_DnsProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForDnsProfile, DnsProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDnsProfile tests if a specific instance of DnsProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDnsProfile(subject DnsProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DnsProfile
	err := copied.AssignProperties_To_DnsProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DnsProfile
	err = actual.AssignProperties_From_DnsProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DnsProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsProfile, DnsProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsProfile runs a test to see if a specific instance of DnsProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsProfile(subject DnsProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsProfile instances for property testing - lazily instantiated by DnsProfileGenerator()
var dnsProfileGenerator gopter.Gen

// DnsProfileGenerator returns a generator of DnsProfile instances for property testing.
func DnsProfileGenerator() gopter.Gen {
	if dnsProfileGenerator != nil {
		return dnsProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsProfile(generators)
	dnsProfileGenerator = gen.Struct(reflect.TypeOf(DnsProfile{}), generators)

	return dnsProfileGenerator
}

// AddIndependentPropertyGeneratorsForDnsProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsProfile(gens map[string]gopter.Gen) {
	gens["BaseDomainPrefix"] = gen.PtrOf(gen.AlphaString())
}

func Test_DnsProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DnsProfile_STATUS to DnsProfile_STATUS via AssignProperties_To_DnsProfile_STATUS & AssignProperties_From_DnsProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDnsProfile_STATUS, DnsProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDnsProfile_STATUS tests if a specific instance of DnsProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForDnsProfile_STATUS(subject DnsProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.DnsProfile_STATUS
	err := copied.AssignProperties_To_DnsProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DnsProfile_STATUS
	err = actual.AssignProperties_From_DnsProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DnsProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsProfile_STATUS, DnsProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsProfile_STATUS runs a test to see if a specific instance of DnsProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsProfile_STATUS(subject DnsProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsProfile_STATUS instances for property testing - lazily instantiated by DnsProfile_STATUSGenerator()
var dnsProfile_STATUSGenerator gopter.Gen

// DnsProfile_STATUSGenerator returns a generator of DnsProfile_STATUS instances for property testing.
func DnsProfile_STATUSGenerator() gopter.Gen {
	if dnsProfile_STATUSGenerator != nil {
		return dnsProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsProfile_STATUS(generators)
	dnsProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(DnsProfile_STATUS{}), generators)

	return dnsProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDnsProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsProfile_STATUS(gens map[string]gopter.Gen) {
	gens["BaseDomain"] = gen.PtrOf(gen.AlphaString())
	gens["BaseDomainPrefix"] = gen.PtrOf(gen.AlphaString())
}

func Test_EtcdDataEncryptionProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EtcdDataEncryptionProfile to EtcdDataEncryptionProfile via AssignProperties_To_EtcdDataEncryptionProfile & AssignProperties_From_EtcdDataEncryptionProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForEtcdDataEncryptionProfile, EtcdDataEncryptionProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEtcdDataEncryptionProfile tests if a specific instance of EtcdDataEncryptionProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEtcdDataEncryptionProfile(subject EtcdDataEncryptionProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EtcdDataEncryptionProfile
	err := copied.AssignProperties_To_EtcdDataEncryptionProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EtcdDataEncryptionProfile
	err = actual.AssignProperties_From_EtcdDataEncryptionProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EtcdDataEncryptionProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EtcdDataEncryptionProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEtcdDataEncryptionProfile, EtcdDataEncryptionProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEtcdDataEncryptionProfile runs a test to see if a specific instance of EtcdDataEncryptionProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForEtcdDataEncryptionProfile(subject EtcdDataEncryptionProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EtcdDataEncryptionProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EtcdDataEncryptionProfile instances for property testing - lazily instantiated by
// EtcdDataEncryptionProfileGenerator()
var etcdDataEncryptionProfileGenerator gopter.Gen

// EtcdDataEncryptionProfileGenerator returns a generator of EtcdDataEncryptionProfile instances for property testing.
// We first initialize etcdDataEncryptionProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EtcdDataEncryptionProfileGenerator() gopter.Gen {
	if etcdDataEncryptionProfileGenerator != nil {
		return etcdDataEncryptionProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEtcdDataEncryptionProfile(generators)
	etcdDataEncryptionProfileGenerator = gen.Struct(reflect.TypeOf(EtcdDataEncryptionProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEtcdDataEncryptionProfile(generators)
	AddRelatedPropertyGeneratorsForEtcdDataEncryptionProfile(generators)
	etcdDataEncryptionProfileGenerator = gen.Struct(reflect.TypeOf(EtcdDataEncryptionProfile{}), generators)

	return etcdDataEncryptionProfileGenerator
}

// AddIndependentPropertyGeneratorsForEtcdDataEncryptionProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEtcdDataEncryptionProfile(gens map[string]gopter.Gen) {
	gens["KeyManagementMode"] = gen.PtrOf(gen.OneConstOf(EtcdDataEncryptionProfile_KeyManagementMode_CustomerManaged, EtcdDataEncryptionProfile_KeyManagementMode_PlatformManaged))
}

// AddRelatedPropertyGeneratorsForEtcdDataEncryptionProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEtcdDataEncryptionProfile(gens map[string]gopter.Gen) {
	gens["CustomerManaged"] = gen.PtrOf(CustomerManagedEncryptionProfileGenerator())
}

func Test_EtcdDataEncryptionProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EtcdDataEncryptionProfile_STATUS to EtcdDataEncryptionProfile_STATUS via AssignProperties_To_EtcdDataEncryptionProfile_STATUS & AssignProperties_From_EtcdDataEncryptionProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEtcdDataEncryptionProfile_STATUS, EtcdDataEncryptionProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEtcdDataEncryptionProfile_STATUS tests if a specific instance of EtcdDataEncryptionProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEtcdDataEncryptionProfile_STATUS(subject EtcdDataEncryptionProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EtcdDataEncryptionProfile_STATUS
	err := copied.AssignProperties_To_EtcdDataEncryptionProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EtcdDataEncryptionProfile_STATUS
	err = actual.AssignProperties_From_EtcdDataEncryptionProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EtcdDataEncryptionProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EtcdDataEncryptionProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEtcdDataEncryptionProfile_STATUS, EtcdDataEncryptionProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEtcdDataEncryptionProfile_STATUS runs a test to see if a specific instance of EtcdDataEncryptionProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEtcdDataEncryptionProfile_STATUS(subject EtcdDataEncryptionProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EtcdDataEncryptionProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EtcdDataEncryptionProfile_STATUS instances for property testing - lazily instantiated by
// EtcdDataEncryptionProfile_STATUSGenerator()
var etcdDataEncryptionProfile_STATUSGenerator gopter.Gen

// EtcdDataEncryptionProfile_STATUSGenerator returns a generator of EtcdDataEncryptionProfile_STATUS instances for property testing.
// We first initialize etcdDataEncryptionProfile_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EtcdDataEncryptionProfile_STATUSGenerator() gopter.Gen {
	if etcdDataEncryptionProfile_STATUSGenerator != nil {
		return etcdDataEncryptionProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEtcdDataEncryptionProfile_STATUS(generators)
	etcdDataEncryptionProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(EtcdDataEncryptionProfile_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEtcdDataEncryptionProfile_STATUS(generators)
	AddRelatedPropertyGeneratorsForEtcdDataEncryptionProfile_STATUS(generators)
	etcdDataEncryptionProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(EtcdDataEncryptionProfile_STATUS{}), generators)

	return etcdDataEncryptionProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEtcdDataEncryptionProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEtcdDataEncryptionProfile_STATUS(gens map[string]gopter.Gen) {
	gens["KeyManagementMode"] = gen.PtrOf(gen.OneConstOf(EtcdDataEncryptionProfile_KeyManagementMode_STATUS_CustomerManaged, EtcdDataEncryptionProfile_KeyManagementMode_STATUS_PlatformManaged))
}

// AddRelatedPropertyGeneratorsForEtcdDataEncryptionProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEtcdDataEncryptionProfile_STATUS(gens map[string]gopter.Gen) {
	gens["CustomerManaged"] = gen.PtrOf(CustomerManagedEncryptionProfile_STATUSGenerator())
}

func Test_EtcdProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EtcdProfile to EtcdProfile via AssignProperties_To_EtcdProfile & AssignProperties_From_EtcdProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForEtcdProfile, EtcdProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEtcdProfile tests if a specific instance of EtcdProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEtcdProfile(subject EtcdProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EtcdProfile
	err := copied.AssignProperties_To_EtcdProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EtcdProfile
	err = actual.AssignProperties_From_EtcdProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EtcdProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EtcdProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEtcdProfile, EtcdProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEtcdProfile runs a test to see if a specific instance of EtcdProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForEtcdProfile(subject EtcdProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EtcdProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EtcdProfile instances for property testing - lazily instantiated by EtcdProfileGenerator()
var etcdProfileGenerator gopter.Gen

// EtcdProfileGenerator returns a generator of EtcdProfile instances for property testing.
func EtcdProfileGenerator() gopter.Gen {
	if etcdProfileGenerator != nil {
		return etcdProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEtcdProfile(generators)
	etcdProfileGenerator = gen.Struct(reflect.TypeOf(EtcdProfile{}), generators)

	return etcdProfileGenerator
}

// AddRelatedPropertyGeneratorsForEtcdProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEtcdProfile(gens map[string]gopter.Gen) {
	gens["DataEncryption"] = gen.PtrOf(EtcdDataEncryptionProfileGenerator())
}

func Test_EtcdProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EtcdProfile_STATUS to EtcdProfile_STATUS via AssignProperties_To_EtcdProfile_STATUS & AssignProperties_From_EtcdProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEtcdProfile_STATUS, EtcdProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEtcdProfile_STATUS tests if a specific instance of EtcdProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForEtcdProfile_STATUS(subject EtcdProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.EtcdProfile_STATUS
	err := copied.AssignProperties_To_EtcdProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EtcdProfile_STATUS
	err = actual.AssignProperties_From_EtcdProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EtcdProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EtcdProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEtcdProfile_STATUS, EtcdProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEtcdProfile_STATUS runs a test to see if a specific instance of EtcdProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEtcdProfile_STATUS(subject EtcdProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EtcdProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EtcdProfile_STATUS instances for property testing - lazily instantiated by EtcdProfile_STATUSGenerator()
var etcdProfile_STATUSGenerator gopter.Gen

// EtcdProfile_STATUSGenerator returns a generator of EtcdProfile_STATUS instances for property testing.
func EtcdProfile_STATUSGenerator() gopter.Gen {
	if etcdProfile_STATUSGenerator != nil {
		return etcdProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEtcdProfile_STATUS(generators)
	etcdProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(EtcdProfile_STATUS{}), generators)

	return etcdProfile_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForEtcdProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEtcdProfile_STATUS(gens map[string]gopter.Gen) {
	gens["DataEncryption"] = gen.PtrOf(EtcdDataEncryptionProfile_STATUSGenerator())
}

func Test_HcpOpenShiftCluster_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HcpOpenShiftCluster to hub returns original",
		prop.ForAll(RunResourceConversionTestForHcpOpenShiftCluster, HcpOpenShiftClusterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForHcpOpenShiftCluster tests if a specific instance of HcpOpenShiftCluster round trips to the hub storage version and back losslessly
func RunResourceConversionTestForHcpOpenShiftCluster(subject HcpOpenShiftCluster) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.HcpOpenShiftCluster
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual HcpOpenShiftCluster
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HcpOpenShiftCluster_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HcpOpenShiftCluster to HcpOpenShiftCluster via AssignProperties_To_HcpOpenShiftCluster & AssignProperties_From_HcpOpenShiftCluster returns original",
		prop.ForAll(RunPropertyAssignmentTestForHcpOpenShiftCluster, HcpOpenShiftClusterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHcpOpenShiftCluster tests if a specific instance of HcpOpenShiftCluster can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHcpOpenShiftCluster(subject HcpOpenShiftCluster) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HcpOpenShiftCluster
	err := copied.AssignProperties_To_HcpOpenShiftCluster(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HcpOpenShiftCluster
	err = actual.AssignProperties_From_HcpOpenShiftCluster(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HcpOpenShiftCluster_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HcpOpenShiftCluster via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHcpOpenShiftCluster, HcpOpenShiftClusterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHcpOpenShiftCluster runs a test to see if a specific instance of HcpOpenShiftCluster round trips to JSON and back losslessly
func RunJSONSerializationTestForHcpOpenShiftCluster(subject HcpOpenShiftCluster) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HcpOpenShiftCluster
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HcpOpenShiftCluster instances for property testing - lazily instantiated by
// HcpOpenShiftClusterGenerator()
var hcpOpenShiftClusterGenerator gopter.Gen

// HcpOpenShiftClusterGenerator returns a generator of HcpOpenShiftCluster instances for property testing.
func HcpOpenShiftClusterGenerator() gopter.Gen {
	if hcpOpenShiftClusterGenerator != nil {
		return hcpOpenShiftClusterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForHcpOpenShiftCluster(generators)
	hcpOpenShiftClusterGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftCluster{}), generators)

	return hcpOpenShiftClusterGenerator
}

// AddRelatedPropertyGeneratorsForHcpOpenShiftCluster is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHcpOpenShiftCluster(gens map[string]gopter.Gen) {
	gens["Spec"] = HcpOpenShiftCluster_SpecGenerator()
	gens["Status"] = HcpOpenShiftCluster_STATUSGenerator()
}

func Test_HcpOpenShiftClusterOperatorSecrets_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HcpOpenShiftClusterOperatorSecrets to HcpOpenShiftClusterOperatorSecrets via AssignProperties_To_HcpOpenShiftClusterOperatorSecrets & AssignProperties_From_HcpOpenShiftClusterOperatorSecrets returns original",
		prop.ForAll(RunPropertyAssignmentTestForHcpOpenShiftClusterOperatorSecrets, HcpOpenShiftClusterOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHcpOpenShiftClusterOperatorSecrets tests if a specific instance of HcpOpenShiftClusterOperatorSecrets can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHcpOpenShiftClusterOperatorSecrets(subject HcpOpenShiftClusterOperatorSecrets) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HcpOpenShiftClusterOperatorSecrets
	err := copied.AssignProperties_To_HcpOpenShiftClusterOperatorSecrets(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HcpOpenShiftClusterOperatorSecrets
	err = actual.AssignProperties_From_HcpOpenShiftClusterOperatorSecrets(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HcpOpenShiftClusterOperatorSecrets_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HcpOpenShiftClusterOperatorSecrets via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHcpOpenShiftClusterOperatorSecrets, HcpOpenShiftClusterOperatorSecretsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHcpOpenShiftClusterOperatorSecrets runs a test to see if a specific instance of HcpOpenShiftClusterOperatorSecrets round trips to JSON and back losslessly
func RunJSONSerializationTestForHcpOpenShiftClusterOperatorSecrets(subject HcpOpenShiftClusterOperatorSecrets) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HcpOpenShiftClusterOperatorSecrets
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HcpOpenShiftClusterOperatorSecrets instances for property testing - lazily instantiated by
// HcpOpenShiftClusterOperatorSecretsGenerator()
var hcpOpenShiftClusterOperatorSecretsGenerator gopter.Gen

// HcpOpenShiftClusterOperatorSecretsGenerator returns a generator of HcpOpenShiftClusterOperatorSecrets instances for property testing.
func HcpOpenShiftClusterOperatorSecretsGenerator() gopter.Gen {
	if hcpOpenShiftClusterOperatorSecretsGenerator != nil {
		return hcpOpenShiftClusterOperatorSecretsGenerator
	}

	generators := make(map[string]gopter.Gen)
	hcpOpenShiftClusterOperatorSecretsGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClusterOperatorSecrets{}), generators)

	return hcpOpenShiftClusterOperatorSecretsGenerator
}

func Test_HcpOpenShiftClusterOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HcpOpenShiftClusterOperatorSpec to HcpOpenShiftClusterOperatorSpec via AssignProperties_To_HcpOpenShiftClusterOperatorSpec & AssignProperties_From_HcpOpenShiftClusterOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForHcpOpenShiftClusterOperatorSpec, HcpOpenShiftClusterOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHcpOpenShiftClusterOperatorSpec tests if a specific instance of HcpOpenShiftClusterOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHcpOpenShiftClusterOperatorSpec(subject HcpOpenShiftClusterOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HcpOpenShiftClusterOperatorSpec
	err := copied.AssignProperties_To_HcpOpenShiftClusterOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HcpOpenShiftClusterOperatorSpec
	err = actual.AssignProperties_From_HcpOpenShiftClusterOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HcpOpenShiftClusterOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HcpOpenShiftClusterOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHcpOpenShiftClusterOperatorSpec, HcpOpenShiftClusterOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHcpOpenShiftClusterOperatorSpec runs a test to see if a specific instance of HcpOpenShiftClusterOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForHcpOpenShiftClusterOperatorSpec(subject HcpOpenShiftClusterOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HcpOpenShiftClusterOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HcpOpenShiftClusterOperatorSpec instances for property testing - lazily instantiated by
// HcpOpenShiftClusterOperatorSpecGenerator()
var hcpOpenShiftClusterOperatorSpecGenerator gopter.Gen

// HcpOpenShiftClusterOperatorSpecGenerator returns a generator of HcpOpenShiftClusterOperatorSpec instances for property testing.
func HcpOpenShiftClusterOperatorSpecGenerator() gopter.Gen {
	if hcpOpenShiftClusterOperatorSpecGenerator != nil {
		return hcpOpenShiftClusterOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForHcpOpenShiftClusterOperatorSpec(generators)
	hcpOpenShiftClusterOperatorSpecGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClusterOperatorSpec{}), generators)

	return hcpOpenShiftClusterOperatorSpecGenerator
}

// AddRelatedPropertyGeneratorsForHcpOpenShiftClusterOperatorSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHcpOpenShiftClusterOperatorSpec(gens map[string]gopter.Gen) {
	gens["Secrets"] = gen.PtrOf(HcpOpenShiftClusterOperatorSecretsGenerator())
}

func Test_HcpOpenShiftClusterProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HcpOpenShiftClusterProperties to HcpOpenShiftClusterProperties via AssignProperties_To_HcpOpenShiftClusterProperties & AssignProperties_From_HcpOpenShiftClusterProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForHcpOpenShiftClusterProperties, HcpOpenShiftClusterPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHcpOpenShiftClusterProperties tests if a specific instance of HcpOpenShiftClusterProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHcpOpenShiftClusterProperties(subject HcpOpenShiftClusterProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HcpOpenShiftClusterProperties
	err := copied.AssignProperties_To_HcpOpenShiftClusterProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HcpOpenShiftClusterProperties
	err = actual.AssignProperties_From_HcpOpenShiftClusterProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HcpOpenShiftClusterProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HcpOpenShiftClusterProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHcpOpenShiftClusterProperties, HcpOpenShiftClusterPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHcpOpenShiftClusterProperties runs a test to see if a specific instance of HcpOpenShiftClusterProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForHcpOpenShiftClusterProperties(subject HcpOpenShiftClusterProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HcpOpenShiftClusterProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HcpOpenShiftClusterProperties instances for property testing - lazily instantiated by
// HcpOpenShiftClusterPropertiesGenerator()
var hcpOpenShiftClusterPropertiesGenerator gopter.Gen

// HcpOpenShiftClusterPropertiesGenerator returns a generator of HcpOpenShiftClusterProperties instances for property testing.
// We first initialize hcpOpenShiftClusterPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HcpOpenShiftClusterPropertiesGenerator() gopter.Gen {
	if hcpOpenShiftClusterPropertiesGenerator != nil {
		return hcpOpenShiftClusterPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftClusterProperties(generators)
	hcpOpenShiftClusterPropertiesGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClusterProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftClusterProperties(generators)
	AddRelatedPropertyGeneratorsForHcpOpenShiftClusterProperties(generators)
	hcpOpenShiftClusterPropertiesGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClusterProperties{}), generators)

	return hcpOpenShiftClusterPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForHcpOpenShiftClusterProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHcpOpenShiftClusterProperties(gens map[string]gopter.Gen) {
	gens["NodeDrainTimeoutMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForHcpOpenShiftClusterProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHcpOpenShiftClusterProperties(gens map[string]gopter.Gen) {
	gens["Api"] = gen.PtrOf(ApiProfileGenerator())
	gens["Autoscaling"] = gen.PtrOf(ClusterAutoscalingProfileGenerator())
	gens["ClusterImageRegistry"] = gen.PtrOf(ClusterImageRegistryProfileGenerator())
	gens["Dns"] = gen.PtrOf(DnsProfileGenerator())
	gens["Etcd"] = gen.PtrOf(EtcdProfileGenerator())
	gens["Network"] = gen.PtrOf(NetworkProfileGenerator())
	gens["Platform"] = gen.PtrOf(PlatformProfileGenerator())
	gens["Version"] = gen.PtrOf(VersionProfileGenerator())
}

func Test_HcpOpenShiftClusterProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HcpOpenShiftClusterProperties_STATUS to HcpOpenShiftClusterProperties_STATUS via AssignProperties_To_HcpOpenShiftClusterProperties_STATUS & AssignProperties_From_HcpOpenShiftClusterProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHcpOpenShiftClusterProperties_STATUS, HcpOpenShiftClusterProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHcpOpenShiftClusterProperties_STATUS tests if a specific instance of HcpOpenShiftClusterProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHcpOpenShiftClusterProperties_STATUS(subject HcpOpenShiftClusterProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HcpOpenShiftClusterProperties_STATUS
	err := copied.AssignProperties_To_HcpOpenShiftClusterProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HcpOpenShiftClusterProperties_STATUS
	err = actual.AssignProperties_From_HcpOpenShiftClusterProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HcpOpenShiftClusterProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HcpOpenShiftClusterProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHcpOpenShiftClusterProperties_STATUS, HcpOpenShiftClusterProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHcpOpenShiftClusterProperties_STATUS runs a test to see if a specific instance of HcpOpenShiftClusterProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHcpOpenShiftClusterProperties_STATUS(subject HcpOpenShiftClusterProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HcpOpenShiftClusterProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HcpOpenShiftClusterProperties_STATUS instances for property testing - lazily instantiated by
// HcpOpenShiftClusterProperties_STATUSGenerator()
var hcpOpenShiftClusterProperties_STATUSGenerator gopter.Gen

// HcpOpenShiftClusterProperties_STATUSGenerator returns a generator of HcpOpenShiftClusterProperties_STATUS instances for property testing.
// We first initialize hcpOpenShiftClusterProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HcpOpenShiftClusterProperties_STATUSGenerator() gopter.Gen {
	if hcpOpenShiftClusterProperties_STATUSGenerator != nil {
		return hcpOpenShiftClusterProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftClusterProperties_STATUS(generators)
	hcpOpenShiftClusterProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClusterProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftClusterProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForHcpOpenShiftClusterProperties_STATUS(generators)
	hcpOpenShiftClusterProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClusterProperties_STATUS{}), generators)

	return hcpOpenShiftClusterProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHcpOpenShiftClusterProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHcpOpenShiftClusterProperties_STATUS(gens map[string]gopter.Gen) {
	gens["NodeDrainTimeoutMinutes"] = gen.PtrOf(gen.Int())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ProvisioningState_STATUS_Accepted,
		ProvisioningState_STATUS_Canceled,
		ProvisioningState_STATUS_Deleting,
		ProvisioningState_STATUS_Failed,
		ProvisioningState_STATUS_Provisioning,
		ProvisioningState_STATUS_Succeeded,
		ProvisioningState_STATUS_Updating))
}

// AddRelatedPropertyGeneratorsForHcpOpenShiftClusterProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHcpOpenShiftClusterProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Api"] = gen.PtrOf(ApiProfile_STATUSGenerator())
	gens["Autoscaling"] = gen.PtrOf(ClusterAutoscalingProfile_STATUSGenerator())
	gens["ClusterImageRegistry"] = gen.PtrOf(ClusterImageRegistryProfile_STATUSGenerator())
	gens["Console"] = gen.PtrOf(ConsoleProfile_STATUSGenerator())
	gens["Dns"] = gen.PtrOf(DnsProfile_STATUSGenerator())
	gens["Etcd"] = gen.PtrOf(EtcdProfile_STATUSGenerator())
	gens["Network"] = gen.PtrOf(NetworkProfile_STATUSGenerator())
	gens["Platform"] = gen.PtrOf(PlatformProfile_STATUSGenerator())
	gens["Version"] = gen.PtrOf(VersionProfile_STATUSGenerator())
}

func Test_HcpOpenShiftCluster_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HcpOpenShiftCluster_STATUS to HcpOpenShiftCluster_STATUS via AssignProperties_To_HcpOpenShiftCluster_STATUS & AssignProperties_From_HcpOpenShiftCluster_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHcpOpenShiftCluster_STATUS, HcpOpenShiftCluster_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHcpOpenShiftCluster_STATUS tests if a specific instance of HcpOpenShiftCluster_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHcpOpenShiftCluster_STATUS(subject HcpOpenShiftCluster_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HcpOpenShiftCluster_STATUS
	err := copied.AssignProperties_To_HcpOpenShiftCluster_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HcpOpenShiftCluster_STATUS
	err = actual.AssignProperties_From_HcpOpenShiftCluster_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HcpOpenShiftCluster_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HcpOpenShiftCluster_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHcpOpenShiftCluster_STATUS, HcpOpenShiftCluster_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHcpOpenShiftCluster_STATUS runs a test to see if a specific instance of HcpOpenShiftCluster_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHcpOpenShiftCluster_STATUS(subject HcpOpenShiftCluster_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HcpOpenShiftCluster_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HcpOpenShiftCluster_STATUS instances for property testing - lazily instantiated by
// HcpOpenShiftCluster_STATUSGenerator()
var hcpOpenShiftCluster_STATUSGenerator gopter.Gen

// HcpOpenShiftCluster_STATUSGenerator returns a generator of HcpOpenShiftCluster_STATUS instances for property testing.
// We first initialize hcpOpenShiftCluster_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HcpOpenShiftCluster_STATUSGenerator() gopter.Gen {
	if hcpOpenShiftCluster_STATUSGenerator != nil {
		return hcpOpenShiftCluster_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftCluster_STATUS(generators)
	hcpOpenShiftCluster_STATUSGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftCluster_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftCluster_STATUS(generators)
	AddRelatedPropertyGeneratorsForHcpOpenShiftCluster_STATUS(generators)
	hcpOpenShiftCluster_STATUSGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftCluster_STATUS{}), generators)

	return hcpOpenShiftCluster_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHcpOpenShiftCluster_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHcpOpenShiftCluster_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHcpOpenShiftCluster_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHcpOpenShiftCluster_STATUS(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_STATUSGenerator())
	gens["Properties"] = gen.PtrOf(HcpOpenShiftClusterProperties_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_HcpOpenShiftCluster_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HcpOpenShiftCluster_Spec to HcpOpenShiftCluster_Spec via AssignProperties_To_HcpOpenShiftCluster_Spec & AssignProperties_From_HcpOpenShiftCluster_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForHcpOpenShiftCluster_Spec, HcpOpenShiftCluster_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHcpOpenShiftCluster_Spec tests if a specific instance of HcpOpenShiftCluster_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHcpOpenShiftCluster_Spec(subject HcpOpenShiftCluster_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HcpOpenShiftCluster_Spec
	err := copied.AssignProperties_To_HcpOpenShiftCluster_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HcpOpenShiftCluster_Spec
	err = actual.AssignProperties_From_HcpOpenShiftCluster_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HcpOpenShiftCluster_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HcpOpenShiftCluster_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHcpOpenShiftCluster_Spec, HcpOpenShiftCluster_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHcpOpenShiftCluster_Spec runs a test to see if a specific instance of HcpOpenShiftCluster_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForHcpOpenShiftCluster_Spec(subject HcpOpenShiftCluster_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HcpOpenShiftCluster_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HcpOpenShiftCluster_Spec instances for property testing - lazily instantiated by
// HcpOpenShiftCluster_SpecGenerator()
var hcpOpenShiftCluster_SpecGenerator gopter.Gen

// HcpOpenShiftCluster_SpecGenerator returns a generator of HcpOpenShiftCluster_Spec instances for property testing.
// We first initialize hcpOpenShiftCluster_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HcpOpenShiftCluster_SpecGenerator() gopter.Gen {
	if hcpOpenShiftCluster_SpecGenerator != nil {
		return hcpOpenShiftCluster_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftCluster_Spec(generators)
	hcpOpenShiftCluster_SpecGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftCluster_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftCluster_Spec(generators)
	AddRelatedPropertyGeneratorsForHcpOpenShiftCluster_Spec(generators)
	hcpOpenShiftCluster_SpecGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftCluster_Spec{}), generators)

	return hcpOpenShiftCluster_SpecGenerator
}

// AddIndependentPropertyGeneratorsForHcpOpenShiftCluster_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHcpOpenShiftCluster_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHcpOpenShiftCluster_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHcpOpenShiftCluster_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["OperatorSpec"] = gen.PtrOf(HcpOpenShiftClusterOperatorSpecGenerator())
	gens["Properties"] = gen.PtrOf(HcpOpenShiftClusterPropertiesGenerator())
}

func Test_KmsEncryptionProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KmsEncryptionProfile to KmsEncryptionProfile via AssignProperties_To_KmsEncryptionProfile & AssignProperties_From_KmsEncryptionProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForKmsEncryptionProfile, KmsEncryptionProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKmsEncryptionProfile tests if a specific instance of KmsEncryptionProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKmsEncryptionProfile(subject KmsEncryptionProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.KmsEncryptionProfile
	err := copied.AssignProperties_To_KmsEncryptionProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KmsEncryptionProfile
	err = actual.AssignProperties_From_KmsEncryptionProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KmsEncryptionProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KmsEncryptionProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKmsEncryptionProfile, KmsEncryptionProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKmsEncryptionProfile runs a test to see if a specific instance of KmsEncryptionProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForKmsEncryptionProfile(subject KmsEncryptionProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KmsEncryptionProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KmsEncryptionProfile instances for property testing - lazily instantiated by
// KmsEncryptionProfileGenerator()
var kmsEncryptionProfileGenerator gopter.Gen

// KmsEncryptionProfileGenerator returns a generator of KmsEncryptionProfile instances for property testing.
func KmsEncryptionProfileGenerator() gopter.Gen {
	if kmsEncryptionProfileGenerator != nil {
		return kmsEncryptionProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForKmsEncryptionProfile(generators)
	kmsEncryptionProfileGenerator = gen.Struct(reflect.TypeOf(KmsEncryptionProfile{}), generators)

	return kmsEncryptionProfileGenerator
}

// AddRelatedPropertyGeneratorsForKmsEncryptionProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKmsEncryptionProfile(gens map[string]gopter.Gen) {
	gens["ActiveKey"] = gen.PtrOf(KmsKeyGenerator())
}

func Test_KmsEncryptionProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KmsEncryptionProfile_STATUS to KmsEncryptionProfile_STATUS via AssignProperties_To_KmsEncryptionProfile_STATUS & AssignProperties_From_KmsEncryptionProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKmsEncryptionProfile_STATUS, KmsEncryptionProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKmsEncryptionProfile_STATUS tests if a specific instance of KmsEncryptionProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKmsEncryptionProfile_STATUS(subject KmsEncryptionProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.KmsEncryptionProfile_STATUS
	err := copied.AssignProperties_To_KmsEncryptionProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KmsEncryptionProfile_STATUS
	err = actual.AssignProperties_From_KmsEncryptionProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KmsEncryptionProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KmsEncryptionProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKmsEncryptionProfile_STATUS, KmsEncryptionProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKmsEncryptionProfile_STATUS runs a test to see if a specific instance of KmsEncryptionProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKmsEncryptionProfile_STATUS(subject KmsEncryptionProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KmsEncryptionProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KmsEncryptionProfile_STATUS instances for property testing - lazily instantiated by
// KmsEncryptionProfile_STATUSGenerator()
var kmsEncryptionProfile_STATUSGenerator gopter.Gen

// KmsEncryptionProfile_STATUSGenerator returns a generator of KmsEncryptionProfile_STATUS instances for property testing.
func KmsEncryptionProfile_STATUSGenerator() gopter.Gen {
	if kmsEncryptionProfile_STATUSGenerator != nil {
		return kmsEncryptionProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForKmsEncryptionProfile_STATUS(generators)
	kmsEncryptionProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(KmsEncryptionProfile_STATUS{}), generators)

	return kmsEncryptionProfile_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForKmsEncryptionProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKmsEncryptionProfile_STATUS(gens map[string]gopter.Gen) {
	gens["ActiveKey"] = gen.PtrOf(KmsKey_STATUSGenerator())
}

func Test_KmsKey_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KmsKey to KmsKey via AssignProperties_To_KmsKey & AssignProperties_From_KmsKey returns original",
		prop.ForAll(RunPropertyAssignmentTestForKmsKey, KmsKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKmsKey tests if a specific instance of KmsKey can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKmsKey(subject KmsKey) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.KmsKey
	err := copied.AssignProperties_To_KmsKey(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KmsKey
	err = actual.AssignProperties_From_KmsKey(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KmsKey_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KmsKey via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKmsKey, KmsKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKmsKey runs a test to see if a specific instance of KmsKey round trips to JSON and back losslessly
func RunJSONSerializationTestForKmsKey(subject KmsKey) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KmsKey
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KmsKey instances for property testing - lazily instantiated by KmsKeyGenerator()
var kmsKeyGenerator gopter.Gen

// KmsKeyGenerator returns a generator of KmsKey instances for property testing.
func KmsKeyGenerator() gopter.Gen {
	if kmsKeyGenerator != nil {
		return kmsKeyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKmsKey(generators)
	kmsKeyGenerator = gen.Struct(reflect.TypeOf(KmsKey{}), generators)

	return kmsKeyGenerator
}

// AddIndependentPropertyGeneratorsForKmsKey is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKmsKey(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["VaultName"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_KmsKey_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KmsKey_STATUS to KmsKey_STATUS via AssignProperties_To_KmsKey_STATUS & AssignProperties_From_KmsKey_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKmsKey_STATUS, KmsKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKmsKey_STATUS tests if a specific instance of KmsKey_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForKmsKey_STATUS(subject KmsKey_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.KmsKey_STATUS
	err := copied.AssignProperties_To_KmsKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KmsKey_STATUS
	err = actual.AssignProperties_From_KmsKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KmsKey_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KmsKey_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKmsKey_STATUS, KmsKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKmsKey_STATUS runs a test to see if a specific instance of KmsKey_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKmsKey_STATUS(subject KmsKey_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KmsKey_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KmsKey_STATUS instances for property testing - lazily instantiated by KmsKey_STATUSGenerator()
var kmsKey_STATUSGenerator gopter.Gen

// KmsKey_STATUSGenerator returns a generator of KmsKey_STATUS instances for property testing.
func KmsKey_STATUSGenerator() gopter.Gen {
	if kmsKey_STATUSGenerator != nil {
		return kmsKey_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKmsKey_STATUS(generators)
	kmsKey_STATUSGenerator = gen.Struct(reflect.TypeOf(KmsKey_STATUS{}), generators)

	return kmsKey_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKmsKey_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKmsKey_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["VaultName"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity to ManagedServiceIdentity via AssignProperties_To_ManagedServiceIdentity & AssignProperties_From_ManagedServiceIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity tests if a specific instance of ManagedServiceIdentity can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedServiceIdentity
	err := copied.AssignProperties_To_ManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity
	err = actual.AssignProperties_From_ManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity runs a test to see if a specific instance of ManagedServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity instances for property testing - lazily instantiated by
// ManagedServiceIdentityGenerator()
var managedServiceIdentityGenerator gopter.Gen

// ManagedServiceIdentityGenerator returns a generator of ManagedServiceIdentity instances for property testing.
// We first initialize managedServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityGenerator() gopter.Gen {
	if managedServiceIdentityGenerator != nil {
		return managedServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	return managedServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityType_None,
		ManagedServiceIdentityType_SystemAssigned,
		ManagedServiceIdentityType_SystemAssignedUserAssigned,
		ManagedServiceIdentityType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(UserAssignedIdentityDetailsGenerator())
}

func Test_ManagedServiceIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_STATUS to ManagedServiceIdentity_STATUS via AssignProperties_To_ManagedServiceIdentity_STATUS & AssignProperties_From_ManagedServiceIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity_STATUS tests if a specific instance of ManagedServiceIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ManagedServiceIdentity_STATUS
	err := copied.AssignProperties_To_ManagedServiceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_STATUS
	err = actual.AssignProperties_From_ManagedServiceIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_STATUS, ManagedServiceIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_STATUS runs a test to see if a specific instance of ManagedServiceIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_STATUS(subject ManagedServiceIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_STATUS instances for property testing - lazily instantiated by
// ManagedServiceIdentity_STATUSGenerator()
var managedServiceIdentity_STATUSGenerator gopter.Gen

// ManagedServiceIdentity_STATUSGenerator returns a generator of ManagedServiceIdentity_STATUS instances for property testing.
// We first initialize managedServiceIdentity_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_STATUSGenerator() gopter.Gen {
	if managedServiceIdentity_STATUSGenerator != nil {
		return managedServiceIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(generators)
	managedServiceIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS{}), generators)

	return managedServiceIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityType_STATUS_None,
		ManagedServiceIdentityType_STATUS_SystemAssigned,
		ManagedServiceIdentityType_STATUS_SystemAssignedUserAssigned,
		ManagedServiceIdentityType_STATUS_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentity_STATUSGenerator())
}

func Test_NetworkProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkProfile to NetworkProfile via AssignProperties_To_NetworkProfile & AssignProperties_From_NetworkProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkProfile, NetworkProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkProfile tests if a specific instance of NetworkProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNetworkProfile(subject NetworkProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NetworkProfile
	err := copied.AssignProperties_To_NetworkProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkProfile
	err = actual.AssignProperties_From_NetworkProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile, NetworkProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile runs a test to see if a specific instance of NetworkProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile(subject NetworkProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile instances for property testing - lazily instantiated by NetworkProfileGenerator()
var networkProfileGenerator gopter.Gen

// NetworkProfileGenerator returns a generator of NetworkProfile instances for property testing.
func NetworkProfileGenerator() gopter.Gen {
	if networkProfileGenerator != nil {
		return networkProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfile(generators)
	networkProfileGenerator = gen.Struct(reflect.TypeOf(NetworkProfile{}), generators)

	return networkProfileGenerator
}

// AddIndependentPropertyGeneratorsForNetworkProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkProfile(gens map[string]gopter.Gen) {
	gens["HostPrefix"] = gen.PtrOf(gen.Int())
	gens["MachineCidr"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkType"] = gen.PtrOf(gen.OneConstOf(NetworkProfile_NetworkType_OVNKubernetes, NetworkProfile_NetworkType_Other))
	gens["PodCidr"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceCidr"] = gen.PtrOf(gen.AlphaString())
}

func Test_NetworkProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from NetworkProfile_STATUS to NetworkProfile_STATUS via AssignProperties_To_NetworkProfile_STATUS & AssignProperties_From_NetworkProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForNetworkProfile_STATUS, NetworkProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForNetworkProfile_STATUS tests if a specific instance of NetworkProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForNetworkProfile_STATUS(subject NetworkProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.NetworkProfile_STATUS
	err := copied.AssignProperties_To_NetworkProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual NetworkProfile_STATUS
	err = actual.AssignProperties_From_NetworkProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_NetworkProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile_STATUS, NetworkProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile_STATUS runs a test to see if a specific instance of NetworkProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile_STATUS(subject NetworkProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile_STATUS instances for property testing - lazily instantiated by
// NetworkProfile_STATUSGenerator()
var networkProfile_STATUSGenerator gopter.Gen

// NetworkProfile_STATUSGenerator returns a generator of NetworkProfile_STATUS instances for property testing.
func NetworkProfile_STATUSGenerator() gopter.Gen {
	if networkProfile_STATUSGenerator != nil {
		return networkProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfile_STATUS(generators)
	networkProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(NetworkProfile_STATUS{}), generators)

	return networkProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForNetworkProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkProfile_STATUS(gens map[string]gopter.Gen) {
	gens["HostPrefix"] = gen.PtrOf(gen.Int())
	gens["MachineCidr"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkType"] = gen.PtrOf(gen.OneConstOf(NetworkProfile_NetworkType_STATUS_OVNKubernetes, NetworkProfile_NetworkType_STATUS_Other))
	gens["PodCidr"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceCidr"] = gen.PtrOf(gen.AlphaString())
}

func Test_OperatorsAuthenticationProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OperatorsAuthenticationProfile to OperatorsAuthenticationProfile via AssignProperties_To_OperatorsAuthenticationProfile & AssignProperties_From_OperatorsAuthenticationProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForOperatorsAuthenticationProfile, OperatorsAuthenticationProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOperatorsAuthenticationProfile tests if a specific instance of OperatorsAuthenticationProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForOperatorsAuthenticationProfile(subject OperatorsAuthenticationProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.OperatorsAuthenticationProfile
	err := copied.AssignProperties_To_OperatorsAuthenticationProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OperatorsAuthenticationProfile
	err = actual.AssignProperties_From_OperatorsAuthenticationProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OperatorsAuthenticationProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OperatorsAuthenticationProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOperatorsAuthenticationProfile, OperatorsAuthenticationProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOperatorsAuthenticationProfile runs a test to see if a specific instance of OperatorsAuthenticationProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForOperatorsAuthenticationProfile(subject OperatorsAuthenticationProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OperatorsAuthenticationProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OperatorsAuthenticationProfile instances for property testing - lazily instantiated by
// OperatorsAuthenticationProfileGenerator()
var operatorsAuthenticationProfileGenerator gopter.Gen

// OperatorsAuthenticationProfileGenerator returns a generator of OperatorsAuthenticationProfile instances for property testing.
func OperatorsAuthenticationProfileGenerator() gopter.Gen {
	if operatorsAuthenticationProfileGenerator != nil {
		return operatorsAuthenticationProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForOperatorsAuthenticationProfile(generators)
	operatorsAuthenticationProfileGenerator = gen.Struct(reflect.TypeOf(OperatorsAuthenticationProfile{}), generators)

	return operatorsAuthenticationProfileGenerator
}

// AddRelatedPropertyGeneratorsForOperatorsAuthenticationProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOperatorsAuthenticationProfile(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.PtrOf(UserAssignedIdentitiesProfileGenerator())
}

func Test_OperatorsAuthenticationProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OperatorsAuthenticationProfile_STATUS to OperatorsAuthenticationProfile_STATUS via AssignProperties_To_OperatorsAuthenticationProfile_STATUS & AssignProperties_From_OperatorsAuthenticationProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForOperatorsAuthenticationProfile_STATUS, OperatorsAuthenticationProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOperatorsAuthenticationProfile_STATUS tests if a specific instance of OperatorsAuthenticationProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForOperatorsAuthenticationProfile_STATUS(subject OperatorsAuthenticationProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.OperatorsAuthenticationProfile_STATUS
	err := copied.AssignProperties_To_OperatorsAuthenticationProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OperatorsAuthenticationProfile_STATUS
	err = actual.AssignProperties_From_OperatorsAuthenticationProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OperatorsAuthenticationProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OperatorsAuthenticationProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOperatorsAuthenticationProfile_STATUS, OperatorsAuthenticationProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOperatorsAuthenticationProfile_STATUS runs a test to see if a specific instance of OperatorsAuthenticationProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForOperatorsAuthenticationProfile_STATUS(subject OperatorsAuthenticationProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OperatorsAuthenticationProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OperatorsAuthenticationProfile_STATUS instances for property testing - lazily instantiated by
// OperatorsAuthenticationProfile_STATUSGenerator()
var operatorsAuthenticationProfile_STATUSGenerator gopter.Gen

// OperatorsAuthenticationProfile_STATUSGenerator returns a generator of OperatorsAuthenticationProfile_STATUS instances for property testing.
func OperatorsAuthenticationProfile_STATUSGenerator() gopter.Gen {
	if operatorsAuthenticationProfile_STATUSGenerator != nil {
		return operatorsAuthenticationProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForOperatorsAuthenticationProfile_STATUS(generators)
	operatorsAuthenticationProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(OperatorsAuthenticationProfile_STATUS{}), generators)

	return operatorsAuthenticationProfile_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForOperatorsAuthenticationProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOperatorsAuthenticationProfile_STATUS(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.PtrOf(UserAssignedIdentitiesProfile_STATUSGenerator())
}

func Test_PlatformProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PlatformProfile to PlatformProfile via AssignProperties_To_PlatformProfile & AssignProperties_From_PlatformProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForPlatformProfile, PlatformProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPlatformProfile tests if a specific instance of PlatformProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPlatformProfile(subject PlatformProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PlatformProfile
	err := copied.AssignProperties_To_PlatformProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PlatformProfile
	err = actual.AssignProperties_From_PlatformProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PlatformProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PlatformProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlatformProfile, PlatformProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlatformProfile runs a test to see if a specific instance of PlatformProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForPlatformProfile(subject PlatformProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PlatformProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PlatformProfile instances for property testing - lazily instantiated by PlatformProfileGenerator()
var platformProfileGenerator gopter.Gen

// PlatformProfileGenerator returns a generator of PlatformProfile instances for property testing.
// We first initialize platformProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PlatformProfileGenerator() gopter.Gen {
	if platformProfileGenerator != nil {
		return platformProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlatformProfile(generators)
	platformProfileGenerator = gen.Struct(reflect.TypeOf(PlatformProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlatformProfile(generators)
	AddRelatedPropertyGeneratorsForPlatformProfile(generators)
	platformProfileGenerator = gen.Struct(reflect.TypeOf(PlatformProfile{}), generators)

	return platformProfileGenerator
}

// AddIndependentPropertyGeneratorsForPlatformProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlatformProfile(gens map[string]gopter.Gen) {
	gens["ManagedResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["OutboundType"] = gen.PtrOf(gen.OneConstOf(PlatformProfile_OutboundType_LoadBalancer))
}

// AddRelatedPropertyGeneratorsForPlatformProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPlatformProfile(gens map[string]gopter.Gen) {
	gens["OperatorsAuthentication"] = gen.PtrOf(OperatorsAuthenticationProfileGenerator())
}

func Test_PlatformProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PlatformProfile_STATUS to PlatformProfile_STATUS via AssignProperties_To_PlatformProfile_STATUS & AssignProperties_From_PlatformProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPlatformProfile_STATUS, PlatformProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPlatformProfile_STATUS tests if a specific instance of PlatformProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPlatformProfile_STATUS(subject PlatformProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PlatformProfile_STATUS
	err := copied.AssignProperties_To_PlatformProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PlatformProfile_STATUS
	err = actual.AssignProperties_From_PlatformProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PlatformProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PlatformProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlatformProfile_STATUS, PlatformProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlatformProfile_STATUS runs a test to see if a specific instance of PlatformProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPlatformProfile_STATUS(subject PlatformProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PlatformProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PlatformProfile_STATUS instances for property testing - lazily instantiated by
// PlatformProfile_STATUSGenerator()
var platformProfile_STATUSGenerator gopter.Gen

// PlatformProfile_STATUSGenerator returns a generator of PlatformProfile_STATUS instances for property testing.
// We first initialize platformProfile_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PlatformProfile_STATUSGenerator() gopter.Gen {
	if platformProfile_STATUSGenerator != nil {
		return platformProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlatformProfile_STATUS(generators)
	platformProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(PlatformProfile_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlatformProfile_STATUS(generators)
	AddRelatedPropertyGeneratorsForPlatformProfile_STATUS(generators)
	platformProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(PlatformProfile_STATUS{}), generators)

	return platformProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPlatformProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlatformProfile_STATUS(gens map[string]gopter.Gen) {
	gens["IssuerUrl"] = gen.PtrOf(gen.AlphaString())
	gens["ManagedResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkSecurityGroupId"] = gen.PtrOf(gen.AlphaString())
	gens["OutboundType"] = gen.PtrOf(gen.OneConstOf(PlatformProfile_OutboundType_STATUS_LoadBalancer))
	gens["SubnetId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPlatformProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPlatformProfile_STATUS(gens map[string]gopter.Gen) {
	gens["OperatorsAuthentication"] = gen.PtrOf(OperatorsAuthenticationProfile_STATUSGenerator())
}

func Test_SystemData_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SystemData_STATUS to SystemData_STATUS via AssignProperties_To_SystemData_STATUS & AssignProperties_From_SystemData_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSystemData_STATUS tests if a specific instance of SystemData_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.SystemData_STATUS
	err := copied.AssignProperties_To_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SystemData_STATUS
	err = actual.AssignProperties_From_SystemData_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SystemData_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SystemData_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSystemData_STATUS, SystemData_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSystemData_STATUS runs a test to see if a specific instance of SystemData_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSystemData_STATUS(subject SystemData_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SystemData_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SystemData_STATUS instances for property testing - lazily instantiated by SystemData_STATUSGenerator()
var systemData_STATUSGenerator gopter.Gen

// SystemData_STATUSGenerator returns a generator of SystemData_STATUS instances for property testing.
func SystemData_STATUSGenerator() gopter.Gen {
	if systemData_STATUSGenerator != nil {
		return systemData_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSystemData_STATUS(generators)
	systemData_STATUSGenerator = gen.Struct(reflect.TypeOf(SystemData_STATUS{}), generators)

	return systemData_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSystemData_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSystemData_STATUS(gens map[string]gopter.Gen) {
	gens["CreatedAt"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedBy"] = gen.PtrOf(gen.AlphaString())
	gens["CreatedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_CreatedByType_STATUS_Application,
		SystemData_CreatedByType_STATUS_Key,
		SystemData_CreatedByType_STATUS_ManagedIdentity,
		SystemData_CreatedByType_STATUS_User))
	gens["LastModifiedAt"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedBy"] = gen.PtrOf(gen.AlphaString())
	gens["LastModifiedByType"] = gen.PtrOf(gen.OneConstOf(
		SystemData_LastModifiedByType_STATUS_Application,
		SystemData_LastModifiedByType_STATUS_Key,
		SystemData_LastModifiedByType_STATUS_ManagedIdentity,
		SystemData_LastModifiedByType_STATUS_User))
}

func Test_UserAssignedIdentitiesProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentitiesProfile to UserAssignedIdentitiesProfile via AssignProperties_To_UserAssignedIdentitiesProfile & AssignProperties_From_UserAssignedIdentitiesProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentitiesProfile, UserAssignedIdentitiesProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentitiesProfile tests if a specific instance of UserAssignedIdentitiesProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentitiesProfile(subject UserAssignedIdentitiesProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserAssignedIdentitiesProfile
	err := copied.AssignProperties_To_UserAssignedIdentitiesProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentitiesProfile
	err = actual.AssignProperties_From_UserAssignedIdentitiesProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentitiesProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentitiesProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentitiesProfile, UserAssignedIdentitiesProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentitiesProfile runs a test to see if a specific instance of UserAssignedIdentitiesProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentitiesProfile(subject UserAssignedIdentitiesProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentitiesProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentitiesProfile instances for property testing - lazily instantiated by
// UserAssignedIdentitiesProfileGenerator()
var userAssignedIdentitiesProfileGenerator gopter.Gen

// UserAssignedIdentitiesProfileGenerator returns a generator of UserAssignedIdentitiesProfile instances for property testing.
func UserAssignedIdentitiesProfileGenerator() gopter.Gen {
	if userAssignedIdentitiesProfileGenerator != nil {
		return userAssignedIdentitiesProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentitiesProfileGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentitiesProfile{}), generators)

	return userAssignedIdentitiesProfileGenerator
}

func Test_UserAssignedIdentitiesProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentitiesProfile_STATUS to UserAssignedIdentitiesProfile_STATUS via AssignProperties_To_UserAssignedIdentitiesProfile_STATUS & AssignProperties_From_UserAssignedIdentitiesProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentitiesProfile_STATUS, UserAssignedIdentitiesProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentitiesProfile_STATUS tests if a specific instance of UserAssignedIdentitiesProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentitiesProfile_STATUS(subject UserAssignedIdentitiesProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserAssignedIdentitiesProfile_STATUS
	err := copied.AssignProperties_To_UserAssignedIdentitiesProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentitiesProfile_STATUS
	err = actual.AssignProperties_From_UserAssignedIdentitiesProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentitiesProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentitiesProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentitiesProfile_STATUS, UserAssignedIdentitiesProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentitiesProfile_STATUS runs a test to see if a specific instance of UserAssignedIdentitiesProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentitiesProfile_STATUS(subject UserAssignedIdentitiesProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentitiesProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentitiesProfile_STATUS instances for property testing - lazily instantiated by
// UserAssignedIdentitiesProfile_STATUSGenerator()
var userAssignedIdentitiesProfile_STATUSGenerator gopter.Gen

// UserAssignedIdentitiesProfile_STATUSGenerator returns a generator of UserAssignedIdentitiesProfile_STATUS instances for property testing.
func UserAssignedIdentitiesProfile_STATUSGenerator() gopter.Gen {
	if userAssignedIdentitiesProfile_STATUSGenerator != nil {
		return userAssignedIdentitiesProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentitiesProfile_STATUS(generators)
	userAssignedIdentitiesProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentitiesProfile_STATUS{}), generators)

	return userAssignedIdentitiesProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentitiesProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentitiesProfile_STATUS(gens map[string]gopter.Gen) {
	gens["ControlPlaneOperators"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["DataPlaneOperators"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ServiceManagedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentityDetails_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentityDetails to UserAssignedIdentityDetails via AssignProperties_To_UserAssignedIdentityDetails & AssignProperties_From_UserAssignedIdentityDetails returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentityDetails tests if a specific instance of UserAssignedIdentityDetails can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserAssignedIdentityDetails
	err := copied.AssignProperties_To_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentityDetails
	err = actual.AssignProperties_From_UserAssignedIdentityDetails(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_UserAssignedIdentity_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UserAssignedIdentity_STATUS to UserAssignedIdentity_STATUS via AssignProperties_To_UserAssignedIdentity_STATUS & AssignProperties_From_UserAssignedIdentity_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUserAssignedIdentity_STATUS, UserAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUserAssignedIdentity_STATUS tests if a specific instance of UserAssignedIdentity_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUserAssignedIdentity_STATUS(subject UserAssignedIdentity_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UserAssignedIdentity_STATUS
	err := copied.AssignProperties_To_UserAssignedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UserAssignedIdentity_STATUS
	err = actual.AssignProperties_From_UserAssignedIdentity_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UserAssignedIdentity_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentity_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentity_STATUS, UserAssignedIdentity_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentity_STATUS runs a test to see if a specific instance of UserAssignedIdentity_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentity_STATUS(subject UserAssignedIdentity_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentity_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentity_STATUS instances for property testing - lazily instantiated by
// UserAssignedIdentity_STATUSGenerator()
var userAssignedIdentity_STATUSGenerator gopter.Gen

// UserAssignedIdentity_STATUSGenerator returns a generator of UserAssignedIdentity_STATUS instances for property testing.
func UserAssignedIdentity_STATUSGenerator() gopter.Gen {
	if userAssignedIdentity_STATUSGenerator != nil {
		return userAssignedIdentity_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(generators)
	userAssignedIdentity_STATUSGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentity_STATUS{}), generators)

	return userAssignedIdentity_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentity_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VersionProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VersionProfile to VersionProfile via AssignProperties_To_VersionProfile & AssignProperties_From_VersionProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForVersionProfile, VersionProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVersionProfile tests if a specific instance of VersionProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVersionProfile(subject VersionProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.VersionProfile
	err := copied.AssignProperties_To_VersionProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VersionProfile
	err = actual.AssignProperties_From_VersionProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VersionProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VersionProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVersionProfile, VersionProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVersionProfile runs a test to see if a specific instance of VersionProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForVersionProfile(subject VersionProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VersionProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VersionProfile instances for property testing - lazily instantiated by VersionProfileGenerator()
var versionProfileGenerator gopter.Gen

// VersionProfileGenerator returns a generator of VersionProfile instances for property testing.
func VersionProfileGenerator() gopter.Gen {
	if versionProfileGenerator != nil {
		return versionProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVersionProfile(generators)
	versionProfileGenerator = gen.Struct(reflect.TypeOf(VersionProfile{}), generators)

	return versionProfileGenerator
}

// AddIndependentPropertyGeneratorsForVersionProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVersionProfile(gens map[string]gopter.Gen) {
	gens["ChannelGroup"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VersionProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VersionProfile_STATUS to VersionProfile_STATUS via AssignProperties_To_VersionProfile_STATUS & AssignProperties_From_VersionProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForVersionProfile_STATUS, VersionProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVersionProfile_STATUS tests if a specific instance of VersionProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForVersionProfile_STATUS(subject VersionProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.VersionProfile_STATUS
	err := copied.AssignProperties_To_VersionProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VersionProfile_STATUS
	err = actual.AssignProperties_From_VersionProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VersionProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VersionProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVersionProfile_STATUS, VersionProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVersionProfile_STATUS runs a test to see if a specific instance of VersionProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForVersionProfile_STATUS(subject VersionProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VersionProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VersionProfile_STATUS instances for property testing - lazily instantiated by
// VersionProfile_STATUSGenerator()
var versionProfile_STATUSGenerator gopter.Gen

// VersionProfile_STATUSGenerator returns a generator of VersionProfile_STATUS instances for property testing.
func VersionProfile_STATUSGenerator() gopter.Gen {
	if versionProfile_STATUSGenerator != nil {
		return versionProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVersionProfile_STATUS(generators)
	versionProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(VersionProfile_STATUS{}), generators)

	return versionProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForVersionProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVersionProfile_STATUS(gens map[string]gopter.Gen) {
	gens["ChannelGroup"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
