// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240610preview

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/redhatopenshift/v1api20240610preview/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/redhatopenshift/v1api20240610preview/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,redhatopenshift}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /redhatopenshift/resource-manager/Microsoft.RedHatOpenShift/hcpclusters/preview/2024-06-10-preview/openapi.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RedHatOpenShift/hcpOpenShiftClusters/{hcpOpenShiftClusterName}/nodePools/{nodePoolName}
type HcpOpenShiftClustersNodePool struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              HcpOpenShiftClustersNodePool_Spec   `json:"spec,omitempty"`
	Status            HcpOpenShiftClustersNodePool_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &HcpOpenShiftClustersNodePool{}

// GetConditions returns the conditions of the resource
func (pool *HcpOpenShiftClustersNodePool) GetConditions() conditions.Conditions {
	return pool.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (pool *HcpOpenShiftClustersNodePool) SetConditions(conditions conditions.Conditions) {
	pool.Status.Conditions = conditions
}

var _ conversion.Convertible = &HcpOpenShiftClustersNodePool{}

// ConvertFrom populates our HcpOpenShiftClustersNodePool from the provided hub HcpOpenShiftClustersNodePool
func (pool *HcpOpenShiftClustersNodePool) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.HcpOpenShiftClustersNodePool)
	if !ok {
		return fmt.Errorf("expected redhatopenshift/v1api20240610preview/storage/HcpOpenShiftClustersNodePool but received %T instead", hub)
	}

	return pool.AssignProperties_From_HcpOpenShiftClustersNodePool(source)
}

// ConvertTo populates the provided hub HcpOpenShiftClustersNodePool from our HcpOpenShiftClustersNodePool
func (pool *HcpOpenShiftClustersNodePool) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.HcpOpenShiftClustersNodePool)
	if !ok {
		return fmt.Errorf("expected redhatopenshift/v1api20240610preview/storage/HcpOpenShiftClustersNodePool but received %T instead", hub)
	}

	return pool.AssignProperties_To_HcpOpenShiftClustersNodePool(destination)
}

var _ configmaps.Exporter = &HcpOpenShiftClustersNodePool{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (pool *HcpOpenShiftClustersNodePool) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if pool.Spec.OperatorSpec == nil {
		return nil
	}
	return pool.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &HcpOpenShiftClustersNodePool{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (pool *HcpOpenShiftClustersNodePool) SecretDestinationExpressions() []*core.DestinationExpression {
	if pool.Spec.OperatorSpec == nil {
		return nil
	}
	return pool.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &HcpOpenShiftClustersNodePool{}

// InitializeSpec initializes the spec for this resource from the given status
func (pool *HcpOpenShiftClustersNodePool) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*HcpOpenShiftClustersNodePool_STATUS); ok {
		return pool.Spec.Initialize_From_HcpOpenShiftClustersNodePool_STATUS(s)
	}

	return fmt.Errorf("expected Status of type HcpOpenShiftClustersNodePool_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &HcpOpenShiftClustersNodePool{}

// AzureName returns the Azure name of the resource
func (pool *HcpOpenShiftClustersNodePool) AzureName() string {
	return pool.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-06-10-preview"
func (pool HcpOpenShiftClustersNodePool) GetAPIVersion() string {
	return "2024-06-10-preview"
}

// GetResourceScope returns the scope of the resource
func (pool *HcpOpenShiftClustersNodePool) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (pool *HcpOpenShiftClustersNodePool) GetSpec() genruntime.ConvertibleSpec {
	return &pool.Spec
}

// GetStatus returns the status of this resource
func (pool *HcpOpenShiftClustersNodePool) GetStatus() genruntime.ConvertibleStatus {
	return &pool.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (pool *HcpOpenShiftClustersNodePool) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.RedHatOpenShift/hcpOpenShiftClusters/nodePools"
func (pool *HcpOpenShiftClustersNodePool) GetType() string {
	return "Microsoft.RedHatOpenShift/hcpOpenShiftClusters/nodePools"
}

// NewEmptyStatus returns a new empty (blank) status
func (pool *HcpOpenShiftClustersNodePool) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &HcpOpenShiftClustersNodePool_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (pool *HcpOpenShiftClustersNodePool) Owner() *genruntime.ResourceReference {
	if pool.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(pool.Spec)
	return pool.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (pool *HcpOpenShiftClustersNodePool) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*HcpOpenShiftClustersNodePool_STATUS); ok {
		pool.Status = *st
		return nil
	}

	// Convert status to required version
	var st HcpOpenShiftClustersNodePool_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	pool.Status = st
	return nil
}

// AssignProperties_From_HcpOpenShiftClustersNodePool populates our HcpOpenShiftClustersNodePool from the provided source HcpOpenShiftClustersNodePool
func (pool *HcpOpenShiftClustersNodePool) AssignProperties_From_HcpOpenShiftClustersNodePool(source *storage.HcpOpenShiftClustersNodePool) error {

	// ObjectMeta
	pool.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec HcpOpenShiftClustersNodePool_Spec
	err := spec.AssignProperties_From_HcpOpenShiftClustersNodePool_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_HcpOpenShiftClustersNodePool_Spec() to populate field Spec")
	}
	pool.Spec = spec

	// Status
	var status HcpOpenShiftClustersNodePool_STATUS
	err = status.AssignProperties_From_HcpOpenShiftClustersNodePool_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_HcpOpenShiftClustersNodePool_STATUS() to populate field Status")
	}
	pool.Status = status

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftClustersNodePool populates the provided destination HcpOpenShiftClustersNodePool from our HcpOpenShiftClustersNodePool
func (pool *HcpOpenShiftClustersNodePool) AssignProperties_To_HcpOpenShiftClustersNodePool(destination *storage.HcpOpenShiftClustersNodePool) error {

	// ObjectMeta
	destination.ObjectMeta = *pool.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.HcpOpenShiftClustersNodePool_Spec
	err := pool.Spec.AssignProperties_To_HcpOpenShiftClustersNodePool_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_HcpOpenShiftClustersNodePool_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.HcpOpenShiftClustersNodePool_STATUS
	err = pool.Status.AssignProperties_To_HcpOpenShiftClustersNodePool_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_HcpOpenShiftClustersNodePool_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (pool *HcpOpenShiftClustersNodePool) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: pool.Spec.OriginalVersion(),
		Kind:    "HcpOpenShiftClustersNodePool",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /redhatopenshift/resource-manager/Microsoft.RedHatOpenShift/hcpclusters/preview/2024-06-10-preview/openapi.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RedHatOpenShift/hcpOpenShiftClusters/{hcpOpenShiftClusterName}/nodePools/{nodePoolName}
type HcpOpenShiftClustersNodePoolList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []HcpOpenShiftClustersNodePool `json:"items"`
}

type HcpOpenShiftClustersNodePool_Spec struct {
	// +kubebuilder:validation:Pattern="^[a-zA-Z][-a-zA-Z0-9]{1,13}[a-zA-Z0-9]$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Identity: The managed service identities assigned to this resource.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *HcpOpenShiftClustersNodePoolOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a redhatopenshift.azure.com/HcpOpenShiftCluster resource
	Owner *genruntime.KnownResourceReference `group:"redhatopenshift.azure.com" json:"owner,omitempty" kind:"HcpOpenShiftCluster"`

	// Properties: The resource-specific properties for this resource.
	Properties *NodePoolProperties `json:"properties,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &HcpOpenShiftClustersNodePool_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (pool *HcpOpenShiftClustersNodePool_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if pool == nil {
		return nil, nil
	}
	result := &arm.HcpOpenShiftClustersNodePool_Spec{}

	// Set property "Identity":
	if pool.Identity != nil {
		identity_ARM, err := pool.Identity.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedServiceIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if pool.Location != nil {
		location := *pool.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if pool.Properties != nil {
		properties_ARM, err := pool.Properties.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.NodePoolProperties)
		result.Properties = &properties
	}

	// Set property "Tags":
	if pool.Tags != nil {
		result.Tags = make(map[string]string, len(pool.Tags))
		for key, value := range pool.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *HcpOpenShiftClustersNodePool_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HcpOpenShiftClustersNodePool_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *HcpOpenShiftClustersNodePool_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HcpOpenShiftClustersNodePool_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HcpOpenShiftClustersNodePool_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	pool.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		pool.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		pool.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	pool.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 NodePoolProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		pool.Properties = &properties
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		pool.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			pool.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &HcpOpenShiftClustersNodePool_Spec{}

// ConvertSpecFrom populates our HcpOpenShiftClustersNodePool_Spec from the provided source
func (pool *HcpOpenShiftClustersNodePool_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.HcpOpenShiftClustersNodePool_Spec)
	if ok {
		// Populate our instance from source
		return pool.AssignProperties_From_HcpOpenShiftClustersNodePool_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.HcpOpenShiftClustersNodePool_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = pool.AssignProperties_From_HcpOpenShiftClustersNodePool_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our HcpOpenShiftClustersNodePool_Spec
func (pool *HcpOpenShiftClustersNodePool_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.HcpOpenShiftClustersNodePool_Spec)
	if ok {
		// Populate destination from our instance
		return pool.AssignProperties_To_HcpOpenShiftClustersNodePool_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.HcpOpenShiftClustersNodePool_Spec{}
	err := pool.AssignProperties_To_HcpOpenShiftClustersNodePool_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_HcpOpenShiftClustersNodePool_Spec populates our HcpOpenShiftClustersNodePool_Spec from the provided source HcpOpenShiftClustersNodePool_Spec
func (pool *HcpOpenShiftClustersNodePool_Spec) AssignProperties_From_HcpOpenShiftClustersNodePool_Spec(source *storage.HcpOpenShiftClustersNodePool_Spec) error {

	// AzureName
	pool.AzureName = source.AzureName

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		pool.Identity = &identity
	} else {
		pool.Identity = nil
	}

	// Location
	pool.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec HcpOpenShiftClustersNodePoolOperatorSpec
		err := operatorSpec.AssignProperties_From_HcpOpenShiftClustersNodePoolOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HcpOpenShiftClustersNodePoolOperatorSpec() to populate field OperatorSpec")
		}
		pool.OperatorSpec = &operatorSpec
	} else {
		pool.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		pool.Owner = &owner
	} else {
		pool.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property NodePoolProperties
		err := property.AssignProperties_From_NodePoolProperties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NodePoolProperties() to populate field Properties")
		}
		pool.Properties = &property
	} else {
		pool.Properties = nil
	}

	// Tags
	pool.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftClustersNodePool_Spec populates the provided destination HcpOpenShiftClustersNodePool_Spec from our HcpOpenShiftClustersNodePool_Spec
func (pool *HcpOpenShiftClustersNodePool_Spec) AssignProperties_To_HcpOpenShiftClustersNodePool_Spec(destination *storage.HcpOpenShiftClustersNodePool_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = pool.AzureName

	// Identity
	if pool.Identity != nil {
		var identity storage.ManagedServiceIdentity
		err := pool.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(pool.Location)

	// OperatorSpec
	if pool.OperatorSpec != nil {
		var operatorSpec storage.HcpOpenShiftClustersNodePoolOperatorSpec
		err := pool.OperatorSpec.AssignProperties_To_HcpOpenShiftClustersNodePoolOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HcpOpenShiftClustersNodePoolOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = pool.OriginalVersion()

	// Owner
	if pool.Owner != nil {
		owner := pool.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if pool.Properties != nil {
		var property storage.NodePoolProperties
		err := pool.Properties.AssignProperties_To_NodePoolProperties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NodePoolProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(pool.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HcpOpenShiftClustersNodePool_STATUS populates our HcpOpenShiftClustersNodePool_Spec from the provided source HcpOpenShiftClustersNodePool_STATUS
func (pool *HcpOpenShiftClustersNodePool_Spec) Initialize_From_HcpOpenShiftClustersNodePool_STATUS(source *HcpOpenShiftClustersNodePool_STATUS) error {

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.Initialize_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		pool.Identity = &identity
	} else {
		pool.Identity = nil
	}

	// Location
	pool.Location = genruntime.ClonePointerToString(source.Location)

	// Properties
	if source.Properties != nil {
		var property NodePoolProperties
		err := property.Initialize_From_NodePoolProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_NodePoolProperties_STATUS() to populate field Properties")
		}
		pool.Properties = &property
	} else {
		pool.Properties = nil
	}

	// Tags
	pool.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (pool *HcpOpenShiftClustersNodePool_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (pool *HcpOpenShiftClustersNodePool_Spec) SetAzureName(azureName string) {
	pool.AzureName = azureName
}

type HcpOpenShiftClustersNodePool_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Id: Fully qualified resource ID for the resource. E.g.
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
	Id *string `json:"id,omitempty"`

	// Identity: The managed service identities assigned to this resource.
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Properties: The resource-specific properties for this resource.
	Properties *NodePoolProperties_STATUS `json:"properties,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &HcpOpenShiftClustersNodePool_STATUS{}

// ConvertStatusFrom populates our HcpOpenShiftClustersNodePool_STATUS from the provided source
func (pool *HcpOpenShiftClustersNodePool_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.HcpOpenShiftClustersNodePool_STATUS)
	if ok {
		// Populate our instance from source
		return pool.AssignProperties_From_HcpOpenShiftClustersNodePool_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.HcpOpenShiftClustersNodePool_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = pool.AssignProperties_From_HcpOpenShiftClustersNodePool_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our HcpOpenShiftClustersNodePool_STATUS
func (pool *HcpOpenShiftClustersNodePool_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.HcpOpenShiftClustersNodePool_STATUS)
	if ok {
		// Populate destination from our instance
		return pool.AssignProperties_To_HcpOpenShiftClustersNodePool_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.HcpOpenShiftClustersNodePool_STATUS{}
	err := pool.AssignProperties_To_HcpOpenShiftClustersNodePool_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &HcpOpenShiftClustersNodePool_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (pool *HcpOpenShiftClustersNodePool_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HcpOpenShiftClustersNodePool_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (pool *HcpOpenShiftClustersNodePool_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HcpOpenShiftClustersNodePool_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HcpOpenShiftClustersNodePool_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		pool.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		pool.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		pool.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		pool.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 NodePoolProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		pool.Properties = &properties
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		pool.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		pool.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			pool.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		pool.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_HcpOpenShiftClustersNodePool_STATUS populates our HcpOpenShiftClustersNodePool_STATUS from the provided source HcpOpenShiftClustersNodePool_STATUS
func (pool *HcpOpenShiftClustersNodePool_STATUS) AssignProperties_From_HcpOpenShiftClustersNodePool_STATUS(source *storage.HcpOpenShiftClustersNodePool_STATUS) error {

	// Conditions
	pool.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Id
	pool.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		pool.Identity = &identity
	} else {
		pool.Identity = nil
	}

	// Location
	pool.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	pool.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property NodePoolProperties_STATUS
		err := property.AssignProperties_From_NodePoolProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NodePoolProperties_STATUS() to populate field Properties")
		}
		pool.Properties = &property
	} else {
		pool.Properties = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		pool.SystemData = &systemDatum
	} else {
		pool.SystemData = nil
	}

	// Tags
	pool.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	pool.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftClustersNodePool_STATUS populates the provided destination HcpOpenShiftClustersNodePool_STATUS from our HcpOpenShiftClustersNodePool_STATUS
func (pool *HcpOpenShiftClustersNodePool_STATUS) AssignProperties_To_HcpOpenShiftClustersNodePool_STATUS(destination *storage.HcpOpenShiftClustersNodePool_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(pool.Conditions)

	// Id
	destination.Id = genruntime.ClonePointerToString(pool.Id)

	// Identity
	if pool.Identity != nil {
		var identity storage.ManagedServiceIdentity_STATUS
		err := pool.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(pool.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(pool.Name)

	// Properties
	if pool.Properties != nil {
		var property storage.NodePoolProperties_STATUS
		err := pool.Properties.AssignProperties_To_NodePoolProperties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NodePoolProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// SystemData
	if pool.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := pool.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(pool.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(pool.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type HcpOpenShiftClustersNodePoolOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_HcpOpenShiftClustersNodePoolOperatorSpec populates our HcpOpenShiftClustersNodePoolOperatorSpec from the provided source HcpOpenShiftClustersNodePoolOperatorSpec
func (operator *HcpOpenShiftClustersNodePoolOperatorSpec) AssignProperties_From_HcpOpenShiftClustersNodePoolOperatorSpec(source *storage.HcpOpenShiftClustersNodePoolOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftClustersNodePoolOperatorSpec populates the provided destination HcpOpenShiftClustersNodePoolOperatorSpec from our HcpOpenShiftClustersNodePoolOperatorSpec
func (operator *HcpOpenShiftClustersNodePoolOperatorSpec) AssignProperties_To_HcpOpenShiftClustersNodePoolOperatorSpec(destination *storage.HcpOpenShiftClustersNodePoolOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Represents the node pool properties
type NodePoolProperties struct {
	// AutoRepair: Auto-repair
	AutoRepair *bool `json:"autoRepair,omitempty"`

	// AutoScaling: Representation of a autoscaling in a node pool.
	AutoScaling *NodePoolAutoScaling `json:"autoScaling,omitempty"`

	// Labels: Kubernetes labels to propagate to the NodePool Nodes
	// Note that when the labels are updated this is only applied to newly
	// create nodes in the Nodepool, existing node labels remain unchanged.
	Labels []Label `json:"labels,omitempty"`

	// NodeDrainTimeoutMinutes: nodeDrainTimeoutMinutes is the grace period for how long Pod Disruption Budget-protected
	// workloads will be
	// respected during any node draining operation. After this grace period, any workloads protected by Pod Disruption
	// Budgets that have not been successfully drained from a node will be forcibly evicted. This is
	// especially relevant to cluster upgrades.
	// Valid values are from 0 to 10080 minutes (1 week) .
	// 0 means that the NodePool can be drained without any time limitation.
	// If unset the cluster nodeDrainTimeoutMinutes value is used as a default.
	NodeDrainTimeoutMinutes *int `json:"nodeDrainTimeoutMinutes,omitempty"`

	// +kubebuilder:validation:Required
	// Platform: Azure node pool platform configuration
	Platform *NodePoolPlatformProfile `json:"platform,omitempty"`

	// Replicas: The number of worker nodes, it cannot be used together with autoscaling
	Replicas *int `json:"replicas,omitempty"`

	// Taints: Taints for the nodes
	Taints []Taint `json:"taints,omitempty"`

	// Version: OpenShift version for the nodepool
	Version *NodePoolVersionProfile `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &NodePoolProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *NodePoolProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.NodePoolProperties{}

	// Set property "AutoRepair":
	if properties.AutoRepair != nil {
		autoRepair := *properties.AutoRepair
		result.AutoRepair = &autoRepair
	}

	// Set property "AutoScaling":
	if properties.AutoScaling != nil {
		autoScaling_ARM, err := properties.AutoScaling.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoScaling := *autoScaling_ARM.(*arm.NodePoolAutoScaling)
		result.AutoScaling = &autoScaling
	}

	// Set property "Labels":
	for _, item := range properties.Labels {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Labels = append(result.Labels, *item_ARM.(*arm.Label))
	}

	// Set property "NodeDrainTimeoutMinutes":
	if properties.NodeDrainTimeoutMinutes != nil {
		nodeDrainTimeoutMinutes := *properties.NodeDrainTimeoutMinutes
		result.NodeDrainTimeoutMinutes = &nodeDrainTimeoutMinutes
	}

	// Set property "Platform":
	if properties.Platform != nil {
		platform_ARM, err := properties.Platform.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		platform := *platform_ARM.(*arm.NodePoolPlatformProfile)
		result.Platform = &platform
	}

	// Set property "Replicas":
	if properties.Replicas != nil {
		replicas := *properties.Replicas
		result.Replicas = &replicas
	}

	// Set property "Taints":
	for _, item := range properties.Taints {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Taints = append(result.Taints, *item_ARM.(*arm.Taint))
	}

	// Set property "Version":
	if properties.Version != nil {
		version_ARM, err := properties.Version.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		version := *version_ARM.(*arm.NodePoolVersionProfile)
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *NodePoolProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NodePoolProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *NodePoolProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NodePoolProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NodePoolProperties, got %T", armInput)
	}

	// Set property "AutoRepair":
	if typedInput.AutoRepair != nil {
		autoRepair := *typedInput.AutoRepair
		properties.AutoRepair = &autoRepair
	}

	// Set property "AutoScaling":
	if typedInput.AutoScaling != nil {
		var autoScaling1 NodePoolAutoScaling
		err := autoScaling1.PopulateFromARM(owner, *typedInput.AutoScaling)
		if err != nil {
			return err
		}
		autoScaling := autoScaling1
		properties.AutoScaling = &autoScaling
	}

	// Set property "Labels":
	for _, item := range typedInput.Labels {
		var item1 Label
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Labels = append(properties.Labels, item1)
	}

	// Set property "NodeDrainTimeoutMinutes":
	if typedInput.NodeDrainTimeoutMinutes != nil {
		nodeDrainTimeoutMinutes := *typedInput.NodeDrainTimeoutMinutes
		properties.NodeDrainTimeoutMinutes = &nodeDrainTimeoutMinutes
	}

	// Set property "Platform":
	if typedInput.Platform != nil {
		var platform1 NodePoolPlatformProfile
		err := platform1.PopulateFromARM(owner, *typedInput.Platform)
		if err != nil {
			return err
		}
		platform := platform1
		properties.Platform = &platform
	}

	// Set property "Replicas":
	if typedInput.Replicas != nil {
		replicas := *typedInput.Replicas
		properties.Replicas = &replicas
	}

	// Set property "Taints":
	for _, item := range typedInput.Taints {
		var item1 Taint
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Taints = append(properties.Taints, item1)
	}

	// Set property "Version":
	if typedInput.Version != nil {
		var version1 NodePoolVersionProfile
		err := version1.PopulateFromARM(owner, *typedInput.Version)
		if err != nil {
			return err
		}
		version := version1
		properties.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_NodePoolProperties populates our NodePoolProperties from the provided source NodePoolProperties
func (properties *NodePoolProperties) AssignProperties_From_NodePoolProperties(source *storage.NodePoolProperties) error {

	// AutoRepair
	if source.AutoRepair != nil {
		autoRepair := *source.AutoRepair
		properties.AutoRepair = &autoRepair
	} else {
		properties.AutoRepair = nil
	}

	// AutoScaling
	if source.AutoScaling != nil {
		var autoScaling NodePoolAutoScaling
		err := autoScaling.AssignProperties_From_NodePoolAutoScaling(source.AutoScaling)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NodePoolAutoScaling() to populate field AutoScaling")
		}
		properties.AutoScaling = &autoScaling
	} else {
		properties.AutoScaling = nil
	}

	// Labels
	if source.Labels != nil {
		labelList := make([]Label, len(source.Labels))
		for labelIndex, labelItem := range source.Labels {
			var label Label
			err := label.AssignProperties_From_Label(&labelItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Label() to populate field Labels")
			}
			labelList[labelIndex] = label
		}
		properties.Labels = labelList
	} else {
		properties.Labels = nil
	}

	// NodeDrainTimeoutMinutes
	properties.NodeDrainTimeoutMinutes = genruntime.ClonePointerToInt(source.NodeDrainTimeoutMinutes)

	// Platform
	if source.Platform != nil {
		var platform NodePoolPlatformProfile
		err := platform.AssignProperties_From_NodePoolPlatformProfile(source.Platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NodePoolPlatformProfile() to populate field Platform")
		}
		properties.Platform = &platform
	} else {
		properties.Platform = nil
	}

	// Replicas
	properties.Replicas = genruntime.ClonePointerToInt(source.Replicas)

	// Taints
	if source.Taints != nil {
		taintList := make([]Taint, len(source.Taints))
		for taintIndex, taintItem := range source.Taints {
			var taint Taint
			err := taint.AssignProperties_From_Taint(&taintItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Taint() to populate field Taints")
			}
			taintList[taintIndex] = taint
		}
		properties.Taints = taintList
	} else {
		properties.Taints = nil
	}

	// Version
	if source.Version != nil {
		var version NodePoolVersionProfile
		err := version.AssignProperties_From_NodePoolVersionProfile(source.Version)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NodePoolVersionProfile() to populate field Version")
		}
		properties.Version = &version
	} else {
		properties.Version = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NodePoolProperties populates the provided destination NodePoolProperties from our NodePoolProperties
func (properties *NodePoolProperties) AssignProperties_To_NodePoolProperties(destination *storage.NodePoolProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoRepair
	if properties.AutoRepair != nil {
		autoRepair := *properties.AutoRepair
		destination.AutoRepair = &autoRepair
	} else {
		destination.AutoRepair = nil
	}

	// AutoScaling
	if properties.AutoScaling != nil {
		var autoScaling storage.NodePoolAutoScaling
		err := properties.AutoScaling.AssignProperties_To_NodePoolAutoScaling(&autoScaling)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NodePoolAutoScaling() to populate field AutoScaling")
		}
		destination.AutoScaling = &autoScaling
	} else {
		destination.AutoScaling = nil
	}

	// Labels
	if properties.Labels != nil {
		labelList := make([]storage.Label, len(properties.Labels))
		for labelIndex, labelItem := range properties.Labels {
			var label storage.Label
			err := labelItem.AssignProperties_To_Label(&label)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Label() to populate field Labels")
			}
			labelList[labelIndex] = label
		}
		destination.Labels = labelList
	} else {
		destination.Labels = nil
	}

	// NodeDrainTimeoutMinutes
	destination.NodeDrainTimeoutMinutes = genruntime.ClonePointerToInt(properties.NodeDrainTimeoutMinutes)

	// Platform
	if properties.Platform != nil {
		var platform storage.NodePoolPlatformProfile
		err := properties.Platform.AssignProperties_To_NodePoolPlatformProfile(&platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NodePoolPlatformProfile() to populate field Platform")
		}
		destination.Platform = &platform
	} else {
		destination.Platform = nil
	}

	// Replicas
	destination.Replicas = genruntime.ClonePointerToInt(properties.Replicas)

	// Taints
	if properties.Taints != nil {
		taintList := make([]storage.Taint, len(properties.Taints))
		for taintIndex, taintItem := range properties.Taints {
			var taint storage.Taint
			err := taintItem.AssignProperties_To_Taint(&taint)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Taint() to populate field Taints")
			}
			taintList[taintIndex] = taint
		}
		destination.Taints = taintList
	} else {
		destination.Taints = nil
	}

	// Version
	if properties.Version != nil {
		var version storage.NodePoolVersionProfile
		err := properties.Version.AssignProperties_To_NodePoolVersionProfile(&version)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NodePoolVersionProfile() to populate field Version")
		}
		destination.Version = &version
	} else {
		destination.Version = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NodePoolProperties_STATUS populates our NodePoolProperties from the provided source NodePoolProperties_STATUS
func (properties *NodePoolProperties) Initialize_From_NodePoolProperties_STATUS(source *NodePoolProperties_STATUS) error {

	// AutoRepair
	if source.AutoRepair != nil {
		autoRepair := *source.AutoRepair
		properties.AutoRepair = &autoRepair
	} else {
		properties.AutoRepair = nil
	}

	// AutoScaling
	if source.AutoScaling != nil {
		var autoScaling NodePoolAutoScaling
		err := autoScaling.Initialize_From_NodePoolAutoScaling_STATUS(source.AutoScaling)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_NodePoolAutoScaling_STATUS() to populate field AutoScaling")
		}
		properties.AutoScaling = &autoScaling
	} else {
		properties.AutoScaling = nil
	}

	// Labels
	if source.Labels != nil {
		labelList := make([]Label, len(source.Labels))
		for labelIndex, labelItem := range source.Labels {
			var label Label
			err := label.Initialize_From_Label_STATUS(&labelItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_Label_STATUS() to populate field Labels")
			}
			labelList[labelIndex] = label
		}
		properties.Labels = labelList
	} else {
		properties.Labels = nil
	}

	// NodeDrainTimeoutMinutes
	properties.NodeDrainTimeoutMinutes = genruntime.ClonePointerToInt(source.NodeDrainTimeoutMinutes)

	// Platform
	if source.Platform != nil {
		var platform NodePoolPlatformProfile
		err := platform.Initialize_From_NodePoolPlatformProfile_STATUS(source.Platform)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_NodePoolPlatformProfile_STATUS() to populate field Platform")
		}
		properties.Platform = &platform
	} else {
		properties.Platform = nil
	}

	// Replicas
	properties.Replicas = genruntime.ClonePointerToInt(source.Replicas)

	// Taints
	if source.Taints != nil {
		taintList := make([]Taint, len(source.Taints))
		for taintIndex, taintItem := range source.Taints {
			var taint Taint
			err := taint.Initialize_From_Taint_STATUS(&taintItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_Taint_STATUS() to populate field Taints")
			}
			taintList[taintIndex] = taint
		}
		properties.Taints = taintList
	} else {
		properties.Taints = nil
	}

	// Version
	if source.Version != nil {
		var version NodePoolVersionProfile
		err := version.Initialize_From_NodePoolVersionProfile_STATUS(source.Version)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_NodePoolVersionProfile_STATUS() to populate field Version")
		}
		properties.Version = &version
	} else {
		properties.Version = nil
	}

	// No error
	return nil
}

// Represents the node pool properties
type NodePoolProperties_STATUS struct {
	// AutoRepair: Auto-repair
	AutoRepair *bool `json:"autoRepair,omitempty"`

	// AutoScaling: Representation of a autoscaling in a node pool.
	AutoScaling *NodePoolAutoScaling_STATUS `json:"autoScaling,omitempty"`

	// Labels: Kubernetes labels to propagate to the NodePool Nodes
	// Note that when the labels are updated this is only applied to newly
	// create nodes in the Nodepool, existing node labels remain unchanged.
	Labels []Label_STATUS `json:"labels,omitempty"`

	// NodeDrainTimeoutMinutes: nodeDrainTimeoutMinutes is the grace period for how long Pod Disruption Budget-protected
	// workloads will be
	// respected during any node draining operation. After this grace period, any workloads protected by Pod Disruption
	// Budgets that have not been successfully drained from a node will be forcibly evicted. This is
	// especially relevant to cluster upgrades.
	// Valid values are from 0 to 10080 minutes (1 week) .
	// 0 means that the NodePool can be drained without any time limitation.
	// If unset the cluster nodeDrainTimeoutMinutes value is used as a default.
	NodeDrainTimeoutMinutes *int `json:"nodeDrainTimeoutMinutes,omitempty"`

	// Platform: Azure node pool platform configuration
	Platform *NodePoolPlatformProfile_STATUS `json:"platform,omitempty"`

	// ProvisioningState: Provisioning state
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// Replicas: The number of worker nodes, it cannot be used together with autoscaling
	Replicas *int `json:"replicas,omitempty"`

	// Taints: Taints for the nodes
	Taints []Taint_STATUS `json:"taints,omitempty"`

	// Version: OpenShift version for the nodepool
	Version *NodePoolVersionProfile_STATUS `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &NodePoolProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *NodePoolProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NodePoolProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *NodePoolProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NodePoolProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NodePoolProperties_STATUS, got %T", armInput)
	}

	// Set property "AutoRepair":
	if typedInput.AutoRepair != nil {
		autoRepair := *typedInput.AutoRepair
		properties.AutoRepair = &autoRepair
	}

	// Set property "AutoScaling":
	if typedInput.AutoScaling != nil {
		var autoScaling1 NodePoolAutoScaling_STATUS
		err := autoScaling1.PopulateFromARM(owner, *typedInput.AutoScaling)
		if err != nil {
			return err
		}
		autoScaling := autoScaling1
		properties.AutoScaling = &autoScaling
	}

	// Set property "Labels":
	for _, item := range typedInput.Labels {
		var item1 Label_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Labels = append(properties.Labels, item1)
	}

	// Set property "NodeDrainTimeoutMinutes":
	if typedInput.NodeDrainTimeoutMinutes != nil {
		nodeDrainTimeoutMinutes := *typedInput.NodeDrainTimeoutMinutes
		properties.NodeDrainTimeoutMinutes = &nodeDrainTimeoutMinutes
	}

	// Set property "Platform":
	if typedInput.Platform != nil {
		var platform1 NodePoolPlatformProfile_STATUS
		err := platform1.PopulateFromARM(owner, *typedInput.Platform)
		if err != nil {
			return err
		}
		platform := platform1
		properties.Platform = &platform
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var temp string
		temp = string(*typedInput.ProvisioningState)
		provisioningState := ProvisioningState_STATUS(temp)
		properties.ProvisioningState = &provisioningState
	}

	// Set property "Replicas":
	if typedInput.Replicas != nil {
		replicas := *typedInput.Replicas
		properties.Replicas = &replicas
	}

	// Set property "Taints":
	for _, item := range typedInput.Taints {
		var item1 Taint_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Taints = append(properties.Taints, item1)
	}

	// Set property "Version":
	if typedInput.Version != nil {
		var version1 NodePoolVersionProfile_STATUS
		err := version1.PopulateFromARM(owner, *typedInput.Version)
		if err != nil {
			return err
		}
		version := version1
		properties.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_NodePoolProperties_STATUS populates our NodePoolProperties_STATUS from the provided source NodePoolProperties_STATUS
func (properties *NodePoolProperties_STATUS) AssignProperties_From_NodePoolProperties_STATUS(source *storage.NodePoolProperties_STATUS) error {

	// AutoRepair
	if source.AutoRepair != nil {
		autoRepair := *source.AutoRepair
		properties.AutoRepair = &autoRepair
	} else {
		properties.AutoRepair = nil
	}

	// AutoScaling
	if source.AutoScaling != nil {
		var autoScaling NodePoolAutoScaling_STATUS
		err := autoScaling.AssignProperties_From_NodePoolAutoScaling_STATUS(source.AutoScaling)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NodePoolAutoScaling_STATUS() to populate field AutoScaling")
		}
		properties.AutoScaling = &autoScaling
	} else {
		properties.AutoScaling = nil
	}

	// Labels
	if source.Labels != nil {
		labelList := make([]Label_STATUS, len(source.Labels))
		for labelIndex, labelItem := range source.Labels {
			var label Label_STATUS
			err := label.AssignProperties_From_Label_STATUS(&labelItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Label_STATUS() to populate field Labels")
			}
			labelList[labelIndex] = label
		}
		properties.Labels = labelList
	} else {
		properties.Labels = nil
	}

	// NodeDrainTimeoutMinutes
	properties.NodeDrainTimeoutMinutes = genruntime.ClonePointerToInt(source.NodeDrainTimeoutMinutes)

	// Platform
	if source.Platform != nil {
		var platform NodePoolPlatformProfile_STATUS
		err := platform.AssignProperties_From_NodePoolPlatformProfile_STATUS(source.Platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NodePoolPlatformProfile_STATUS() to populate field Platform")
		}
		properties.Platform = &platform
	} else {
		properties.Platform = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, provisioningState_STATUS_Values)
		properties.ProvisioningState = &provisioningStateTemp
	} else {
		properties.ProvisioningState = nil
	}

	// Replicas
	properties.Replicas = genruntime.ClonePointerToInt(source.Replicas)

	// Taints
	if source.Taints != nil {
		taintList := make([]Taint_STATUS, len(source.Taints))
		for taintIndex, taintItem := range source.Taints {
			var taint Taint_STATUS
			err := taint.AssignProperties_From_Taint_STATUS(&taintItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_Taint_STATUS() to populate field Taints")
			}
			taintList[taintIndex] = taint
		}
		properties.Taints = taintList
	} else {
		properties.Taints = nil
	}

	// Version
	if source.Version != nil {
		var version NodePoolVersionProfile_STATUS
		err := version.AssignProperties_From_NodePoolVersionProfile_STATUS(source.Version)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NodePoolVersionProfile_STATUS() to populate field Version")
		}
		properties.Version = &version
	} else {
		properties.Version = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NodePoolProperties_STATUS populates the provided destination NodePoolProperties_STATUS from our NodePoolProperties_STATUS
func (properties *NodePoolProperties_STATUS) AssignProperties_To_NodePoolProperties_STATUS(destination *storage.NodePoolProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AutoRepair
	if properties.AutoRepair != nil {
		autoRepair := *properties.AutoRepair
		destination.AutoRepair = &autoRepair
	} else {
		destination.AutoRepair = nil
	}

	// AutoScaling
	if properties.AutoScaling != nil {
		var autoScaling storage.NodePoolAutoScaling_STATUS
		err := properties.AutoScaling.AssignProperties_To_NodePoolAutoScaling_STATUS(&autoScaling)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NodePoolAutoScaling_STATUS() to populate field AutoScaling")
		}
		destination.AutoScaling = &autoScaling
	} else {
		destination.AutoScaling = nil
	}

	// Labels
	if properties.Labels != nil {
		labelList := make([]storage.Label_STATUS, len(properties.Labels))
		for labelIndex, labelItem := range properties.Labels {
			var label storage.Label_STATUS
			err := labelItem.AssignProperties_To_Label_STATUS(&label)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Label_STATUS() to populate field Labels")
			}
			labelList[labelIndex] = label
		}
		destination.Labels = labelList
	} else {
		destination.Labels = nil
	}

	// NodeDrainTimeoutMinutes
	destination.NodeDrainTimeoutMinutes = genruntime.ClonePointerToInt(properties.NodeDrainTimeoutMinutes)

	// Platform
	if properties.Platform != nil {
		var platform storage.NodePoolPlatformProfile_STATUS
		err := properties.Platform.AssignProperties_To_NodePoolPlatformProfile_STATUS(&platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NodePoolPlatformProfile_STATUS() to populate field Platform")
		}
		destination.Platform = &platform
	} else {
		destination.Platform = nil
	}

	// ProvisioningState
	if properties.ProvisioningState != nil {
		provisioningState := string(*properties.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Replicas
	destination.Replicas = genruntime.ClonePointerToInt(properties.Replicas)

	// Taints
	if properties.Taints != nil {
		taintList := make([]storage.Taint_STATUS, len(properties.Taints))
		for taintIndex, taintItem := range properties.Taints {
			var taint storage.Taint_STATUS
			err := taintItem.AssignProperties_To_Taint_STATUS(&taint)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_Taint_STATUS() to populate field Taints")
			}
			taintList[taintIndex] = taint
		}
		destination.Taints = taintList
	} else {
		destination.Taints = nil
	}

	// Version
	if properties.Version != nil {
		var version storage.NodePoolVersionProfile_STATUS
		err := properties.Version.AssignProperties_To_NodePoolVersionProfile_STATUS(&version)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NodePoolVersionProfile_STATUS() to populate field Version")
		}
		destination.Version = &version
	} else {
		destination.Version = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Label represents the Kubernetes label
type Label struct {
	// +kubebuilder:validation:Required
	// Key: The key of the label
	Key *string `json:"key,omitempty"`

	// Value: The value of the label
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &Label{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (label *Label) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if label == nil {
		return nil, nil
	}
	result := &arm.Label{}

	// Set property "Key":
	if label.Key != nil {
		key := *label.Key
		result.Key = &key
	}

	// Set property "Value":
	if label.Value != nil {
		value := *label.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (label *Label) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Label{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (label *Label) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Label)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Label, got %T", armInput)
	}

	// Set property "Key":
	if typedInput.Key != nil {
		key := *typedInput.Key
		label.Key = &key
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		label.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_Label populates our Label from the provided source Label
func (label *Label) AssignProperties_From_Label(source *storage.Label) error {

	// Key
	label.Key = genruntime.ClonePointerToString(source.Key)

	// Value
	label.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_Label populates the provided destination Label from our Label
func (label *Label) AssignProperties_To_Label(destination *storage.Label) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Key
	destination.Key = genruntime.ClonePointerToString(label.Key)

	// Value
	destination.Value = genruntime.ClonePointerToString(label.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Label_STATUS populates our Label from the provided source Label_STATUS
func (label *Label) Initialize_From_Label_STATUS(source *Label_STATUS) error {

	// Key
	label.Key = genruntime.ClonePointerToString(source.Key)

	// Value
	label.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// Label represents the Kubernetes label
type Label_STATUS struct {
	// Key: The key of the label
	Key *string `json:"key,omitempty"`

	// Value: The value of the label
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &Label_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (label *Label_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Label_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (label *Label_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Label_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Label_STATUS, got %T", armInput)
	}

	// Set property "Key":
	if typedInput.Key != nil {
		key := *typedInput.Key
		label.Key = &key
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		label.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_Label_STATUS populates our Label_STATUS from the provided source Label_STATUS
func (label *Label_STATUS) AssignProperties_From_Label_STATUS(source *storage.Label_STATUS) error {

	// Key
	label.Key = genruntime.ClonePointerToString(source.Key)

	// Value
	label.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_Label_STATUS populates the provided destination Label_STATUS from our Label_STATUS
func (label *Label_STATUS) AssignProperties_To_Label_STATUS(destination *storage.Label_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Key
	destination.Key = genruntime.ClonePointerToString(label.Key)

	// Value
	destination.Value = genruntime.ClonePointerToString(label.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Node pool autoscaling
type NodePoolAutoScaling struct {
	// +kubebuilder:validation:Minimum=0
	// Max: The maximum number of nodes in the node pool
	Max *int `json:"max,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// Min: The minimum number of nodes in the node pool
	Min *int `json:"min,omitempty"`
}

var _ genruntime.ARMTransformer = &NodePoolAutoScaling{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (scaling *NodePoolAutoScaling) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if scaling == nil {
		return nil, nil
	}
	result := &arm.NodePoolAutoScaling{}

	// Set property "Max":
	if scaling.Max != nil {
		max := *scaling.Max
		result.Max = &max
	}

	// Set property "Min":
	if scaling.Min != nil {
		min := *scaling.Min
		result.Min = &min
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scaling *NodePoolAutoScaling) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NodePoolAutoScaling{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scaling *NodePoolAutoScaling) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NodePoolAutoScaling)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NodePoolAutoScaling, got %T", armInput)
	}

	// Set property "Max":
	if typedInput.Max != nil {
		max := *typedInput.Max
		scaling.Max = &max
	}

	// Set property "Min":
	if typedInput.Min != nil {
		min := *typedInput.Min
		scaling.Min = &min
	}

	// No error
	return nil
}

// AssignProperties_From_NodePoolAutoScaling populates our NodePoolAutoScaling from the provided source NodePoolAutoScaling
func (scaling *NodePoolAutoScaling) AssignProperties_From_NodePoolAutoScaling(source *storage.NodePoolAutoScaling) error {

	// Max
	scaling.Max = genruntime.ClonePointerToInt(source.Max)

	// Min
	scaling.Min = genruntime.ClonePointerToInt(source.Min)

	// No error
	return nil
}

// AssignProperties_To_NodePoolAutoScaling populates the provided destination NodePoolAutoScaling from our NodePoolAutoScaling
func (scaling *NodePoolAutoScaling) AssignProperties_To_NodePoolAutoScaling(destination *storage.NodePoolAutoScaling) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Max
	destination.Max = genruntime.ClonePointerToInt(scaling.Max)

	// Min
	destination.Min = genruntime.ClonePointerToInt(scaling.Min)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NodePoolAutoScaling_STATUS populates our NodePoolAutoScaling from the provided source NodePoolAutoScaling_STATUS
func (scaling *NodePoolAutoScaling) Initialize_From_NodePoolAutoScaling_STATUS(source *NodePoolAutoScaling_STATUS) error {

	// Max
	scaling.Max = genruntime.ClonePointerToInt(source.Max)

	// Min
	scaling.Min = genruntime.ClonePointerToInt(source.Min)

	// No error
	return nil
}

// Node pool autoscaling
type NodePoolAutoScaling_STATUS struct {
	// Max: The maximum number of nodes in the node pool
	Max *int `json:"max,omitempty"`

	// Min: The minimum number of nodes in the node pool
	Min *int `json:"min,omitempty"`
}

var _ genruntime.FromARMConverter = &NodePoolAutoScaling_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (scaling *NodePoolAutoScaling_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NodePoolAutoScaling_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (scaling *NodePoolAutoScaling_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NodePoolAutoScaling_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NodePoolAutoScaling_STATUS, got %T", armInput)
	}

	// Set property "Max":
	if typedInput.Max != nil {
		max := *typedInput.Max
		scaling.Max = &max
	}

	// Set property "Min":
	if typedInput.Min != nil {
		min := *typedInput.Min
		scaling.Min = &min
	}

	// No error
	return nil
}

// AssignProperties_From_NodePoolAutoScaling_STATUS populates our NodePoolAutoScaling_STATUS from the provided source NodePoolAutoScaling_STATUS
func (scaling *NodePoolAutoScaling_STATUS) AssignProperties_From_NodePoolAutoScaling_STATUS(source *storage.NodePoolAutoScaling_STATUS) error {

	// Max
	scaling.Max = genruntime.ClonePointerToInt(source.Max)

	// Min
	scaling.Min = genruntime.ClonePointerToInt(source.Min)

	// No error
	return nil
}

// AssignProperties_To_NodePoolAutoScaling_STATUS populates the provided destination NodePoolAutoScaling_STATUS from our NodePoolAutoScaling_STATUS
func (scaling *NodePoolAutoScaling_STATUS) AssignProperties_To_NodePoolAutoScaling_STATUS(destination *storage.NodePoolAutoScaling_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Max
	destination.Max = genruntime.ClonePointerToInt(scaling.Max)

	// Min
	destination.Min = genruntime.ClonePointerToInt(scaling.Min)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure node pool platform configuration
type NodePoolPlatformProfile struct {
	// AvailabilityZone: The availability zone for the node pool.
	// Please read the documentation to see which regions support availability zones
	// - https://learn.microsoft.com/en-us/azure/availability-zones/az-overview
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	// EnableEncryptionAtHost: Whether to enable host based OS and data drive encryption.
	// -
	// https://learn.microsoft.com/en-us/azure/virtual-machines/disk-encryption#encryption-at-host---end-to-end-encryption-for-your-vm-data
	EnableEncryptionAtHost *bool `json:"enableEncryptionAtHost,omitempty"`

	// OsDisk: The settings and configuration options for OSDisk
	OsDisk *OsDiskProfile `json:"osDisk,omitempty"`

	// SubnetReference: The Azure resource ID of the worker subnet
	// Note that a subnet cannot be reused between ARO-HCP Clusters, however the
	// same subnet can be used for NodePools of the same cluster.
	SubnetReference *genruntime.ResourceReference `armReference:"SubnetId" json:"subnetReference,omitempty"`

	// +kubebuilder:validation:Required
	// VmSize: The VM size according to the documentation:
	// - https://learn.microsoft.com/en-us/azure/virtual-machines/sizes
	VmSize *string `json:"vmSize,omitempty"`
}

var _ genruntime.ARMTransformer = &NodePoolPlatformProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *NodePoolPlatformProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.NodePoolPlatformProfile{}

	// Set property "AvailabilityZone":
	if profile.AvailabilityZone != nil {
		availabilityZone := *profile.AvailabilityZone
		result.AvailabilityZone = &availabilityZone
	}

	// Set property "EnableEncryptionAtHost":
	if profile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *profile.EnableEncryptionAtHost
		result.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property "OsDisk":
	if profile.OsDisk != nil {
		osDisk_ARM, err := profile.OsDisk.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		osDisk := *osDisk_ARM.(*arm.OsDiskProfile)
		result.OsDisk = &osDisk
	}

	// Set property "SubnetId":
	if profile.SubnetReference != nil {
		subnetReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.SubnetReference)
		if err != nil {
			return nil, err
		}
		subnetReference := subnetReferenceARMID
		result.SubnetId = &subnetReference
	}

	// Set property "VmSize":
	if profile.VmSize != nil {
		vmSize := *profile.VmSize
		result.VmSize = &vmSize
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *NodePoolPlatformProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NodePoolPlatformProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *NodePoolPlatformProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NodePoolPlatformProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NodePoolPlatformProfile, got %T", armInput)
	}

	// Set property "AvailabilityZone":
	if typedInput.AvailabilityZone != nil {
		availabilityZone := *typedInput.AvailabilityZone
		profile.AvailabilityZone = &availabilityZone
	}

	// Set property "EnableEncryptionAtHost":
	if typedInput.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *typedInput.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property "OsDisk":
	if typedInput.OsDisk != nil {
		var osDisk1 OsDiskProfile
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		profile.OsDisk = &osDisk
	}

	// no assignment for property "SubnetReference"

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		profile.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignProperties_From_NodePoolPlatformProfile populates our NodePoolPlatformProfile from the provided source NodePoolPlatformProfile
func (profile *NodePoolPlatformProfile) AssignProperties_From_NodePoolPlatformProfile(source *storage.NodePoolPlatformProfile) error {

	// AvailabilityZone
	profile.AvailabilityZone = genruntime.ClonePointerToString(source.AvailabilityZone)

	// EnableEncryptionAtHost
	if source.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *source.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		profile.EnableEncryptionAtHost = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OsDiskProfile
		err := osDisk.AssignProperties_From_OsDiskProfile(source.OsDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OsDiskProfile() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// SubnetReference
	if source.SubnetReference != nil {
		subnetReference := source.SubnetReference.Copy()
		profile.SubnetReference = &subnetReference
	} else {
		profile.SubnetReference = nil
	}

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// AssignProperties_To_NodePoolPlatformProfile populates the provided destination NodePoolPlatformProfile from our NodePoolPlatformProfile
func (profile *NodePoolPlatformProfile) AssignProperties_To_NodePoolPlatformProfile(destination *storage.NodePoolPlatformProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AvailabilityZone
	destination.AvailabilityZone = genruntime.ClonePointerToString(profile.AvailabilityZone)

	// EnableEncryptionAtHost
	if profile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *profile.EnableEncryptionAtHost
		destination.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		destination.EnableEncryptionAtHost = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk storage.OsDiskProfile
		err := profile.OsDisk.AssignProperties_To_OsDiskProfile(&osDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OsDiskProfile() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// SubnetReference
	if profile.SubnetReference != nil {
		subnetReference := profile.SubnetReference.Copy()
		destination.SubnetReference = &subnetReference
	} else {
		destination.SubnetReference = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NodePoolPlatformProfile_STATUS populates our NodePoolPlatformProfile from the provided source NodePoolPlatformProfile_STATUS
func (profile *NodePoolPlatformProfile) Initialize_From_NodePoolPlatformProfile_STATUS(source *NodePoolPlatformProfile_STATUS) error {

	// AvailabilityZone
	profile.AvailabilityZone = genruntime.ClonePointerToString(source.AvailabilityZone)

	// EnableEncryptionAtHost
	if source.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *source.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		profile.EnableEncryptionAtHost = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OsDiskProfile
		err := osDisk.Initialize_From_OsDiskProfile_STATUS(source.OsDisk)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_OsDiskProfile_STATUS() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// SubnetReference
	if source.SubnetId != nil {
		subnetReference := genruntime.CreateResourceReferenceFromARMID(*source.SubnetId)
		profile.SubnetReference = &subnetReference
	} else {
		profile.SubnetReference = nil
	}

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// Azure node pool platform configuration
type NodePoolPlatformProfile_STATUS struct {
	// AvailabilityZone: The availability zone for the node pool.
	// Please read the documentation to see which regions support availability zones
	// - https://learn.microsoft.com/en-us/azure/availability-zones/az-overview
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	// EnableEncryptionAtHost: Whether to enable host based OS and data drive encryption.
	// -
	// https://learn.microsoft.com/en-us/azure/virtual-machines/disk-encryption#encryption-at-host---end-to-end-encryption-for-your-vm-data
	EnableEncryptionAtHost *bool `json:"enableEncryptionAtHost,omitempty"`

	// OsDisk: The settings and configuration options for OSDisk
	OsDisk *OsDiskProfile_STATUS `json:"osDisk,omitempty"`

	// SubnetId: The Azure resource ID of the worker subnet
	// Note that a subnet cannot be reused between ARO-HCP Clusters, however the
	// same subnet can be used for NodePools of the same cluster.
	SubnetId *string `json:"subnetId,omitempty"`

	// VmSize: The VM size according to the documentation:
	// - https://learn.microsoft.com/en-us/azure/virtual-machines/sizes
	VmSize *string `json:"vmSize,omitempty"`
}

var _ genruntime.FromARMConverter = &NodePoolPlatformProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *NodePoolPlatformProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NodePoolPlatformProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *NodePoolPlatformProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NodePoolPlatformProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NodePoolPlatformProfile_STATUS, got %T", armInput)
	}

	// Set property "AvailabilityZone":
	if typedInput.AvailabilityZone != nil {
		availabilityZone := *typedInput.AvailabilityZone
		profile.AvailabilityZone = &availabilityZone
	}

	// Set property "EnableEncryptionAtHost":
	if typedInput.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *typedInput.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	}

	// Set property "OsDisk":
	if typedInput.OsDisk != nil {
		var osDisk1 OsDiskProfile_STATUS
		err := osDisk1.PopulateFromARM(owner, *typedInput.OsDisk)
		if err != nil {
			return err
		}
		osDisk := osDisk1
		profile.OsDisk = &osDisk
	}

	// Set property "SubnetId":
	if typedInput.SubnetId != nil {
		subnetId := *typedInput.SubnetId
		profile.SubnetId = &subnetId
	}

	// Set property "VmSize":
	if typedInput.VmSize != nil {
		vmSize := *typedInput.VmSize
		profile.VmSize = &vmSize
	}

	// No error
	return nil
}

// AssignProperties_From_NodePoolPlatformProfile_STATUS populates our NodePoolPlatformProfile_STATUS from the provided source NodePoolPlatformProfile_STATUS
func (profile *NodePoolPlatformProfile_STATUS) AssignProperties_From_NodePoolPlatformProfile_STATUS(source *storage.NodePoolPlatformProfile_STATUS) error {

	// AvailabilityZone
	profile.AvailabilityZone = genruntime.ClonePointerToString(source.AvailabilityZone)

	// EnableEncryptionAtHost
	if source.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *source.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		profile.EnableEncryptionAtHost = nil
	}

	// OsDisk
	if source.OsDisk != nil {
		var osDisk OsDiskProfile_STATUS
		err := osDisk.AssignProperties_From_OsDiskProfile_STATUS(source.OsDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OsDiskProfile_STATUS() to populate field OsDisk")
		}
		profile.OsDisk = &osDisk
	} else {
		profile.OsDisk = nil
	}

	// SubnetId
	profile.SubnetId = genruntime.ClonePointerToString(source.SubnetId)

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// No error
	return nil
}

// AssignProperties_To_NodePoolPlatformProfile_STATUS populates the provided destination NodePoolPlatformProfile_STATUS from our NodePoolPlatformProfile_STATUS
func (profile *NodePoolPlatformProfile_STATUS) AssignProperties_To_NodePoolPlatformProfile_STATUS(destination *storage.NodePoolPlatformProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AvailabilityZone
	destination.AvailabilityZone = genruntime.ClonePointerToString(profile.AvailabilityZone)

	// EnableEncryptionAtHost
	if profile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *profile.EnableEncryptionAtHost
		destination.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		destination.EnableEncryptionAtHost = nil
	}

	// OsDisk
	if profile.OsDisk != nil {
		var osDisk storage.OsDiskProfile_STATUS
		err := profile.OsDisk.AssignProperties_To_OsDiskProfile_STATUS(&osDisk)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OsDiskProfile_STATUS() to populate field OsDisk")
		}
		destination.OsDisk = &osDisk
	} else {
		destination.OsDisk = nil
	}

	// SubnetId
	destination.SubnetId = genruntime.ClonePointerToString(profile.SubnetId)

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Versions represents an OpenShift version.
type NodePoolVersionProfile struct {
	// ChannelGroup: ChannelGroup is the name of the set to which this version belongs. Each version belongs to only a single
	// set.
	ChannelGroup *string `json:"channelGroup,omitempty"`

	// Id: ID is the unique identifier of the version.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.ARMTransformer = &NodePoolVersionProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *NodePoolVersionProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.NodePoolVersionProfile{}

	// Set property "ChannelGroup":
	if profile.ChannelGroup != nil {
		channelGroup := *profile.ChannelGroup
		result.ChannelGroup = &channelGroup
	}

	// Set property "Id":
	if profile.Id != nil {
		id := *profile.Id
		result.Id = &id
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *NodePoolVersionProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NodePoolVersionProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *NodePoolVersionProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NodePoolVersionProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NodePoolVersionProfile, got %T", armInput)
	}

	// Set property "ChannelGroup":
	if typedInput.ChannelGroup != nil {
		channelGroup := *typedInput.ChannelGroup
		profile.ChannelGroup = &channelGroup
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		profile.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_NodePoolVersionProfile populates our NodePoolVersionProfile from the provided source NodePoolVersionProfile
func (profile *NodePoolVersionProfile) AssignProperties_From_NodePoolVersionProfile(source *storage.NodePoolVersionProfile) error {

	// ChannelGroup
	profile.ChannelGroup = genruntime.ClonePointerToString(source.ChannelGroup)

	// Id
	profile.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_NodePoolVersionProfile populates the provided destination NodePoolVersionProfile from our NodePoolVersionProfile
func (profile *NodePoolVersionProfile) AssignProperties_To_NodePoolVersionProfile(destination *storage.NodePoolVersionProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ChannelGroup
	destination.ChannelGroup = genruntime.ClonePointerToString(profile.ChannelGroup)

	// Id
	destination.Id = genruntime.ClonePointerToString(profile.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NodePoolVersionProfile_STATUS populates our NodePoolVersionProfile from the provided source NodePoolVersionProfile_STATUS
func (profile *NodePoolVersionProfile) Initialize_From_NodePoolVersionProfile_STATUS(source *NodePoolVersionProfile_STATUS) error {

	// ChannelGroup
	profile.ChannelGroup = genruntime.ClonePointerToString(source.ChannelGroup)

	// Id
	profile.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// Versions represents an OpenShift version.
type NodePoolVersionProfile_STATUS struct {
	// ChannelGroup: ChannelGroup is the name of the set to which this version belongs. Each version belongs to only a single
	// set.
	ChannelGroup *string `json:"channelGroup,omitempty"`

	// Id: ID is the unique identifier of the version.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &NodePoolVersionProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *NodePoolVersionProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NodePoolVersionProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *NodePoolVersionProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NodePoolVersionProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NodePoolVersionProfile_STATUS, got %T", armInput)
	}

	// Set property "ChannelGroup":
	if typedInput.ChannelGroup != nil {
		channelGroup := *typedInput.ChannelGroup
		profile.ChannelGroup = &channelGroup
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		profile.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_NodePoolVersionProfile_STATUS populates our NodePoolVersionProfile_STATUS from the provided source NodePoolVersionProfile_STATUS
func (profile *NodePoolVersionProfile_STATUS) AssignProperties_From_NodePoolVersionProfile_STATUS(source *storage.NodePoolVersionProfile_STATUS) error {

	// ChannelGroup
	profile.ChannelGroup = genruntime.ClonePointerToString(source.ChannelGroup)

	// Id
	profile.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_NodePoolVersionProfile_STATUS populates the provided destination NodePoolVersionProfile_STATUS from our NodePoolVersionProfile_STATUS
func (profile *NodePoolVersionProfile_STATUS) AssignProperties_To_NodePoolVersionProfile_STATUS(destination *storage.NodePoolVersionProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ChannelGroup
	destination.ChannelGroup = genruntime.ClonePointerToString(profile.ChannelGroup)

	// Id
	destination.Id = genruntime.ClonePointerToString(profile.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Taint is controlling the node taint and its effects
type Taint struct {
	// +kubebuilder:validation:Required
	// Effect: The effect of the taint
	Effect *Effect `json:"effect,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=316
	// +kubebuilder:validation:MinLength=1
	// Key: The key of the taint
	Key *string `json:"key,omitempty"`

	// +kubebuilder:validation:MaxLength=63
	// Value: The value of the taint
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &Taint{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (taint *Taint) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if taint == nil {
		return nil, nil
	}
	result := &arm.Taint{}

	// Set property "Effect":
	if taint.Effect != nil {
		var temp string
		temp = string(*taint.Effect)
		effect := arm.Effect(temp)
		result.Effect = &effect
	}

	// Set property "Key":
	if taint.Key != nil {
		key := *taint.Key
		result.Key = &key
	}

	// Set property "Value":
	if taint.Value != nil {
		value := *taint.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (taint *Taint) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Taint{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (taint *Taint) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Taint)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Taint, got %T", armInput)
	}

	// Set property "Effect":
	if typedInput.Effect != nil {
		var temp string
		temp = string(*typedInput.Effect)
		effect := Effect(temp)
		taint.Effect = &effect
	}

	// Set property "Key":
	if typedInput.Key != nil {
		key := *typedInput.Key
		taint.Key = &key
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		taint.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_Taint populates our Taint from the provided source Taint
func (taint *Taint) AssignProperties_From_Taint(source *storage.Taint) error {

	// Effect
	if source.Effect != nil {
		effect := *source.Effect
		effectTemp := genruntime.ToEnum(effect, effect_Values)
		taint.Effect = &effectTemp
	} else {
		taint.Effect = nil
	}

	// Key
	taint.Key = genruntime.ClonePointerToString(source.Key)

	// Value
	taint.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_Taint populates the provided destination Taint from our Taint
func (taint *Taint) AssignProperties_To_Taint(destination *storage.Taint) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Effect
	if taint.Effect != nil {
		effect := string(*taint.Effect)
		destination.Effect = &effect
	} else {
		destination.Effect = nil
	}

	// Key
	destination.Key = genruntime.ClonePointerToString(taint.Key)

	// Value
	destination.Value = genruntime.ClonePointerToString(taint.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Taint_STATUS populates our Taint from the provided source Taint_STATUS
func (taint *Taint) Initialize_From_Taint_STATUS(source *Taint_STATUS) error {

	// Effect
	if source.Effect != nil {
		effect := genruntime.ToEnum(string(*source.Effect), effect_Values)
		taint.Effect = &effect
	} else {
		taint.Effect = nil
	}

	// Key
	taint.Key = genruntime.ClonePointerToString(source.Key)

	// Value
	taint.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// Taint is controlling the node taint and its effects
type Taint_STATUS struct {
	// Effect: The effect of the taint
	Effect *Effect_STATUS `json:"effect,omitempty"`

	// Key: The key of the taint
	Key *string `json:"key,omitempty"`

	// Value: The value of the taint
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &Taint_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (taint *Taint_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Taint_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (taint *Taint_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Taint_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Taint_STATUS, got %T", armInput)
	}

	// Set property "Effect":
	if typedInput.Effect != nil {
		var temp string
		temp = string(*typedInput.Effect)
		effect := Effect_STATUS(temp)
		taint.Effect = &effect
	}

	// Set property "Key":
	if typedInput.Key != nil {
		key := *typedInput.Key
		taint.Key = &key
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		taint.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_Taint_STATUS populates our Taint_STATUS from the provided source Taint_STATUS
func (taint *Taint_STATUS) AssignProperties_From_Taint_STATUS(source *storage.Taint_STATUS) error {

	// Effect
	if source.Effect != nil {
		effect := *source.Effect
		effectTemp := genruntime.ToEnum(effect, effect_STATUS_Values)
		taint.Effect = &effectTemp
	} else {
		taint.Effect = nil
	}

	// Key
	taint.Key = genruntime.ClonePointerToString(source.Key)

	// Value
	taint.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_Taint_STATUS populates the provided destination Taint_STATUS from our Taint_STATUS
func (taint *Taint_STATUS) AssignProperties_To_Taint_STATUS(destination *storage.Taint_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Effect
	if taint.Effect != nil {
		effect := string(*taint.Effect)
		destination.Effect = &effect
	} else {
		destination.Effect = nil
	}

	// Key
	destination.Key = genruntime.ClonePointerToString(taint.Key)

	// Value
	destination.Value = genruntime.ClonePointerToString(taint.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The taint effect the same as in Kubernetes
// +kubebuilder:validation:Enum={"NoExecute","NoSchedule","PreferNoSchedule"}
type Effect string

const (
	Effect_NoExecute        = Effect("NoExecute")
	Effect_NoSchedule       = Effect("NoSchedule")
	Effect_PreferNoSchedule = Effect("PreferNoSchedule")
)

// Mapping from string to Effect
var effect_Values = map[string]Effect{
	"noexecute":        Effect_NoExecute,
	"noschedule":       Effect_NoSchedule,
	"prefernoschedule": Effect_PreferNoSchedule,
}

// The taint effect the same as in Kubernetes
type Effect_STATUS string

const (
	Effect_STATUS_NoExecute        = Effect_STATUS("NoExecute")
	Effect_STATUS_NoSchedule       = Effect_STATUS("NoSchedule")
	Effect_STATUS_PreferNoSchedule = Effect_STATUS("PreferNoSchedule")
)

// Mapping from string to Effect_STATUS
var effect_STATUS_Values = map[string]Effect_STATUS{
	"noexecute":        Effect_STATUS_NoExecute,
	"noschedule":       Effect_STATUS_NoSchedule,
	"prefernoschedule": Effect_STATUS_PreferNoSchedule,
}

// The settings and configuration options for OSDisk
type OsDiskProfile struct {
	// DiskStorageAccountType: The type of the disk storage account
	// - https://learn.microsoft.com/en-us/azure/virtual-machines/disks-types
	DiskStorageAccountType *OsDiskProfile_DiskStorageAccountType `json:"diskStorageAccountType,omitempty"`

	// EncryptionSetReference: The ID of the DiskEncryptionSet resource to use to encrypt the OS disks for the VMs.
	// This needs to exist in the same subscription id listed in the Hosted Cluster,
	// HostedCluster.Spec.Platform.Azure.SubscriptionID.
	// DiskEncryptionSetID should also exist in a resource group under the same subscription id and the same location
	// listed in the Hosted Cluster, HostedCluster.Spec.Platform.Azure.Location.
	// Details on how to create a Disk Encryption Set can be found here:
	// https://learn.microsoft.com/en-us/azure/virtual-machines/disks-enable-customer-managed-keys-portal#set-up-your-disk-encryption-set
	EncryptionSetReference *genruntime.ResourceReference `armReference:"EncryptionSetId" json:"encryptionSetReference,omitempty"`

	// SizeGiB: The OS disk size in GiB
	SizeGiB *int `json:"sizeGiB,omitempty"`
}

var _ genruntime.ARMTransformer = &OsDiskProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *OsDiskProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.OsDiskProfile{}

	// Set property "DiskStorageAccountType":
	if profile.DiskStorageAccountType != nil {
		var temp string
		temp = string(*profile.DiskStorageAccountType)
		diskStorageAccountType := arm.OsDiskProfile_DiskStorageAccountType(temp)
		result.DiskStorageAccountType = &diskStorageAccountType
	}

	// Set property "EncryptionSetId":
	if profile.EncryptionSetReference != nil {
		encryptionSetReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.EncryptionSetReference)
		if err != nil {
			return nil, err
		}
		encryptionSetReference := encryptionSetReferenceARMID
		result.EncryptionSetId = &encryptionSetReference
	}

	// Set property "SizeGiB":
	if profile.SizeGiB != nil {
		sizeGiB := *profile.SizeGiB
		result.SizeGiB = &sizeGiB
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *OsDiskProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OsDiskProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *OsDiskProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OsDiskProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OsDiskProfile, got %T", armInput)
	}

	// Set property "DiskStorageAccountType":
	if typedInput.DiskStorageAccountType != nil {
		var temp string
		temp = string(*typedInput.DiskStorageAccountType)
		diskStorageAccountType := OsDiskProfile_DiskStorageAccountType(temp)
		profile.DiskStorageAccountType = &diskStorageAccountType
	}

	// no assignment for property "EncryptionSetReference"

	// Set property "SizeGiB":
	if typedInput.SizeGiB != nil {
		sizeGiB := *typedInput.SizeGiB
		profile.SizeGiB = &sizeGiB
	}

	// No error
	return nil
}

// AssignProperties_From_OsDiskProfile populates our OsDiskProfile from the provided source OsDiskProfile
func (profile *OsDiskProfile) AssignProperties_From_OsDiskProfile(source *storage.OsDiskProfile) error {

	// DiskStorageAccountType
	if source.DiskStorageAccountType != nil {
		diskStorageAccountType := *source.DiskStorageAccountType
		diskStorageAccountTypeTemp := genruntime.ToEnum(diskStorageAccountType, osDiskProfile_DiskStorageAccountType_Values)
		profile.DiskStorageAccountType = &diskStorageAccountTypeTemp
	} else {
		profile.DiskStorageAccountType = nil
	}

	// EncryptionSetReference
	if source.EncryptionSetReference != nil {
		encryptionSetReference := source.EncryptionSetReference.Copy()
		profile.EncryptionSetReference = &encryptionSetReference
	} else {
		profile.EncryptionSetReference = nil
	}

	// SizeGiB
	profile.SizeGiB = genruntime.ClonePointerToInt(source.SizeGiB)

	// No error
	return nil
}

// AssignProperties_To_OsDiskProfile populates the provided destination OsDiskProfile from our OsDiskProfile
func (profile *OsDiskProfile) AssignProperties_To_OsDiskProfile(destination *storage.OsDiskProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskStorageAccountType
	if profile.DiskStorageAccountType != nil {
		diskStorageAccountType := string(*profile.DiskStorageAccountType)
		destination.DiskStorageAccountType = &diskStorageAccountType
	} else {
		destination.DiskStorageAccountType = nil
	}

	// EncryptionSetReference
	if profile.EncryptionSetReference != nil {
		encryptionSetReference := profile.EncryptionSetReference.Copy()
		destination.EncryptionSetReference = &encryptionSetReference
	} else {
		destination.EncryptionSetReference = nil
	}

	// SizeGiB
	destination.SizeGiB = genruntime.ClonePointerToInt(profile.SizeGiB)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OsDiskProfile_STATUS populates our OsDiskProfile from the provided source OsDiskProfile_STATUS
func (profile *OsDiskProfile) Initialize_From_OsDiskProfile_STATUS(source *OsDiskProfile_STATUS) error {

	// DiskStorageAccountType
	if source.DiskStorageAccountType != nil {
		diskStorageAccountType := genruntime.ToEnum(string(*source.DiskStorageAccountType), osDiskProfile_DiskStorageAccountType_Values)
		profile.DiskStorageAccountType = &diskStorageAccountType
	} else {
		profile.DiskStorageAccountType = nil
	}

	// EncryptionSetReference
	if source.EncryptionSetId != nil {
		encryptionSetReference := genruntime.CreateResourceReferenceFromARMID(*source.EncryptionSetId)
		profile.EncryptionSetReference = &encryptionSetReference
	} else {
		profile.EncryptionSetReference = nil
	}

	// SizeGiB
	profile.SizeGiB = genruntime.ClonePointerToInt(source.SizeGiB)

	// No error
	return nil
}

// The settings and configuration options for OSDisk
type OsDiskProfile_STATUS struct {
	// DiskStorageAccountType: The type of the disk storage account
	// - https://learn.microsoft.com/en-us/azure/virtual-machines/disks-types
	DiskStorageAccountType *OsDiskProfile_DiskStorageAccountType_STATUS `json:"diskStorageAccountType,omitempty"`

	// EncryptionSetId: The ID of the DiskEncryptionSet resource to use to encrypt the OS disks for the VMs.
	// This needs to exist in the same subscription id listed in the Hosted Cluster,
	// HostedCluster.Spec.Platform.Azure.SubscriptionID.
	// DiskEncryptionSetID should also exist in a resource group under the same subscription id and the same location
	// listed in the Hosted Cluster, HostedCluster.Spec.Platform.Azure.Location.
	// Details on how to create a Disk Encryption Set can be found here:
	// https://learn.microsoft.com/en-us/azure/virtual-machines/disks-enable-customer-managed-keys-portal#set-up-your-disk-encryption-set
	EncryptionSetId *string `json:"encryptionSetId,omitempty"`

	// SizeGiB: The OS disk size in GiB
	SizeGiB *int `json:"sizeGiB,omitempty"`
}

var _ genruntime.FromARMConverter = &OsDiskProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *OsDiskProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OsDiskProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *OsDiskProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OsDiskProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OsDiskProfile_STATUS, got %T", armInput)
	}

	// Set property "DiskStorageAccountType":
	if typedInput.DiskStorageAccountType != nil {
		var temp string
		temp = string(*typedInput.DiskStorageAccountType)
		diskStorageAccountType := OsDiskProfile_DiskStorageAccountType_STATUS(temp)
		profile.DiskStorageAccountType = &diskStorageAccountType
	}

	// Set property "EncryptionSetId":
	if typedInput.EncryptionSetId != nil {
		encryptionSetId := *typedInput.EncryptionSetId
		profile.EncryptionSetId = &encryptionSetId
	}

	// Set property "SizeGiB":
	if typedInput.SizeGiB != nil {
		sizeGiB := *typedInput.SizeGiB
		profile.SizeGiB = &sizeGiB
	}

	// No error
	return nil
}

// AssignProperties_From_OsDiskProfile_STATUS populates our OsDiskProfile_STATUS from the provided source OsDiskProfile_STATUS
func (profile *OsDiskProfile_STATUS) AssignProperties_From_OsDiskProfile_STATUS(source *storage.OsDiskProfile_STATUS) error {

	// DiskStorageAccountType
	if source.DiskStorageAccountType != nil {
		diskStorageAccountType := *source.DiskStorageAccountType
		diskStorageAccountTypeTemp := genruntime.ToEnum(diskStorageAccountType, osDiskProfile_DiskStorageAccountType_STATUS_Values)
		profile.DiskStorageAccountType = &diskStorageAccountTypeTemp
	} else {
		profile.DiskStorageAccountType = nil
	}

	// EncryptionSetId
	profile.EncryptionSetId = genruntime.ClonePointerToString(source.EncryptionSetId)

	// SizeGiB
	profile.SizeGiB = genruntime.ClonePointerToInt(source.SizeGiB)

	// No error
	return nil
}

// AssignProperties_To_OsDiskProfile_STATUS populates the provided destination OsDiskProfile_STATUS from our OsDiskProfile_STATUS
func (profile *OsDiskProfile_STATUS) AssignProperties_To_OsDiskProfile_STATUS(destination *storage.OsDiskProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DiskStorageAccountType
	if profile.DiskStorageAccountType != nil {
		diskStorageAccountType := string(*profile.DiskStorageAccountType)
		destination.DiskStorageAccountType = &diskStorageAccountType
	} else {
		destination.DiskStorageAccountType = nil
	}

	// EncryptionSetId
	destination.EncryptionSetId = genruntime.ClonePointerToString(profile.EncryptionSetId)

	// SizeGiB
	destination.SizeGiB = genruntime.ClonePointerToInt(profile.SizeGiB)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Premium_LRS","StandardSSD_LRS","Standard_LRS"}
type OsDiskProfile_DiskStorageAccountType string

const (
	OsDiskProfile_DiskStorageAccountType_Premium_LRS     = OsDiskProfile_DiskStorageAccountType("Premium_LRS")
	OsDiskProfile_DiskStorageAccountType_StandardSSD_LRS = OsDiskProfile_DiskStorageAccountType("StandardSSD_LRS")
	OsDiskProfile_DiskStorageAccountType_Standard_LRS    = OsDiskProfile_DiskStorageAccountType("Standard_LRS")
)

// Mapping from string to OsDiskProfile_DiskStorageAccountType
var osDiskProfile_DiskStorageAccountType_Values = map[string]OsDiskProfile_DiskStorageAccountType{
	"premium_lrs":     OsDiskProfile_DiskStorageAccountType_Premium_LRS,
	"standardssd_lrs": OsDiskProfile_DiskStorageAccountType_StandardSSD_LRS,
	"standard_lrs":    OsDiskProfile_DiskStorageAccountType_Standard_LRS,
}

type OsDiskProfile_DiskStorageAccountType_STATUS string

const (
	OsDiskProfile_DiskStorageAccountType_STATUS_Premium_LRS     = OsDiskProfile_DiskStorageAccountType_STATUS("Premium_LRS")
	OsDiskProfile_DiskStorageAccountType_STATUS_StandardSSD_LRS = OsDiskProfile_DiskStorageAccountType_STATUS("StandardSSD_LRS")
	OsDiskProfile_DiskStorageAccountType_STATUS_Standard_LRS    = OsDiskProfile_DiskStorageAccountType_STATUS("Standard_LRS")
)

// Mapping from string to OsDiskProfile_DiskStorageAccountType_STATUS
var osDiskProfile_DiskStorageAccountType_STATUS_Values = map[string]OsDiskProfile_DiskStorageAccountType_STATUS{
	"premium_lrs":     OsDiskProfile_DiskStorageAccountType_STATUS_Premium_LRS,
	"standardssd_lrs": OsDiskProfile_DiskStorageAccountType_STATUS_StandardSSD_LRS,
	"standard_lrs":    OsDiskProfile_DiskStorageAccountType_STATUS_Standard_LRS,
}

func init() {
	SchemeBuilder.Register(&HcpOpenShiftClustersNodePool{}, &HcpOpenShiftClustersNodePoolList{})
}
