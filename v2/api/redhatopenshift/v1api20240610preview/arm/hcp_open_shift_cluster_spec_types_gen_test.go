// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ApiProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProfile, ApiProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProfile runs a test to see if a specific instance of ApiProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProfile(subject ApiProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProfile instances for property testing - lazily instantiated by ApiProfileGenerator()
var apiProfileGenerator gopter.Gen

// ApiProfileGenerator returns a generator of ApiProfile instances for property testing.
func ApiProfileGenerator() gopter.Gen {
	if apiProfileGenerator != nil {
		return apiProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProfile(generators)
	apiProfileGenerator = gen.Struct(reflect.TypeOf(ApiProfile{}), generators)

	return apiProfileGenerator
}

// AddIndependentPropertyGeneratorsForApiProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProfile(gens map[string]gopter.Gen) {
	gens["AuthorizedCidrs"] = gen.SliceOf(gen.AlphaString())
	gens["Visibility"] = gen.PtrOf(gen.OneConstOf(ApiProfile_Visibility_Private, ApiProfile_Visibility_Public))
}

func Test_ClusterAutoscalingProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClusterAutoscalingProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClusterAutoscalingProfile, ClusterAutoscalingProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClusterAutoscalingProfile runs a test to see if a specific instance of ClusterAutoscalingProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForClusterAutoscalingProfile(subject ClusterAutoscalingProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClusterAutoscalingProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClusterAutoscalingProfile instances for property testing - lazily instantiated by
// ClusterAutoscalingProfileGenerator()
var clusterAutoscalingProfileGenerator gopter.Gen

// ClusterAutoscalingProfileGenerator returns a generator of ClusterAutoscalingProfile instances for property testing.
func ClusterAutoscalingProfileGenerator() gopter.Gen {
	if clusterAutoscalingProfileGenerator != nil {
		return clusterAutoscalingProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClusterAutoscalingProfile(generators)
	clusterAutoscalingProfileGenerator = gen.Struct(reflect.TypeOf(ClusterAutoscalingProfile{}), generators)

	return clusterAutoscalingProfileGenerator
}

// AddIndependentPropertyGeneratorsForClusterAutoscalingProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClusterAutoscalingProfile(gens map[string]gopter.Gen) {
	gens["MaxNodeProvisionTimeSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxNodesTotal"] = gen.PtrOf(gen.Int())
	gens["MaxPodGracePeriodSeconds"] = gen.PtrOf(gen.Int())
	gens["PodPriorityThreshold"] = gen.PtrOf(gen.Int())
}

func Test_ClusterImageRegistryProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClusterImageRegistryProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClusterImageRegistryProfile, ClusterImageRegistryProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClusterImageRegistryProfile runs a test to see if a specific instance of ClusterImageRegistryProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForClusterImageRegistryProfile(subject ClusterImageRegistryProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClusterImageRegistryProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClusterImageRegistryProfile instances for property testing - lazily instantiated by
// ClusterImageRegistryProfileGenerator()
var clusterImageRegistryProfileGenerator gopter.Gen

// ClusterImageRegistryProfileGenerator returns a generator of ClusterImageRegistryProfile instances for property testing.
func ClusterImageRegistryProfileGenerator() gopter.Gen {
	if clusterImageRegistryProfileGenerator != nil {
		return clusterImageRegistryProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClusterImageRegistryProfile(generators)
	clusterImageRegistryProfileGenerator = gen.Struct(reflect.TypeOf(ClusterImageRegistryProfile{}), generators)

	return clusterImageRegistryProfileGenerator
}

// AddIndependentPropertyGeneratorsForClusterImageRegistryProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClusterImageRegistryProfile(gens map[string]gopter.Gen) {
	gens["State"] = gen.PtrOf(gen.OneConstOf(ClusterImageRegistryProfile_State_Disabled, ClusterImageRegistryProfile_State_Enabled))
}

func Test_CustomerManagedEncryptionProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomerManagedEncryptionProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomerManagedEncryptionProfile, CustomerManagedEncryptionProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomerManagedEncryptionProfile runs a test to see if a specific instance of CustomerManagedEncryptionProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomerManagedEncryptionProfile(subject CustomerManagedEncryptionProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomerManagedEncryptionProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomerManagedEncryptionProfile instances for property testing - lazily instantiated by
// CustomerManagedEncryptionProfileGenerator()
var customerManagedEncryptionProfileGenerator gopter.Gen

// CustomerManagedEncryptionProfileGenerator returns a generator of CustomerManagedEncryptionProfile instances for property testing.
// We first initialize customerManagedEncryptionProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomerManagedEncryptionProfileGenerator() gopter.Gen {
	if customerManagedEncryptionProfileGenerator != nil {
		return customerManagedEncryptionProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomerManagedEncryptionProfile(generators)
	customerManagedEncryptionProfileGenerator = gen.Struct(reflect.TypeOf(CustomerManagedEncryptionProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomerManagedEncryptionProfile(generators)
	AddRelatedPropertyGeneratorsForCustomerManagedEncryptionProfile(generators)
	customerManagedEncryptionProfileGenerator = gen.Struct(reflect.TypeOf(CustomerManagedEncryptionProfile{}), generators)

	return customerManagedEncryptionProfileGenerator
}

// AddIndependentPropertyGeneratorsForCustomerManagedEncryptionProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomerManagedEncryptionProfile(gens map[string]gopter.Gen) {
	gens["EncryptionType"] = gen.PtrOf(gen.OneConstOf(CustomerManagedEncryptionProfile_EncryptionType_KMS))
}

// AddRelatedPropertyGeneratorsForCustomerManagedEncryptionProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomerManagedEncryptionProfile(gens map[string]gopter.Gen) {
	gens["Kms"] = gen.PtrOf(KmsEncryptionProfileGenerator())
}

func Test_DnsProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DnsProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDnsProfile, DnsProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDnsProfile runs a test to see if a specific instance of DnsProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForDnsProfile(subject DnsProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DnsProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DnsProfile instances for property testing - lazily instantiated by DnsProfileGenerator()
var dnsProfileGenerator gopter.Gen

// DnsProfileGenerator returns a generator of DnsProfile instances for property testing.
func DnsProfileGenerator() gopter.Gen {
	if dnsProfileGenerator != nil {
		return dnsProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDnsProfile(generators)
	dnsProfileGenerator = gen.Struct(reflect.TypeOf(DnsProfile{}), generators)

	return dnsProfileGenerator
}

// AddIndependentPropertyGeneratorsForDnsProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDnsProfile(gens map[string]gopter.Gen) {
	gens["BaseDomainPrefix"] = gen.PtrOf(gen.AlphaString())
}

func Test_EtcdDataEncryptionProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EtcdDataEncryptionProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEtcdDataEncryptionProfile, EtcdDataEncryptionProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEtcdDataEncryptionProfile runs a test to see if a specific instance of EtcdDataEncryptionProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForEtcdDataEncryptionProfile(subject EtcdDataEncryptionProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EtcdDataEncryptionProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EtcdDataEncryptionProfile instances for property testing - lazily instantiated by
// EtcdDataEncryptionProfileGenerator()
var etcdDataEncryptionProfileGenerator gopter.Gen

// EtcdDataEncryptionProfileGenerator returns a generator of EtcdDataEncryptionProfile instances for property testing.
// We first initialize etcdDataEncryptionProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EtcdDataEncryptionProfileGenerator() gopter.Gen {
	if etcdDataEncryptionProfileGenerator != nil {
		return etcdDataEncryptionProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEtcdDataEncryptionProfile(generators)
	etcdDataEncryptionProfileGenerator = gen.Struct(reflect.TypeOf(EtcdDataEncryptionProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEtcdDataEncryptionProfile(generators)
	AddRelatedPropertyGeneratorsForEtcdDataEncryptionProfile(generators)
	etcdDataEncryptionProfileGenerator = gen.Struct(reflect.TypeOf(EtcdDataEncryptionProfile{}), generators)

	return etcdDataEncryptionProfileGenerator
}

// AddIndependentPropertyGeneratorsForEtcdDataEncryptionProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEtcdDataEncryptionProfile(gens map[string]gopter.Gen) {
	gens["KeyManagementMode"] = gen.PtrOf(gen.OneConstOf(EtcdDataEncryptionProfile_KeyManagementMode_CustomerManaged, EtcdDataEncryptionProfile_KeyManagementMode_PlatformManaged))
}

// AddRelatedPropertyGeneratorsForEtcdDataEncryptionProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEtcdDataEncryptionProfile(gens map[string]gopter.Gen) {
	gens["CustomerManaged"] = gen.PtrOf(CustomerManagedEncryptionProfileGenerator())
}

func Test_EtcdProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EtcdProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEtcdProfile, EtcdProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEtcdProfile runs a test to see if a specific instance of EtcdProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForEtcdProfile(subject EtcdProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EtcdProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EtcdProfile instances for property testing - lazily instantiated by EtcdProfileGenerator()
var etcdProfileGenerator gopter.Gen

// EtcdProfileGenerator returns a generator of EtcdProfile instances for property testing.
func EtcdProfileGenerator() gopter.Gen {
	if etcdProfileGenerator != nil {
		return etcdProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForEtcdProfile(generators)
	etcdProfileGenerator = gen.Struct(reflect.TypeOf(EtcdProfile{}), generators)

	return etcdProfileGenerator
}

// AddRelatedPropertyGeneratorsForEtcdProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEtcdProfile(gens map[string]gopter.Gen) {
	gens["DataEncryption"] = gen.PtrOf(EtcdDataEncryptionProfileGenerator())
}

func Test_HcpOpenShiftClusterProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HcpOpenShiftClusterProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHcpOpenShiftClusterProperties, HcpOpenShiftClusterPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHcpOpenShiftClusterProperties runs a test to see if a specific instance of HcpOpenShiftClusterProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForHcpOpenShiftClusterProperties(subject HcpOpenShiftClusterProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HcpOpenShiftClusterProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HcpOpenShiftClusterProperties instances for property testing - lazily instantiated by
// HcpOpenShiftClusterPropertiesGenerator()
var hcpOpenShiftClusterPropertiesGenerator gopter.Gen

// HcpOpenShiftClusterPropertiesGenerator returns a generator of HcpOpenShiftClusterProperties instances for property testing.
// We first initialize hcpOpenShiftClusterPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HcpOpenShiftClusterPropertiesGenerator() gopter.Gen {
	if hcpOpenShiftClusterPropertiesGenerator != nil {
		return hcpOpenShiftClusterPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftClusterProperties(generators)
	hcpOpenShiftClusterPropertiesGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClusterProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftClusterProperties(generators)
	AddRelatedPropertyGeneratorsForHcpOpenShiftClusterProperties(generators)
	hcpOpenShiftClusterPropertiesGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClusterProperties{}), generators)

	return hcpOpenShiftClusterPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForHcpOpenShiftClusterProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHcpOpenShiftClusterProperties(gens map[string]gopter.Gen) {
	gens["NodeDrainTimeoutMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForHcpOpenShiftClusterProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHcpOpenShiftClusterProperties(gens map[string]gopter.Gen) {
	gens["Api"] = gen.PtrOf(ApiProfileGenerator())
	gens["Autoscaling"] = gen.PtrOf(ClusterAutoscalingProfileGenerator())
	gens["ClusterImageRegistry"] = gen.PtrOf(ClusterImageRegistryProfileGenerator())
	gens["Dns"] = gen.PtrOf(DnsProfileGenerator())
	gens["Etcd"] = gen.PtrOf(EtcdProfileGenerator())
	gens["Network"] = gen.PtrOf(NetworkProfileGenerator())
	gens["Platform"] = gen.PtrOf(PlatformProfileGenerator())
	gens["Version"] = gen.PtrOf(VersionProfileGenerator())
}

func Test_HcpOpenShiftCluster_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HcpOpenShiftCluster_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHcpOpenShiftCluster_Spec, HcpOpenShiftCluster_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHcpOpenShiftCluster_Spec runs a test to see if a specific instance of HcpOpenShiftCluster_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForHcpOpenShiftCluster_Spec(subject HcpOpenShiftCluster_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HcpOpenShiftCluster_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HcpOpenShiftCluster_Spec instances for property testing - lazily instantiated by
// HcpOpenShiftCluster_SpecGenerator()
var hcpOpenShiftCluster_SpecGenerator gopter.Gen

// HcpOpenShiftCluster_SpecGenerator returns a generator of HcpOpenShiftCluster_Spec instances for property testing.
// We first initialize hcpOpenShiftCluster_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HcpOpenShiftCluster_SpecGenerator() gopter.Gen {
	if hcpOpenShiftCluster_SpecGenerator != nil {
		return hcpOpenShiftCluster_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftCluster_Spec(generators)
	hcpOpenShiftCluster_SpecGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftCluster_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftCluster_Spec(generators)
	AddRelatedPropertyGeneratorsForHcpOpenShiftCluster_Spec(generators)
	hcpOpenShiftCluster_SpecGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftCluster_Spec{}), generators)

	return hcpOpenShiftCluster_SpecGenerator
}

// AddIndependentPropertyGeneratorsForHcpOpenShiftCluster_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHcpOpenShiftCluster_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHcpOpenShiftCluster_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHcpOpenShiftCluster_Spec(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["Properties"] = gen.PtrOf(HcpOpenShiftClusterPropertiesGenerator())
}

func Test_KmsEncryptionProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KmsEncryptionProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKmsEncryptionProfile, KmsEncryptionProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKmsEncryptionProfile runs a test to see if a specific instance of KmsEncryptionProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForKmsEncryptionProfile(subject KmsEncryptionProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KmsEncryptionProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KmsEncryptionProfile instances for property testing - lazily instantiated by
// KmsEncryptionProfileGenerator()
var kmsEncryptionProfileGenerator gopter.Gen

// KmsEncryptionProfileGenerator returns a generator of KmsEncryptionProfile instances for property testing.
func KmsEncryptionProfileGenerator() gopter.Gen {
	if kmsEncryptionProfileGenerator != nil {
		return kmsEncryptionProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForKmsEncryptionProfile(generators)
	kmsEncryptionProfileGenerator = gen.Struct(reflect.TypeOf(KmsEncryptionProfile{}), generators)

	return kmsEncryptionProfileGenerator
}

// AddRelatedPropertyGeneratorsForKmsEncryptionProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForKmsEncryptionProfile(gens map[string]gopter.Gen) {
	gens["ActiveKey"] = gen.PtrOf(KmsKeyGenerator())
}

func Test_KmsKey_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KmsKey via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKmsKey, KmsKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKmsKey runs a test to see if a specific instance of KmsKey round trips to JSON and back losslessly
func RunJSONSerializationTestForKmsKey(subject KmsKey) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KmsKey
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KmsKey instances for property testing - lazily instantiated by KmsKeyGenerator()
var kmsKeyGenerator gopter.Gen

// KmsKeyGenerator returns a generator of KmsKey instances for property testing.
func KmsKeyGenerator() gopter.Gen {
	if kmsKeyGenerator != nil {
		return kmsKeyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKmsKey(generators)
	kmsKeyGenerator = gen.Struct(reflect.TypeOf(KmsKey{}), generators)

	return kmsKeyGenerator
}

// AddIndependentPropertyGeneratorsForKmsKey is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKmsKey(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["VaultName"] = gen.PtrOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity runs a test to see if a specific instance of ManagedServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity instances for property testing - lazily instantiated by
// ManagedServiceIdentityGenerator()
var managedServiceIdentityGenerator gopter.Gen

// ManagedServiceIdentityGenerator returns a generator of ManagedServiceIdentity instances for property testing.
// We first initialize managedServiceIdentityGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityGenerator() gopter.Gen {
	if managedServiceIdentityGenerator != nil {
		return managedServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	return managedServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityType_None,
		ManagedServiceIdentityType_SystemAssigned,
		ManagedServiceIdentityType_SystemAssignedUserAssigned,
		ManagedServiceIdentityType_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(
		gen.AlphaString(),
		UserAssignedIdentityDetailsGenerator())
}

func Test_NetworkProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of NetworkProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkProfile, NetworkProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkProfile runs a test to see if a specific instance of NetworkProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkProfile(subject NetworkProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual NetworkProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of NetworkProfile instances for property testing - lazily instantiated by NetworkProfileGenerator()
var networkProfileGenerator gopter.Gen

// NetworkProfileGenerator returns a generator of NetworkProfile instances for property testing.
func NetworkProfileGenerator() gopter.Gen {
	if networkProfileGenerator != nil {
		return networkProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkProfile(generators)
	networkProfileGenerator = gen.Struct(reflect.TypeOf(NetworkProfile{}), generators)

	return networkProfileGenerator
}

// AddIndependentPropertyGeneratorsForNetworkProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkProfile(gens map[string]gopter.Gen) {
	gens["HostPrefix"] = gen.PtrOf(gen.Int())
	gens["MachineCidr"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkType"] = gen.PtrOf(gen.OneConstOf(NetworkProfile_NetworkType_OVNKubernetes, NetworkProfile_NetworkType_Other))
	gens["PodCidr"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceCidr"] = gen.PtrOf(gen.AlphaString())
}

func Test_OperatorsAuthenticationProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OperatorsAuthenticationProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOperatorsAuthenticationProfile, OperatorsAuthenticationProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOperatorsAuthenticationProfile runs a test to see if a specific instance of OperatorsAuthenticationProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForOperatorsAuthenticationProfile(subject OperatorsAuthenticationProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OperatorsAuthenticationProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OperatorsAuthenticationProfile instances for property testing - lazily instantiated by
// OperatorsAuthenticationProfileGenerator()
var operatorsAuthenticationProfileGenerator gopter.Gen

// OperatorsAuthenticationProfileGenerator returns a generator of OperatorsAuthenticationProfile instances for property testing.
func OperatorsAuthenticationProfileGenerator() gopter.Gen {
	if operatorsAuthenticationProfileGenerator != nil {
		return operatorsAuthenticationProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForOperatorsAuthenticationProfile(generators)
	operatorsAuthenticationProfileGenerator = gen.Struct(reflect.TypeOf(OperatorsAuthenticationProfile{}), generators)

	return operatorsAuthenticationProfileGenerator
}

// AddRelatedPropertyGeneratorsForOperatorsAuthenticationProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOperatorsAuthenticationProfile(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.PtrOf(UserAssignedIdentitiesProfileGenerator())
}

func Test_PlatformProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PlatformProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPlatformProfile, PlatformProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPlatformProfile runs a test to see if a specific instance of PlatformProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForPlatformProfile(subject PlatformProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PlatformProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PlatformProfile instances for property testing - lazily instantiated by PlatformProfileGenerator()
var platformProfileGenerator gopter.Gen

// PlatformProfileGenerator returns a generator of PlatformProfile instances for property testing.
// We first initialize platformProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func PlatformProfileGenerator() gopter.Gen {
	if platformProfileGenerator != nil {
		return platformProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlatformProfile(generators)
	platformProfileGenerator = gen.Struct(reflect.TypeOf(PlatformProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPlatformProfile(generators)
	AddRelatedPropertyGeneratorsForPlatformProfile(generators)
	platformProfileGenerator = gen.Struct(reflect.TypeOf(PlatformProfile{}), generators)

	return platformProfileGenerator
}

// AddIndependentPropertyGeneratorsForPlatformProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPlatformProfile(gens map[string]gopter.Gen) {
	gens["ManagedResourceGroup"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkSecurityGroupId"] = gen.PtrOf(gen.AlphaString())
	gens["OutboundType"] = gen.PtrOf(gen.OneConstOf(PlatformProfile_OutboundType_LoadBalancer))
	gens["SubnetId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForPlatformProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForPlatformProfile(gens map[string]gopter.Gen) {
	gens["OperatorsAuthentication"] = gen.PtrOf(OperatorsAuthenticationProfileGenerator())
}

func Test_UserAssignedIdentitiesProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentitiesProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentitiesProfile, UserAssignedIdentitiesProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentitiesProfile runs a test to see if a specific instance of UserAssignedIdentitiesProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentitiesProfile(subject UserAssignedIdentitiesProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentitiesProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentitiesProfile instances for property testing - lazily instantiated by
// UserAssignedIdentitiesProfileGenerator()
var userAssignedIdentitiesProfileGenerator gopter.Gen

// UserAssignedIdentitiesProfileGenerator returns a generator of UserAssignedIdentitiesProfile instances for property testing.
func UserAssignedIdentitiesProfileGenerator() gopter.Gen {
	if userAssignedIdentitiesProfileGenerator != nil {
		return userAssignedIdentitiesProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentitiesProfile(generators)
	userAssignedIdentitiesProfileGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentitiesProfile{}), generators)

	return userAssignedIdentitiesProfileGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentitiesProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentitiesProfile(gens map[string]gopter.Gen) {
	gens["ControlPlaneOperators"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["DataPlaneOperators"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["ServiceManagedIdentity"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentityDetails_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityDetails via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityDetails, UserAssignedIdentityDetailsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityDetails runs a test to see if a specific instance of UserAssignedIdentityDetails round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityDetails(subject UserAssignedIdentityDetails) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityDetails
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityDetails instances for property testing - lazily instantiated by
// UserAssignedIdentityDetailsGenerator()
var userAssignedIdentityDetailsGenerator gopter.Gen

// UserAssignedIdentityDetailsGenerator returns a generator of UserAssignedIdentityDetails instances for property testing.
func UserAssignedIdentityDetailsGenerator() gopter.Gen {
	if userAssignedIdentityDetailsGenerator != nil {
		return userAssignedIdentityDetailsGenerator
	}

	generators := make(map[string]gopter.Gen)
	userAssignedIdentityDetailsGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityDetails{}), generators)

	return userAssignedIdentityDetailsGenerator
}

func Test_VersionProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VersionProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVersionProfile, VersionProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVersionProfile runs a test to see if a specific instance of VersionProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForVersionProfile(subject VersionProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VersionProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VersionProfile instances for property testing - lazily instantiated by VersionProfileGenerator()
var versionProfileGenerator gopter.Gen

// VersionProfileGenerator returns a generator of VersionProfile instances for property testing.
func VersionProfileGenerator() gopter.Gen {
	if versionProfileGenerator != nil {
		return versionProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVersionProfile(generators)
	versionProfileGenerator = gen.Struct(reflect.TypeOf(VersionProfile{}), generators)

	return versionProfileGenerator
}

// AddIndependentPropertyGeneratorsForVersionProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVersionProfile(gens map[string]gopter.Gen) {
	gens["ChannelGroup"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}
