// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

type HcpOpenShiftClustersNodePool_STATUS struct {
	// Id: Fully qualified resource ID for the resource. E.g.
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
	Id *string `json:"id,omitempty"`

	// Identity: The managed service identities assigned to this resource.
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Properties: The resource-specific properties for this resource.
	Properties *NodePoolProperties_STATUS `json:"properties,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

// Represents the node pool properties
type NodePoolProperties_STATUS struct {
	// AutoRepair: Auto-repair
	AutoRepair *bool `json:"autoRepair,omitempty"`

	// AutoScaling: Representation of a autoscaling in a node pool.
	AutoScaling *NodePoolAutoScaling_STATUS `json:"autoScaling,omitempty"`

	// Labels: Kubernetes labels to propagate to the NodePool Nodes
	// Note that when the labels are updated this is only applied to newly
	// create nodes in the Nodepool, existing node labels remain unchanged.
	Labels []Label_STATUS `json:"labels,omitempty"`

	// NodeDrainTimeoutMinutes: nodeDrainTimeoutMinutes is the grace period for how long Pod Disruption Budget-protected
	// workloads will be
	// respected during any node draining operation. After this grace period, any workloads protected by Pod Disruption
	// Budgets that have not been successfully drained from a node will be forcibly evicted. This is
	// especially relevant to cluster upgrades.
	// Valid values are from 0 to 10080 minutes (1 week) .
	// 0 means that the NodePool can be drained without any time limitation.
	// If unset the cluster nodeDrainTimeoutMinutes value is used as a default.
	NodeDrainTimeoutMinutes *int `json:"nodeDrainTimeoutMinutes,omitempty"`

	// Platform: Azure node pool platform configuration
	Platform *NodePoolPlatformProfile_STATUS `json:"platform,omitempty"`

	// ProvisioningState: Provisioning state
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// Replicas: The number of worker nodes, it cannot be used together with autoscaling
	Replicas *int `json:"replicas,omitempty"`

	// Taints: Taints for the nodes
	Taints []Taint_STATUS `json:"taints,omitempty"`

	// Version: OpenShift version for the nodepool
	Version *NodePoolVersionProfile_STATUS `json:"version,omitempty"`
}

// Label represents the Kubernetes label
type Label_STATUS struct {
	// Key: The key of the label
	Key *string `json:"key,omitempty"`

	// Value: The value of the label
	Value *string `json:"value,omitempty"`
}

// Node pool autoscaling
type NodePoolAutoScaling_STATUS struct {
	// Max: The maximum number of nodes in the node pool
	Max *int `json:"max,omitempty"`

	// Min: The minimum number of nodes in the node pool
	Min *int `json:"min,omitempty"`
}

// Azure node pool platform configuration
type NodePoolPlatformProfile_STATUS struct {
	// AvailabilityZone: The availability zone for the node pool.
	// Please read the documentation to see which regions support availability zones
	// - https://learn.microsoft.com/en-us/azure/availability-zones/az-overview
	AvailabilityZone *string `json:"availabilityZone,omitempty"`

	// EnableEncryptionAtHost: Whether to enable host based OS and data drive encryption.
	// -
	// https://learn.microsoft.com/en-us/azure/virtual-machines/disk-encryption#encryption-at-host---end-to-end-encryption-for-your-vm-data
	EnableEncryptionAtHost *bool `json:"enableEncryptionAtHost,omitempty"`

	// OsDisk: The settings and configuration options for OSDisk
	OsDisk *OsDiskProfile_STATUS `json:"osDisk,omitempty"`

	// SubnetId: The Azure resource ID of the worker subnet
	// Note that a subnet cannot be reused between ARO-HCP Clusters, however the
	// same subnet can be used for NodePools of the same cluster.
	SubnetId *string `json:"subnetId,omitempty"`

	// VmSize: The VM size according to the documentation:
	// - https://learn.microsoft.com/en-us/azure/virtual-machines/sizes
	VmSize *string `json:"vmSize,omitempty"`
}

// Versions represents an OpenShift version.
type NodePoolVersionProfile_STATUS struct {
	// ChannelGroup: ChannelGroup is the name of the set to which this version belongs. Each version belongs to only a single
	// set.
	ChannelGroup *string `json:"channelGroup,omitempty"`

	// Id: ID is the unique identifier of the version.
	Id *string `json:"id,omitempty"`
}

// Taint is controlling the node taint and its effects
type Taint_STATUS struct {
	// Effect: The effect of the taint
	Effect *Effect_STATUS `json:"effect,omitempty"`

	// Key: The key of the taint
	Key *string `json:"key,omitempty"`

	// Value: The value of the taint
	Value *string `json:"value,omitempty"`
}

// The taint effect the same as in Kubernetes
type Effect_STATUS string

const (
	Effect_STATUS_NoExecute        = Effect_STATUS("NoExecute")
	Effect_STATUS_NoSchedule       = Effect_STATUS("NoSchedule")
	Effect_STATUS_PreferNoSchedule = Effect_STATUS("PreferNoSchedule")
)

// Mapping from string to Effect_STATUS
var effect_STATUS_Values = map[string]Effect_STATUS{
	"noexecute":        Effect_STATUS_NoExecute,
	"noschedule":       Effect_STATUS_NoSchedule,
	"prefernoschedule": Effect_STATUS_PreferNoSchedule,
}

// The settings and configuration options for OSDisk
type OsDiskProfile_STATUS struct {
	// DiskStorageAccountType: The type of the disk storage account
	// - https://learn.microsoft.com/en-us/azure/virtual-machines/disks-types
	DiskStorageAccountType *OsDiskProfile_DiskStorageAccountType_STATUS `json:"diskStorageAccountType,omitempty"`

	// EncryptionSetId: The ID of the DiskEncryptionSet resource to use to encrypt the OS disks for the VMs.
	// This needs to exist in the same subscription id listed in the Hosted Cluster,
	// HostedCluster.Spec.Platform.Azure.SubscriptionID.
	// DiskEncryptionSetID should also exist in a resource group under the same subscription id and the same location
	// listed in the Hosted Cluster, HostedCluster.Spec.Platform.Azure.Location.
	// Details on how to create a Disk Encryption Set can be found here:
	// https://learn.microsoft.com/en-us/azure/virtual-machines/disks-enable-customer-managed-keys-portal#set-up-your-disk-encryption-set
	EncryptionSetId *string `json:"encryptionSetId,omitempty"`

	// SizeGiB: The OS disk size in GiB
	SizeGiB *int `json:"sizeGiB,omitempty"`
}

type OsDiskProfile_DiskStorageAccountType_STATUS string

const (
	OsDiskProfile_DiskStorageAccountType_STATUS_Premium_LRS     = OsDiskProfile_DiskStorageAccountType_STATUS("Premium_LRS")
	OsDiskProfile_DiskStorageAccountType_STATUS_StandardSSD_LRS = OsDiskProfile_DiskStorageAccountType_STATUS("StandardSSD_LRS")
	OsDiskProfile_DiskStorageAccountType_STATUS_Standard_LRS    = OsDiskProfile_DiskStorageAccountType_STATUS("Standard_LRS")
)

// Mapping from string to OsDiskProfile_DiskStorageAccountType_STATUS
var osDiskProfile_DiskStorageAccountType_STATUS_Values = map[string]OsDiskProfile_DiskStorageAccountType_STATUS{
	"premium_lrs":     OsDiskProfile_DiskStorageAccountType_STATUS_Premium_LRS,
	"standardssd_lrs": OsDiskProfile_DiskStorageAccountType_STATUS_StandardSSD_LRS,
	"standard_lrs":    OsDiskProfile_DiskStorageAccountType_STATUS_Standard_LRS,
}
