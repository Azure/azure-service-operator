// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ExternalAuthClaimProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExternalAuthClaimProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExternalAuthClaimProfile, ExternalAuthClaimProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExternalAuthClaimProfile runs a test to see if a specific instance of ExternalAuthClaimProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForExternalAuthClaimProfile(subject ExternalAuthClaimProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExternalAuthClaimProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExternalAuthClaimProfile instances for property testing - lazily instantiated by
// ExternalAuthClaimProfileGenerator()
var externalAuthClaimProfileGenerator gopter.Gen

// ExternalAuthClaimProfileGenerator returns a generator of ExternalAuthClaimProfile instances for property testing.
func ExternalAuthClaimProfileGenerator() gopter.Gen {
	if externalAuthClaimProfileGenerator != nil {
		return externalAuthClaimProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExternalAuthClaimProfile(generators)
	externalAuthClaimProfileGenerator = gen.Struct(reflect.TypeOf(ExternalAuthClaimProfile{}), generators)

	return externalAuthClaimProfileGenerator
}

// AddRelatedPropertyGeneratorsForExternalAuthClaimProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExternalAuthClaimProfile(gens map[string]gopter.Gen) {
	gens["Mappings"] = gen.PtrOf(TokenClaimMappingsProfileGenerator())
	gens["ValidationRules"] = gen.SliceOf(TokenClaimValidationRuleGenerator())
}

func Test_ExternalAuthClientComponentProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExternalAuthClientComponentProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExternalAuthClientComponentProfile, ExternalAuthClientComponentProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExternalAuthClientComponentProfile runs a test to see if a specific instance of ExternalAuthClientComponentProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForExternalAuthClientComponentProfile(subject ExternalAuthClientComponentProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExternalAuthClientComponentProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExternalAuthClientComponentProfile instances for property testing - lazily instantiated by
// ExternalAuthClientComponentProfileGenerator()
var externalAuthClientComponentProfileGenerator gopter.Gen

// ExternalAuthClientComponentProfileGenerator returns a generator of ExternalAuthClientComponentProfile instances for property testing.
func ExternalAuthClientComponentProfileGenerator() gopter.Gen {
	if externalAuthClientComponentProfileGenerator != nil {
		return externalAuthClientComponentProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExternalAuthClientComponentProfile(generators)
	externalAuthClientComponentProfileGenerator = gen.Struct(reflect.TypeOf(ExternalAuthClientComponentProfile{}), generators)

	return externalAuthClientComponentProfileGenerator
}

// AddIndependentPropertyGeneratorsForExternalAuthClientComponentProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExternalAuthClientComponentProfile(gens map[string]gopter.Gen) {
	gens["AuthClientNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExternalAuthClientProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExternalAuthClientProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExternalAuthClientProfile, ExternalAuthClientProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExternalAuthClientProfile runs a test to see if a specific instance of ExternalAuthClientProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForExternalAuthClientProfile(subject ExternalAuthClientProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExternalAuthClientProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExternalAuthClientProfile instances for property testing - lazily instantiated by
// ExternalAuthClientProfileGenerator()
var externalAuthClientProfileGenerator gopter.Gen

// ExternalAuthClientProfileGenerator returns a generator of ExternalAuthClientProfile instances for property testing.
// We first initialize externalAuthClientProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ExternalAuthClientProfileGenerator() gopter.Gen {
	if externalAuthClientProfileGenerator != nil {
		return externalAuthClientProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExternalAuthClientProfile(generators)
	externalAuthClientProfileGenerator = gen.Struct(reflect.TypeOf(ExternalAuthClientProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExternalAuthClientProfile(generators)
	AddRelatedPropertyGeneratorsForExternalAuthClientProfile(generators)
	externalAuthClientProfileGenerator = gen.Struct(reflect.TypeOf(ExternalAuthClientProfile{}), generators)

	return externalAuthClientProfileGenerator
}

// AddIndependentPropertyGeneratorsForExternalAuthClientProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExternalAuthClientProfile(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ExtraScopes"] = gen.SliceOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExternalAuthClientType_Confidential, ExternalAuthClientType_Public))
}

// AddRelatedPropertyGeneratorsForExternalAuthClientProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExternalAuthClientProfile(gens map[string]gopter.Gen) {
	gens["Component"] = gen.PtrOf(ExternalAuthClientComponentProfileGenerator())
}

func Test_ExternalAuthProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExternalAuthProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExternalAuthProperties, ExternalAuthPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExternalAuthProperties runs a test to see if a specific instance of ExternalAuthProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForExternalAuthProperties(subject ExternalAuthProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExternalAuthProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExternalAuthProperties instances for property testing - lazily instantiated by
// ExternalAuthPropertiesGenerator()
var externalAuthPropertiesGenerator gopter.Gen

// ExternalAuthPropertiesGenerator returns a generator of ExternalAuthProperties instances for property testing.
func ExternalAuthPropertiesGenerator() gopter.Gen {
	if externalAuthPropertiesGenerator != nil {
		return externalAuthPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExternalAuthProperties(generators)
	externalAuthPropertiesGenerator = gen.Struct(reflect.TypeOf(ExternalAuthProperties{}), generators)

	return externalAuthPropertiesGenerator
}

// AddRelatedPropertyGeneratorsForExternalAuthProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExternalAuthProperties(gens map[string]gopter.Gen) {
	gens["Claim"] = gen.PtrOf(ExternalAuthClaimProfileGenerator())
	gens["Clients"] = gen.SliceOf(ExternalAuthClientProfileGenerator())
	gens["Issuer"] = gen.PtrOf(TokenIssuerProfileGenerator())
}

func Test_GroupClaimProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GroupClaimProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGroupClaimProfile, GroupClaimProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGroupClaimProfile runs a test to see if a specific instance of GroupClaimProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForGroupClaimProfile(subject GroupClaimProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GroupClaimProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GroupClaimProfile instances for property testing - lazily instantiated by GroupClaimProfileGenerator()
var groupClaimProfileGenerator gopter.Gen

// GroupClaimProfileGenerator returns a generator of GroupClaimProfile instances for property testing.
func GroupClaimProfileGenerator() gopter.Gen {
	if groupClaimProfileGenerator != nil {
		return groupClaimProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGroupClaimProfile(generators)
	groupClaimProfileGenerator = gen.Struct(reflect.TypeOf(GroupClaimProfile{}), generators)

	return groupClaimProfileGenerator
}

// AddIndependentPropertyGeneratorsForGroupClaimProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGroupClaimProfile(gens map[string]gopter.Gen) {
	gens["Claim"] = gen.PtrOf(gen.AlphaString())
	gens["Prefix"] = gen.PtrOf(gen.AlphaString())
}

func Test_HcpOpenShiftClustersExternalAuth_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HcpOpenShiftClustersExternalAuth_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHcpOpenShiftClustersExternalAuth_Spec, HcpOpenShiftClustersExternalAuth_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHcpOpenShiftClustersExternalAuth_Spec runs a test to see if a specific instance of HcpOpenShiftClustersExternalAuth_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForHcpOpenShiftClustersExternalAuth_Spec(subject HcpOpenShiftClustersExternalAuth_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HcpOpenShiftClustersExternalAuth_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HcpOpenShiftClustersExternalAuth_Spec instances for property testing - lazily instantiated by
// HcpOpenShiftClustersExternalAuth_SpecGenerator()
var hcpOpenShiftClustersExternalAuth_SpecGenerator gopter.Gen

// HcpOpenShiftClustersExternalAuth_SpecGenerator returns a generator of HcpOpenShiftClustersExternalAuth_Spec instances for property testing.
// We first initialize hcpOpenShiftClustersExternalAuth_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HcpOpenShiftClustersExternalAuth_SpecGenerator() gopter.Gen {
	if hcpOpenShiftClustersExternalAuth_SpecGenerator != nil {
		return hcpOpenShiftClustersExternalAuth_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_Spec(generators)
	hcpOpenShiftClustersExternalAuth_SpecGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClustersExternalAuth_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_Spec(generators)
	AddRelatedPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_Spec(generators)
	hcpOpenShiftClustersExternalAuth_SpecGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClustersExternalAuth_Spec{}), generators)

	return hcpOpenShiftClustersExternalAuth_SpecGenerator
}

// AddIndependentPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ExternalAuthPropertiesGenerator())
}

func Test_TokenClaimMappingsProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenClaimMappingsProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenClaimMappingsProfile, TokenClaimMappingsProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenClaimMappingsProfile runs a test to see if a specific instance of TokenClaimMappingsProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenClaimMappingsProfile(subject TokenClaimMappingsProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenClaimMappingsProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenClaimMappingsProfile instances for property testing - lazily instantiated by
// TokenClaimMappingsProfileGenerator()
var tokenClaimMappingsProfileGenerator gopter.Gen

// TokenClaimMappingsProfileGenerator returns a generator of TokenClaimMappingsProfile instances for property testing.
func TokenClaimMappingsProfileGenerator() gopter.Gen {
	if tokenClaimMappingsProfileGenerator != nil {
		return tokenClaimMappingsProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForTokenClaimMappingsProfile(generators)
	tokenClaimMappingsProfileGenerator = gen.Struct(reflect.TypeOf(TokenClaimMappingsProfile{}), generators)

	return tokenClaimMappingsProfileGenerator
}

// AddRelatedPropertyGeneratorsForTokenClaimMappingsProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTokenClaimMappingsProfile(gens map[string]gopter.Gen) {
	gens["Groups"] = gen.PtrOf(GroupClaimProfileGenerator())
	gens["Username"] = gen.PtrOf(UsernameClaimProfileGenerator())
}

func Test_TokenClaimValidationRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenClaimValidationRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenClaimValidationRule, TokenClaimValidationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenClaimValidationRule runs a test to see if a specific instance of TokenClaimValidationRule round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenClaimValidationRule(subject TokenClaimValidationRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenClaimValidationRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenClaimValidationRule instances for property testing - lazily instantiated by
// TokenClaimValidationRuleGenerator()
var tokenClaimValidationRuleGenerator gopter.Gen

// TokenClaimValidationRuleGenerator returns a generator of TokenClaimValidationRule instances for property testing.
// We first initialize tokenClaimValidationRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TokenClaimValidationRuleGenerator() gopter.Gen {
	if tokenClaimValidationRuleGenerator != nil {
		return tokenClaimValidationRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenClaimValidationRule(generators)
	tokenClaimValidationRuleGenerator = gen.Struct(reflect.TypeOf(TokenClaimValidationRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenClaimValidationRule(generators)
	AddRelatedPropertyGeneratorsForTokenClaimValidationRule(generators)
	tokenClaimValidationRuleGenerator = gen.Struct(reflect.TypeOf(TokenClaimValidationRule{}), generators)

	return tokenClaimValidationRuleGenerator
}

// AddIndependentPropertyGeneratorsForTokenClaimValidationRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTokenClaimValidationRule(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(TokenClaimValidationRule_Type_RequiredClaim))
}

// AddRelatedPropertyGeneratorsForTokenClaimValidationRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTokenClaimValidationRule(gens map[string]gopter.Gen) {
	gens["RequiredClaim"] = gen.PtrOf(TokenRequiredClaimGenerator())
}

func Test_TokenIssuerProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenIssuerProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenIssuerProfile, TokenIssuerProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenIssuerProfile runs a test to see if a specific instance of TokenIssuerProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenIssuerProfile(subject TokenIssuerProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenIssuerProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenIssuerProfile instances for property testing - lazily instantiated by TokenIssuerProfileGenerator()
var tokenIssuerProfileGenerator gopter.Gen

// TokenIssuerProfileGenerator returns a generator of TokenIssuerProfile instances for property testing.
func TokenIssuerProfileGenerator() gopter.Gen {
	if tokenIssuerProfileGenerator != nil {
		return tokenIssuerProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenIssuerProfile(generators)
	tokenIssuerProfileGenerator = gen.Struct(reflect.TypeOf(TokenIssuerProfile{}), generators)

	return tokenIssuerProfileGenerator
}

// AddIndependentPropertyGeneratorsForTokenIssuerProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTokenIssuerProfile(gens map[string]gopter.Gen) {
	gens["Audiences"] = gen.SliceOf(gen.AlphaString())
	gens["Ca"] = gen.PtrOf(gen.AlphaString())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_TokenRequiredClaim_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenRequiredClaim via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenRequiredClaim, TokenRequiredClaimGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenRequiredClaim runs a test to see if a specific instance of TokenRequiredClaim round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenRequiredClaim(subject TokenRequiredClaim) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenRequiredClaim
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenRequiredClaim instances for property testing - lazily instantiated by TokenRequiredClaimGenerator()
var tokenRequiredClaimGenerator gopter.Gen

// TokenRequiredClaimGenerator returns a generator of TokenRequiredClaim instances for property testing.
func TokenRequiredClaimGenerator() gopter.Gen {
	if tokenRequiredClaimGenerator != nil {
		return tokenRequiredClaimGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenRequiredClaim(generators)
	tokenRequiredClaimGenerator = gen.Struct(reflect.TypeOf(TokenRequiredClaim{}), generators)

	return tokenRequiredClaimGenerator
}

// AddIndependentPropertyGeneratorsForTokenRequiredClaim is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTokenRequiredClaim(gens map[string]gopter.Gen) {
	gens["Claim"] = gen.PtrOf(gen.AlphaString())
	gens["RequiredValue"] = gen.PtrOf(gen.AlphaString())
}

func Test_UsernameClaimProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UsernameClaimProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUsernameClaimProfile, UsernameClaimProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUsernameClaimProfile runs a test to see if a specific instance of UsernameClaimProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForUsernameClaimProfile(subject UsernameClaimProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UsernameClaimProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UsernameClaimProfile instances for property testing - lazily instantiated by
// UsernameClaimProfileGenerator()
var usernameClaimProfileGenerator gopter.Gen

// UsernameClaimProfileGenerator returns a generator of UsernameClaimProfile instances for property testing.
func UsernameClaimProfileGenerator() gopter.Gen {
	if usernameClaimProfileGenerator != nil {
		return usernameClaimProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUsernameClaimProfile(generators)
	usernameClaimProfileGenerator = gen.Struct(reflect.TypeOf(UsernameClaimProfile{}), generators)

	return usernameClaimProfileGenerator
}

// AddIndependentPropertyGeneratorsForUsernameClaimProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUsernameClaimProfile(gens map[string]gopter.Gen) {
	gens["Claim"] = gen.PtrOf(gen.AlphaString())
	gens["Prefix"] = gen.PtrOf(gen.AlphaString())
	gens["PrefixPolicy"] = gen.PtrOf(gen.OneConstOf(UsernameClaimPrefixPolicy_NoPrefix, UsernameClaimPrefixPolicy_None, UsernameClaimPrefixPolicy_Prefix))
}
