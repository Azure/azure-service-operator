// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	storage "github.com/Azure/azure-service-operator/v2/api/redhatopenshift/v1api20231122/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// +kubebuilder:rbac:groups=redhatopenshift.azure.com,resources=hcpopenshiftclusters,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=redhatopenshift.azure.com,resources={hcpopenshiftclusters/status,hcpopenshiftclusters/finalizers},verbs=get;update;patch

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,redhatopenshift}
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1api20240610preview.HcpOpenShiftCluster
// Generator information:
// - Generated from: /redhatopenshift/resource-manager/Microsoft.RedHatOpenShift/hcpclusters/preview/2024-06-10-preview/openapi.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RedHatOpenShift/hcpOpenShiftClusters/{hcpOpenShiftClusterName}
type HcpOpenShiftCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              HcpOpenShiftCluster_Spec   `json:"spec,omitempty"`
	Status            HcpOpenShiftCluster_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &HcpOpenShiftCluster{}

// GetConditions returns the conditions of the resource
func (cluster *HcpOpenShiftCluster) GetConditions() conditions.Conditions {
	return cluster.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (cluster *HcpOpenShiftCluster) SetConditions(conditions conditions.Conditions) {
	cluster.Status.Conditions = conditions
}

var _ configmaps.Exporter = &HcpOpenShiftCluster{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (cluster *HcpOpenShiftCluster) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if cluster.Spec.OperatorSpec == nil {
		return nil
	}
	return cluster.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &HcpOpenShiftCluster{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (cluster *HcpOpenShiftCluster) SecretDestinationExpressions() []*core.DestinationExpression {
	if cluster.Spec.OperatorSpec == nil {
		return nil
	}
	return cluster.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesResource = &HcpOpenShiftCluster{}

// AzureName returns the Azure name of the resource
func (cluster *HcpOpenShiftCluster) AzureName() string {
	return cluster.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-06-10-preview"
func (cluster HcpOpenShiftCluster) GetAPIVersion() string {
	return "2024-06-10-preview"
}

// GetResourceScope returns the scope of the resource
func (cluster *HcpOpenShiftCluster) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (cluster *HcpOpenShiftCluster) GetSpec() genruntime.ConvertibleSpec {
	return &cluster.Spec
}

// GetStatus returns the status of this resource
func (cluster *HcpOpenShiftCluster) GetStatus() genruntime.ConvertibleStatus {
	return &cluster.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (cluster *HcpOpenShiftCluster) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.RedHatOpenShift/hcpOpenShiftClusters"
func (cluster *HcpOpenShiftCluster) GetType() string {
	return "Microsoft.RedHatOpenShift/hcpOpenShiftClusters"
}

// NewEmptyStatus returns a new empty (blank) status
func (cluster *HcpOpenShiftCluster) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &HcpOpenShiftCluster_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (cluster *HcpOpenShiftCluster) Owner() *genruntime.ResourceReference {
	if cluster.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(cluster.Spec)
	return cluster.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (cluster *HcpOpenShiftCluster) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*HcpOpenShiftCluster_STATUS); ok {
		cluster.Status = *st
		return nil
	}

	// Convert status to required version
	var st HcpOpenShiftCluster_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	cluster.Status = st
	return nil
}

// Hub marks that this HcpOpenShiftCluster is the hub type for conversion
func (cluster *HcpOpenShiftCluster) Hub() {}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (cluster *HcpOpenShiftCluster) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: cluster.Spec.OriginalVersion,
		Kind:    "HcpOpenShiftCluster",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1api20240610preview.HcpOpenShiftCluster
// Generator information:
// - Generated from: /redhatopenshift/resource-manager/Microsoft.RedHatOpenShift/hcpclusters/preview/2024-06-10-preview/openapi.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RedHatOpenShift/hcpOpenShiftClusters/{hcpOpenShiftClusterName}
type HcpOpenShiftClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []HcpOpenShiftCluster `json:"items"`
}

// Storage version of v1api20240610preview.APIVersion
// +kubebuilder:validation:Enum={"2024-06-10-preview"}
type APIVersion string

const APIVersion_Value = APIVersion("2024-06-10-preview")

// Storage version of v1api20240610preview.HcpOpenShiftCluster_Spec
type HcpOpenShiftCluster_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName       string                           `json:"azureName,omitempty"`
	Identity        *ManagedServiceIdentity          `json:"identity,omitempty"`
	Location        *string                          `json:"location,omitempty"`
	OperatorSpec    *HcpOpenShiftClusterOperatorSpec `json:"operatorSpec,omitempty"`
	OriginalVersion string                           `json:"originalVersion,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner       *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	Properties  *HcpOpenShiftClusterProperties     `json:"properties,omitempty"`
	PropertyBag genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	Tags        map[string]string                  `json:"tags,omitempty"`
}

var _ genruntime.ConvertibleSpec = &HcpOpenShiftCluster_Spec{}

// ConvertSpecFrom populates our HcpOpenShiftCluster_Spec from the provided source
func (cluster *HcpOpenShiftCluster_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	if source == cluster {
		return eris.New("attempted conversion between unrelated implementations of github.com/Azure/azure-service-operator/v2/pkg/genruntime/ConvertibleSpec")
	}

	return source.ConvertSpecTo(cluster)
}

// ConvertSpecTo populates the provided destination from our HcpOpenShiftCluster_Spec
func (cluster *HcpOpenShiftCluster_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	if destination == cluster {
		return eris.New("attempted conversion between unrelated implementations of github.com/Azure/azure-service-operator/v2/pkg/genruntime/ConvertibleSpec")
	}

	return destination.ConvertSpecFrom(cluster)
}

// Storage version of v1api20240610preview.HcpOpenShiftCluster_STATUS
// HCP cluster resource
type HcpOpenShiftCluster_STATUS struct {
	Conditions  []conditions.Condition                `json:"conditions,omitempty"`
	Id          *string                               `json:"id,omitempty"`
	Identity    *ManagedServiceIdentity_STATUS        `json:"identity,omitempty"`
	Location    *string                               `json:"location,omitempty"`
	Name        *string                               `json:"name,omitempty"`
	Properties  *HcpOpenShiftClusterProperties_STATUS `json:"properties,omitempty"`
	PropertyBag genruntime.PropertyBag                `json:"$propertyBag,omitempty"`
	SystemData  *SystemData_STATUS                    `json:"systemData,omitempty"`
	Tags        map[string]string                     `json:"tags,omitempty"`
	Type        *string                               `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &HcpOpenShiftCluster_STATUS{}

// ConvertStatusFrom populates our HcpOpenShiftCluster_STATUS from the provided source
func (cluster *HcpOpenShiftCluster_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	if source == cluster {
		return eris.New("attempted conversion between unrelated implementations of github.com/Azure/azure-service-operator/v2/pkg/genruntime/ConvertibleStatus")
	}

	return source.ConvertStatusTo(cluster)
}

// ConvertStatusTo populates the provided destination from our HcpOpenShiftCluster_STATUS
func (cluster *HcpOpenShiftCluster_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	if destination == cluster {
		return eris.New("attempted conversion between unrelated implementations of github.com/Azure/azure-service-operator/v2/pkg/genruntime/ConvertibleStatus")
	}

	return destination.ConvertStatusFrom(cluster)
}

// Storage version of v1api20240610preview.HcpOpenShiftClusterOperatorSpec
// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type HcpOpenShiftClusterOperatorSpec struct {
	ConfigMapExpressions []*core.DestinationExpression       `json:"configMapExpressions,omitempty"`
	PropertyBag          genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
	SecretExpressions    []*core.DestinationExpression       `json:"secretExpressions,omitempty"`
	Secrets              *HcpOpenShiftClusterOperatorSecrets `json:"secrets,omitempty"`
}

// Storage version of v1api20240610preview.HcpOpenShiftClusterProperties
// HCP cluster properties
type HcpOpenShiftClusterProperties struct {
	Api                     *ApiProfile                  `json:"api,omitempty"`
	Autoscaling             *ClusterAutoscalingProfile   `json:"autoscaling,omitempty"`
	ClusterImageRegistry    *ClusterImageRegistryProfile `json:"clusterImageRegistry,omitempty"`
	Dns                     *DnsProfile                  `json:"dns,omitempty"`
	Etcd                    *EtcdProfile                 `json:"etcd,omitempty"`
	Network                 *NetworkProfile              `json:"network,omitempty"`
	NodeDrainTimeoutMinutes *int                         `json:"nodeDrainTimeoutMinutes,omitempty"`
	Platform                *PlatformProfile             `json:"platform,omitempty"`
	PropertyBag             genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
	Version                 *VersionProfile              `json:"version,omitempty"`
}

// Storage version of v1api20240610preview.HcpOpenShiftClusterProperties_STATUS
// HCP cluster properties
type HcpOpenShiftClusterProperties_STATUS struct {
	Api                     *ApiProfile_STATUS                  `json:"api,omitempty"`
	Autoscaling             *ClusterAutoscalingProfile_STATUS   `json:"autoscaling,omitempty"`
	ClusterImageRegistry    *ClusterImageRegistryProfile_STATUS `json:"clusterImageRegistry,omitempty"`
	Console                 *ConsoleProfile_STATUS              `json:"console,omitempty"`
	Dns                     *DnsProfile_STATUS                  `json:"dns,omitempty"`
	Etcd                    *EtcdProfile_STATUS                 `json:"etcd,omitempty"`
	Network                 *NetworkProfile_STATUS              `json:"network,omitempty"`
	NodeDrainTimeoutMinutes *int                                `json:"nodeDrainTimeoutMinutes,omitempty"`
	Platform                *PlatformProfile_STATUS             `json:"platform,omitempty"`
	PropertyBag             genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
	ProvisioningState       *string                             `json:"provisioningState,omitempty"`
	Version                 *VersionProfile_STATUS              `json:"version,omitempty"`
}

// Storage version of v1api20240610preview.ManagedServiceIdentity
// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity struct {
	PropertyBag            genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Type                   *string                       `json:"type,omitempty"`
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

// Storage version of v1api20240610preview.ManagedServiceIdentity_STATUS
// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity_STATUS struct {
	PrincipalId            *string                                `json:"principalId,omitempty"`
	PropertyBag            genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	TenantId               *string                                `json:"tenantId,omitempty"`
	Type                   *string                                `json:"type,omitempty"`
	UserAssignedIdentities map[string]UserAssignedIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

// Storage version of v1api20240610preview.SystemData_STATUS
// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	CreatedAt          *string                `json:"createdAt,omitempty"`
	CreatedBy          *string                `json:"createdBy,omitempty"`
	CreatedByType      *string                `json:"createdByType,omitempty"`
	LastModifiedAt     *string                `json:"lastModifiedAt,omitempty"`
	LastModifiedBy     *string                `json:"lastModifiedBy,omitempty"`
	LastModifiedByType *string                `json:"lastModifiedByType,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *storage.SystemData_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	data.CreatedByType = genruntime.ClonePointerToString(source.CreatedByType)

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	data.LastModifiedByType = genruntime.ClonePointerToString(source.LastModifiedByType)

	// Update the property bag
	if len(propertyBag) > 0 {
		data.PropertyBag = propertyBag
	} else {
		data.PropertyBag = nil
	}

	// Invoke the augmentConversionForSystemData_STATUS interface (if implemented) to customize the conversion
	var dataAsAny any = data
	if augmentedData, ok := dataAsAny.(augmentConversionForSystemData_STATUS); ok {
		err := augmentedData.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *storage.SystemData_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(data.PropertyBag)

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	destination.CreatedByType = genruntime.ClonePointerToString(data.CreatedByType)

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	destination.LastModifiedByType = genruntime.ClonePointerToString(data.LastModifiedByType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSystemData_STATUS interface (if implemented) to customize the conversion
	var dataAsAny any = data
	if augmentedData, ok := dataAsAny.(augmentConversionForSystemData_STATUS); ok {
		err := augmentedData.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240610preview.ApiProfile
// Information about the API of a cluster.
type ApiProfile struct {
	AuthorizedCidrs []string               `json:"authorizedCidrs,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Visibility      *string                `json:"visibility,omitempty"`
}

// Storage version of v1api20240610preview.ApiProfile_STATUS
// Information about the API of a cluster.
type ApiProfile_STATUS struct {
	AuthorizedCidrs []string               `json:"authorizedCidrs,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Url             *string                `json:"url,omitempty"`
	Visibility      *string                `json:"visibility,omitempty"`
}

type augmentConversionForSystemData_STATUS interface {
	AssignPropertiesFrom(src *storage.SystemData_STATUS) error
	AssignPropertiesTo(dst *storage.SystemData_STATUS) error
}

// Storage version of v1api20240610preview.ClusterAutoscalingProfile
// ClusterAutoscaling specifies auto-scaling behavior that
// applies to all NodePools associated with a control plane.
type ClusterAutoscalingProfile struct {
	MaxNodeProvisionTimeSeconds *int                   `json:"maxNodeProvisionTimeSeconds,omitempty"`
	MaxNodesTotal               *int                   `json:"maxNodesTotal,omitempty"`
	MaxPodGracePeriodSeconds    *int                   `json:"maxPodGracePeriodSeconds,omitempty"`
	PodPriorityThreshold        *int                   `json:"podPriorityThreshold,omitempty"`
	PropertyBag                 genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.ClusterAutoscalingProfile_STATUS
// ClusterAutoscaling specifies auto-scaling behavior that
// applies to all NodePools associated with a control plane.
type ClusterAutoscalingProfile_STATUS struct {
	MaxNodeProvisionTimeSeconds *int                   `json:"maxNodeProvisionTimeSeconds,omitempty"`
	MaxNodesTotal               *int                   `json:"maxNodesTotal,omitempty"`
	MaxPodGracePeriodSeconds    *int                   `json:"maxPodGracePeriodSeconds,omitempty"`
	PodPriorityThreshold        *int                   `json:"podPriorityThreshold,omitempty"`
	PropertyBag                 genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.ClusterImageRegistryProfile
// OpenShift cluster image registry
type ClusterImageRegistryProfile struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	State       *string                `json:"state,omitempty"`
}

// Storage version of v1api20240610preview.ClusterImageRegistryProfile_STATUS
// OpenShift cluster image registry
type ClusterImageRegistryProfile_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	State       *string                `json:"state,omitempty"`
}

// Storage version of v1api20240610preview.ConsoleProfile_STATUS
// Configuration of the cluster web console
type ConsoleProfile_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Url         *string                `json:"url,omitempty"`
}

// AssignProperties_From_ConsoleProfile_STATUS populates our ConsoleProfile_STATUS from the provided source ConsoleProfile_STATUS
func (profile *ConsoleProfile_STATUS) AssignProperties_From_ConsoleProfile_STATUS(source *storage.ConsoleProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Url
	profile.Url = genruntime.ClonePointerToString(source.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForConsoleProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForConsoleProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ConsoleProfile_STATUS populates the provided destination ConsoleProfile_STATUS from our ConsoleProfile_STATUS
func (profile *ConsoleProfile_STATUS) AssignProperties_To_ConsoleProfile_STATUS(destination *storage.ConsoleProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// Url
	destination.Url = genruntime.ClonePointerToString(profile.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForConsoleProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForConsoleProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240610preview.DnsProfile
// DNS contains the DNS settings of the cluster
type DnsProfile struct {
	BaseDomainPrefix *string                `json:"baseDomainPrefix,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.DnsProfile_STATUS
// DNS contains the DNS settings of the cluster
type DnsProfile_STATUS struct {
	BaseDomain       *string                `json:"baseDomain,omitempty"`
	BaseDomainPrefix *string                `json:"baseDomainPrefix,omitempty"`
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.EtcdProfile
// The ETCD settings and configuration options.
type EtcdProfile struct {
	DataEncryption *EtcdDataEncryptionProfile `json:"dataEncryption,omitempty"`
	PropertyBag    genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.EtcdProfile_STATUS
// The ETCD settings and configuration options.
type EtcdProfile_STATUS struct {
	DataEncryption *EtcdDataEncryptionProfile_STATUS `json:"dataEncryption,omitempty"`
	PropertyBag    genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.HcpOpenShiftClusterOperatorSecrets
type HcpOpenShiftClusterOperatorSecrets struct {
	AdminCredentials *genruntime.SecretDestination `json:"adminCredentials,omitempty"`
	PropertyBag      genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.NetworkProfile
// OpenShift networking configuration
type NetworkProfile struct {
	HostPrefix  *int                   `json:"hostPrefix,omitempty"`
	MachineCidr *string                `json:"machineCidr,omitempty"`
	NetworkType *string                `json:"networkType,omitempty"`
	PodCidr     *string                `json:"podCidr,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ServiceCidr *string                `json:"serviceCidr,omitempty"`
}

// AssignProperties_From_NetworkProfile populates our NetworkProfile from the provided source NetworkProfile
func (profile *NetworkProfile) AssignProperties_From_NetworkProfile(source *storage.NetworkProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HostPrefix
	if propertyBag.Contains("HostPrefix") {
		var hostPrefix int
		err := propertyBag.Pull("HostPrefix", &hostPrefix)
		if err != nil {
			return eris.Wrap(err, "pulling 'HostPrefix' from propertyBag")
		}

		profile.HostPrefix = &hostPrefix
	} else {
		profile.HostPrefix = nil
	}

	// LoadBalancerProfile
	if source.LoadBalancerProfile != nil {
		propertyBag.Add("LoadBalancerProfile", *source.LoadBalancerProfile)
	} else {
		propertyBag.Remove("LoadBalancerProfile")
	}

	// MachineCidr
	if propertyBag.Contains("MachineCidr") {
		var machineCidr string
		err := propertyBag.Pull("MachineCidr", &machineCidr)
		if err != nil {
			return eris.Wrap(err, "pulling 'MachineCidr' from propertyBag")
		}

		profile.MachineCidr = &machineCidr
	} else {
		profile.MachineCidr = nil
	}

	// NetworkType
	if propertyBag.Contains("NetworkType") {
		var networkType string
		err := propertyBag.Pull("NetworkType", &networkType)
		if err != nil {
			return eris.Wrap(err, "pulling 'NetworkType' from propertyBag")
		}

		profile.NetworkType = &networkType
	} else {
		profile.NetworkType = nil
	}

	// OutboundType
	if source.OutboundType != nil {
		propertyBag.Add("OutboundType", *source.OutboundType)
	} else {
		propertyBag.Remove("OutboundType")
	}

	// PodCidr
	profile.PodCidr = genruntime.ClonePointerToString(source.PodCidr)

	// PreconfiguredNSG
	if source.PreconfiguredNSG != nil {
		propertyBag.Add("PreconfiguredNSG", *source.PreconfiguredNSG)
	} else {
		propertyBag.Remove("PreconfiguredNSG")
	}

	// ServiceCidr
	profile.ServiceCidr = genruntime.ClonePointerToString(source.ServiceCidr)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForNetworkProfile); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkProfile populates the provided destination NetworkProfile from our NetworkProfile
func (profile *NetworkProfile) AssignProperties_To_NetworkProfile(destination *storage.NetworkProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// HostPrefix
	if profile.HostPrefix != nil {
		propertyBag.Add("HostPrefix", *profile.HostPrefix)
	} else {
		propertyBag.Remove("HostPrefix")
	}

	// LoadBalancerProfile
	if propertyBag.Contains("LoadBalancerProfile") {
		var loadBalancerProfile storage.LoadBalancerProfile
		err := propertyBag.Pull("LoadBalancerProfile", &loadBalancerProfile)
		if err != nil {
			return eris.Wrap(err, "pulling 'LoadBalancerProfile' from propertyBag")
		}

		destination.LoadBalancerProfile = &loadBalancerProfile
	} else {
		destination.LoadBalancerProfile = nil
	}

	// MachineCidr
	if profile.MachineCidr != nil {
		propertyBag.Add("MachineCidr", *profile.MachineCidr)
	} else {
		propertyBag.Remove("MachineCidr")
	}

	// NetworkType
	if profile.NetworkType != nil {
		propertyBag.Add("NetworkType", *profile.NetworkType)
	} else {
		propertyBag.Remove("NetworkType")
	}

	// OutboundType
	if propertyBag.Contains("OutboundType") {
		var outboundType string
		err := propertyBag.Pull("OutboundType", &outboundType)
		if err != nil {
			return eris.Wrap(err, "pulling 'OutboundType' from propertyBag")
		}

		destination.OutboundType = &outboundType
	} else {
		destination.OutboundType = nil
	}

	// PodCidr
	destination.PodCidr = genruntime.ClonePointerToString(profile.PodCidr)

	// PreconfiguredNSG
	if propertyBag.Contains("PreconfiguredNSG") {
		var preconfiguredNSG string
		err := propertyBag.Pull("PreconfiguredNSG", &preconfiguredNSG)
		if err != nil {
			return eris.Wrap(err, "pulling 'PreconfiguredNSG' from propertyBag")
		}

		destination.PreconfiguredNSG = &preconfiguredNSG
	} else {
		destination.PreconfiguredNSG = nil
	}

	// ServiceCidr
	destination.ServiceCidr = genruntime.ClonePointerToString(profile.ServiceCidr)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkProfile interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForNetworkProfile); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240610preview.NetworkProfile_STATUS
// OpenShift networking configuration
type NetworkProfile_STATUS struct {
	HostPrefix  *int                   `json:"hostPrefix,omitempty"`
	MachineCidr *string                `json:"machineCidr,omitempty"`
	NetworkType *string                `json:"networkType,omitempty"`
	PodCidr     *string                `json:"podCidr,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ServiceCidr *string                `json:"serviceCidr,omitempty"`
}

// AssignProperties_From_NetworkProfile_STATUS populates our NetworkProfile_STATUS from the provided source NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignProperties_From_NetworkProfile_STATUS(source *storage.NetworkProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HostPrefix
	if propertyBag.Contains("HostPrefix") {
		var hostPrefix int
		err := propertyBag.Pull("HostPrefix", &hostPrefix)
		if err != nil {
			return eris.Wrap(err, "pulling 'HostPrefix' from propertyBag")
		}

		profile.HostPrefix = &hostPrefix
	} else {
		profile.HostPrefix = nil
	}

	// LoadBalancerProfile
	if source.LoadBalancerProfile != nil {
		propertyBag.Add("LoadBalancerProfile", *source.LoadBalancerProfile)
	} else {
		propertyBag.Remove("LoadBalancerProfile")
	}

	// MachineCidr
	if propertyBag.Contains("MachineCidr") {
		var machineCidr string
		err := propertyBag.Pull("MachineCidr", &machineCidr)
		if err != nil {
			return eris.Wrap(err, "pulling 'MachineCidr' from propertyBag")
		}

		profile.MachineCidr = &machineCidr
	} else {
		profile.MachineCidr = nil
	}

	// NetworkType
	if propertyBag.Contains("NetworkType") {
		var networkType string
		err := propertyBag.Pull("NetworkType", &networkType)
		if err != nil {
			return eris.Wrap(err, "pulling 'NetworkType' from propertyBag")
		}

		profile.NetworkType = &networkType
	} else {
		profile.NetworkType = nil
	}

	// OutboundType
	if source.OutboundType != nil {
		propertyBag.Add("OutboundType", *source.OutboundType)
	} else {
		propertyBag.Remove("OutboundType")
	}

	// PodCidr
	profile.PodCidr = genruntime.ClonePointerToString(source.PodCidr)

	// PreconfiguredNSG
	if source.PreconfiguredNSG != nil {
		propertyBag.Add("PreconfiguredNSG", *source.PreconfiguredNSG)
	} else {
		propertyBag.Remove("PreconfiguredNSG")
	}

	// ServiceCidr
	profile.ServiceCidr = genruntime.ClonePointerToString(source.ServiceCidr)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForNetworkProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkProfile_STATUS populates the provided destination NetworkProfile_STATUS from our NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignProperties_To_NetworkProfile_STATUS(destination *storage.NetworkProfile_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// HostPrefix
	if profile.HostPrefix != nil {
		propertyBag.Add("HostPrefix", *profile.HostPrefix)
	} else {
		propertyBag.Remove("HostPrefix")
	}

	// LoadBalancerProfile
	if propertyBag.Contains("LoadBalancerProfile") {
		var loadBalancerProfile storage.LoadBalancerProfile_STATUS
		err := propertyBag.Pull("LoadBalancerProfile", &loadBalancerProfile)
		if err != nil {
			return eris.Wrap(err, "pulling 'LoadBalancerProfile' from propertyBag")
		}

		destination.LoadBalancerProfile = &loadBalancerProfile
	} else {
		destination.LoadBalancerProfile = nil
	}

	// MachineCidr
	if profile.MachineCidr != nil {
		propertyBag.Add("MachineCidr", *profile.MachineCidr)
	} else {
		propertyBag.Remove("MachineCidr")
	}

	// NetworkType
	if profile.NetworkType != nil {
		propertyBag.Add("NetworkType", *profile.NetworkType)
	} else {
		propertyBag.Remove("NetworkType")
	}

	// OutboundType
	if propertyBag.Contains("OutboundType") {
		var outboundType string
		err := propertyBag.Pull("OutboundType", &outboundType)
		if err != nil {
			return eris.Wrap(err, "pulling 'OutboundType' from propertyBag")
		}

		destination.OutboundType = &outboundType
	} else {
		destination.OutboundType = nil
	}

	// PodCidr
	destination.PodCidr = genruntime.ClonePointerToString(profile.PodCidr)

	// PreconfiguredNSG
	if propertyBag.Contains("PreconfiguredNSG") {
		var preconfiguredNSG string
		err := propertyBag.Pull("PreconfiguredNSG", &preconfiguredNSG)
		if err != nil {
			return eris.Wrap(err, "pulling 'PreconfiguredNSG' from propertyBag")
		}

		destination.PreconfiguredNSG = &preconfiguredNSG
	} else {
		destination.PreconfiguredNSG = nil
	}

	// ServiceCidr
	destination.ServiceCidr = genruntime.ClonePointerToString(profile.ServiceCidr)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForNetworkProfile_STATUS interface (if implemented) to customize the conversion
	var profileAsAny any = profile
	if augmentedProfile, ok := profileAsAny.(augmentConversionForNetworkProfile_STATUS); ok {
		err := augmentedProfile.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20240610preview.PlatformProfile
// Azure specific configuration
type PlatformProfile struct {
	ManagedResourceGroup *string `json:"managedResourceGroup,omitempty"`

	// +kubebuilder:validation:Required
	// NetworkSecurityGroupReference: ResourceId for the NSG (network security group) attached to the cluster subnet
	// Note that NSGs cannot be reused for other ARO-HCP clusters.
	NetworkSecurityGroupReference *genruntime.ResourceReference   `armReference:"NetworkSecurityGroupId" json:"networkSecurityGroupReference,omitempty"`
	OperatorsAuthentication       *OperatorsAuthenticationProfile `json:"operatorsAuthentication,omitempty"`
	OutboundType                  *string                         `json:"outboundType,omitempty"`
	PropertyBag                   genruntime.PropertyBag          `json:"$propertyBag,omitempty"`

	// +kubebuilder:validation:Required
	// SubnetReference: The Azure resource ID of the worker subnet
	// Note that a subnet cannot be reused between ARO-HCP Clusters.
	SubnetReference *genruntime.ResourceReference `armReference:"SubnetId" json:"subnetReference,omitempty"`
}

// Storage version of v1api20240610preview.PlatformProfile_STATUS
// Azure specific configuration
type PlatformProfile_STATUS struct {
	IssuerUrl               *string                                `json:"issuerUrl,omitempty"`
	ManagedResourceGroup    *string                                `json:"managedResourceGroup,omitempty"`
	NetworkSecurityGroupId  *string                                `json:"networkSecurityGroupId,omitempty"`
	OperatorsAuthentication *OperatorsAuthenticationProfile_STATUS `json:"operatorsAuthentication,omitempty"`
	OutboundType            *string                                `json:"outboundType,omitempty"`
	PropertyBag             genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	SubnetId                *string                                `json:"subnetId,omitempty"`
}

// Storage version of v1api20240610preview.UserAssignedIdentity_STATUS
// User assigned identity properties
type UserAssignedIdentity_STATUS struct {
	ClientId    *string                `json:"clientId,omitempty"`
	PrincipalId *string                `json:"principalId,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.UserAssignedIdentityDetails
// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	PropertyBag genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
	Reference   genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// Storage version of v1api20240610preview.VersionProfile
// Versions represents an OpenShift version.
type VersionProfile struct {
	ChannelGroup *string                `json:"channelGroup,omitempty"`
	Id           *string                `json:"id,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.VersionProfile_STATUS
// Versions represents an OpenShift version.
type VersionProfile_STATUS struct {
	ChannelGroup *string                `json:"channelGroup,omitempty"`
	Id           *string                `json:"id,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

type augmentConversionForConsoleProfile_STATUS interface {
	AssignPropertiesFrom(src *storage.ConsoleProfile_STATUS) error
	AssignPropertiesTo(dst *storage.ConsoleProfile_STATUS) error
}

type augmentConversionForNetworkProfile interface {
	AssignPropertiesFrom(src *storage.NetworkProfile) error
	AssignPropertiesTo(dst *storage.NetworkProfile) error
}

type augmentConversionForNetworkProfile_STATUS interface {
	AssignPropertiesFrom(src *storage.NetworkProfile_STATUS) error
	AssignPropertiesTo(dst *storage.NetworkProfile_STATUS) error
}

// Storage version of v1api20240610preview.EtcdDataEncryptionProfile
// The ETCD data encryption settings.
type EtcdDataEncryptionProfile struct {
	CustomerManaged   *CustomerManagedEncryptionProfile `json:"customerManaged,omitempty"`
	KeyManagementMode *string                           `json:"keyManagementMode,omitempty"`
	PropertyBag       genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.EtcdDataEncryptionProfile_STATUS
// The ETCD data encryption settings.
type EtcdDataEncryptionProfile_STATUS struct {
	CustomerManaged   *CustomerManagedEncryptionProfile_STATUS `json:"customerManaged,omitempty"`
	KeyManagementMode *string                                  `json:"keyManagementMode,omitempty"`
	PropertyBag       genruntime.PropertyBag                   `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.OperatorsAuthenticationProfile
// The configuration that the operators of the cluster have to authenticate to Azure.
type OperatorsAuthenticationProfile struct {
	PropertyBag            genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
	UserAssignedIdentities *UserAssignedIdentitiesProfile `json:"userAssignedIdentities,omitempty"`
}

// Storage version of v1api20240610preview.OperatorsAuthenticationProfile_STATUS
// The configuration that the operators of the cluster have to authenticate to Azure.
type OperatorsAuthenticationProfile_STATUS struct {
	PropertyBag            genruntime.PropertyBag                `json:"$propertyBag,omitempty"`
	UserAssignedIdentities *UserAssignedIdentitiesProfile_STATUS `json:"userAssignedIdentities,omitempty"`
}

// Storage version of v1api20240610preview.CustomerManagedEncryptionProfile
// Customer managed encryption key profile.
type CustomerManagedEncryptionProfile struct {
	EncryptionType *string                `json:"encryptionType,omitempty"`
	Kms            *KmsEncryptionProfile  `json:"kms,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.CustomerManagedEncryptionProfile_STATUS
// Customer managed encryption key profile.
type CustomerManagedEncryptionProfile_STATUS struct {
	EncryptionType *string                      `json:"encryptionType,omitempty"`
	Kms            *KmsEncryptionProfile_STATUS `json:"kms,omitempty"`
	PropertyBag    genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.UserAssignedIdentitiesProfile
// Represents the information related to Azure User-Assigned managed identities needed
// to perform Operators authentication
// based on Azure User-Assigned Managed Identities
type UserAssignedIdentitiesProfile struct {
	ControlPlaneOperatorsReferences map[string]genruntime.ResourceReference `armReference:"ControlPlaneOperators" json:"controlPlaneOperatorsReferences,omitempty"`
	DataPlaneOperatorsReferences    map[string]genruntime.ResourceReference `armReference:"DataPlaneOperators" json:"dataPlaneOperatorsReferences,omitempty"`
	PropertyBag                     genruntime.PropertyBag                  `json:"$propertyBag,omitempty"`

	// +kubebuilder:validation:Required
	// ServiceManagedIdentityReference: Represents the information associated to an Azure User-Assigned Managed Identity whose
	// purpose is to perform service level actions.
	ServiceManagedIdentityReference *genruntime.ResourceReference `armReference:"ServiceManagedIdentity" json:"serviceManagedIdentityReference,omitempty"`
}

// Storage version of v1api20240610preview.UserAssignedIdentitiesProfile_STATUS
// Represents the information related to Azure User-Assigned managed identities needed
// to perform Operators authentication
// based on Azure User-Assigned Managed Identities
type UserAssignedIdentitiesProfile_STATUS struct {
	ControlPlaneOperators  map[string]string      `json:"controlPlaneOperators,omitempty"`
	DataPlaneOperators     map[string]string      `json:"dataPlaneOperators,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ServiceManagedIdentity *string                `json:"serviceManagedIdentity,omitempty"`
}

// Storage version of v1api20240610preview.KmsEncryptionProfile
// Configure etcd encryption Key Management Service (KMS) key.
// Your Microsoft Entra application used to create the cluster
// must be authorized to access this keyvault,
// e.g using the AzureCLI: `az keyvault set-policy -n $KEYVAULT_NAME
// --key-permissions decrypt encrypt --spn <YOUR APPLICATION CLIENT ID>`
type KmsEncryptionProfile struct {
	ActiveKey   *KmsKey                `json:"activeKey,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.KmsEncryptionProfile_STATUS
// Configure etcd encryption Key Management Service (KMS) key.
// Your Microsoft Entra application used to create the cluster
// must be authorized to access this keyvault,
// e.g using the AzureCLI: `az keyvault set-policy -n $KEYVAULT_NAME
// --key-permissions decrypt encrypt --spn <YOUR APPLICATION CLIENT ID>`
type KmsEncryptionProfile_STATUS struct {
	ActiveKey   *KmsKey_STATUS         `json:"activeKey,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20240610preview.KmsKey
// A representation of a KeyVault Secret.
type KmsKey struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	VaultName   *string                `json:"vaultName,omitempty"`
	Version     *string                `json:"version,omitempty"`
}

// Storage version of v1api20240610preview.KmsKey_STATUS
// A representation of a KeyVault Secret.
type KmsKey_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	VaultName   *string                `json:"vaultName,omitempty"`
	Version     *string                `json:"version,omitempty"`
}

func init() {
	SchemeBuilder.Register(&HcpOpenShiftCluster{}, &HcpOpenShiftClusterList{})
}
