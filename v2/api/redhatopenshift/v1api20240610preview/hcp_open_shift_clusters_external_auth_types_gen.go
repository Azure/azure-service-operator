// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240610preview

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/redhatopenshift/v1api20240610preview/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/redhatopenshift/v1api20240610preview/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,redhatopenshift}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /redhatopenshift/resource-manager/Microsoft.RedHatOpenShift/hcpclusters/preview/2024-06-10-preview/openapi.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RedHatOpenShift/hcpOpenShiftClusters/{hcpOpenShiftClusterName}/externalAuths/{externalAuthName}
type HcpOpenShiftClustersExternalAuth struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              HcpOpenShiftClustersExternalAuth_Spec   `json:"spec,omitempty"`
	Status            HcpOpenShiftClustersExternalAuth_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &HcpOpenShiftClustersExternalAuth{}

// GetConditions returns the conditions of the resource
func (auth *HcpOpenShiftClustersExternalAuth) GetConditions() conditions.Conditions {
	return auth.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (auth *HcpOpenShiftClustersExternalAuth) SetConditions(conditions conditions.Conditions) {
	auth.Status.Conditions = conditions
}

var _ conversion.Convertible = &HcpOpenShiftClustersExternalAuth{}

// ConvertFrom populates our HcpOpenShiftClustersExternalAuth from the provided hub HcpOpenShiftClustersExternalAuth
func (auth *HcpOpenShiftClustersExternalAuth) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.HcpOpenShiftClustersExternalAuth)
	if !ok {
		return fmt.Errorf("expected redhatopenshift/v1api20240610preview/storage/HcpOpenShiftClustersExternalAuth but received %T instead", hub)
	}

	return auth.AssignProperties_From_HcpOpenShiftClustersExternalAuth(source)
}

// ConvertTo populates the provided hub HcpOpenShiftClustersExternalAuth from our HcpOpenShiftClustersExternalAuth
func (auth *HcpOpenShiftClustersExternalAuth) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.HcpOpenShiftClustersExternalAuth)
	if !ok {
		return fmt.Errorf("expected redhatopenshift/v1api20240610preview/storage/HcpOpenShiftClustersExternalAuth but received %T instead", hub)
	}

	return auth.AssignProperties_To_HcpOpenShiftClustersExternalAuth(destination)
}

var _ configmaps.Exporter = &HcpOpenShiftClustersExternalAuth{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (auth *HcpOpenShiftClustersExternalAuth) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if auth.Spec.OperatorSpec == nil {
		return nil
	}
	return auth.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &HcpOpenShiftClustersExternalAuth{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (auth *HcpOpenShiftClustersExternalAuth) SecretDestinationExpressions() []*core.DestinationExpression {
	if auth.Spec.OperatorSpec == nil {
		return nil
	}
	return auth.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &HcpOpenShiftClustersExternalAuth{}

// InitializeSpec initializes the spec for this resource from the given status
func (auth *HcpOpenShiftClustersExternalAuth) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*HcpOpenShiftClustersExternalAuth_STATUS); ok {
		return auth.Spec.Initialize_From_HcpOpenShiftClustersExternalAuth_STATUS(s)
	}

	return fmt.Errorf("expected Status of type HcpOpenShiftClustersExternalAuth_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &HcpOpenShiftClustersExternalAuth{}

// AzureName returns the Azure name of the resource
func (auth *HcpOpenShiftClustersExternalAuth) AzureName() string {
	return auth.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-06-10-preview"
func (auth HcpOpenShiftClustersExternalAuth) GetAPIVersion() string {
	return "2024-06-10-preview"
}

// GetResourceScope returns the scope of the resource
func (auth *HcpOpenShiftClustersExternalAuth) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (auth *HcpOpenShiftClustersExternalAuth) GetSpec() genruntime.ConvertibleSpec {
	return &auth.Spec
}

// GetStatus returns the status of this resource
func (auth *HcpOpenShiftClustersExternalAuth) GetStatus() genruntime.ConvertibleStatus {
	return &auth.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (auth *HcpOpenShiftClustersExternalAuth) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.RedHatOpenShift/hcpOpenShiftClusters/externalAuths"
func (auth *HcpOpenShiftClustersExternalAuth) GetType() string {
	return "Microsoft.RedHatOpenShift/hcpOpenShiftClusters/externalAuths"
}

// NewEmptyStatus returns a new empty (blank) status
func (auth *HcpOpenShiftClustersExternalAuth) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &HcpOpenShiftClustersExternalAuth_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (auth *HcpOpenShiftClustersExternalAuth) Owner() *genruntime.ResourceReference {
	if auth.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(auth.Spec)
	return auth.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (auth *HcpOpenShiftClustersExternalAuth) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*HcpOpenShiftClustersExternalAuth_STATUS); ok {
		auth.Status = *st
		return nil
	}

	// Convert status to required version
	var st HcpOpenShiftClustersExternalAuth_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	auth.Status = st
	return nil
}

// AssignProperties_From_HcpOpenShiftClustersExternalAuth populates our HcpOpenShiftClustersExternalAuth from the provided source HcpOpenShiftClustersExternalAuth
func (auth *HcpOpenShiftClustersExternalAuth) AssignProperties_From_HcpOpenShiftClustersExternalAuth(source *storage.HcpOpenShiftClustersExternalAuth) error {

	// ObjectMeta
	auth.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec HcpOpenShiftClustersExternalAuth_Spec
	err := spec.AssignProperties_From_HcpOpenShiftClustersExternalAuth_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_HcpOpenShiftClustersExternalAuth_Spec() to populate field Spec")
	}
	auth.Spec = spec

	// Status
	var status HcpOpenShiftClustersExternalAuth_STATUS
	err = status.AssignProperties_From_HcpOpenShiftClustersExternalAuth_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_HcpOpenShiftClustersExternalAuth_STATUS() to populate field Status")
	}
	auth.Status = status

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftClustersExternalAuth populates the provided destination HcpOpenShiftClustersExternalAuth from our HcpOpenShiftClustersExternalAuth
func (auth *HcpOpenShiftClustersExternalAuth) AssignProperties_To_HcpOpenShiftClustersExternalAuth(destination *storage.HcpOpenShiftClustersExternalAuth) error {

	// ObjectMeta
	destination.ObjectMeta = *auth.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.HcpOpenShiftClustersExternalAuth_Spec
	err := auth.Spec.AssignProperties_To_HcpOpenShiftClustersExternalAuth_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_HcpOpenShiftClustersExternalAuth_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.HcpOpenShiftClustersExternalAuth_STATUS
	err = auth.Status.AssignProperties_To_HcpOpenShiftClustersExternalAuth_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_HcpOpenShiftClustersExternalAuth_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (auth *HcpOpenShiftClustersExternalAuth) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: auth.Spec.OriginalVersion(),
		Kind:    "HcpOpenShiftClustersExternalAuth",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /redhatopenshift/resource-manager/Microsoft.RedHatOpenShift/hcpclusters/preview/2024-06-10-preview/openapi.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RedHatOpenShift/hcpOpenShiftClusters/{hcpOpenShiftClusterName}/externalAuths/{externalAuthName}
type HcpOpenShiftClustersExternalAuthList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []HcpOpenShiftClustersExternalAuth `json:"items"`
}

type HcpOpenShiftClustersExternalAuth_Spec struct {
	// +kubebuilder:validation:Pattern="^[a-zA-Z][-a-zA-Z0-9]{1,15}$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *HcpOpenShiftClustersExternalAuthOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a redhatopenshift.azure.com/HcpOpenShiftCluster resource
	Owner *genruntime.KnownResourceReference `group:"redhatopenshift.azure.com" json:"owner,omitempty" kind:"HcpOpenShiftCluster"`

	// Properties: The resource-specific properties for this resource.
	Properties *ExternalAuthProperties `json:"properties,omitempty"`
}

var _ genruntime.ARMTransformer = &HcpOpenShiftClustersExternalAuth_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (auth *HcpOpenShiftClustersExternalAuth_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if auth == nil {
		return nil, nil
	}
	result := &arm.HcpOpenShiftClustersExternalAuth_Spec{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if auth.Properties != nil {
		properties_ARM, err := auth.Properties.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.ExternalAuthProperties)
		result.Properties = &properties
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (auth *HcpOpenShiftClustersExternalAuth_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HcpOpenShiftClustersExternalAuth_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (auth *HcpOpenShiftClustersExternalAuth_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HcpOpenShiftClustersExternalAuth_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HcpOpenShiftClustersExternalAuth_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	auth.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	auth.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 ExternalAuthProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		auth.Properties = &properties
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &HcpOpenShiftClustersExternalAuth_Spec{}

// ConvertSpecFrom populates our HcpOpenShiftClustersExternalAuth_Spec from the provided source
func (auth *HcpOpenShiftClustersExternalAuth_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.HcpOpenShiftClustersExternalAuth_Spec)
	if ok {
		// Populate our instance from source
		return auth.AssignProperties_From_HcpOpenShiftClustersExternalAuth_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.HcpOpenShiftClustersExternalAuth_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = auth.AssignProperties_From_HcpOpenShiftClustersExternalAuth_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our HcpOpenShiftClustersExternalAuth_Spec
func (auth *HcpOpenShiftClustersExternalAuth_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.HcpOpenShiftClustersExternalAuth_Spec)
	if ok {
		// Populate destination from our instance
		return auth.AssignProperties_To_HcpOpenShiftClustersExternalAuth_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.HcpOpenShiftClustersExternalAuth_Spec{}
	err := auth.AssignProperties_To_HcpOpenShiftClustersExternalAuth_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_HcpOpenShiftClustersExternalAuth_Spec populates our HcpOpenShiftClustersExternalAuth_Spec from the provided source HcpOpenShiftClustersExternalAuth_Spec
func (auth *HcpOpenShiftClustersExternalAuth_Spec) AssignProperties_From_HcpOpenShiftClustersExternalAuth_Spec(source *storage.HcpOpenShiftClustersExternalAuth_Spec) error {

	// AzureName
	auth.AzureName = source.AzureName

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec HcpOpenShiftClustersExternalAuthOperatorSpec
		err := operatorSpec.AssignProperties_From_HcpOpenShiftClustersExternalAuthOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HcpOpenShiftClustersExternalAuthOperatorSpec() to populate field OperatorSpec")
		}
		auth.OperatorSpec = &operatorSpec
	} else {
		auth.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		auth.Owner = &owner
	} else {
		auth.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property ExternalAuthProperties
		err := property.AssignProperties_From_ExternalAuthProperties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExternalAuthProperties() to populate field Properties")
		}
		auth.Properties = &property
	} else {
		auth.Properties = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftClustersExternalAuth_Spec populates the provided destination HcpOpenShiftClustersExternalAuth_Spec from our HcpOpenShiftClustersExternalAuth_Spec
func (auth *HcpOpenShiftClustersExternalAuth_Spec) AssignProperties_To_HcpOpenShiftClustersExternalAuth_Spec(destination *storage.HcpOpenShiftClustersExternalAuth_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = auth.AzureName

	// OperatorSpec
	if auth.OperatorSpec != nil {
		var operatorSpec storage.HcpOpenShiftClustersExternalAuthOperatorSpec
		err := auth.OperatorSpec.AssignProperties_To_HcpOpenShiftClustersExternalAuthOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HcpOpenShiftClustersExternalAuthOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = auth.OriginalVersion()

	// Owner
	if auth.Owner != nil {
		owner := auth.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if auth.Properties != nil {
		var property storage.ExternalAuthProperties
		err := auth.Properties.AssignProperties_To_ExternalAuthProperties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExternalAuthProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HcpOpenShiftClustersExternalAuth_STATUS populates our HcpOpenShiftClustersExternalAuth_Spec from the provided source HcpOpenShiftClustersExternalAuth_STATUS
func (auth *HcpOpenShiftClustersExternalAuth_Spec) Initialize_From_HcpOpenShiftClustersExternalAuth_STATUS(source *HcpOpenShiftClustersExternalAuth_STATUS) error {

	// Properties
	if source.Properties != nil {
		var property ExternalAuthProperties
		err := property.Initialize_From_ExternalAuthProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ExternalAuthProperties_STATUS() to populate field Properties")
		}
		auth.Properties = &property
	} else {
		auth.Properties = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (auth *HcpOpenShiftClustersExternalAuth_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (auth *HcpOpenShiftClustersExternalAuth_Spec) SetAzureName(azureName string) {
	auth.AzureName = azureName
}

type HcpOpenShiftClustersExternalAuth_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Id: Fully qualified resource ID for the resource. E.g.
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
	Id *string `json:"id,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Properties: The resource-specific properties for this resource.
	Properties *ExternalAuthProperties_STATUS `json:"properties,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &HcpOpenShiftClustersExternalAuth_STATUS{}

// ConvertStatusFrom populates our HcpOpenShiftClustersExternalAuth_STATUS from the provided source
func (auth *HcpOpenShiftClustersExternalAuth_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.HcpOpenShiftClustersExternalAuth_STATUS)
	if ok {
		// Populate our instance from source
		return auth.AssignProperties_From_HcpOpenShiftClustersExternalAuth_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.HcpOpenShiftClustersExternalAuth_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = auth.AssignProperties_From_HcpOpenShiftClustersExternalAuth_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our HcpOpenShiftClustersExternalAuth_STATUS
func (auth *HcpOpenShiftClustersExternalAuth_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.HcpOpenShiftClustersExternalAuth_STATUS)
	if ok {
		// Populate destination from our instance
		return auth.AssignProperties_To_HcpOpenShiftClustersExternalAuth_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.HcpOpenShiftClustersExternalAuth_STATUS{}
	err := auth.AssignProperties_To_HcpOpenShiftClustersExternalAuth_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &HcpOpenShiftClustersExternalAuth_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (auth *HcpOpenShiftClustersExternalAuth_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HcpOpenShiftClustersExternalAuth_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (auth *HcpOpenShiftClustersExternalAuth_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HcpOpenShiftClustersExternalAuth_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HcpOpenShiftClustersExternalAuth_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		auth.Id = &id
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		auth.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 ExternalAuthProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		auth.Properties = &properties
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		auth.SystemData = &systemData
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		auth.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_HcpOpenShiftClustersExternalAuth_STATUS populates our HcpOpenShiftClustersExternalAuth_STATUS from the provided source HcpOpenShiftClustersExternalAuth_STATUS
func (auth *HcpOpenShiftClustersExternalAuth_STATUS) AssignProperties_From_HcpOpenShiftClustersExternalAuth_STATUS(source *storage.HcpOpenShiftClustersExternalAuth_STATUS) error {

	// Conditions
	auth.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Id
	auth.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	auth.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property ExternalAuthProperties_STATUS
		err := property.AssignProperties_From_ExternalAuthProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExternalAuthProperties_STATUS() to populate field Properties")
		}
		auth.Properties = &property
	} else {
		auth.Properties = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		auth.SystemData = &systemDatum
	} else {
		auth.SystemData = nil
	}

	// Type
	auth.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftClustersExternalAuth_STATUS populates the provided destination HcpOpenShiftClustersExternalAuth_STATUS from our HcpOpenShiftClustersExternalAuth_STATUS
func (auth *HcpOpenShiftClustersExternalAuth_STATUS) AssignProperties_To_HcpOpenShiftClustersExternalAuth_STATUS(destination *storage.HcpOpenShiftClustersExternalAuth_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(auth.Conditions)

	// Id
	destination.Id = genruntime.ClonePointerToString(auth.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(auth.Name)

	// Properties
	if auth.Properties != nil {
		var property storage.ExternalAuthProperties_STATUS
		err := auth.Properties.AssignProperties_To_ExternalAuthProperties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExternalAuthProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// SystemData
	if auth.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := auth.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(auth.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// External Auth profile
type ExternalAuthProperties struct {
	// +kubebuilder:validation:Required
	// Claim: External Auth claim
	// This configures how claims are validated and applied.
	Claim *ExternalAuthClaimProfile `json:"claim,omitempty"`

	// +kubebuilder:validation:MaxItems=20
	// Clients: External Auth OIDC clients
	// There must not be more than 20 entries and entries must have unique namespace/name pairs.
	Clients []ExternalAuthClientProfile `json:"clients,omitempty"`

	// +kubebuilder:validation:Required
	// Issuer: Token Issuer profile
	Issuer *TokenIssuerProfile `json:"issuer,omitempty"`
}

var _ genruntime.ARMTransformer = &ExternalAuthProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *ExternalAuthProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.ExternalAuthProperties{}

	// Set property "Claim":
	if properties.Claim != nil {
		claim_ARM, err := properties.Claim.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		claim := *claim_ARM.(*arm.ExternalAuthClaimProfile)
		result.Claim = &claim
	}

	// Set property "Clients":
	for _, item := range properties.Clients {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Clients = append(result.Clients, *item_ARM.(*arm.ExternalAuthClientProfile))
	}

	// Set property "Issuer":
	if properties.Issuer != nil {
		issuer_ARM, err := properties.Issuer.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		issuer := *issuer_ARM.(*arm.TokenIssuerProfile)
		result.Issuer = &issuer
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ExternalAuthProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExternalAuthProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ExternalAuthProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExternalAuthProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExternalAuthProperties, got %T", armInput)
	}

	// Set property "Claim":
	if typedInput.Claim != nil {
		var claim1 ExternalAuthClaimProfile
		err := claim1.PopulateFromARM(owner, *typedInput.Claim)
		if err != nil {
			return err
		}
		claim := claim1
		properties.Claim = &claim
	}

	// Set property "Clients":
	for _, item := range typedInput.Clients {
		var item1 ExternalAuthClientProfile
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Clients = append(properties.Clients, item1)
	}

	// Set property "Issuer":
	if typedInput.Issuer != nil {
		var issuer1 TokenIssuerProfile
		err := issuer1.PopulateFromARM(owner, *typedInput.Issuer)
		if err != nil {
			return err
		}
		issuer := issuer1
		properties.Issuer = &issuer
	}

	// No error
	return nil
}

// AssignProperties_From_ExternalAuthProperties populates our ExternalAuthProperties from the provided source ExternalAuthProperties
func (properties *ExternalAuthProperties) AssignProperties_From_ExternalAuthProperties(source *storage.ExternalAuthProperties) error {

	// Claim
	if source.Claim != nil {
		var claim ExternalAuthClaimProfile
		err := claim.AssignProperties_From_ExternalAuthClaimProfile(source.Claim)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExternalAuthClaimProfile() to populate field Claim")
		}
		properties.Claim = &claim
	} else {
		properties.Claim = nil
	}

	// Clients
	if source.Clients != nil {
		clientList := make([]ExternalAuthClientProfile, len(source.Clients))
		for clientIndex, clientItem := range source.Clients {
			var client ExternalAuthClientProfile
			err := client.AssignProperties_From_ExternalAuthClientProfile(&clientItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ExternalAuthClientProfile() to populate field Clients")
			}
			clientList[clientIndex] = client
		}
		properties.Clients = clientList
	} else {
		properties.Clients = nil
	}

	// Issuer
	if source.Issuer != nil {
		var issuer TokenIssuerProfile
		err := issuer.AssignProperties_From_TokenIssuerProfile(source.Issuer)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TokenIssuerProfile() to populate field Issuer")
		}
		properties.Issuer = &issuer
	} else {
		properties.Issuer = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExternalAuthProperties populates the provided destination ExternalAuthProperties from our ExternalAuthProperties
func (properties *ExternalAuthProperties) AssignProperties_To_ExternalAuthProperties(destination *storage.ExternalAuthProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Claim
	if properties.Claim != nil {
		var claim storage.ExternalAuthClaimProfile
		err := properties.Claim.AssignProperties_To_ExternalAuthClaimProfile(&claim)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExternalAuthClaimProfile() to populate field Claim")
		}
		destination.Claim = &claim
	} else {
		destination.Claim = nil
	}

	// Clients
	if properties.Clients != nil {
		clientList := make([]storage.ExternalAuthClientProfile, len(properties.Clients))
		for clientIndex, clientItem := range properties.Clients {
			var client storage.ExternalAuthClientProfile
			err := clientItem.AssignProperties_To_ExternalAuthClientProfile(&client)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ExternalAuthClientProfile() to populate field Clients")
			}
			clientList[clientIndex] = client
		}
		destination.Clients = clientList
	} else {
		destination.Clients = nil
	}

	// Issuer
	if properties.Issuer != nil {
		var issuer storage.TokenIssuerProfile
		err := properties.Issuer.AssignProperties_To_TokenIssuerProfile(&issuer)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TokenIssuerProfile() to populate field Issuer")
		}
		destination.Issuer = &issuer
	} else {
		destination.Issuer = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ExternalAuthProperties_STATUS populates our ExternalAuthProperties from the provided source ExternalAuthProperties_STATUS
func (properties *ExternalAuthProperties) Initialize_From_ExternalAuthProperties_STATUS(source *ExternalAuthProperties_STATUS) error {

	// Claim
	if source.Claim != nil {
		var claim ExternalAuthClaimProfile
		err := claim.Initialize_From_ExternalAuthClaimProfile_STATUS(source.Claim)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ExternalAuthClaimProfile_STATUS() to populate field Claim")
		}
		properties.Claim = &claim
	} else {
		properties.Claim = nil
	}

	// Clients
	if source.Clients != nil {
		clientList := make([]ExternalAuthClientProfile, len(source.Clients))
		for clientIndex, clientItem := range source.Clients {
			var client ExternalAuthClientProfile
			err := client.Initialize_From_ExternalAuthClientProfile_STATUS(&clientItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_ExternalAuthClientProfile_STATUS() to populate field Clients")
			}
			clientList[clientIndex] = client
		}
		properties.Clients = clientList
	} else {
		properties.Clients = nil
	}

	// Issuer
	if source.Issuer != nil {
		var issuer TokenIssuerProfile
		err := issuer.Initialize_From_TokenIssuerProfile_STATUS(source.Issuer)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_TokenIssuerProfile_STATUS() to populate field Issuer")
		}
		properties.Issuer = &issuer
	} else {
		properties.Issuer = nil
	}

	// No error
	return nil
}

// External Auth profile
type ExternalAuthProperties_STATUS struct {
	// Claim: External Auth claim
	// This configures how claims are validated and applied.
	Claim *ExternalAuthClaimProfile_STATUS `json:"claim,omitempty"`

	// Clients: External Auth OIDC clients
	// There must not be more than 20 entries and entries must have unique namespace/name pairs.
	Clients []ExternalAuthClientProfile_STATUS `json:"clients,omitempty"`

	// Condition: An observation of the current state with additional information.
	Condition *ExternalAuthCondition_STATUS `json:"condition,omitempty"`

	// Issuer: Token Issuer profile
	Issuer *TokenIssuerProfile_STATUS `json:"issuer,omitempty"`

	// ProvisioningState: Provisioning state
	ProvisioningState *ExternalAuthProvisioningState_STATUS `json:"provisioningState,omitempty"`
}

var _ genruntime.FromARMConverter = &ExternalAuthProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ExternalAuthProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExternalAuthProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ExternalAuthProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExternalAuthProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExternalAuthProperties_STATUS, got %T", armInput)
	}

	// Set property "Claim":
	if typedInput.Claim != nil {
		var claim1 ExternalAuthClaimProfile_STATUS
		err := claim1.PopulateFromARM(owner, *typedInput.Claim)
		if err != nil {
			return err
		}
		claim := claim1
		properties.Claim = &claim
	}

	// Set property "Clients":
	for _, item := range typedInput.Clients {
		var item1 ExternalAuthClientProfile_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		properties.Clients = append(properties.Clients, item1)
	}

	// Set property "Condition":
	if typedInput.Condition != nil {
		var condition1 ExternalAuthCondition_STATUS
		err := condition1.PopulateFromARM(owner, *typedInput.Condition)
		if err != nil {
			return err
		}
		condition := condition1
		properties.Condition = &condition
	}

	// Set property "Issuer":
	if typedInput.Issuer != nil {
		var issuer1 TokenIssuerProfile_STATUS
		err := issuer1.PopulateFromARM(owner, *typedInput.Issuer)
		if err != nil {
			return err
		}
		issuer := issuer1
		properties.Issuer = &issuer
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var temp string
		temp = string(*typedInput.ProvisioningState)
		provisioningState := ExternalAuthProvisioningState_STATUS(temp)
		properties.ProvisioningState = &provisioningState
	}

	// No error
	return nil
}

// AssignProperties_From_ExternalAuthProperties_STATUS populates our ExternalAuthProperties_STATUS from the provided source ExternalAuthProperties_STATUS
func (properties *ExternalAuthProperties_STATUS) AssignProperties_From_ExternalAuthProperties_STATUS(source *storage.ExternalAuthProperties_STATUS) error {

	// Claim
	if source.Claim != nil {
		var claim ExternalAuthClaimProfile_STATUS
		err := claim.AssignProperties_From_ExternalAuthClaimProfile_STATUS(source.Claim)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExternalAuthClaimProfile_STATUS() to populate field Claim")
		}
		properties.Claim = &claim
	} else {
		properties.Claim = nil
	}

	// Clients
	if source.Clients != nil {
		clientList := make([]ExternalAuthClientProfile_STATUS, len(source.Clients))
		for clientIndex, clientItem := range source.Clients {
			var client ExternalAuthClientProfile_STATUS
			err := client.AssignProperties_From_ExternalAuthClientProfile_STATUS(&clientItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ExternalAuthClientProfile_STATUS() to populate field Clients")
			}
			clientList[clientIndex] = client
		}
		properties.Clients = clientList
	} else {
		properties.Clients = nil
	}

	// Condition
	if source.Condition != nil {
		var condition ExternalAuthCondition_STATUS
		err := condition.AssignProperties_From_ExternalAuthCondition_STATUS(source.Condition)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExternalAuthCondition_STATUS() to populate field Condition")
		}
		properties.Condition = &condition
	} else {
		properties.Condition = nil
	}

	// Issuer
	if source.Issuer != nil {
		var issuer TokenIssuerProfile_STATUS
		err := issuer.AssignProperties_From_TokenIssuerProfile_STATUS(source.Issuer)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TokenIssuerProfile_STATUS() to populate field Issuer")
		}
		properties.Issuer = &issuer
	} else {
		properties.Issuer = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, externalAuthProvisioningState_STATUS_Values)
		properties.ProvisioningState = &provisioningStateTemp
	} else {
		properties.ProvisioningState = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExternalAuthProperties_STATUS populates the provided destination ExternalAuthProperties_STATUS from our ExternalAuthProperties_STATUS
func (properties *ExternalAuthProperties_STATUS) AssignProperties_To_ExternalAuthProperties_STATUS(destination *storage.ExternalAuthProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Claim
	if properties.Claim != nil {
		var claim storage.ExternalAuthClaimProfile_STATUS
		err := properties.Claim.AssignProperties_To_ExternalAuthClaimProfile_STATUS(&claim)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExternalAuthClaimProfile_STATUS() to populate field Claim")
		}
		destination.Claim = &claim
	} else {
		destination.Claim = nil
	}

	// Clients
	if properties.Clients != nil {
		clientList := make([]storage.ExternalAuthClientProfile_STATUS, len(properties.Clients))
		for clientIndex, clientItem := range properties.Clients {
			var client storage.ExternalAuthClientProfile_STATUS
			err := clientItem.AssignProperties_To_ExternalAuthClientProfile_STATUS(&client)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ExternalAuthClientProfile_STATUS() to populate field Clients")
			}
			clientList[clientIndex] = client
		}
		destination.Clients = clientList
	} else {
		destination.Clients = nil
	}

	// Condition
	if properties.Condition != nil {
		var condition storage.ExternalAuthCondition_STATUS
		err := properties.Condition.AssignProperties_To_ExternalAuthCondition_STATUS(&condition)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExternalAuthCondition_STATUS() to populate field Condition")
		}
		destination.Condition = &condition
	} else {
		destination.Condition = nil
	}

	// Issuer
	if properties.Issuer != nil {
		var issuer storage.TokenIssuerProfile_STATUS
		err := properties.Issuer.AssignProperties_To_TokenIssuerProfile_STATUS(&issuer)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TokenIssuerProfile_STATUS() to populate field Issuer")
		}
		destination.Issuer = &issuer
	} else {
		destination.Issuer = nil
	}

	// ProvisioningState
	if properties.ProvisioningState != nil {
		provisioningState := string(*properties.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type HcpOpenShiftClustersExternalAuthOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_HcpOpenShiftClustersExternalAuthOperatorSpec populates our HcpOpenShiftClustersExternalAuthOperatorSpec from the provided source HcpOpenShiftClustersExternalAuthOperatorSpec
func (operator *HcpOpenShiftClustersExternalAuthOperatorSpec) AssignProperties_From_HcpOpenShiftClustersExternalAuthOperatorSpec(source *storage.HcpOpenShiftClustersExternalAuthOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftClustersExternalAuthOperatorSpec populates the provided destination HcpOpenShiftClustersExternalAuthOperatorSpec from our HcpOpenShiftClustersExternalAuthOperatorSpec
func (operator *HcpOpenShiftClustersExternalAuthOperatorSpec) AssignProperties_To_HcpOpenShiftClustersExternalAuthOperatorSpec(destination *storage.HcpOpenShiftClustersExternalAuthOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// External Auth claim profile
type ExternalAuthClaimProfile struct {
	// +kubebuilder:validation:Required
	// Mappings: The claim mappings
	Mappings *TokenClaimMappingsProfile `json:"mappings,omitempty"`

	// ValidationRules: The claim validation rules
	ValidationRules []TokenClaimValidationRule `json:"validationRules,omitempty"`
}

var _ genruntime.ARMTransformer = &ExternalAuthClaimProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ExternalAuthClaimProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ExternalAuthClaimProfile{}

	// Set property "Mappings":
	if profile.Mappings != nil {
		mappings_ARM, err := profile.Mappings.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		mappings := *mappings_ARM.(*arm.TokenClaimMappingsProfile)
		result.Mappings = &mappings
	}

	// Set property "ValidationRules":
	for _, item := range profile.ValidationRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ValidationRules = append(result.ValidationRules, *item_ARM.(*arm.TokenClaimValidationRule))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ExternalAuthClaimProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExternalAuthClaimProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ExternalAuthClaimProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExternalAuthClaimProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExternalAuthClaimProfile, got %T", armInput)
	}

	// Set property "Mappings":
	if typedInput.Mappings != nil {
		var mappings1 TokenClaimMappingsProfile
		err := mappings1.PopulateFromARM(owner, *typedInput.Mappings)
		if err != nil {
			return err
		}
		mappings := mappings1
		profile.Mappings = &mappings
	}

	// Set property "ValidationRules":
	for _, item := range typedInput.ValidationRules {
		var item1 TokenClaimValidationRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.ValidationRules = append(profile.ValidationRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ExternalAuthClaimProfile populates our ExternalAuthClaimProfile from the provided source ExternalAuthClaimProfile
func (profile *ExternalAuthClaimProfile) AssignProperties_From_ExternalAuthClaimProfile(source *storage.ExternalAuthClaimProfile) error {

	// Mappings
	if source.Mappings != nil {
		var mapping TokenClaimMappingsProfile
		err := mapping.AssignProperties_From_TokenClaimMappingsProfile(source.Mappings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TokenClaimMappingsProfile() to populate field Mappings")
		}
		profile.Mappings = &mapping
	} else {
		profile.Mappings = nil
	}

	// ValidationRules
	if source.ValidationRules != nil {
		validationRuleList := make([]TokenClaimValidationRule, len(source.ValidationRules))
		for validationRuleIndex, validationRuleItem := range source.ValidationRules {
			var validationRule TokenClaimValidationRule
			err := validationRule.AssignProperties_From_TokenClaimValidationRule(&validationRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_TokenClaimValidationRule() to populate field ValidationRules")
			}
			validationRuleList[validationRuleIndex] = validationRule
		}
		profile.ValidationRules = validationRuleList
	} else {
		profile.ValidationRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExternalAuthClaimProfile populates the provided destination ExternalAuthClaimProfile from our ExternalAuthClaimProfile
func (profile *ExternalAuthClaimProfile) AssignProperties_To_ExternalAuthClaimProfile(destination *storage.ExternalAuthClaimProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Mappings
	if profile.Mappings != nil {
		var mapping storage.TokenClaimMappingsProfile
		err := profile.Mappings.AssignProperties_To_TokenClaimMappingsProfile(&mapping)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TokenClaimMappingsProfile() to populate field Mappings")
		}
		destination.Mappings = &mapping
	} else {
		destination.Mappings = nil
	}

	// ValidationRules
	if profile.ValidationRules != nil {
		validationRuleList := make([]storage.TokenClaimValidationRule, len(profile.ValidationRules))
		for validationRuleIndex, validationRuleItem := range profile.ValidationRules {
			var validationRule storage.TokenClaimValidationRule
			err := validationRuleItem.AssignProperties_To_TokenClaimValidationRule(&validationRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_TokenClaimValidationRule() to populate field ValidationRules")
			}
			validationRuleList[validationRuleIndex] = validationRule
		}
		destination.ValidationRules = validationRuleList
	} else {
		destination.ValidationRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ExternalAuthClaimProfile_STATUS populates our ExternalAuthClaimProfile from the provided source ExternalAuthClaimProfile_STATUS
func (profile *ExternalAuthClaimProfile) Initialize_From_ExternalAuthClaimProfile_STATUS(source *ExternalAuthClaimProfile_STATUS) error {

	// Mappings
	if source.Mappings != nil {
		var mapping TokenClaimMappingsProfile
		err := mapping.Initialize_From_TokenClaimMappingsProfile_STATUS(source.Mappings)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_TokenClaimMappingsProfile_STATUS() to populate field Mappings")
		}
		profile.Mappings = &mapping
	} else {
		profile.Mappings = nil
	}

	// ValidationRules
	if source.ValidationRules != nil {
		validationRuleList := make([]TokenClaimValidationRule, len(source.ValidationRules))
		for validationRuleIndex, validationRuleItem := range source.ValidationRules {
			var validationRule TokenClaimValidationRule
			err := validationRule.Initialize_From_TokenClaimValidationRule_STATUS(&validationRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling Initialize_From_TokenClaimValidationRule_STATUS() to populate field ValidationRules")
			}
			validationRuleList[validationRuleIndex] = validationRule
		}
		profile.ValidationRules = validationRuleList
	} else {
		profile.ValidationRules = nil
	}

	// No error
	return nil
}

// External Auth claim profile
type ExternalAuthClaimProfile_STATUS struct {
	// Mappings: The claim mappings
	Mappings *TokenClaimMappingsProfile_STATUS `json:"mappings,omitempty"`

	// ValidationRules: The claim validation rules
	ValidationRules []TokenClaimValidationRule_STATUS `json:"validationRules,omitempty"`
}

var _ genruntime.FromARMConverter = &ExternalAuthClaimProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ExternalAuthClaimProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExternalAuthClaimProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ExternalAuthClaimProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExternalAuthClaimProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExternalAuthClaimProfile_STATUS, got %T", armInput)
	}

	// Set property "Mappings":
	if typedInput.Mappings != nil {
		var mappings1 TokenClaimMappingsProfile_STATUS
		err := mappings1.PopulateFromARM(owner, *typedInput.Mappings)
		if err != nil {
			return err
		}
		mappings := mappings1
		profile.Mappings = &mappings
	}

	// Set property "ValidationRules":
	for _, item := range typedInput.ValidationRules {
		var item1 TokenClaimValidationRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		profile.ValidationRules = append(profile.ValidationRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_ExternalAuthClaimProfile_STATUS populates our ExternalAuthClaimProfile_STATUS from the provided source ExternalAuthClaimProfile_STATUS
func (profile *ExternalAuthClaimProfile_STATUS) AssignProperties_From_ExternalAuthClaimProfile_STATUS(source *storage.ExternalAuthClaimProfile_STATUS) error {

	// Mappings
	if source.Mappings != nil {
		var mapping TokenClaimMappingsProfile_STATUS
		err := mapping.AssignProperties_From_TokenClaimMappingsProfile_STATUS(source.Mappings)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TokenClaimMappingsProfile_STATUS() to populate field Mappings")
		}
		profile.Mappings = &mapping
	} else {
		profile.Mappings = nil
	}

	// ValidationRules
	if source.ValidationRules != nil {
		validationRuleList := make([]TokenClaimValidationRule_STATUS, len(source.ValidationRules))
		for validationRuleIndex, validationRuleItem := range source.ValidationRules {
			var validationRule TokenClaimValidationRule_STATUS
			err := validationRule.AssignProperties_From_TokenClaimValidationRule_STATUS(&validationRuleItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_TokenClaimValidationRule_STATUS() to populate field ValidationRules")
			}
			validationRuleList[validationRuleIndex] = validationRule
		}
		profile.ValidationRules = validationRuleList
	} else {
		profile.ValidationRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExternalAuthClaimProfile_STATUS populates the provided destination ExternalAuthClaimProfile_STATUS from our ExternalAuthClaimProfile_STATUS
func (profile *ExternalAuthClaimProfile_STATUS) AssignProperties_To_ExternalAuthClaimProfile_STATUS(destination *storage.ExternalAuthClaimProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Mappings
	if profile.Mappings != nil {
		var mapping storage.TokenClaimMappingsProfile_STATUS
		err := profile.Mappings.AssignProperties_To_TokenClaimMappingsProfile_STATUS(&mapping)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TokenClaimMappingsProfile_STATUS() to populate field Mappings")
		}
		destination.Mappings = &mapping
	} else {
		destination.Mappings = nil
	}

	// ValidationRules
	if profile.ValidationRules != nil {
		validationRuleList := make([]storage.TokenClaimValidationRule_STATUS, len(profile.ValidationRules))
		for validationRuleIndex, validationRuleItem := range profile.ValidationRules {
			var validationRule storage.TokenClaimValidationRule_STATUS
			err := validationRuleItem.AssignProperties_To_TokenClaimValidationRule_STATUS(&validationRule)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_TokenClaimValidationRule_STATUS() to populate field ValidationRules")
			}
			validationRuleList[validationRuleIndex] = validationRule
		}
		destination.ValidationRules = validationRuleList
	} else {
		destination.ValidationRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// External Auth client profile
// This configures how on-cluster, platform clients should request tokens from the identity
// provider.
type ExternalAuthClientProfile struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MinLength=1
	// ClientId: External Auth client id
	// The clientId must appear in the audience field of the TokenIssuerProfile.
	ClientId *string `json:"clientId,omitempty"`

	// +kubebuilder:validation:Required
	// Component: External Auth client component
	Component *ExternalAuthClientComponentProfile `json:"component,omitempty"`

	// ExtraScopes: external auth client scopes
	// This is useful if you have configured claim mappings that requires specific
	// scopes to be requested beyond the standard OIDC scopes.
	// When omitted, no additional scopes are requested.
	ExtraScopes []string `json:"extraScopes,omitempty"`

	// +kubebuilder:validation:Required
	// Type: Determines the OIDC provider client type.
	Type *ExternalAuthClientType `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &ExternalAuthClientProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ExternalAuthClientProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ExternalAuthClientProfile{}

	// Set property "ClientId":
	if profile.ClientId != nil {
		clientId := *profile.ClientId
		result.ClientId = &clientId
	}

	// Set property "Component":
	if profile.Component != nil {
		component_ARM, err := profile.Component.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		component := *component_ARM.(*arm.ExternalAuthClientComponentProfile)
		result.Component = &component
	}

	// Set property "ExtraScopes":
	for _, item := range profile.ExtraScopes {
		result.ExtraScopes = append(result.ExtraScopes, item)
	}

	// Set property "Type":
	if profile.Type != nil {
		var temp string
		temp = string(*profile.Type)
		typeVar := arm.ExternalAuthClientType(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ExternalAuthClientProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExternalAuthClientProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ExternalAuthClientProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExternalAuthClientProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExternalAuthClientProfile, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		profile.ClientId = &clientId
	}

	// Set property "Component":
	if typedInput.Component != nil {
		var component1 ExternalAuthClientComponentProfile
		err := component1.PopulateFromARM(owner, *typedInput.Component)
		if err != nil {
			return err
		}
		component := component1
		profile.Component = &component
	}

	// Set property "ExtraScopes":
	for _, item := range typedInput.ExtraScopes {
		profile.ExtraScopes = append(profile.ExtraScopes, item)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ExternalAuthClientType(temp)
		profile.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ExternalAuthClientProfile populates our ExternalAuthClientProfile from the provided source ExternalAuthClientProfile
func (profile *ExternalAuthClientProfile) AssignProperties_From_ExternalAuthClientProfile(source *storage.ExternalAuthClientProfile) error {

	// ClientId
	profile.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// Component
	if source.Component != nil {
		var component ExternalAuthClientComponentProfile
		err := component.AssignProperties_From_ExternalAuthClientComponentProfile(source.Component)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExternalAuthClientComponentProfile() to populate field Component")
		}
		profile.Component = &component
	} else {
		profile.Component = nil
	}

	// ExtraScopes
	profile.ExtraScopes = genruntime.CloneSliceOfString(source.ExtraScopes)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, externalAuthClientType_Values)
		profile.Type = &typeTemp
	} else {
		profile.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExternalAuthClientProfile populates the provided destination ExternalAuthClientProfile from our ExternalAuthClientProfile
func (profile *ExternalAuthClientProfile) AssignProperties_To_ExternalAuthClientProfile(destination *storage.ExternalAuthClientProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(profile.ClientId)

	// Component
	if profile.Component != nil {
		var component storage.ExternalAuthClientComponentProfile
		err := profile.Component.AssignProperties_To_ExternalAuthClientComponentProfile(&component)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExternalAuthClientComponentProfile() to populate field Component")
		}
		destination.Component = &component
	} else {
		destination.Component = nil
	}

	// ExtraScopes
	destination.ExtraScopes = genruntime.CloneSliceOfString(profile.ExtraScopes)

	// Type
	if profile.Type != nil {
		typeVar := string(*profile.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ExternalAuthClientProfile_STATUS populates our ExternalAuthClientProfile from the provided source ExternalAuthClientProfile_STATUS
func (profile *ExternalAuthClientProfile) Initialize_From_ExternalAuthClientProfile_STATUS(source *ExternalAuthClientProfile_STATUS) error {

	// ClientId
	profile.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// Component
	if source.Component != nil {
		var component ExternalAuthClientComponentProfile
		err := component.Initialize_From_ExternalAuthClientComponentProfile_STATUS(source.Component)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ExternalAuthClientComponentProfile_STATUS() to populate field Component")
		}
		profile.Component = &component
	} else {
		profile.Component = nil
	}

	// ExtraScopes
	profile.ExtraScopes = genruntime.CloneSliceOfString(source.ExtraScopes)

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), externalAuthClientType_Values)
		profile.Type = &typeVar
	} else {
		profile.Type = nil
	}

	// No error
	return nil
}

// External Auth client profile
// This configures how on-cluster, platform clients should request tokens from the identity
// provider.
type ExternalAuthClientProfile_STATUS struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MinLength=1
	// ClientId: External Auth client id
	// The clientId must appear in the audience field of the TokenIssuerProfile.
	ClientId *string `json:"clientId,omitempty"`

	// +kubebuilder:validation:Required
	// Component: External Auth client component
	Component *ExternalAuthClientComponentProfile_STATUS `json:"component,omitempty"`

	// ExtraScopes: external auth client scopes
	// This is useful if you have configured claim mappings that requires specific
	// scopes to be requested beyond the standard OIDC scopes.
	// When omitted, no additional scopes are requested.
	ExtraScopes []string `json:"extraScopes,omitempty"`

	// +kubebuilder:validation:Required
	// Type: Determines the OIDC provider client type.
	Type *ExternalAuthClientType_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ExternalAuthClientProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ExternalAuthClientProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExternalAuthClientProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ExternalAuthClientProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExternalAuthClientProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExternalAuthClientProfile_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		profile.ClientId = &clientId
	}

	// Set property "Component":
	if typedInput.Component != nil {
		var component1 ExternalAuthClientComponentProfile_STATUS
		err := component1.PopulateFromARM(owner, *typedInput.Component)
		if err != nil {
			return err
		}
		component := component1
		profile.Component = &component
	}

	// Set property "ExtraScopes":
	for _, item := range typedInput.ExtraScopes {
		profile.ExtraScopes = append(profile.ExtraScopes, item)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ExternalAuthClientType_STATUS(temp)
		profile.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ExternalAuthClientProfile_STATUS populates our ExternalAuthClientProfile_STATUS from the provided source ExternalAuthClientProfile_STATUS
func (profile *ExternalAuthClientProfile_STATUS) AssignProperties_From_ExternalAuthClientProfile_STATUS(source *storage.ExternalAuthClientProfile_STATUS) error {

	// ClientId
	profile.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// Component
	if source.Component != nil {
		var component ExternalAuthClientComponentProfile_STATUS
		err := component.AssignProperties_From_ExternalAuthClientComponentProfile_STATUS(source.Component)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ExternalAuthClientComponentProfile_STATUS() to populate field Component")
		}
		profile.Component = &component
	} else {
		profile.Component = nil
	}

	// ExtraScopes
	profile.ExtraScopes = genruntime.CloneSliceOfString(source.ExtraScopes)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, externalAuthClientType_STATUS_Values)
		profile.Type = &typeTemp
	} else {
		profile.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExternalAuthClientProfile_STATUS populates the provided destination ExternalAuthClientProfile_STATUS from our ExternalAuthClientProfile_STATUS
func (profile *ExternalAuthClientProfile_STATUS) AssignProperties_To_ExternalAuthClientProfile_STATUS(destination *storage.ExternalAuthClientProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(profile.ClientId)

	// Component
	if profile.Component != nil {
		var component storage.ExternalAuthClientComponentProfile_STATUS
		err := profile.Component.AssignProperties_To_ExternalAuthClientComponentProfile_STATUS(&component)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ExternalAuthClientComponentProfile_STATUS() to populate field Component")
		}
		destination.Component = &component
	} else {
		destination.Component = nil
	}

	// ExtraScopes
	destination.ExtraScopes = genruntime.CloneSliceOfString(profile.ExtraScopes)

	// Type
	if profile.Type != nil {
		typeVar := string(*profile.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Condition defines an observation of the external auth state.
type ExternalAuthCondition_STATUS struct {
	// LastTransitionTime: The last time the condition transitioned from one status to another.
	LastTransitionTime *string `json:"lastTransitionTime,omitempty"`

	// Message: This is a human readable message indicating details about the transition.
	// This may be an empty string.
	Message *string `json:"message,omitempty"`

	// Reason: This contains a programmatic identifier indicating the reason for the condition's last transition.
	Reason *string `json:"reason,omitempty"`

	// Status: The status of the condition.
	Status *StatusType_STATUS `json:"status,omitempty"`

	// Type: This is a PascalCase (or in foo.example.com/PascalCase) code to represent the type of condition.
	Type *ExternalAuthConditionType_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &ExternalAuthCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *ExternalAuthCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExternalAuthCondition_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *ExternalAuthCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExternalAuthCondition_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExternalAuthCondition_STATUS, got %T", armInput)
	}

	// Set property "LastTransitionTime":
	if typedInput.LastTransitionTime != nil {
		lastTransitionTime := *typedInput.LastTransitionTime
		condition.LastTransitionTime = &lastTransitionTime
	}

	// Set property "Message":
	if typedInput.Message != nil {
		message := *typedInput.Message
		condition.Message = &message
	}

	// Set property "Reason":
	if typedInput.Reason != nil {
		reason := *typedInput.Reason
		condition.Reason = &reason
	}

	// Set property "Status":
	if typedInput.Status != nil {
		var temp string
		temp = string(*typedInput.Status)
		status := StatusType_STATUS(temp)
		condition.Status = &status
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ExternalAuthConditionType_STATUS(temp)
		condition.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_ExternalAuthCondition_STATUS populates our ExternalAuthCondition_STATUS from the provided source ExternalAuthCondition_STATUS
func (condition *ExternalAuthCondition_STATUS) AssignProperties_From_ExternalAuthCondition_STATUS(source *storage.ExternalAuthCondition_STATUS) error {

	// LastTransitionTime
	condition.LastTransitionTime = genruntime.ClonePointerToString(source.LastTransitionTime)

	// Message
	condition.Message = genruntime.ClonePointerToString(source.Message)

	// Reason
	condition.Reason = genruntime.ClonePointerToString(source.Reason)

	// Status
	if source.Status != nil {
		status := *source.Status
		statusTemp := genruntime.ToEnum(status, statusType_STATUS_Values)
		condition.Status = &statusTemp
	} else {
		condition.Status = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, externalAuthConditionType_STATUS_Values)
		condition.Type = &typeTemp
	} else {
		condition.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExternalAuthCondition_STATUS populates the provided destination ExternalAuthCondition_STATUS from our ExternalAuthCondition_STATUS
func (condition *ExternalAuthCondition_STATUS) AssignProperties_To_ExternalAuthCondition_STATUS(destination *storage.ExternalAuthCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// LastTransitionTime
	destination.LastTransitionTime = genruntime.ClonePointerToString(condition.LastTransitionTime)

	// Message
	destination.Message = genruntime.ClonePointerToString(condition.Message)

	// Reason
	destination.Reason = genruntime.ClonePointerToString(condition.Reason)

	// Status
	if condition.Status != nil {
		status := string(*condition.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Type
	if condition.Type != nil {
		typeVar := string(*condition.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The resource provisioning state.
type ExternalAuthProvisioningState_STATUS string

const (
	ExternalAuthProvisioningState_STATUS_Accepted       = ExternalAuthProvisioningState_STATUS("Accepted")
	ExternalAuthProvisioningState_STATUS_AwaitingSecret = ExternalAuthProvisioningState_STATUS("AwaitingSecret")
	ExternalAuthProvisioningState_STATUS_Canceled       = ExternalAuthProvisioningState_STATUS("Canceled")
	ExternalAuthProvisioningState_STATUS_Deleting       = ExternalAuthProvisioningState_STATUS("Deleting")
	ExternalAuthProvisioningState_STATUS_Failed         = ExternalAuthProvisioningState_STATUS("Failed")
	ExternalAuthProvisioningState_STATUS_Provisioning   = ExternalAuthProvisioningState_STATUS("Provisioning")
	ExternalAuthProvisioningState_STATUS_Succeeded      = ExternalAuthProvisioningState_STATUS("Succeeded")
	ExternalAuthProvisioningState_STATUS_Updating       = ExternalAuthProvisioningState_STATUS("Updating")
)

// Mapping from string to ExternalAuthProvisioningState_STATUS
var externalAuthProvisioningState_STATUS_Values = map[string]ExternalAuthProvisioningState_STATUS{
	"accepted":       ExternalAuthProvisioningState_STATUS_Accepted,
	"awaitingsecret": ExternalAuthProvisioningState_STATUS_AwaitingSecret,
	"canceled":       ExternalAuthProvisioningState_STATUS_Canceled,
	"deleting":       ExternalAuthProvisioningState_STATUS_Deleting,
	"failed":         ExternalAuthProvisioningState_STATUS_Failed,
	"provisioning":   ExternalAuthProvisioningState_STATUS_Provisioning,
	"succeeded":      ExternalAuthProvisioningState_STATUS_Succeeded,
	"updating":       ExternalAuthProvisioningState_STATUS_Updating,
}

// Token issuer profile
// This configures how the platform interacts with the identity provider and
// how tokens issued from
// the identity provider are evaluated by the Kubernetes API server.
type TokenIssuerProfile struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxItems=10
	// +kubebuilder:validation:MinItems=1
	// Audiences: This configures the acceptable audiences the JWT token, issued by the identity
	// provider, must be issued to. At least one of the entries must match the
	// 'aud' claim in the JWT token.
	// audiences must contain at least one entry and must not exceed ten entries.
	Audiences []string `json:"audiences,omitempty"`

	// Ca: The issuer of the token
	// Certificate bundle to use to validate server certificates for the configured URL.
	// It must be PEM encoded and when not specified, the system trust is used.
	Ca *string `json:"ca,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:Pattern="^[a-zA-Z][a-zA-Z0-9+-.]*:[^\\s]*$"
	// Url: This configures the URL used to issue tokens by the identity provider.
	// The Kubernetes API server determines how authentication tokens should be handled
	// by matching the 'iss' claim in the JWT to the issuerURL of configured identity providers.
	// issuerURL must use the 'https' scheme.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.ARMTransformer = &TokenIssuerProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *TokenIssuerProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.TokenIssuerProfile{}

	// Set property "Audiences":
	for _, item := range profile.Audiences {
		result.Audiences = append(result.Audiences, item)
	}

	// Set property "Ca":
	if profile.Ca != nil {
		ca := *profile.Ca
		result.Ca = &ca
	}

	// Set property "Url":
	if profile.Url != nil {
		url := *profile.Url
		result.Url = &url
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *TokenIssuerProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TokenIssuerProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *TokenIssuerProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TokenIssuerProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TokenIssuerProfile, got %T", armInput)
	}

	// Set property "Audiences":
	for _, item := range typedInput.Audiences {
		profile.Audiences = append(profile.Audiences, item)
	}

	// Set property "Ca":
	if typedInput.Ca != nil {
		ca := *typedInput.Ca
		profile.Ca = &ca
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		profile.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_TokenIssuerProfile populates our TokenIssuerProfile from the provided source TokenIssuerProfile
func (profile *TokenIssuerProfile) AssignProperties_From_TokenIssuerProfile(source *storage.TokenIssuerProfile) error {

	// Audiences
	profile.Audiences = genruntime.CloneSliceOfString(source.Audiences)

	// Ca
	profile.Ca = genruntime.ClonePointerToString(source.Ca)

	// Url
	profile.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_TokenIssuerProfile populates the provided destination TokenIssuerProfile from our TokenIssuerProfile
func (profile *TokenIssuerProfile) AssignProperties_To_TokenIssuerProfile(destination *storage.TokenIssuerProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Audiences
	destination.Audiences = genruntime.CloneSliceOfString(profile.Audiences)

	// Ca
	destination.Ca = genruntime.ClonePointerToString(profile.Ca)

	// Url
	destination.Url = genruntime.ClonePointerToString(profile.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TokenIssuerProfile_STATUS populates our TokenIssuerProfile from the provided source TokenIssuerProfile_STATUS
func (profile *TokenIssuerProfile) Initialize_From_TokenIssuerProfile_STATUS(source *TokenIssuerProfile_STATUS) error {

	// Audiences
	profile.Audiences = genruntime.CloneSliceOfString(source.Audiences)

	// Ca
	profile.Ca = genruntime.ClonePointerToString(source.Ca)

	// Url
	profile.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// Token issuer profile
// This configures how the platform interacts with the identity provider and
// how tokens issued from
// the identity provider are evaluated by the Kubernetes API server.
type TokenIssuerProfile_STATUS struct {
	// Audiences: This configures the acceptable audiences the JWT token, issued by the identity
	// provider, must be issued to. At least one of the entries must match the
	// 'aud' claim in the JWT token.
	// audiences must contain at least one entry and must not exceed ten entries.
	Audiences []string `json:"audiences,omitempty"`

	// Ca: The issuer of the token
	// Certificate bundle to use to validate server certificates for the configured URL.
	// It must be PEM encoded and when not specified, the system trust is used.
	Ca *string `json:"ca,omitempty"`

	// Url: This configures the URL used to issue tokens by the identity provider.
	// The Kubernetes API server determines how authentication tokens should be handled
	// by matching the 'iss' claim in the JWT to the issuerURL of configured identity providers.
	// issuerURL must use the 'https' scheme.
	Url *string `json:"url,omitempty"`
}

var _ genruntime.FromARMConverter = &TokenIssuerProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *TokenIssuerProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TokenIssuerProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *TokenIssuerProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TokenIssuerProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TokenIssuerProfile_STATUS, got %T", armInput)
	}

	// Set property "Audiences":
	for _, item := range typedInput.Audiences {
		profile.Audiences = append(profile.Audiences, item)
	}

	// Set property "Ca":
	if typedInput.Ca != nil {
		ca := *typedInput.Ca
		profile.Ca = &ca
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		profile.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_TokenIssuerProfile_STATUS populates our TokenIssuerProfile_STATUS from the provided source TokenIssuerProfile_STATUS
func (profile *TokenIssuerProfile_STATUS) AssignProperties_From_TokenIssuerProfile_STATUS(source *storage.TokenIssuerProfile_STATUS) error {

	// Audiences
	profile.Audiences = genruntime.CloneSliceOfString(source.Audiences)

	// Ca
	profile.Ca = genruntime.ClonePointerToString(source.Ca)

	// Url
	profile.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_TokenIssuerProfile_STATUS populates the provided destination TokenIssuerProfile_STATUS from our TokenIssuerProfile_STATUS
func (profile *TokenIssuerProfile_STATUS) AssignProperties_To_TokenIssuerProfile_STATUS(destination *storage.TokenIssuerProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Audiences
	destination.Audiences = genruntime.CloneSliceOfString(profile.Audiences)

	// Ca
	destination.Ca = genruntime.ClonePointerToString(profile.Ca)

	// Url
	destination.Url = genruntime.ClonePointerToString(profile.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// External Auth component profile
// Must have unique namespace/name pairs.
type ExternalAuthClientComponentProfile struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=63
	// +kubebuilder:validation:MinLength=1
	// AuthClientNamespace: The namespace of the external Auth client
	// This specifies the namespace in which the platform component being configured
	// to use the identity provider as an authentication mode is running.
	// It is used in combination with name as a unique identifier.
	AuthClientNamespace *string `json:"authClientNamespace,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=256
	// +kubebuilder:validation:MinLength=1
	// Name: The name of the external auth client
	// This specifies the name of the platform component being configured to use
	// the identity provider as an authentication mode.
	// It is used in combination with namespace as a unique identifier.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &ExternalAuthClientComponentProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ExternalAuthClientComponentProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ExternalAuthClientComponentProfile{}

	// Set property "AuthClientNamespace":
	if profile.AuthClientNamespace != nil {
		authClientNamespace := *profile.AuthClientNamespace
		result.AuthClientNamespace = &authClientNamespace
	}

	// Set property "Name":
	if profile.Name != nil {
		name := *profile.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ExternalAuthClientComponentProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExternalAuthClientComponentProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ExternalAuthClientComponentProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExternalAuthClientComponentProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExternalAuthClientComponentProfile, got %T", armInput)
	}

	// Set property "AuthClientNamespace":
	if typedInput.AuthClientNamespace != nil {
		authClientNamespace := *typedInput.AuthClientNamespace
		profile.AuthClientNamespace = &authClientNamespace
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_ExternalAuthClientComponentProfile populates our ExternalAuthClientComponentProfile from the provided source ExternalAuthClientComponentProfile
func (profile *ExternalAuthClientComponentProfile) AssignProperties_From_ExternalAuthClientComponentProfile(source *storage.ExternalAuthClientComponentProfile) error {

	// AuthClientNamespace
	profile.AuthClientNamespace = genruntime.ClonePointerToString(source.AuthClientNamespace)

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_ExternalAuthClientComponentProfile populates the provided destination ExternalAuthClientComponentProfile from our ExternalAuthClientComponentProfile
func (profile *ExternalAuthClientComponentProfile) AssignProperties_To_ExternalAuthClientComponentProfile(destination *storage.ExternalAuthClientComponentProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthClientNamespace
	destination.AuthClientNamespace = genruntime.ClonePointerToString(profile.AuthClientNamespace)

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ExternalAuthClientComponentProfile_STATUS populates our ExternalAuthClientComponentProfile from the provided source ExternalAuthClientComponentProfile_STATUS
func (profile *ExternalAuthClientComponentProfile) Initialize_From_ExternalAuthClientComponentProfile_STATUS(source *ExternalAuthClientComponentProfile_STATUS) error {

	// AuthClientNamespace
	profile.AuthClientNamespace = genruntime.ClonePointerToString(source.AuthClientNamespace)

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// External Auth component profile
// Must have unique namespace/name pairs.
type ExternalAuthClientComponentProfile_STATUS struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=63
	// +kubebuilder:validation:MinLength=1
	// AuthClientNamespace: The namespace of the external Auth client
	// This specifies the namespace in which the platform component being configured
	// to use the identity provider as an authentication mode is running.
	// It is used in combination with name as a unique identifier.
	AuthClientNamespace *string `json:"authClientNamespace,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=256
	// +kubebuilder:validation:MinLength=1
	// Name: The name of the external auth client
	// This specifies the name of the platform component being configured to use
	// the identity provider as an authentication mode.
	// It is used in combination with namespace as a unique identifier.
	Name *string `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &ExternalAuthClientComponentProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ExternalAuthClientComponentProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ExternalAuthClientComponentProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ExternalAuthClientComponentProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ExternalAuthClientComponentProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ExternalAuthClientComponentProfile_STATUS, got %T", armInput)
	}

	// Set property "AuthClientNamespace":
	if typedInput.AuthClientNamespace != nil {
		authClientNamespace := *typedInput.AuthClientNamespace
		profile.AuthClientNamespace = &authClientNamespace
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		profile.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_ExternalAuthClientComponentProfile_STATUS populates our ExternalAuthClientComponentProfile_STATUS from the provided source ExternalAuthClientComponentProfile_STATUS
func (profile *ExternalAuthClientComponentProfile_STATUS) AssignProperties_From_ExternalAuthClientComponentProfile_STATUS(source *storage.ExternalAuthClientComponentProfile_STATUS) error {

	// AuthClientNamespace
	profile.AuthClientNamespace = genruntime.ClonePointerToString(source.AuthClientNamespace)

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// No error
	return nil
}

// AssignProperties_To_ExternalAuthClientComponentProfile_STATUS populates the provided destination ExternalAuthClientComponentProfile_STATUS from our ExternalAuthClientComponentProfile_STATUS
func (profile *ExternalAuthClientComponentProfile_STATUS) AssignProperties_To_ExternalAuthClientComponentProfile_STATUS(destination *storage.ExternalAuthClientComponentProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthClientNamespace
	destination.AuthClientNamespace = genruntime.ClonePointerToString(profile.AuthClientNamespace)

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Representation of the possible values of an external authentication client's type
// +kubebuilder:validation:Enum={"Confidential","Public"}
type ExternalAuthClientType string

const (
	ExternalAuthClientType_Confidential = ExternalAuthClientType("Confidential")
	ExternalAuthClientType_Public       = ExternalAuthClientType("Public")
)

// Mapping from string to ExternalAuthClientType
var externalAuthClientType_Values = map[string]ExternalAuthClientType{
	"confidential": ExternalAuthClientType_Confidential,
	"public":       ExternalAuthClientType_Public,
}

// Representation of the possible values of an external authentication client's type
// +kubebuilder:validation:Enum={"Confidential","Public"}
type ExternalAuthClientType_STATUS string

const (
	ExternalAuthClientType_STATUS_Confidential = ExternalAuthClientType_STATUS("Confidential")
	ExternalAuthClientType_STATUS_Public       = ExternalAuthClientType_STATUS("Public")
)

// Mapping from string to ExternalAuthClientType_STATUS
var externalAuthClientType_STATUS_Values = map[string]ExternalAuthClientType_STATUS{
	"confidential": ExternalAuthClientType_STATUS_Confidential,
	"public":       ExternalAuthClientType_STATUS_Public,
}

// Representation of the possible types of a external auths condition.
type ExternalAuthConditionType_STATUS string

const (
	ExternalAuthConditionType_STATUS_Available   = ExternalAuthConditionType_STATUS("Available")
	ExternalAuthConditionType_STATUS_Degraded    = ExternalAuthConditionType_STATUS("Degraded")
	ExternalAuthConditionType_STATUS_Progressing = ExternalAuthConditionType_STATUS("Progressing")
)

// Mapping from string to ExternalAuthConditionType_STATUS
var externalAuthConditionType_STATUS_Values = map[string]ExternalAuthConditionType_STATUS{
	"available":   ExternalAuthConditionType_STATUS_Available,
	"degraded":    ExternalAuthConditionType_STATUS_Degraded,
	"progressing": ExternalAuthConditionType_STATUS_Progressing,
}

// Representation of the possible values of a external auths condition status.
type StatusType_STATUS string

const (
	StatusType_STATUS_False   = StatusType_STATUS("False")
	StatusType_STATUS_True    = StatusType_STATUS("True")
	StatusType_STATUS_Unknown = StatusType_STATUS("Unknown")
)

// Mapping from string to StatusType_STATUS
var statusType_STATUS_Values = map[string]StatusType_STATUS{
	"false":   StatusType_STATUS_False,
	"true":    StatusType_STATUS_True,
	"unknown": StatusType_STATUS_Unknown,
}

// External Auth claim mappings profile.
// At a minimum username or groups must be defined.
type TokenClaimMappingsProfile struct {
	// Groups: The claim mappings groups.
	Groups *GroupClaimProfile `json:"groups,omitempty"`

	// +kubebuilder:validation:Required
	// Username: The claim mappings username.
	Username *UsernameClaimProfile `json:"username,omitempty"`
}

var _ genruntime.ARMTransformer = &TokenClaimMappingsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *TokenClaimMappingsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.TokenClaimMappingsProfile{}

	// Set property "Groups":
	if profile.Groups != nil {
		groups_ARM, err := profile.Groups.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		groups := *groups_ARM.(*arm.GroupClaimProfile)
		result.Groups = &groups
	}

	// Set property "Username":
	if profile.Username != nil {
		username_ARM, err := profile.Username.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		username := *username_ARM.(*arm.UsernameClaimProfile)
		result.Username = &username
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *TokenClaimMappingsProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TokenClaimMappingsProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *TokenClaimMappingsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TokenClaimMappingsProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TokenClaimMappingsProfile, got %T", armInput)
	}

	// Set property "Groups":
	if typedInput.Groups != nil {
		var groups1 GroupClaimProfile
		err := groups1.PopulateFromARM(owner, *typedInput.Groups)
		if err != nil {
			return err
		}
		groups := groups1
		profile.Groups = &groups
	}

	// Set property "Username":
	if typedInput.Username != nil {
		var username1 UsernameClaimProfile
		err := username1.PopulateFromARM(owner, *typedInput.Username)
		if err != nil {
			return err
		}
		username := username1
		profile.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_TokenClaimMappingsProfile populates our TokenClaimMappingsProfile from the provided source TokenClaimMappingsProfile
func (profile *TokenClaimMappingsProfile) AssignProperties_From_TokenClaimMappingsProfile(source *storage.TokenClaimMappingsProfile) error {

	// Groups
	if source.Groups != nil {
		var group GroupClaimProfile
		err := group.AssignProperties_From_GroupClaimProfile(source.Groups)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_GroupClaimProfile() to populate field Groups")
		}
		profile.Groups = &group
	} else {
		profile.Groups = nil
	}

	// Username
	if source.Username != nil {
		var username UsernameClaimProfile
		err := username.AssignProperties_From_UsernameClaimProfile(source.Username)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UsernameClaimProfile() to populate field Username")
		}
		profile.Username = &username
	} else {
		profile.Username = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TokenClaimMappingsProfile populates the provided destination TokenClaimMappingsProfile from our TokenClaimMappingsProfile
func (profile *TokenClaimMappingsProfile) AssignProperties_To_TokenClaimMappingsProfile(destination *storage.TokenClaimMappingsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Groups
	if profile.Groups != nil {
		var group storage.GroupClaimProfile
		err := profile.Groups.AssignProperties_To_GroupClaimProfile(&group)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_GroupClaimProfile() to populate field Groups")
		}
		destination.Groups = &group
	} else {
		destination.Groups = nil
	}

	// Username
	if profile.Username != nil {
		var username storage.UsernameClaimProfile
		err := profile.Username.AssignProperties_To_UsernameClaimProfile(&username)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UsernameClaimProfile() to populate field Username")
		}
		destination.Username = &username
	} else {
		destination.Username = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TokenClaimMappingsProfile_STATUS populates our TokenClaimMappingsProfile from the provided source TokenClaimMappingsProfile_STATUS
func (profile *TokenClaimMappingsProfile) Initialize_From_TokenClaimMappingsProfile_STATUS(source *TokenClaimMappingsProfile_STATUS) error {

	// Groups
	if source.Groups != nil {
		var group GroupClaimProfile
		err := group.Initialize_From_GroupClaimProfile_STATUS(source.Groups)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_GroupClaimProfile_STATUS() to populate field Groups")
		}
		profile.Groups = &group
	} else {
		profile.Groups = nil
	}

	// Username
	if source.Username != nil {
		var username UsernameClaimProfile
		err := username.Initialize_From_UsernameClaimProfile_STATUS(source.Username)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_UsernameClaimProfile_STATUS() to populate field Username")
		}
		profile.Username = &username
	} else {
		profile.Username = nil
	}

	// No error
	return nil
}

// External Auth claim mappings profile.
// At a minimum username or groups must be defined.
type TokenClaimMappingsProfile_STATUS struct {
	// Groups: The claim mappings groups.
	Groups *GroupClaimProfile_STATUS `json:"groups,omitempty"`

	// Username: The claim mappings username.
	Username *UsernameClaimProfile_STATUS `json:"username,omitempty"`
}

var _ genruntime.FromARMConverter = &TokenClaimMappingsProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *TokenClaimMappingsProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TokenClaimMappingsProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *TokenClaimMappingsProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TokenClaimMappingsProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TokenClaimMappingsProfile_STATUS, got %T", armInput)
	}

	// Set property "Groups":
	if typedInput.Groups != nil {
		var groups1 GroupClaimProfile_STATUS
		err := groups1.PopulateFromARM(owner, *typedInput.Groups)
		if err != nil {
			return err
		}
		groups := groups1
		profile.Groups = &groups
	}

	// Set property "Username":
	if typedInput.Username != nil {
		var username1 UsernameClaimProfile_STATUS
		err := username1.PopulateFromARM(owner, *typedInput.Username)
		if err != nil {
			return err
		}
		username := username1
		profile.Username = &username
	}

	// No error
	return nil
}

// AssignProperties_From_TokenClaimMappingsProfile_STATUS populates our TokenClaimMappingsProfile_STATUS from the provided source TokenClaimMappingsProfile_STATUS
func (profile *TokenClaimMappingsProfile_STATUS) AssignProperties_From_TokenClaimMappingsProfile_STATUS(source *storage.TokenClaimMappingsProfile_STATUS) error {

	// Groups
	if source.Groups != nil {
		var group GroupClaimProfile_STATUS
		err := group.AssignProperties_From_GroupClaimProfile_STATUS(source.Groups)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_GroupClaimProfile_STATUS() to populate field Groups")
		}
		profile.Groups = &group
	} else {
		profile.Groups = nil
	}

	// Username
	if source.Username != nil {
		var username UsernameClaimProfile_STATUS
		err := username.AssignProperties_From_UsernameClaimProfile_STATUS(source.Username)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UsernameClaimProfile_STATUS() to populate field Username")
		}
		profile.Username = &username
	} else {
		profile.Username = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TokenClaimMappingsProfile_STATUS populates the provided destination TokenClaimMappingsProfile_STATUS from our TokenClaimMappingsProfile_STATUS
func (profile *TokenClaimMappingsProfile_STATUS) AssignProperties_To_TokenClaimMappingsProfile_STATUS(destination *storage.TokenClaimMappingsProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Groups
	if profile.Groups != nil {
		var group storage.GroupClaimProfile_STATUS
		err := profile.Groups.AssignProperties_To_GroupClaimProfile_STATUS(&group)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_GroupClaimProfile_STATUS() to populate field Groups")
		}
		destination.Groups = &group
	} else {
		destination.Groups = nil
	}

	// Username
	if profile.Username != nil {
		var username storage.UsernameClaimProfile_STATUS
		err := profile.Username.AssignProperties_To_UsernameClaimProfile_STATUS(&username)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UsernameClaimProfile_STATUS() to populate field Username")
		}
		destination.Username = &username
	} else {
		destination.Username = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// External Auth claim validation rule
type TokenClaimValidationRule struct {
	// RequiredClaim: The required claim rule to be applied.
	RequiredClaim *TokenRequiredClaim `json:"requiredClaim,omitempty"`

	// Type: This configures the type of the validation rule.
	// It defaults to "RequiredClaim"
	Type *TokenClaimValidationRule_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &TokenClaimValidationRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *TokenClaimValidationRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &arm.TokenClaimValidationRule{}

	// Set property "RequiredClaim":
	if rule.RequiredClaim != nil {
		requiredClaim_ARM, err := rule.RequiredClaim.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requiredClaim := *requiredClaim_ARM.(*arm.TokenRequiredClaim)
		result.RequiredClaim = &requiredClaim
	}

	// Set property "Type":
	if rule.Type != nil {
		var temp string
		temp = string(*rule.Type)
		typeVar := arm.TokenClaimValidationRule_Type(temp)
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *TokenClaimValidationRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TokenClaimValidationRule{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *TokenClaimValidationRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TokenClaimValidationRule)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TokenClaimValidationRule, got %T", armInput)
	}

	// Set property "RequiredClaim":
	if typedInput.RequiredClaim != nil {
		var requiredClaim1 TokenRequiredClaim
		err := requiredClaim1.PopulateFromARM(owner, *typedInput.RequiredClaim)
		if err != nil {
			return err
		}
		requiredClaim := requiredClaim1
		rule.RequiredClaim = &requiredClaim
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := TokenClaimValidationRule_Type(temp)
		rule.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_TokenClaimValidationRule populates our TokenClaimValidationRule from the provided source TokenClaimValidationRule
func (rule *TokenClaimValidationRule) AssignProperties_From_TokenClaimValidationRule(source *storage.TokenClaimValidationRule) error {

	// RequiredClaim
	if source.RequiredClaim != nil {
		var requiredClaim TokenRequiredClaim
		err := requiredClaim.AssignProperties_From_TokenRequiredClaim(source.RequiredClaim)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TokenRequiredClaim() to populate field RequiredClaim")
		}
		rule.RequiredClaim = &requiredClaim
	} else {
		rule.RequiredClaim = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, tokenClaimValidationRule_Type_Values)
		rule.Type = &typeTemp
	} else {
		rule.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TokenClaimValidationRule populates the provided destination TokenClaimValidationRule from our TokenClaimValidationRule
func (rule *TokenClaimValidationRule) AssignProperties_To_TokenClaimValidationRule(destination *storage.TokenClaimValidationRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RequiredClaim
	if rule.RequiredClaim != nil {
		var requiredClaim storage.TokenRequiredClaim
		err := rule.RequiredClaim.AssignProperties_To_TokenRequiredClaim(&requiredClaim)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TokenRequiredClaim() to populate field RequiredClaim")
		}
		destination.RequiredClaim = &requiredClaim
	} else {
		destination.RequiredClaim = nil
	}

	// Type
	if rule.Type != nil {
		typeVar := string(*rule.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TokenClaimValidationRule_STATUS populates our TokenClaimValidationRule from the provided source TokenClaimValidationRule_STATUS
func (rule *TokenClaimValidationRule) Initialize_From_TokenClaimValidationRule_STATUS(source *TokenClaimValidationRule_STATUS) error {

	// RequiredClaim
	if source.RequiredClaim != nil {
		var requiredClaim TokenRequiredClaim
		err := requiredClaim.Initialize_From_TokenRequiredClaim_STATUS(source.RequiredClaim)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_TokenRequiredClaim_STATUS() to populate field RequiredClaim")
		}
		rule.RequiredClaim = &requiredClaim
	} else {
		rule.RequiredClaim = nil
	}

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), tokenClaimValidationRule_Type_Values)
		rule.Type = &typeVar
	} else {
		rule.Type = nil
	}

	// No error
	return nil
}

// External Auth claim validation rule
type TokenClaimValidationRule_STATUS struct {
	// RequiredClaim: The required claim rule to be applied.
	RequiredClaim *TokenRequiredClaim_STATUS `json:"requiredClaim,omitempty"`

	// Type: This configures the type of the validation rule.
	// It defaults to "RequiredClaim"
	Type *TokenClaimValidationRule_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &TokenClaimValidationRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *TokenClaimValidationRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TokenClaimValidationRule_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *TokenClaimValidationRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TokenClaimValidationRule_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TokenClaimValidationRule_STATUS, got %T", armInput)
	}

	// Set property "RequiredClaim":
	if typedInput.RequiredClaim != nil {
		var requiredClaim1 TokenRequiredClaim_STATUS
		err := requiredClaim1.PopulateFromARM(owner, *typedInput.RequiredClaim)
		if err != nil {
			return err
		}
		requiredClaim := requiredClaim1
		rule.RequiredClaim = &requiredClaim
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := TokenClaimValidationRule_Type_STATUS(temp)
		rule.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_TokenClaimValidationRule_STATUS populates our TokenClaimValidationRule_STATUS from the provided source TokenClaimValidationRule_STATUS
func (rule *TokenClaimValidationRule_STATUS) AssignProperties_From_TokenClaimValidationRule_STATUS(source *storage.TokenClaimValidationRule_STATUS) error {

	// RequiredClaim
	if source.RequiredClaim != nil {
		var requiredClaim TokenRequiredClaim_STATUS
		err := requiredClaim.AssignProperties_From_TokenRequiredClaim_STATUS(source.RequiredClaim)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_TokenRequiredClaim_STATUS() to populate field RequiredClaim")
		}
		rule.RequiredClaim = &requiredClaim
	} else {
		rule.RequiredClaim = nil
	}

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, tokenClaimValidationRule_Type_STATUS_Values)
		rule.Type = &typeTemp
	} else {
		rule.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_TokenClaimValidationRule_STATUS populates the provided destination TokenClaimValidationRule_STATUS from our TokenClaimValidationRule_STATUS
func (rule *TokenClaimValidationRule_STATUS) AssignProperties_To_TokenClaimValidationRule_STATUS(destination *storage.TokenClaimValidationRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// RequiredClaim
	if rule.RequiredClaim != nil {
		var requiredClaim storage.TokenRequiredClaim_STATUS
		err := rule.RequiredClaim.AssignProperties_To_TokenRequiredClaim_STATUS(&requiredClaim)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_TokenRequiredClaim_STATUS() to populate field RequiredClaim")
		}
		destination.RequiredClaim = &requiredClaim
	} else {
		destination.RequiredClaim = nil
	}

	// Type
	if rule.Type != nil {
		typeVar := string(*rule.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// External Auth claim profile
// This configures how the groups of a cluster identity should be constructed
// from the claims
// in a JWT token issued by the identity provider. When
// referencing a claim, if the claim is present in the JWT token, its
// value
// must be a list of groups separated by a comma (',').
// For example - '"example"' and '"exampleOne", "exampleTwo",
// "exampleThree"' are valid claim values.
type GroupClaimProfile struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=256
	// +kubebuilder:validation:MinLength=1
	// Claim: Claim name of the external profile
	Claim *string `json:"claim,omitempty"`

	// Prefix: Prefix for the claim external profile
	// If this is specified prefixPolicy will be set to "Prefix" by default
	Prefix *string `json:"prefix,omitempty"`
}

var _ genruntime.ARMTransformer = &GroupClaimProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *GroupClaimProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.GroupClaimProfile{}

	// Set property "Claim":
	if profile.Claim != nil {
		claim := *profile.Claim
		result.Claim = &claim
	}

	// Set property "Prefix":
	if profile.Prefix != nil {
		prefix := *profile.Prefix
		result.Prefix = &prefix
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *GroupClaimProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GroupClaimProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *GroupClaimProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GroupClaimProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GroupClaimProfile, got %T", armInput)
	}

	// Set property "Claim":
	if typedInput.Claim != nil {
		claim := *typedInput.Claim
		profile.Claim = &claim
	}

	// Set property "Prefix":
	if typedInput.Prefix != nil {
		prefix := *typedInput.Prefix
		profile.Prefix = &prefix
	}

	// No error
	return nil
}

// AssignProperties_From_GroupClaimProfile populates our GroupClaimProfile from the provided source GroupClaimProfile
func (profile *GroupClaimProfile) AssignProperties_From_GroupClaimProfile(source *storage.GroupClaimProfile) error {

	// Claim
	profile.Claim = genruntime.ClonePointerToString(source.Claim)

	// Prefix
	profile.Prefix = genruntime.ClonePointerToString(source.Prefix)

	// No error
	return nil
}

// AssignProperties_To_GroupClaimProfile populates the provided destination GroupClaimProfile from our GroupClaimProfile
func (profile *GroupClaimProfile) AssignProperties_To_GroupClaimProfile(destination *storage.GroupClaimProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Claim
	destination.Claim = genruntime.ClonePointerToString(profile.Claim)

	// Prefix
	destination.Prefix = genruntime.ClonePointerToString(profile.Prefix)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_GroupClaimProfile_STATUS populates our GroupClaimProfile from the provided source GroupClaimProfile_STATUS
func (profile *GroupClaimProfile) Initialize_From_GroupClaimProfile_STATUS(source *GroupClaimProfile_STATUS) error {

	// Claim
	profile.Claim = genruntime.ClonePointerToString(source.Claim)

	// Prefix
	profile.Prefix = genruntime.ClonePointerToString(source.Prefix)

	// No error
	return nil
}

// External Auth claim profile
// This configures how the groups of a cluster identity should be constructed
// from the claims
// in a JWT token issued by the identity provider. When
// referencing a claim, if the claim is present in the JWT token, its
// value
// must be a list of groups separated by a comma (',').
// For example - '"example"' and '"exampleOne", "exampleTwo",
// "exampleThree"' are valid claim values.
type GroupClaimProfile_STATUS struct {
	// Claim: Claim name of the external profile
	Claim *string `json:"claim,omitempty"`

	// Prefix: Prefix for the claim external profile
	// If this is specified prefixPolicy will be set to "Prefix" by default
	Prefix *string `json:"prefix,omitempty"`
}

var _ genruntime.FromARMConverter = &GroupClaimProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *GroupClaimProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.GroupClaimProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *GroupClaimProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.GroupClaimProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.GroupClaimProfile_STATUS, got %T", armInput)
	}

	// Set property "Claim":
	if typedInput.Claim != nil {
		claim := *typedInput.Claim
		profile.Claim = &claim
	}

	// Set property "Prefix":
	if typedInput.Prefix != nil {
		prefix := *typedInput.Prefix
		profile.Prefix = &prefix
	}

	// No error
	return nil
}

// AssignProperties_From_GroupClaimProfile_STATUS populates our GroupClaimProfile_STATUS from the provided source GroupClaimProfile_STATUS
func (profile *GroupClaimProfile_STATUS) AssignProperties_From_GroupClaimProfile_STATUS(source *storage.GroupClaimProfile_STATUS) error {

	// Claim
	profile.Claim = genruntime.ClonePointerToString(source.Claim)

	// Prefix
	profile.Prefix = genruntime.ClonePointerToString(source.Prefix)

	// No error
	return nil
}

// AssignProperties_To_GroupClaimProfile_STATUS populates the provided destination GroupClaimProfile_STATUS from our GroupClaimProfile_STATUS
func (profile *GroupClaimProfile_STATUS) AssignProperties_To_GroupClaimProfile_STATUS(destination *storage.GroupClaimProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Claim
	destination.Claim = genruntime.ClonePointerToString(profile.Claim)

	// Prefix
	destination.Prefix = genruntime.ClonePointerToString(profile.Prefix)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"RequiredClaim"}
type TokenClaimValidationRule_Type string

const TokenClaimValidationRule_Type_RequiredClaim = TokenClaimValidationRule_Type("RequiredClaim")

// Mapping from string to TokenClaimValidationRule_Type
var tokenClaimValidationRule_Type_Values = map[string]TokenClaimValidationRule_Type{
	"requiredclaim": TokenClaimValidationRule_Type_RequiredClaim,
}

type TokenClaimValidationRule_Type_STATUS string

const TokenClaimValidationRule_Type_STATUS_RequiredClaim = TokenClaimValidationRule_Type_STATUS("RequiredClaim")

// Mapping from string to TokenClaimValidationRule_Type_STATUS
var tokenClaimValidationRule_Type_STATUS_Values = map[string]TokenClaimValidationRule_Type_STATUS{
	"requiredclaim": TokenClaimValidationRule_Type_STATUS_RequiredClaim,
}

// Token required claim validation rule.
type TokenRequiredClaim struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MinLength=1
	// Claim: Claim name for the validation profile
	// claim is a required field that configures the name of the required claim.
	Claim *string `json:"claim,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MinLength=1
	// RequiredValue: Required value
	// requiredValue is a required field that configures the value that 'claim' must
	// have when taken from the incoming JWT claims.
	// If the value in the JWT claims does not match, the token
	// will be rejected for authentication.
	RequiredValue *string `json:"requiredValue,omitempty"`
}

var _ genruntime.ARMTransformer = &TokenRequiredClaim{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (claim *TokenRequiredClaim) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if claim == nil {
		return nil, nil
	}
	result := &arm.TokenRequiredClaim{}

	// Set property "Claim":
	if claim.Claim != nil {
		claim1 := *claim.Claim
		result.Claim = &claim1
	}

	// Set property "RequiredValue":
	if claim.RequiredValue != nil {
		requiredValue := *claim.RequiredValue
		result.RequiredValue = &requiredValue
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (claim *TokenRequiredClaim) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TokenRequiredClaim{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (claim *TokenRequiredClaim) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TokenRequiredClaim)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TokenRequiredClaim, got %T", armInput)
	}

	// Set property "Claim":
	if typedInput.Claim != nil {
		claim1 := *typedInput.Claim
		claim.Claim = &claim1
	}

	// Set property "RequiredValue":
	if typedInput.RequiredValue != nil {
		requiredValue := *typedInput.RequiredValue
		claim.RequiredValue = &requiredValue
	}

	// No error
	return nil
}

// AssignProperties_From_TokenRequiredClaim populates our TokenRequiredClaim from the provided source TokenRequiredClaim
func (claim *TokenRequiredClaim) AssignProperties_From_TokenRequiredClaim(source *storage.TokenRequiredClaim) error {

	// Claim
	claim.Claim = genruntime.ClonePointerToString(source.Claim)

	// RequiredValue
	claim.RequiredValue = genruntime.ClonePointerToString(source.RequiredValue)

	// No error
	return nil
}

// AssignProperties_To_TokenRequiredClaim populates the provided destination TokenRequiredClaim from our TokenRequiredClaim
func (claim *TokenRequiredClaim) AssignProperties_To_TokenRequiredClaim(destination *storage.TokenRequiredClaim) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Claim
	destination.Claim = genruntime.ClonePointerToString(claim.Claim)

	// RequiredValue
	destination.RequiredValue = genruntime.ClonePointerToString(claim.RequiredValue)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_TokenRequiredClaim_STATUS populates our TokenRequiredClaim from the provided source TokenRequiredClaim_STATUS
func (claim *TokenRequiredClaim) Initialize_From_TokenRequiredClaim_STATUS(source *TokenRequiredClaim_STATUS) error {

	// Claim
	claim.Claim = genruntime.ClonePointerToString(source.Claim)

	// RequiredValue
	claim.RequiredValue = genruntime.ClonePointerToString(source.RequiredValue)

	// No error
	return nil
}

// Token required claim validation rule.
type TokenRequiredClaim_STATUS struct {
	// Claim: Claim name for the validation profile
	// claim is a required field that configures the name of the required claim.
	Claim *string `json:"claim,omitempty"`

	// RequiredValue: Required value
	// requiredValue is a required field that configures the value that 'claim' must
	// have when taken from the incoming JWT claims.
	// If the value in the JWT claims does not match, the token
	// will be rejected for authentication.
	RequiredValue *string `json:"requiredValue,omitempty"`
}

var _ genruntime.FromARMConverter = &TokenRequiredClaim_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (claim *TokenRequiredClaim_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.TokenRequiredClaim_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (claim *TokenRequiredClaim_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.TokenRequiredClaim_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.TokenRequiredClaim_STATUS, got %T", armInput)
	}

	// Set property "Claim":
	if typedInput.Claim != nil {
		claim1 := *typedInput.Claim
		claim.Claim = &claim1
	}

	// Set property "RequiredValue":
	if typedInput.RequiredValue != nil {
		requiredValue := *typedInput.RequiredValue
		claim.RequiredValue = &requiredValue
	}

	// No error
	return nil
}

// AssignProperties_From_TokenRequiredClaim_STATUS populates our TokenRequiredClaim_STATUS from the provided source TokenRequiredClaim_STATUS
func (claim *TokenRequiredClaim_STATUS) AssignProperties_From_TokenRequiredClaim_STATUS(source *storage.TokenRequiredClaim_STATUS) error {

	// Claim
	claim.Claim = genruntime.ClonePointerToString(source.Claim)

	// RequiredValue
	claim.RequiredValue = genruntime.ClonePointerToString(source.RequiredValue)

	// No error
	return nil
}

// AssignProperties_To_TokenRequiredClaim_STATUS populates the provided destination TokenRequiredClaim_STATUS from our TokenRequiredClaim_STATUS
func (claim *TokenRequiredClaim_STATUS) AssignProperties_To_TokenRequiredClaim_STATUS(destination *storage.TokenRequiredClaim_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Claim
	destination.Claim = genruntime.ClonePointerToString(claim.Claim)

	// RequiredValue
	destination.RequiredValue = genruntime.ClonePointerToString(claim.RequiredValue)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// External Auth claim profile
// This configures how the username of a cluster identity should be constructed
// from the claims
// in a JWT token issued by the identity provider.
type UsernameClaimProfile struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=256
	// +kubebuilder:validation:MinLength=1
	// Claim: Claim name of the external profile
	Claim *string `json:"claim,omitempty"`

	// Prefix: Prefix for the claim external profile
	// Must be set when the prefixPolicy field is set to 'Prefix' and must be unset
	// otherwise.
	Prefix *string `json:"prefix,omitempty"`

	// PrefixPolicy: Prefix policy is an optional field that configures how a prefix should be
	// applied to the value of the JWT claim specified in the 'claim' field.
	// Allowed values are 'Prefix', 'NoPrefix', and 'None'.
	// When set to 'Prefix', the value specified in the prefix field will be
	// prepended to the value of the JWT claim.
	// The prefix field must be set when prefixPolicy is 'Prefix'.
	// When set to 'NoPrefix', no prefix will be prepended to the value
	// of the JWT claim.
	// When set to 'None', this means no opinion and the platform is left to choose
	// any prefixes that are applied which is subject to change over time.
	// Currently, the platform prepends `{issuerURL}#` to the value of the JWT claim
	// when the claim is not 'email'.
	// As an example, consider the following scenario:
	// `prefix` is unset, `issuerURL` is set to `https://myoidc.tld`,
	// the JWT claims include "username":"userA" and "email":"userA
	PrefixPolicy *UsernameClaimPrefixPolicy `json:"prefixPolicy,omitempty"`
}

var _ genruntime.ARMTransformer = &UsernameClaimProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *UsernameClaimProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.UsernameClaimProfile{}

	// Set property "Claim":
	if profile.Claim != nil {
		claim := *profile.Claim
		result.Claim = &claim
	}

	// Set property "Prefix":
	if profile.Prefix != nil {
		prefix := *profile.Prefix
		result.Prefix = &prefix
	}

	// Set property "PrefixPolicy":
	if profile.PrefixPolicy != nil {
		var temp string
		temp = string(*profile.PrefixPolicy)
		prefixPolicy := arm.UsernameClaimPrefixPolicy(temp)
		result.PrefixPolicy = &prefixPolicy
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *UsernameClaimProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UsernameClaimProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *UsernameClaimProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UsernameClaimProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UsernameClaimProfile, got %T", armInput)
	}

	// Set property "Claim":
	if typedInput.Claim != nil {
		claim := *typedInput.Claim
		profile.Claim = &claim
	}

	// Set property "Prefix":
	if typedInput.Prefix != nil {
		prefix := *typedInput.Prefix
		profile.Prefix = &prefix
	}

	// Set property "PrefixPolicy":
	if typedInput.PrefixPolicy != nil {
		var temp string
		temp = string(*typedInput.PrefixPolicy)
		prefixPolicy := UsernameClaimPrefixPolicy(temp)
		profile.PrefixPolicy = &prefixPolicy
	}

	// No error
	return nil
}

// AssignProperties_From_UsernameClaimProfile populates our UsernameClaimProfile from the provided source UsernameClaimProfile
func (profile *UsernameClaimProfile) AssignProperties_From_UsernameClaimProfile(source *storage.UsernameClaimProfile) error {

	// Claim
	profile.Claim = genruntime.ClonePointerToString(source.Claim)

	// Prefix
	profile.Prefix = genruntime.ClonePointerToString(source.Prefix)

	// PrefixPolicy
	if source.PrefixPolicy != nil {
		prefixPolicy := *source.PrefixPolicy
		prefixPolicyTemp := genruntime.ToEnum(prefixPolicy, usernameClaimPrefixPolicy_Values)
		profile.PrefixPolicy = &prefixPolicyTemp
	} else {
		profile.PrefixPolicy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UsernameClaimProfile populates the provided destination UsernameClaimProfile from our UsernameClaimProfile
func (profile *UsernameClaimProfile) AssignProperties_To_UsernameClaimProfile(destination *storage.UsernameClaimProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Claim
	destination.Claim = genruntime.ClonePointerToString(profile.Claim)

	// Prefix
	destination.Prefix = genruntime.ClonePointerToString(profile.Prefix)

	// PrefixPolicy
	if profile.PrefixPolicy != nil {
		prefixPolicy := string(*profile.PrefixPolicy)
		destination.PrefixPolicy = &prefixPolicy
	} else {
		destination.PrefixPolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UsernameClaimProfile_STATUS populates our UsernameClaimProfile from the provided source UsernameClaimProfile_STATUS
func (profile *UsernameClaimProfile) Initialize_From_UsernameClaimProfile_STATUS(source *UsernameClaimProfile_STATUS) error {

	// Claim
	profile.Claim = genruntime.ClonePointerToString(source.Claim)

	// Prefix
	profile.Prefix = genruntime.ClonePointerToString(source.Prefix)

	// PrefixPolicy
	if source.PrefixPolicy != nil {
		prefixPolicy := genruntime.ToEnum(string(*source.PrefixPolicy), usernameClaimPrefixPolicy_Values)
		profile.PrefixPolicy = &prefixPolicy
	} else {
		profile.PrefixPolicy = nil
	}

	// No error
	return nil
}

// External Auth claim profile
// This configures how the username of a cluster identity should be constructed
// from the claims
// in a JWT token issued by the identity provider.
type UsernameClaimProfile_STATUS struct {
	// Claim: Claim name of the external profile
	Claim *string `json:"claim,omitempty"`

	// Prefix: Prefix for the claim external profile
	// Must be set when the prefixPolicy field is set to 'Prefix' and must be unset
	// otherwise.
	Prefix *string `json:"prefix,omitempty"`

	// PrefixPolicy: Prefix policy is an optional field that configures how a prefix should be
	// applied to the value of the JWT claim specified in the 'claim' field.
	// Allowed values are 'Prefix', 'NoPrefix', and 'None'.
	// When set to 'Prefix', the value specified in the prefix field will be
	// prepended to the value of the JWT claim.
	// The prefix field must be set when prefixPolicy is 'Prefix'.
	// When set to 'NoPrefix', no prefix will be prepended to the value
	// of the JWT claim.
	// When set to 'None', this means no opinion and the platform is left to choose
	// any prefixes that are applied which is subject to change over time.
	// Currently, the platform prepends `{issuerURL}#` to the value of the JWT claim
	// when the claim is not 'email'.
	// As an example, consider the following scenario:
	// `prefix` is unset, `issuerURL` is set to `https://myoidc.tld`,
	// the JWT claims include "username":"userA" and "email":"userA
	PrefixPolicy *UsernameClaimPrefixPolicy_STATUS `json:"prefixPolicy,omitempty"`
}

var _ genruntime.FromARMConverter = &UsernameClaimProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *UsernameClaimProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UsernameClaimProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *UsernameClaimProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UsernameClaimProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UsernameClaimProfile_STATUS, got %T", armInput)
	}

	// Set property "Claim":
	if typedInput.Claim != nil {
		claim := *typedInput.Claim
		profile.Claim = &claim
	}

	// Set property "Prefix":
	if typedInput.Prefix != nil {
		prefix := *typedInput.Prefix
		profile.Prefix = &prefix
	}

	// Set property "PrefixPolicy":
	if typedInput.PrefixPolicy != nil {
		var temp string
		temp = string(*typedInput.PrefixPolicy)
		prefixPolicy := UsernameClaimPrefixPolicy_STATUS(temp)
		profile.PrefixPolicy = &prefixPolicy
	}

	// No error
	return nil
}

// AssignProperties_From_UsernameClaimProfile_STATUS populates our UsernameClaimProfile_STATUS from the provided source UsernameClaimProfile_STATUS
func (profile *UsernameClaimProfile_STATUS) AssignProperties_From_UsernameClaimProfile_STATUS(source *storage.UsernameClaimProfile_STATUS) error {

	// Claim
	profile.Claim = genruntime.ClonePointerToString(source.Claim)

	// Prefix
	profile.Prefix = genruntime.ClonePointerToString(source.Prefix)

	// PrefixPolicy
	if source.PrefixPolicy != nil {
		prefixPolicy := *source.PrefixPolicy
		prefixPolicyTemp := genruntime.ToEnum(prefixPolicy, usernameClaimPrefixPolicy_STATUS_Values)
		profile.PrefixPolicy = &prefixPolicyTemp
	} else {
		profile.PrefixPolicy = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UsernameClaimProfile_STATUS populates the provided destination UsernameClaimProfile_STATUS from our UsernameClaimProfile_STATUS
func (profile *UsernameClaimProfile_STATUS) AssignProperties_To_UsernameClaimProfile_STATUS(destination *storage.UsernameClaimProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Claim
	destination.Claim = genruntime.ClonePointerToString(profile.Claim)

	// Prefix
	destination.Prefix = genruntime.ClonePointerToString(profile.Prefix)

	// PrefixPolicy
	if profile.PrefixPolicy != nil {
		prefixPolicy := string(*profile.PrefixPolicy)
		destination.PrefixPolicy = &prefixPolicy
	} else {
		destination.PrefixPolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// UsernameClaimPrefixPolicy configures whether to add a prefix to a JWT claim.
// +kubebuilder:validation:Enum={"NoPrefix","None","Prefix"}
type UsernameClaimPrefixPolicy string

const (
	UsernameClaimPrefixPolicy_NoPrefix = UsernameClaimPrefixPolicy("NoPrefix")
	UsernameClaimPrefixPolicy_None     = UsernameClaimPrefixPolicy("None")
	UsernameClaimPrefixPolicy_Prefix   = UsernameClaimPrefixPolicy("Prefix")
)

// Mapping from string to UsernameClaimPrefixPolicy
var usernameClaimPrefixPolicy_Values = map[string]UsernameClaimPrefixPolicy{
	"noprefix": UsernameClaimPrefixPolicy_NoPrefix,
	"none":     UsernameClaimPrefixPolicy_None,
	"prefix":   UsernameClaimPrefixPolicy_Prefix,
}

// UsernameClaimPrefixPolicy configures whether to add a prefix to a JWT claim.
type UsernameClaimPrefixPolicy_STATUS string

const (
	UsernameClaimPrefixPolicy_STATUS_NoPrefix = UsernameClaimPrefixPolicy_STATUS("NoPrefix")
	UsernameClaimPrefixPolicy_STATUS_None     = UsernameClaimPrefixPolicy_STATUS("None")
	UsernameClaimPrefixPolicy_STATUS_Prefix   = UsernameClaimPrefixPolicy_STATUS("Prefix")
)

// Mapping from string to UsernameClaimPrefixPolicy_STATUS
var usernameClaimPrefixPolicy_STATUS_Values = map[string]UsernameClaimPrefixPolicy_STATUS{
	"noprefix": UsernameClaimPrefixPolicy_STATUS_NoPrefix,
	"none":     UsernameClaimPrefixPolicy_STATUS_None,
	"prefix":   UsernameClaimPrefixPolicy_STATUS_Prefix,
}

func init() {
	SchemeBuilder.Register(&HcpOpenShiftClustersExternalAuth{}, &HcpOpenShiftClustersExternalAuthList{})
}
