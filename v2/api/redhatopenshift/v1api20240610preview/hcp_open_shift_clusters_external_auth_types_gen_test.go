// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240610preview

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/redhatopenshift/v1api20240610preview/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ExternalAuthClaimProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExternalAuthClaimProfile to ExternalAuthClaimProfile via AssignProperties_To_ExternalAuthClaimProfile & AssignProperties_From_ExternalAuthClaimProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForExternalAuthClaimProfile, ExternalAuthClaimProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExternalAuthClaimProfile tests if a specific instance of ExternalAuthClaimProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExternalAuthClaimProfile(subject ExternalAuthClaimProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExternalAuthClaimProfile
	err := copied.AssignProperties_To_ExternalAuthClaimProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExternalAuthClaimProfile
	err = actual.AssignProperties_From_ExternalAuthClaimProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExternalAuthClaimProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExternalAuthClaimProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExternalAuthClaimProfile, ExternalAuthClaimProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExternalAuthClaimProfile runs a test to see if a specific instance of ExternalAuthClaimProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForExternalAuthClaimProfile(subject ExternalAuthClaimProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExternalAuthClaimProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExternalAuthClaimProfile instances for property testing - lazily instantiated by
// ExternalAuthClaimProfileGenerator()
var externalAuthClaimProfileGenerator gopter.Gen

// ExternalAuthClaimProfileGenerator returns a generator of ExternalAuthClaimProfile instances for property testing.
func ExternalAuthClaimProfileGenerator() gopter.Gen {
	if externalAuthClaimProfileGenerator != nil {
		return externalAuthClaimProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExternalAuthClaimProfile(generators)
	externalAuthClaimProfileGenerator = gen.Struct(reflect.TypeOf(ExternalAuthClaimProfile{}), generators)

	return externalAuthClaimProfileGenerator
}

// AddRelatedPropertyGeneratorsForExternalAuthClaimProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExternalAuthClaimProfile(gens map[string]gopter.Gen) {
	gens["Mappings"] = gen.PtrOf(TokenClaimMappingsProfileGenerator())
	gens["ValidationRules"] = gen.SliceOf(TokenClaimValidationRuleGenerator())
}

func Test_ExternalAuthClaimProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExternalAuthClaimProfile_STATUS to ExternalAuthClaimProfile_STATUS via AssignProperties_To_ExternalAuthClaimProfile_STATUS & AssignProperties_From_ExternalAuthClaimProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExternalAuthClaimProfile_STATUS, ExternalAuthClaimProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExternalAuthClaimProfile_STATUS tests if a specific instance of ExternalAuthClaimProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExternalAuthClaimProfile_STATUS(subject ExternalAuthClaimProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExternalAuthClaimProfile_STATUS
	err := copied.AssignProperties_To_ExternalAuthClaimProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExternalAuthClaimProfile_STATUS
	err = actual.AssignProperties_From_ExternalAuthClaimProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExternalAuthClaimProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExternalAuthClaimProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExternalAuthClaimProfile_STATUS, ExternalAuthClaimProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExternalAuthClaimProfile_STATUS runs a test to see if a specific instance of ExternalAuthClaimProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExternalAuthClaimProfile_STATUS(subject ExternalAuthClaimProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExternalAuthClaimProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExternalAuthClaimProfile_STATUS instances for property testing - lazily instantiated by
// ExternalAuthClaimProfile_STATUSGenerator()
var externalAuthClaimProfile_STATUSGenerator gopter.Gen

// ExternalAuthClaimProfile_STATUSGenerator returns a generator of ExternalAuthClaimProfile_STATUS instances for property testing.
func ExternalAuthClaimProfile_STATUSGenerator() gopter.Gen {
	if externalAuthClaimProfile_STATUSGenerator != nil {
		return externalAuthClaimProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExternalAuthClaimProfile_STATUS(generators)
	externalAuthClaimProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(ExternalAuthClaimProfile_STATUS{}), generators)

	return externalAuthClaimProfile_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForExternalAuthClaimProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExternalAuthClaimProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Mappings"] = gen.PtrOf(TokenClaimMappingsProfile_STATUSGenerator())
	gens["ValidationRules"] = gen.SliceOf(TokenClaimValidationRule_STATUSGenerator())
}

func Test_ExternalAuthClientComponentProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExternalAuthClientComponentProfile to ExternalAuthClientComponentProfile via AssignProperties_To_ExternalAuthClientComponentProfile & AssignProperties_From_ExternalAuthClientComponentProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForExternalAuthClientComponentProfile, ExternalAuthClientComponentProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExternalAuthClientComponentProfile tests if a specific instance of ExternalAuthClientComponentProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExternalAuthClientComponentProfile(subject ExternalAuthClientComponentProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExternalAuthClientComponentProfile
	err := copied.AssignProperties_To_ExternalAuthClientComponentProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExternalAuthClientComponentProfile
	err = actual.AssignProperties_From_ExternalAuthClientComponentProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExternalAuthClientComponentProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExternalAuthClientComponentProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExternalAuthClientComponentProfile, ExternalAuthClientComponentProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExternalAuthClientComponentProfile runs a test to see if a specific instance of ExternalAuthClientComponentProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForExternalAuthClientComponentProfile(subject ExternalAuthClientComponentProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExternalAuthClientComponentProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExternalAuthClientComponentProfile instances for property testing - lazily instantiated by
// ExternalAuthClientComponentProfileGenerator()
var externalAuthClientComponentProfileGenerator gopter.Gen

// ExternalAuthClientComponentProfileGenerator returns a generator of ExternalAuthClientComponentProfile instances for property testing.
func ExternalAuthClientComponentProfileGenerator() gopter.Gen {
	if externalAuthClientComponentProfileGenerator != nil {
		return externalAuthClientComponentProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExternalAuthClientComponentProfile(generators)
	externalAuthClientComponentProfileGenerator = gen.Struct(reflect.TypeOf(ExternalAuthClientComponentProfile{}), generators)

	return externalAuthClientComponentProfileGenerator
}

// AddIndependentPropertyGeneratorsForExternalAuthClientComponentProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExternalAuthClientComponentProfile(gens map[string]gopter.Gen) {
	gens["AuthClientNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExternalAuthClientComponentProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExternalAuthClientComponentProfile_STATUS to ExternalAuthClientComponentProfile_STATUS via AssignProperties_To_ExternalAuthClientComponentProfile_STATUS & AssignProperties_From_ExternalAuthClientComponentProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExternalAuthClientComponentProfile_STATUS, ExternalAuthClientComponentProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExternalAuthClientComponentProfile_STATUS tests if a specific instance of ExternalAuthClientComponentProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExternalAuthClientComponentProfile_STATUS(subject ExternalAuthClientComponentProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExternalAuthClientComponentProfile_STATUS
	err := copied.AssignProperties_To_ExternalAuthClientComponentProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExternalAuthClientComponentProfile_STATUS
	err = actual.AssignProperties_From_ExternalAuthClientComponentProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExternalAuthClientComponentProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExternalAuthClientComponentProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExternalAuthClientComponentProfile_STATUS, ExternalAuthClientComponentProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExternalAuthClientComponentProfile_STATUS runs a test to see if a specific instance of ExternalAuthClientComponentProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExternalAuthClientComponentProfile_STATUS(subject ExternalAuthClientComponentProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExternalAuthClientComponentProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExternalAuthClientComponentProfile_STATUS instances for property testing - lazily instantiated by
// ExternalAuthClientComponentProfile_STATUSGenerator()
var externalAuthClientComponentProfile_STATUSGenerator gopter.Gen

// ExternalAuthClientComponentProfile_STATUSGenerator returns a generator of ExternalAuthClientComponentProfile_STATUS instances for property testing.
func ExternalAuthClientComponentProfile_STATUSGenerator() gopter.Gen {
	if externalAuthClientComponentProfile_STATUSGenerator != nil {
		return externalAuthClientComponentProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExternalAuthClientComponentProfile_STATUS(generators)
	externalAuthClientComponentProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(ExternalAuthClientComponentProfile_STATUS{}), generators)

	return externalAuthClientComponentProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExternalAuthClientComponentProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExternalAuthClientComponentProfile_STATUS(gens map[string]gopter.Gen) {
	gens["AuthClientNamespace"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExternalAuthClientProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExternalAuthClientProfile to ExternalAuthClientProfile via AssignProperties_To_ExternalAuthClientProfile & AssignProperties_From_ExternalAuthClientProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForExternalAuthClientProfile, ExternalAuthClientProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExternalAuthClientProfile tests if a specific instance of ExternalAuthClientProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExternalAuthClientProfile(subject ExternalAuthClientProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExternalAuthClientProfile
	err := copied.AssignProperties_To_ExternalAuthClientProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExternalAuthClientProfile
	err = actual.AssignProperties_From_ExternalAuthClientProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExternalAuthClientProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExternalAuthClientProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExternalAuthClientProfile, ExternalAuthClientProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExternalAuthClientProfile runs a test to see if a specific instance of ExternalAuthClientProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForExternalAuthClientProfile(subject ExternalAuthClientProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExternalAuthClientProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExternalAuthClientProfile instances for property testing - lazily instantiated by
// ExternalAuthClientProfileGenerator()
var externalAuthClientProfileGenerator gopter.Gen

// ExternalAuthClientProfileGenerator returns a generator of ExternalAuthClientProfile instances for property testing.
// We first initialize externalAuthClientProfileGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ExternalAuthClientProfileGenerator() gopter.Gen {
	if externalAuthClientProfileGenerator != nil {
		return externalAuthClientProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExternalAuthClientProfile(generators)
	externalAuthClientProfileGenerator = gen.Struct(reflect.TypeOf(ExternalAuthClientProfile{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExternalAuthClientProfile(generators)
	AddRelatedPropertyGeneratorsForExternalAuthClientProfile(generators)
	externalAuthClientProfileGenerator = gen.Struct(reflect.TypeOf(ExternalAuthClientProfile{}), generators)

	return externalAuthClientProfileGenerator
}

// AddIndependentPropertyGeneratorsForExternalAuthClientProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExternalAuthClientProfile(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ExtraScopes"] = gen.SliceOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExternalAuthClientType_Confidential, ExternalAuthClientType_Public))
}

// AddRelatedPropertyGeneratorsForExternalAuthClientProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExternalAuthClientProfile(gens map[string]gopter.Gen) {
	gens["Component"] = gen.PtrOf(ExternalAuthClientComponentProfileGenerator())
}

func Test_ExternalAuthClientProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExternalAuthClientProfile_STATUS to ExternalAuthClientProfile_STATUS via AssignProperties_To_ExternalAuthClientProfile_STATUS & AssignProperties_From_ExternalAuthClientProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExternalAuthClientProfile_STATUS, ExternalAuthClientProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExternalAuthClientProfile_STATUS tests if a specific instance of ExternalAuthClientProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExternalAuthClientProfile_STATUS(subject ExternalAuthClientProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExternalAuthClientProfile_STATUS
	err := copied.AssignProperties_To_ExternalAuthClientProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExternalAuthClientProfile_STATUS
	err = actual.AssignProperties_From_ExternalAuthClientProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExternalAuthClientProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExternalAuthClientProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExternalAuthClientProfile_STATUS, ExternalAuthClientProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExternalAuthClientProfile_STATUS runs a test to see if a specific instance of ExternalAuthClientProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExternalAuthClientProfile_STATUS(subject ExternalAuthClientProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExternalAuthClientProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExternalAuthClientProfile_STATUS instances for property testing - lazily instantiated by
// ExternalAuthClientProfile_STATUSGenerator()
var externalAuthClientProfile_STATUSGenerator gopter.Gen

// ExternalAuthClientProfile_STATUSGenerator returns a generator of ExternalAuthClientProfile_STATUS instances for property testing.
// We first initialize externalAuthClientProfile_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ExternalAuthClientProfile_STATUSGenerator() gopter.Gen {
	if externalAuthClientProfile_STATUSGenerator != nil {
		return externalAuthClientProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExternalAuthClientProfile_STATUS(generators)
	externalAuthClientProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(ExternalAuthClientProfile_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExternalAuthClientProfile_STATUS(generators)
	AddRelatedPropertyGeneratorsForExternalAuthClientProfile_STATUS(generators)
	externalAuthClientProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(ExternalAuthClientProfile_STATUS{}), generators)

	return externalAuthClientProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExternalAuthClientProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExternalAuthClientProfile_STATUS(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ExtraScopes"] = gen.SliceOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExternalAuthClientType_STATUS_Confidential, ExternalAuthClientType_STATUS_Public))
}

// AddRelatedPropertyGeneratorsForExternalAuthClientProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExternalAuthClientProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Component"] = gen.PtrOf(ExternalAuthClientComponentProfile_STATUSGenerator())
}

func Test_ExternalAuthCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExternalAuthCondition_STATUS to ExternalAuthCondition_STATUS via AssignProperties_To_ExternalAuthCondition_STATUS & AssignProperties_From_ExternalAuthCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExternalAuthCondition_STATUS, ExternalAuthCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExternalAuthCondition_STATUS tests if a specific instance of ExternalAuthCondition_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExternalAuthCondition_STATUS(subject ExternalAuthCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExternalAuthCondition_STATUS
	err := copied.AssignProperties_To_ExternalAuthCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExternalAuthCondition_STATUS
	err = actual.AssignProperties_From_ExternalAuthCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExternalAuthCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExternalAuthCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExternalAuthCondition_STATUS, ExternalAuthCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExternalAuthCondition_STATUS runs a test to see if a specific instance of ExternalAuthCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExternalAuthCondition_STATUS(subject ExternalAuthCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExternalAuthCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExternalAuthCondition_STATUS instances for property testing - lazily instantiated by
// ExternalAuthCondition_STATUSGenerator()
var externalAuthCondition_STATUSGenerator gopter.Gen

// ExternalAuthCondition_STATUSGenerator returns a generator of ExternalAuthCondition_STATUS instances for property testing.
func ExternalAuthCondition_STATUSGenerator() gopter.Gen {
	if externalAuthCondition_STATUSGenerator != nil {
		return externalAuthCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExternalAuthCondition_STATUS(generators)
	externalAuthCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(ExternalAuthCondition_STATUS{}), generators)

	return externalAuthCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExternalAuthCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExternalAuthCondition_STATUS(gens map[string]gopter.Gen) {
	gens["LastTransitionTime"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Reason"] = gen.PtrOf(gen.AlphaString())
	gens["Status"] = gen.PtrOf(gen.OneConstOf(StatusType_STATUS_False, StatusType_STATUS_True, StatusType_STATUS_Unknown))
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExternalAuthConditionType_STATUS_Available, ExternalAuthConditionType_STATUS_Degraded, ExternalAuthConditionType_STATUS_Progressing))
}

func Test_ExternalAuthProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExternalAuthProperties to ExternalAuthProperties via AssignProperties_To_ExternalAuthProperties & AssignProperties_From_ExternalAuthProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForExternalAuthProperties, ExternalAuthPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExternalAuthProperties tests if a specific instance of ExternalAuthProperties can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExternalAuthProperties(subject ExternalAuthProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExternalAuthProperties
	err := copied.AssignProperties_To_ExternalAuthProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExternalAuthProperties
	err = actual.AssignProperties_From_ExternalAuthProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExternalAuthProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExternalAuthProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExternalAuthProperties, ExternalAuthPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExternalAuthProperties runs a test to see if a specific instance of ExternalAuthProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForExternalAuthProperties(subject ExternalAuthProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExternalAuthProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExternalAuthProperties instances for property testing - lazily instantiated by
// ExternalAuthPropertiesGenerator()
var externalAuthPropertiesGenerator gopter.Gen

// ExternalAuthPropertiesGenerator returns a generator of ExternalAuthProperties instances for property testing.
func ExternalAuthPropertiesGenerator() gopter.Gen {
	if externalAuthPropertiesGenerator != nil {
		return externalAuthPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForExternalAuthProperties(generators)
	externalAuthPropertiesGenerator = gen.Struct(reflect.TypeOf(ExternalAuthProperties{}), generators)

	return externalAuthPropertiesGenerator
}

// AddRelatedPropertyGeneratorsForExternalAuthProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExternalAuthProperties(gens map[string]gopter.Gen) {
	gens["Claim"] = gen.PtrOf(ExternalAuthClaimProfileGenerator())
	gens["Clients"] = gen.SliceOf(ExternalAuthClientProfileGenerator())
	gens["Issuer"] = gen.PtrOf(TokenIssuerProfileGenerator())
}

func Test_ExternalAuthProperties_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExternalAuthProperties_STATUS to ExternalAuthProperties_STATUS via AssignProperties_To_ExternalAuthProperties_STATUS & AssignProperties_From_ExternalAuthProperties_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForExternalAuthProperties_STATUS, ExternalAuthProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExternalAuthProperties_STATUS tests if a specific instance of ExternalAuthProperties_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForExternalAuthProperties_STATUS(subject ExternalAuthProperties_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.ExternalAuthProperties_STATUS
	err := copied.AssignProperties_To_ExternalAuthProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExternalAuthProperties_STATUS
	err = actual.AssignProperties_From_ExternalAuthProperties_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExternalAuthProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExternalAuthProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExternalAuthProperties_STATUS, ExternalAuthProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExternalAuthProperties_STATUS runs a test to see if a specific instance of ExternalAuthProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForExternalAuthProperties_STATUS(subject ExternalAuthProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExternalAuthProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExternalAuthProperties_STATUS instances for property testing - lazily instantiated by
// ExternalAuthProperties_STATUSGenerator()
var externalAuthProperties_STATUSGenerator gopter.Gen

// ExternalAuthProperties_STATUSGenerator returns a generator of ExternalAuthProperties_STATUS instances for property testing.
// We first initialize externalAuthProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ExternalAuthProperties_STATUSGenerator() gopter.Gen {
	if externalAuthProperties_STATUSGenerator != nil {
		return externalAuthProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExternalAuthProperties_STATUS(generators)
	externalAuthProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ExternalAuthProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExternalAuthProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForExternalAuthProperties_STATUS(generators)
	externalAuthProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ExternalAuthProperties_STATUS{}), generators)

	return externalAuthProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForExternalAuthProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExternalAuthProperties_STATUS(gens map[string]gopter.Gen) {
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		ExternalAuthProvisioningState_STATUS_Accepted,
		ExternalAuthProvisioningState_STATUS_AwaitingSecret,
		ExternalAuthProvisioningState_STATUS_Canceled,
		ExternalAuthProvisioningState_STATUS_Deleting,
		ExternalAuthProvisioningState_STATUS_Failed,
		ExternalAuthProvisioningState_STATUS_Provisioning,
		ExternalAuthProvisioningState_STATUS_Succeeded,
		ExternalAuthProvisioningState_STATUS_Updating))
}

// AddRelatedPropertyGeneratorsForExternalAuthProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForExternalAuthProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Claim"] = gen.PtrOf(ExternalAuthClaimProfile_STATUSGenerator())
	gens["Clients"] = gen.SliceOf(ExternalAuthClientProfile_STATUSGenerator())
	gens["Condition"] = gen.PtrOf(ExternalAuthCondition_STATUSGenerator())
	gens["Issuer"] = gen.PtrOf(TokenIssuerProfile_STATUSGenerator())
}

func Test_GroupClaimProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GroupClaimProfile to GroupClaimProfile via AssignProperties_To_GroupClaimProfile & AssignProperties_From_GroupClaimProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForGroupClaimProfile, GroupClaimProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGroupClaimProfile tests if a specific instance of GroupClaimProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForGroupClaimProfile(subject GroupClaimProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.GroupClaimProfile
	err := copied.AssignProperties_To_GroupClaimProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GroupClaimProfile
	err = actual.AssignProperties_From_GroupClaimProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GroupClaimProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GroupClaimProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGroupClaimProfile, GroupClaimProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGroupClaimProfile runs a test to see if a specific instance of GroupClaimProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForGroupClaimProfile(subject GroupClaimProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GroupClaimProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GroupClaimProfile instances for property testing - lazily instantiated by GroupClaimProfileGenerator()
var groupClaimProfileGenerator gopter.Gen

// GroupClaimProfileGenerator returns a generator of GroupClaimProfile instances for property testing.
func GroupClaimProfileGenerator() gopter.Gen {
	if groupClaimProfileGenerator != nil {
		return groupClaimProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGroupClaimProfile(generators)
	groupClaimProfileGenerator = gen.Struct(reflect.TypeOf(GroupClaimProfile{}), generators)

	return groupClaimProfileGenerator
}

// AddIndependentPropertyGeneratorsForGroupClaimProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGroupClaimProfile(gens map[string]gopter.Gen) {
	gens["Claim"] = gen.PtrOf(gen.AlphaString())
	gens["Prefix"] = gen.PtrOf(gen.AlphaString())
}

func Test_GroupClaimProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GroupClaimProfile_STATUS to GroupClaimProfile_STATUS via AssignProperties_To_GroupClaimProfile_STATUS & AssignProperties_From_GroupClaimProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForGroupClaimProfile_STATUS, GroupClaimProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGroupClaimProfile_STATUS tests if a specific instance of GroupClaimProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForGroupClaimProfile_STATUS(subject GroupClaimProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.GroupClaimProfile_STATUS
	err := copied.AssignProperties_To_GroupClaimProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GroupClaimProfile_STATUS
	err = actual.AssignProperties_From_GroupClaimProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GroupClaimProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GroupClaimProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGroupClaimProfile_STATUS, GroupClaimProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGroupClaimProfile_STATUS runs a test to see if a specific instance of GroupClaimProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGroupClaimProfile_STATUS(subject GroupClaimProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GroupClaimProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GroupClaimProfile_STATUS instances for property testing - lazily instantiated by
// GroupClaimProfile_STATUSGenerator()
var groupClaimProfile_STATUSGenerator gopter.Gen

// GroupClaimProfile_STATUSGenerator returns a generator of GroupClaimProfile_STATUS instances for property testing.
func GroupClaimProfile_STATUSGenerator() gopter.Gen {
	if groupClaimProfile_STATUSGenerator != nil {
		return groupClaimProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGroupClaimProfile_STATUS(generators)
	groupClaimProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(GroupClaimProfile_STATUS{}), generators)

	return groupClaimProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForGroupClaimProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGroupClaimProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Claim"] = gen.PtrOf(gen.AlphaString())
	gens["Prefix"] = gen.PtrOf(gen.AlphaString())
}

func Test_HcpOpenShiftClustersExternalAuth_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HcpOpenShiftClustersExternalAuth to hub returns original",
		prop.ForAll(RunResourceConversionTestForHcpOpenShiftClustersExternalAuth, HcpOpenShiftClustersExternalAuthGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForHcpOpenShiftClustersExternalAuth tests if a specific instance of HcpOpenShiftClustersExternalAuth round trips to the hub storage version and back losslessly
func RunResourceConversionTestForHcpOpenShiftClustersExternalAuth(subject HcpOpenShiftClustersExternalAuth) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub storage.HcpOpenShiftClustersExternalAuth
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual HcpOpenShiftClustersExternalAuth
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HcpOpenShiftClustersExternalAuth_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HcpOpenShiftClustersExternalAuth to HcpOpenShiftClustersExternalAuth via AssignProperties_To_HcpOpenShiftClustersExternalAuth & AssignProperties_From_HcpOpenShiftClustersExternalAuth returns original",
		prop.ForAll(RunPropertyAssignmentTestForHcpOpenShiftClustersExternalAuth, HcpOpenShiftClustersExternalAuthGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHcpOpenShiftClustersExternalAuth tests if a specific instance of HcpOpenShiftClustersExternalAuth can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHcpOpenShiftClustersExternalAuth(subject HcpOpenShiftClustersExternalAuth) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HcpOpenShiftClustersExternalAuth
	err := copied.AssignProperties_To_HcpOpenShiftClustersExternalAuth(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HcpOpenShiftClustersExternalAuth
	err = actual.AssignProperties_From_HcpOpenShiftClustersExternalAuth(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HcpOpenShiftClustersExternalAuth_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HcpOpenShiftClustersExternalAuth via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHcpOpenShiftClustersExternalAuth, HcpOpenShiftClustersExternalAuthGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHcpOpenShiftClustersExternalAuth runs a test to see if a specific instance of HcpOpenShiftClustersExternalAuth round trips to JSON and back losslessly
func RunJSONSerializationTestForHcpOpenShiftClustersExternalAuth(subject HcpOpenShiftClustersExternalAuth) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HcpOpenShiftClustersExternalAuth
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HcpOpenShiftClustersExternalAuth instances for property testing - lazily instantiated by
// HcpOpenShiftClustersExternalAuthGenerator()
var hcpOpenShiftClustersExternalAuthGenerator gopter.Gen

// HcpOpenShiftClustersExternalAuthGenerator returns a generator of HcpOpenShiftClustersExternalAuth instances for property testing.
func HcpOpenShiftClustersExternalAuthGenerator() gopter.Gen {
	if hcpOpenShiftClustersExternalAuthGenerator != nil {
		return hcpOpenShiftClustersExternalAuthGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForHcpOpenShiftClustersExternalAuth(generators)
	hcpOpenShiftClustersExternalAuthGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClustersExternalAuth{}), generators)

	return hcpOpenShiftClustersExternalAuthGenerator
}

// AddRelatedPropertyGeneratorsForHcpOpenShiftClustersExternalAuth is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHcpOpenShiftClustersExternalAuth(gens map[string]gopter.Gen) {
	gens["Spec"] = HcpOpenShiftClustersExternalAuth_SpecGenerator()
	gens["Status"] = HcpOpenShiftClustersExternalAuth_STATUSGenerator()
}

func Test_HcpOpenShiftClustersExternalAuthOperatorSpec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HcpOpenShiftClustersExternalAuthOperatorSpec to HcpOpenShiftClustersExternalAuthOperatorSpec via AssignProperties_To_HcpOpenShiftClustersExternalAuthOperatorSpec & AssignProperties_From_HcpOpenShiftClustersExternalAuthOperatorSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForHcpOpenShiftClustersExternalAuthOperatorSpec, HcpOpenShiftClustersExternalAuthOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHcpOpenShiftClustersExternalAuthOperatorSpec tests if a specific instance of HcpOpenShiftClustersExternalAuthOperatorSpec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHcpOpenShiftClustersExternalAuthOperatorSpec(subject HcpOpenShiftClustersExternalAuthOperatorSpec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HcpOpenShiftClustersExternalAuthOperatorSpec
	err := copied.AssignProperties_To_HcpOpenShiftClustersExternalAuthOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HcpOpenShiftClustersExternalAuthOperatorSpec
	err = actual.AssignProperties_From_HcpOpenShiftClustersExternalAuthOperatorSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HcpOpenShiftClustersExternalAuthOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HcpOpenShiftClustersExternalAuthOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHcpOpenShiftClustersExternalAuthOperatorSpec, HcpOpenShiftClustersExternalAuthOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHcpOpenShiftClustersExternalAuthOperatorSpec runs a test to see if a specific instance of HcpOpenShiftClustersExternalAuthOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForHcpOpenShiftClustersExternalAuthOperatorSpec(subject HcpOpenShiftClustersExternalAuthOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HcpOpenShiftClustersExternalAuthOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HcpOpenShiftClustersExternalAuthOperatorSpec instances for property testing - lazily instantiated by
// HcpOpenShiftClustersExternalAuthOperatorSpecGenerator()
var hcpOpenShiftClustersExternalAuthOperatorSpecGenerator gopter.Gen

// HcpOpenShiftClustersExternalAuthOperatorSpecGenerator returns a generator of HcpOpenShiftClustersExternalAuthOperatorSpec instances for property testing.
func HcpOpenShiftClustersExternalAuthOperatorSpecGenerator() gopter.Gen {
	if hcpOpenShiftClustersExternalAuthOperatorSpecGenerator != nil {
		return hcpOpenShiftClustersExternalAuthOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	hcpOpenShiftClustersExternalAuthOperatorSpecGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClustersExternalAuthOperatorSpec{}), generators)

	return hcpOpenShiftClustersExternalAuthOperatorSpecGenerator
}

func Test_HcpOpenShiftClustersExternalAuth_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HcpOpenShiftClustersExternalAuth_STATUS to HcpOpenShiftClustersExternalAuth_STATUS via AssignProperties_To_HcpOpenShiftClustersExternalAuth_STATUS & AssignProperties_From_HcpOpenShiftClustersExternalAuth_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHcpOpenShiftClustersExternalAuth_STATUS, HcpOpenShiftClustersExternalAuth_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHcpOpenShiftClustersExternalAuth_STATUS tests if a specific instance of HcpOpenShiftClustersExternalAuth_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHcpOpenShiftClustersExternalAuth_STATUS(subject HcpOpenShiftClustersExternalAuth_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HcpOpenShiftClustersExternalAuth_STATUS
	err := copied.AssignProperties_To_HcpOpenShiftClustersExternalAuth_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HcpOpenShiftClustersExternalAuth_STATUS
	err = actual.AssignProperties_From_HcpOpenShiftClustersExternalAuth_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HcpOpenShiftClustersExternalAuth_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HcpOpenShiftClustersExternalAuth_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHcpOpenShiftClustersExternalAuth_STATUS, HcpOpenShiftClustersExternalAuth_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHcpOpenShiftClustersExternalAuth_STATUS runs a test to see if a specific instance of HcpOpenShiftClustersExternalAuth_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHcpOpenShiftClustersExternalAuth_STATUS(subject HcpOpenShiftClustersExternalAuth_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HcpOpenShiftClustersExternalAuth_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HcpOpenShiftClustersExternalAuth_STATUS instances for property testing - lazily instantiated by
// HcpOpenShiftClustersExternalAuth_STATUSGenerator()
var hcpOpenShiftClustersExternalAuth_STATUSGenerator gopter.Gen

// HcpOpenShiftClustersExternalAuth_STATUSGenerator returns a generator of HcpOpenShiftClustersExternalAuth_STATUS instances for property testing.
// We first initialize hcpOpenShiftClustersExternalAuth_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HcpOpenShiftClustersExternalAuth_STATUSGenerator() gopter.Gen {
	if hcpOpenShiftClustersExternalAuth_STATUSGenerator != nil {
		return hcpOpenShiftClustersExternalAuth_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_STATUS(generators)
	hcpOpenShiftClustersExternalAuth_STATUSGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClustersExternalAuth_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_STATUS(generators)
	AddRelatedPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_STATUS(generators)
	hcpOpenShiftClustersExternalAuth_STATUSGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClustersExternalAuth_STATUS{}), generators)

	return hcpOpenShiftClustersExternalAuth_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ExternalAuthProperties_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_HcpOpenShiftClustersExternalAuth_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HcpOpenShiftClustersExternalAuth_Spec to HcpOpenShiftClustersExternalAuth_Spec via AssignProperties_To_HcpOpenShiftClustersExternalAuth_Spec & AssignProperties_From_HcpOpenShiftClustersExternalAuth_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForHcpOpenShiftClustersExternalAuth_Spec, HcpOpenShiftClustersExternalAuth_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHcpOpenShiftClustersExternalAuth_Spec tests if a specific instance of HcpOpenShiftClustersExternalAuth_Spec can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForHcpOpenShiftClustersExternalAuth_Spec(subject HcpOpenShiftClustersExternalAuth_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.HcpOpenShiftClustersExternalAuth_Spec
	err := copied.AssignProperties_To_HcpOpenShiftClustersExternalAuth_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HcpOpenShiftClustersExternalAuth_Spec
	err = actual.AssignProperties_From_HcpOpenShiftClustersExternalAuth_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HcpOpenShiftClustersExternalAuth_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HcpOpenShiftClustersExternalAuth_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHcpOpenShiftClustersExternalAuth_Spec, HcpOpenShiftClustersExternalAuth_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHcpOpenShiftClustersExternalAuth_Spec runs a test to see if a specific instance of HcpOpenShiftClustersExternalAuth_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForHcpOpenShiftClustersExternalAuth_Spec(subject HcpOpenShiftClustersExternalAuth_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HcpOpenShiftClustersExternalAuth_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HcpOpenShiftClustersExternalAuth_Spec instances for property testing - lazily instantiated by
// HcpOpenShiftClustersExternalAuth_SpecGenerator()
var hcpOpenShiftClustersExternalAuth_SpecGenerator gopter.Gen

// HcpOpenShiftClustersExternalAuth_SpecGenerator returns a generator of HcpOpenShiftClustersExternalAuth_Spec instances for property testing.
// We first initialize hcpOpenShiftClustersExternalAuth_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func HcpOpenShiftClustersExternalAuth_SpecGenerator() gopter.Gen {
	if hcpOpenShiftClustersExternalAuth_SpecGenerator != nil {
		return hcpOpenShiftClustersExternalAuth_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_Spec(generators)
	hcpOpenShiftClustersExternalAuth_SpecGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClustersExternalAuth_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_Spec(generators)
	AddRelatedPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_Spec(generators)
	hcpOpenShiftClustersExternalAuth_SpecGenerator = gen.Struct(reflect.TypeOf(HcpOpenShiftClustersExternalAuth_Spec{}), generators)

	return hcpOpenShiftClustersExternalAuth_SpecGenerator
}

// AddIndependentPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForHcpOpenShiftClustersExternalAuth_Spec(gens map[string]gopter.Gen) {
	gens["OperatorSpec"] = gen.PtrOf(HcpOpenShiftClustersExternalAuthOperatorSpecGenerator())
	gens["Properties"] = gen.PtrOf(ExternalAuthPropertiesGenerator())
}

func Test_TokenClaimMappingsProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TokenClaimMappingsProfile to TokenClaimMappingsProfile via AssignProperties_To_TokenClaimMappingsProfile & AssignProperties_From_TokenClaimMappingsProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForTokenClaimMappingsProfile, TokenClaimMappingsProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTokenClaimMappingsProfile tests if a specific instance of TokenClaimMappingsProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTokenClaimMappingsProfile(subject TokenClaimMappingsProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.TokenClaimMappingsProfile
	err := copied.AssignProperties_To_TokenClaimMappingsProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TokenClaimMappingsProfile
	err = actual.AssignProperties_From_TokenClaimMappingsProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TokenClaimMappingsProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenClaimMappingsProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenClaimMappingsProfile, TokenClaimMappingsProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenClaimMappingsProfile runs a test to see if a specific instance of TokenClaimMappingsProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenClaimMappingsProfile(subject TokenClaimMappingsProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenClaimMappingsProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenClaimMappingsProfile instances for property testing - lazily instantiated by
// TokenClaimMappingsProfileGenerator()
var tokenClaimMappingsProfileGenerator gopter.Gen

// TokenClaimMappingsProfileGenerator returns a generator of TokenClaimMappingsProfile instances for property testing.
func TokenClaimMappingsProfileGenerator() gopter.Gen {
	if tokenClaimMappingsProfileGenerator != nil {
		return tokenClaimMappingsProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForTokenClaimMappingsProfile(generators)
	tokenClaimMappingsProfileGenerator = gen.Struct(reflect.TypeOf(TokenClaimMappingsProfile{}), generators)

	return tokenClaimMappingsProfileGenerator
}

// AddRelatedPropertyGeneratorsForTokenClaimMappingsProfile is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTokenClaimMappingsProfile(gens map[string]gopter.Gen) {
	gens["Groups"] = gen.PtrOf(GroupClaimProfileGenerator())
	gens["Username"] = gen.PtrOf(UsernameClaimProfileGenerator())
}

func Test_TokenClaimMappingsProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TokenClaimMappingsProfile_STATUS to TokenClaimMappingsProfile_STATUS via AssignProperties_To_TokenClaimMappingsProfile_STATUS & AssignProperties_From_TokenClaimMappingsProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForTokenClaimMappingsProfile_STATUS, TokenClaimMappingsProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTokenClaimMappingsProfile_STATUS tests if a specific instance of TokenClaimMappingsProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTokenClaimMappingsProfile_STATUS(subject TokenClaimMappingsProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.TokenClaimMappingsProfile_STATUS
	err := copied.AssignProperties_To_TokenClaimMappingsProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TokenClaimMappingsProfile_STATUS
	err = actual.AssignProperties_From_TokenClaimMappingsProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TokenClaimMappingsProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenClaimMappingsProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenClaimMappingsProfile_STATUS, TokenClaimMappingsProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenClaimMappingsProfile_STATUS runs a test to see if a specific instance of TokenClaimMappingsProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenClaimMappingsProfile_STATUS(subject TokenClaimMappingsProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenClaimMappingsProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenClaimMappingsProfile_STATUS instances for property testing - lazily instantiated by
// TokenClaimMappingsProfile_STATUSGenerator()
var tokenClaimMappingsProfile_STATUSGenerator gopter.Gen

// TokenClaimMappingsProfile_STATUSGenerator returns a generator of TokenClaimMappingsProfile_STATUS instances for property testing.
func TokenClaimMappingsProfile_STATUSGenerator() gopter.Gen {
	if tokenClaimMappingsProfile_STATUSGenerator != nil {
		return tokenClaimMappingsProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForTokenClaimMappingsProfile_STATUS(generators)
	tokenClaimMappingsProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(TokenClaimMappingsProfile_STATUS{}), generators)

	return tokenClaimMappingsProfile_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForTokenClaimMappingsProfile_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTokenClaimMappingsProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Groups"] = gen.PtrOf(GroupClaimProfile_STATUSGenerator())
	gens["Username"] = gen.PtrOf(UsernameClaimProfile_STATUSGenerator())
}

func Test_TokenClaimValidationRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TokenClaimValidationRule to TokenClaimValidationRule via AssignProperties_To_TokenClaimValidationRule & AssignProperties_From_TokenClaimValidationRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForTokenClaimValidationRule, TokenClaimValidationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTokenClaimValidationRule tests if a specific instance of TokenClaimValidationRule can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTokenClaimValidationRule(subject TokenClaimValidationRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.TokenClaimValidationRule
	err := copied.AssignProperties_To_TokenClaimValidationRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TokenClaimValidationRule
	err = actual.AssignProperties_From_TokenClaimValidationRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TokenClaimValidationRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenClaimValidationRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenClaimValidationRule, TokenClaimValidationRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenClaimValidationRule runs a test to see if a specific instance of TokenClaimValidationRule round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenClaimValidationRule(subject TokenClaimValidationRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenClaimValidationRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenClaimValidationRule instances for property testing - lazily instantiated by
// TokenClaimValidationRuleGenerator()
var tokenClaimValidationRuleGenerator gopter.Gen

// TokenClaimValidationRuleGenerator returns a generator of TokenClaimValidationRule instances for property testing.
// We first initialize tokenClaimValidationRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TokenClaimValidationRuleGenerator() gopter.Gen {
	if tokenClaimValidationRuleGenerator != nil {
		return tokenClaimValidationRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenClaimValidationRule(generators)
	tokenClaimValidationRuleGenerator = gen.Struct(reflect.TypeOf(TokenClaimValidationRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenClaimValidationRule(generators)
	AddRelatedPropertyGeneratorsForTokenClaimValidationRule(generators)
	tokenClaimValidationRuleGenerator = gen.Struct(reflect.TypeOf(TokenClaimValidationRule{}), generators)

	return tokenClaimValidationRuleGenerator
}

// AddIndependentPropertyGeneratorsForTokenClaimValidationRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTokenClaimValidationRule(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(TokenClaimValidationRule_Type_RequiredClaim))
}

// AddRelatedPropertyGeneratorsForTokenClaimValidationRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTokenClaimValidationRule(gens map[string]gopter.Gen) {
	gens["RequiredClaim"] = gen.PtrOf(TokenRequiredClaimGenerator())
}

func Test_TokenClaimValidationRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TokenClaimValidationRule_STATUS to TokenClaimValidationRule_STATUS via AssignProperties_To_TokenClaimValidationRule_STATUS & AssignProperties_From_TokenClaimValidationRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForTokenClaimValidationRule_STATUS, TokenClaimValidationRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTokenClaimValidationRule_STATUS tests if a specific instance of TokenClaimValidationRule_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTokenClaimValidationRule_STATUS(subject TokenClaimValidationRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.TokenClaimValidationRule_STATUS
	err := copied.AssignProperties_To_TokenClaimValidationRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TokenClaimValidationRule_STATUS
	err = actual.AssignProperties_From_TokenClaimValidationRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TokenClaimValidationRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenClaimValidationRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenClaimValidationRule_STATUS, TokenClaimValidationRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenClaimValidationRule_STATUS runs a test to see if a specific instance of TokenClaimValidationRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenClaimValidationRule_STATUS(subject TokenClaimValidationRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenClaimValidationRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenClaimValidationRule_STATUS instances for property testing - lazily instantiated by
// TokenClaimValidationRule_STATUSGenerator()
var tokenClaimValidationRule_STATUSGenerator gopter.Gen

// TokenClaimValidationRule_STATUSGenerator returns a generator of TokenClaimValidationRule_STATUS instances for property testing.
// We first initialize tokenClaimValidationRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func TokenClaimValidationRule_STATUSGenerator() gopter.Gen {
	if tokenClaimValidationRule_STATUSGenerator != nil {
		return tokenClaimValidationRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenClaimValidationRule_STATUS(generators)
	tokenClaimValidationRule_STATUSGenerator = gen.Struct(reflect.TypeOf(TokenClaimValidationRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenClaimValidationRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForTokenClaimValidationRule_STATUS(generators)
	tokenClaimValidationRule_STATUSGenerator = gen.Struct(reflect.TypeOf(TokenClaimValidationRule_STATUS{}), generators)

	return tokenClaimValidationRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTokenClaimValidationRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTokenClaimValidationRule_STATUS(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(TokenClaimValidationRule_Type_STATUS_RequiredClaim))
}

// AddRelatedPropertyGeneratorsForTokenClaimValidationRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForTokenClaimValidationRule_STATUS(gens map[string]gopter.Gen) {
	gens["RequiredClaim"] = gen.PtrOf(TokenRequiredClaim_STATUSGenerator())
}

func Test_TokenIssuerProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TokenIssuerProfile to TokenIssuerProfile via AssignProperties_To_TokenIssuerProfile & AssignProperties_From_TokenIssuerProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForTokenIssuerProfile, TokenIssuerProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTokenIssuerProfile tests if a specific instance of TokenIssuerProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTokenIssuerProfile(subject TokenIssuerProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.TokenIssuerProfile
	err := copied.AssignProperties_To_TokenIssuerProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TokenIssuerProfile
	err = actual.AssignProperties_From_TokenIssuerProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TokenIssuerProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenIssuerProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenIssuerProfile, TokenIssuerProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenIssuerProfile runs a test to see if a specific instance of TokenIssuerProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenIssuerProfile(subject TokenIssuerProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenIssuerProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenIssuerProfile instances for property testing - lazily instantiated by TokenIssuerProfileGenerator()
var tokenIssuerProfileGenerator gopter.Gen

// TokenIssuerProfileGenerator returns a generator of TokenIssuerProfile instances for property testing.
func TokenIssuerProfileGenerator() gopter.Gen {
	if tokenIssuerProfileGenerator != nil {
		return tokenIssuerProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenIssuerProfile(generators)
	tokenIssuerProfileGenerator = gen.Struct(reflect.TypeOf(TokenIssuerProfile{}), generators)

	return tokenIssuerProfileGenerator
}

// AddIndependentPropertyGeneratorsForTokenIssuerProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTokenIssuerProfile(gens map[string]gopter.Gen) {
	gens["Audiences"] = gen.SliceOf(gen.AlphaString())
	gens["Ca"] = gen.PtrOf(gen.AlphaString())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_TokenIssuerProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TokenIssuerProfile_STATUS to TokenIssuerProfile_STATUS via AssignProperties_To_TokenIssuerProfile_STATUS & AssignProperties_From_TokenIssuerProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForTokenIssuerProfile_STATUS, TokenIssuerProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTokenIssuerProfile_STATUS tests if a specific instance of TokenIssuerProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTokenIssuerProfile_STATUS(subject TokenIssuerProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.TokenIssuerProfile_STATUS
	err := copied.AssignProperties_To_TokenIssuerProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TokenIssuerProfile_STATUS
	err = actual.AssignProperties_From_TokenIssuerProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TokenIssuerProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenIssuerProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenIssuerProfile_STATUS, TokenIssuerProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenIssuerProfile_STATUS runs a test to see if a specific instance of TokenIssuerProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenIssuerProfile_STATUS(subject TokenIssuerProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenIssuerProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenIssuerProfile_STATUS instances for property testing - lazily instantiated by
// TokenIssuerProfile_STATUSGenerator()
var tokenIssuerProfile_STATUSGenerator gopter.Gen

// TokenIssuerProfile_STATUSGenerator returns a generator of TokenIssuerProfile_STATUS instances for property testing.
func TokenIssuerProfile_STATUSGenerator() gopter.Gen {
	if tokenIssuerProfile_STATUSGenerator != nil {
		return tokenIssuerProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenIssuerProfile_STATUS(generators)
	tokenIssuerProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(TokenIssuerProfile_STATUS{}), generators)

	return tokenIssuerProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTokenIssuerProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTokenIssuerProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Audiences"] = gen.SliceOf(gen.AlphaString())
	gens["Ca"] = gen.PtrOf(gen.AlphaString())
	gens["Url"] = gen.PtrOf(gen.AlphaString())
}

func Test_TokenRequiredClaim_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TokenRequiredClaim to TokenRequiredClaim via AssignProperties_To_TokenRequiredClaim & AssignProperties_From_TokenRequiredClaim returns original",
		prop.ForAll(RunPropertyAssignmentTestForTokenRequiredClaim, TokenRequiredClaimGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTokenRequiredClaim tests if a specific instance of TokenRequiredClaim can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTokenRequiredClaim(subject TokenRequiredClaim) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.TokenRequiredClaim
	err := copied.AssignProperties_To_TokenRequiredClaim(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TokenRequiredClaim
	err = actual.AssignProperties_From_TokenRequiredClaim(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TokenRequiredClaim_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenRequiredClaim via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenRequiredClaim, TokenRequiredClaimGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenRequiredClaim runs a test to see if a specific instance of TokenRequiredClaim round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenRequiredClaim(subject TokenRequiredClaim) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenRequiredClaim
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenRequiredClaim instances for property testing - lazily instantiated by TokenRequiredClaimGenerator()
var tokenRequiredClaimGenerator gopter.Gen

// TokenRequiredClaimGenerator returns a generator of TokenRequiredClaim instances for property testing.
func TokenRequiredClaimGenerator() gopter.Gen {
	if tokenRequiredClaimGenerator != nil {
		return tokenRequiredClaimGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenRequiredClaim(generators)
	tokenRequiredClaimGenerator = gen.Struct(reflect.TypeOf(TokenRequiredClaim{}), generators)

	return tokenRequiredClaimGenerator
}

// AddIndependentPropertyGeneratorsForTokenRequiredClaim is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTokenRequiredClaim(gens map[string]gopter.Gen) {
	gens["Claim"] = gen.PtrOf(gen.AlphaString())
	gens["RequiredValue"] = gen.PtrOf(gen.AlphaString())
}

func Test_TokenRequiredClaim_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from TokenRequiredClaim_STATUS to TokenRequiredClaim_STATUS via AssignProperties_To_TokenRequiredClaim_STATUS & AssignProperties_From_TokenRequiredClaim_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForTokenRequiredClaim_STATUS, TokenRequiredClaim_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForTokenRequiredClaim_STATUS tests if a specific instance of TokenRequiredClaim_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForTokenRequiredClaim_STATUS(subject TokenRequiredClaim_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.TokenRequiredClaim_STATUS
	err := copied.AssignProperties_To_TokenRequiredClaim_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual TokenRequiredClaim_STATUS
	err = actual.AssignProperties_From_TokenRequiredClaim_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_TokenRequiredClaim_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of TokenRequiredClaim_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForTokenRequiredClaim_STATUS, TokenRequiredClaim_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForTokenRequiredClaim_STATUS runs a test to see if a specific instance of TokenRequiredClaim_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForTokenRequiredClaim_STATUS(subject TokenRequiredClaim_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual TokenRequiredClaim_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of TokenRequiredClaim_STATUS instances for property testing - lazily instantiated by
// TokenRequiredClaim_STATUSGenerator()
var tokenRequiredClaim_STATUSGenerator gopter.Gen

// TokenRequiredClaim_STATUSGenerator returns a generator of TokenRequiredClaim_STATUS instances for property testing.
func TokenRequiredClaim_STATUSGenerator() gopter.Gen {
	if tokenRequiredClaim_STATUSGenerator != nil {
		return tokenRequiredClaim_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForTokenRequiredClaim_STATUS(generators)
	tokenRequiredClaim_STATUSGenerator = gen.Struct(reflect.TypeOf(TokenRequiredClaim_STATUS{}), generators)

	return tokenRequiredClaim_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForTokenRequiredClaim_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForTokenRequiredClaim_STATUS(gens map[string]gopter.Gen) {
	gens["Claim"] = gen.PtrOf(gen.AlphaString())
	gens["RequiredValue"] = gen.PtrOf(gen.AlphaString())
}

func Test_UsernameClaimProfile_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UsernameClaimProfile to UsernameClaimProfile via AssignProperties_To_UsernameClaimProfile & AssignProperties_From_UsernameClaimProfile returns original",
		prop.ForAll(RunPropertyAssignmentTestForUsernameClaimProfile, UsernameClaimProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUsernameClaimProfile tests if a specific instance of UsernameClaimProfile can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUsernameClaimProfile(subject UsernameClaimProfile) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UsernameClaimProfile
	err := copied.AssignProperties_To_UsernameClaimProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UsernameClaimProfile
	err = actual.AssignProperties_From_UsernameClaimProfile(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UsernameClaimProfile_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UsernameClaimProfile via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUsernameClaimProfile, UsernameClaimProfileGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUsernameClaimProfile runs a test to see if a specific instance of UsernameClaimProfile round trips to JSON and back losslessly
func RunJSONSerializationTestForUsernameClaimProfile(subject UsernameClaimProfile) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UsernameClaimProfile
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UsernameClaimProfile instances for property testing - lazily instantiated by
// UsernameClaimProfileGenerator()
var usernameClaimProfileGenerator gopter.Gen

// UsernameClaimProfileGenerator returns a generator of UsernameClaimProfile instances for property testing.
func UsernameClaimProfileGenerator() gopter.Gen {
	if usernameClaimProfileGenerator != nil {
		return usernameClaimProfileGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUsernameClaimProfile(generators)
	usernameClaimProfileGenerator = gen.Struct(reflect.TypeOf(UsernameClaimProfile{}), generators)

	return usernameClaimProfileGenerator
}

// AddIndependentPropertyGeneratorsForUsernameClaimProfile is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUsernameClaimProfile(gens map[string]gopter.Gen) {
	gens["Claim"] = gen.PtrOf(gen.AlphaString())
	gens["Prefix"] = gen.PtrOf(gen.AlphaString())
	gens["PrefixPolicy"] = gen.PtrOf(gen.OneConstOf(UsernameClaimPrefixPolicy_NoPrefix, UsernameClaimPrefixPolicy_None, UsernameClaimPrefixPolicy_Prefix))
}

func Test_UsernameClaimProfile_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UsernameClaimProfile_STATUS to UsernameClaimProfile_STATUS via AssignProperties_To_UsernameClaimProfile_STATUS & AssignProperties_From_UsernameClaimProfile_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUsernameClaimProfile_STATUS, UsernameClaimProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUsernameClaimProfile_STATUS tests if a specific instance of UsernameClaimProfile_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForUsernameClaimProfile_STATUS(subject UsernameClaimProfile_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.UsernameClaimProfile_STATUS
	err := copied.AssignProperties_To_UsernameClaimProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UsernameClaimProfile_STATUS
	err = actual.AssignProperties_From_UsernameClaimProfile_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UsernameClaimProfile_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UsernameClaimProfile_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUsernameClaimProfile_STATUS, UsernameClaimProfile_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUsernameClaimProfile_STATUS runs a test to see if a specific instance of UsernameClaimProfile_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUsernameClaimProfile_STATUS(subject UsernameClaimProfile_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UsernameClaimProfile_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UsernameClaimProfile_STATUS instances for property testing - lazily instantiated by
// UsernameClaimProfile_STATUSGenerator()
var usernameClaimProfile_STATUSGenerator gopter.Gen

// UsernameClaimProfile_STATUSGenerator returns a generator of UsernameClaimProfile_STATUS instances for property testing.
func UsernameClaimProfile_STATUSGenerator() gopter.Gen {
	if usernameClaimProfile_STATUSGenerator != nil {
		return usernameClaimProfile_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUsernameClaimProfile_STATUS(generators)
	usernameClaimProfile_STATUSGenerator = gen.Struct(reflect.TypeOf(UsernameClaimProfile_STATUS{}), generators)

	return usernameClaimProfile_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUsernameClaimProfile_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUsernameClaimProfile_STATUS(gens map[string]gopter.Gen) {
	gens["Claim"] = gen.PtrOf(gen.AlphaString())
	gens["Prefix"] = gen.PtrOf(gen.AlphaString())
	gens["PrefixPolicy"] = gen.PtrOf(gen.OneConstOf(UsernameClaimPrefixPolicy_STATUS_NoPrefix, UsernameClaimPrefixPolicy_STATUS_None, UsernameClaimPrefixPolicy_STATUS_Prefix))
}
