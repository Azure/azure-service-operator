// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20240610preview

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/redhatopenshift/v1api20240610preview/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/redhatopenshift/v1api20240610preview/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,redhatopenshift}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /redhatopenshift/resource-manager/Microsoft.RedHatOpenShift/hcpclusters/preview/2024-06-10-preview/openapi.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RedHatOpenShift/hcpOpenShiftClusters/{hcpOpenShiftClusterName}
type HcpOpenShiftCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              HcpOpenShiftCluster_Spec   `json:"spec,omitempty"`
	Status            HcpOpenShiftCluster_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &HcpOpenShiftCluster{}

// GetConditions returns the conditions of the resource
func (cluster *HcpOpenShiftCluster) GetConditions() conditions.Conditions {
	return cluster.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (cluster *HcpOpenShiftCluster) SetConditions(conditions conditions.Conditions) {
	cluster.Status.Conditions = conditions
}

var _ conversion.Convertible = &HcpOpenShiftCluster{}

// ConvertFrom populates our HcpOpenShiftCluster from the provided hub HcpOpenShiftCluster
func (cluster *HcpOpenShiftCluster) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.HcpOpenShiftCluster)
	if !ok {
		return fmt.Errorf("expected redhatopenshift/v1api20240610preview/storage/HcpOpenShiftCluster but received %T instead", hub)
	}

	return cluster.AssignProperties_From_HcpOpenShiftCluster(source)
}

// ConvertTo populates the provided hub HcpOpenShiftCluster from our HcpOpenShiftCluster
func (cluster *HcpOpenShiftCluster) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.HcpOpenShiftCluster)
	if !ok {
		return fmt.Errorf("expected redhatopenshift/v1api20240610preview/storage/HcpOpenShiftCluster but received %T instead", hub)
	}

	return cluster.AssignProperties_To_HcpOpenShiftCluster(destination)
}

var _ configmaps.Exporter = &HcpOpenShiftCluster{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (cluster *HcpOpenShiftCluster) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if cluster.Spec.OperatorSpec == nil {
		return nil
	}
	return cluster.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &HcpOpenShiftCluster{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (cluster *HcpOpenShiftCluster) SecretDestinationExpressions() []*core.DestinationExpression {
	if cluster.Spec.OperatorSpec == nil {
		return nil
	}
	return cluster.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &HcpOpenShiftCluster{}

// InitializeSpec initializes the spec for this resource from the given status
func (cluster *HcpOpenShiftCluster) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*HcpOpenShiftCluster_STATUS); ok {
		return cluster.Spec.Initialize_From_HcpOpenShiftCluster_STATUS(s)
	}

	return fmt.Errorf("expected Status of type HcpOpenShiftCluster_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &HcpOpenShiftCluster{}

// AzureName returns the Azure name of the resource
func (cluster *HcpOpenShiftCluster) AzureName() string {
	return cluster.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2024-06-10-preview"
func (cluster HcpOpenShiftCluster) GetAPIVersion() string {
	return "2024-06-10-preview"
}

// GetResourceScope returns the scope of the resource
func (cluster *HcpOpenShiftCluster) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (cluster *HcpOpenShiftCluster) GetSpec() genruntime.ConvertibleSpec {
	return &cluster.Spec
}

// GetStatus returns the status of this resource
func (cluster *HcpOpenShiftCluster) GetStatus() genruntime.ConvertibleStatus {
	return &cluster.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (cluster *HcpOpenShiftCluster) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.RedHatOpenShift/hcpOpenShiftClusters"
func (cluster *HcpOpenShiftCluster) GetType() string {
	return "Microsoft.RedHatOpenShift/hcpOpenShiftClusters"
}

// NewEmptyStatus returns a new empty (blank) status
func (cluster *HcpOpenShiftCluster) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &HcpOpenShiftCluster_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (cluster *HcpOpenShiftCluster) Owner() *genruntime.ResourceReference {
	if cluster.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(cluster.Spec)
	return cluster.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (cluster *HcpOpenShiftCluster) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*HcpOpenShiftCluster_STATUS); ok {
		cluster.Status = *st
		return nil
	}

	// Convert status to required version
	var st HcpOpenShiftCluster_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	cluster.Status = st
	return nil
}

// AssignProperties_From_HcpOpenShiftCluster populates our HcpOpenShiftCluster from the provided source HcpOpenShiftCluster
func (cluster *HcpOpenShiftCluster) AssignProperties_From_HcpOpenShiftCluster(source *storage.HcpOpenShiftCluster) error {

	// ObjectMeta
	cluster.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec HcpOpenShiftCluster_Spec
	err := spec.AssignProperties_From_HcpOpenShiftCluster_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_HcpOpenShiftCluster_Spec() to populate field Spec")
	}
	cluster.Spec = spec

	// Status
	var status HcpOpenShiftCluster_STATUS
	err = status.AssignProperties_From_HcpOpenShiftCluster_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_HcpOpenShiftCluster_STATUS() to populate field Status")
	}
	cluster.Status = status

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftCluster populates the provided destination HcpOpenShiftCluster from our HcpOpenShiftCluster
func (cluster *HcpOpenShiftCluster) AssignProperties_To_HcpOpenShiftCluster(destination *storage.HcpOpenShiftCluster) error {

	// ObjectMeta
	destination.ObjectMeta = *cluster.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.HcpOpenShiftCluster_Spec
	err := cluster.Spec.AssignProperties_To_HcpOpenShiftCluster_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_HcpOpenShiftCluster_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.HcpOpenShiftCluster_STATUS
	err = cluster.Status.AssignProperties_To_HcpOpenShiftCluster_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_HcpOpenShiftCluster_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (cluster *HcpOpenShiftCluster) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: cluster.Spec.OriginalVersion(),
		Kind:    "HcpOpenShiftCluster",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /redhatopenshift/resource-manager/Microsoft.RedHatOpenShift/hcpclusters/preview/2024-06-10-preview/openapi.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.RedHatOpenShift/hcpOpenShiftClusters/{hcpOpenShiftClusterName}
type HcpOpenShiftClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []HcpOpenShiftCluster `json:"items"`
}

// +kubebuilder:validation:Enum={"2024-06-10-preview"}
type APIVersion string

const APIVersion_Value = APIVersion("2024-06-10-preview")

type HcpOpenShiftCluster_Spec struct {
	// +kubebuilder:validation:Pattern="^[a-zA-Z][-a-zA-Z0-9]{1,52}[a-zA-Z0-9]$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Identity: The managed service identities assigned to this resource.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *HcpOpenShiftClusterOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// Properties: The resource-specific properties for this resource.
	Properties *HcpOpenShiftClusterProperties `json:"properties,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &HcpOpenShiftCluster_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (cluster *HcpOpenShiftCluster_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if cluster == nil {
		return nil, nil
	}
	result := &arm.HcpOpenShiftCluster_Spec{}

	// Set property "Identity":
	if cluster.Identity != nil {
		identity_ARM, err := cluster.Identity.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedServiceIdentity)
		result.Identity = &identity
	}

	// Set property "Location":
	if cluster.Location != nil {
		location := *cluster.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if cluster.Properties != nil {
		properties_ARM, err := cluster.Properties.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *properties_ARM.(*arm.HcpOpenShiftClusterProperties)
		result.Properties = &properties
	}

	// Set property "Tags":
	if cluster.Tags != nil {
		result.Tags = make(map[string]string, len(cluster.Tags))
		for key, value := range cluster.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cluster *HcpOpenShiftCluster_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HcpOpenShiftCluster_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cluster *HcpOpenShiftCluster_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HcpOpenShiftCluster_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HcpOpenShiftCluster_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	cluster.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		cluster.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		cluster.Location = &location
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	cluster.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 HcpOpenShiftClusterProperties
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		cluster.Properties = &properties
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		cluster.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			cluster.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &HcpOpenShiftCluster_Spec{}

// ConvertSpecFrom populates our HcpOpenShiftCluster_Spec from the provided source
func (cluster *HcpOpenShiftCluster_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.HcpOpenShiftCluster_Spec)
	if ok {
		// Populate our instance from source
		return cluster.AssignProperties_From_HcpOpenShiftCluster_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.HcpOpenShiftCluster_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = cluster.AssignProperties_From_HcpOpenShiftCluster_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our HcpOpenShiftCluster_Spec
func (cluster *HcpOpenShiftCluster_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.HcpOpenShiftCluster_Spec)
	if ok {
		// Populate destination from our instance
		return cluster.AssignProperties_To_HcpOpenShiftCluster_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.HcpOpenShiftCluster_Spec{}
	err := cluster.AssignProperties_To_HcpOpenShiftCluster_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_HcpOpenShiftCluster_Spec populates our HcpOpenShiftCluster_Spec from the provided source HcpOpenShiftCluster_Spec
func (cluster *HcpOpenShiftCluster_Spec) AssignProperties_From_HcpOpenShiftCluster_Spec(source *storage.HcpOpenShiftCluster_Spec) error {

	// AzureName
	cluster.AzureName = source.AzureName

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		cluster.Identity = &identity
	} else {
		cluster.Identity = nil
	}

	// Location
	cluster.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec HcpOpenShiftClusterOperatorSpec
		err := operatorSpec.AssignProperties_From_HcpOpenShiftClusterOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HcpOpenShiftClusterOperatorSpec() to populate field OperatorSpec")
		}
		cluster.OperatorSpec = &operatorSpec
	} else {
		cluster.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		cluster.Owner = &owner
	} else {
		cluster.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property HcpOpenShiftClusterProperties
		err := property.AssignProperties_From_HcpOpenShiftClusterProperties(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HcpOpenShiftClusterProperties() to populate field Properties")
		}
		cluster.Properties = &property
	} else {
		cluster.Properties = nil
	}

	// Tags
	cluster.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftCluster_Spec populates the provided destination HcpOpenShiftCluster_Spec from our HcpOpenShiftCluster_Spec
func (cluster *HcpOpenShiftCluster_Spec) AssignProperties_To_HcpOpenShiftCluster_Spec(destination *storage.HcpOpenShiftCluster_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = cluster.AzureName

	// Identity
	if cluster.Identity != nil {
		var identity storage.ManagedServiceIdentity
		err := cluster.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(cluster.Location)

	// OperatorSpec
	if cluster.OperatorSpec != nil {
		var operatorSpec storage.HcpOpenShiftClusterOperatorSpec
		err := cluster.OperatorSpec.AssignProperties_To_HcpOpenShiftClusterOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HcpOpenShiftClusterOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = cluster.OriginalVersion()

	// Owner
	if cluster.Owner != nil {
		owner := cluster.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if cluster.Properties != nil {
		var property storage.HcpOpenShiftClusterProperties
		err := cluster.Properties.AssignProperties_To_HcpOpenShiftClusterProperties(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HcpOpenShiftClusterProperties() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(cluster.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HcpOpenShiftCluster_STATUS populates our HcpOpenShiftCluster_Spec from the provided source HcpOpenShiftCluster_STATUS
func (cluster *HcpOpenShiftCluster_Spec) Initialize_From_HcpOpenShiftCluster_STATUS(source *HcpOpenShiftCluster_STATUS) error {

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.Initialize_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		cluster.Identity = &identity
	} else {
		cluster.Identity = nil
	}

	// Location
	cluster.Location = genruntime.ClonePointerToString(source.Location)

	// Properties
	if source.Properties != nil {
		var property HcpOpenShiftClusterProperties
		err := property.Initialize_From_HcpOpenShiftClusterProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_HcpOpenShiftClusterProperties_STATUS() to populate field Properties")
		}
		cluster.Properties = &property
	} else {
		cluster.Properties = nil
	}

	// Tags
	cluster.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (cluster *HcpOpenShiftCluster_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (cluster *HcpOpenShiftCluster_Spec) SetAzureName(azureName string) {
	cluster.AzureName = azureName
}

// HCP cluster resource
type HcpOpenShiftCluster_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Id: Fully qualified resource ID for the resource. E.g.
	// "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}"
	Id *string `json:"id,omitempty"`

	// Identity: The managed service identities assigned to this resource.
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// Properties: The resource-specific properties for this resource.
	Properties *HcpOpenShiftClusterProperties_STATUS `json:"properties,omitempty"`

	// SystemData: Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &HcpOpenShiftCluster_STATUS{}

// ConvertStatusFrom populates our HcpOpenShiftCluster_STATUS from the provided source
func (cluster *HcpOpenShiftCluster_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.HcpOpenShiftCluster_STATUS)
	if ok {
		// Populate our instance from source
		return cluster.AssignProperties_From_HcpOpenShiftCluster_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.HcpOpenShiftCluster_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = cluster.AssignProperties_From_HcpOpenShiftCluster_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our HcpOpenShiftCluster_STATUS
func (cluster *HcpOpenShiftCluster_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.HcpOpenShiftCluster_STATUS)
	if ok {
		// Populate destination from our instance
		return cluster.AssignProperties_To_HcpOpenShiftCluster_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.HcpOpenShiftCluster_STATUS{}
	err := cluster.AssignProperties_To_HcpOpenShiftCluster_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &HcpOpenShiftCluster_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (cluster *HcpOpenShiftCluster_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HcpOpenShiftCluster_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (cluster *HcpOpenShiftCluster_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HcpOpenShiftCluster_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HcpOpenShiftCluster_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		cluster.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		cluster.Identity = &identity
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		cluster.Location = &location
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		cluster.Name = &name
	}

	// Set property "Properties":
	if typedInput.Properties != nil {
		var properties1 HcpOpenShiftClusterProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		cluster.Properties = &properties
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		cluster.SystemData = &systemData
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		cluster.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			cluster.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		cluster.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_HcpOpenShiftCluster_STATUS populates our HcpOpenShiftCluster_STATUS from the provided source HcpOpenShiftCluster_STATUS
func (cluster *HcpOpenShiftCluster_STATUS) AssignProperties_From_HcpOpenShiftCluster_STATUS(source *storage.HcpOpenShiftCluster_STATUS) error {

	// Conditions
	cluster.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Id
	cluster.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		cluster.Identity = &identity
	} else {
		cluster.Identity = nil
	}

	// Location
	cluster.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	cluster.Name = genruntime.ClonePointerToString(source.Name)

	// Properties
	if source.Properties != nil {
		var property HcpOpenShiftClusterProperties_STATUS
		err := property.AssignProperties_From_HcpOpenShiftClusterProperties_STATUS(source.Properties)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HcpOpenShiftClusterProperties_STATUS() to populate field Properties")
		}
		cluster.Properties = &property
	} else {
		cluster.Properties = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		cluster.SystemData = &systemDatum
	} else {
		cluster.SystemData = nil
	}

	// Tags
	cluster.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	cluster.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftCluster_STATUS populates the provided destination HcpOpenShiftCluster_STATUS from our HcpOpenShiftCluster_STATUS
func (cluster *HcpOpenShiftCluster_STATUS) AssignProperties_To_HcpOpenShiftCluster_STATUS(destination *storage.HcpOpenShiftCluster_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(cluster.Conditions)

	// Id
	destination.Id = genruntime.ClonePointerToString(cluster.Id)

	// Identity
	if cluster.Identity != nil {
		var identity storage.ManagedServiceIdentity_STATUS
		err := cluster.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(cluster.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(cluster.Name)

	// Properties
	if cluster.Properties != nil {
		var property storage.HcpOpenShiftClusterProperties_STATUS
		err := cluster.Properties.AssignProperties_To_HcpOpenShiftClusterProperties_STATUS(&property)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HcpOpenShiftClusterProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// SystemData
	if cluster.SystemData != nil {
		var systemDatum storage.SystemData_STATUS
		err := cluster.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(cluster.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(cluster.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type HcpOpenShiftClusterOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`

	// Secrets: configures where to place Azure generated secrets.
	Secrets *HcpOpenShiftClusterOperatorSecrets `json:"secrets,omitempty"`
}

// AssignProperties_From_HcpOpenShiftClusterOperatorSpec populates our HcpOpenShiftClusterOperatorSpec from the provided source HcpOpenShiftClusterOperatorSpec
func (operator *HcpOpenShiftClusterOperatorSpec) AssignProperties_From_HcpOpenShiftClusterOperatorSpec(source *storage.HcpOpenShiftClusterOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// Secrets
	if source.Secrets != nil {
		var secret HcpOpenShiftClusterOperatorSecrets
		err := secret.AssignProperties_From_HcpOpenShiftClusterOperatorSecrets(source.Secrets)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_HcpOpenShiftClusterOperatorSecrets() to populate field Secrets")
		}
		operator.Secrets = &secret
	} else {
		operator.Secrets = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftClusterOperatorSpec populates the provided destination HcpOpenShiftClusterOperatorSpec from our HcpOpenShiftClusterOperatorSpec
func (operator *HcpOpenShiftClusterOperatorSpec) AssignProperties_To_HcpOpenShiftClusterOperatorSpec(destination *storage.HcpOpenShiftClusterOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Secrets
	if operator.Secrets != nil {
		var secret storage.HcpOpenShiftClusterOperatorSecrets
		err := operator.Secrets.AssignProperties_To_HcpOpenShiftClusterOperatorSecrets(&secret)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_HcpOpenShiftClusterOperatorSecrets() to populate field Secrets")
		}
		destination.Secrets = &secret
	} else {
		destination.Secrets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// HCP cluster properties
type HcpOpenShiftClusterProperties struct {
	// Api: Shows the cluster API server profile
	Api *ApiProfile `json:"api,omitempty"`

	// Autoscaling: Configure ClusterAutoscaling .
	Autoscaling *ClusterAutoscalingProfile `json:"autoscaling,omitempty"`

	// ClusterImageRegistry: OpenShift internal image registry
	ClusterImageRegistry *ClusterImageRegistryProfile `json:"clusterImageRegistry,omitempty"`

	// Dns: Cluster DNS configuration
	Dns *DnsProfile `json:"dns,omitempty"`

	// Etcd: Configure ETCD.
	Etcd *EtcdProfile `json:"etcd,omitempty"`

	// Network: Cluster network configuration
	Network *NetworkProfile `json:"network,omitempty"`

	// +kubebuilder:validation:Maximum=10080
	// +kubebuilder:validation:Minimum=0
	// NodeDrainTimeoutMinutes: nodeDrainTimeoutMinutes is the grace period for how long Pod Disruption Budget-protected
	// workloads will be
	// respected during any node draining operation. After this grace period, any workloads protected by Pod Disruption
	// Budgets that have not been successfully drained from a node will be forcibly evicted. This is
	// especially relevant to cluster upgrades.
	// Valid values are in minutes and from 0 to 10080 minutes (1 week).
	// 0 means that the MachinePool can be drained without any time limitation.
	// This is the value is used a default for all NodePools. It can be overridden
	// by specifying nodeDrainTimeoutMinutes for a given NodePool
	NodeDrainTimeoutMinutes *int `json:"nodeDrainTimeoutMinutes,omitempty"`

	// +kubebuilder:validation:Required
	// Platform: Azure platform configuration
	Platform *PlatformProfile `json:"platform,omitempty"`

	// Version: Version of the control plane components
	Version *VersionProfile `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &HcpOpenShiftClusterProperties{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (properties *HcpOpenShiftClusterProperties) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if properties == nil {
		return nil, nil
	}
	result := &arm.HcpOpenShiftClusterProperties{}

	// Set property "Api":
	if properties.Api != nil {
		api_ARM, err := properties.Api.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		api := *api_ARM.(*arm.ApiProfile)
		result.Api = &api
	}

	// Set property "Autoscaling":
	if properties.Autoscaling != nil {
		autoscaling_ARM, err := properties.Autoscaling.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		autoscaling := *autoscaling_ARM.(*arm.ClusterAutoscalingProfile)
		result.Autoscaling = &autoscaling
	}

	// Set property "ClusterImageRegistry":
	if properties.ClusterImageRegistry != nil {
		clusterImageRegistry_ARM, err := properties.ClusterImageRegistry.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		clusterImageRegistry := *clusterImageRegistry_ARM.(*arm.ClusterImageRegistryProfile)
		result.ClusterImageRegistry = &clusterImageRegistry
	}

	// Set property "Dns":
	if properties.Dns != nil {
		dns_ARM, err := properties.Dns.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dns := *dns_ARM.(*arm.DnsProfile)
		result.Dns = &dns
	}

	// Set property "Etcd":
	if properties.Etcd != nil {
		etcd_ARM, err := properties.Etcd.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		etcd := *etcd_ARM.(*arm.EtcdProfile)
		result.Etcd = &etcd
	}

	// Set property "Network":
	if properties.Network != nil {
		network_ARM, err := properties.Network.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		network := *network_ARM.(*arm.NetworkProfile)
		result.Network = &network
	}

	// Set property "NodeDrainTimeoutMinutes":
	if properties.NodeDrainTimeoutMinutes != nil {
		nodeDrainTimeoutMinutes := *properties.NodeDrainTimeoutMinutes
		result.NodeDrainTimeoutMinutes = &nodeDrainTimeoutMinutes
	}

	// Set property "Platform":
	if properties.Platform != nil {
		platform_ARM, err := properties.Platform.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		platform := *platform_ARM.(*arm.PlatformProfile)
		result.Platform = &platform
	}

	// Set property "Version":
	if properties.Version != nil {
		version_ARM, err := properties.Version.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		version := *version_ARM.(*arm.VersionProfile)
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *HcpOpenShiftClusterProperties) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HcpOpenShiftClusterProperties{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *HcpOpenShiftClusterProperties) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HcpOpenShiftClusterProperties)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HcpOpenShiftClusterProperties, got %T", armInput)
	}

	// Set property "Api":
	if typedInput.Api != nil {
		var api1 ApiProfile
		err := api1.PopulateFromARM(owner, *typedInput.Api)
		if err != nil {
			return err
		}
		api := api1
		properties.Api = &api
	}

	// Set property "Autoscaling":
	if typedInput.Autoscaling != nil {
		var autoscaling1 ClusterAutoscalingProfile
		err := autoscaling1.PopulateFromARM(owner, *typedInput.Autoscaling)
		if err != nil {
			return err
		}
		autoscaling := autoscaling1
		properties.Autoscaling = &autoscaling
	}

	// Set property "ClusterImageRegistry":
	if typedInput.ClusterImageRegistry != nil {
		var clusterImageRegistry1 ClusterImageRegistryProfile
		err := clusterImageRegistry1.PopulateFromARM(owner, *typedInput.ClusterImageRegistry)
		if err != nil {
			return err
		}
		clusterImageRegistry := clusterImageRegistry1
		properties.ClusterImageRegistry = &clusterImageRegistry
	}

	// Set property "Dns":
	if typedInput.Dns != nil {
		var dns1 DnsProfile
		err := dns1.PopulateFromARM(owner, *typedInput.Dns)
		if err != nil {
			return err
		}
		dns := dns1
		properties.Dns = &dns
	}

	// Set property "Etcd":
	if typedInput.Etcd != nil {
		var etcd1 EtcdProfile
		err := etcd1.PopulateFromARM(owner, *typedInput.Etcd)
		if err != nil {
			return err
		}
		etcd := etcd1
		properties.Etcd = &etcd
	}

	// Set property "Network":
	if typedInput.Network != nil {
		var network1 NetworkProfile
		err := network1.PopulateFromARM(owner, *typedInput.Network)
		if err != nil {
			return err
		}
		network := network1
		properties.Network = &network
	}

	// Set property "NodeDrainTimeoutMinutes":
	if typedInput.NodeDrainTimeoutMinutes != nil {
		nodeDrainTimeoutMinutes := *typedInput.NodeDrainTimeoutMinutes
		properties.NodeDrainTimeoutMinutes = &nodeDrainTimeoutMinutes
	}

	// Set property "Platform":
	if typedInput.Platform != nil {
		var platform1 PlatformProfile
		err := platform1.PopulateFromARM(owner, *typedInput.Platform)
		if err != nil {
			return err
		}
		platform := platform1
		properties.Platform = &platform
	}

	// Set property "Version":
	if typedInput.Version != nil {
		var version1 VersionProfile
		err := version1.PopulateFromARM(owner, *typedInput.Version)
		if err != nil {
			return err
		}
		version := version1
		properties.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_HcpOpenShiftClusterProperties populates our HcpOpenShiftClusterProperties from the provided source HcpOpenShiftClusterProperties
func (properties *HcpOpenShiftClusterProperties) AssignProperties_From_HcpOpenShiftClusterProperties(source *storage.HcpOpenShiftClusterProperties) error {

	// Api
	if source.Api != nil {
		var api ApiProfile
		err := api.AssignProperties_From_ApiProfile(source.Api)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ApiProfile() to populate field Api")
		}
		properties.Api = &api
	} else {
		properties.Api = nil
	}

	// Autoscaling
	if source.Autoscaling != nil {
		var autoscaling ClusterAutoscalingProfile
		err := autoscaling.AssignProperties_From_ClusterAutoscalingProfile(source.Autoscaling)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClusterAutoscalingProfile() to populate field Autoscaling")
		}
		properties.Autoscaling = &autoscaling
	} else {
		properties.Autoscaling = nil
	}

	// ClusterImageRegistry
	if source.ClusterImageRegistry != nil {
		var clusterImageRegistry ClusterImageRegistryProfile
		err := clusterImageRegistry.AssignProperties_From_ClusterImageRegistryProfile(source.ClusterImageRegistry)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClusterImageRegistryProfile() to populate field ClusterImageRegistry")
		}
		properties.ClusterImageRegistry = &clusterImageRegistry
	} else {
		properties.ClusterImageRegistry = nil
	}

	// Dns
	if source.Dns != nil {
		var dnsDNS DnsProfile
		err := dnsDNS.AssignProperties_From_DnsProfile(source.Dns)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DnsProfile() to populate field Dns")
		}
		properties.Dns = &dnsDNS
	} else {
		properties.Dns = nil
	}

	// Etcd
	if source.Etcd != nil {
		var etcd EtcdProfile
		err := etcd.AssignProperties_From_EtcdProfile(source.Etcd)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EtcdProfile() to populate field Etcd")
		}
		properties.Etcd = &etcd
	} else {
		properties.Etcd = nil
	}

	// Network
	if source.Network != nil {
		var network NetworkProfile
		err := network.AssignProperties_From_NetworkProfile(source.Network)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkProfile() to populate field Network")
		}
		properties.Network = &network
	} else {
		properties.Network = nil
	}

	// NodeDrainTimeoutMinutes
	properties.NodeDrainTimeoutMinutes = genruntime.ClonePointerToInt(source.NodeDrainTimeoutMinutes)

	// Platform
	if source.Platform != nil {
		var platform PlatformProfile
		err := platform.AssignProperties_From_PlatformProfile(source.Platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_PlatformProfile() to populate field Platform")
		}
		properties.Platform = &platform
	} else {
		properties.Platform = nil
	}

	// Version
	if source.Version != nil {
		var version VersionProfile
		err := version.AssignProperties_From_VersionProfile(source.Version)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VersionProfile() to populate field Version")
		}
		properties.Version = &version
	} else {
		properties.Version = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftClusterProperties populates the provided destination HcpOpenShiftClusterProperties from our HcpOpenShiftClusterProperties
func (properties *HcpOpenShiftClusterProperties) AssignProperties_To_HcpOpenShiftClusterProperties(destination *storage.HcpOpenShiftClusterProperties) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Api
	if properties.Api != nil {
		var api storage.ApiProfile
		err := properties.Api.AssignProperties_To_ApiProfile(&api)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ApiProfile() to populate field Api")
		}
		destination.Api = &api
	} else {
		destination.Api = nil
	}

	// Autoscaling
	if properties.Autoscaling != nil {
		var autoscaling storage.ClusterAutoscalingProfile
		err := properties.Autoscaling.AssignProperties_To_ClusterAutoscalingProfile(&autoscaling)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClusterAutoscalingProfile() to populate field Autoscaling")
		}
		destination.Autoscaling = &autoscaling
	} else {
		destination.Autoscaling = nil
	}

	// ClusterImageRegistry
	if properties.ClusterImageRegistry != nil {
		var clusterImageRegistry storage.ClusterImageRegistryProfile
		err := properties.ClusterImageRegistry.AssignProperties_To_ClusterImageRegistryProfile(&clusterImageRegistry)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClusterImageRegistryProfile() to populate field ClusterImageRegistry")
		}
		destination.ClusterImageRegistry = &clusterImageRegistry
	} else {
		destination.ClusterImageRegistry = nil
	}

	// Dns
	if properties.Dns != nil {
		var dnsDNS storage.DnsProfile
		err := properties.Dns.AssignProperties_To_DnsProfile(&dnsDNS)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DnsProfile() to populate field Dns")
		}
		destination.Dns = &dnsDNS
	} else {
		destination.Dns = nil
	}

	// Etcd
	if properties.Etcd != nil {
		var etcd storage.EtcdProfile
		err := properties.Etcd.AssignProperties_To_EtcdProfile(&etcd)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EtcdProfile() to populate field Etcd")
		}
		destination.Etcd = &etcd
	} else {
		destination.Etcd = nil
	}

	// Network
	if properties.Network != nil {
		var network storage.NetworkProfile
		err := properties.Network.AssignProperties_To_NetworkProfile(&network)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkProfile() to populate field Network")
		}
		destination.Network = &network
	} else {
		destination.Network = nil
	}

	// NodeDrainTimeoutMinutes
	destination.NodeDrainTimeoutMinutes = genruntime.ClonePointerToInt(properties.NodeDrainTimeoutMinutes)

	// Platform
	if properties.Platform != nil {
		var platform storage.PlatformProfile
		err := properties.Platform.AssignProperties_To_PlatformProfile(&platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_PlatformProfile() to populate field Platform")
		}
		destination.Platform = &platform
	} else {
		destination.Platform = nil
	}

	// Version
	if properties.Version != nil {
		var version storage.VersionProfile
		err := properties.Version.AssignProperties_To_VersionProfile(&version)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VersionProfile() to populate field Version")
		}
		destination.Version = &version
	} else {
		destination.Version = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HcpOpenShiftClusterProperties_STATUS populates our HcpOpenShiftClusterProperties from the provided source HcpOpenShiftClusterProperties_STATUS
func (properties *HcpOpenShiftClusterProperties) Initialize_From_HcpOpenShiftClusterProperties_STATUS(source *HcpOpenShiftClusterProperties_STATUS) error {

	// Api
	if source.Api != nil {
		var api ApiProfile
		err := api.Initialize_From_ApiProfile_STATUS(source.Api)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ApiProfile_STATUS() to populate field Api")
		}
		properties.Api = &api
	} else {
		properties.Api = nil
	}

	// Autoscaling
	if source.Autoscaling != nil {
		var autoscaling ClusterAutoscalingProfile
		err := autoscaling.Initialize_From_ClusterAutoscalingProfile_STATUS(source.Autoscaling)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ClusterAutoscalingProfile_STATUS() to populate field Autoscaling")
		}
		properties.Autoscaling = &autoscaling
	} else {
		properties.Autoscaling = nil
	}

	// ClusterImageRegistry
	if source.ClusterImageRegistry != nil {
		var clusterImageRegistry ClusterImageRegistryProfile
		err := clusterImageRegistry.Initialize_From_ClusterImageRegistryProfile_STATUS(source.ClusterImageRegistry)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ClusterImageRegistryProfile_STATUS() to populate field ClusterImageRegistry")
		}
		properties.ClusterImageRegistry = &clusterImageRegistry
	} else {
		properties.ClusterImageRegistry = nil
	}

	// Dns
	if source.Dns != nil {
		var dnsDNS DnsProfile
		err := dnsDNS.Initialize_From_DnsProfile_STATUS(source.Dns)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_DnsProfile_STATUS() to populate field Dns")
		}
		properties.Dns = &dnsDNS
	} else {
		properties.Dns = nil
	}

	// Etcd
	if source.Etcd != nil {
		var etcd EtcdProfile
		err := etcd.Initialize_From_EtcdProfile_STATUS(source.Etcd)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EtcdProfile_STATUS() to populate field Etcd")
		}
		properties.Etcd = &etcd
	} else {
		properties.Etcd = nil
	}

	// Network
	if source.Network != nil {
		var network NetworkProfile
		err := network.Initialize_From_NetworkProfile_STATUS(source.Network)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_NetworkProfile_STATUS() to populate field Network")
		}
		properties.Network = &network
	} else {
		properties.Network = nil
	}

	// NodeDrainTimeoutMinutes
	properties.NodeDrainTimeoutMinutes = genruntime.ClonePointerToInt(source.NodeDrainTimeoutMinutes)

	// Platform
	if source.Platform != nil {
		var platform PlatformProfile
		err := platform.Initialize_From_PlatformProfile_STATUS(source.Platform)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_PlatformProfile_STATUS() to populate field Platform")
		}
		properties.Platform = &platform
	} else {
		properties.Platform = nil
	}

	// Version
	if source.Version != nil {
		var version VersionProfile
		err := version.Initialize_From_VersionProfile_STATUS(source.Version)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_VersionProfile_STATUS() to populate field Version")
		}
		properties.Version = &version
	} else {
		properties.Version = nil
	}

	// No error
	return nil
}

// HCP cluster properties
type HcpOpenShiftClusterProperties_STATUS struct {
	// Api: Shows the cluster API server profile
	Api *ApiProfile_STATUS `json:"api,omitempty"`

	// Autoscaling: Configure ClusterAutoscaling .
	Autoscaling *ClusterAutoscalingProfile_STATUS `json:"autoscaling,omitempty"`

	// ClusterImageRegistry: OpenShift internal image registry
	ClusterImageRegistry *ClusterImageRegistryProfile_STATUS `json:"clusterImageRegistry,omitempty"`

	// Console: Shows the cluster web console information
	Console *ConsoleProfile_STATUS `json:"console,omitempty"`

	// Dns: Cluster DNS configuration
	Dns *DnsProfile_STATUS `json:"dns,omitempty"`

	// Etcd: Configure ETCD.
	Etcd *EtcdProfile_STATUS `json:"etcd,omitempty"`

	// Network: Cluster network configuration
	Network *NetworkProfile_STATUS `json:"network,omitempty"`

	// NodeDrainTimeoutMinutes: nodeDrainTimeoutMinutes is the grace period for how long Pod Disruption Budget-protected
	// workloads will be
	// respected during any node draining operation. After this grace period, any workloads protected by Pod Disruption
	// Budgets that have not been successfully drained from a node will be forcibly evicted. This is
	// especially relevant to cluster upgrades.
	// Valid values are in minutes and from 0 to 10080 minutes (1 week).
	// 0 means that the MachinePool can be drained without any time limitation.
	// This is the value is used a default for all NodePools. It can be overridden
	// by specifying nodeDrainTimeoutMinutes for a given NodePool
	NodeDrainTimeoutMinutes *int `json:"nodeDrainTimeoutMinutes,omitempty"`

	// Platform: Azure platform configuration
	Platform *PlatformProfile_STATUS `json:"platform,omitempty"`

	// ProvisioningState: The status of the last operation.
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// Version: Version of the control plane components
	Version *VersionProfile_STATUS `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &HcpOpenShiftClusterProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *HcpOpenShiftClusterProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.HcpOpenShiftClusterProperties_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *HcpOpenShiftClusterProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.HcpOpenShiftClusterProperties_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.HcpOpenShiftClusterProperties_STATUS, got %T", armInput)
	}

	// Set property "Api":
	if typedInput.Api != nil {
		var api1 ApiProfile_STATUS
		err := api1.PopulateFromARM(owner, *typedInput.Api)
		if err != nil {
			return err
		}
		api := api1
		properties.Api = &api
	}

	// Set property "Autoscaling":
	if typedInput.Autoscaling != nil {
		var autoscaling1 ClusterAutoscalingProfile_STATUS
		err := autoscaling1.PopulateFromARM(owner, *typedInput.Autoscaling)
		if err != nil {
			return err
		}
		autoscaling := autoscaling1
		properties.Autoscaling = &autoscaling
	}

	// Set property "ClusterImageRegistry":
	if typedInput.ClusterImageRegistry != nil {
		var clusterImageRegistry1 ClusterImageRegistryProfile_STATUS
		err := clusterImageRegistry1.PopulateFromARM(owner, *typedInput.ClusterImageRegistry)
		if err != nil {
			return err
		}
		clusterImageRegistry := clusterImageRegistry1
		properties.ClusterImageRegistry = &clusterImageRegistry
	}

	// Set property "Console":
	if typedInput.Console != nil {
		var console1 ConsoleProfile_STATUS
		err := console1.PopulateFromARM(owner, *typedInput.Console)
		if err != nil {
			return err
		}
		console := console1
		properties.Console = &console
	}

	// Set property "Dns":
	if typedInput.Dns != nil {
		var dns1 DnsProfile_STATUS
		err := dns1.PopulateFromARM(owner, *typedInput.Dns)
		if err != nil {
			return err
		}
		dns := dns1
		properties.Dns = &dns
	}

	// Set property "Etcd":
	if typedInput.Etcd != nil {
		var etcd1 EtcdProfile_STATUS
		err := etcd1.PopulateFromARM(owner, *typedInput.Etcd)
		if err != nil {
			return err
		}
		etcd := etcd1
		properties.Etcd = &etcd
	}

	// Set property "Network":
	if typedInput.Network != nil {
		var network1 NetworkProfile_STATUS
		err := network1.PopulateFromARM(owner, *typedInput.Network)
		if err != nil {
			return err
		}
		network := network1
		properties.Network = &network
	}

	// Set property "NodeDrainTimeoutMinutes":
	if typedInput.NodeDrainTimeoutMinutes != nil {
		nodeDrainTimeoutMinutes := *typedInput.NodeDrainTimeoutMinutes
		properties.NodeDrainTimeoutMinutes = &nodeDrainTimeoutMinutes
	}

	// Set property "Platform":
	if typedInput.Platform != nil {
		var platform1 PlatformProfile_STATUS
		err := platform1.PopulateFromARM(owner, *typedInput.Platform)
		if err != nil {
			return err
		}
		platform := platform1
		properties.Platform = &platform
	}

	// Set property "ProvisioningState":
	if typedInput.ProvisioningState != nil {
		var temp string
		temp = string(*typedInput.ProvisioningState)
		provisioningState := ProvisioningState_STATUS(temp)
		properties.ProvisioningState = &provisioningState
	}

	// Set property "Version":
	if typedInput.Version != nil {
		var version1 VersionProfile_STATUS
		err := version1.PopulateFromARM(owner, *typedInput.Version)
		if err != nil {
			return err
		}
		version := version1
		properties.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_HcpOpenShiftClusterProperties_STATUS populates our HcpOpenShiftClusterProperties_STATUS from the provided source HcpOpenShiftClusterProperties_STATUS
func (properties *HcpOpenShiftClusterProperties_STATUS) AssignProperties_From_HcpOpenShiftClusterProperties_STATUS(source *storage.HcpOpenShiftClusterProperties_STATUS) error {

	// Api
	if source.Api != nil {
		var api ApiProfile_STATUS
		err := api.AssignProperties_From_ApiProfile_STATUS(source.Api)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ApiProfile_STATUS() to populate field Api")
		}
		properties.Api = &api
	} else {
		properties.Api = nil
	}

	// Autoscaling
	if source.Autoscaling != nil {
		var autoscaling ClusterAutoscalingProfile_STATUS
		err := autoscaling.AssignProperties_From_ClusterAutoscalingProfile_STATUS(source.Autoscaling)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClusterAutoscalingProfile_STATUS() to populate field Autoscaling")
		}
		properties.Autoscaling = &autoscaling
	} else {
		properties.Autoscaling = nil
	}

	// ClusterImageRegistry
	if source.ClusterImageRegistry != nil {
		var clusterImageRegistry ClusterImageRegistryProfile_STATUS
		err := clusterImageRegistry.AssignProperties_From_ClusterImageRegistryProfile_STATUS(source.ClusterImageRegistry)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClusterImageRegistryProfile_STATUS() to populate field ClusterImageRegistry")
		}
		properties.ClusterImageRegistry = &clusterImageRegistry
	} else {
		properties.ClusterImageRegistry = nil
	}

	// Console
	if source.Console != nil {
		var console ConsoleProfile_STATUS
		err := console.AssignProperties_From_ConsoleProfile_STATUS(source.Console)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ConsoleProfile_STATUS() to populate field Console")
		}
		properties.Console = &console
	} else {
		properties.Console = nil
	}

	// Dns
	if source.Dns != nil {
		var dnsDNS DnsProfile_STATUS
		err := dnsDNS.AssignProperties_From_DnsProfile_STATUS(source.Dns)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_DnsProfile_STATUS() to populate field Dns")
		}
		properties.Dns = &dnsDNS
	} else {
		properties.Dns = nil
	}

	// Etcd
	if source.Etcd != nil {
		var etcd EtcdProfile_STATUS
		err := etcd.AssignProperties_From_EtcdProfile_STATUS(source.Etcd)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EtcdProfile_STATUS() to populate field Etcd")
		}
		properties.Etcd = &etcd
	} else {
		properties.Etcd = nil
	}

	// Network
	if source.Network != nil {
		var network NetworkProfile_STATUS
		err := network.AssignProperties_From_NetworkProfile_STATUS(source.Network)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_NetworkProfile_STATUS() to populate field Network")
		}
		properties.Network = &network
	} else {
		properties.Network = nil
	}

	// NodeDrainTimeoutMinutes
	properties.NodeDrainTimeoutMinutes = genruntime.ClonePointerToInt(source.NodeDrainTimeoutMinutes)

	// Platform
	if source.Platform != nil {
		var platform PlatformProfile_STATUS
		err := platform.AssignProperties_From_PlatformProfile_STATUS(source.Platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_PlatformProfile_STATUS() to populate field Platform")
		}
		properties.Platform = &platform
	} else {
		properties.Platform = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, provisioningState_STATUS_Values)
		properties.ProvisioningState = &provisioningStateTemp
	} else {
		properties.ProvisioningState = nil
	}

	// Version
	if source.Version != nil {
		var version VersionProfile_STATUS
		err := version.AssignProperties_From_VersionProfile_STATUS(source.Version)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_VersionProfile_STATUS() to populate field Version")
		}
		properties.Version = &version
	} else {
		properties.Version = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftClusterProperties_STATUS populates the provided destination HcpOpenShiftClusterProperties_STATUS from our HcpOpenShiftClusterProperties_STATUS
func (properties *HcpOpenShiftClusterProperties_STATUS) AssignProperties_To_HcpOpenShiftClusterProperties_STATUS(destination *storage.HcpOpenShiftClusterProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Api
	if properties.Api != nil {
		var api storage.ApiProfile_STATUS
		err := properties.Api.AssignProperties_To_ApiProfile_STATUS(&api)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ApiProfile_STATUS() to populate field Api")
		}
		destination.Api = &api
	} else {
		destination.Api = nil
	}

	// Autoscaling
	if properties.Autoscaling != nil {
		var autoscaling storage.ClusterAutoscalingProfile_STATUS
		err := properties.Autoscaling.AssignProperties_To_ClusterAutoscalingProfile_STATUS(&autoscaling)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClusterAutoscalingProfile_STATUS() to populate field Autoscaling")
		}
		destination.Autoscaling = &autoscaling
	} else {
		destination.Autoscaling = nil
	}

	// ClusterImageRegistry
	if properties.ClusterImageRegistry != nil {
		var clusterImageRegistry storage.ClusterImageRegistryProfile_STATUS
		err := properties.ClusterImageRegistry.AssignProperties_To_ClusterImageRegistryProfile_STATUS(&clusterImageRegistry)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClusterImageRegistryProfile_STATUS() to populate field ClusterImageRegistry")
		}
		destination.ClusterImageRegistry = &clusterImageRegistry
	} else {
		destination.ClusterImageRegistry = nil
	}

	// Console
	if properties.Console != nil {
		var console storage.ConsoleProfile_STATUS
		err := properties.Console.AssignProperties_To_ConsoleProfile_STATUS(&console)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ConsoleProfile_STATUS() to populate field Console")
		}
		destination.Console = &console
	} else {
		destination.Console = nil
	}

	// Dns
	if properties.Dns != nil {
		var dnsDNS storage.DnsProfile_STATUS
		err := properties.Dns.AssignProperties_To_DnsProfile_STATUS(&dnsDNS)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_DnsProfile_STATUS() to populate field Dns")
		}
		destination.Dns = &dnsDNS
	} else {
		destination.Dns = nil
	}

	// Etcd
	if properties.Etcd != nil {
		var etcd storage.EtcdProfile_STATUS
		err := properties.Etcd.AssignProperties_To_EtcdProfile_STATUS(&etcd)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EtcdProfile_STATUS() to populate field Etcd")
		}
		destination.Etcd = &etcd
	} else {
		destination.Etcd = nil
	}

	// Network
	if properties.Network != nil {
		var network storage.NetworkProfile_STATUS
		err := properties.Network.AssignProperties_To_NetworkProfile_STATUS(&network)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_NetworkProfile_STATUS() to populate field Network")
		}
		destination.Network = &network
	} else {
		destination.Network = nil
	}

	// NodeDrainTimeoutMinutes
	destination.NodeDrainTimeoutMinutes = genruntime.ClonePointerToInt(properties.NodeDrainTimeoutMinutes)

	// Platform
	if properties.Platform != nil {
		var platform storage.PlatformProfile_STATUS
		err := properties.Platform.AssignProperties_To_PlatformProfile_STATUS(&platform)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_PlatformProfile_STATUS() to populate field Platform")
		}
		destination.Platform = &platform
	} else {
		destination.Platform = nil
	}

	// ProvisioningState
	if properties.ProvisioningState != nil {
		provisioningState := string(*properties.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Version
	if properties.Version != nil {
		var version storage.VersionProfile_STATUS
		err := properties.Version.AssignProperties_To_VersionProfile_STATUS(&version)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_VersionProfile_STATUS() to populate field Version")
		}
		destination.Version = &version
	} else {
		destination.Version = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity struct {
	// +kubebuilder:validation:Required
	// Type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type *ManagedServiceIdentityType `json:"type,omitempty"`

	// UserAssignedIdentities: The set of user assigned identities associated with the resource. The userAssignedIdentities
	// dictionary keys will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
	// The dictionary values can be empty objects ({}) in requests.
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedServiceIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedServiceIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ManagedServiceIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.ManagedServiceIdentityType(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentityType(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_From_ManagedServiceIdentity(source *storage.ManagedServiceIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentityType_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity populates the provided destination ManagedServiceIdentity from our ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_To_ManagedServiceIdentity(destination *storage.ManagedServiceIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity) Initialize_From_ManagedServiceIdentity_STATUS(source *ManagedServiceIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), managedServiceIdentityType_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity_STATUS struct {
	// PrincipalId: The service principal ID of the system assigned identity. This property will only be provided for a system
	// assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant ID of the system assigned identity. This property will only be provided for a system assigned
	// identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type *ManagedServiceIdentityType_STATUS `json:"type,omitempty"`

	// UserAssignedIdentities: The set of user assigned identities associated with the resource. The userAssignedIdentities
	// dictionary keys will be ARM resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}.
	// The dictionary values can be empty objects ({}) in requests.
	UserAssignedIdentities map[string]UserAssignedIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentityType_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]UserAssignedIdentity_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 UserAssignedIdentity_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity_STATUS from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_From_ManagedServiceIdentity_STATUS(source *storage.ManagedServiceIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentityType_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]UserAssignedIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			var userAssignedIdentity UserAssignedIdentity_STATUS
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentity_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity_STATUS populates the provided destination ManagedServiceIdentity_STATUS from our ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_To_ManagedServiceIdentity_STATUS(destination *storage.ManagedServiceIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.UserAssignedIdentity_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			var userAssignedIdentity storage.UserAssignedIdentity_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_UserAssignedIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Metadata pertaining to creation and last modification of the resource.
type SystemData_STATUS struct {
	// CreatedAt: The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty"`

	// CreatedBy: The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// CreatedByType: The type of identity that created the resource.
	CreatedByType *SystemData_CreatedByType_STATUS `json:"createdByType,omitempty"`

	// LastModifiedAt: The timestamp of resource last modification (UTC)
	LastModifiedAt *string `json:"lastModifiedAt,omitempty"`

	// LastModifiedBy: The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// LastModifiedByType: The type of identity that last modified the resource.
	LastModifiedByType *SystemData_LastModifiedByType_STATUS `json:"lastModifiedByType,omitempty"`
}

var _ genruntime.FromARMConverter = &SystemData_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (data *SystemData_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.SystemData_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (data *SystemData_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.SystemData_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.SystemData_STATUS, got %T", armInput)
	}

	// Set property "CreatedAt":
	if typedInput.CreatedAt != nil {
		createdAt := *typedInput.CreatedAt
		data.CreatedAt = &createdAt
	}

	// Set property "CreatedBy":
	if typedInput.CreatedBy != nil {
		createdBy := *typedInput.CreatedBy
		data.CreatedBy = &createdBy
	}

	// Set property "CreatedByType":
	if typedInput.CreatedByType != nil {
		var temp string
		temp = string(*typedInput.CreatedByType)
		createdByType := SystemData_CreatedByType_STATUS(temp)
		data.CreatedByType = &createdByType
	}

	// Set property "LastModifiedAt":
	if typedInput.LastModifiedAt != nil {
		lastModifiedAt := *typedInput.LastModifiedAt
		data.LastModifiedAt = &lastModifiedAt
	}

	// Set property "LastModifiedBy":
	if typedInput.LastModifiedBy != nil {
		lastModifiedBy := *typedInput.LastModifiedBy
		data.LastModifiedBy = &lastModifiedBy
	}

	// Set property "LastModifiedByType":
	if typedInput.LastModifiedByType != nil {
		var temp string
		temp = string(*typedInput.LastModifiedByType)
		lastModifiedByType := SystemData_LastModifiedByType_STATUS(temp)
		data.LastModifiedByType = &lastModifiedByType
	}

	// No error
	return nil
}

// AssignProperties_From_SystemData_STATUS populates our SystemData_STATUS from the provided source SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_From_SystemData_STATUS(source *storage.SystemData_STATUS) error {

	// CreatedAt
	data.CreatedAt = genruntime.ClonePointerToString(source.CreatedAt)

	// CreatedBy
	data.CreatedBy = genruntime.ClonePointerToString(source.CreatedBy)

	// CreatedByType
	if source.CreatedByType != nil {
		createdByType := *source.CreatedByType
		createdByTypeTemp := genruntime.ToEnum(createdByType, systemData_CreatedByType_STATUS_Values)
		data.CreatedByType = &createdByTypeTemp
	} else {
		data.CreatedByType = nil
	}

	// LastModifiedAt
	data.LastModifiedAt = genruntime.ClonePointerToString(source.LastModifiedAt)

	// LastModifiedBy
	data.LastModifiedBy = genruntime.ClonePointerToString(source.LastModifiedBy)

	// LastModifiedByType
	if source.LastModifiedByType != nil {
		lastModifiedByType := *source.LastModifiedByType
		lastModifiedByTypeTemp := genruntime.ToEnum(lastModifiedByType, systemData_LastModifiedByType_STATUS_Values)
		data.LastModifiedByType = &lastModifiedByTypeTemp
	} else {
		data.LastModifiedByType = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SystemData_STATUS populates the provided destination SystemData_STATUS from our SystemData_STATUS
func (data *SystemData_STATUS) AssignProperties_To_SystemData_STATUS(destination *storage.SystemData_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreatedAt
	destination.CreatedAt = genruntime.ClonePointerToString(data.CreatedAt)

	// CreatedBy
	destination.CreatedBy = genruntime.ClonePointerToString(data.CreatedBy)

	// CreatedByType
	if data.CreatedByType != nil {
		createdByType := string(*data.CreatedByType)
		destination.CreatedByType = &createdByType
	} else {
		destination.CreatedByType = nil
	}

	// LastModifiedAt
	destination.LastModifiedAt = genruntime.ClonePointerToString(data.LastModifiedAt)

	// LastModifiedBy
	destination.LastModifiedBy = genruntime.ClonePointerToString(data.LastModifiedBy)

	// LastModifiedByType
	if data.LastModifiedByType != nil {
		lastModifiedByType := string(*data.LastModifiedByType)
		destination.LastModifiedByType = &lastModifiedByType
	} else {
		destination.LastModifiedByType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the API of a cluster.
type ApiProfile struct {
	// +kubebuilder:validation:MaxItems=500
	// AuthorizedCidrs: The list of authorized IPv4 CIDR blocks allowed to access the API server. Maximum 500 entries.
	AuthorizedCidrs []string `json:"authorizedCidrs,omitempty"`

	// Visibility: The internet visibility of the OpenShift API server
	Visibility *ApiProfile_Visibility `json:"visibility,omitempty"`
}

var _ genruntime.ARMTransformer = &ApiProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ApiProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ApiProfile{}

	// Set property "AuthorizedCidrs":
	for _, item := range profile.AuthorizedCidrs {
		result.AuthorizedCidrs = append(result.AuthorizedCidrs, item)
	}

	// Set property "Visibility":
	if profile.Visibility != nil {
		var temp string
		temp = string(*profile.Visibility)
		visibility := arm.ApiProfile_Visibility(temp)
		result.Visibility = &visibility
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ApiProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApiProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ApiProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApiProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApiProfile, got %T", armInput)
	}

	// Set property "AuthorizedCidrs":
	for _, item := range typedInput.AuthorizedCidrs {
		profile.AuthorizedCidrs = append(profile.AuthorizedCidrs, item)
	}

	// Set property "Visibility":
	if typedInput.Visibility != nil {
		var temp string
		temp = string(*typedInput.Visibility)
		visibility := ApiProfile_Visibility(temp)
		profile.Visibility = &visibility
	}

	// No error
	return nil
}

// AssignProperties_From_ApiProfile populates our ApiProfile from the provided source ApiProfile
func (profile *ApiProfile) AssignProperties_From_ApiProfile(source *storage.ApiProfile) error {

	// AuthorizedCidrs
	profile.AuthorizedCidrs = genruntime.CloneSliceOfString(source.AuthorizedCidrs)

	// Visibility
	if source.Visibility != nil {
		visibility := *source.Visibility
		visibilityTemp := genruntime.ToEnum(visibility, apiProfile_Visibility_Values)
		profile.Visibility = &visibilityTemp
	} else {
		profile.Visibility = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApiProfile populates the provided destination ApiProfile from our ApiProfile
func (profile *ApiProfile) AssignProperties_To_ApiProfile(destination *storage.ApiProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthorizedCidrs
	destination.AuthorizedCidrs = genruntime.CloneSliceOfString(profile.AuthorizedCidrs)

	// Visibility
	if profile.Visibility != nil {
		visibility := string(*profile.Visibility)
		destination.Visibility = &visibility
	} else {
		destination.Visibility = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ApiProfile_STATUS populates our ApiProfile from the provided source ApiProfile_STATUS
func (profile *ApiProfile) Initialize_From_ApiProfile_STATUS(source *ApiProfile_STATUS) error {

	// AuthorizedCidrs
	profile.AuthorizedCidrs = genruntime.CloneSliceOfString(source.AuthorizedCidrs)

	// Visibility
	if source.Visibility != nil {
		visibility := genruntime.ToEnum(string(*source.Visibility), apiProfile_Visibility_Values)
		profile.Visibility = &visibility
	} else {
		profile.Visibility = nil
	}

	// No error
	return nil
}

// Information about the API of a cluster.
type ApiProfile_STATUS struct {
	// AuthorizedCidrs: The list of authorized IPv4 CIDR blocks allowed to access the API server. Maximum 500 entries.
	AuthorizedCidrs []string `json:"authorizedCidrs,omitempty"`

	// Url: URL endpoint for the API server
	Url *string `json:"url,omitempty"`

	// Visibility: The internet visibility of the OpenShift API server
	Visibility *ApiProfile_Visibility_STATUS `json:"visibility,omitempty"`
}

var _ genruntime.FromARMConverter = &ApiProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ApiProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ApiProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ApiProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ApiProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ApiProfile_STATUS, got %T", armInput)
	}

	// Set property "AuthorizedCidrs":
	for _, item := range typedInput.AuthorizedCidrs {
		profile.AuthorizedCidrs = append(profile.AuthorizedCidrs, item)
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		profile.Url = &url
	}

	// Set property "Visibility":
	if typedInput.Visibility != nil {
		var temp string
		temp = string(*typedInput.Visibility)
		visibility := ApiProfile_Visibility_STATUS(temp)
		profile.Visibility = &visibility
	}

	// No error
	return nil
}

// AssignProperties_From_ApiProfile_STATUS populates our ApiProfile_STATUS from the provided source ApiProfile_STATUS
func (profile *ApiProfile_STATUS) AssignProperties_From_ApiProfile_STATUS(source *storage.ApiProfile_STATUS) error {

	// AuthorizedCidrs
	profile.AuthorizedCidrs = genruntime.CloneSliceOfString(source.AuthorizedCidrs)

	// Url
	profile.Url = genruntime.ClonePointerToString(source.Url)

	// Visibility
	if source.Visibility != nil {
		visibility := *source.Visibility
		visibilityTemp := genruntime.ToEnum(visibility, apiProfile_Visibility_STATUS_Values)
		profile.Visibility = &visibilityTemp
	} else {
		profile.Visibility = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ApiProfile_STATUS populates the provided destination ApiProfile_STATUS from our ApiProfile_STATUS
func (profile *ApiProfile_STATUS) AssignProperties_To_ApiProfile_STATUS(destination *storage.ApiProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthorizedCidrs
	destination.AuthorizedCidrs = genruntime.CloneSliceOfString(profile.AuthorizedCidrs)

	// Url
	destination.Url = genruntime.ClonePointerToString(profile.Url)

	// Visibility
	if profile.Visibility != nil {
		visibility := string(*profile.Visibility)
		destination.Visibility = &visibility
	} else {
		destination.Visibility = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// ClusterAutoscaling specifies auto-scaling behavior that
// applies to all NodePools associated with a control plane.
type ClusterAutoscalingProfile struct {
	// +kubebuilder:validation:Minimum=0
	// MaxNodeProvisionTimeSeconds: maxNodeProvisionTimeSeconds is the maximum time to wait for node provisioning before
	// considering the
	// provisioning to be unsuccessful. The default is 900 seconds, or 15 minutes.
	MaxNodeProvisionTimeSeconds *int `json:"maxNodeProvisionTimeSeconds,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// MaxNodesTotal: maxNodesTotal is the maximum allowable number of nodes for the Autoscaler scale out to be operational.
	// The autoscaler will not grow the cluster beyond this number. If omitted, the autoscaler will not have a maximum limit.
	MaxNodesTotal *int `json:"maxNodesTotal,omitempty"`

	// +kubebuilder:validation:Minimum=0
	// MaxPodGracePeriodSeconds: maxPodGracePeriod is the maximum seconds to wait for graceful pod termination before scaling
	// down a NodePool.
	// The default is 600 seconds.
	MaxPodGracePeriodSeconds *int `json:"maxPodGracePeriodSeconds,omitempty"`

	// PodPriorityThreshold: podPriorityThreshold enables users to schedule “best-effort” pods, which shouldn’t trigger
	// autoscaler actions,
	// but only run when there are spare resources available. The default is -10.
	// See the following for more details:
	// https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-does-cluster-autoscaler-work-with-pod-priority-and-preemption
	PodPriorityThreshold *int `json:"podPriorityThreshold,omitempty"`
}

var _ genruntime.ARMTransformer = &ClusterAutoscalingProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ClusterAutoscalingProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ClusterAutoscalingProfile{}

	// Set property "MaxNodeProvisionTimeSeconds":
	if profile.MaxNodeProvisionTimeSeconds != nil {
		maxNodeProvisionTimeSeconds := *profile.MaxNodeProvisionTimeSeconds
		result.MaxNodeProvisionTimeSeconds = &maxNodeProvisionTimeSeconds
	}

	// Set property "MaxNodesTotal":
	if profile.MaxNodesTotal != nil {
		maxNodesTotal := *profile.MaxNodesTotal
		result.MaxNodesTotal = &maxNodesTotal
	}

	// Set property "MaxPodGracePeriodSeconds":
	if profile.MaxPodGracePeriodSeconds != nil {
		maxPodGracePeriodSeconds := *profile.MaxPodGracePeriodSeconds
		result.MaxPodGracePeriodSeconds = &maxPodGracePeriodSeconds
	}

	// Set property "PodPriorityThreshold":
	if profile.PodPriorityThreshold != nil {
		podPriorityThreshold := *profile.PodPriorityThreshold
		result.PodPriorityThreshold = &podPriorityThreshold
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ClusterAutoscalingProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClusterAutoscalingProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ClusterAutoscalingProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClusterAutoscalingProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClusterAutoscalingProfile, got %T", armInput)
	}

	// Set property "MaxNodeProvisionTimeSeconds":
	if typedInput.MaxNodeProvisionTimeSeconds != nil {
		maxNodeProvisionTimeSeconds := *typedInput.MaxNodeProvisionTimeSeconds
		profile.MaxNodeProvisionTimeSeconds = &maxNodeProvisionTimeSeconds
	}

	// Set property "MaxNodesTotal":
	if typedInput.MaxNodesTotal != nil {
		maxNodesTotal := *typedInput.MaxNodesTotal
		profile.MaxNodesTotal = &maxNodesTotal
	}

	// Set property "MaxPodGracePeriodSeconds":
	if typedInput.MaxPodGracePeriodSeconds != nil {
		maxPodGracePeriodSeconds := *typedInput.MaxPodGracePeriodSeconds
		profile.MaxPodGracePeriodSeconds = &maxPodGracePeriodSeconds
	}

	// Set property "PodPriorityThreshold":
	if typedInput.PodPriorityThreshold != nil {
		podPriorityThreshold := *typedInput.PodPriorityThreshold
		profile.PodPriorityThreshold = &podPriorityThreshold
	}

	// No error
	return nil
}

// AssignProperties_From_ClusterAutoscalingProfile populates our ClusterAutoscalingProfile from the provided source ClusterAutoscalingProfile
func (profile *ClusterAutoscalingProfile) AssignProperties_From_ClusterAutoscalingProfile(source *storage.ClusterAutoscalingProfile) error {

	// MaxNodeProvisionTimeSeconds
	profile.MaxNodeProvisionTimeSeconds = genruntime.ClonePointerToInt(source.MaxNodeProvisionTimeSeconds)

	// MaxNodesTotal
	profile.MaxNodesTotal = genruntime.ClonePointerToInt(source.MaxNodesTotal)

	// MaxPodGracePeriodSeconds
	profile.MaxPodGracePeriodSeconds = genruntime.ClonePointerToInt(source.MaxPodGracePeriodSeconds)

	// PodPriorityThreshold
	profile.PodPriorityThreshold = genruntime.ClonePointerToInt(source.PodPriorityThreshold)

	// No error
	return nil
}

// AssignProperties_To_ClusterAutoscalingProfile populates the provided destination ClusterAutoscalingProfile from our ClusterAutoscalingProfile
func (profile *ClusterAutoscalingProfile) AssignProperties_To_ClusterAutoscalingProfile(destination *storage.ClusterAutoscalingProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxNodeProvisionTimeSeconds
	destination.MaxNodeProvisionTimeSeconds = genruntime.ClonePointerToInt(profile.MaxNodeProvisionTimeSeconds)

	// MaxNodesTotal
	destination.MaxNodesTotal = genruntime.ClonePointerToInt(profile.MaxNodesTotal)

	// MaxPodGracePeriodSeconds
	destination.MaxPodGracePeriodSeconds = genruntime.ClonePointerToInt(profile.MaxPodGracePeriodSeconds)

	// PodPriorityThreshold
	destination.PodPriorityThreshold = genruntime.ClonePointerToInt(profile.PodPriorityThreshold)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ClusterAutoscalingProfile_STATUS populates our ClusterAutoscalingProfile from the provided source ClusterAutoscalingProfile_STATUS
func (profile *ClusterAutoscalingProfile) Initialize_From_ClusterAutoscalingProfile_STATUS(source *ClusterAutoscalingProfile_STATUS) error {

	// MaxNodeProvisionTimeSeconds
	profile.MaxNodeProvisionTimeSeconds = genruntime.ClonePointerToInt(source.MaxNodeProvisionTimeSeconds)

	// MaxNodesTotal
	profile.MaxNodesTotal = genruntime.ClonePointerToInt(source.MaxNodesTotal)

	// MaxPodGracePeriodSeconds
	profile.MaxPodGracePeriodSeconds = genruntime.ClonePointerToInt(source.MaxPodGracePeriodSeconds)

	// PodPriorityThreshold
	profile.PodPriorityThreshold = genruntime.ClonePointerToInt(source.PodPriorityThreshold)

	// No error
	return nil
}

// ClusterAutoscaling specifies auto-scaling behavior that
// applies to all NodePools associated with a control plane.
type ClusterAutoscalingProfile_STATUS struct {
	// MaxNodeProvisionTimeSeconds: maxNodeProvisionTimeSeconds is the maximum time to wait for node provisioning before
	// considering the
	// provisioning to be unsuccessful. The default is 900 seconds, or 15 minutes.
	MaxNodeProvisionTimeSeconds *int `json:"maxNodeProvisionTimeSeconds,omitempty"`

	// MaxNodesTotal: maxNodesTotal is the maximum allowable number of nodes for the Autoscaler scale out to be operational.
	// The autoscaler will not grow the cluster beyond this number. If omitted, the autoscaler will not have a maximum limit.
	MaxNodesTotal *int `json:"maxNodesTotal,omitempty"`

	// MaxPodGracePeriodSeconds: maxPodGracePeriod is the maximum seconds to wait for graceful pod termination before scaling
	// down a NodePool.
	// The default is 600 seconds.
	MaxPodGracePeriodSeconds *int `json:"maxPodGracePeriodSeconds,omitempty"`

	// PodPriorityThreshold: podPriorityThreshold enables users to schedule “best-effort” pods, which shouldn’t trigger
	// autoscaler actions,
	// but only run when there are spare resources available. The default is -10.
	// See the following for more details:
	// https://github.com/kubernetes/autoscaler/blob/master/cluster-autoscaler/FAQ.md#how-does-cluster-autoscaler-work-with-pod-priority-and-preemption
	PodPriorityThreshold *int `json:"podPriorityThreshold,omitempty"`
}

var _ genruntime.FromARMConverter = &ClusterAutoscalingProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ClusterAutoscalingProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClusterAutoscalingProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ClusterAutoscalingProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClusterAutoscalingProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClusterAutoscalingProfile_STATUS, got %T", armInput)
	}

	// Set property "MaxNodeProvisionTimeSeconds":
	if typedInput.MaxNodeProvisionTimeSeconds != nil {
		maxNodeProvisionTimeSeconds := *typedInput.MaxNodeProvisionTimeSeconds
		profile.MaxNodeProvisionTimeSeconds = &maxNodeProvisionTimeSeconds
	}

	// Set property "MaxNodesTotal":
	if typedInput.MaxNodesTotal != nil {
		maxNodesTotal := *typedInput.MaxNodesTotal
		profile.MaxNodesTotal = &maxNodesTotal
	}

	// Set property "MaxPodGracePeriodSeconds":
	if typedInput.MaxPodGracePeriodSeconds != nil {
		maxPodGracePeriodSeconds := *typedInput.MaxPodGracePeriodSeconds
		profile.MaxPodGracePeriodSeconds = &maxPodGracePeriodSeconds
	}

	// Set property "PodPriorityThreshold":
	if typedInput.PodPriorityThreshold != nil {
		podPriorityThreshold := *typedInput.PodPriorityThreshold
		profile.PodPriorityThreshold = &podPriorityThreshold
	}

	// No error
	return nil
}

// AssignProperties_From_ClusterAutoscalingProfile_STATUS populates our ClusterAutoscalingProfile_STATUS from the provided source ClusterAutoscalingProfile_STATUS
func (profile *ClusterAutoscalingProfile_STATUS) AssignProperties_From_ClusterAutoscalingProfile_STATUS(source *storage.ClusterAutoscalingProfile_STATUS) error {

	// MaxNodeProvisionTimeSeconds
	profile.MaxNodeProvisionTimeSeconds = genruntime.ClonePointerToInt(source.MaxNodeProvisionTimeSeconds)

	// MaxNodesTotal
	profile.MaxNodesTotal = genruntime.ClonePointerToInt(source.MaxNodesTotal)

	// MaxPodGracePeriodSeconds
	profile.MaxPodGracePeriodSeconds = genruntime.ClonePointerToInt(source.MaxPodGracePeriodSeconds)

	// PodPriorityThreshold
	profile.PodPriorityThreshold = genruntime.ClonePointerToInt(source.PodPriorityThreshold)

	// No error
	return nil
}

// AssignProperties_To_ClusterAutoscalingProfile_STATUS populates the provided destination ClusterAutoscalingProfile_STATUS from our ClusterAutoscalingProfile_STATUS
func (profile *ClusterAutoscalingProfile_STATUS) AssignProperties_To_ClusterAutoscalingProfile_STATUS(destination *storage.ClusterAutoscalingProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MaxNodeProvisionTimeSeconds
	destination.MaxNodeProvisionTimeSeconds = genruntime.ClonePointerToInt(profile.MaxNodeProvisionTimeSeconds)

	// MaxNodesTotal
	destination.MaxNodesTotal = genruntime.ClonePointerToInt(profile.MaxNodesTotal)

	// MaxPodGracePeriodSeconds
	destination.MaxPodGracePeriodSeconds = genruntime.ClonePointerToInt(profile.MaxPodGracePeriodSeconds)

	// PodPriorityThreshold
	destination.PodPriorityThreshold = genruntime.ClonePointerToInt(profile.PodPriorityThreshold)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OpenShift cluster image registry
type ClusterImageRegistryProfile struct {
	// State: state indicates the desired ImageStream-backed cluster image registry installation mode.
	// This can only be set during cluster creation and cannot be changed after cluster creation.
	// Enabled means the ImageStream-backed image registry will be run as pods on worker nodes in
	// the cluster. Disabled means the ImageStream-backed image registry will not be present in
	// the cluster. The default is Enabled.
	State *ClusterImageRegistryProfile_State `json:"state,omitempty"`
}

var _ genruntime.ARMTransformer = &ClusterImageRegistryProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *ClusterImageRegistryProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.ClusterImageRegistryProfile{}

	// Set property "State":
	if profile.State != nil {
		var temp string
		temp = string(*profile.State)
		state := arm.ClusterImageRegistryProfile_State(temp)
		result.State = &state
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ClusterImageRegistryProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClusterImageRegistryProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ClusterImageRegistryProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClusterImageRegistryProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClusterImageRegistryProfile, got %T", armInput)
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := ClusterImageRegistryProfile_State(temp)
		profile.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_ClusterImageRegistryProfile populates our ClusterImageRegistryProfile from the provided source ClusterImageRegistryProfile
func (profile *ClusterImageRegistryProfile) AssignProperties_From_ClusterImageRegistryProfile(source *storage.ClusterImageRegistryProfile) error {

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, clusterImageRegistryProfile_State_Values)
		profile.State = &stateTemp
	} else {
		profile.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ClusterImageRegistryProfile populates the provided destination ClusterImageRegistryProfile from our ClusterImageRegistryProfile
func (profile *ClusterImageRegistryProfile) AssignProperties_To_ClusterImageRegistryProfile(destination *storage.ClusterImageRegistryProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// State
	if profile.State != nil {
		state := string(*profile.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ClusterImageRegistryProfile_STATUS populates our ClusterImageRegistryProfile from the provided source ClusterImageRegistryProfile_STATUS
func (profile *ClusterImageRegistryProfile) Initialize_From_ClusterImageRegistryProfile_STATUS(source *ClusterImageRegistryProfile_STATUS) error {

	// State
	if source.State != nil {
		state := genruntime.ToEnum(string(*source.State), clusterImageRegistryProfile_State_Values)
		profile.State = &state
	} else {
		profile.State = nil
	}

	// No error
	return nil
}

// OpenShift cluster image registry
type ClusterImageRegistryProfile_STATUS struct {
	// State: state indicates the desired ImageStream-backed cluster image registry installation mode.
	// This can only be set during cluster creation and cannot be changed after cluster creation.
	// Enabled means the ImageStream-backed image registry will be run as pods on worker nodes in
	// the cluster. Disabled means the ImageStream-backed image registry will not be present in
	// the cluster. The default is Enabled.
	State *ClusterImageRegistryProfile_State_STATUS `json:"state,omitempty"`
}

var _ genruntime.FromARMConverter = &ClusterImageRegistryProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ClusterImageRegistryProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClusterImageRegistryProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ClusterImageRegistryProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClusterImageRegistryProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClusterImageRegistryProfile_STATUS, got %T", armInput)
	}

	// Set property "State":
	if typedInput.State != nil {
		var temp string
		temp = string(*typedInput.State)
		state := ClusterImageRegistryProfile_State_STATUS(temp)
		profile.State = &state
	}

	// No error
	return nil
}

// AssignProperties_From_ClusterImageRegistryProfile_STATUS populates our ClusterImageRegistryProfile_STATUS from the provided source ClusterImageRegistryProfile_STATUS
func (profile *ClusterImageRegistryProfile_STATUS) AssignProperties_From_ClusterImageRegistryProfile_STATUS(source *storage.ClusterImageRegistryProfile_STATUS) error {

	// State
	if source.State != nil {
		state := *source.State
		stateTemp := genruntime.ToEnum(state, clusterImageRegistryProfile_State_STATUS_Values)
		profile.State = &stateTemp
	} else {
		profile.State = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ClusterImageRegistryProfile_STATUS populates the provided destination ClusterImageRegistryProfile_STATUS from our ClusterImageRegistryProfile_STATUS
func (profile *ClusterImageRegistryProfile_STATUS) AssignProperties_To_ClusterImageRegistryProfile_STATUS(destination *storage.ClusterImageRegistryProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// State
	if profile.State != nil {
		state := string(*profile.State)
		destination.State = &state
	} else {
		destination.State = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Configuration of the cluster web console
type ConsoleProfile_STATUS struct {
	// Url: The cluster web console URL endpoint
	Url *string `json:"url,omitempty"`
}

var _ genruntime.FromARMConverter = &ConsoleProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *ConsoleProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ConsoleProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *ConsoleProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ConsoleProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ConsoleProfile_STATUS, got %T", armInput)
	}

	// Set property "Url":
	if typedInput.Url != nil {
		url := *typedInput.Url
		profile.Url = &url
	}

	// No error
	return nil
}

// AssignProperties_From_ConsoleProfile_STATUS populates our ConsoleProfile_STATUS from the provided source ConsoleProfile_STATUS
func (profile *ConsoleProfile_STATUS) AssignProperties_From_ConsoleProfile_STATUS(source *storage.ConsoleProfile_STATUS) error {

	// Url
	profile.Url = genruntime.ClonePointerToString(source.Url)

	// No error
	return nil
}

// AssignProperties_To_ConsoleProfile_STATUS populates the provided destination ConsoleProfile_STATUS from our ConsoleProfile_STATUS
func (profile *ConsoleProfile_STATUS) AssignProperties_To_ConsoleProfile_STATUS(destination *storage.ConsoleProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Url
	destination.Url = genruntime.ClonePointerToString(profile.Url)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// DNS contains the DNS settings of the cluster
type DnsProfile struct {
	// +kubebuilder:validation:MaxLength=15
	// +kubebuilder:validation:Pattern="^[a-z]([-a-z0-9]*[a-z0-9])?$"
	// BaseDomainPrefix: BaseDomainPrefix is the unique name of the cluster representing the OpenShift's cluster name.
	// BaseDomainPrefix is the name that will appear in the cluster's DNS, provisioned cloud providers resources
	BaseDomainPrefix *string `json:"baseDomainPrefix,omitempty"`
}

var _ genruntime.ARMTransformer = &DnsProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *DnsProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.DnsProfile{}

	// Set property "BaseDomainPrefix":
	if profile.BaseDomainPrefix != nil {
		baseDomainPrefix := *profile.BaseDomainPrefix
		result.BaseDomainPrefix = &baseDomainPrefix
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *DnsProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DnsProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *DnsProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DnsProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DnsProfile, got %T", armInput)
	}

	// Set property "BaseDomainPrefix":
	if typedInput.BaseDomainPrefix != nil {
		baseDomainPrefix := *typedInput.BaseDomainPrefix
		profile.BaseDomainPrefix = &baseDomainPrefix
	}

	// No error
	return nil
}

// AssignProperties_From_DnsProfile populates our DnsProfile from the provided source DnsProfile
func (profile *DnsProfile) AssignProperties_From_DnsProfile(source *storage.DnsProfile) error {

	// BaseDomainPrefix
	profile.BaseDomainPrefix = genruntime.ClonePointerToString(source.BaseDomainPrefix)

	// No error
	return nil
}

// AssignProperties_To_DnsProfile populates the provided destination DnsProfile from our DnsProfile
func (profile *DnsProfile) AssignProperties_To_DnsProfile(destination *storage.DnsProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BaseDomainPrefix
	destination.BaseDomainPrefix = genruntime.ClonePointerToString(profile.BaseDomainPrefix)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DnsProfile_STATUS populates our DnsProfile from the provided source DnsProfile_STATUS
func (profile *DnsProfile) Initialize_From_DnsProfile_STATUS(source *DnsProfile_STATUS) error {

	// BaseDomainPrefix
	profile.BaseDomainPrefix = genruntime.ClonePointerToString(source.BaseDomainPrefix)

	// No error
	return nil
}

// DNS contains the DNS settings of the cluster
type DnsProfile_STATUS struct {
	// BaseDomain: BaseDomain is the base DNS domain of the cluster.
	BaseDomain *string `json:"baseDomain,omitempty"`

	// BaseDomainPrefix: BaseDomainPrefix is the unique name of the cluster representing the OpenShift's cluster name.
	// BaseDomainPrefix is the name that will appear in the cluster's DNS, provisioned cloud providers resources
	BaseDomainPrefix *string `json:"baseDomainPrefix,omitempty"`
}

var _ genruntime.FromARMConverter = &DnsProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *DnsProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.DnsProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *DnsProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.DnsProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.DnsProfile_STATUS, got %T", armInput)
	}

	// Set property "BaseDomain":
	if typedInput.BaseDomain != nil {
		baseDomain := *typedInput.BaseDomain
		profile.BaseDomain = &baseDomain
	}

	// Set property "BaseDomainPrefix":
	if typedInput.BaseDomainPrefix != nil {
		baseDomainPrefix := *typedInput.BaseDomainPrefix
		profile.BaseDomainPrefix = &baseDomainPrefix
	}

	// No error
	return nil
}

// AssignProperties_From_DnsProfile_STATUS populates our DnsProfile_STATUS from the provided source DnsProfile_STATUS
func (profile *DnsProfile_STATUS) AssignProperties_From_DnsProfile_STATUS(source *storage.DnsProfile_STATUS) error {

	// BaseDomain
	profile.BaseDomain = genruntime.ClonePointerToString(source.BaseDomain)

	// BaseDomainPrefix
	profile.BaseDomainPrefix = genruntime.ClonePointerToString(source.BaseDomainPrefix)

	// No error
	return nil
}

// AssignProperties_To_DnsProfile_STATUS populates the provided destination DnsProfile_STATUS from our DnsProfile_STATUS
func (profile *DnsProfile_STATUS) AssignProperties_To_DnsProfile_STATUS(destination *storage.DnsProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BaseDomain
	destination.BaseDomain = genruntime.ClonePointerToString(profile.BaseDomain)

	// BaseDomainPrefix
	destination.BaseDomainPrefix = genruntime.ClonePointerToString(profile.BaseDomainPrefix)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The ETCD settings and configuration options.
type EtcdProfile struct {
	// DataEncryption: ETCD Data Encryption settings.
	// If not specified platform managed keys are used.
	DataEncryption *EtcdDataEncryptionProfile `json:"dataEncryption,omitempty"`
}

var _ genruntime.ARMTransformer = &EtcdProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *EtcdProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.EtcdProfile{}

	// Set property "DataEncryption":
	if profile.DataEncryption != nil {
		dataEncryption_ARM, err := profile.DataEncryption.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		dataEncryption := *dataEncryption_ARM.(*arm.EtcdDataEncryptionProfile)
		result.DataEncryption = &dataEncryption
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *EtcdProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EtcdProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *EtcdProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EtcdProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EtcdProfile, got %T", armInput)
	}

	// Set property "DataEncryption":
	if typedInput.DataEncryption != nil {
		var dataEncryption1 EtcdDataEncryptionProfile
		err := dataEncryption1.PopulateFromARM(owner, *typedInput.DataEncryption)
		if err != nil {
			return err
		}
		dataEncryption := dataEncryption1
		profile.DataEncryption = &dataEncryption
	}

	// No error
	return nil
}

// AssignProperties_From_EtcdProfile populates our EtcdProfile from the provided source EtcdProfile
func (profile *EtcdProfile) AssignProperties_From_EtcdProfile(source *storage.EtcdProfile) error {

	// DataEncryption
	if source.DataEncryption != nil {
		var dataEncryption EtcdDataEncryptionProfile
		err := dataEncryption.AssignProperties_From_EtcdDataEncryptionProfile(source.DataEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EtcdDataEncryptionProfile() to populate field DataEncryption")
		}
		profile.DataEncryption = &dataEncryption
	} else {
		profile.DataEncryption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EtcdProfile populates the provided destination EtcdProfile from our EtcdProfile
func (profile *EtcdProfile) AssignProperties_To_EtcdProfile(destination *storage.EtcdProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataEncryption
	if profile.DataEncryption != nil {
		var dataEncryption storage.EtcdDataEncryptionProfile
		err := profile.DataEncryption.AssignProperties_To_EtcdDataEncryptionProfile(&dataEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EtcdDataEncryptionProfile() to populate field DataEncryption")
		}
		destination.DataEncryption = &dataEncryption
	} else {
		destination.DataEncryption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EtcdProfile_STATUS populates our EtcdProfile from the provided source EtcdProfile_STATUS
func (profile *EtcdProfile) Initialize_From_EtcdProfile_STATUS(source *EtcdProfile_STATUS) error {

	// DataEncryption
	if source.DataEncryption != nil {
		var dataEncryption EtcdDataEncryptionProfile
		err := dataEncryption.Initialize_From_EtcdDataEncryptionProfile_STATUS(source.DataEncryption)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_EtcdDataEncryptionProfile_STATUS() to populate field DataEncryption")
		}
		profile.DataEncryption = &dataEncryption
	} else {
		profile.DataEncryption = nil
	}

	// No error
	return nil
}

// The ETCD settings and configuration options.
type EtcdProfile_STATUS struct {
	// DataEncryption: ETCD Data Encryption settings.
	// If not specified platform managed keys are used.
	DataEncryption *EtcdDataEncryptionProfile_STATUS `json:"dataEncryption,omitempty"`
}

var _ genruntime.FromARMConverter = &EtcdProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *EtcdProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EtcdProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *EtcdProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EtcdProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EtcdProfile_STATUS, got %T", armInput)
	}

	// Set property "DataEncryption":
	if typedInput.DataEncryption != nil {
		var dataEncryption1 EtcdDataEncryptionProfile_STATUS
		err := dataEncryption1.PopulateFromARM(owner, *typedInput.DataEncryption)
		if err != nil {
			return err
		}
		dataEncryption := dataEncryption1
		profile.DataEncryption = &dataEncryption
	}

	// No error
	return nil
}

// AssignProperties_From_EtcdProfile_STATUS populates our EtcdProfile_STATUS from the provided source EtcdProfile_STATUS
func (profile *EtcdProfile_STATUS) AssignProperties_From_EtcdProfile_STATUS(source *storage.EtcdProfile_STATUS) error {

	// DataEncryption
	if source.DataEncryption != nil {
		var dataEncryption EtcdDataEncryptionProfile_STATUS
		err := dataEncryption.AssignProperties_From_EtcdDataEncryptionProfile_STATUS(source.DataEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_EtcdDataEncryptionProfile_STATUS() to populate field DataEncryption")
		}
		profile.DataEncryption = &dataEncryption
	} else {
		profile.DataEncryption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EtcdProfile_STATUS populates the provided destination EtcdProfile_STATUS from our EtcdProfile_STATUS
func (profile *EtcdProfile_STATUS) AssignProperties_To_EtcdProfile_STATUS(destination *storage.EtcdProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataEncryption
	if profile.DataEncryption != nil {
		var dataEncryption storage.EtcdDataEncryptionProfile_STATUS
		err := profile.DataEncryption.AssignProperties_To_EtcdDataEncryptionProfile_STATUS(&dataEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_EtcdDataEncryptionProfile_STATUS() to populate field DataEncryption")
		}
		destination.DataEncryption = &dataEncryption
	} else {
		destination.DataEncryption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type HcpOpenShiftClusterOperatorSecrets struct {
	// AdminCredentials: indicates where the AdminCredentials secret should be placed. If omitted, the secret will not be
	// retrieved from Azure.
	AdminCredentials *genruntime.SecretDestination `json:"adminCredentials,omitempty"`
}

// AssignProperties_From_HcpOpenShiftClusterOperatorSecrets populates our HcpOpenShiftClusterOperatorSecrets from the provided source HcpOpenShiftClusterOperatorSecrets
func (secrets *HcpOpenShiftClusterOperatorSecrets) AssignProperties_From_HcpOpenShiftClusterOperatorSecrets(source *storage.HcpOpenShiftClusterOperatorSecrets) error {

	// AdminCredentials
	if source.AdminCredentials != nil {
		adminCredential := source.AdminCredentials.Copy()
		secrets.AdminCredentials = &adminCredential
	} else {
		secrets.AdminCredentials = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HcpOpenShiftClusterOperatorSecrets populates the provided destination HcpOpenShiftClusterOperatorSecrets from our HcpOpenShiftClusterOperatorSecrets
func (secrets *HcpOpenShiftClusterOperatorSecrets) AssignProperties_To_HcpOpenShiftClusterOperatorSecrets(destination *storage.HcpOpenShiftClusterOperatorSecrets) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdminCredentials
	if secrets.AdminCredentials != nil {
		adminCredential := secrets.AdminCredentials.Copy()
		destination.AdminCredentials = &adminCredential
	} else {
		destination.AdminCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned,UserAssigned","UserAssigned"}
type ManagedServiceIdentityType string

const (
	ManagedServiceIdentityType_None                       = ManagedServiceIdentityType("None")
	ManagedServiceIdentityType_SystemAssigned             = ManagedServiceIdentityType("SystemAssigned")
	ManagedServiceIdentityType_SystemAssignedUserAssigned = ManagedServiceIdentityType("SystemAssigned,UserAssigned")
	ManagedServiceIdentityType_UserAssigned               = ManagedServiceIdentityType("UserAssigned")
)

// Mapping from string to ManagedServiceIdentityType
var managedServiceIdentityType_Values = map[string]ManagedServiceIdentityType{
	"none":                        ManagedServiceIdentityType_None,
	"systemassigned":              ManagedServiceIdentityType_SystemAssigned,
	"systemassigned,userassigned": ManagedServiceIdentityType_SystemAssignedUserAssigned,
	"userassigned":                ManagedServiceIdentityType_UserAssigned,
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
type ManagedServiceIdentityType_STATUS string

const (
	ManagedServiceIdentityType_STATUS_None                       = ManagedServiceIdentityType_STATUS("None")
	ManagedServiceIdentityType_STATUS_SystemAssigned             = ManagedServiceIdentityType_STATUS("SystemAssigned")
	ManagedServiceIdentityType_STATUS_SystemAssignedUserAssigned = ManagedServiceIdentityType_STATUS("SystemAssigned,UserAssigned")
	ManagedServiceIdentityType_STATUS_UserAssigned               = ManagedServiceIdentityType_STATUS("UserAssigned")
)

// Mapping from string to ManagedServiceIdentityType_STATUS
var managedServiceIdentityType_STATUS_Values = map[string]ManagedServiceIdentityType_STATUS{
	"none":                        ManagedServiceIdentityType_STATUS_None,
	"systemassigned":              ManagedServiceIdentityType_STATUS_SystemAssigned,
	"systemassigned,userassigned": ManagedServiceIdentityType_STATUS_SystemAssignedUserAssigned,
	"userassigned":                ManagedServiceIdentityType_STATUS_UserAssigned,
}

// OpenShift networking configuration
type NetworkProfile struct {
	// HostPrefix: Network host prefix
	HostPrefix *int `json:"hostPrefix,omitempty"`

	// MachineCidr: The CIDR block from which to assign machine IP addresses
	MachineCidr *string `json:"machineCidr,omitempty"`

	// NetworkType: The main controller responsible for rendering the core networking components
	NetworkType *NetworkProfile_NetworkType `json:"networkType,omitempty"`

	// PodCidr: The CIDR of the pod IP addresses
	PodCidr *string `json:"podCidr,omitempty"`

	// ServiceCidr: The CIDR block for assigned service IPs
	ServiceCidr *string `json:"serviceCidr,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *NetworkProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.NetworkProfile{}

	// Set property "HostPrefix":
	if profile.HostPrefix != nil {
		hostPrefix := *profile.HostPrefix
		result.HostPrefix = &hostPrefix
	}

	// Set property "MachineCidr":
	if profile.MachineCidr != nil {
		machineCidr := *profile.MachineCidr
		result.MachineCidr = &machineCidr
	}

	// Set property "NetworkType":
	if profile.NetworkType != nil {
		var temp string
		temp = string(*profile.NetworkType)
		networkType := arm.NetworkProfile_NetworkType(temp)
		result.NetworkType = &networkType
	}

	// Set property "PodCidr":
	if profile.PodCidr != nil {
		podCidr := *profile.PodCidr
		result.PodCidr = &podCidr
	}

	// Set property "ServiceCidr":
	if profile.ServiceCidr != nil {
		serviceCidr := *profile.ServiceCidr
		result.ServiceCidr = &serviceCidr
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *NetworkProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *NetworkProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkProfile, got %T", armInput)
	}

	// Set property "HostPrefix":
	if typedInput.HostPrefix != nil {
		hostPrefix := *typedInput.HostPrefix
		profile.HostPrefix = &hostPrefix
	}

	// Set property "MachineCidr":
	if typedInput.MachineCidr != nil {
		machineCidr := *typedInput.MachineCidr
		profile.MachineCidr = &machineCidr
	}

	// Set property "NetworkType":
	if typedInput.NetworkType != nil {
		var temp string
		temp = string(*typedInput.NetworkType)
		networkType := NetworkProfile_NetworkType(temp)
		profile.NetworkType = &networkType
	}

	// Set property "PodCidr":
	if typedInput.PodCidr != nil {
		podCidr := *typedInput.PodCidr
		profile.PodCidr = &podCidr
	}

	// Set property "ServiceCidr":
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		profile.ServiceCidr = &serviceCidr
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkProfile populates our NetworkProfile from the provided source NetworkProfile
func (profile *NetworkProfile) AssignProperties_From_NetworkProfile(source *storage.NetworkProfile) error {

	// HostPrefix
	profile.HostPrefix = genruntime.ClonePointerToInt(source.HostPrefix)

	// MachineCidr
	profile.MachineCidr = genruntime.ClonePointerToString(source.MachineCidr)

	// NetworkType
	if source.NetworkType != nil {
		networkType := *source.NetworkType
		networkTypeTemp := genruntime.ToEnum(networkType, networkProfile_NetworkType_Values)
		profile.NetworkType = &networkTypeTemp
	} else {
		profile.NetworkType = nil
	}

	// PodCidr
	profile.PodCidr = genruntime.ClonePointerToString(source.PodCidr)

	// ServiceCidr
	profile.ServiceCidr = genruntime.ClonePointerToString(source.ServiceCidr)

	// No error
	return nil
}

// AssignProperties_To_NetworkProfile populates the provided destination NetworkProfile from our NetworkProfile
func (profile *NetworkProfile) AssignProperties_To_NetworkProfile(destination *storage.NetworkProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HostPrefix
	destination.HostPrefix = genruntime.ClonePointerToInt(profile.HostPrefix)

	// MachineCidr
	destination.MachineCidr = genruntime.ClonePointerToString(profile.MachineCidr)

	// NetworkType
	if profile.NetworkType != nil {
		networkType := string(*profile.NetworkType)
		destination.NetworkType = &networkType
	} else {
		destination.NetworkType = nil
	}

	// PodCidr
	destination.PodCidr = genruntime.ClonePointerToString(profile.PodCidr)

	// ServiceCidr
	destination.ServiceCidr = genruntime.ClonePointerToString(profile.ServiceCidr)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkProfile_STATUS populates our NetworkProfile from the provided source NetworkProfile_STATUS
func (profile *NetworkProfile) Initialize_From_NetworkProfile_STATUS(source *NetworkProfile_STATUS) error {

	// HostPrefix
	profile.HostPrefix = genruntime.ClonePointerToInt(source.HostPrefix)

	// MachineCidr
	profile.MachineCidr = genruntime.ClonePointerToString(source.MachineCidr)

	// NetworkType
	if source.NetworkType != nil {
		networkType := genruntime.ToEnum(string(*source.NetworkType), networkProfile_NetworkType_Values)
		profile.NetworkType = &networkType
	} else {
		profile.NetworkType = nil
	}

	// PodCidr
	profile.PodCidr = genruntime.ClonePointerToString(source.PodCidr)

	// ServiceCidr
	profile.ServiceCidr = genruntime.ClonePointerToString(source.ServiceCidr)

	// No error
	return nil
}

// OpenShift networking configuration
type NetworkProfile_STATUS struct {
	// HostPrefix: Network host prefix
	HostPrefix *int `json:"hostPrefix,omitempty"`

	// MachineCidr: The CIDR block from which to assign machine IP addresses
	MachineCidr *string `json:"machineCidr,omitempty"`

	// NetworkType: The main controller responsible for rendering the core networking components
	NetworkType *NetworkProfile_NetworkType_STATUS `json:"networkType,omitempty"`

	// PodCidr: The CIDR of the pod IP addresses
	PodCidr *string `json:"podCidr,omitempty"`

	// ServiceCidr: The CIDR block for assigned service IPs
	ServiceCidr *string `json:"serviceCidr,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *NetworkProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.NetworkProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *NetworkProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.NetworkProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.NetworkProfile_STATUS, got %T", armInput)
	}

	// Set property "HostPrefix":
	if typedInput.HostPrefix != nil {
		hostPrefix := *typedInput.HostPrefix
		profile.HostPrefix = &hostPrefix
	}

	// Set property "MachineCidr":
	if typedInput.MachineCidr != nil {
		machineCidr := *typedInput.MachineCidr
		profile.MachineCidr = &machineCidr
	}

	// Set property "NetworkType":
	if typedInput.NetworkType != nil {
		var temp string
		temp = string(*typedInput.NetworkType)
		networkType := NetworkProfile_NetworkType_STATUS(temp)
		profile.NetworkType = &networkType
	}

	// Set property "PodCidr":
	if typedInput.PodCidr != nil {
		podCidr := *typedInput.PodCidr
		profile.PodCidr = &podCidr
	}

	// Set property "ServiceCidr":
	if typedInput.ServiceCidr != nil {
		serviceCidr := *typedInput.ServiceCidr
		profile.ServiceCidr = &serviceCidr
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkProfile_STATUS populates our NetworkProfile_STATUS from the provided source NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignProperties_From_NetworkProfile_STATUS(source *storage.NetworkProfile_STATUS) error {

	// HostPrefix
	profile.HostPrefix = genruntime.ClonePointerToInt(source.HostPrefix)

	// MachineCidr
	profile.MachineCidr = genruntime.ClonePointerToString(source.MachineCidr)

	// NetworkType
	if source.NetworkType != nil {
		networkType := *source.NetworkType
		networkTypeTemp := genruntime.ToEnum(networkType, networkProfile_NetworkType_STATUS_Values)
		profile.NetworkType = &networkTypeTemp
	} else {
		profile.NetworkType = nil
	}

	// PodCidr
	profile.PodCidr = genruntime.ClonePointerToString(source.PodCidr)

	// ServiceCidr
	profile.ServiceCidr = genruntime.ClonePointerToString(source.ServiceCidr)

	// No error
	return nil
}

// AssignProperties_To_NetworkProfile_STATUS populates the provided destination NetworkProfile_STATUS from our NetworkProfile_STATUS
func (profile *NetworkProfile_STATUS) AssignProperties_To_NetworkProfile_STATUS(destination *storage.NetworkProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HostPrefix
	destination.HostPrefix = genruntime.ClonePointerToInt(profile.HostPrefix)

	// MachineCidr
	destination.MachineCidr = genruntime.ClonePointerToString(profile.MachineCidr)

	// NetworkType
	if profile.NetworkType != nil {
		networkType := string(*profile.NetworkType)
		destination.NetworkType = &networkType
	} else {
		destination.NetworkType = nil
	}

	// PodCidr
	destination.PodCidr = genruntime.ClonePointerToString(profile.PodCidr)

	// ServiceCidr
	destination.ServiceCidr = genruntime.ClonePointerToString(profile.ServiceCidr)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Azure specific configuration
type PlatformProfile struct {
	// ManagedResourceGroup: Resource group to put cluster resources
	ManagedResourceGroup *string `json:"managedResourceGroup,omitempty"`

	// +kubebuilder:validation:Required
	// NetworkSecurityGroupReference: ResourceId for the NSG (network security group) attached to the cluster subnet
	// Note that NSGs cannot be reused for other ARO-HCP clusters.
	NetworkSecurityGroupReference *genruntime.ResourceReference `armReference:"NetworkSecurityGroupId" json:"networkSecurityGroupReference,omitempty"`

	// +kubebuilder:validation:Required
	// OperatorsAuthentication: The configuration that the operators of the cluster have to authenticate to Azure
	OperatorsAuthentication *OperatorsAuthenticationProfile `json:"operatorsAuthentication,omitempty"`

	// OutboundType: The core outgoing configuration
	OutboundType *PlatformProfile_OutboundType `json:"outboundType,omitempty"`

	// +kubebuilder:validation:Required
	// SubnetReference: The Azure resource ID of the worker subnet
	// Note that a subnet cannot be reused between ARO-HCP Clusters.
	SubnetReference *genruntime.ResourceReference `armReference:"SubnetId" json:"subnetReference,omitempty"`
}

var _ genruntime.ARMTransformer = &PlatformProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *PlatformProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.PlatformProfile{}

	// Set property "ManagedResourceGroup":
	if profile.ManagedResourceGroup != nil {
		managedResourceGroup := *profile.ManagedResourceGroup
		result.ManagedResourceGroup = &managedResourceGroup
	}

	// Set property "NetworkSecurityGroupId":
	if profile.NetworkSecurityGroupReference != nil {
		networkSecurityGroupReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.NetworkSecurityGroupReference)
		if err != nil {
			return nil, err
		}
		networkSecurityGroupReference := networkSecurityGroupReferenceARMID
		result.NetworkSecurityGroupId = &networkSecurityGroupReference
	}

	// Set property "OperatorsAuthentication":
	if profile.OperatorsAuthentication != nil {
		operatorsAuthentication_ARM, err := profile.OperatorsAuthentication.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		operatorsAuthentication := *operatorsAuthentication_ARM.(*arm.OperatorsAuthenticationProfile)
		result.OperatorsAuthentication = &operatorsAuthentication
	}

	// Set property "OutboundType":
	if profile.OutboundType != nil {
		var temp string
		temp = string(*profile.OutboundType)
		outboundType := arm.PlatformProfile_OutboundType(temp)
		result.OutboundType = &outboundType
	}

	// Set property "SubnetId":
	if profile.SubnetReference != nil {
		subnetReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.SubnetReference)
		if err != nil {
			return nil, err
		}
		subnetReference := subnetReferenceARMID
		result.SubnetId = &subnetReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *PlatformProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PlatformProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *PlatformProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PlatformProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PlatformProfile, got %T", armInput)
	}

	// Set property "ManagedResourceGroup":
	if typedInput.ManagedResourceGroup != nil {
		managedResourceGroup := *typedInput.ManagedResourceGroup
		profile.ManagedResourceGroup = &managedResourceGroup
	}

	// no assignment for property "NetworkSecurityGroupReference"

	// Set property "OperatorsAuthentication":
	if typedInput.OperatorsAuthentication != nil {
		var operatorsAuthentication1 OperatorsAuthenticationProfile
		err := operatorsAuthentication1.PopulateFromARM(owner, *typedInput.OperatorsAuthentication)
		if err != nil {
			return err
		}
		operatorsAuthentication := operatorsAuthentication1
		profile.OperatorsAuthentication = &operatorsAuthentication
	}

	// Set property "OutboundType":
	if typedInput.OutboundType != nil {
		var temp string
		temp = string(*typedInput.OutboundType)
		outboundType := PlatformProfile_OutboundType(temp)
		profile.OutboundType = &outboundType
	}

	// no assignment for property "SubnetReference"

	// No error
	return nil
}

// AssignProperties_From_PlatformProfile populates our PlatformProfile from the provided source PlatformProfile
func (profile *PlatformProfile) AssignProperties_From_PlatformProfile(source *storage.PlatformProfile) error {

	// ManagedResourceGroup
	profile.ManagedResourceGroup = genruntime.ClonePointerToString(source.ManagedResourceGroup)

	// NetworkSecurityGroupReference
	if source.NetworkSecurityGroupReference != nil {
		networkSecurityGroupReference := source.NetworkSecurityGroupReference.Copy()
		profile.NetworkSecurityGroupReference = &networkSecurityGroupReference
	} else {
		profile.NetworkSecurityGroupReference = nil
	}

	// OperatorsAuthentication
	if source.OperatorsAuthentication != nil {
		var operatorsAuthentication OperatorsAuthenticationProfile
		err := operatorsAuthentication.AssignProperties_From_OperatorsAuthenticationProfile(source.OperatorsAuthentication)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OperatorsAuthenticationProfile() to populate field OperatorsAuthentication")
		}
		profile.OperatorsAuthentication = &operatorsAuthentication
	} else {
		profile.OperatorsAuthentication = nil
	}

	// OutboundType
	if source.OutboundType != nil {
		outboundType := *source.OutboundType
		outboundTypeTemp := genruntime.ToEnum(outboundType, platformProfile_OutboundType_Values)
		profile.OutboundType = &outboundTypeTemp
	} else {
		profile.OutboundType = nil
	}

	// SubnetReference
	if source.SubnetReference != nil {
		subnetReference := source.SubnetReference.Copy()
		profile.SubnetReference = &subnetReference
	} else {
		profile.SubnetReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PlatformProfile populates the provided destination PlatformProfile from our PlatformProfile
func (profile *PlatformProfile) AssignProperties_To_PlatformProfile(destination *storage.PlatformProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ManagedResourceGroup
	destination.ManagedResourceGroup = genruntime.ClonePointerToString(profile.ManagedResourceGroup)

	// NetworkSecurityGroupReference
	if profile.NetworkSecurityGroupReference != nil {
		networkSecurityGroupReference := profile.NetworkSecurityGroupReference.Copy()
		destination.NetworkSecurityGroupReference = &networkSecurityGroupReference
	} else {
		destination.NetworkSecurityGroupReference = nil
	}

	// OperatorsAuthentication
	if profile.OperatorsAuthentication != nil {
		var operatorsAuthentication storage.OperatorsAuthenticationProfile
		err := profile.OperatorsAuthentication.AssignProperties_To_OperatorsAuthenticationProfile(&operatorsAuthentication)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OperatorsAuthenticationProfile() to populate field OperatorsAuthentication")
		}
		destination.OperatorsAuthentication = &operatorsAuthentication
	} else {
		destination.OperatorsAuthentication = nil
	}

	// OutboundType
	if profile.OutboundType != nil {
		outboundType := string(*profile.OutboundType)
		destination.OutboundType = &outboundType
	} else {
		destination.OutboundType = nil
	}

	// SubnetReference
	if profile.SubnetReference != nil {
		subnetReference := profile.SubnetReference.Copy()
		destination.SubnetReference = &subnetReference
	} else {
		destination.SubnetReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PlatformProfile_STATUS populates our PlatformProfile from the provided source PlatformProfile_STATUS
func (profile *PlatformProfile) Initialize_From_PlatformProfile_STATUS(source *PlatformProfile_STATUS) error {

	// ManagedResourceGroup
	profile.ManagedResourceGroup = genruntime.ClonePointerToString(source.ManagedResourceGroup)

	// NetworkSecurityGroupReference
	if source.NetworkSecurityGroupId != nil {
		networkSecurityGroupReference := genruntime.CreateResourceReferenceFromARMID(*source.NetworkSecurityGroupId)
		profile.NetworkSecurityGroupReference = &networkSecurityGroupReference
	} else {
		profile.NetworkSecurityGroupReference = nil
	}

	// OperatorsAuthentication
	if source.OperatorsAuthentication != nil {
		var operatorsAuthentication OperatorsAuthenticationProfile
		err := operatorsAuthentication.Initialize_From_OperatorsAuthenticationProfile_STATUS(source.OperatorsAuthentication)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_OperatorsAuthenticationProfile_STATUS() to populate field OperatorsAuthentication")
		}
		profile.OperatorsAuthentication = &operatorsAuthentication
	} else {
		profile.OperatorsAuthentication = nil
	}

	// OutboundType
	if source.OutboundType != nil {
		outboundType := genruntime.ToEnum(string(*source.OutboundType), platformProfile_OutboundType_Values)
		profile.OutboundType = &outboundType
	} else {
		profile.OutboundType = nil
	}

	// SubnetReference
	if source.SubnetId != nil {
		subnetReference := genruntime.CreateResourceReferenceFromARMID(*source.SubnetId)
		profile.SubnetReference = &subnetReference
	} else {
		profile.SubnetReference = nil
	}

	// No error
	return nil
}

// Azure specific configuration
type PlatformProfile_STATUS struct {
	// IssuerUrl: URL for the OIDC provider to be used for authentication
	// to authenticate against user Azure cloud account
	IssuerUrl *string `json:"issuerUrl,omitempty"`

	// ManagedResourceGroup: Resource group to put cluster resources
	ManagedResourceGroup *string `json:"managedResourceGroup,omitempty"`

	// NetworkSecurityGroupId: ResourceId for the NSG (network security group) attached to the cluster subnet
	// Note that NSGs cannot be reused for other ARO-HCP clusters.
	NetworkSecurityGroupId *string `json:"networkSecurityGroupId,omitempty"`

	// OperatorsAuthentication: The configuration that the operators of the cluster have to authenticate to Azure
	OperatorsAuthentication *OperatorsAuthenticationProfile_STATUS `json:"operatorsAuthentication,omitempty"`

	// OutboundType: The core outgoing configuration
	OutboundType *PlatformProfile_OutboundType_STATUS `json:"outboundType,omitempty"`

	// SubnetId: The Azure resource ID of the worker subnet
	// Note that a subnet cannot be reused between ARO-HCP Clusters.
	SubnetId *string `json:"subnetId,omitempty"`
}

var _ genruntime.FromARMConverter = &PlatformProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *PlatformProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PlatformProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *PlatformProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PlatformProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PlatformProfile_STATUS, got %T", armInput)
	}

	// Set property "IssuerUrl":
	if typedInput.IssuerUrl != nil {
		issuerUrl := *typedInput.IssuerUrl
		profile.IssuerUrl = &issuerUrl
	}

	// Set property "ManagedResourceGroup":
	if typedInput.ManagedResourceGroup != nil {
		managedResourceGroup := *typedInput.ManagedResourceGroup
		profile.ManagedResourceGroup = &managedResourceGroup
	}

	// Set property "NetworkSecurityGroupId":
	if typedInput.NetworkSecurityGroupId != nil {
		networkSecurityGroupId := *typedInput.NetworkSecurityGroupId
		profile.NetworkSecurityGroupId = &networkSecurityGroupId
	}

	// Set property "OperatorsAuthentication":
	if typedInput.OperatorsAuthentication != nil {
		var operatorsAuthentication1 OperatorsAuthenticationProfile_STATUS
		err := operatorsAuthentication1.PopulateFromARM(owner, *typedInput.OperatorsAuthentication)
		if err != nil {
			return err
		}
		operatorsAuthentication := operatorsAuthentication1
		profile.OperatorsAuthentication = &operatorsAuthentication
	}

	// Set property "OutboundType":
	if typedInput.OutboundType != nil {
		var temp string
		temp = string(*typedInput.OutboundType)
		outboundType := PlatformProfile_OutboundType_STATUS(temp)
		profile.OutboundType = &outboundType
	}

	// Set property "SubnetId":
	if typedInput.SubnetId != nil {
		subnetId := *typedInput.SubnetId
		profile.SubnetId = &subnetId
	}

	// No error
	return nil
}

// AssignProperties_From_PlatformProfile_STATUS populates our PlatformProfile_STATUS from the provided source PlatformProfile_STATUS
func (profile *PlatformProfile_STATUS) AssignProperties_From_PlatformProfile_STATUS(source *storage.PlatformProfile_STATUS) error {

	// IssuerUrl
	profile.IssuerUrl = genruntime.ClonePointerToString(source.IssuerUrl)

	// ManagedResourceGroup
	profile.ManagedResourceGroup = genruntime.ClonePointerToString(source.ManagedResourceGroup)

	// NetworkSecurityGroupId
	profile.NetworkSecurityGroupId = genruntime.ClonePointerToString(source.NetworkSecurityGroupId)

	// OperatorsAuthentication
	if source.OperatorsAuthentication != nil {
		var operatorsAuthentication OperatorsAuthenticationProfile_STATUS
		err := operatorsAuthentication.AssignProperties_From_OperatorsAuthenticationProfile_STATUS(source.OperatorsAuthentication)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_OperatorsAuthenticationProfile_STATUS() to populate field OperatorsAuthentication")
		}
		profile.OperatorsAuthentication = &operatorsAuthentication
	} else {
		profile.OperatorsAuthentication = nil
	}

	// OutboundType
	if source.OutboundType != nil {
		outboundType := *source.OutboundType
		outboundTypeTemp := genruntime.ToEnum(outboundType, platformProfile_OutboundType_STATUS_Values)
		profile.OutboundType = &outboundTypeTemp
	} else {
		profile.OutboundType = nil
	}

	// SubnetId
	profile.SubnetId = genruntime.ClonePointerToString(source.SubnetId)

	// No error
	return nil
}

// AssignProperties_To_PlatformProfile_STATUS populates the provided destination PlatformProfile_STATUS from our PlatformProfile_STATUS
func (profile *PlatformProfile_STATUS) AssignProperties_To_PlatformProfile_STATUS(destination *storage.PlatformProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IssuerUrl
	destination.IssuerUrl = genruntime.ClonePointerToString(profile.IssuerUrl)

	// ManagedResourceGroup
	destination.ManagedResourceGroup = genruntime.ClonePointerToString(profile.ManagedResourceGroup)

	// NetworkSecurityGroupId
	destination.NetworkSecurityGroupId = genruntime.ClonePointerToString(profile.NetworkSecurityGroupId)

	// OperatorsAuthentication
	if profile.OperatorsAuthentication != nil {
		var operatorsAuthentication storage.OperatorsAuthenticationProfile_STATUS
		err := profile.OperatorsAuthentication.AssignProperties_To_OperatorsAuthenticationProfile_STATUS(&operatorsAuthentication)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_OperatorsAuthenticationProfile_STATUS() to populate field OperatorsAuthentication")
		}
		destination.OperatorsAuthentication = &operatorsAuthentication
	} else {
		destination.OperatorsAuthentication = nil
	}

	// OutboundType
	if profile.OutboundType != nil {
		outboundType := string(*profile.OutboundType)
		destination.OutboundType = &outboundType
	} else {
		destination.OutboundType = nil
	}

	// SubnetId
	destination.SubnetId = genruntime.ClonePointerToString(profile.SubnetId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The resource provisioning state.
type ProvisioningState_STATUS string

const (
	ProvisioningState_STATUS_Accepted     = ProvisioningState_STATUS("Accepted")
	ProvisioningState_STATUS_Canceled     = ProvisioningState_STATUS("Canceled")
	ProvisioningState_STATUS_Deleting     = ProvisioningState_STATUS("Deleting")
	ProvisioningState_STATUS_Failed       = ProvisioningState_STATUS("Failed")
	ProvisioningState_STATUS_Provisioning = ProvisioningState_STATUS("Provisioning")
	ProvisioningState_STATUS_Succeeded    = ProvisioningState_STATUS("Succeeded")
	ProvisioningState_STATUS_Updating     = ProvisioningState_STATUS("Updating")
)

// Mapping from string to ProvisioningState_STATUS
var provisioningState_STATUS_Values = map[string]ProvisioningState_STATUS{
	"accepted":     ProvisioningState_STATUS_Accepted,
	"canceled":     ProvisioningState_STATUS_Canceled,
	"deleting":     ProvisioningState_STATUS_Deleting,
	"failed":       ProvisioningState_STATUS_Failed,
	"provisioning": ProvisioningState_STATUS_Provisioning,
	"succeeded":    ProvisioningState_STATUS_Succeeded,
	"updating":     ProvisioningState_STATUS_Updating,
}

type SystemData_CreatedByType_STATUS string

const (
	SystemData_CreatedByType_STATUS_Application     = SystemData_CreatedByType_STATUS("Application")
	SystemData_CreatedByType_STATUS_Key             = SystemData_CreatedByType_STATUS("Key")
	SystemData_CreatedByType_STATUS_ManagedIdentity = SystemData_CreatedByType_STATUS("ManagedIdentity")
	SystemData_CreatedByType_STATUS_User            = SystemData_CreatedByType_STATUS("User")
)

// Mapping from string to SystemData_CreatedByType_STATUS
var systemData_CreatedByType_STATUS_Values = map[string]SystemData_CreatedByType_STATUS{
	"application":     SystemData_CreatedByType_STATUS_Application,
	"key":             SystemData_CreatedByType_STATUS_Key,
	"managedidentity": SystemData_CreatedByType_STATUS_ManagedIdentity,
	"user":            SystemData_CreatedByType_STATUS_User,
}

type SystemData_LastModifiedByType_STATUS string

const (
	SystemData_LastModifiedByType_STATUS_Application     = SystemData_LastModifiedByType_STATUS("Application")
	SystemData_LastModifiedByType_STATUS_Key             = SystemData_LastModifiedByType_STATUS("Key")
	SystemData_LastModifiedByType_STATUS_ManagedIdentity = SystemData_LastModifiedByType_STATUS("ManagedIdentity")
	SystemData_LastModifiedByType_STATUS_User            = SystemData_LastModifiedByType_STATUS("User")
)

// Mapping from string to SystemData_LastModifiedByType_STATUS
var systemData_LastModifiedByType_STATUS_Values = map[string]SystemData_LastModifiedByType_STATUS{
	"application":     SystemData_LastModifiedByType_STATUS_Application,
	"key":             SystemData_LastModifiedByType_STATUS_Key,
	"managedidentity": SystemData_LastModifiedByType_STATUS_ManagedIdentity,
	"user":            SystemData_LastModifiedByType_STATUS_User,
}

// User assigned identity properties
type UserAssignedIdentity_STATUS struct {
	// ClientId: The client ID of the assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal ID of the assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAssignedIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAssignedIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAssignedIdentity_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentity_STATUS populates our UserAssignedIdentity_STATUS from the provided source UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_From_UserAssignedIdentity_STATUS(source *storage.UserAssignedIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentity_STATUS populates the provided destination UserAssignedIdentity_STATUS from our UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_To_UserAssignedIdentity_STATUS(destination *storage.UserAssignedIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Versions represents an OpenShift version.
type VersionProfile struct {
	// ChannelGroup: ChannelGroup is the name of the set to which this version belongs. Each version belongs to only a single
	// set.
	ChannelGroup *string `json:"channelGroup,omitempty"`

	// Id: ID is the unique identifier of the version.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.ARMTransformer = &VersionProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *VersionProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.VersionProfile{}

	// Set property "ChannelGroup":
	if profile.ChannelGroup != nil {
		channelGroup := *profile.ChannelGroup
		result.ChannelGroup = &channelGroup
	}

	// Set property "Id":
	if profile.Id != nil {
		id := *profile.Id
		result.Id = &id
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VersionProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VersionProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VersionProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VersionProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VersionProfile, got %T", armInput)
	}

	// Set property "ChannelGroup":
	if typedInput.ChannelGroup != nil {
		channelGroup := *typedInput.ChannelGroup
		profile.ChannelGroup = &channelGroup
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		profile.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_VersionProfile populates our VersionProfile from the provided source VersionProfile
func (profile *VersionProfile) AssignProperties_From_VersionProfile(source *storage.VersionProfile) error {

	// ChannelGroup
	profile.ChannelGroup = genruntime.ClonePointerToString(source.ChannelGroup)

	// Id
	profile.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_VersionProfile populates the provided destination VersionProfile from our VersionProfile
func (profile *VersionProfile) AssignProperties_To_VersionProfile(destination *storage.VersionProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ChannelGroup
	destination.ChannelGroup = genruntime.ClonePointerToString(profile.ChannelGroup)

	// Id
	destination.Id = genruntime.ClonePointerToString(profile.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_VersionProfile_STATUS populates our VersionProfile from the provided source VersionProfile_STATUS
func (profile *VersionProfile) Initialize_From_VersionProfile_STATUS(source *VersionProfile_STATUS) error {

	// ChannelGroup
	profile.ChannelGroup = genruntime.ClonePointerToString(source.ChannelGroup)

	// Id
	profile.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// Versions represents an OpenShift version.
type VersionProfile_STATUS struct {
	// ChannelGroup: ChannelGroup is the name of the set to which this version belongs. Each version belongs to only a single
	// set.
	ChannelGroup *string `json:"channelGroup,omitempty"`

	// Id: ID is the unique identifier of the version.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &VersionProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *VersionProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.VersionProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *VersionProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.VersionProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.VersionProfile_STATUS, got %T", armInput)
	}

	// Set property "ChannelGroup":
	if typedInput.ChannelGroup != nil {
		channelGroup := *typedInput.ChannelGroup
		profile.ChannelGroup = &channelGroup
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		profile.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_VersionProfile_STATUS populates our VersionProfile_STATUS from the provided source VersionProfile_STATUS
func (profile *VersionProfile_STATUS) AssignProperties_From_VersionProfile_STATUS(source *storage.VersionProfile_STATUS) error {

	// ChannelGroup
	profile.ChannelGroup = genruntime.ClonePointerToString(source.ChannelGroup)

	// Id
	profile.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_VersionProfile_STATUS populates the provided destination VersionProfile_STATUS from our VersionProfile_STATUS
func (profile *VersionProfile_STATUS) AssignProperties_To_VersionProfile_STATUS(destination *storage.VersionProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ChannelGroup
	destination.ChannelGroup = genruntime.ClonePointerToString(profile.ChannelGroup)

	// Id
	destination.Id = genruntime.ClonePointerToString(profile.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Private","Public"}
type ApiProfile_Visibility string

const (
	ApiProfile_Visibility_Private = ApiProfile_Visibility("Private")
	ApiProfile_Visibility_Public  = ApiProfile_Visibility("Public")
)

// Mapping from string to ApiProfile_Visibility
var apiProfile_Visibility_Values = map[string]ApiProfile_Visibility{
	"private": ApiProfile_Visibility_Private,
	"public":  ApiProfile_Visibility_Public,
}

type ApiProfile_Visibility_STATUS string

const (
	ApiProfile_Visibility_STATUS_Private = ApiProfile_Visibility_STATUS("Private")
	ApiProfile_Visibility_STATUS_Public  = ApiProfile_Visibility_STATUS("Public")
)

// Mapping from string to ApiProfile_Visibility_STATUS
var apiProfile_Visibility_STATUS_Values = map[string]ApiProfile_Visibility_STATUS{
	"private": ApiProfile_Visibility_STATUS_Private,
	"public":  ApiProfile_Visibility_STATUS_Public,
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ClusterImageRegistryProfile_State string

const (
	ClusterImageRegistryProfile_State_Disabled = ClusterImageRegistryProfile_State("Disabled")
	ClusterImageRegistryProfile_State_Enabled  = ClusterImageRegistryProfile_State("Enabled")
)

// Mapping from string to ClusterImageRegistryProfile_State
var clusterImageRegistryProfile_State_Values = map[string]ClusterImageRegistryProfile_State{
	"disabled": ClusterImageRegistryProfile_State_Disabled,
	"enabled":  ClusterImageRegistryProfile_State_Enabled,
}

type ClusterImageRegistryProfile_State_STATUS string

const (
	ClusterImageRegistryProfile_State_STATUS_Disabled = ClusterImageRegistryProfile_State_STATUS("Disabled")
	ClusterImageRegistryProfile_State_STATUS_Enabled  = ClusterImageRegistryProfile_State_STATUS("Enabled")
)

// Mapping from string to ClusterImageRegistryProfile_State_STATUS
var clusterImageRegistryProfile_State_STATUS_Values = map[string]ClusterImageRegistryProfile_State_STATUS{
	"disabled": ClusterImageRegistryProfile_State_STATUS_Disabled,
	"enabled":  ClusterImageRegistryProfile_State_STATUS_Enabled,
}

// The ETCD data encryption settings.
type EtcdDataEncryptionProfile struct {
	// CustomerManaged: Specify customer managed encryption key details.
	// Required when keyManagementMode is "CustomerManaged".
	CustomerManaged *CustomerManagedEncryptionProfile `json:"customerManaged,omitempty"`

	// KeyManagementMode: Specify the key management strategy used for the encryption key that encrypts the ETCD data.
	// By default, "PlatformManaged" is used.
	KeyManagementMode *EtcdDataEncryptionProfile_KeyManagementMode `json:"keyManagementMode,omitempty"`
}

var _ genruntime.ARMTransformer = &EtcdDataEncryptionProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *EtcdDataEncryptionProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.EtcdDataEncryptionProfile{}

	// Set property "CustomerManaged":
	if profile.CustomerManaged != nil {
		customerManaged_ARM, err := profile.CustomerManaged.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customerManaged := *customerManaged_ARM.(*arm.CustomerManagedEncryptionProfile)
		result.CustomerManaged = &customerManaged
	}

	// Set property "KeyManagementMode":
	if profile.KeyManagementMode != nil {
		var temp string
		temp = string(*profile.KeyManagementMode)
		keyManagementMode := arm.EtcdDataEncryptionProfile_KeyManagementMode(temp)
		result.KeyManagementMode = &keyManagementMode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *EtcdDataEncryptionProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EtcdDataEncryptionProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *EtcdDataEncryptionProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EtcdDataEncryptionProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EtcdDataEncryptionProfile, got %T", armInput)
	}

	// Set property "CustomerManaged":
	if typedInput.CustomerManaged != nil {
		var customerManaged1 CustomerManagedEncryptionProfile
		err := customerManaged1.PopulateFromARM(owner, *typedInput.CustomerManaged)
		if err != nil {
			return err
		}
		customerManaged := customerManaged1
		profile.CustomerManaged = &customerManaged
	}

	// Set property "KeyManagementMode":
	if typedInput.KeyManagementMode != nil {
		var temp string
		temp = string(*typedInput.KeyManagementMode)
		keyManagementMode := EtcdDataEncryptionProfile_KeyManagementMode(temp)
		profile.KeyManagementMode = &keyManagementMode
	}

	// No error
	return nil
}

// AssignProperties_From_EtcdDataEncryptionProfile populates our EtcdDataEncryptionProfile from the provided source EtcdDataEncryptionProfile
func (profile *EtcdDataEncryptionProfile) AssignProperties_From_EtcdDataEncryptionProfile(source *storage.EtcdDataEncryptionProfile) error {

	// CustomerManaged
	if source.CustomerManaged != nil {
		var customerManaged CustomerManagedEncryptionProfile
		err := customerManaged.AssignProperties_From_CustomerManagedEncryptionProfile(source.CustomerManaged)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CustomerManagedEncryptionProfile() to populate field CustomerManaged")
		}
		profile.CustomerManaged = &customerManaged
	} else {
		profile.CustomerManaged = nil
	}

	// KeyManagementMode
	if source.KeyManagementMode != nil {
		keyManagementMode := *source.KeyManagementMode
		keyManagementModeTemp := genruntime.ToEnum(keyManagementMode, etcdDataEncryptionProfile_KeyManagementMode_Values)
		profile.KeyManagementMode = &keyManagementModeTemp
	} else {
		profile.KeyManagementMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EtcdDataEncryptionProfile populates the provided destination EtcdDataEncryptionProfile from our EtcdDataEncryptionProfile
func (profile *EtcdDataEncryptionProfile) AssignProperties_To_EtcdDataEncryptionProfile(destination *storage.EtcdDataEncryptionProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomerManaged
	if profile.CustomerManaged != nil {
		var customerManaged storage.CustomerManagedEncryptionProfile
		err := profile.CustomerManaged.AssignProperties_To_CustomerManagedEncryptionProfile(&customerManaged)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CustomerManagedEncryptionProfile() to populate field CustomerManaged")
		}
		destination.CustomerManaged = &customerManaged
	} else {
		destination.CustomerManaged = nil
	}

	// KeyManagementMode
	if profile.KeyManagementMode != nil {
		keyManagementMode := string(*profile.KeyManagementMode)
		destination.KeyManagementMode = &keyManagementMode
	} else {
		destination.KeyManagementMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EtcdDataEncryptionProfile_STATUS populates our EtcdDataEncryptionProfile from the provided source EtcdDataEncryptionProfile_STATUS
func (profile *EtcdDataEncryptionProfile) Initialize_From_EtcdDataEncryptionProfile_STATUS(source *EtcdDataEncryptionProfile_STATUS) error {

	// CustomerManaged
	if source.CustomerManaged != nil {
		var customerManaged CustomerManagedEncryptionProfile
		err := customerManaged.Initialize_From_CustomerManagedEncryptionProfile_STATUS(source.CustomerManaged)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_CustomerManagedEncryptionProfile_STATUS() to populate field CustomerManaged")
		}
		profile.CustomerManaged = &customerManaged
	} else {
		profile.CustomerManaged = nil
	}

	// KeyManagementMode
	if source.KeyManagementMode != nil {
		keyManagementMode := genruntime.ToEnum(string(*source.KeyManagementMode), etcdDataEncryptionProfile_KeyManagementMode_Values)
		profile.KeyManagementMode = &keyManagementMode
	} else {
		profile.KeyManagementMode = nil
	}

	// No error
	return nil
}

// The ETCD data encryption settings.
type EtcdDataEncryptionProfile_STATUS struct {
	// CustomerManaged: Specify customer managed encryption key details.
	// Required when keyManagementMode is "CustomerManaged".
	CustomerManaged *CustomerManagedEncryptionProfile_STATUS `json:"customerManaged,omitempty"`

	// KeyManagementMode: Specify the key management strategy used for the encryption key that encrypts the ETCD data.
	// By default, "PlatformManaged" is used.
	KeyManagementMode *EtcdDataEncryptionProfile_KeyManagementMode_STATUS `json:"keyManagementMode,omitempty"`
}

var _ genruntime.FromARMConverter = &EtcdDataEncryptionProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *EtcdDataEncryptionProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.EtcdDataEncryptionProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *EtcdDataEncryptionProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.EtcdDataEncryptionProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.EtcdDataEncryptionProfile_STATUS, got %T", armInput)
	}

	// Set property "CustomerManaged":
	if typedInput.CustomerManaged != nil {
		var customerManaged1 CustomerManagedEncryptionProfile_STATUS
		err := customerManaged1.PopulateFromARM(owner, *typedInput.CustomerManaged)
		if err != nil {
			return err
		}
		customerManaged := customerManaged1
		profile.CustomerManaged = &customerManaged
	}

	// Set property "KeyManagementMode":
	if typedInput.KeyManagementMode != nil {
		var temp string
		temp = string(*typedInput.KeyManagementMode)
		keyManagementMode := EtcdDataEncryptionProfile_KeyManagementMode_STATUS(temp)
		profile.KeyManagementMode = &keyManagementMode
	}

	// No error
	return nil
}

// AssignProperties_From_EtcdDataEncryptionProfile_STATUS populates our EtcdDataEncryptionProfile_STATUS from the provided source EtcdDataEncryptionProfile_STATUS
func (profile *EtcdDataEncryptionProfile_STATUS) AssignProperties_From_EtcdDataEncryptionProfile_STATUS(source *storage.EtcdDataEncryptionProfile_STATUS) error {

	// CustomerManaged
	if source.CustomerManaged != nil {
		var customerManaged CustomerManagedEncryptionProfile_STATUS
		err := customerManaged.AssignProperties_From_CustomerManagedEncryptionProfile_STATUS(source.CustomerManaged)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_CustomerManagedEncryptionProfile_STATUS() to populate field CustomerManaged")
		}
		profile.CustomerManaged = &customerManaged
	} else {
		profile.CustomerManaged = nil
	}

	// KeyManagementMode
	if source.KeyManagementMode != nil {
		keyManagementMode := *source.KeyManagementMode
		keyManagementModeTemp := genruntime.ToEnum(keyManagementMode, etcdDataEncryptionProfile_KeyManagementMode_STATUS_Values)
		profile.KeyManagementMode = &keyManagementModeTemp
	} else {
		profile.KeyManagementMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EtcdDataEncryptionProfile_STATUS populates the provided destination EtcdDataEncryptionProfile_STATUS from our EtcdDataEncryptionProfile_STATUS
func (profile *EtcdDataEncryptionProfile_STATUS) AssignProperties_To_EtcdDataEncryptionProfile_STATUS(destination *storage.EtcdDataEncryptionProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomerManaged
	if profile.CustomerManaged != nil {
		var customerManaged storage.CustomerManagedEncryptionProfile_STATUS
		err := profile.CustomerManaged.AssignProperties_To_CustomerManagedEncryptionProfile_STATUS(&customerManaged)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_CustomerManagedEncryptionProfile_STATUS() to populate field CustomerManaged")
		}
		destination.CustomerManaged = &customerManaged
	} else {
		destination.CustomerManaged = nil
	}

	// KeyManagementMode
	if profile.KeyManagementMode != nil {
		keyManagementMode := string(*profile.KeyManagementMode)
		destination.KeyManagementMode = &keyManagementMode
	} else {
		destination.KeyManagementMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"OVNKubernetes","Other"}
type NetworkProfile_NetworkType string

const (
	NetworkProfile_NetworkType_OVNKubernetes = NetworkProfile_NetworkType("OVNKubernetes")
	NetworkProfile_NetworkType_Other         = NetworkProfile_NetworkType("Other")
)

// Mapping from string to NetworkProfile_NetworkType
var networkProfile_NetworkType_Values = map[string]NetworkProfile_NetworkType{
	"ovnkubernetes": NetworkProfile_NetworkType_OVNKubernetes,
	"other":         NetworkProfile_NetworkType_Other,
}

type NetworkProfile_NetworkType_STATUS string

const (
	NetworkProfile_NetworkType_STATUS_OVNKubernetes = NetworkProfile_NetworkType_STATUS("OVNKubernetes")
	NetworkProfile_NetworkType_STATUS_Other         = NetworkProfile_NetworkType_STATUS("Other")
)

// Mapping from string to NetworkProfile_NetworkType_STATUS
var networkProfile_NetworkType_STATUS_Values = map[string]NetworkProfile_NetworkType_STATUS{
	"ovnkubernetes": NetworkProfile_NetworkType_STATUS_OVNKubernetes,
	"other":         NetworkProfile_NetworkType_STATUS_Other,
}

// The configuration that the operators of the cluster have to authenticate to Azure.
type OperatorsAuthenticationProfile struct {
	// +kubebuilder:validation:Required
	// UserAssignedIdentities: Represents the information related to Azure User-Assigned managed identities needed
	// to perform Operators authentication based on Azure User-Assigned Managed Identities
	UserAssignedIdentities *UserAssignedIdentitiesProfile `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &OperatorsAuthenticationProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *OperatorsAuthenticationProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.OperatorsAuthenticationProfile{}

	// Set property "UserAssignedIdentities":
	if profile.UserAssignedIdentities != nil {
		userAssignedIdentities_ARM, err := profile.UserAssignedIdentities.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		userAssignedIdentities := *userAssignedIdentities_ARM.(*arm.UserAssignedIdentitiesProfile)
		result.UserAssignedIdentities = &userAssignedIdentities
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *OperatorsAuthenticationProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OperatorsAuthenticationProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *OperatorsAuthenticationProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OperatorsAuthenticationProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OperatorsAuthenticationProfile, got %T", armInput)
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		var userAssignedIdentities1 UserAssignedIdentitiesProfile
		err := userAssignedIdentities1.PopulateFromARM(owner, *typedInput.UserAssignedIdentities)
		if err != nil {
			return err
		}
		userAssignedIdentities := userAssignedIdentities1
		profile.UserAssignedIdentities = &userAssignedIdentities
	}

	// No error
	return nil
}

// AssignProperties_From_OperatorsAuthenticationProfile populates our OperatorsAuthenticationProfile from the provided source OperatorsAuthenticationProfile
func (profile *OperatorsAuthenticationProfile) AssignProperties_From_OperatorsAuthenticationProfile(source *storage.OperatorsAuthenticationProfile) error {

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		var userAssignedIdentity UserAssignedIdentitiesProfile
		err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentitiesProfile(source.UserAssignedIdentities)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentitiesProfile() to populate field UserAssignedIdentities")
		}
		profile.UserAssignedIdentities = &userAssignedIdentity
	} else {
		profile.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OperatorsAuthenticationProfile populates the provided destination OperatorsAuthenticationProfile from our OperatorsAuthenticationProfile
func (profile *OperatorsAuthenticationProfile) AssignProperties_To_OperatorsAuthenticationProfile(destination *storage.OperatorsAuthenticationProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UserAssignedIdentities
	if profile.UserAssignedIdentities != nil {
		var userAssignedIdentity storage.UserAssignedIdentitiesProfile
		err := profile.UserAssignedIdentities.AssignProperties_To_UserAssignedIdentitiesProfile(&userAssignedIdentity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentitiesProfile() to populate field UserAssignedIdentities")
		}
		destination.UserAssignedIdentities = &userAssignedIdentity
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OperatorsAuthenticationProfile_STATUS populates our OperatorsAuthenticationProfile from the provided source OperatorsAuthenticationProfile_STATUS
func (profile *OperatorsAuthenticationProfile) Initialize_From_OperatorsAuthenticationProfile_STATUS(source *OperatorsAuthenticationProfile_STATUS) error {

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		var userAssignedIdentity UserAssignedIdentitiesProfile
		err := userAssignedIdentity.Initialize_From_UserAssignedIdentitiesProfile_STATUS(source.UserAssignedIdentities)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_UserAssignedIdentitiesProfile_STATUS() to populate field UserAssignedIdentities")
		}
		profile.UserAssignedIdentities = &userAssignedIdentity
	} else {
		profile.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// The configuration that the operators of the cluster have to authenticate to Azure.
type OperatorsAuthenticationProfile_STATUS struct {
	// UserAssignedIdentities: Represents the information related to Azure User-Assigned managed identities needed
	// to perform Operators authentication based on Azure User-Assigned Managed Identities
	UserAssignedIdentities *UserAssignedIdentitiesProfile_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &OperatorsAuthenticationProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *OperatorsAuthenticationProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.OperatorsAuthenticationProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *OperatorsAuthenticationProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.OperatorsAuthenticationProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.OperatorsAuthenticationProfile_STATUS, got %T", armInput)
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		var userAssignedIdentities1 UserAssignedIdentitiesProfile_STATUS
		err := userAssignedIdentities1.PopulateFromARM(owner, *typedInput.UserAssignedIdentities)
		if err != nil {
			return err
		}
		userAssignedIdentities := userAssignedIdentities1
		profile.UserAssignedIdentities = &userAssignedIdentities
	}

	// No error
	return nil
}

// AssignProperties_From_OperatorsAuthenticationProfile_STATUS populates our OperatorsAuthenticationProfile_STATUS from the provided source OperatorsAuthenticationProfile_STATUS
func (profile *OperatorsAuthenticationProfile_STATUS) AssignProperties_From_OperatorsAuthenticationProfile_STATUS(source *storage.OperatorsAuthenticationProfile_STATUS) error {

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		var userAssignedIdentity UserAssignedIdentitiesProfile_STATUS
		err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentitiesProfile_STATUS(source.UserAssignedIdentities)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentitiesProfile_STATUS() to populate field UserAssignedIdentities")
		}
		profile.UserAssignedIdentities = &userAssignedIdentity
	} else {
		profile.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OperatorsAuthenticationProfile_STATUS populates the provided destination OperatorsAuthenticationProfile_STATUS from our OperatorsAuthenticationProfile_STATUS
func (profile *OperatorsAuthenticationProfile_STATUS) AssignProperties_To_OperatorsAuthenticationProfile_STATUS(destination *storage.OperatorsAuthenticationProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UserAssignedIdentities
	if profile.UserAssignedIdentities != nil {
		var userAssignedIdentity storage.UserAssignedIdentitiesProfile_STATUS
		err := profile.UserAssignedIdentities.AssignProperties_To_UserAssignedIdentitiesProfile_STATUS(&userAssignedIdentity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentitiesProfile_STATUS() to populate field UserAssignedIdentities")
		}
		destination.UserAssignedIdentities = &userAssignedIdentity
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"LoadBalancer"}
type PlatformProfile_OutboundType string

const PlatformProfile_OutboundType_LoadBalancer = PlatformProfile_OutboundType("LoadBalancer")

// Mapping from string to PlatformProfile_OutboundType
var platformProfile_OutboundType_Values = map[string]PlatformProfile_OutboundType{
	"loadbalancer": PlatformProfile_OutboundType_LoadBalancer,
}

type PlatformProfile_OutboundType_STATUS string

const PlatformProfile_OutboundType_STATUS_LoadBalancer = PlatformProfile_OutboundType_STATUS("LoadBalancer")

// Mapping from string to PlatformProfile_OutboundType_STATUS
var platformProfile_OutboundType_STATUS_Values = map[string]PlatformProfile_OutboundType_STATUS{
	"loadbalancer": PlatformProfile_OutboundType_STATUS_LoadBalancer,
}

// Customer managed encryption key profile.
type CustomerManagedEncryptionProfile struct {
	// EncryptionType: The encryption type used.
	// By default, "KMS" is used.
	EncryptionType *CustomerManagedEncryptionProfile_EncryptionType `json:"encryptionType,omitempty"`

	// Kms: The Key Management Service (KMS) encryption key details.
	// Required when encryptionType is "KMS".
	Kms *KmsEncryptionProfile `json:"kms,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomerManagedEncryptionProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *CustomerManagedEncryptionProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.CustomerManagedEncryptionProfile{}

	// Set property "EncryptionType":
	if profile.EncryptionType != nil {
		var temp string
		temp = string(*profile.EncryptionType)
		encryptionType := arm.CustomerManagedEncryptionProfile_EncryptionType(temp)
		result.EncryptionType = &encryptionType
	}

	// Set property "Kms":
	if profile.Kms != nil {
		kms_ARM, err := profile.Kms.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		kms := *kms_ARM.(*arm.KmsEncryptionProfile)
		result.Kms = &kms
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *CustomerManagedEncryptionProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomerManagedEncryptionProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *CustomerManagedEncryptionProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomerManagedEncryptionProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomerManagedEncryptionProfile, got %T", armInput)
	}

	// Set property "EncryptionType":
	if typedInput.EncryptionType != nil {
		var temp string
		temp = string(*typedInput.EncryptionType)
		encryptionType := CustomerManagedEncryptionProfile_EncryptionType(temp)
		profile.EncryptionType = &encryptionType
	}

	// Set property "Kms":
	if typedInput.Kms != nil {
		var kms1 KmsEncryptionProfile
		err := kms1.PopulateFromARM(owner, *typedInput.Kms)
		if err != nil {
			return err
		}
		kms := kms1
		profile.Kms = &kms
	}

	// No error
	return nil
}

// AssignProperties_From_CustomerManagedEncryptionProfile populates our CustomerManagedEncryptionProfile from the provided source CustomerManagedEncryptionProfile
func (profile *CustomerManagedEncryptionProfile) AssignProperties_From_CustomerManagedEncryptionProfile(source *storage.CustomerManagedEncryptionProfile) error {

	// EncryptionType
	if source.EncryptionType != nil {
		encryptionType := *source.EncryptionType
		encryptionTypeTemp := genruntime.ToEnum(encryptionType, customerManagedEncryptionProfile_EncryptionType_Values)
		profile.EncryptionType = &encryptionTypeTemp
	} else {
		profile.EncryptionType = nil
	}

	// Kms
	if source.Kms != nil {
		var km KmsEncryptionProfile
		err := km.AssignProperties_From_KmsEncryptionProfile(source.Kms)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KmsEncryptionProfile() to populate field Kms")
		}
		profile.Kms = &km
	} else {
		profile.Kms = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomerManagedEncryptionProfile populates the provided destination CustomerManagedEncryptionProfile from our CustomerManagedEncryptionProfile
func (profile *CustomerManagedEncryptionProfile) AssignProperties_To_CustomerManagedEncryptionProfile(destination *storage.CustomerManagedEncryptionProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionType
	if profile.EncryptionType != nil {
		encryptionType := string(*profile.EncryptionType)
		destination.EncryptionType = &encryptionType
	} else {
		destination.EncryptionType = nil
	}

	// Kms
	if profile.Kms != nil {
		var km storage.KmsEncryptionProfile
		err := profile.Kms.AssignProperties_To_KmsEncryptionProfile(&km)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KmsEncryptionProfile() to populate field Kms")
		}
		destination.Kms = &km
	} else {
		destination.Kms = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CustomerManagedEncryptionProfile_STATUS populates our CustomerManagedEncryptionProfile from the provided source CustomerManagedEncryptionProfile_STATUS
func (profile *CustomerManagedEncryptionProfile) Initialize_From_CustomerManagedEncryptionProfile_STATUS(source *CustomerManagedEncryptionProfile_STATUS) error {

	// EncryptionType
	if source.EncryptionType != nil {
		encryptionType := genruntime.ToEnum(string(*source.EncryptionType), customerManagedEncryptionProfile_EncryptionType_Values)
		profile.EncryptionType = &encryptionType
	} else {
		profile.EncryptionType = nil
	}

	// Kms
	if source.Kms != nil {
		var km KmsEncryptionProfile
		err := km.Initialize_From_KmsEncryptionProfile_STATUS(source.Kms)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_KmsEncryptionProfile_STATUS() to populate field Kms")
		}
		profile.Kms = &km
	} else {
		profile.Kms = nil
	}

	// No error
	return nil
}

// Customer managed encryption key profile.
type CustomerManagedEncryptionProfile_STATUS struct {
	// EncryptionType: The encryption type used.
	// By default, "KMS" is used.
	EncryptionType *CustomerManagedEncryptionProfile_EncryptionType_STATUS `json:"encryptionType,omitempty"`

	// Kms: The Key Management Service (KMS) encryption key details.
	// Required when encryptionType is "KMS".
	Kms *KmsEncryptionProfile_STATUS `json:"kms,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomerManagedEncryptionProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *CustomerManagedEncryptionProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.CustomerManagedEncryptionProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *CustomerManagedEncryptionProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.CustomerManagedEncryptionProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.CustomerManagedEncryptionProfile_STATUS, got %T", armInput)
	}

	// Set property "EncryptionType":
	if typedInput.EncryptionType != nil {
		var temp string
		temp = string(*typedInput.EncryptionType)
		encryptionType := CustomerManagedEncryptionProfile_EncryptionType_STATUS(temp)
		profile.EncryptionType = &encryptionType
	}

	// Set property "Kms":
	if typedInput.Kms != nil {
		var kms1 KmsEncryptionProfile_STATUS
		err := kms1.PopulateFromARM(owner, *typedInput.Kms)
		if err != nil {
			return err
		}
		kms := kms1
		profile.Kms = &kms
	}

	// No error
	return nil
}

// AssignProperties_From_CustomerManagedEncryptionProfile_STATUS populates our CustomerManagedEncryptionProfile_STATUS from the provided source CustomerManagedEncryptionProfile_STATUS
func (profile *CustomerManagedEncryptionProfile_STATUS) AssignProperties_From_CustomerManagedEncryptionProfile_STATUS(source *storage.CustomerManagedEncryptionProfile_STATUS) error {

	// EncryptionType
	if source.EncryptionType != nil {
		encryptionType := *source.EncryptionType
		encryptionTypeTemp := genruntime.ToEnum(encryptionType, customerManagedEncryptionProfile_EncryptionType_STATUS_Values)
		profile.EncryptionType = &encryptionTypeTemp
	} else {
		profile.EncryptionType = nil
	}

	// Kms
	if source.Kms != nil {
		var km KmsEncryptionProfile_STATUS
		err := km.AssignProperties_From_KmsEncryptionProfile_STATUS(source.Kms)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KmsEncryptionProfile_STATUS() to populate field Kms")
		}
		profile.Kms = &km
	} else {
		profile.Kms = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CustomerManagedEncryptionProfile_STATUS populates the provided destination CustomerManagedEncryptionProfile_STATUS from our CustomerManagedEncryptionProfile_STATUS
func (profile *CustomerManagedEncryptionProfile_STATUS) AssignProperties_To_CustomerManagedEncryptionProfile_STATUS(destination *storage.CustomerManagedEncryptionProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionType
	if profile.EncryptionType != nil {
		encryptionType := string(*profile.EncryptionType)
		destination.EncryptionType = &encryptionType
	} else {
		destination.EncryptionType = nil
	}

	// Kms
	if profile.Kms != nil {
		var km storage.KmsEncryptionProfile_STATUS
		err := profile.Kms.AssignProperties_To_KmsEncryptionProfile_STATUS(&km)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KmsEncryptionProfile_STATUS() to populate field Kms")
		}
		destination.Kms = &km
	} else {
		destination.Kms = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"CustomerManaged","PlatformManaged"}
type EtcdDataEncryptionProfile_KeyManagementMode string

const (
	EtcdDataEncryptionProfile_KeyManagementMode_CustomerManaged = EtcdDataEncryptionProfile_KeyManagementMode("CustomerManaged")
	EtcdDataEncryptionProfile_KeyManagementMode_PlatformManaged = EtcdDataEncryptionProfile_KeyManagementMode("PlatformManaged")
)

// Mapping from string to EtcdDataEncryptionProfile_KeyManagementMode
var etcdDataEncryptionProfile_KeyManagementMode_Values = map[string]EtcdDataEncryptionProfile_KeyManagementMode{
	"customermanaged": EtcdDataEncryptionProfile_KeyManagementMode_CustomerManaged,
	"platformmanaged": EtcdDataEncryptionProfile_KeyManagementMode_PlatformManaged,
}

type EtcdDataEncryptionProfile_KeyManagementMode_STATUS string

const (
	EtcdDataEncryptionProfile_KeyManagementMode_STATUS_CustomerManaged = EtcdDataEncryptionProfile_KeyManagementMode_STATUS("CustomerManaged")
	EtcdDataEncryptionProfile_KeyManagementMode_STATUS_PlatformManaged = EtcdDataEncryptionProfile_KeyManagementMode_STATUS("PlatformManaged")
)

// Mapping from string to EtcdDataEncryptionProfile_KeyManagementMode_STATUS
var etcdDataEncryptionProfile_KeyManagementMode_STATUS_Values = map[string]EtcdDataEncryptionProfile_KeyManagementMode_STATUS{
	"customermanaged": EtcdDataEncryptionProfile_KeyManagementMode_STATUS_CustomerManaged,
	"platformmanaged": EtcdDataEncryptionProfile_KeyManagementMode_STATUS_PlatformManaged,
}

// Represents the information related to Azure User-Assigned managed identities needed
// to perform Operators authentication
// based on Azure User-Assigned Managed Identities
type UserAssignedIdentitiesProfile struct {
	// +kubebuilder:validation:Required
	// ControlPlaneOperatorsReferences: The set of Azure User-Assigned Managed Identities leveraged for the Control Plane
	// operators of the cluster. The set of required managed identities is dependent on the
	// Cluster's OpenShift version.
	ControlPlaneOperatorsReferences map[string]genruntime.ResourceReference `armReference:"ControlPlaneOperators" json:"controlPlaneOperatorsReferences,omitempty"`

	// +kubebuilder:validation:Required
	// DataPlaneOperatorsReferences: The set of Azure User-Assigned Managed Identities leveraged for the Data Plane
	// operators of the cluster. The set of required managed identities is dependent on the
	// Cluster's OpenShift version.
	DataPlaneOperatorsReferences map[string]genruntime.ResourceReference `armReference:"DataPlaneOperators" json:"dataPlaneOperatorsReferences,omitempty"`

	// +kubebuilder:validation:Required
	// ServiceManagedIdentityReference: Represents the information associated to an Azure User-Assigned Managed Identity whose
	// purpose is to perform service level actions.
	ServiceManagedIdentityReference *genruntime.ResourceReference `armReference:"ServiceManagedIdentity" json:"serviceManagedIdentityReference,omitempty"`
}

var _ genruntime.ARMTransformer = &UserAssignedIdentitiesProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *UserAssignedIdentitiesProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.UserAssignedIdentitiesProfile{}

	// Set property "ControlPlaneOperators":
	if profile.ControlPlaneOperatorsReferences != nil {
		result.ControlPlaneOperators = make(map[string]string, len(profile.ControlPlaneOperatorsReferences))
		for key, value := range profile.ControlPlaneOperatorsReferences {
			valueARMID, err := resolved.ResolvedReferences.Lookup(value)
			if err != nil {
				return nil, err
			}
			result.ControlPlaneOperators[key] = valueARMID
		}
	}

	// Set property "DataPlaneOperators":
	if profile.DataPlaneOperatorsReferences != nil {
		result.DataPlaneOperators = make(map[string]string, len(profile.DataPlaneOperatorsReferences))
		for key, value := range profile.DataPlaneOperatorsReferences {
			valueARMID, err := resolved.ResolvedReferences.Lookup(value)
			if err != nil {
				return nil, err
			}
			result.DataPlaneOperators[key] = valueARMID
		}
	}

	// Set property "ServiceManagedIdentity":
	if profile.ServiceManagedIdentityReference != nil {
		serviceManagedIdentityReferenceARMID, err := resolved.ResolvedReferences.Lookup(*profile.ServiceManagedIdentityReference)
		if err != nil {
			return nil, err
		}
		serviceManagedIdentityReference := serviceManagedIdentityReferenceARMID
		result.ServiceManagedIdentity = &serviceManagedIdentityReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *UserAssignedIdentitiesProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAssignedIdentitiesProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *UserAssignedIdentitiesProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(arm.UserAssignedIdentitiesProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAssignedIdentitiesProfile, got %T", armInput)
	}

	// no assignment for property "ControlPlaneOperatorsReferences"

	// no assignment for property "DataPlaneOperatorsReferences"

	// no assignment for property "ServiceManagedIdentityReference"

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentitiesProfile populates our UserAssignedIdentitiesProfile from the provided source UserAssignedIdentitiesProfile
func (profile *UserAssignedIdentitiesProfile) AssignProperties_From_UserAssignedIdentitiesProfile(source *storage.UserAssignedIdentitiesProfile) error {

	// ControlPlaneOperatorsReferences
	if source.ControlPlaneOperatorsReferences != nil {
		controlPlaneOperatorsReferenceMap := make(map[string]genruntime.ResourceReference, len(source.ControlPlaneOperatorsReferences))
		for controlPlaneOperatorsReferenceKey, controlPlaneOperatorsReferenceValue := range source.ControlPlaneOperatorsReferences {
			controlPlaneOperatorsReferenceMap[controlPlaneOperatorsReferenceKey] = controlPlaneOperatorsReferenceValue.Copy()
		}
		profile.ControlPlaneOperatorsReferences = controlPlaneOperatorsReferenceMap
	} else {
		profile.ControlPlaneOperatorsReferences = nil
	}

	// DataPlaneOperatorsReferences
	if source.DataPlaneOperatorsReferences != nil {
		dataPlaneOperatorsReferenceMap := make(map[string]genruntime.ResourceReference, len(source.DataPlaneOperatorsReferences))
		for dataPlaneOperatorsReferenceKey, dataPlaneOperatorsReferenceValue := range source.DataPlaneOperatorsReferences {
			dataPlaneOperatorsReferenceMap[dataPlaneOperatorsReferenceKey] = dataPlaneOperatorsReferenceValue.Copy()
		}
		profile.DataPlaneOperatorsReferences = dataPlaneOperatorsReferenceMap
	} else {
		profile.DataPlaneOperatorsReferences = nil
	}

	// ServiceManagedIdentityReference
	if source.ServiceManagedIdentityReference != nil {
		serviceManagedIdentityReference := source.ServiceManagedIdentityReference.Copy()
		profile.ServiceManagedIdentityReference = &serviceManagedIdentityReference
	} else {
		profile.ServiceManagedIdentityReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentitiesProfile populates the provided destination UserAssignedIdentitiesProfile from our UserAssignedIdentitiesProfile
func (profile *UserAssignedIdentitiesProfile) AssignProperties_To_UserAssignedIdentitiesProfile(destination *storage.UserAssignedIdentitiesProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ControlPlaneOperatorsReferences
	if profile.ControlPlaneOperatorsReferences != nil {
		controlPlaneOperatorsReferenceMap := make(map[string]genruntime.ResourceReference, len(profile.ControlPlaneOperatorsReferences))
		for controlPlaneOperatorsReferenceKey, controlPlaneOperatorsReferenceValue := range profile.ControlPlaneOperatorsReferences {
			controlPlaneOperatorsReferenceMap[controlPlaneOperatorsReferenceKey] = controlPlaneOperatorsReferenceValue.Copy()
		}
		destination.ControlPlaneOperatorsReferences = controlPlaneOperatorsReferenceMap
	} else {
		destination.ControlPlaneOperatorsReferences = nil
	}

	// DataPlaneOperatorsReferences
	if profile.DataPlaneOperatorsReferences != nil {
		dataPlaneOperatorsReferenceMap := make(map[string]genruntime.ResourceReference, len(profile.DataPlaneOperatorsReferences))
		for dataPlaneOperatorsReferenceKey, dataPlaneOperatorsReferenceValue := range profile.DataPlaneOperatorsReferences {
			dataPlaneOperatorsReferenceMap[dataPlaneOperatorsReferenceKey] = dataPlaneOperatorsReferenceValue.Copy()
		}
		destination.DataPlaneOperatorsReferences = dataPlaneOperatorsReferenceMap
	} else {
		destination.DataPlaneOperatorsReferences = nil
	}

	// ServiceManagedIdentityReference
	if profile.ServiceManagedIdentityReference != nil {
		serviceManagedIdentityReference := profile.ServiceManagedIdentityReference.Copy()
		destination.ServiceManagedIdentityReference = &serviceManagedIdentityReference
	} else {
		destination.ServiceManagedIdentityReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UserAssignedIdentitiesProfile_STATUS populates our UserAssignedIdentitiesProfile from the provided source UserAssignedIdentitiesProfile_STATUS
func (profile *UserAssignedIdentitiesProfile) Initialize_From_UserAssignedIdentitiesProfile_STATUS(source *UserAssignedIdentitiesProfile_STATUS) error {

	// No error
	return nil
}

// Represents the information related to Azure User-Assigned managed identities needed
// to perform Operators authentication
// based on Azure User-Assigned Managed Identities
type UserAssignedIdentitiesProfile_STATUS struct {
	// ControlPlaneOperators: The set of Azure User-Assigned Managed Identities leveraged for the Control Plane
	// operators of the cluster. The set of required managed identities is dependent on the
	// Cluster's OpenShift version.
	ControlPlaneOperators map[string]string `json:"controlPlaneOperators,omitempty"`

	// DataPlaneOperators: The set of Azure User-Assigned Managed Identities leveraged for the Data Plane
	// operators of the cluster. The set of required managed identities is dependent on the
	// Cluster's OpenShift version.
	DataPlaneOperators map[string]string `json:"dataPlaneOperators,omitempty"`

	// ServiceManagedIdentity: Represents the information associated to an Azure User-Assigned Managed Identity whose
	// purpose is to perform service level actions.
	ServiceManagedIdentity *string `json:"serviceManagedIdentity,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentitiesProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *UserAssignedIdentitiesProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAssignedIdentitiesProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *UserAssignedIdentitiesProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAssignedIdentitiesProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAssignedIdentitiesProfile_STATUS, got %T", armInput)
	}

	// Set property "ControlPlaneOperators":
	if typedInput.ControlPlaneOperators != nil {
		profile.ControlPlaneOperators = make(map[string]string, len(typedInput.ControlPlaneOperators))
		for key, value := range typedInput.ControlPlaneOperators {
			profile.ControlPlaneOperators[key] = value
		}
	}

	// Set property "DataPlaneOperators":
	if typedInput.DataPlaneOperators != nil {
		profile.DataPlaneOperators = make(map[string]string, len(typedInput.DataPlaneOperators))
		for key, value := range typedInput.DataPlaneOperators {
			profile.DataPlaneOperators[key] = value
		}
	}

	// Set property "ServiceManagedIdentity":
	if typedInput.ServiceManagedIdentity != nil {
		serviceManagedIdentity := *typedInput.ServiceManagedIdentity
		profile.ServiceManagedIdentity = &serviceManagedIdentity
	}

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentitiesProfile_STATUS populates our UserAssignedIdentitiesProfile_STATUS from the provided source UserAssignedIdentitiesProfile_STATUS
func (profile *UserAssignedIdentitiesProfile_STATUS) AssignProperties_From_UserAssignedIdentitiesProfile_STATUS(source *storage.UserAssignedIdentitiesProfile_STATUS) error {

	// ControlPlaneOperators
	profile.ControlPlaneOperators = genruntime.CloneMapOfStringToString(source.ControlPlaneOperators)

	// DataPlaneOperators
	profile.DataPlaneOperators = genruntime.CloneMapOfStringToString(source.DataPlaneOperators)

	// ServiceManagedIdentity
	profile.ServiceManagedIdentity = genruntime.ClonePointerToString(source.ServiceManagedIdentity)

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentitiesProfile_STATUS populates the provided destination UserAssignedIdentitiesProfile_STATUS from our UserAssignedIdentitiesProfile_STATUS
func (profile *UserAssignedIdentitiesProfile_STATUS) AssignProperties_To_UserAssignedIdentitiesProfile_STATUS(destination *storage.UserAssignedIdentitiesProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ControlPlaneOperators
	destination.ControlPlaneOperators = genruntime.CloneMapOfStringToString(profile.ControlPlaneOperators)

	// DataPlaneOperators
	destination.DataPlaneOperators = genruntime.CloneMapOfStringToString(profile.DataPlaneOperators)

	// ServiceManagedIdentity
	destination.ServiceManagedIdentity = genruntime.ClonePointerToString(profile.ServiceManagedIdentity)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"KMS"}
type CustomerManagedEncryptionProfile_EncryptionType string

const CustomerManagedEncryptionProfile_EncryptionType_KMS = CustomerManagedEncryptionProfile_EncryptionType("KMS")

// Mapping from string to CustomerManagedEncryptionProfile_EncryptionType
var customerManagedEncryptionProfile_EncryptionType_Values = map[string]CustomerManagedEncryptionProfile_EncryptionType{
	"kms": CustomerManagedEncryptionProfile_EncryptionType_KMS,
}

type CustomerManagedEncryptionProfile_EncryptionType_STATUS string

const CustomerManagedEncryptionProfile_EncryptionType_STATUS_KMS = CustomerManagedEncryptionProfile_EncryptionType_STATUS("KMS")

// Mapping from string to CustomerManagedEncryptionProfile_EncryptionType_STATUS
var customerManagedEncryptionProfile_EncryptionType_STATUS_Values = map[string]CustomerManagedEncryptionProfile_EncryptionType_STATUS{
	"kms": CustomerManagedEncryptionProfile_EncryptionType_STATUS_KMS,
}

// Configure etcd encryption Key Management Service (KMS) key.
// Your Microsoft Entra application used to create the cluster
// must be authorized to access this keyvault,
// e.g using the AzureCLI: `az keyvault set-policy -n $KEYVAULT_NAME
// --key-permissions decrypt encrypt --spn <YOUR APPLICATION CLIENT ID>`
type KmsEncryptionProfile struct {
	// +kubebuilder:validation:Required
	// ActiveKey: The details of the active key.
	ActiveKey *KmsKey `json:"activeKey,omitempty"`
}

var _ genruntime.ARMTransformer = &KmsEncryptionProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *KmsEncryptionProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &arm.KmsEncryptionProfile{}

	// Set property "ActiveKey":
	if profile.ActiveKey != nil {
		activeKey_ARM, err := profile.ActiveKey.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		activeKey := *activeKey_ARM.(*arm.KmsKey)
		result.ActiveKey = &activeKey
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *KmsEncryptionProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KmsEncryptionProfile{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *KmsEncryptionProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KmsEncryptionProfile)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KmsEncryptionProfile, got %T", armInput)
	}

	// Set property "ActiveKey":
	if typedInput.ActiveKey != nil {
		var activeKey1 KmsKey
		err := activeKey1.PopulateFromARM(owner, *typedInput.ActiveKey)
		if err != nil {
			return err
		}
		activeKey := activeKey1
		profile.ActiveKey = &activeKey
	}

	// No error
	return nil
}

// AssignProperties_From_KmsEncryptionProfile populates our KmsEncryptionProfile from the provided source KmsEncryptionProfile
func (profile *KmsEncryptionProfile) AssignProperties_From_KmsEncryptionProfile(source *storage.KmsEncryptionProfile) error {

	// ActiveKey
	if source.ActiveKey != nil {
		var activeKey KmsKey
		err := activeKey.AssignProperties_From_KmsKey(source.ActiveKey)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KmsKey() to populate field ActiveKey")
		}
		profile.ActiveKey = &activeKey
	} else {
		profile.ActiveKey = nil
	}

	// No error
	return nil
}

// AssignProperties_To_KmsEncryptionProfile populates the provided destination KmsEncryptionProfile from our KmsEncryptionProfile
func (profile *KmsEncryptionProfile) AssignProperties_To_KmsEncryptionProfile(destination *storage.KmsEncryptionProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActiveKey
	if profile.ActiveKey != nil {
		var activeKey storage.KmsKey
		err := profile.ActiveKey.AssignProperties_To_KmsKey(&activeKey)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KmsKey() to populate field ActiveKey")
		}
		destination.ActiveKey = &activeKey
	} else {
		destination.ActiveKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_KmsEncryptionProfile_STATUS populates our KmsEncryptionProfile from the provided source KmsEncryptionProfile_STATUS
func (profile *KmsEncryptionProfile) Initialize_From_KmsEncryptionProfile_STATUS(source *KmsEncryptionProfile_STATUS) error {

	// ActiveKey
	if source.ActiveKey != nil {
		var activeKey KmsKey
		err := activeKey.Initialize_From_KmsKey_STATUS(source.ActiveKey)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_KmsKey_STATUS() to populate field ActiveKey")
		}
		profile.ActiveKey = &activeKey
	} else {
		profile.ActiveKey = nil
	}

	// No error
	return nil
}

// Configure etcd encryption Key Management Service (KMS) key.
// Your Microsoft Entra application used to create the cluster
// must be authorized to access this keyvault,
// e.g using the AzureCLI: `az keyvault set-policy -n $KEYVAULT_NAME
// --key-permissions decrypt encrypt --spn <YOUR APPLICATION CLIENT ID>`
type KmsEncryptionProfile_STATUS struct {
	// ActiveKey: The details of the active key.
	ActiveKey *KmsKey_STATUS `json:"activeKey,omitempty"`
}

var _ genruntime.FromARMConverter = &KmsEncryptionProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *KmsEncryptionProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KmsEncryptionProfile_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *KmsEncryptionProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KmsEncryptionProfile_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KmsEncryptionProfile_STATUS, got %T", armInput)
	}

	// Set property "ActiveKey":
	if typedInput.ActiveKey != nil {
		var activeKey1 KmsKey_STATUS
		err := activeKey1.PopulateFromARM(owner, *typedInput.ActiveKey)
		if err != nil {
			return err
		}
		activeKey := activeKey1
		profile.ActiveKey = &activeKey
	}

	// No error
	return nil
}

// AssignProperties_From_KmsEncryptionProfile_STATUS populates our KmsEncryptionProfile_STATUS from the provided source KmsEncryptionProfile_STATUS
func (profile *KmsEncryptionProfile_STATUS) AssignProperties_From_KmsEncryptionProfile_STATUS(source *storage.KmsEncryptionProfile_STATUS) error {

	// ActiveKey
	if source.ActiveKey != nil {
		var activeKey KmsKey_STATUS
		err := activeKey.AssignProperties_From_KmsKey_STATUS(source.ActiveKey)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_KmsKey_STATUS() to populate field ActiveKey")
		}
		profile.ActiveKey = &activeKey
	} else {
		profile.ActiveKey = nil
	}

	// No error
	return nil
}

// AssignProperties_To_KmsEncryptionProfile_STATUS populates the provided destination KmsEncryptionProfile_STATUS from our KmsEncryptionProfile_STATUS
func (profile *KmsEncryptionProfile_STATUS) AssignProperties_To_KmsEncryptionProfile_STATUS(destination *storage.KmsEncryptionProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActiveKey
	if profile.ActiveKey != nil {
		var activeKey storage.KmsKey_STATUS
		err := profile.ActiveKey.AssignProperties_To_KmsKey_STATUS(&activeKey)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_KmsKey_STATUS() to populate field ActiveKey")
		}
		destination.ActiveKey = &activeKey
	} else {
		destination.ActiveKey = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A representation of a KeyVault Secret.
type KmsKey struct {
	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=255
	// +kubebuilder:validation:MinLength=1
	// Name: name is the name of the keyvault key used for encryption/decryption.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=255
	// +kubebuilder:validation:MinLength=1
	// VaultName: vaultName is the name of the keyvault that contains the secret.
	VaultName *string `json:"vaultName,omitempty"`

	// +kubebuilder:validation:Required
	// +kubebuilder:validation:MaxLength=255
	// +kubebuilder:validation:MinLength=1
	// Version: version contains the version of the key to use.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &KmsKey{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (kmsKey *KmsKey) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if kmsKey == nil {
		return nil, nil
	}
	result := &arm.KmsKey{}

	// Set property "Name":
	if kmsKey.Name != nil {
		name := *kmsKey.Name
		result.Name = &name
	}

	// Set property "VaultName":
	if kmsKey.VaultName != nil {
		vaultName := *kmsKey.VaultName
		result.VaultName = &vaultName
	}

	// Set property "Version":
	if kmsKey.Version != nil {
		version := *kmsKey.Version
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (kmsKey *KmsKey) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KmsKey{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (kmsKey *KmsKey) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KmsKey)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KmsKey, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		kmsKey.Name = &name
	}

	// Set property "VaultName":
	if typedInput.VaultName != nil {
		vaultName := *typedInput.VaultName
		kmsKey.VaultName = &vaultName
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		kmsKey.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_KmsKey populates our KmsKey from the provided source KmsKey
func (kmsKey *KmsKey) AssignProperties_From_KmsKey(source *storage.KmsKey) error {

	// Name
	kmsKey.Name = genruntime.ClonePointerToString(source.Name)

	// VaultName
	kmsKey.VaultName = genruntime.ClonePointerToString(source.VaultName)

	// Version
	kmsKey.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_KmsKey populates the provided destination KmsKey from our KmsKey
func (kmsKey *KmsKey) AssignProperties_To_KmsKey(destination *storage.KmsKey) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(kmsKey.Name)

	// VaultName
	destination.VaultName = genruntime.ClonePointerToString(kmsKey.VaultName)

	// Version
	destination.Version = genruntime.ClonePointerToString(kmsKey.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_KmsKey_STATUS populates our KmsKey from the provided source KmsKey_STATUS
func (kmsKey *KmsKey) Initialize_From_KmsKey_STATUS(source *KmsKey_STATUS) error {

	// Name
	kmsKey.Name = genruntime.ClonePointerToString(source.Name)

	// VaultName
	kmsKey.VaultName = genruntime.ClonePointerToString(source.VaultName)

	// Version
	kmsKey.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// A representation of a KeyVault Secret.
type KmsKey_STATUS struct {
	// Name: name is the name of the keyvault key used for encryption/decryption.
	Name *string `json:"name,omitempty"`

	// VaultName: vaultName is the name of the keyvault that contains the secret.
	VaultName *string `json:"vaultName,omitempty"`

	// Version: version contains the version of the key to use.
	Version *string `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &KmsKey_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (kmsKey *KmsKey_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.KmsKey_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (kmsKey *KmsKey_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.KmsKey_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.KmsKey_STATUS, got %T", armInput)
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		kmsKey.Name = &name
	}

	// Set property "VaultName":
	if typedInput.VaultName != nil {
		vaultName := *typedInput.VaultName
		kmsKey.VaultName = &vaultName
	}

	// Set property "Version":
	if typedInput.Version != nil {
		version := *typedInput.Version
		kmsKey.Version = &version
	}

	// No error
	return nil
}

// AssignProperties_From_KmsKey_STATUS populates our KmsKey_STATUS from the provided source KmsKey_STATUS
func (kmsKey *KmsKey_STATUS) AssignProperties_From_KmsKey_STATUS(source *storage.KmsKey_STATUS) error {

	// Name
	kmsKey.Name = genruntime.ClonePointerToString(source.Name)

	// VaultName
	kmsKey.VaultName = genruntime.ClonePointerToString(source.VaultName)

	// Version
	kmsKey.Version = genruntime.ClonePointerToString(source.Version)

	// No error
	return nil
}

// AssignProperties_To_KmsKey_STATUS populates the provided destination KmsKey_STATUS from our KmsKey_STATUS
func (kmsKey *KmsKey_STATUS) AssignProperties_To_KmsKey_STATUS(destination *storage.KmsKey_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	destination.Name = genruntime.ClonePointerToString(kmsKey.Name)

	// VaultName
	destination.VaultName = genruntime.ClonePointerToString(kmsKey.VaultName)

	// Version
	destination.Version = genruntime.ClonePointerToString(kmsKey.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&HcpOpenShiftCluster{}, &HcpOpenShiftClusterList{})
}
