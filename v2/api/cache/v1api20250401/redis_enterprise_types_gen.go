// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20250401

import (
	"fmt"
	arm "github.com/Azure/azure-service-operator/v2/api/cache/v1api20250401/arm"
	storage "github.com/Azure/azure-service-operator/v2/api/cache/v1api20250401/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,cache}
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /redisenterprise/resource-manager/Microsoft.Cache/stable/2025-04-01/redisenterprise.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}
type RedisEnterprise struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              RedisEnterprise_Spec   `json:"spec,omitempty"`
	Status            RedisEnterprise_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &RedisEnterprise{}

// GetConditions returns the conditions of the resource
func (enterprise *RedisEnterprise) GetConditions() conditions.Conditions {
	return enterprise.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (enterprise *RedisEnterprise) SetConditions(conditions conditions.Conditions) {
	enterprise.Status.Conditions = conditions
}

var _ conversion.Convertible = &RedisEnterprise{}

// ConvertFrom populates our RedisEnterprise from the provided hub RedisEnterprise
func (enterprise *RedisEnterprise) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*storage.RedisEnterprise)
	if !ok {
		return fmt.Errorf("expected cache/v1api20250401/storage/RedisEnterprise but received %T instead", hub)
	}

	return enterprise.AssignProperties_From_RedisEnterprise(source)
}

// ConvertTo populates the provided hub RedisEnterprise from our RedisEnterprise
func (enterprise *RedisEnterprise) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*storage.RedisEnterprise)
	if !ok {
		return fmt.Errorf("expected cache/v1api20250401/storage/RedisEnterprise but received %T instead", hub)
	}

	return enterprise.AssignProperties_To_RedisEnterprise(destination)
}

var _ configmaps.Exporter = &RedisEnterprise{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (enterprise *RedisEnterprise) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if enterprise.Spec.OperatorSpec == nil {
		return nil
	}
	return enterprise.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &RedisEnterprise{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (enterprise *RedisEnterprise) SecretDestinationExpressions() []*core.DestinationExpression {
	if enterprise.Spec.OperatorSpec == nil {
		return nil
	}
	return enterprise.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.ImportableResource = &RedisEnterprise{}

// InitializeSpec initializes the spec for this resource from the given status
func (enterprise *RedisEnterprise) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*RedisEnterprise_STATUS); ok {
		return enterprise.Spec.Initialize_From_RedisEnterprise_STATUS(s)
	}

	return fmt.Errorf("expected Status of type RedisEnterprise_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &RedisEnterprise{}

// AzureName returns the Azure name of the resource
func (enterprise *RedisEnterprise) AzureName() string {
	return enterprise.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2025-04-01"
func (enterprise RedisEnterprise) GetAPIVersion() string {
	return "2025-04-01"
}

// GetResourceScope returns the scope of the resource
func (enterprise *RedisEnterprise) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (enterprise *RedisEnterprise) GetSpec() genruntime.ConvertibleSpec {
	return &enterprise.Spec
}

// GetStatus returns the status of this resource
func (enterprise *RedisEnterprise) GetStatus() genruntime.ConvertibleStatus {
	return &enterprise.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (enterprise *RedisEnterprise) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Cache/redisEnterprise"
func (enterprise *RedisEnterprise) GetType() string {
	return "Microsoft.Cache/redisEnterprise"
}

// NewEmptyStatus returns a new empty (blank) status
func (enterprise *RedisEnterprise) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &RedisEnterprise_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (enterprise *RedisEnterprise) Owner() *genruntime.ResourceReference {
	if enterprise.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(enterprise.Spec)
	return enterprise.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (enterprise *RedisEnterprise) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*RedisEnterprise_STATUS); ok {
		enterprise.Status = *st
		return nil
	}

	// Convert status to required version
	var st RedisEnterprise_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	enterprise.Status = st
	return nil
}

// AssignProperties_From_RedisEnterprise populates our RedisEnterprise from the provided source RedisEnterprise
func (enterprise *RedisEnterprise) AssignProperties_From_RedisEnterprise(source *storage.RedisEnterprise) error {

	// ObjectMeta
	enterprise.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec RedisEnterprise_Spec
	err := spec.AssignProperties_From_RedisEnterprise_Spec(&source.Spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_RedisEnterprise_Spec() to populate field Spec")
	}
	enterprise.Spec = spec

	// Status
	var status RedisEnterprise_STATUS
	err = status.AssignProperties_From_RedisEnterprise_STATUS(&source.Status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_From_RedisEnterprise_STATUS() to populate field Status")
	}
	enterprise.Status = status

	// No error
	return nil
}

// AssignProperties_To_RedisEnterprise populates the provided destination RedisEnterprise from our RedisEnterprise
func (enterprise *RedisEnterprise) AssignProperties_To_RedisEnterprise(destination *storage.RedisEnterprise) error {

	// ObjectMeta
	destination.ObjectMeta = *enterprise.ObjectMeta.DeepCopy()

	// Spec
	var spec storage.RedisEnterprise_Spec
	err := enterprise.Spec.AssignProperties_To_RedisEnterprise_Spec(&spec)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_RedisEnterprise_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status storage.RedisEnterprise_STATUS
	err = enterprise.Status.AssignProperties_To_RedisEnterprise_STATUS(&status)
	if err != nil {
		return eris.Wrap(err, "calling AssignProperties_To_RedisEnterprise_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (enterprise *RedisEnterprise) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: enterprise.Spec.OriginalVersion(),
		Kind:    "RedisEnterprise",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /redisenterprise/resource-manager/Microsoft.Cache/stable/2025-04-01/redisenterprise.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redisEnterprise/{clusterName}
type RedisEnterpriseList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []RedisEnterprise `json:"items"`
}

// +kubebuilder:validation:Enum={"2025-04-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2025-04-01")

type RedisEnterprise_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// Encryption: Encryption-at-rest configuration for the cluster.
	Encryption *ClusterProperties_Encryption `json:"encryption,omitempty"`

	// HighAvailability: Enabled by default. If highAvailability is disabled, the data set is not replicated. This affects the
	// availability SLA, and increases the risk of data loss.
	HighAvailability *ClusterProperties_HighAvailability `json:"highAvailability,omitempty"`

	// Identity: The identity of the resource.
	Identity *ManagedServiceIdentity `json:"identity,omitempty"`

	// Kind: Distinguishes the kind of cluster. Read-only.
	Kind *Kind `json:"kind,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// MinimumTlsVersion: The minimum TLS version for the cluster to support, e.g. '1.2'. Newer versions can be added in the
	// future. Note that TLS 1.0 and TLS 1.1 are now completely obsolete -- you cannot use them. They are mentioned only for
	// the sake of consistency with old API versions.
	MinimumTlsVersion *ClusterProperties_MinimumTlsVersion `json:"minimumTlsVersion,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *RedisEnterpriseOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// +kubebuilder:validation:Required
	// Sku: The SKU to create, which affects price, performance, and features.
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Zones: The Availability Zones where this cluster will be deployed.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ARMTransformer = &RedisEnterprise_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (enterprise *RedisEnterprise_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if enterprise == nil {
		return nil, nil
	}
	result := &arm.RedisEnterprise_Spec{}

	// Set property "Identity":
	if enterprise.Identity != nil {
		identity_ARM, err := (*enterprise.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*arm.ManagedServiceIdentity)
		result.Identity = &identity
	}

	// Set property "Kind":
	if enterprise.Kind != nil {
		var temp string
		temp = string(*enterprise.Kind)
		kind := arm.Kind(temp)
		result.Kind = &kind
	}

	// Set property "Location":
	if enterprise.Location != nil {
		location := *enterprise.Location
		result.Location = &location
	}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if enterprise.Encryption != nil ||
		enterprise.HighAvailability != nil ||
		enterprise.MinimumTlsVersion != nil {
		result.Properties = &arm.ClusterProperties{}
	}
	if enterprise.Encryption != nil {
		encryption_ARM, err := (*enterprise.Encryption).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryption := *encryption_ARM.(*arm.ClusterProperties_Encryption)
		result.Properties.Encryption = &encryption
	}
	if enterprise.HighAvailability != nil {
		var temp string
		temp = string(*enterprise.HighAvailability)
		highAvailability := arm.ClusterProperties_HighAvailability(temp)
		result.Properties.HighAvailability = &highAvailability
	}
	if enterprise.MinimumTlsVersion != nil {
		var temp string
		temp = string(*enterprise.MinimumTlsVersion)
		minimumTlsVersion := arm.ClusterProperties_MinimumTlsVersion(temp)
		result.Properties.MinimumTlsVersion = &minimumTlsVersion
	}

	// Set property "Sku":
	if enterprise.Sku != nil {
		sku_ARM, err := (*enterprise.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*arm.Sku)
		result.Sku = &sku
	}

	// Set property "Tags":
	if enterprise.Tags != nil {
		result.Tags = make(map[string]string, len(enterprise.Tags))
		for key, value := range enterprise.Tags {
			result.Tags[key] = value
		}
	}

	// Set property "Zones":
	for _, item := range enterprise.Zones {
		result.Zones = append(result.Zones, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (enterprise *RedisEnterprise_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RedisEnterprise_Spec{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (enterprise *RedisEnterprise_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RedisEnterprise_Spec)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RedisEnterprise_Spec, got %T", armInput)
	}

	// Set property "AzureName":
	enterprise.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "Encryption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Encryption != nil {
			var encryption1 ClusterProperties_Encryption
			err := encryption1.PopulateFromARM(owner, *typedInput.Properties.Encryption)
			if err != nil {
				return err
			}
			encryption := encryption1
			enterprise.Encryption = &encryption
		}
	}

	// Set property "HighAvailability":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HighAvailability != nil {
			var temp string
			temp = string(*typedInput.Properties.HighAvailability)
			highAvailability := ClusterProperties_HighAvailability(temp)
			enterprise.HighAvailability = &highAvailability
		}
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		enterprise.Identity = &identity
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		var temp string
		temp = string(*typedInput.Kind)
		kind := Kind(temp)
		enterprise.Kind = &kind
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		enterprise.Location = &location
	}

	// Set property "MinimumTlsVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinimumTlsVersion != nil {
			var temp string
			temp = string(*typedInput.Properties.MinimumTlsVersion)
			minimumTlsVersion := ClusterProperties_MinimumTlsVersion(temp)
			enterprise.MinimumTlsVersion = &minimumTlsVersion
		}
	}

	// no assignment for property "OperatorSpec"

	// Set property "Owner":
	enterprise.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		enterprise.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		enterprise.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			enterprise.Tags[key] = value
		}
	}

	// Set property "Zones":
	for _, item := range typedInput.Zones {
		enterprise.Zones = append(enterprise.Zones, item)
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &RedisEnterprise_Spec{}

// ConvertSpecFrom populates our RedisEnterprise_Spec from the provided source
func (enterprise *RedisEnterprise_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*storage.RedisEnterprise_Spec)
	if ok {
		// Populate our instance from source
		return enterprise.AssignProperties_From_RedisEnterprise_Spec(src)
	}

	// Convert to an intermediate form
	src = &storage.RedisEnterprise_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = enterprise.AssignProperties_From_RedisEnterprise_Spec(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our RedisEnterprise_Spec
func (enterprise *RedisEnterprise_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*storage.RedisEnterprise_Spec)
	if ok {
		// Populate destination from our instance
		return enterprise.AssignProperties_To_RedisEnterprise_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &storage.RedisEnterprise_Spec{}
	err := enterprise.AssignProperties_To_RedisEnterprise_Spec(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_RedisEnterprise_Spec populates our RedisEnterprise_Spec from the provided source RedisEnterprise_Spec
func (enterprise *RedisEnterprise_Spec) AssignProperties_From_RedisEnterprise_Spec(source *storage.RedisEnterprise_Spec) error {

	// AzureName
	enterprise.AzureName = source.AzureName

	// Encryption
	if source.Encryption != nil {
		var encryption ClusterProperties_Encryption
		err := encryption.AssignProperties_From_ClusterProperties_Encryption(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClusterProperties_Encryption() to populate field Encryption")
		}
		enterprise.Encryption = &encryption
	} else {
		enterprise.Encryption = nil
	}

	// HighAvailability
	if source.HighAvailability != nil {
		highAvailability := *source.HighAvailability
		highAvailabilityTemp := genruntime.ToEnum(highAvailability, clusterProperties_HighAvailability_Values)
		enterprise.HighAvailability = &highAvailabilityTemp
	} else {
		enterprise.HighAvailability = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.AssignProperties_From_ManagedServiceIdentity(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity() to populate field Identity")
		}
		enterprise.Identity = &identity
	} else {
		enterprise.Identity = nil
	}

	// Kind
	if source.Kind != nil {
		kind := *source.Kind
		kindTemp := genruntime.ToEnum(kind, kind_Values)
		enterprise.Kind = &kindTemp
	} else {
		enterprise.Kind = nil
	}

	// Location
	enterprise.Location = genruntime.ClonePointerToString(source.Location)

	// MinimumTlsVersion
	if source.MinimumTlsVersion != nil {
		minimumTlsVersion := *source.MinimumTlsVersion
		minimumTlsVersionTemp := genruntime.ToEnum(minimumTlsVersion, clusterProperties_MinimumTlsVersion_Values)
		enterprise.MinimumTlsVersion = &minimumTlsVersionTemp
	} else {
		enterprise.MinimumTlsVersion = nil
	}

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec RedisEnterpriseOperatorSpec
		err := operatorSpec.AssignProperties_From_RedisEnterpriseOperatorSpec(source.OperatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_RedisEnterpriseOperatorSpec() to populate field OperatorSpec")
		}
		enterprise.OperatorSpec = &operatorSpec
	} else {
		enterprise.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		enterprise.Owner = &owner
	} else {
		enterprise.Owner = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		enterprise.Sku = &sku
	} else {
		enterprise.Sku = nil
	}

	// Tags
	enterprise.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Zones
	enterprise.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_RedisEnterprise_Spec populates the provided destination RedisEnterprise_Spec from our RedisEnterprise_Spec
func (enterprise *RedisEnterprise_Spec) AssignProperties_To_RedisEnterprise_Spec(destination *storage.RedisEnterprise_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = enterprise.AzureName

	// Encryption
	if enterprise.Encryption != nil {
		var encryption storage.ClusterProperties_Encryption
		err := enterprise.Encryption.AssignProperties_To_ClusterProperties_Encryption(&encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClusterProperties_Encryption() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// HighAvailability
	if enterprise.HighAvailability != nil {
		highAvailability := string(*enterprise.HighAvailability)
		destination.HighAvailability = &highAvailability
	} else {
		destination.HighAvailability = nil
	}

	// Identity
	if enterprise.Identity != nil {
		var identity storage.ManagedServiceIdentity
		err := enterprise.Identity.AssignProperties_To_ManagedServiceIdentity(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Kind
	if enterprise.Kind != nil {
		kind := string(*enterprise.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(enterprise.Location)

	// MinimumTlsVersion
	if enterprise.MinimumTlsVersion != nil {
		minimumTlsVersion := string(*enterprise.MinimumTlsVersion)
		destination.MinimumTlsVersion = &minimumTlsVersion
	} else {
		destination.MinimumTlsVersion = nil
	}

	// OperatorSpec
	if enterprise.OperatorSpec != nil {
		var operatorSpec storage.RedisEnterpriseOperatorSpec
		err := enterprise.OperatorSpec.AssignProperties_To_RedisEnterpriseOperatorSpec(&operatorSpec)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_RedisEnterpriseOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = enterprise.OriginalVersion()

	// Owner
	if enterprise.Owner != nil {
		owner := enterprise.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Sku
	if enterprise.Sku != nil {
		var sku storage.Sku
		err := enterprise.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(enterprise.Tags)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(enterprise.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RedisEnterprise_STATUS populates our RedisEnterprise_Spec from the provided source RedisEnterprise_STATUS
func (enterprise *RedisEnterprise_Spec) Initialize_From_RedisEnterprise_STATUS(source *RedisEnterprise_STATUS) error {

	// Encryption
	if source.Encryption != nil {
		var encryption ClusterProperties_Encryption
		err := encryption.Initialize_From_ClusterProperties_Encryption_STATUS(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ClusterProperties_Encryption_STATUS() to populate field Encryption")
		}
		enterprise.Encryption = &encryption
	} else {
		enterprise.Encryption = nil
	}

	// HighAvailability
	if source.HighAvailability != nil {
		highAvailability := genruntime.ToEnum(string(*source.HighAvailability), clusterProperties_HighAvailability_Values)
		enterprise.HighAvailability = &highAvailability
	} else {
		enterprise.HighAvailability = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity
		err := identity.Initialize_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		enterprise.Identity = &identity
	} else {
		enterprise.Identity = nil
	}

	// Kind
	if source.Kind != nil {
		kind := genruntime.ToEnum(string(*source.Kind), kind_Values)
		enterprise.Kind = &kind
	} else {
		enterprise.Kind = nil
	}

	// Location
	enterprise.Location = genruntime.ClonePointerToString(source.Location)

	// MinimumTlsVersion
	if source.MinimumTlsVersion != nil {
		minimumTlsVersion := genruntime.ToEnum(string(*source.MinimumTlsVersion), clusterProperties_MinimumTlsVersion_Values)
		enterprise.MinimumTlsVersion = &minimumTlsVersion
	} else {
		enterprise.MinimumTlsVersion = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		enterprise.Sku = &sku
	} else {
		enterprise.Sku = nil
	}

	// Tags
	enterprise.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Zones
	enterprise.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (enterprise *RedisEnterprise_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (enterprise *RedisEnterprise_Spec) SetAzureName(azureName string) {
	enterprise.AzureName = azureName
}

type RedisEnterprise_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// Encryption: Encryption-at-rest configuration for the cluster.
	Encryption *ClusterProperties_Encryption_STATUS `json:"encryption,omitempty"`

	// HighAvailability: Enabled by default. If highAvailability is disabled, the data set is not replicated. This affects the
	// availability SLA, and increases the risk of data loss.
	HighAvailability *ClusterProperties_HighAvailability_STATUS `json:"highAvailability,omitempty"`

	// HostName: DNS name of the cluster endpoint
	HostName *string `json:"hostName,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the resource.
	Identity *ManagedServiceIdentity_STATUS `json:"identity,omitempty"`

	// Kind: Distinguishes the kind of cluster. Read-only.
	Kind *Kind_STATUS `json:"kind,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// MinimumTlsVersion: The minimum TLS version for the cluster to support, e.g. '1.2'. Newer versions can be added in the
	// future. Note that TLS 1.0 and TLS 1.1 are now completely obsolete -- you cannot use them. They are mentioned only for
	// the sake of consistency with old API versions.
	MinimumTlsVersion *ClusterProperties_MinimumTlsVersion_STATUS `json:"minimumTlsVersion,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// PrivateEndpointConnections: List of private endpoint connections associated with the specified Redis Enterprise cluster
	PrivateEndpointConnections []PrivateEndpointConnection_STATUS `json:"privateEndpointConnections,omitempty"`

	// ProvisioningState: Current provisioning status of the cluster
	ProvisioningState *ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// RedisVersion: Version of redis the cluster supports, e.g. '6'
	RedisVersion *string `json:"redisVersion,omitempty"`

	// RedundancyMode: Explains the current redundancy strategy of the cluster, which affects the expected SLA.
	RedundancyMode *ClusterProperties_RedundancyMode_STATUS `json:"redundancyMode,omitempty"`

	// ResourceState: Current resource status of the cluster
	ResourceState *ResourceState_STATUS `json:"resourceState,omitempty"`

	// Sku: The SKU to create, which affects price, performance, and features.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`

	// Zones: The Availability Zones where this cluster will be deployed.
	Zones []string `json:"zones,omitempty"`
}

var _ genruntime.ConvertibleStatus = &RedisEnterprise_STATUS{}

// ConvertStatusFrom populates our RedisEnterprise_STATUS from the provided source
func (enterprise *RedisEnterprise_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*storage.RedisEnterprise_STATUS)
	if ok {
		// Populate our instance from source
		return enterprise.AssignProperties_From_RedisEnterprise_STATUS(src)
	}

	// Convert to an intermediate form
	src = &storage.RedisEnterprise_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = enterprise.AssignProperties_From_RedisEnterprise_STATUS(src)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our RedisEnterprise_STATUS
func (enterprise *RedisEnterprise_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*storage.RedisEnterprise_STATUS)
	if ok {
		// Populate destination from our instance
		return enterprise.AssignProperties_To_RedisEnterprise_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &storage.RedisEnterprise_STATUS{}
	err := enterprise.AssignProperties_To_RedisEnterprise_STATUS(dst)
	if err != nil {
		return eris.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return eris.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &RedisEnterprise_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (enterprise *RedisEnterprise_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.RedisEnterprise_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (enterprise *RedisEnterprise_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.RedisEnterprise_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.RedisEnterprise_STATUS, got %T", armInput)
	}

	// no assignment for property "Conditions"

	// Set property "Encryption":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Encryption != nil {
			var encryption1 ClusterProperties_Encryption_STATUS
			err := encryption1.PopulateFromARM(owner, *typedInput.Properties.Encryption)
			if err != nil {
				return err
			}
			encryption := encryption1
			enterprise.Encryption = &encryption
		}
	}

	// Set property "HighAvailability":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HighAvailability != nil {
			var temp string
			temp = string(*typedInput.Properties.HighAvailability)
			highAvailability := ClusterProperties_HighAvailability_STATUS(temp)
			enterprise.HighAvailability = &highAvailability
		}
	}

	// Set property "HostName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			enterprise.HostName = &hostName
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		enterprise.Id = &id
	}

	// Set property "Identity":
	if typedInput.Identity != nil {
		var identity1 ManagedServiceIdentity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		enterprise.Identity = &identity
	}

	// Set property "Kind":
	if typedInput.Kind != nil {
		var temp string
		temp = string(*typedInput.Kind)
		kind := Kind_STATUS(temp)
		enterprise.Kind = &kind
	}

	// Set property "Location":
	if typedInput.Location != nil {
		location := *typedInput.Location
		enterprise.Location = &location
	}

	// Set property "MinimumTlsVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinimumTlsVersion != nil {
			var temp string
			temp = string(*typedInput.Properties.MinimumTlsVersion)
			minimumTlsVersion := ClusterProperties_MinimumTlsVersion_STATUS(temp)
			enterprise.MinimumTlsVersion = &minimumTlsVersion
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		enterprise.Name = &name
	}

	// Set property "PrivateEndpointConnections":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateEndpointConnections {
			var item1 PrivateEndpointConnection_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			enterprise.PrivateEndpointConnections = append(enterprise.PrivateEndpointConnections, item1)
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			var temp string
			temp = string(*typedInput.Properties.ProvisioningState)
			provisioningState := ProvisioningState_STATUS(temp)
			enterprise.ProvisioningState = &provisioningState
		}
	}

	// Set property "RedisVersion":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RedisVersion != nil {
			redisVersion := *typedInput.Properties.RedisVersion
			enterprise.RedisVersion = &redisVersion
		}
	}

	// Set property "RedundancyMode":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RedundancyMode != nil {
			var temp string
			temp = string(*typedInput.Properties.RedundancyMode)
			redundancyMode := ClusterProperties_RedundancyMode_STATUS(temp)
			enterprise.RedundancyMode = &redundancyMode
		}
	}

	// Set property "ResourceState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceState != nil {
			var temp string
			temp = string(*typedInput.Properties.ResourceState)
			resourceState := ResourceState_STATUS(temp)
			enterprise.ResourceState = &resourceState
		}
	}

	// Set property "Sku":
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		enterprise.Sku = &sku
	}

	// Set property "Tags":
	if typedInput.Tags != nil {
		enterprise.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			enterprise.Tags[key] = value
		}
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		enterprise.Type = &typeVar
	}

	// Set property "Zones":
	for _, item := range typedInput.Zones {
		enterprise.Zones = append(enterprise.Zones, item)
	}

	// No error
	return nil
}

// AssignProperties_From_RedisEnterprise_STATUS populates our RedisEnterprise_STATUS from the provided source RedisEnterprise_STATUS
func (enterprise *RedisEnterprise_STATUS) AssignProperties_From_RedisEnterprise_STATUS(source *storage.RedisEnterprise_STATUS) error {

	// Conditions
	enterprise.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Encryption
	if source.Encryption != nil {
		var encryption ClusterProperties_Encryption_STATUS
		err := encryption.AssignProperties_From_ClusterProperties_Encryption_STATUS(source.Encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClusterProperties_Encryption_STATUS() to populate field Encryption")
		}
		enterprise.Encryption = &encryption
	} else {
		enterprise.Encryption = nil
	}

	// HighAvailability
	if source.HighAvailability != nil {
		highAvailability := *source.HighAvailability
		highAvailabilityTemp := genruntime.ToEnum(highAvailability, clusterProperties_HighAvailability_STATUS_Values)
		enterprise.HighAvailability = &highAvailabilityTemp
	} else {
		enterprise.HighAvailability = nil
	}

	// HostName
	enterprise.HostName = genruntime.ClonePointerToString(source.HostName)

	// Id
	enterprise.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedServiceIdentity_STATUS
		err := identity.AssignProperties_From_ManagedServiceIdentity_STATUS(source.Identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		enterprise.Identity = &identity
	} else {
		enterprise.Identity = nil
	}

	// Kind
	if source.Kind != nil {
		kind := *source.Kind
		kindTemp := genruntime.ToEnum(kind, kind_STATUS_Values)
		enterprise.Kind = &kindTemp
	} else {
		enterprise.Kind = nil
	}

	// Location
	enterprise.Location = genruntime.ClonePointerToString(source.Location)

	// MinimumTlsVersion
	if source.MinimumTlsVersion != nil {
		minimumTlsVersion := *source.MinimumTlsVersion
		minimumTlsVersionTemp := genruntime.ToEnum(minimumTlsVersion, clusterProperties_MinimumTlsVersion_STATUS_Values)
		enterprise.MinimumTlsVersion = &minimumTlsVersionTemp
	} else {
		enterprise.MinimumTlsVersion = nil
	}

	// Name
	enterprise.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]PrivateEndpointConnection_STATUS, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection PrivateEndpointConnection_STATUS
			err := privateEndpointConnection.AssignProperties_From_PrivateEndpointConnection_STATUS(&privateEndpointConnectionItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		enterprise.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		enterprise.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := *source.ProvisioningState
		provisioningStateTemp := genruntime.ToEnum(provisioningState, provisioningState_STATUS_Values)
		enterprise.ProvisioningState = &provisioningStateTemp
	} else {
		enterprise.ProvisioningState = nil
	}

	// RedisVersion
	enterprise.RedisVersion = genruntime.ClonePointerToString(source.RedisVersion)

	// RedundancyMode
	if source.RedundancyMode != nil {
		redundancyMode := *source.RedundancyMode
		redundancyModeTemp := genruntime.ToEnum(redundancyMode, clusterProperties_RedundancyMode_STATUS_Values)
		enterprise.RedundancyMode = &redundancyModeTemp
	} else {
		enterprise.RedundancyMode = nil
	}

	// ResourceState
	if source.ResourceState != nil {
		resourceState := *source.ResourceState
		resourceStateTemp := genruntime.ToEnum(resourceState, resourceState_STATUS_Values)
		enterprise.ResourceState = &resourceStateTemp
	} else {
		enterprise.ResourceState = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		enterprise.Sku = &sku
	} else {
		enterprise.Sku = nil
	}

	// Tags
	enterprise.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	enterprise.Type = genruntime.ClonePointerToString(source.Type)

	// Zones
	enterprise.Zones = genruntime.CloneSliceOfString(source.Zones)

	// No error
	return nil
}

// AssignProperties_To_RedisEnterprise_STATUS populates the provided destination RedisEnterprise_STATUS from our RedisEnterprise_STATUS
func (enterprise *RedisEnterprise_STATUS) AssignProperties_To_RedisEnterprise_STATUS(destination *storage.RedisEnterprise_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(enterprise.Conditions)

	// Encryption
	if enterprise.Encryption != nil {
		var encryption storage.ClusterProperties_Encryption_STATUS
		err := enterprise.Encryption.AssignProperties_To_ClusterProperties_Encryption_STATUS(&encryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClusterProperties_Encryption_STATUS() to populate field Encryption")
		}
		destination.Encryption = &encryption
	} else {
		destination.Encryption = nil
	}

	// HighAvailability
	if enterprise.HighAvailability != nil {
		highAvailability := string(*enterprise.HighAvailability)
		destination.HighAvailability = &highAvailability
	} else {
		destination.HighAvailability = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(enterprise.HostName)

	// Id
	destination.Id = genruntime.ClonePointerToString(enterprise.Id)

	// Identity
	if enterprise.Identity != nil {
		var identity storage.ManagedServiceIdentity_STATUS
		err := enterprise.Identity.AssignProperties_To_ManagedServiceIdentity_STATUS(&identity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ManagedServiceIdentity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Kind
	if enterprise.Kind != nil {
		kind := string(*enterprise.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(enterprise.Location)

	// MinimumTlsVersion
	if enterprise.MinimumTlsVersion != nil {
		minimumTlsVersion := string(*enterprise.MinimumTlsVersion)
		destination.MinimumTlsVersion = &minimumTlsVersion
	} else {
		destination.MinimumTlsVersion = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(enterprise.Name)

	// PrivateEndpointConnections
	if enterprise.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]storage.PrivateEndpointConnection_STATUS, len(enterprise.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range enterprise.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection storage.PrivateEndpointConnection_STATUS
			err := privateEndpointConnectionItem.AssignProperties_To_PrivateEndpointConnection_STATUS(&privateEndpointConnection)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if enterprise.ProvisioningState != nil {
		provisioningState := string(*enterprise.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// RedisVersion
	destination.RedisVersion = genruntime.ClonePointerToString(enterprise.RedisVersion)

	// RedundancyMode
	if enterprise.RedundancyMode != nil {
		redundancyMode := string(*enterprise.RedundancyMode)
		destination.RedundancyMode = &redundancyMode
	} else {
		destination.RedundancyMode = nil
	}

	// ResourceState
	if enterprise.ResourceState != nil {
		resourceState := string(*enterprise.ResourceState)
		destination.ResourceState = &resourceState
	} else {
		destination.ResourceState = nil
	}

	// Sku
	if enterprise.Sku != nil {
		var sku storage.Sku_STATUS
		err := enterprise.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(enterprise.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(enterprise.Type)

	// Zones
	destination.Zones = genruntime.CloneSliceOfString(enterprise.Zones)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ClusterProperties_Encryption struct {
	// CustomerManagedKeyEncryption: All Customer-managed key encryption properties for the resource. Set this to an empty
	// object to use Microsoft-managed key encryption.
	CustomerManagedKeyEncryption *ClusterProperties_Encryption_CustomerManagedKeyEncryption `json:"customerManagedKeyEncryption,omitempty"`
}

var _ genruntime.ARMTransformer = &ClusterProperties_Encryption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (encryption *ClusterProperties_Encryption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if encryption == nil {
		return nil, nil
	}
	result := &arm.ClusterProperties_Encryption{}

	// Set property "CustomerManagedKeyEncryption":
	if encryption.CustomerManagedKeyEncryption != nil {
		customerManagedKeyEncryption_ARM, err := (*encryption.CustomerManagedKeyEncryption).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customerManagedKeyEncryption := *customerManagedKeyEncryption_ARM.(*arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption)
		result.CustomerManagedKeyEncryption = &customerManagedKeyEncryption
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *ClusterProperties_Encryption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClusterProperties_Encryption{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *ClusterProperties_Encryption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClusterProperties_Encryption)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClusterProperties_Encryption, got %T", armInput)
	}

	// Set property "CustomerManagedKeyEncryption":
	if typedInput.CustomerManagedKeyEncryption != nil {
		var customerManagedKeyEncryption1 ClusterProperties_Encryption_CustomerManagedKeyEncryption
		err := customerManagedKeyEncryption1.PopulateFromARM(owner, *typedInput.CustomerManagedKeyEncryption)
		if err != nil {
			return err
		}
		customerManagedKeyEncryption := customerManagedKeyEncryption1
		encryption.CustomerManagedKeyEncryption = &customerManagedKeyEncryption
	}

	// No error
	return nil
}

// AssignProperties_From_ClusterProperties_Encryption populates our ClusterProperties_Encryption from the provided source ClusterProperties_Encryption
func (encryption *ClusterProperties_Encryption) AssignProperties_From_ClusterProperties_Encryption(source *storage.ClusterProperties_Encryption) error {

	// CustomerManagedKeyEncryption
	if source.CustomerManagedKeyEncryption != nil {
		var customerManagedKeyEncryption ClusterProperties_Encryption_CustomerManagedKeyEncryption
		err := customerManagedKeyEncryption.AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption(source.CustomerManagedKeyEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption() to populate field CustomerManagedKeyEncryption")
		}
		encryption.CustomerManagedKeyEncryption = &customerManagedKeyEncryption
	} else {
		encryption.CustomerManagedKeyEncryption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ClusterProperties_Encryption populates the provided destination ClusterProperties_Encryption from our ClusterProperties_Encryption
func (encryption *ClusterProperties_Encryption) AssignProperties_To_ClusterProperties_Encryption(destination *storage.ClusterProperties_Encryption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomerManagedKeyEncryption
	if encryption.CustomerManagedKeyEncryption != nil {
		var customerManagedKeyEncryption storage.ClusterProperties_Encryption_CustomerManagedKeyEncryption
		err := encryption.CustomerManagedKeyEncryption.AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption(&customerManagedKeyEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption() to populate field CustomerManagedKeyEncryption")
		}
		destination.CustomerManagedKeyEncryption = &customerManagedKeyEncryption
	} else {
		destination.CustomerManagedKeyEncryption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ClusterProperties_Encryption_STATUS populates our ClusterProperties_Encryption from the provided source ClusterProperties_Encryption_STATUS
func (encryption *ClusterProperties_Encryption) Initialize_From_ClusterProperties_Encryption_STATUS(source *ClusterProperties_Encryption_STATUS) error {

	// CustomerManagedKeyEncryption
	if source.CustomerManagedKeyEncryption != nil {
		var customerManagedKeyEncryption ClusterProperties_Encryption_CustomerManagedKeyEncryption
		err := customerManagedKeyEncryption.Initialize_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS(source.CustomerManagedKeyEncryption)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS() to populate field CustomerManagedKeyEncryption")
		}
		encryption.CustomerManagedKeyEncryption = &customerManagedKeyEncryption
	} else {
		encryption.CustomerManagedKeyEncryption = nil
	}

	// No error
	return nil
}

type ClusterProperties_Encryption_STATUS struct {
	// CustomerManagedKeyEncryption: All Customer-managed key encryption properties for the resource. Set this to an empty
	// object to use Microsoft-managed key encryption.
	CustomerManagedKeyEncryption *ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS `json:"customerManagedKeyEncryption,omitempty"`
}

var _ genruntime.FromARMConverter = &ClusterProperties_Encryption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *ClusterProperties_Encryption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClusterProperties_Encryption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *ClusterProperties_Encryption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClusterProperties_Encryption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClusterProperties_Encryption_STATUS, got %T", armInput)
	}

	// Set property "CustomerManagedKeyEncryption":
	if typedInput.CustomerManagedKeyEncryption != nil {
		var customerManagedKeyEncryption1 ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS
		err := customerManagedKeyEncryption1.PopulateFromARM(owner, *typedInput.CustomerManagedKeyEncryption)
		if err != nil {
			return err
		}
		customerManagedKeyEncryption := customerManagedKeyEncryption1
		encryption.CustomerManagedKeyEncryption = &customerManagedKeyEncryption
	}

	// No error
	return nil
}

// AssignProperties_From_ClusterProperties_Encryption_STATUS populates our ClusterProperties_Encryption_STATUS from the provided source ClusterProperties_Encryption_STATUS
func (encryption *ClusterProperties_Encryption_STATUS) AssignProperties_From_ClusterProperties_Encryption_STATUS(source *storage.ClusterProperties_Encryption_STATUS) error {

	// CustomerManagedKeyEncryption
	if source.CustomerManagedKeyEncryption != nil {
		var customerManagedKeyEncryption ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS
		err := customerManagedKeyEncryption.AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS(source.CustomerManagedKeyEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS() to populate field CustomerManagedKeyEncryption")
		}
		encryption.CustomerManagedKeyEncryption = &customerManagedKeyEncryption
	} else {
		encryption.CustomerManagedKeyEncryption = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ClusterProperties_Encryption_STATUS populates the provided destination ClusterProperties_Encryption_STATUS from our ClusterProperties_Encryption_STATUS
func (encryption *ClusterProperties_Encryption_STATUS) AssignProperties_To_ClusterProperties_Encryption_STATUS(destination *storage.ClusterProperties_Encryption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomerManagedKeyEncryption
	if encryption.CustomerManagedKeyEncryption != nil {
		var customerManagedKeyEncryption storage.ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS
		err := encryption.CustomerManagedKeyEncryption.AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS(&customerManagedKeyEncryption)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS() to populate field CustomerManagedKeyEncryption")
		}
		destination.CustomerManagedKeyEncryption = &customerManagedKeyEncryption
	} else {
		destination.CustomerManagedKeyEncryption = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Enabled"}
type ClusterProperties_HighAvailability string

const (
	ClusterProperties_HighAvailability_Disabled = ClusterProperties_HighAvailability("Disabled")
	ClusterProperties_HighAvailability_Enabled  = ClusterProperties_HighAvailability("Enabled")
)

// Mapping from string to ClusterProperties_HighAvailability
var clusterProperties_HighAvailability_Values = map[string]ClusterProperties_HighAvailability{
	"disabled": ClusterProperties_HighAvailability_Disabled,
	"enabled":  ClusterProperties_HighAvailability_Enabled,
}

type ClusterProperties_HighAvailability_STATUS string

const (
	ClusterProperties_HighAvailability_STATUS_Disabled = ClusterProperties_HighAvailability_STATUS("Disabled")
	ClusterProperties_HighAvailability_STATUS_Enabled  = ClusterProperties_HighAvailability_STATUS("Enabled")
)

// Mapping from string to ClusterProperties_HighAvailability_STATUS
var clusterProperties_HighAvailability_STATUS_Values = map[string]ClusterProperties_HighAvailability_STATUS{
	"disabled": ClusterProperties_HighAvailability_STATUS_Disabled,
	"enabled":  ClusterProperties_HighAvailability_STATUS_Enabled,
}

// +kubebuilder:validation:Enum={"1.0","1.1","1.2"}
type ClusterProperties_MinimumTlsVersion string

const (
	ClusterProperties_MinimumTlsVersion_10 = ClusterProperties_MinimumTlsVersion("1.0")
	ClusterProperties_MinimumTlsVersion_11 = ClusterProperties_MinimumTlsVersion("1.1")
	ClusterProperties_MinimumTlsVersion_12 = ClusterProperties_MinimumTlsVersion("1.2")
)

// Mapping from string to ClusterProperties_MinimumTlsVersion
var clusterProperties_MinimumTlsVersion_Values = map[string]ClusterProperties_MinimumTlsVersion{
	"1.0": ClusterProperties_MinimumTlsVersion_10,
	"1.1": ClusterProperties_MinimumTlsVersion_11,
	"1.2": ClusterProperties_MinimumTlsVersion_12,
}

type ClusterProperties_MinimumTlsVersion_STATUS string

const (
	ClusterProperties_MinimumTlsVersion_STATUS_10 = ClusterProperties_MinimumTlsVersion_STATUS("1.0")
	ClusterProperties_MinimumTlsVersion_STATUS_11 = ClusterProperties_MinimumTlsVersion_STATUS("1.1")
	ClusterProperties_MinimumTlsVersion_STATUS_12 = ClusterProperties_MinimumTlsVersion_STATUS("1.2")
)

// Mapping from string to ClusterProperties_MinimumTlsVersion_STATUS
var clusterProperties_MinimumTlsVersion_STATUS_Values = map[string]ClusterProperties_MinimumTlsVersion_STATUS{
	"1.0": ClusterProperties_MinimumTlsVersion_STATUS_10,
	"1.1": ClusterProperties_MinimumTlsVersion_STATUS_11,
	"1.2": ClusterProperties_MinimumTlsVersion_STATUS_12,
}

type ClusterProperties_RedundancyMode_STATUS string

const (
	ClusterProperties_RedundancyMode_STATUS_LR   = ClusterProperties_RedundancyMode_STATUS("LR")
	ClusterProperties_RedundancyMode_STATUS_None = ClusterProperties_RedundancyMode_STATUS("None")
	ClusterProperties_RedundancyMode_STATUS_ZR   = ClusterProperties_RedundancyMode_STATUS("ZR")
)

// Mapping from string to ClusterProperties_RedundancyMode_STATUS
var clusterProperties_RedundancyMode_STATUS_Values = map[string]ClusterProperties_RedundancyMode_STATUS{
	"lr":   ClusterProperties_RedundancyMode_STATUS_LR,
	"none": ClusterProperties_RedundancyMode_STATUS_None,
	"zr":   ClusterProperties_RedundancyMode_STATUS_ZR,
}

// Distinguishes the kind of cluster. Read-only.
// +kubebuilder:validation:Enum={"v1","v2"}
type Kind string

const (
	Kind_V1 = Kind("v1")
	Kind_V2 = Kind("v2")
)

// Mapping from string to Kind
var kind_Values = map[string]Kind{
	"v1": Kind_V1,
	"v2": Kind_V2,
}

// Distinguishes the kind of cluster. Read-only.
type Kind_STATUS string

const (
	Kind_STATUS_V1 = Kind_STATUS("v1")
	Kind_STATUS_V2 = Kind_STATUS("v2")
)

// Mapping from string to Kind_STATUS
var kind_STATUS_Values = map[string]Kind_STATUS{
	"v1": Kind_STATUS_V1,
	"v2": Kind_STATUS_V2,
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity struct {
	// +kubebuilder:validation:Required
	// Type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type                   *ManagedServiceIdentityType   `json:"type,omitempty"`
	UserAssignedIdentities []UserAssignedIdentityDetails `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.ARMTransformer = &ManagedServiceIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ManagedServiceIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ManagedServiceIdentity{}

	// Set property "Type":
	if identity.Type != nil {
		var temp string
		temp = string(*identity.Type)
		typeVar := arm.ManagedServiceIdentityType(temp)
		result.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	result.UserAssignedIdentities = make(map[string]arm.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
	for _, ident := range identity.UserAssignedIdentities {
		identARMID, err := resolved.ResolvedReferences.Lookup(ident.Reference)
		if err != nil {
			return nil, err
		}
		key := identARMID
		result.UserAssignedIdentities[key] = arm.UserAssignedIdentityDetails{}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity, got %T", armInput)
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentityType(temp)
		identity.Type = &typeVar
	}

	// no assignment for property "UserAssignedIdentities"

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_From_ManagedServiceIdentity(source *storage.ManagedServiceIdentity) error {

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentityType_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity UserAssignedIdentityDetails
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentityDetails(&userAssignedIdentityItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity populates the provided destination ManagedServiceIdentity from our ManagedServiceIdentity
func (identity *ManagedServiceIdentity) AssignProperties_To_ManagedServiceIdentity(destination *storage.ManagedServiceIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]storage.UserAssignedIdentityDetails, len(identity.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity storage.UserAssignedIdentityDetails
			err := userAssignedIdentityItem.AssignProperties_To_UserAssignedIdentityDetails(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentityDetails() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity) Initialize_From_ManagedServiceIdentity_STATUS(source *ManagedServiceIdentity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := genruntime.ToEnum(string(*source.Type), managedServiceIdentityType_Values)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]UserAssignedIdentityDetails, 0, len(source.UserAssignedIdentities))
		for userAssignedIdentitiesKey := range source.UserAssignedIdentities {
			userAssignedIdentitiesRef := genruntime.CreateResourceReferenceFromARMID(userAssignedIdentitiesKey)
			userAssignedIdentityList = append(userAssignedIdentityList, UserAssignedIdentityDetails{Reference: userAssignedIdentitiesRef})
		}
		identity.UserAssignedIdentities = userAssignedIdentityList
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// Managed service identity (system assigned and/or user assigned identities)
type ManagedServiceIdentity_STATUS struct {
	// PrincipalId: The service principal ID of the system assigned identity. This property will only be provided for a system
	// assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant ID of the system assigned identity. This property will only be provided for a system assigned
	// identity.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
	Type                   *ManagedServiceIdentityType_STATUS     `json:"type,omitempty"`
	UserAssignedIdentities map[string]UserAssignedIdentity_STATUS `json:"userAssignedIdentities,omitempty"`
}

var _ genruntime.FromARMConverter = &ManagedServiceIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ManagedServiceIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ManagedServiceIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ManagedServiceIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ManagedServiceIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ManagedServiceIdentity_STATUS, got %T", armInput)
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property "TenantId":
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property "Type":
	if typedInput.Type != nil {
		var temp string
		temp = string(*typedInput.Type)
		typeVar := ManagedServiceIdentityType_STATUS(temp)
		identity.Type = &typeVar
	}

	// Set property "UserAssignedIdentities":
	if typedInput.UserAssignedIdentities != nil {
		identity.UserAssignedIdentities = make(map[string]UserAssignedIdentity_STATUS, len(typedInput.UserAssignedIdentities))
		for key, value := range typedInput.UserAssignedIdentities {
			var value1 UserAssignedIdentity_STATUS
			err := value1.PopulateFromARM(owner, value)
			if err != nil {
				return err
			}
			identity.UserAssignedIdentities[key] = value1
		}
	}

	// No error
	return nil
}

// AssignProperties_From_ManagedServiceIdentity_STATUS populates our ManagedServiceIdentity_STATUS from the provided source ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_From_ManagedServiceIdentity_STATUS(source *storage.ManagedServiceIdentity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := *source.Type
		typeTemp := genruntime.ToEnum(typeVar, managedServiceIdentityType_STATUS_Values)
		identity.Type = &typeTemp
	} else {
		identity.Type = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]UserAssignedIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity UserAssignedIdentity_STATUS
			err := userAssignedIdentity.AssignProperties_From_UserAssignedIdentity_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedServiceIdentity_STATUS populates the provided destination ManagedServiceIdentity_STATUS from our ManagedServiceIdentity_STATUS
func (identity *ManagedServiceIdentity_STATUS) AssignProperties_To_ManagedServiceIdentity_STATUS(destination *storage.ManagedServiceIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]storage.UserAssignedIdentity_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
			var userAssignedIdentity storage.UserAssignedIdentity_STATUS
			err := userAssignedIdentityValue.AssignProperties_To_UserAssignedIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// The Private Endpoint Connection resource.
type PrivateEndpointConnection_STATUS struct {
	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *PrivateEndpointConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.PrivateEndpointConnection_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *PrivateEndpointConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.PrivateEndpointConnection_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.PrivateEndpointConnection_STATUS, got %T", armInput)
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointConnection_STATUS populates our PrivateEndpointConnection_STATUS from the provided source PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_From_PrivateEndpointConnection_STATUS(source *storage.PrivateEndpointConnection_STATUS) error {

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointConnection_STATUS populates the provided destination PrivateEndpointConnection_STATUS from our PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_To_PrivateEndpointConnection_STATUS(destination *storage.PrivateEndpointConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Current provisioning status
type ProvisioningState_STATUS string

const (
	ProvisioningState_STATUS_Canceled  = ProvisioningState_STATUS("Canceled")
	ProvisioningState_STATUS_Creating  = ProvisioningState_STATUS("Creating")
	ProvisioningState_STATUS_Deleting  = ProvisioningState_STATUS("Deleting")
	ProvisioningState_STATUS_Failed    = ProvisioningState_STATUS("Failed")
	ProvisioningState_STATUS_Succeeded = ProvisioningState_STATUS("Succeeded")
	ProvisioningState_STATUS_Updating  = ProvisioningState_STATUS("Updating")
)

// Mapping from string to ProvisioningState_STATUS
var provisioningState_STATUS_Values = map[string]ProvisioningState_STATUS{
	"canceled":  ProvisioningState_STATUS_Canceled,
	"creating":  ProvisioningState_STATUS_Creating,
	"deleting":  ProvisioningState_STATUS_Deleting,
	"failed":    ProvisioningState_STATUS_Failed,
	"succeeded": ProvisioningState_STATUS_Succeeded,
	"updating":  ProvisioningState_STATUS_Updating,
}

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type RedisEnterpriseOperatorSpec struct {
	// ConfigMapExpressions: configures where to place operator written dynamic ConfigMaps (created with CEL expressions).
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`

	// SecretExpressions: configures where to place operator written dynamic secrets (created with CEL expressions).
	SecretExpressions []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// AssignProperties_From_RedisEnterpriseOperatorSpec populates our RedisEnterpriseOperatorSpec from the provided source RedisEnterpriseOperatorSpec
func (operator *RedisEnterpriseOperatorSpec) AssignProperties_From_RedisEnterpriseOperatorSpec(source *storage.RedisEnterpriseOperatorSpec) error {

	// ConfigMapExpressions
	if source.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(source.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range source.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		operator.ConfigMapExpressions = configMapExpressionList
	} else {
		operator.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if source.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(source.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range source.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		operator.SecretExpressions = secretExpressionList
	} else {
		operator.SecretExpressions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RedisEnterpriseOperatorSpec populates the provided destination RedisEnterpriseOperatorSpec from our RedisEnterpriseOperatorSpec
func (operator *RedisEnterpriseOperatorSpec) AssignProperties_To_RedisEnterpriseOperatorSpec(destination *storage.RedisEnterpriseOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConfigMapExpressions
	if operator.ConfigMapExpressions != nil {
		configMapExpressionList := make([]*core.DestinationExpression, len(operator.ConfigMapExpressions))
		for configMapExpressionIndex, configMapExpressionItem := range operator.ConfigMapExpressions {
			// Shadow the loop variable to avoid aliasing
			configMapExpressionItem := configMapExpressionItem
			if configMapExpressionItem != nil {
				configMapExpression := *configMapExpressionItem.DeepCopy()
				configMapExpressionList[configMapExpressionIndex] = &configMapExpression
			} else {
				configMapExpressionList[configMapExpressionIndex] = nil
			}
		}
		destination.ConfigMapExpressions = configMapExpressionList
	} else {
		destination.ConfigMapExpressions = nil
	}

	// SecretExpressions
	if operator.SecretExpressions != nil {
		secretExpressionList := make([]*core.DestinationExpression, len(operator.SecretExpressions))
		for secretExpressionIndex, secretExpressionItem := range operator.SecretExpressions {
			// Shadow the loop variable to avoid aliasing
			secretExpressionItem := secretExpressionItem
			if secretExpressionItem != nil {
				secretExpression := *secretExpressionItem.DeepCopy()
				secretExpressionList[secretExpressionIndex] = &secretExpression
			} else {
				secretExpressionList[secretExpressionIndex] = nil
			}
		}
		destination.SecretExpressions = secretExpressionList
	} else {
		destination.SecretExpressions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Current resource status
type ResourceState_STATUS string

const (
	ResourceState_STATUS_CreateFailed  = ResourceState_STATUS("CreateFailed")
	ResourceState_STATUS_Creating      = ResourceState_STATUS("Creating")
	ResourceState_STATUS_DeleteFailed  = ResourceState_STATUS("DeleteFailed")
	ResourceState_STATUS_Deleting      = ResourceState_STATUS("Deleting")
	ResourceState_STATUS_DisableFailed = ResourceState_STATUS("DisableFailed")
	ResourceState_STATUS_Disabled      = ResourceState_STATUS("Disabled")
	ResourceState_STATUS_Disabling     = ResourceState_STATUS("Disabling")
	ResourceState_STATUS_EnableFailed  = ResourceState_STATUS("EnableFailed")
	ResourceState_STATUS_Enabling      = ResourceState_STATUS("Enabling")
	ResourceState_STATUS_Moving        = ResourceState_STATUS("Moving")
	ResourceState_STATUS_Running       = ResourceState_STATUS("Running")
	ResourceState_STATUS_Scaling       = ResourceState_STATUS("Scaling")
	ResourceState_STATUS_ScalingFailed = ResourceState_STATUS("ScalingFailed")
	ResourceState_STATUS_UpdateFailed  = ResourceState_STATUS("UpdateFailed")
	ResourceState_STATUS_Updating      = ResourceState_STATUS("Updating")
)

// Mapping from string to ResourceState_STATUS
var resourceState_STATUS_Values = map[string]ResourceState_STATUS{
	"createfailed":  ResourceState_STATUS_CreateFailed,
	"creating":      ResourceState_STATUS_Creating,
	"deletefailed":  ResourceState_STATUS_DeleteFailed,
	"deleting":      ResourceState_STATUS_Deleting,
	"disablefailed": ResourceState_STATUS_DisableFailed,
	"disabled":      ResourceState_STATUS_Disabled,
	"disabling":     ResourceState_STATUS_Disabling,
	"enablefailed":  ResourceState_STATUS_EnableFailed,
	"enabling":      ResourceState_STATUS_Enabling,
	"moving":        ResourceState_STATUS_Moving,
	"running":       ResourceState_STATUS_Running,
	"scaling":       ResourceState_STATUS_Scaling,
	"scalingfailed": ResourceState_STATUS_ScalingFailed,
	"updatefailed":  ResourceState_STATUS_UpdateFailed,
	"updating":      ResourceState_STATUS_Updating,
}

// SKU parameters supplied to the create Redis Enterprise cluster operation.
type Sku struct {
	// Capacity: This property is only used with Enterprise and EnterpriseFlash SKUs. Determines the size of the cluster. Valid
	// values are (2, 4, 6, ...) for Enterprise SKUs and (3, 9, 15, ...) for EnterpriseFlash SKUs.
	Capacity *int `json:"capacity,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The level of Redis Enterprise cluster to deploy. Possible values: ('Balanced_B5', 'MemoryOptimized_M10',
	// 'ComputeOptimized_X5', etc.). For more information on SKUs see the latest pricing documentation. Note that additional
	// SKUs may become supported in the future.
	Name *Sku_Name `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &arm.Sku{}

	// Set property "Capacity":
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		result.Capacity = &capacity
	}

	// Set property "Name":
	if sku.Name != nil {
		var temp string
		temp = string(*sku.Name)
		name := arm.Sku_Name(temp)
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := Sku_Name(temp)
		sku.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_Sku populates our Sku from the provided source Sku
func (sku *Sku) AssignProperties_From_Sku(source *storage.Sku) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, sku_Name_Values)
		sku.Name = &nameTemp
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku populates the provided destination Sku from our Sku
func (sku *Sku) AssignProperties_To_Sku(destination *storage.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Name
	if sku.Name != nil {
		name := string(*sku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Sku_STATUS populates our Sku from the provided source Sku_STATUS
func (sku *Sku) Initialize_From_Sku_STATUS(source *Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	if source.Name != nil {
		name := genruntime.ToEnum(string(*source.Name), sku_Name_Values)
		sku.Name = &name
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// SKU parameters supplied to the create Redis Enterprise cluster operation.
type Sku_STATUS struct {
	// Capacity: This property is only used with Enterprise and EnterpriseFlash SKUs. Determines the size of the cluster. Valid
	// values are (2, 4, 6, ...) for Enterprise SKUs and (3, 9, 15, ...) for EnterpriseFlash SKUs.
	Capacity *int `json:"capacity,omitempty"`

	// Name: The level of Redis Enterprise cluster to deploy. Possible values: ('Balanced_B5', 'MemoryOptimized_M10',
	// 'ComputeOptimized_X5', etc.). For more information on SKUs see the latest pricing documentation. Note that additional
	// SKUs may become supported in the future.
	Name *Sku_Name_STATUS `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.Sku_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.Sku_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.Sku_STATUS, got %T", armInput)
	}

	// Set property "Capacity":
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property "Name":
	if typedInput.Name != nil {
		var temp string
		temp = string(*typedInput.Name)
		name := Sku_Name_STATUS(temp)
		sku.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_Sku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_From_Sku_STATUS(source *storage.Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Name
	if source.Name != nil {
		name := *source.Name
		nameTemp := genruntime.ToEnum(name, sku_Name_STATUS_Values)
		sku.Name = &nameTemp
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_To_Sku_STATUS(destination *storage.Sku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Name
	if sku.Name != nil {
		name := string(*sku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ClusterProperties_Encryption_CustomerManagedKeyEncryption struct {
	// KeyEncryptionKeyIdentity: All identity configuration for Customer-managed key settings defining which identity should be
	// used to auth to Key Vault.
	KeyEncryptionKeyIdentity *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity `json:"keyEncryptionKeyIdentity,omitempty"`

	// KeyEncryptionKeyUrl: Key encryption key Url, versioned only. Ex:
	// https://contosovault.vault.azure.net/keys/contosokek/562a4bb76b524a1493a6afe8e536ee78
	KeyEncryptionKeyUrl *string `json:"keyEncryptionKeyUrl,omitempty"`
}

var _ genruntime.ARMTransformer = &ClusterProperties_Encryption_CustomerManagedKeyEncryption{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (encryption *ClusterProperties_Encryption_CustomerManagedKeyEncryption) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if encryption == nil {
		return nil, nil
	}
	result := &arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption{}

	// Set property "KeyEncryptionKeyIdentity":
	if encryption.KeyEncryptionKeyIdentity != nil {
		keyEncryptionKeyIdentity_ARM, err := (*encryption.KeyEncryptionKeyIdentity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keyEncryptionKeyIdentity := *keyEncryptionKeyIdentity_ARM.(*arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity)
		result.KeyEncryptionKeyIdentity = &keyEncryptionKeyIdentity
	}

	// Set property "KeyEncryptionKeyUrl":
	if encryption.KeyEncryptionKeyUrl != nil {
		keyEncryptionKeyUrl := *encryption.KeyEncryptionKeyUrl
		result.KeyEncryptionKeyUrl = &keyEncryptionKeyUrl
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *ClusterProperties_Encryption_CustomerManagedKeyEncryption) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *ClusterProperties_Encryption_CustomerManagedKeyEncryption) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption, got %T", armInput)
	}

	// Set property "KeyEncryptionKeyIdentity":
	if typedInput.KeyEncryptionKeyIdentity != nil {
		var keyEncryptionKeyIdentity1 ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity
		err := keyEncryptionKeyIdentity1.PopulateFromARM(owner, *typedInput.KeyEncryptionKeyIdentity)
		if err != nil {
			return err
		}
		keyEncryptionKeyIdentity := keyEncryptionKeyIdentity1
		encryption.KeyEncryptionKeyIdentity = &keyEncryptionKeyIdentity
	}

	// Set property "KeyEncryptionKeyUrl":
	if typedInput.KeyEncryptionKeyUrl != nil {
		keyEncryptionKeyUrl := *typedInput.KeyEncryptionKeyUrl
		encryption.KeyEncryptionKeyUrl = &keyEncryptionKeyUrl
	}

	// No error
	return nil
}

// AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption populates our ClusterProperties_Encryption_CustomerManagedKeyEncryption from the provided source ClusterProperties_Encryption_CustomerManagedKeyEncryption
func (encryption *ClusterProperties_Encryption_CustomerManagedKeyEncryption) AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption(source *storage.ClusterProperties_Encryption_CustomerManagedKeyEncryption) error {

	// KeyEncryptionKeyIdentity
	if source.KeyEncryptionKeyIdentity != nil {
		var keyEncryptionKeyIdentity ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity
		err := keyEncryptionKeyIdentity.AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity(source.KeyEncryptionKeyIdentity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity() to populate field KeyEncryptionKeyIdentity")
		}
		encryption.KeyEncryptionKeyIdentity = &keyEncryptionKeyIdentity
	} else {
		encryption.KeyEncryptionKeyIdentity = nil
	}

	// KeyEncryptionKeyUrl
	encryption.KeyEncryptionKeyUrl = genruntime.ClonePointerToString(source.KeyEncryptionKeyUrl)

	// No error
	return nil
}

// AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption populates the provided destination ClusterProperties_Encryption_CustomerManagedKeyEncryption from our ClusterProperties_Encryption_CustomerManagedKeyEncryption
func (encryption *ClusterProperties_Encryption_CustomerManagedKeyEncryption) AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption(destination *storage.ClusterProperties_Encryption_CustomerManagedKeyEncryption) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyEncryptionKeyIdentity
	if encryption.KeyEncryptionKeyIdentity != nil {
		var keyEncryptionKeyIdentity storage.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity
		err := encryption.KeyEncryptionKeyIdentity.AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity(&keyEncryptionKeyIdentity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity() to populate field KeyEncryptionKeyIdentity")
		}
		destination.KeyEncryptionKeyIdentity = &keyEncryptionKeyIdentity
	} else {
		destination.KeyEncryptionKeyIdentity = nil
	}

	// KeyEncryptionKeyUrl
	destination.KeyEncryptionKeyUrl = genruntime.ClonePointerToString(encryption.KeyEncryptionKeyUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS populates our ClusterProperties_Encryption_CustomerManagedKeyEncryption from the provided source ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS
func (encryption *ClusterProperties_Encryption_CustomerManagedKeyEncryption) Initialize_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS(source *ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS) error {

	// KeyEncryptionKeyIdentity
	if source.KeyEncryptionKeyIdentity != nil {
		var keyEncryptionKeyIdentity ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity
		err := keyEncryptionKeyIdentity.Initialize_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS(source.KeyEncryptionKeyIdentity)
		if err != nil {
			return eris.Wrap(err, "calling Initialize_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS() to populate field KeyEncryptionKeyIdentity")
		}
		encryption.KeyEncryptionKeyIdentity = &keyEncryptionKeyIdentity
	} else {
		encryption.KeyEncryptionKeyIdentity = nil
	}

	// KeyEncryptionKeyUrl
	encryption.KeyEncryptionKeyUrl = genruntime.ClonePointerToString(source.KeyEncryptionKeyUrl)

	// No error
	return nil
}

type ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS struct {
	// KeyEncryptionKeyIdentity: All identity configuration for Customer-managed key settings defining which identity should be
	// used to auth to Key Vault.
	KeyEncryptionKeyIdentity *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS `json:"keyEncryptionKeyIdentity,omitempty"`

	// KeyEncryptionKeyUrl: Key encryption key Url, versioned only. Ex:
	// https://contosovault.vault.azure.net/keys/contosokek/562a4bb76b524a1493a6afe8e536ee78
	KeyEncryptionKeyUrl *string `json:"keyEncryptionKeyUrl,omitempty"`
}

var _ genruntime.FromARMConverter = &ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (encryption *ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (encryption *ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS, got %T", armInput)
	}

	// Set property "KeyEncryptionKeyIdentity":
	if typedInput.KeyEncryptionKeyIdentity != nil {
		var keyEncryptionKeyIdentity1 ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS
		err := keyEncryptionKeyIdentity1.PopulateFromARM(owner, *typedInput.KeyEncryptionKeyIdentity)
		if err != nil {
			return err
		}
		keyEncryptionKeyIdentity := keyEncryptionKeyIdentity1
		encryption.KeyEncryptionKeyIdentity = &keyEncryptionKeyIdentity
	}

	// Set property "KeyEncryptionKeyUrl":
	if typedInput.KeyEncryptionKeyUrl != nil {
		keyEncryptionKeyUrl := *typedInput.KeyEncryptionKeyUrl
		encryption.KeyEncryptionKeyUrl = &keyEncryptionKeyUrl
	}

	// No error
	return nil
}

// AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS populates our ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS from the provided source ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS
func (encryption *ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS) AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS(source *storage.ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS) error {

	// KeyEncryptionKeyIdentity
	if source.KeyEncryptionKeyIdentity != nil {
		var keyEncryptionKeyIdentity ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS
		err := keyEncryptionKeyIdentity.AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS(source.KeyEncryptionKeyIdentity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS() to populate field KeyEncryptionKeyIdentity")
		}
		encryption.KeyEncryptionKeyIdentity = &keyEncryptionKeyIdentity
	} else {
		encryption.KeyEncryptionKeyIdentity = nil
	}

	// KeyEncryptionKeyUrl
	encryption.KeyEncryptionKeyUrl = genruntime.ClonePointerToString(source.KeyEncryptionKeyUrl)

	// No error
	return nil
}

// AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS populates the provided destination ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS from our ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS
func (encryption *ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS) AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS(destination *storage.ClusterProperties_Encryption_CustomerManagedKeyEncryption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyEncryptionKeyIdentity
	if encryption.KeyEncryptionKeyIdentity != nil {
		var keyEncryptionKeyIdentity storage.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS
		err := encryption.KeyEncryptionKeyIdentity.AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS(&keyEncryptionKeyIdentity)
		if err != nil {
			return eris.Wrap(err, "calling AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS() to populate field KeyEncryptionKeyIdentity")
		}
		destination.KeyEncryptionKeyIdentity = &keyEncryptionKeyIdentity
	} else {
		destination.KeyEncryptionKeyIdentity = nil
	}

	// KeyEncryptionKeyUrl
	destination.KeyEncryptionKeyUrl = genruntime.ClonePointerToString(encryption.KeyEncryptionKeyUrl)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
// +kubebuilder:validation:Enum={"None","SystemAssigned","SystemAssigned, UserAssigned","UserAssigned"}
type ManagedServiceIdentityType string

const (
	ManagedServiceIdentityType_None                       = ManagedServiceIdentityType("None")
	ManagedServiceIdentityType_SystemAssigned             = ManagedServiceIdentityType("SystemAssigned")
	ManagedServiceIdentityType_SystemAssignedUserAssigned = ManagedServiceIdentityType("SystemAssigned, UserAssigned")
	ManagedServiceIdentityType_UserAssigned               = ManagedServiceIdentityType("UserAssigned")
)

// Mapping from string to ManagedServiceIdentityType
var managedServiceIdentityType_Values = map[string]ManagedServiceIdentityType{
	"none":                         ManagedServiceIdentityType_None,
	"systemassigned":               ManagedServiceIdentityType_SystemAssigned,
	"systemassigned, userassigned": ManagedServiceIdentityType_SystemAssignedUserAssigned,
	"userassigned":                 ManagedServiceIdentityType_UserAssigned,
}

// Type of managed service identity (where both SystemAssigned and UserAssigned types are allowed).
type ManagedServiceIdentityType_STATUS string

const (
	ManagedServiceIdentityType_STATUS_None                       = ManagedServiceIdentityType_STATUS("None")
	ManagedServiceIdentityType_STATUS_SystemAssigned             = ManagedServiceIdentityType_STATUS("SystemAssigned")
	ManagedServiceIdentityType_STATUS_SystemAssignedUserAssigned = ManagedServiceIdentityType_STATUS("SystemAssigned, UserAssigned")
	ManagedServiceIdentityType_STATUS_UserAssigned               = ManagedServiceIdentityType_STATUS("UserAssigned")
)

// Mapping from string to ManagedServiceIdentityType_STATUS
var managedServiceIdentityType_STATUS_Values = map[string]ManagedServiceIdentityType_STATUS{
	"none":                         ManagedServiceIdentityType_STATUS_None,
	"systemassigned":               ManagedServiceIdentityType_STATUS_SystemAssigned,
	"systemassigned, userassigned": ManagedServiceIdentityType_STATUS_SystemAssignedUserAssigned,
	"userassigned":                 ManagedServiceIdentityType_STATUS_UserAssigned,
}

// +kubebuilder:validation:Enum={"Balanced_B0","Balanced_B1","Balanced_B10","Balanced_B100","Balanced_B1000","Balanced_B150","Balanced_B20","Balanced_B250","Balanced_B3","Balanced_B350","Balanced_B5","Balanced_B50","Balanced_B500","Balanced_B700","ComputeOptimized_X10","ComputeOptimized_X100","ComputeOptimized_X150","ComputeOptimized_X20","ComputeOptimized_X250","ComputeOptimized_X3","ComputeOptimized_X350","ComputeOptimized_X5","ComputeOptimized_X50","ComputeOptimized_X500","ComputeOptimized_X700","EnterpriseFlash_F1500","EnterpriseFlash_F300","EnterpriseFlash_F700","Enterprise_E1","Enterprise_E10","Enterprise_E100","Enterprise_E20","Enterprise_E200","Enterprise_E400","Enterprise_E5","Enterprise_E50","FlashOptimized_A1000","FlashOptimized_A1500","FlashOptimized_A2000","FlashOptimized_A250","FlashOptimized_A4500","FlashOptimized_A500","FlashOptimized_A700","MemoryOptimized_M10","MemoryOptimized_M100","MemoryOptimized_M1000","MemoryOptimized_M150","MemoryOptimized_M1500","MemoryOptimized_M20","MemoryOptimized_M2000","MemoryOptimized_M250","MemoryOptimized_M350","MemoryOptimized_M50","MemoryOptimized_M500","MemoryOptimized_M700"}
type Sku_Name string

const (
	Sku_Name_Balanced_B0           = Sku_Name("Balanced_B0")
	Sku_Name_Balanced_B1           = Sku_Name("Balanced_B1")
	Sku_Name_Balanced_B10          = Sku_Name("Balanced_B10")
	Sku_Name_Balanced_B100         = Sku_Name("Balanced_B100")
	Sku_Name_Balanced_B1000        = Sku_Name("Balanced_B1000")
	Sku_Name_Balanced_B150         = Sku_Name("Balanced_B150")
	Sku_Name_Balanced_B20          = Sku_Name("Balanced_B20")
	Sku_Name_Balanced_B250         = Sku_Name("Balanced_B250")
	Sku_Name_Balanced_B3           = Sku_Name("Balanced_B3")
	Sku_Name_Balanced_B350         = Sku_Name("Balanced_B350")
	Sku_Name_Balanced_B5           = Sku_Name("Balanced_B5")
	Sku_Name_Balanced_B50          = Sku_Name("Balanced_B50")
	Sku_Name_Balanced_B500         = Sku_Name("Balanced_B500")
	Sku_Name_Balanced_B700         = Sku_Name("Balanced_B700")
	Sku_Name_ComputeOptimized_X10  = Sku_Name("ComputeOptimized_X10")
	Sku_Name_ComputeOptimized_X100 = Sku_Name("ComputeOptimized_X100")
	Sku_Name_ComputeOptimized_X150 = Sku_Name("ComputeOptimized_X150")
	Sku_Name_ComputeOptimized_X20  = Sku_Name("ComputeOptimized_X20")
	Sku_Name_ComputeOptimized_X250 = Sku_Name("ComputeOptimized_X250")
	Sku_Name_ComputeOptimized_X3   = Sku_Name("ComputeOptimized_X3")
	Sku_Name_ComputeOptimized_X350 = Sku_Name("ComputeOptimized_X350")
	Sku_Name_ComputeOptimized_X5   = Sku_Name("ComputeOptimized_X5")
	Sku_Name_ComputeOptimized_X50  = Sku_Name("ComputeOptimized_X50")
	Sku_Name_ComputeOptimized_X500 = Sku_Name("ComputeOptimized_X500")
	Sku_Name_ComputeOptimized_X700 = Sku_Name("ComputeOptimized_X700")
	Sku_Name_EnterpriseFlash_F1500 = Sku_Name("EnterpriseFlash_F1500")
	Sku_Name_EnterpriseFlash_F300  = Sku_Name("EnterpriseFlash_F300")
	Sku_Name_EnterpriseFlash_F700  = Sku_Name("EnterpriseFlash_F700")
	Sku_Name_Enterprise_E1         = Sku_Name("Enterprise_E1")
	Sku_Name_Enterprise_E10        = Sku_Name("Enterprise_E10")
	Sku_Name_Enterprise_E100       = Sku_Name("Enterprise_E100")
	Sku_Name_Enterprise_E20        = Sku_Name("Enterprise_E20")
	Sku_Name_Enterprise_E200       = Sku_Name("Enterprise_E200")
	Sku_Name_Enterprise_E400       = Sku_Name("Enterprise_E400")
	Sku_Name_Enterprise_E5         = Sku_Name("Enterprise_E5")
	Sku_Name_Enterprise_E50        = Sku_Name("Enterprise_E50")
	Sku_Name_FlashOptimized_A1000  = Sku_Name("FlashOptimized_A1000")
	Sku_Name_FlashOptimized_A1500  = Sku_Name("FlashOptimized_A1500")
	Sku_Name_FlashOptimized_A2000  = Sku_Name("FlashOptimized_A2000")
	Sku_Name_FlashOptimized_A250   = Sku_Name("FlashOptimized_A250")
	Sku_Name_FlashOptimized_A4500  = Sku_Name("FlashOptimized_A4500")
	Sku_Name_FlashOptimized_A500   = Sku_Name("FlashOptimized_A500")
	Sku_Name_FlashOptimized_A700   = Sku_Name("FlashOptimized_A700")
	Sku_Name_MemoryOptimized_M10   = Sku_Name("MemoryOptimized_M10")
	Sku_Name_MemoryOptimized_M100  = Sku_Name("MemoryOptimized_M100")
	Sku_Name_MemoryOptimized_M1000 = Sku_Name("MemoryOptimized_M1000")
	Sku_Name_MemoryOptimized_M150  = Sku_Name("MemoryOptimized_M150")
	Sku_Name_MemoryOptimized_M1500 = Sku_Name("MemoryOptimized_M1500")
	Sku_Name_MemoryOptimized_M20   = Sku_Name("MemoryOptimized_M20")
	Sku_Name_MemoryOptimized_M2000 = Sku_Name("MemoryOptimized_M2000")
	Sku_Name_MemoryOptimized_M250  = Sku_Name("MemoryOptimized_M250")
	Sku_Name_MemoryOptimized_M350  = Sku_Name("MemoryOptimized_M350")
	Sku_Name_MemoryOptimized_M50   = Sku_Name("MemoryOptimized_M50")
	Sku_Name_MemoryOptimized_M500  = Sku_Name("MemoryOptimized_M500")
	Sku_Name_MemoryOptimized_M700  = Sku_Name("MemoryOptimized_M700")
)

// Mapping from string to Sku_Name
var sku_Name_Values = map[string]Sku_Name{
	"balanced_b0":           Sku_Name_Balanced_B0,
	"balanced_b1":           Sku_Name_Balanced_B1,
	"balanced_b10":          Sku_Name_Balanced_B10,
	"balanced_b100":         Sku_Name_Balanced_B100,
	"balanced_b1000":        Sku_Name_Balanced_B1000,
	"balanced_b150":         Sku_Name_Balanced_B150,
	"balanced_b20":          Sku_Name_Balanced_B20,
	"balanced_b250":         Sku_Name_Balanced_B250,
	"balanced_b3":           Sku_Name_Balanced_B3,
	"balanced_b350":         Sku_Name_Balanced_B350,
	"balanced_b5":           Sku_Name_Balanced_B5,
	"balanced_b50":          Sku_Name_Balanced_B50,
	"balanced_b500":         Sku_Name_Balanced_B500,
	"balanced_b700":         Sku_Name_Balanced_B700,
	"computeoptimized_x10":  Sku_Name_ComputeOptimized_X10,
	"computeoptimized_x100": Sku_Name_ComputeOptimized_X100,
	"computeoptimized_x150": Sku_Name_ComputeOptimized_X150,
	"computeoptimized_x20":  Sku_Name_ComputeOptimized_X20,
	"computeoptimized_x250": Sku_Name_ComputeOptimized_X250,
	"computeoptimized_x3":   Sku_Name_ComputeOptimized_X3,
	"computeoptimized_x350": Sku_Name_ComputeOptimized_X350,
	"computeoptimized_x5":   Sku_Name_ComputeOptimized_X5,
	"computeoptimized_x50":  Sku_Name_ComputeOptimized_X50,
	"computeoptimized_x500": Sku_Name_ComputeOptimized_X500,
	"computeoptimized_x700": Sku_Name_ComputeOptimized_X700,
	"enterpriseflash_f1500": Sku_Name_EnterpriseFlash_F1500,
	"enterpriseflash_f300":  Sku_Name_EnterpriseFlash_F300,
	"enterpriseflash_f700":  Sku_Name_EnterpriseFlash_F700,
	"enterprise_e1":         Sku_Name_Enterprise_E1,
	"enterprise_e10":        Sku_Name_Enterprise_E10,
	"enterprise_e100":       Sku_Name_Enterprise_E100,
	"enterprise_e20":        Sku_Name_Enterprise_E20,
	"enterprise_e200":       Sku_Name_Enterprise_E200,
	"enterprise_e400":       Sku_Name_Enterprise_E400,
	"enterprise_e5":         Sku_Name_Enterprise_E5,
	"enterprise_e50":        Sku_Name_Enterprise_E50,
	"flashoptimized_a1000":  Sku_Name_FlashOptimized_A1000,
	"flashoptimized_a1500":  Sku_Name_FlashOptimized_A1500,
	"flashoptimized_a2000":  Sku_Name_FlashOptimized_A2000,
	"flashoptimized_a250":   Sku_Name_FlashOptimized_A250,
	"flashoptimized_a4500":  Sku_Name_FlashOptimized_A4500,
	"flashoptimized_a500":   Sku_Name_FlashOptimized_A500,
	"flashoptimized_a700":   Sku_Name_FlashOptimized_A700,
	"memoryoptimized_m10":   Sku_Name_MemoryOptimized_M10,
	"memoryoptimized_m100":  Sku_Name_MemoryOptimized_M100,
	"memoryoptimized_m1000": Sku_Name_MemoryOptimized_M1000,
	"memoryoptimized_m150":  Sku_Name_MemoryOptimized_M150,
	"memoryoptimized_m1500": Sku_Name_MemoryOptimized_M1500,
	"memoryoptimized_m20":   Sku_Name_MemoryOptimized_M20,
	"memoryoptimized_m2000": Sku_Name_MemoryOptimized_M2000,
	"memoryoptimized_m250":  Sku_Name_MemoryOptimized_M250,
	"memoryoptimized_m350":  Sku_Name_MemoryOptimized_M350,
	"memoryoptimized_m50":   Sku_Name_MemoryOptimized_M50,
	"memoryoptimized_m500":  Sku_Name_MemoryOptimized_M500,
	"memoryoptimized_m700":  Sku_Name_MemoryOptimized_M700,
}

type Sku_Name_STATUS string

const (
	Sku_Name_STATUS_Balanced_B0           = Sku_Name_STATUS("Balanced_B0")
	Sku_Name_STATUS_Balanced_B1           = Sku_Name_STATUS("Balanced_B1")
	Sku_Name_STATUS_Balanced_B10          = Sku_Name_STATUS("Balanced_B10")
	Sku_Name_STATUS_Balanced_B100         = Sku_Name_STATUS("Balanced_B100")
	Sku_Name_STATUS_Balanced_B1000        = Sku_Name_STATUS("Balanced_B1000")
	Sku_Name_STATUS_Balanced_B150         = Sku_Name_STATUS("Balanced_B150")
	Sku_Name_STATUS_Balanced_B20          = Sku_Name_STATUS("Balanced_B20")
	Sku_Name_STATUS_Balanced_B250         = Sku_Name_STATUS("Balanced_B250")
	Sku_Name_STATUS_Balanced_B3           = Sku_Name_STATUS("Balanced_B3")
	Sku_Name_STATUS_Balanced_B350         = Sku_Name_STATUS("Balanced_B350")
	Sku_Name_STATUS_Balanced_B5           = Sku_Name_STATUS("Balanced_B5")
	Sku_Name_STATUS_Balanced_B50          = Sku_Name_STATUS("Balanced_B50")
	Sku_Name_STATUS_Balanced_B500         = Sku_Name_STATUS("Balanced_B500")
	Sku_Name_STATUS_Balanced_B700         = Sku_Name_STATUS("Balanced_B700")
	Sku_Name_STATUS_ComputeOptimized_X10  = Sku_Name_STATUS("ComputeOptimized_X10")
	Sku_Name_STATUS_ComputeOptimized_X100 = Sku_Name_STATUS("ComputeOptimized_X100")
	Sku_Name_STATUS_ComputeOptimized_X150 = Sku_Name_STATUS("ComputeOptimized_X150")
	Sku_Name_STATUS_ComputeOptimized_X20  = Sku_Name_STATUS("ComputeOptimized_X20")
	Sku_Name_STATUS_ComputeOptimized_X250 = Sku_Name_STATUS("ComputeOptimized_X250")
	Sku_Name_STATUS_ComputeOptimized_X3   = Sku_Name_STATUS("ComputeOptimized_X3")
	Sku_Name_STATUS_ComputeOptimized_X350 = Sku_Name_STATUS("ComputeOptimized_X350")
	Sku_Name_STATUS_ComputeOptimized_X5   = Sku_Name_STATUS("ComputeOptimized_X5")
	Sku_Name_STATUS_ComputeOptimized_X50  = Sku_Name_STATUS("ComputeOptimized_X50")
	Sku_Name_STATUS_ComputeOptimized_X500 = Sku_Name_STATUS("ComputeOptimized_X500")
	Sku_Name_STATUS_ComputeOptimized_X700 = Sku_Name_STATUS("ComputeOptimized_X700")
	Sku_Name_STATUS_EnterpriseFlash_F1500 = Sku_Name_STATUS("EnterpriseFlash_F1500")
	Sku_Name_STATUS_EnterpriseFlash_F300  = Sku_Name_STATUS("EnterpriseFlash_F300")
	Sku_Name_STATUS_EnterpriseFlash_F700  = Sku_Name_STATUS("EnterpriseFlash_F700")
	Sku_Name_STATUS_Enterprise_E1         = Sku_Name_STATUS("Enterprise_E1")
	Sku_Name_STATUS_Enterprise_E10        = Sku_Name_STATUS("Enterprise_E10")
	Sku_Name_STATUS_Enterprise_E100       = Sku_Name_STATUS("Enterprise_E100")
	Sku_Name_STATUS_Enterprise_E20        = Sku_Name_STATUS("Enterprise_E20")
	Sku_Name_STATUS_Enterprise_E200       = Sku_Name_STATUS("Enterprise_E200")
	Sku_Name_STATUS_Enterprise_E400       = Sku_Name_STATUS("Enterprise_E400")
	Sku_Name_STATUS_Enterprise_E5         = Sku_Name_STATUS("Enterprise_E5")
	Sku_Name_STATUS_Enterprise_E50        = Sku_Name_STATUS("Enterprise_E50")
	Sku_Name_STATUS_FlashOptimized_A1000  = Sku_Name_STATUS("FlashOptimized_A1000")
	Sku_Name_STATUS_FlashOptimized_A1500  = Sku_Name_STATUS("FlashOptimized_A1500")
	Sku_Name_STATUS_FlashOptimized_A2000  = Sku_Name_STATUS("FlashOptimized_A2000")
	Sku_Name_STATUS_FlashOptimized_A250   = Sku_Name_STATUS("FlashOptimized_A250")
	Sku_Name_STATUS_FlashOptimized_A4500  = Sku_Name_STATUS("FlashOptimized_A4500")
	Sku_Name_STATUS_FlashOptimized_A500   = Sku_Name_STATUS("FlashOptimized_A500")
	Sku_Name_STATUS_FlashOptimized_A700   = Sku_Name_STATUS("FlashOptimized_A700")
	Sku_Name_STATUS_MemoryOptimized_M10   = Sku_Name_STATUS("MemoryOptimized_M10")
	Sku_Name_STATUS_MemoryOptimized_M100  = Sku_Name_STATUS("MemoryOptimized_M100")
	Sku_Name_STATUS_MemoryOptimized_M1000 = Sku_Name_STATUS("MemoryOptimized_M1000")
	Sku_Name_STATUS_MemoryOptimized_M150  = Sku_Name_STATUS("MemoryOptimized_M150")
	Sku_Name_STATUS_MemoryOptimized_M1500 = Sku_Name_STATUS("MemoryOptimized_M1500")
	Sku_Name_STATUS_MemoryOptimized_M20   = Sku_Name_STATUS("MemoryOptimized_M20")
	Sku_Name_STATUS_MemoryOptimized_M2000 = Sku_Name_STATUS("MemoryOptimized_M2000")
	Sku_Name_STATUS_MemoryOptimized_M250  = Sku_Name_STATUS("MemoryOptimized_M250")
	Sku_Name_STATUS_MemoryOptimized_M350  = Sku_Name_STATUS("MemoryOptimized_M350")
	Sku_Name_STATUS_MemoryOptimized_M50   = Sku_Name_STATUS("MemoryOptimized_M50")
	Sku_Name_STATUS_MemoryOptimized_M500  = Sku_Name_STATUS("MemoryOptimized_M500")
	Sku_Name_STATUS_MemoryOptimized_M700  = Sku_Name_STATUS("MemoryOptimized_M700")
)

// Mapping from string to Sku_Name_STATUS
var sku_Name_STATUS_Values = map[string]Sku_Name_STATUS{
	"balanced_b0":           Sku_Name_STATUS_Balanced_B0,
	"balanced_b1":           Sku_Name_STATUS_Balanced_B1,
	"balanced_b10":          Sku_Name_STATUS_Balanced_B10,
	"balanced_b100":         Sku_Name_STATUS_Balanced_B100,
	"balanced_b1000":        Sku_Name_STATUS_Balanced_B1000,
	"balanced_b150":         Sku_Name_STATUS_Balanced_B150,
	"balanced_b20":          Sku_Name_STATUS_Balanced_B20,
	"balanced_b250":         Sku_Name_STATUS_Balanced_B250,
	"balanced_b3":           Sku_Name_STATUS_Balanced_B3,
	"balanced_b350":         Sku_Name_STATUS_Balanced_B350,
	"balanced_b5":           Sku_Name_STATUS_Balanced_B5,
	"balanced_b50":          Sku_Name_STATUS_Balanced_B50,
	"balanced_b500":         Sku_Name_STATUS_Balanced_B500,
	"balanced_b700":         Sku_Name_STATUS_Balanced_B700,
	"computeoptimized_x10":  Sku_Name_STATUS_ComputeOptimized_X10,
	"computeoptimized_x100": Sku_Name_STATUS_ComputeOptimized_X100,
	"computeoptimized_x150": Sku_Name_STATUS_ComputeOptimized_X150,
	"computeoptimized_x20":  Sku_Name_STATUS_ComputeOptimized_X20,
	"computeoptimized_x250": Sku_Name_STATUS_ComputeOptimized_X250,
	"computeoptimized_x3":   Sku_Name_STATUS_ComputeOptimized_X3,
	"computeoptimized_x350": Sku_Name_STATUS_ComputeOptimized_X350,
	"computeoptimized_x5":   Sku_Name_STATUS_ComputeOptimized_X5,
	"computeoptimized_x50":  Sku_Name_STATUS_ComputeOptimized_X50,
	"computeoptimized_x500": Sku_Name_STATUS_ComputeOptimized_X500,
	"computeoptimized_x700": Sku_Name_STATUS_ComputeOptimized_X700,
	"enterpriseflash_f1500": Sku_Name_STATUS_EnterpriseFlash_F1500,
	"enterpriseflash_f300":  Sku_Name_STATUS_EnterpriseFlash_F300,
	"enterpriseflash_f700":  Sku_Name_STATUS_EnterpriseFlash_F700,
	"enterprise_e1":         Sku_Name_STATUS_Enterprise_E1,
	"enterprise_e10":        Sku_Name_STATUS_Enterprise_E10,
	"enterprise_e100":       Sku_Name_STATUS_Enterprise_E100,
	"enterprise_e20":        Sku_Name_STATUS_Enterprise_E20,
	"enterprise_e200":       Sku_Name_STATUS_Enterprise_E200,
	"enterprise_e400":       Sku_Name_STATUS_Enterprise_E400,
	"enterprise_e5":         Sku_Name_STATUS_Enterprise_E5,
	"enterprise_e50":        Sku_Name_STATUS_Enterprise_E50,
	"flashoptimized_a1000":  Sku_Name_STATUS_FlashOptimized_A1000,
	"flashoptimized_a1500":  Sku_Name_STATUS_FlashOptimized_A1500,
	"flashoptimized_a2000":  Sku_Name_STATUS_FlashOptimized_A2000,
	"flashoptimized_a250":   Sku_Name_STATUS_FlashOptimized_A250,
	"flashoptimized_a4500":  Sku_Name_STATUS_FlashOptimized_A4500,
	"flashoptimized_a500":   Sku_Name_STATUS_FlashOptimized_A500,
	"flashoptimized_a700":   Sku_Name_STATUS_FlashOptimized_A700,
	"memoryoptimized_m10":   Sku_Name_STATUS_MemoryOptimized_M10,
	"memoryoptimized_m100":  Sku_Name_STATUS_MemoryOptimized_M100,
	"memoryoptimized_m1000": Sku_Name_STATUS_MemoryOptimized_M1000,
	"memoryoptimized_m150":  Sku_Name_STATUS_MemoryOptimized_M150,
	"memoryoptimized_m1500": Sku_Name_STATUS_MemoryOptimized_M1500,
	"memoryoptimized_m20":   Sku_Name_STATUS_MemoryOptimized_M20,
	"memoryoptimized_m2000": Sku_Name_STATUS_MemoryOptimized_M2000,
	"memoryoptimized_m250":  Sku_Name_STATUS_MemoryOptimized_M250,
	"memoryoptimized_m350":  Sku_Name_STATUS_MemoryOptimized_M350,
	"memoryoptimized_m50":   Sku_Name_STATUS_MemoryOptimized_M50,
	"memoryoptimized_m500":  Sku_Name_STATUS_MemoryOptimized_M500,
	"memoryoptimized_m700":  Sku_Name_STATUS_MemoryOptimized_M700,
}

// User assigned identity properties
type UserAssignedIdentity_STATUS struct {
	// ClientId: The client ID of the assigned identity.
	ClientId *string `json:"clientId,omitempty"`

	// PrincipalId: The principal ID of the assigned identity.
	PrincipalId *string `json:"principalId,omitempty"`
}

var _ genruntime.FromARMConverter = &UserAssignedIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *UserAssignedIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.UserAssignedIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *UserAssignedIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.UserAssignedIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.UserAssignedIdentity_STATUS, got %T", armInput)
	}

	// Set property "ClientId":
	if typedInput.ClientId != nil {
		clientId := *typedInput.ClientId
		identity.ClientId = &clientId
	}

	// Set property "PrincipalId":
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// No error
	return nil
}

// AssignProperties_From_UserAssignedIdentity_STATUS populates our UserAssignedIdentity_STATUS from the provided source UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_From_UserAssignedIdentity_STATUS(source *storage.UserAssignedIdentity_STATUS) error {

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentity_STATUS populates the provided destination UserAssignedIdentity_STATUS from our UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_To_UserAssignedIdentity_STATUS(destination *storage.UserAssignedIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Information about the user assigned identity for the resource
type UserAssignedIdentityDetails struct {
	Reference genruntime.ResourceReference `armReference:"Reference" json:"reference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentityDetails populates our UserAssignedIdentityDetails from the provided source UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_From_UserAssignedIdentityDetails(source *storage.UserAssignedIdentityDetails) error {

	// Reference
	details.Reference = source.Reference.Copy()

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentityDetails populates the provided destination UserAssignedIdentityDetails from our UserAssignedIdentityDetails
func (details *UserAssignedIdentityDetails) AssignProperties_To_UserAssignedIdentityDetails(destination *storage.UserAssignedIdentityDetails) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	destination.Reference = details.Reference.Copy()

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity struct {
	// IdentityType: Only userAssignedIdentity is supported in this API version; other types may be supported in the future
	IdentityType *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType `json:"identityType,omitempty"`

	// UserAssignedIdentityResourceReference: User assigned identity to use for accessing key encryption key Url. Ex:
	// /subscriptions/<sub uuid>/resourceGroups/<resource
	// group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId.
	UserAssignedIdentityResourceReference *genruntime.ResourceReference `armReference:"UserAssignedIdentityResourceId" json:"userAssignedIdentityResourceReference,omitempty"`
}

var _ genruntime.ARMTransformer = &ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity{}

	// Set property "IdentityType":
	if identity.IdentityType != nil {
		var temp string
		temp = string(*identity.IdentityType)
		identityType := arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType(temp)
		result.IdentityType = &identityType
	}

	// Set property "UserAssignedIdentityResourceId":
	if identity.UserAssignedIdentityResourceReference != nil {
		userAssignedIdentityResourceReferenceARMID, err := resolved.ResolvedReferences.Lookup(*identity.UserAssignedIdentityResourceReference)
		if err != nil {
			return nil, err
		}
		userAssignedIdentityResourceReference := userAssignedIdentityResourceReferenceARMID
		result.UserAssignedIdentityResourceId = &userAssignedIdentityResourceReference
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity, got %T", armInput)
	}

	// Set property "IdentityType":
	if typedInput.IdentityType != nil {
		var temp string
		temp = string(*typedInput.IdentityType)
		identityType := ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType(temp)
		identity.IdentityType = &identityType
	}

	// no assignment for property "UserAssignedIdentityResourceReference"

	// No error
	return nil
}

// AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity populates our ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity from the provided source ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity
func (identity *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity) AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity(source *storage.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity) error {

	// IdentityType
	if source.IdentityType != nil {
		identityType := *source.IdentityType
		identityTypeTemp := genruntime.ToEnum(identityType, clusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_Values)
		identity.IdentityType = &identityTypeTemp
	} else {
		identity.IdentityType = nil
	}

	// UserAssignedIdentityResourceReference
	if source.UserAssignedIdentityResourceReference != nil {
		userAssignedIdentityResourceReference := source.UserAssignedIdentityResourceReference.Copy()
		identity.UserAssignedIdentityResourceReference = &userAssignedIdentityResourceReference
	} else {
		identity.UserAssignedIdentityResourceReference = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity populates the provided destination ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity from our ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity
func (identity *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity) AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity(destination *storage.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdentityType
	if identity.IdentityType != nil {
		identityType := string(*identity.IdentityType)
		destination.IdentityType = &identityType
	} else {
		destination.IdentityType = nil
	}

	// UserAssignedIdentityResourceReference
	if identity.UserAssignedIdentityResourceReference != nil {
		userAssignedIdentityResourceReference := identity.UserAssignedIdentityResourceReference.Copy()
		destination.UserAssignedIdentityResourceReference = &userAssignedIdentityResourceReference
	} else {
		destination.UserAssignedIdentityResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS populates our ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity from the provided source ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS
func (identity *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity) Initialize_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS(source *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS) error {

	// IdentityType
	if source.IdentityType != nil {
		identityType := genruntime.ToEnum(string(*source.IdentityType), clusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_Values)
		identity.IdentityType = &identityType
	} else {
		identity.IdentityType = nil
	}

	// UserAssignedIdentityResourceReference
	if source.UserAssignedIdentityResourceId != nil {
		userAssignedIdentityResourceReference := genruntime.CreateResourceReferenceFromARMID(*source.UserAssignedIdentityResourceId)
		identity.UserAssignedIdentityResourceReference = &userAssignedIdentityResourceReference
	} else {
		identity.UserAssignedIdentityResourceReference = nil
	}

	// No error
	return nil
}

type ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS struct {
	// IdentityType: Only userAssignedIdentity is supported in this API version; other types may be supported in the future
	IdentityType *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_STATUS `json:"identityType,omitempty"`

	// UserAssignedIdentityResourceId: User assigned identity to use for accessing key encryption key Url. Ex:
	// /subscriptions/<sub uuid>/resourceGroups/<resource
	// group>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/myId.
	UserAssignedIdentityResourceId *string `json:"userAssignedIdentityResourceId,omitempty"`
}

var _ genruntime.FromARMConverter = &ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected arm.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS, got %T", armInput)
	}

	// Set property "IdentityType":
	if typedInput.IdentityType != nil {
		var temp string
		temp = string(*typedInput.IdentityType)
		identityType := ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_STATUS(temp)
		identity.IdentityType = &identityType
	}

	// Set property "UserAssignedIdentityResourceId":
	if typedInput.UserAssignedIdentityResourceId != nil {
		userAssignedIdentityResourceId := *typedInput.UserAssignedIdentityResourceId
		identity.UserAssignedIdentityResourceId = &userAssignedIdentityResourceId
	}

	// No error
	return nil
}

// AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS populates our ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS from the provided source ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS
func (identity *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS) AssignProperties_From_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS(source *storage.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS) error {

	// IdentityType
	if source.IdentityType != nil {
		identityType := *source.IdentityType
		identityTypeTemp := genruntime.ToEnum(identityType, clusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_STATUS_Values)
		identity.IdentityType = &identityTypeTemp
	} else {
		identity.IdentityType = nil
	}

	// UserAssignedIdentityResourceId
	identity.UserAssignedIdentityResourceId = genruntime.ClonePointerToString(source.UserAssignedIdentityResourceId)

	// No error
	return nil
}

// AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS populates the provided destination ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS from our ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS
func (identity *ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS) AssignProperties_To_ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS(destination *storage.ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IdentityType
	if identity.IdentityType != nil {
		identityType := string(*identity.IdentityType)
		destination.IdentityType = &identityType
	} else {
		destination.IdentityType = nil
	}

	// UserAssignedIdentityResourceId
	destination.UserAssignedIdentityResourceId = genruntime.ClonePointerToString(identity.UserAssignedIdentityResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"systemAssignedIdentity","userAssignedIdentity"}
type ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType string

const (
	ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_SystemAssignedIdentity = ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType("systemAssignedIdentity")
	ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_UserAssignedIdentity   = ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType("userAssignedIdentity")
)

// Mapping from string to ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType
var clusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_Values = map[string]ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType{
	"systemassignedidentity": ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_SystemAssignedIdentity,
	"userassignedidentity":   ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_UserAssignedIdentity,
}

type ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_STATUS string

const (
	ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_STATUS_SystemAssignedIdentity = ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_STATUS("systemAssignedIdentity")
	ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_STATUS_UserAssignedIdentity   = ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_STATUS("userAssignedIdentity")
)

// Mapping from string to ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_STATUS
var clusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_STATUS_Values = map[string]ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_STATUS{
	"systemassignedidentity": ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_STATUS_SystemAssignedIdentity,
	"userassignedidentity":   ClusterProperties_Encryption_CustomerManagedKeyEncryption_KeyEncryptionKeyIdentity_IdentityType_STATUS_UserAssignedIdentity,
}

func init() {
	SchemeBuilder.Register(&RedisEnterprise{}, &RedisEnterpriseList{})
}
