// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_SqlDatabaseContainer_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlDatabaseContainer via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlDatabaseContainer, SqlDatabaseContainerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlDatabaseContainer runs a test to see if a specific instance of SqlDatabaseContainer round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlDatabaseContainer(subject SqlDatabaseContainer) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlDatabaseContainer
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlDatabaseContainer instances for property testing - lazily instantiated by
//SqlDatabaseContainerGenerator()
var sqlDatabaseContainerGenerator gopter.Gen

// SqlDatabaseContainerGenerator returns a generator of SqlDatabaseContainer instances for property testing.
func SqlDatabaseContainerGenerator() gopter.Gen {
	if sqlDatabaseContainerGenerator != nil {
		return sqlDatabaseContainerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSqlDatabaseContainer(generators)
	sqlDatabaseContainerGenerator = gen.Struct(reflect.TypeOf(SqlDatabaseContainer{}), generators)

	return sqlDatabaseContainerGenerator
}

// AddRelatedPropertyGeneratorsForSqlDatabaseContainer is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlDatabaseContainer(gens map[string]gopter.Gen) {
	gens["Spec"] = DatabaseAccountsSqlDatabasesContainers_SPECGenerator()
	gens["Status"] = SqlContainerCreateUpdateParameters_StatusGenerator()
}

func Test_DatabaseAccountsSqlDatabasesContainers_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountsSqlDatabasesContainers_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountsSqlDatabasesContainers_SPEC, DatabaseAccountsSqlDatabasesContainers_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountsSqlDatabasesContainers_SPEC runs a test to see if a specific instance of DatabaseAccountsSqlDatabasesContainers_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountsSqlDatabasesContainers_SPEC(subject DatabaseAccountsSqlDatabasesContainers_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountsSqlDatabasesContainers_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountsSqlDatabasesContainers_SPEC instances for property testing - lazily instantiated by
//DatabaseAccountsSqlDatabasesContainers_SPECGenerator()
var databaseAccountsSqlDatabasesContainers_specGenerator gopter.Gen

// DatabaseAccountsSqlDatabasesContainers_SPECGenerator returns a generator of DatabaseAccountsSqlDatabasesContainers_SPEC instances for property testing.
// We first initialize databaseAccountsSqlDatabasesContainers_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountsSqlDatabasesContainers_SPECGenerator() gopter.Gen {
	if databaseAccountsSqlDatabasesContainers_specGenerator != nil {
		return databaseAccountsSqlDatabasesContainers_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPEC(generators)
	databaseAccountsSqlDatabasesContainers_specGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountsSqlDatabasesContainers_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPEC(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPEC(generators)
	databaseAccountsSqlDatabasesContainers_specGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountsSqlDatabasesContainers_SPEC{}), generators)

	return databaseAccountsSqlDatabasesContainers_specGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPEC(gens map[string]gopter.Gen) {
	gens["Options"] = gen.PtrOf(CreateUpdateOptions_SpecGenerator())
	gens["Resource"] = gen.PtrOf(SqlContainerResource_SpecGenerator())
}

func Test_SqlContainerCreateUpdateParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlContainerCreateUpdateParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlContainerCreateUpdateParameters_Status, SqlContainerCreateUpdateParameters_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlContainerCreateUpdateParameters_Status runs a test to see if a specific instance of SqlContainerCreateUpdateParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlContainerCreateUpdateParameters_Status(subject SqlContainerCreateUpdateParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlContainerCreateUpdateParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlContainerCreateUpdateParameters_Status instances for property testing - lazily instantiated by
//SqlContainerCreateUpdateParameters_StatusGenerator()
var sqlContainerCreateUpdateParameters_statusGenerator gopter.Gen

// SqlContainerCreateUpdateParameters_StatusGenerator returns a generator of SqlContainerCreateUpdateParameters_Status instances for property testing.
// We first initialize sqlContainerCreateUpdateParameters_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SqlContainerCreateUpdateParameters_StatusGenerator() gopter.Gen {
	if sqlContainerCreateUpdateParameters_statusGenerator != nil {
		return sqlContainerCreateUpdateParameters_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerCreateUpdateParameters_Status(generators)
	sqlContainerCreateUpdateParameters_statusGenerator = gen.Struct(reflect.TypeOf(SqlContainerCreateUpdateParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerCreateUpdateParameters_Status(generators)
	AddRelatedPropertyGeneratorsForSqlContainerCreateUpdateParameters_Status(generators)
	sqlContainerCreateUpdateParameters_statusGenerator = gen.Struct(reflect.TypeOf(SqlContainerCreateUpdateParameters_Status{}), generators)

	return sqlContainerCreateUpdateParameters_statusGenerator
}

// AddIndependentPropertyGeneratorsForSqlContainerCreateUpdateParameters_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSqlContainerCreateUpdateParameters_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSqlContainerCreateUpdateParameters_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlContainerCreateUpdateParameters_Status(gens map[string]gopter.Gen) {
	gens["Options"] = gen.PtrOf(CreateUpdateOptions_StatusGenerator())
	gens["Resource"] = gen.PtrOf(SqlContainerResource_StatusGenerator())
}

func Test_SqlContainerResource_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlContainerResource_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlContainerResource_Spec, SqlContainerResource_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlContainerResource_Spec runs a test to see if a specific instance of SqlContainerResource_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlContainerResource_Spec(subject SqlContainerResource_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlContainerResource_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlContainerResource_Spec instances for property testing - lazily instantiated by
//SqlContainerResource_SpecGenerator()
var sqlContainerResource_specGenerator gopter.Gen

// SqlContainerResource_SpecGenerator returns a generator of SqlContainerResource_Spec instances for property testing.
// We first initialize sqlContainerResource_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SqlContainerResource_SpecGenerator() gopter.Gen {
	if sqlContainerResource_specGenerator != nil {
		return sqlContainerResource_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerResource_Spec(generators)
	sqlContainerResource_specGenerator = gen.Struct(reflect.TypeOf(SqlContainerResource_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerResource_Spec(generators)
	AddRelatedPropertyGeneratorsForSqlContainerResource_Spec(generators)
	sqlContainerResource_specGenerator = gen.Struct(reflect.TypeOf(SqlContainerResource_Spec{}), generators)

	return sqlContainerResource_specGenerator
}

// AddIndependentPropertyGeneratorsForSqlContainerResource_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSqlContainerResource_Spec(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageTtl"] = gen.PtrOf(gen.Int())
	gens["DefaultTtl"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSqlContainerResource_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlContainerResource_Spec(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPolicy"] = gen.PtrOf(ConflictResolutionPolicy_SpecGenerator())
	gens["IndexingPolicy"] = gen.PtrOf(IndexingPolicy_SpecGenerator())
	gens["PartitionKey"] = gen.PtrOf(ContainerPartitionKey_SpecGenerator())
	gens["UniqueKeyPolicy"] = gen.PtrOf(UniqueKeyPolicy_SpecGenerator())
}

func Test_SqlContainerResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlContainerResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlContainerResource_Status, SqlContainerResource_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlContainerResource_Status runs a test to see if a specific instance of SqlContainerResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlContainerResource_Status(subject SqlContainerResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlContainerResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlContainerResource_Status instances for property testing - lazily instantiated by
//SqlContainerResource_StatusGenerator()
var sqlContainerResource_statusGenerator gopter.Gen

// SqlContainerResource_StatusGenerator returns a generator of SqlContainerResource_Status instances for property testing.
// We first initialize sqlContainerResource_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SqlContainerResource_StatusGenerator() gopter.Gen {
	if sqlContainerResource_statusGenerator != nil {
		return sqlContainerResource_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerResource_Status(generators)
	sqlContainerResource_statusGenerator = gen.Struct(reflect.TypeOf(SqlContainerResource_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerResource_Status(generators)
	AddRelatedPropertyGeneratorsForSqlContainerResource_Status(generators)
	sqlContainerResource_statusGenerator = gen.Struct(reflect.TypeOf(SqlContainerResource_Status{}), generators)

	return sqlContainerResource_statusGenerator
}

// AddIndependentPropertyGeneratorsForSqlContainerResource_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSqlContainerResource_Status(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageTtl"] = gen.PtrOf(gen.Int())
	gens["DefaultTtl"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSqlContainerResource_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlContainerResource_Status(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPolicy"] = gen.PtrOf(ConflictResolutionPolicy_StatusGenerator())
	gens["IndexingPolicy"] = gen.PtrOf(IndexingPolicy_StatusGenerator())
	gens["PartitionKey"] = gen.PtrOf(ContainerPartitionKey_StatusGenerator())
	gens["UniqueKeyPolicy"] = gen.PtrOf(UniqueKeyPolicy_StatusGenerator())
}

func Test_ConflictResolutionPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConflictResolutionPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConflictResolutionPolicy_Spec, ConflictResolutionPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConflictResolutionPolicy_Spec runs a test to see if a specific instance of ConflictResolutionPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForConflictResolutionPolicy_Spec(subject ConflictResolutionPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConflictResolutionPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConflictResolutionPolicy_Spec instances for property testing - lazily instantiated by
//ConflictResolutionPolicy_SpecGenerator()
var conflictResolutionPolicy_specGenerator gopter.Gen

// ConflictResolutionPolicy_SpecGenerator returns a generator of ConflictResolutionPolicy_Spec instances for property testing.
func ConflictResolutionPolicy_SpecGenerator() gopter.Gen {
	if conflictResolutionPolicy_specGenerator != nil {
		return conflictResolutionPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConflictResolutionPolicy_Spec(generators)
	conflictResolutionPolicy_specGenerator = gen.Struct(reflect.TypeOf(ConflictResolutionPolicy_Spec{}), generators)

	return conflictResolutionPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForConflictResolutionPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConflictResolutionPolicy_Spec(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPath"] = gen.PtrOf(gen.AlphaString())
	gens["ConflictResolutionProcedure"] = gen.PtrOf(gen.AlphaString())
	gens["Mode"] = gen.PtrOf(gen.AlphaString())
}

func Test_ConflictResolutionPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConflictResolutionPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConflictResolutionPolicy_Status, ConflictResolutionPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConflictResolutionPolicy_Status runs a test to see if a specific instance of ConflictResolutionPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForConflictResolutionPolicy_Status(subject ConflictResolutionPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConflictResolutionPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConflictResolutionPolicy_Status instances for property testing - lazily instantiated by
//ConflictResolutionPolicy_StatusGenerator()
var conflictResolutionPolicy_statusGenerator gopter.Gen

// ConflictResolutionPolicy_StatusGenerator returns a generator of ConflictResolutionPolicy_Status instances for property testing.
func ConflictResolutionPolicy_StatusGenerator() gopter.Gen {
	if conflictResolutionPolicy_statusGenerator != nil {
		return conflictResolutionPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConflictResolutionPolicy_Status(generators)
	conflictResolutionPolicy_statusGenerator = gen.Struct(reflect.TypeOf(ConflictResolutionPolicy_Status{}), generators)

	return conflictResolutionPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForConflictResolutionPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConflictResolutionPolicy_Status(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPath"] = gen.PtrOf(gen.AlphaString())
	gens["ConflictResolutionProcedure"] = gen.PtrOf(gen.AlphaString())
	gens["Mode"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerPartitionKey_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPartitionKey_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPartitionKey_Spec, ContainerPartitionKey_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPartitionKey_Spec runs a test to see if a specific instance of ContainerPartitionKey_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPartitionKey_Spec(subject ContainerPartitionKey_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPartitionKey_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPartitionKey_Spec instances for property testing - lazily instantiated by
//ContainerPartitionKey_SpecGenerator()
var containerPartitionKey_specGenerator gopter.Gen

// ContainerPartitionKey_SpecGenerator returns a generator of ContainerPartitionKey_Spec instances for property testing.
func ContainerPartitionKey_SpecGenerator() gopter.Gen {
	if containerPartitionKey_specGenerator != nil {
		return containerPartitionKey_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPartitionKey_Spec(generators)
	containerPartitionKey_specGenerator = gen.Struct(reflect.TypeOf(ContainerPartitionKey_Spec{}), generators)

	return containerPartitionKey_specGenerator
}

// AddIndependentPropertyGeneratorsForContainerPartitionKey_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPartitionKey_Spec(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.Int())
}

func Test_ContainerPartitionKey_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPartitionKey_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPartitionKey_Status, ContainerPartitionKey_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPartitionKey_Status runs a test to see if a specific instance of ContainerPartitionKey_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPartitionKey_Status(subject ContainerPartitionKey_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPartitionKey_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPartitionKey_Status instances for property testing - lazily instantiated by
//ContainerPartitionKey_StatusGenerator()
var containerPartitionKey_statusGenerator gopter.Gen

// ContainerPartitionKey_StatusGenerator returns a generator of ContainerPartitionKey_Status instances for property testing.
func ContainerPartitionKey_StatusGenerator() gopter.Gen {
	if containerPartitionKey_statusGenerator != nil {
		return containerPartitionKey_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPartitionKey_Status(generators)
	containerPartitionKey_statusGenerator = gen.Struct(reflect.TypeOf(ContainerPartitionKey_Status{}), generators)

	return containerPartitionKey_statusGenerator
}

// AddIndependentPropertyGeneratorsForContainerPartitionKey_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPartitionKey_Status(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
	gens["SystemKey"] = gen.PtrOf(gen.Bool())
	gens["Version"] = gen.PtrOf(gen.Int())
}

func Test_IndexingPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IndexingPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexingPolicy_Spec, IndexingPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexingPolicy_Spec runs a test to see if a specific instance of IndexingPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexingPolicy_Spec(subject IndexingPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IndexingPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IndexingPolicy_Spec instances for property testing - lazily instantiated by
//IndexingPolicy_SpecGenerator()
var indexingPolicy_specGenerator gopter.Gen

// IndexingPolicy_SpecGenerator returns a generator of IndexingPolicy_Spec instances for property testing.
// We first initialize indexingPolicy_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IndexingPolicy_SpecGenerator() gopter.Gen {
	if indexingPolicy_specGenerator != nil {
		return indexingPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicy_Spec(generators)
	indexingPolicy_specGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicy_Spec(generators)
	AddRelatedPropertyGeneratorsForIndexingPolicy_Spec(generators)
	indexingPolicy_specGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_Spec{}), generators)

	return indexingPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForIndexingPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexingPolicy_Spec(gens map[string]gopter.Gen) {
	gens["Automatic"] = gen.PtrOf(gen.Bool())
	gens["IndexingMode"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIndexingPolicy_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIndexingPolicy_Spec(gens map[string]gopter.Gen) {
	gens["CompositeIndexes"] = gen.SliceOf(gen.SliceOf(CompositePath_SpecGenerator()))
	gens["ExcludedPaths"] = gen.SliceOf(ExcludedPath_SpecGenerator())
	gens["IncludedPaths"] = gen.SliceOf(IncludedPath_SpecGenerator())
	gens["SpatialIndexes"] = gen.SliceOf(SpatialSpec_SpecGenerator())
}

func Test_IndexingPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IndexingPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexingPolicy_Status, IndexingPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexingPolicy_Status runs a test to see if a specific instance of IndexingPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexingPolicy_Status(subject IndexingPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IndexingPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IndexingPolicy_Status instances for property testing - lazily instantiated by
//IndexingPolicy_StatusGenerator()
var indexingPolicy_statusGenerator gopter.Gen

// IndexingPolicy_StatusGenerator returns a generator of IndexingPolicy_Status instances for property testing.
// We first initialize indexingPolicy_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IndexingPolicy_StatusGenerator() gopter.Gen {
	if indexingPolicy_statusGenerator != nil {
		return indexingPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicy_Status(generators)
	indexingPolicy_statusGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicy_Status(generators)
	AddRelatedPropertyGeneratorsForIndexingPolicy_Status(generators)
	indexingPolicy_statusGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_Status{}), generators)

	return indexingPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForIndexingPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexingPolicy_Status(gens map[string]gopter.Gen) {
	gens["Automatic"] = gen.PtrOf(gen.Bool())
	gens["IndexingMode"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIndexingPolicy_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIndexingPolicy_Status(gens map[string]gopter.Gen) {
	gens["CompositeIndexes"] = gen.SliceOf(gen.SliceOf(CompositePath_StatusGenerator()))
	gens["ExcludedPaths"] = gen.SliceOf(ExcludedPath_StatusGenerator())
	gens["IncludedPaths"] = gen.SliceOf(IncludedPath_StatusGenerator())
	gens["SpatialIndexes"] = gen.SliceOf(SpatialSpec_StatusGenerator())
}

func Test_UniqueKeyPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKeyPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKeyPolicy_Spec, UniqueKeyPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKeyPolicy_Spec runs a test to see if a specific instance of UniqueKeyPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKeyPolicy_Spec(subject UniqueKeyPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKeyPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKeyPolicy_Spec instances for property testing - lazily instantiated by
//UniqueKeyPolicy_SpecGenerator()
var uniqueKeyPolicy_specGenerator gopter.Gen

// UniqueKeyPolicy_SpecGenerator returns a generator of UniqueKeyPolicy_Spec instances for property testing.
func UniqueKeyPolicy_SpecGenerator() gopter.Gen {
	if uniqueKeyPolicy_specGenerator != nil {
		return uniqueKeyPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForUniqueKeyPolicy_Spec(generators)
	uniqueKeyPolicy_specGenerator = gen.Struct(reflect.TypeOf(UniqueKeyPolicy_Spec{}), generators)

	return uniqueKeyPolicy_specGenerator
}

// AddRelatedPropertyGeneratorsForUniqueKeyPolicy_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUniqueKeyPolicy_Spec(gens map[string]gopter.Gen) {
	gens["UniqueKeys"] = gen.SliceOf(UniqueKey_SpecGenerator())
}

func Test_UniqueKeyPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKeyPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKeyPolicy_Status, UniqueKeyPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKeyPolicy_Status runs a test to see if a specific instance of UniqueKeyPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKeyPolicy_Status(subject UniqueKeyPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKeyPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKeyPolicy_Status instances for property testing - lazily instantiated by
//UniqueKeyPolicy_StatusGenerator()
var uniqueKeyPolicy_statusGenerator gopter.Gen

// UniqueKeyPolicy_StatusGenerator returns a generator of UniqueKeyPolicy_Status instances for property testing.
func UniqueKeyPolicy_StatusGenerator() gopter.Gen {
	if uniqueKeyPolicy_statusGenerator != nil {
		return uniqueKeyPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForUniqueKeyPolicy_Status(generators)
	uniqueKeyPolicy_statusGenerator = gen.Struct(reflect.TypeOf(UniqueKeyPolicy_Status{}), generators)

	return uniqueKeyPolicy_statusGenerator
}

// AddRelatedPropertyGeneratorsForUniqueKeyPolicy_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUniqueKeyPolicy_Status(gens map[string]gopter.Gen) {
	gens["UniqueKeys"] = gen.SliceOf(UniqueKey_StatusGenerator())
}

func Test_CompositePath_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CompositePath_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompositePath_Spec, CompositePath_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompositePath_Spec runs a test to see if a specific instance of CompositePath_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCompositePath_Spec(subject CompositePath_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CompositePath_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CompositePath_Spec instances for property testing - lazily instantiated by CompositePath_SpecGenerator()
var compositePath_specGenerator gopter.Gen

// CompositePath_SpecGenerator returns a generator of CompositePath_Spec instances for property testing.
func CompositePath_SpecGenerator() gopter.Gen {
	if compositePath_specGenerator != nil {
		return compositePath_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompositePath_Spec(generators)
	compositePath_specGenerator = gen.Struct(reflect.TypeOf(CompositePath_Spec{}), generators)

	return compositePath_specGenerator
}

// AddIndependentPropertyGeneratorsForCompositePath_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompositePath_Spec(gens map[string]gopter.Gen) {
	gens["Order"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_CompositePath_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CompositePath_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompositePath_Status, CompositePath_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompositePath_Status runs a test to see if a specific instance of CompositePath_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCompositePath_Status(subject CompositePath_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CompositePath_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CompositePath_Status instances for property testing - lazily instantiated by
//CompositePath_StatusGenerator()
var compositePath_statusGenerator gopter.Gen

// CompositePath_StatusGenerator returns a generator of CompositePath_Status instances for property testing.
func CompositePath_StatusGenerator() gopter.Gen {
	if compositePath_statusGenerator != nil {
		return compositePath_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompositePath_Status(generators)
	compositePath_statusGenerator = gen.Struct(reflect.TypeOf(CompositePath_Status{}), generators)

	return compositePath_statusGenerator
}

// AddIndependentPropertyGeneratorsForCompositePath_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompositePath_Status(gens map[string]gopter.Gen) {
	gens["Order"] = gen.PtrOf(gen.AlphaString())
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExcludedPath_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExcludedPath_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExcludedPath_Spec, ExcludedPath_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExcludedPath_Spec runs a test to see if a specific instance of ExcludedPath_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExcludedPath_Spec(subject ExcludedPath_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExcludedPath_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExcludedPath_Spec instances for property testing - lazily instantiated by ExcludedPath_SpecGenerator()
var excludedPath_specGenerator gopter.Gen

// ExcludedPath_SpecGenerator returns a generator of ExcludedPath_Spec instances for property testing.
func ExcludedPath_SpecGenerator() gopter.Gen {
	if excludedPath_specGenerator != nil {
		return excludedPath_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExcludedPath_Spec(generators)
	excludedPath_specGenerator = gen.Struct(reflect.TypeOf(ExcludedPath_Spec{}), generators)

	return excludedPath_specGenerator
}

// AddIndependentPropertyGeneratorsForExcludedPath_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExcludedPath_Spec(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExcludedPath_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExcludedPath_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExcludedPath_Status, ExcludedPath_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExcludedPath_Status runs a test to see if a specific instance of ExcludedPath_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForExcludedPath_Status(subject ExcludedPath_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExcludedPath_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExcludedPath_Status instances for property testing - lazily instantiated by
//ExcludedPath_StatusGenerator()
var excludedPath_statusGenerator gopter.Gen

// ExcludedPath_StatusGenerator returns a generator of ExcludedPath_Status instances for property testing.
func ExcludedPath_StatusGenerator() gopter.Gen {
	if excludedPath_statusGenerator != nil {
		return excludedPath_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExcludedPath_Status(generators)
	excludedPath_statusGenerator = gen.Struct(reflect.TypeOf(ExcludedPath_Status{}), generators)

	return excludedPath_statusGenerator
}

// AddIndependentPropertyGeneratorsForExcludedPath_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExcludedPath_Status(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_IncludedPath_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IncludedPath_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIncludedPath_Spec, IncludedPath_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIncludedPath_Spec runs a test to see if a specific instance of IncludedPath_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIncludedPath_Spec(subject IncludedPath_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IncludedPath_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IncludedPath_Spec instances for property testing - lazily instantiated by IncludedPath_SpecGenerator()
var includedPath_specGenerator gopter.Gen

// IncludedPath_SpecGenerator returns a generator of IncludedPath_Spec instances for property testing.
// We first initialize includedPath_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IncludedPath_SpecGenerator() gopter.Gen {
	if includedPath_specGenerator != nil {
		return includedPath_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPath_Spec(generators)
	includedPath_specGenerator = gen.Struct(reflect.TypeOf(IncludedPath_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPath_Spec(generators)
	AddRelatedPropertyGeneratorsForIncludedPath_Spec(generators)
	includedPath_specGenerator = gen.Struct(reflect.TypeOf(IncludedPath_Spec{}), generators)

	return includedPath_specGenerator
}

// AddIndependentPropertyGeneratorsForIncludedPath_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIncludedPath_Spec(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIncludedPath_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIncludedPath_Spec(gens map[string]gopter.Gen) {
	gens["Indexes"] = gen.SliceOf(Indexes_SpecGenerator())
}

func Test_IncludedPath_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IncludedPath_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIncludedPath_Status, IncludedPath_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIncludedPath_Status runs a test to see if a specific instance of IncludedPath_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIncludedPath_Status(subject IncludedPath_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IncludedPath_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IncludedPath_Status instances for property testing - lazily instantiated by
//IncludedPath_StatusGenerator()
var includedPath_statusGenerator gopter.Gen

// IncludedPath_StatusGenerator returns a generator of IncludedPath_Status instances for property testing.
// We first initialize includedPath_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IncludedPath_StatusGenerator() gopter.Gen {
	if includedPath_statusGenerator != nil {
		return includedPath_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPath_Status(generators)
	includedPath_statusGenerator = gen.Struct(reflect.TypeOf(IncludedPath_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPath_Status(generators)
	AddRelatedPropertyGeneratorsForIncludedPath_Status(generators)
	includedPath_statusGenerator = gen.Struct(reflect.TypeOf(IncludedPath_Status{}), generators)

	return includedPath_statusGenerator
}

// AddIndependentPropertyGeneratorsForIncludedPath_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIncludedPath_Status(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIncludedPath_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIncludedPath_Status(gens map[string]gopter.Gen) {
	gens["Indexes"] = gen.SliceOf(Indexes_StatusGenerator())
}

func Test_SpatialSpec_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SpatialSpec_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSpatialSpec_Spec, SpatialSpec_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSpatialSpec_Spec runs a test to see if a specific instance of SpatialSpec_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSpatialSpec_Spec(subject SpatialSpec_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SpatialSpec_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SpatialSpec_Spec instances for property testing - lazily instantiated by SpatialSpec_SpecGenerator()
var spatialSpec_specGenerator gopter.Gen

// SpatialSpec_SpecGenerator returns a generator of SpatialSpec_Spec instances for property testing.
func SpatialSpec_SpecGenerator() gopter.Gen {
	if spatialSpec_specGenerator != nil {
		return spatialSpec_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSpatialSpec_Spec(generators)
	spatialSpec_specGenerator = gen.Struct(reflect.TypeOf(SpatialSpec_Spec{}), generators)

	return spatialSpec_specGenerator
}

// AddIndependentPropertyGeneratorsForSpatialSpec_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSpatialSpec_Spec(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Types"] = gen.SliceOf(gen.AlphaString())
}

func Test_SpatialSpec_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SpatialSpec_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSpatialSpec_Status, SpatialSpec_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSpatialSpec_Status runs a test to see if a specific instance of SpatialSpec_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSpatialSpec_Status(subject SpatialSpec_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SpatialSpec_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SpatialSpec_Status instances for property testing - lazily instantiated by SpatialSpec_StatusGenerator()
var spatialSpec_statusGenerator gopter.Gen

// SpatialSpec_StatusGenerator returns a generator of SpatialSpec_Status instances for property testing.
func SpatialSpec_StatusGenerator() gopter.Gen {
	if spatialSpec_statusGenerator != nil {
		return spatialSpec_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSpatialSpec_Status(generators)
	spatialSpec_statusGenerator = gen.Struct(reflect.TypeOf(SpatialSpec_Status{}), generators)

	return spatialSpec_statusGenerator
}

// AddIndependentPropertyGeneratorsForSpatialSpec_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSpatialSpec_Status(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Types"] = gen.SliceOf(gen.AlphaString())
}

func Test_UniqueKey_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKey_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKey_Spec, UniqueKey_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKey_Spec runs a test to see if a specific instance of UniqueKey_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKey_Spec(subject UniqueKey_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKey_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKey_Spec instances for property testing - lazily instantiated by UniqueKey_SpecGenerator()
var uniqueKey_specGenerator gopter.Gen

// UniqueKey_SpecGenerator returns a generator of UniqueKey_Spec instances for property testing.
func UniqueKey_SpecGenerator() gopter.Gen {
	if uniqueKey_specGenerator != nil {
		return uniqueKey_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUniqueKey_Spec(generators)
	uniqueKey_specGenerator = gen.Struct(reflect.TypeOf(UniqueKey_Spec{}), generators)

	return uniqueKey_specGenerator
}

// AddIndependentPropertyGeneratorsForUniqueKey_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUniqueKey_Spec(gens map[string]gopter.Gen) {
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
}

func Test_UniqueKey_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKey_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKey_Status, UniqueKey_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKey_Status runs a test to see if a specific instance of UniqueKey_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKey_Status(subject UniqueKey_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKey_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKey_Status instances for property testing - lazily instantiated by UniqueKey_StatusGenerator()
var uniqueKey_statusGenerator gopter.Gen

// UniqueKey_StatusGenerator returns a generator of UniqueKey_Status instances for property testing.
func UniqueKey_StatusGenerator() gopter.Gen {
	if uniqueKey_statusGenerator != nil {
		return uniqueKey_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUniqueKey_Status(generators)
	uniqueKey_statusGenerator = gen.Struct(reflect.TypeOf(UniqueKey_Status{}), generators)

	return uniqueKey_statusGenerator
}

// AddIndependentPropertyGeneratorsForUniqueKey_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUniqueKey_Status(gens map[string]gopter.Gen) {
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
}

func Test_Indexes_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Indexes_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexes_Spec, Indexes_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexes_Spec runs a test to see if a specific instance of Indexes_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexes_Spec(subject Indexes_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Indexes_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Indexes_Spec instances for property testing - lazily instantiated by Indexes_SpecGenerator()
var indexes_specGenerator gopter.Gen

// Indexes_SpecGenerator returns a generator of Indexes_Spec instances for property testing.
func Indexes_SpecGenerator() gopter.Gen {
	if indexes_specGenerator != nil {
		return indexes_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexes_Spec(generators)
	indexes_specGenerator = gen.Struct(reflect.TypeOf(Indexes_Spec{}), generators)

	return indexes_specGenerator
}

// AddIndependentPropertyGeneratorsForIndexes_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexes_Spec(gens map[string]gopter.Gen) {
	gens["DataType"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Precision"] = gen.PtrOf(gen.Int())
}

func Test_Indexes_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Indexes_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexes_Status, Indexes_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexes_Status runs a test to see if a specific instance of Indexes_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexes_Status(subject Indexes_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Indexes_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Indexes_Status instances for property testing - lazily instantiated by Indexes_StatusGenerator()
var indexes_statusGenerator gopter.Gen

// Indexes_StatusGenerator returns a generator of Indexes_Status instances for property testing.
func Indexes_StatusGenerator() gopter.Gen {
	if indexes_statusGenerator != nil {
		return indexes_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexes_Status(generators)
	indexes_statusGenerator = gen.Struct(reflect.TypeOf(Indexes_Status{}), generators)

	return indexes_statusGenerator
}

// AddIndependentPropertyGeneratorsForIndexes_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexes_Status(gens map[string]gopter.Gen) {
	gens["DataType"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Precision"] = gen.PtrOf(gen.Int())
}
