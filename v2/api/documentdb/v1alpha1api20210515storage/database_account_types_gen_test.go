// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DatabaseAccount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccount, DatabaseAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccount runs a test to see if a specific instance of DatabaseAccount round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccount(subject DatabaseAccount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccount instances for property testing - lazily instantiated by DatabaseAccountGenerator()
var databaseAccountGenerator gopter.Gen

// DatabaseAccountGenerator returns a generator of DatabaseAccount instances for property testing.
func DatabaseAccountGenerator() gopter.Gen {
	if databaseAccountGenerator != nil {
		return databaseAccountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDatabaseAccount(generators)
	databaseAccountGenerator = gen.Struct(reflect.TypeOf(DatabaseAccount{}), generators)

	return databaseAccountGenerator
}

// AddRelatedPropertyGeneratorsForDatabaseAccount is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccount(gens map[string]gopter.Gen) {
	gens["Spec"] = DatabaseAccounts_SPECGenerator()
	gens["Status"] = DatabaseAccountCreateUpdateParameters_StatusGenerator()
}

func Test_DatabaseAccountCreateUpdateParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountCreateUpdateParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountCreateUpdateParameters_Status, DatabaseAccountCreateUpdateParameters_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountCreateUpdateParameters_Status runs a test to see if a specific instance of DatabaseAccountCreateUpdateParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountCreateUpdateParameters_Status(subject DatabaseAccountCreateUpdateParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountCreateUpdateParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountCreateUpdateParameters_Status instances for property testing - lazily instantiated by
//DatabaseAccountCreateUpdateParameters_StatusGenerator()
var databaseAccountCreateUpdateParameters_statusGenerator gopter.Gen

// DatabaseAccountCreateUpdateParameters_StatusGenerator returns a generator of DatabaseAccountCreateUpdateParameters_Status instances for property testing.
// We first initialize databaseAccountCreateUpdateParameters_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountCreateUpdateParameters_StatusGenerator() gopter.Gen {
	if databaseAccountCreateUpdateParameters_statusGenerator != nil {
		return databaseAccountCreateUpdateParameters_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdateParameters_Status(generators)
	databaseAccountCreateUpdateParameters_statusGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountCreateUpdateParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdateParameters_Status(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountCreateUpdateParameters_Status(generators)
	databaseAccountCreateUpdateParameters_statusGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountCreateUpdateParameters_Status{}), generators)

	return databaseAccountCreateUpdateParameters_statusGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdateParameters_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdateParameters_Status(gens map[string]gopter.Gen) {
	gens["ConnectorOffer"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseAccountOfferType"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountCreateUpdateParameters_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountCreateUpdateParameters_Status(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfiguration_StatusGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiProperties_StatusGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicy_StatusGenerator())
	gens["Capabilities"] = gen.SliceOf(Capability_StatusGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicy_StatusGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicy_StatusGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_StatusGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRange_StatusGenerator())
	gens["Locations"] = gen.SliceOf(Location_StatusGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_StatusGenerator())
}

func Test_DatabaseAccounts_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccounts_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccounts_SPEC, DatabaseAccounts_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccounts_SPEC runs a test to see if a specific instance of DatabaseAccounts_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccounts_SPEC(subject DatabaseAccounts_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccounts_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccounts_SPEC instances for property testing - lazily instantiated by
//DatabaseAccounts_SPECGenerator()
var databaseAccounts_specGenerator gopter.Gen

// DatabaseAccounts_SPECGenerator returns a generator of DatabaseAccounts_SPEC instances for property testing.
// We first initialize databaseAccounts_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccounts_SPECGenerator() gopter.Gen {
	if databaseAccounts_specGenerator != nil {
		return databaseAccounts_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccounts_SPEC(generators)
	databaseAccounts_specGenerator = gen.Struct(reflect.TypeOf(DatabaseAccounts_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccounts_SPEC(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccounts_SPEC(generators)
	databaseAccounts_specGenerator = gen.Struct(reflect.TypeOf(DatabaseAccounts_SPEC{}), generators)

	return databaseAccounts_specGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccounts_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccounts_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["ConnectorOffer"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseAccountOfferType"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccounts_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccounts_SPEC(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfiguration_SpecGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiProperties_SpecGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicy_SpecGenerator())
	gens["Capabilities"] = gen.SliceOf(Capability_SpecGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicy_SpecGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicy_SpecGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_SpecGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRange_SpecGenerator())
	gens["Locations"] = gen.SliceOf(Location_SpecGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_SpecGenerator())
}

func Test_AnalyticalStorageConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfiguration_Spec, AnalyticalStorageConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfiguration_Spec runs a test to see if a specific instance of AnalyticalStorageConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfiguration_Spec(subject AnalyticalStorageConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration_Spec instances for property testing - lazily instantiated by
//AnalyticalStorageConfiguration_SpecGenerator()
var analyticalStorageConfiguration_specGenerator gopter.Gen

// AnalyticalStorageConfiguration_SpecGenerator returns a generator of AnalyticalStorageConfiguration_Spec instances for property testing.
func AnalyticalStorageConfiguration_SpecGenerator() gopter.Gen {
	if analyticalStorageConfiguration_specGenerator != nil {
		return analyticalStorageConfiguration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Spec(generators)
	analyticalStorageConfiguration_specGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration_Spec{}), generators)

	return analyticalStorageConfiguration_specGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.AlphaString())
}

func Test_AnalyticalStorageConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfiguration_Status, AnalyticalStorageConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfiguration_Status runs a test to see if a specific instance of AnalyticalStorageConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfiguration_Status(subject AnalyticalStorageConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration_Status instances for property testing - lazily instantiated by
//AnalyticalStorageConfiguration_StatusGenerator()
var analyticalStorageConfiguration_statusGenerator gopter.Gen

// AnalyticalStorageConfiguration_StatusGenerator returns a generator of AnalyticalStorageConfiguration_Status instances for property testing.
func AnalyticalStorageConfiguration_StatusGenerator() gopter.Gen {
	if analyticalStorageConfiguration_statusGenerator != nil {
		return analyticalStorageConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Status(generators)
	analyticalStorageConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration_Status{}), generators)

	return analyticalStorageConfiguration_statusGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Status(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProperties_Spec, ApiProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProperties_Spec runs a test to see if a specific instance of ApiProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProperties_Spec(subject ApiProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_Spec instances for property testing - lazily instantiated by ApiProperties_SpecGenerator()
var apiProperties_specGenerator gopter.Gen

// ApiProperties_SpecGenerator returns a generator of ApiProperties_Spec instances for property testing.
func ApiProperties_SpecGenerator() gopter.Gen {
	if apiProperties_specGenerator != nil {
		return apiProperties_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProperties_Spec(generators)
	apiProperties_specGenerator = gen.Struct(reflect.TypeOf(ApiProperties_Spec{}), generators)

	return apiProperties_specGenerator
}

// AddIndependentPropertyGeneratorsForApiProperties_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProperties_Spec(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProperties_Status, ApiProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProperties_Status runs a test to see if a specific instance of ApiProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProperties_Status(subject ApiProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_Status instances for property testing - lazily instantiated by
//ApiProperties_StatusGenerator()
var apiProperties_statusGenerator gopter.Gen

// ApiProperties_StatusGenerator returns a generator of ApiProperties_Status instances for property testing.
func ApiProperties_StatusGenerator() gopter.Gen {
	if apiProperties_statusGenerator != nil {
		return apiProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProperties_Status(generators)
	apiProperties_statusGenerator = gen.Struct(reflect.TypeOf(ApiProperties_Status{}), generators)

	return apiProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForApiProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProperties_Status(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackupPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicy_Spec, BackupPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicy_Spec runs a test to see if a specific instance of BackupPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicy_Spec(subject BackupPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_Spec instances for property testing - lazily instantiated by BackupPolicy_SpecGenerator()
var backupPolicy_specGenerator gopter.Gen

// BackupPolicy_SpecGenerator returns a generator of BackupPolicy_Spec instances for property testing.
func BackupPolicy_SpecGenerator() gopter.Gen {
	if backupPolicy_specGenerator != nil {
		return backupPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicy_Spec(generators)
	backupPolicy_specGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_Spec{}), generators)

	return backupPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicy_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackupPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicy_Status, BackupPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicy_Status runs a test to see if a specific instance of BackupPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicy_Status(subject BackupPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_Status instances for property testing - lazily instantiated by
//BackupPolicy_StatusGenerator()
var backupPolicy_statusGenerator gopter.Gen

// BackupPolicy_StatusGenerator returns a generator of BackupPolicy_Status instances for property testing.
func BackupPolicy_StatusGenerator() gopter.Gen {
	if backupPolicy_statusGenerator != nil {
		return backupPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicy_Status(generators)
	backupPolicy_statusGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_Status{}), generators)

	return backupPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicy_Status(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_Capability_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapability_Spec, Capability_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapability_Spec runs a test to see if a specific instance of Capability_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCapability_Spec(subject Capability_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability_Spec instances for property testing - lazily instantiated by Capability_SpecGenerator()
var capability_specGenerator gopter.Gen

// Capability_SpecGenerator returns a generator of Capability_Spec instances for property testing.
func Capability_SpecGenerator() gopter.Gen {
	if capability_specGenerator != nil {
		return capability_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapability_Spec(generators)
	capability_specGenerator = gen.Struct(reflect.TypeOf(Capability_Spec{}), generators)

	return capability_specGenerator
}

// AddIndependentPropertyGeneratorsForCapability_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapability_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_Capability_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapability_Status, Capability_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapability_Status runs a test to see if a specific instance of Capability_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCapability_Status(subject Capability_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability_Status instances for property testing - lazily instantiated by Capability_StatusGenerator()
var capability_statusGenerator gopter.Gen

// Capability_StatusGenerator returns a generator of Capability_Status instances for property testing.
func Capability_StatusGenerator() gopter.Gen {
	if capability_statusGenerator != nil {
		return capability_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapability_Status(generators)
	capability_statusGenerator = gen.Struct(reflect.TypeOf(Capability_Status{}), generators)

	return capability_statusGenerator
}

// AddIndependentPropertyGeneratorsForCapability_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapability_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ConsistencyPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicy_Spec, ConsistencyPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicy_Spec runs a test to see if a specific instance of ConsistencyPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicy_Spec(subject ConsistencyPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy_Spec instances for property testing - lazily instantiated by
//ConsistencyPolicy_SpecGenerator()
var consistencyPolicy_specGenerator gopter.Gen

// ConsistencyPolicy_SpecGenerator returns a generator of ConsistencyPolicy_Spec instances for property testing.
func ConsistencyPolicy_SpecGenerator() gopter.Gen {
	if consistencyPolicy_specGenerator != nil {
		return consistencyPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicy_Spec(generators)
	consistencyPolicy_specGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy_Spec{}), generators)

	return consistencyPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicy_Spec(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.PtrOf(gen.AlphaString())
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_ConsistencyPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicy_Status, ConsistencyPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicy_Status runs a test to see if a specific instance of ConsistencyPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicy_Status(subject ConsistencyPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy_Status instances for property testing - lazily instantiated by
//ConsistencyPolicy_StatusGenerator()
var consistencyPolicy_statusGenerator gopter.Gen

// ConsistencyPolicy_StatusGenerator returns a generator of ConsistencyPolicy_Status instances for property testing.
func ConsistencyPolicy_StatusGenerator() gopter.Gen {
	if consistencyPolicy_statusGenerator != nil {
		return consistencyPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicy_Status(generators)
	consistencyPolicy_statusGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy_Status{}), generators)

	return consistencyPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicy_Status(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.PtrOf(gen.AlphaString())
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicy_Spec, CorsPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicy_Spec runs a test to see if a specific instance of CorsPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicy_Spec(subject CorsPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_Spec instances for property testing - lazily instantiated by CorsPolicy_SpecGenerator()
var corsPolicy_specGenerator gopter.Gen

// CorsPolicy_SpecGenerator returns a generator of CorsPolicy_Spec instances for property testing.
func CorsPolicy_SpecGenerator() gopter.Gen {
	if corsPolicy_specGenerator != nil {
		return corsPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicy_Spec(generators)
	corsPolicy_specGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_Spec{}), generators)

	return corsPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicy_Spec(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.PtrOf(gen.AlphaString())
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicy_Status, CorsPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicy_Status runs a test to see if a specific instance of CorsPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicy_Status(subject CorsPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_Status instances for property testing - lazily instantiated by CorsPolicy_StatusGenerator()
var corsPolicy_statusGenerator gopter.Gen

// CorsPolicy_StatusGenerator returns a generator of CorsPolicy_Status instances for property testing.
func CorsPolicy_StatusGenerator() gopter.Gen {
	if corsPolicy_statusGenerator != nil {
		return corsPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicy_Status(generators)
	corsPolicy_statusGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_Status{}), generators)

	return corsPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicy_Status(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.PtrOf(gen.AlphaString())
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_IpAddressOrRange_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRange_Spec, IpAddressOrRange_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRange_Spec runs a test to see if a specific instance of IpAddressOrRange_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRange_Spec(subject IpAddressOrRange_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange_Spec instances for property testing - lazily instantiated by
//IpAddressOrRange_SpecGenerator()
var ipAddressOrRange_specGenerator gopter.Gen

// IpAddressOrRange_SpecGenerator returns a generator of IpAddressOrRange_Spec instances for property testing.
func IpAddressOrRange_SpecGenerator() gopter.Gen {
	if ipAddressOrRange_specGenerator != nil {
		return ipAddressOrRange_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRange_Spec(generators)
	ipAddressOrRange_specGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange_Spec{}), generators)

	return ipAddressOrRange_specGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRange_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRange_Spec(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpAddressOrRange_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRange_Status, IpAddressOrRange_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRange_Status runs a test to see if a specific instance of IpAddressOrRange_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRange_Status(subject IpAddressOrRange_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange_Status instances for property testing - lazily instantiated by
//IpAddressOrRange_StatusGenerator()
var ipAddressOrRange_statusGenerator gopter.Gen

// IpAddressOrRange_StatusGenerator returns a generator of IpAddressOrRange_Status instances for property testing.
func IpAddressOrRange_StatusGenerator() gopter.Gen {
	if ipAddressOrRange_statusGenerator != nil {
		return ipAddressOrRange_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRange_Status(generators)
	ipAddressOrRange_statusGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange_Status{}), generators)

	return ipAddressOrRange_statusGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRange_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRange_Status(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocation_Spec, Location_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocation_Spec runs a test to see if a specific instance of Location_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLocation_Spec(subject Location_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location_Spec instances for property testing - lazily instantiated by Location_SpecGenerator()
var location_specGenerator gopter.Gen

// Location_SpecGenerator returns a generator of Location_Spec instances for property testing.
func Location_SpecGenerator() gopter.Gen {
	if location_specGenerator != nil {
		return location_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocation_Spec(generators)
	location_specGenerator = gen.Struct(reflect.TypeOf(Location_Spec{}), generators)

	return location_specGenerator
}

// AddIndependentPropertyGeneratorsForLocation_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocation_Spec(gens map[string]gopter.Gen) {
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocation_Status, Location_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocation_Status runs a test to see if a specific instance of Location_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLocation_Status(subject Location_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location_Status instances for property testing - lazily instantiated by Location_StatusGenerator()
var location_statusGenerator gopter.Gen

// Location_StatusGenerator returns a generator of Location_Status instances for property testing.
func Location_StatusGenerator() gopter.Gen {
	if location_statusGenerator != nil {
		return location_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocation_Status(generators)
	location_statusGenerator = gen.Struct(reflect.TypeOf(Location_Status{}), generators)

	return location_statusGenerator
}

// AddIndependentPropertyGeneratorsForLocation_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocation_Status(gens map[string]gopter.Gen) {
	gens["DocumentEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_Spec, ManagedServiceIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_Spec runs a test to see if a specific instance of ManagedServiceIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_Spec(subject ManagedServiceIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_Spec instances for property testing - lazily instantiated by
//ManagedServiceIdentity_SpecGenerator()
var managedServiceIdentity_specGenerator gopter.Gen

// ManagedServiceIdentity_SpecGenerator returns a generator of ManagedServiceIdentity_Spec instances for property testing.
func ManagedServiceIdentity_SpecGenerator() gopter.Gen {
	if managedServiceIdentity_specGenerator != nil {
		return managedServiceIdentity_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_Spec(generators)
	managedServiceIdentity_specGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Spec{}), generators)

	return managedServiceIdentity_specGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_Status, ManagedServiceIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_Status runs a test to see if a specific instance of ManagedServiceIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_Status(subject ManagedServiceIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_Status instances for property testing - lazily instantiated by
//ManagedServiceIdentity_StatusGenerator()
var managedServiceIdentity_statusGenerator gopter.Gen

// ManagedServiceIdentity_StatusGenerator returns a generator of ManagedServiceIdentity_Status instances for property testing.
// We first initialize managedServiceIdentity_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_StatusGenerator() gopter.Gen {
	if managedServiceIdentity_statusGenerator != nil {
		return managedServiceIdentity_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_Status(generators)
	managedServiceIdentity_statusGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_Status(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_Status(generators)
	managedServiceIdentity_statusGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Status{}), generators)

	return managedServiceIdentity_statusGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_Status(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_Status(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), ManagedServiceIdentity_UserAssignedIdentities_StatusGenerator())
}

func Test_VirtualNetworkRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_Spec, VirtualNetworkRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_Spec runs a test to see if a specific instance of VirtualNetworkRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_Spec(subject VirtualNetworkRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_Spec instances for property testing - lazily instantiated by
//VirtualNetworkRule_SpecGenerator()
var virtualNetworkRule_specGenerator gopter.Gen

// VirtualNetworkRule_SpecGenerator returns a generator of VirtualNetworkRule_Spec instances for property testing.
func VirtualNetworkRule_SpecGenerator() gopter.Gen {
	if virtualNetworkRule_specGenerator != nil {
		return virtualNetworkRule_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_Spec(generators)
	virtualNetworkRule_specGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_Spec{}), generators)

	return virtualNetworkRule_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_Spec(gens map[string]gopter.Gen) {
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}

func Test_VirtualNetworkRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_Status, VirtualNetworkRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_Status runs a test to see if a specific instance of VirtualNetworkRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_Status(subject VirtualNetworkRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_Status instances for property testing - lazily instantiated by
//VirtualNetworkRule_StatusGenerator()
var virtualNetworkRule_statusGenerator gopter.Gen

// VirtualNetworkRule_StatusGenerator returns a generator of VirtualNetworkRule_Status instances for property testing.
func VirtualNetworkRule_StatusGenerator() gopter.Gen {
	if virtualNetworkRule_statusGenerator != nil {
		return virtualNetworkRule_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_Status(generators)
	virtualNetworkRule_statusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_Status{}), generators)

	return virtualNetworkRule_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}

func Test_ManagedServiceIdentity_UserAssignedIdentities_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_UserAssignedIdentities_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_Status, ManagedServiceIdentity_UserAssignedIdentities_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_Status runs a test to see if a specific instance of ManagedServiceIdentity_UserAssignedIdentities_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_Status(subject ManagedServiceIdentity_UserAssignedIdentities_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_UserAssignedIdentities_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_UserAssignedIdentities_Status instances for property testing - lazily
//instantiated by ManagedServiceIdentity_UserAssignedIdentities_StatusGenerator()
var managedServiceIdentity_userAssignedIdentities_statusGenerator gopter.Gen

// ManagedServiceIdentity_UserAssignedIdentities_StatusGenerator returns a generator of ManagedServiceIdentity_UserAssignedIdentities_Status instances for property testing.
func ManagedServiceIdentity_UserAssignedIdentities_StatusGenerator() gopter.Gen {
	if managedServiceIdentity_userAssignedIdentities_statusGenerator != nil {
		return managedServiceIdentity_userAssignedIdentities_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_Status(generators)
	managedServiceIdentity_userAssignedIdentities_statusGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_UserAssignedIdentities_Status{}), generators)

	return managedServiceIdentity_userAssignedIdentities_statusGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_Status(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}
