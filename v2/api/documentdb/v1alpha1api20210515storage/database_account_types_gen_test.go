// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DatabaseAccount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccount, DatabaseAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccount runs a test to see if a specific instance of DatabaseAccount round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccount(subject DatabaseAccount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccount instances for property testing - lazily instantiated by DatabaseAccountGenerator()
var databaseAccountGenerator gopter.Gen

// DatabaseAccountGenerator returns a generator of DatabaseAccount instances for property testing.
func DatabaseAccountGenerator() gopter.Gen {
	if databaseAccountGenerator != nil {
		return databaseAccountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDatabaseAccount(generators)
	databaseAccountGenerator = gen.Struct(reflect.TypeOf(DatabaseAccount{}), generators)

	return databaseAccountGenerator
}

// AddRelatedPropertyGeneratorsForDatabaseAccount is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccount(gens map[string]gopter.Gen) {
	gens["Spec"] = DatabaseAccountsSPECGenerator()
	gens["Status"] = DatabaseAccountCreateUpdateParametersStatusGenerator()
}

func Test_DatabaseAccountCreateUpdateParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountCreateUpdateParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountCreateUpdateParametersStatus, DatabaseAccountCreateUpdateParametersStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountCreateUpdateParametersStatus runs a test to see if a specific instance of DatabaseAccountCreateUpdateParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountCreateUpdateParametersStatus(subject DatabaseAccountCreateUpdateParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountCreateUpdateParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountCreateUpdateParameters_Status instances for property testing - lazily instantiated by
//DatabaseAccountCreateUpdateParametersStatusGenerator()
var databaseAccountCreateUpdateParametersStatusGenerator gopter.Gen

// DatabaseAccountCreateUpdateParametersStatusGenerator returns a generator of DatabaseAccountCreateUpdateParameters_Status instances for property testing.
// We first initialize databaseAccountCreateUpdateParametersStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountCreateUpdateParametersStatusGenerator() gopter.Gen {
	if databaseAccountCreateUpdateParametersStatusGenerator != nil {
		return databaseAccountCreateUpdateParametersStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdateParametersStatus(generators)
	databaseAccountCreateUpdateParametersStatusGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountCreateUpdateParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdateParametersStatus(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountCreateUpdateParametersStatus(generators)
	databaseAccountCreateUpdateParametersStatusGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountCreateUpdateParameters_Status{}), generators)

	return databaseAccountCreateUpdateParametersStatusGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdateParametersStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdateParametersStatus(gens map[string]gopter.Gen) {
	gens["ConnectorOffer"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseAccountOfferType"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountCreateUpdateParametersStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountCreateUpdateParametersStatus(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfigurationStatusGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiPropertiesStatusGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicyStatusGenerator())
	gens["Capabilities"] = gen.SliceOf(CapabilityStatusGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicyStatusGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicyStatusGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityStatusGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRangeStatusGenerator())
	gens["Locations"] = gen.SliceOf(LocationStatusGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleStatusGenerator())
}

func Test_DatabaseAccounts_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccounts_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountsSPEC, DatabaseAccountsSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountsSPEC runs a test to see if a specific instance of DatabaseAccounts_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountsSPEC(subject DatabaseAccounts_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccounts_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccounts_SPEC instances for property testing - lazily instantiated by
//DatabaseAccountsSPECGenerator()
var databaseAccountsSPECGenerator gopter.Gen

// DatabaseAccountsSPECGenerator returns a generator of DatabaseAccounts_SPEC instances for property testing.
// We first initialize databaseAccountsSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountsSPECGenerator() gopter.Gen {
	if databaseAccountsSPECGenerator != nil {
		return databaseAccountsSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsSPEC(generators)
	databaseAccountsSPECGenerator = gen.Struct(reflect.TypeOf(DatabaseAccounts_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsSPEC(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountsSPEC(generators)
	databaseAccountsSPECGenerator = gen.Struct(reflect.TypeOf(DatabaseAccounts_SPEC{}), generators)

	return databaseAccountsSPECGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountsSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountsSPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["ConnectorOffer"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseAccountOfferType"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountsSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountsSPEC(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfigurationSpecGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiPropertiesSpecGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicySpecGenerator())
	gens["Capabilities"] = gen.SliceOf(CapabilitySpecGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicySpecGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicySpecGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentitySpecGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRangeSpecGenerator())
	gens["Locations"] = gen.SliceOf(LocationSpecGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleSpecGenerator())
}

func Test_AnalyticalStorageConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfigurationSpec, AnalyticalStorageConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfigurationSpec runs a test to see if a specific instance of AnalyticalStorageConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfigurationSpec(subject AnalyticalStorageConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration_Spec instances for property testing - lazily instantiated by
//AnalyticalStorageConfigurationSpecGenerator()
var analyticalStorageConfigurationSpecGenerator gopter.Gen

// AnalyticalStorageConfigurationSpecGenerator returns a generator of AnalyticalStorageConfiguration_Spec instances for property testing.
func AnalyticalStorageConfigurationSpecGenerator() gopter.Gen {
	if analyticalStorageConfigurationSpecGenerator != nil {
		return analyticalStorageConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationSpec(generators)
	analyticalStorageConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration_Spec{}), generators)

	return analyticalStorageConfigurationSpecGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationSpec(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.AlphaString())
}

func Test_AnalyticalStorageConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfigurationStatus, AnalyticalStorageConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfigurationStatus runs a test to see if a specific instance of AnalyticalStorageConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfigurationStatus(subject AnalyticalStorageConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration_Status instances for property testing - lazily instantiated by
//AnalyticalStorageConfigurationStatusGenerator()
var analyticalStorageConfigurationStatusGenerator gopter.Gen

// AnalyticalStorageConfigurationStatusGenerator returns a generator of AnalyticalStorageConfiguration_Status instances for property testing.
func AnalyticalStorageConfigurationStatusGenerator() gopter.Gen {
	if analyticalStorageConfigurationStatusGenerator != nil {
		return analyticalStorageConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationStatus(generators)
	analyticalStorageConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration_Status{}), generators)

	return analyticalStorageConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationStatus(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiPropertiesSpec, ApiPropertiesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiPropertiesSpec runs a test to see if a specific instance of ApiProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForApiPropertiesSpec(subject ApiProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_Spec instances for property testing - lazily instantiated by ApiPropertiesSpecGenerator()
var apiPropertiesSpecGenerator gopter.Gen

// ApiPropertiesSpecGenerator returns a generator of ApiProperties_Spec instances for property testing.
func ApiPropertiesSpecGenerator() gopter.Gen {
	if apiPropertiesSpecGenerator != nil {
		return apiPropertiesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiPropertiesSpec(generators)
	apiPropertiesSpecGenerator = gen.Struct(reflect.TypeOf(ApiProperties_Spec{}), generators)

	return apiPropertiesSpecGenerator
}

// AddIndependentPropertyGeneratorsForApiPropertiesSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiPropertiesSpec(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiPropertiesStatus, ApiPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiPropertiesStatus runs a test to see if a specific instance of ApiProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiPropertiesStatus(subject ApiProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_Status instances for property testing - lazily instantiated by
//ApiPropertiesStatusGenerator()
var apiPropertiesStatusGenerator gopter.Gen

// ApiPropertiesStatusGenerator returns a generator of ApiProperties_Status instances for property testing.
func ApiPropertiesStatusGenerator() gopter.Gen {
	if apiPropertiesStatusGenerator != nil {
		return apiPropertiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiPropertiesStatus(generators)
	apiPropertiesStatusGenerator = gen.Struct(reflect.TypeOf(ApiProperties_Status{}), generators)

	return apiPropertiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForApiPropertiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiPropertiesStatus(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackupPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicySpec, BackupPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicySpec runs a test to see if a specific instance of BackupPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicySpec(subject BackupPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_Spec instances for property testing - lazily instantiated by BackupPolicySpecGenerator()
var backupPolicySpecGenerator gopter.Gen

// BackupPolicySpecGenerator returns a generator of BackupPolicy_Spec instances for property testing.
func BackupPolicySpecGenerator() gopter.Gen {
	if backupPolicySpecGenerator != nil {
		return backupPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicySpec(generators)
	backupPolicySpecGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_Spec{}), generators)

	return backupPolicySpecGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicySpec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackupPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicyStatus, BackupPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicyStatus runs a test to see if a specific instance of BackupPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicyStatus(subject BackupPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_Status instances for property testing - lazily instantiated by BackupPolicyStatusGenerator()
var backupPolicyStatusGenerator gopter.Gen

// BackupPolicyStatusGenerator returns a generator of BackupPolicy_Status instances for property testing.
func BackupPolicyStatusGenerator() gopter.Gen {
	if backupPolicyStatusGenerator != nil {
		return backupPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicyStatus(generators)
	backupPolicyStatusGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_Status{}), generators)

	return backupPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicyStatus(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_Capability_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapabilitySpec, CapabilitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapabilitySpec runs a test to see if a specific instance of Capability_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCapabilitySpec(subject Capability_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability_Spec instances for property testing - lazily instantiated by CapabilitySpecGenerator()
var capabilitySpecGenerator gopter.Gen

// CapabilitySpecGenerator returns a generator of Capability_Spec instances for property testing.
func CapabilitySpecGenerator() gopter.Gen {
	if capabilitySpecGenerator != nil {
		return capabilitySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapabilitySpec(generators)
	capabilitySpecGenerator = gen.Struct(reflect.TypeOf(Capability_Spec{}), generators)

	return capabilitySpecGenerator
}

// AddIndependentPropertyGeneratorsForCapabilitySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapabilitySpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_Capability_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapabilityStatus, CapabilityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapabilityStatus runs a test to see if a specific instance of Capability_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCapabilityStatus(subject Capability_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability_Status instances for property testing - lazily instantiated by CapabilityStatusGenerator()
var capabilityStatusGenerator gopter.Gen

// CapabilityStatusGenerator returns a generator of Capability_Status instances for property testing.
func CapabilityStatusGenerator() gopter.Gen {
	if capabilityStatusGenerator != nil {
		return capabilityStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapabilityStatus(generators)
	capabilityStatusGenerator = gen.Struct(reflect.TypeOf(Capability_Status{}), generators)

	return capabilityStatusGenerator
}

// AddIndependentPropertyGeneratorsForCapabilityStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapabilityStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ConsistencyPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicySpec, ConsistencyPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicySpec runs a test to see if a specific instance of ConsistencyPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicySpec(subject ConsistencyPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy_Spec instances for property testing - lazily instantiated by
//ConsistencyPolicySpecGenerator()
var consistencyPolicySpecGenerator gopter.Gen

// ConsistencyPolicySpecGenerator returns a generator of ConsistencyPolicy_Spec instances for property testing.
func ConsistencyPolicySpecGenerator() gopter.Gen {
	if consistencyPolicySpecGenerator != nil {
		return consistencyPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicySpec(generators)
	consistencyPolicySpecGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy_Spec{}), generators)

	return consistencyPolicySpecGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicySpec(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.PtrOf(gen.AlphaString())
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_ConsistencyPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicyStatus, ConsistencyPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicyStatus runs a test to see if a specific instance of ConsistencyPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicyStatus(subject ConsistencyPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy_Status instances for property testing - lazily instantiated by
//ConsistencyPolicyStatusGenerator()
var consistencyPolicyStatusGenerator gopter.Gen

// ConsistencyPolicyStatusGenerator returns a generator of ConsistencyPolicy_Status instances for property testing.
func ConsistencyPolicyStatusGenerator() gopter.Gen {
	if consistencyPolicyStatusGenerator != nil {
		return consistencyPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicyStatus(generators)
	consistencyPolicyStatusGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy_Status{}), generators)

	return consistencyPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicyStatus(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.PtrOf(gen.AlphaString())
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicySpec, CorsPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicySpec runs a test to see if a specific instance of CorsPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicySpec(subject CorsPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_Spec instances for property testing - lazily instantiated by CorsPolicySpecGenerator()
var corsPolicySpecGenerator gopter.Gen

// CorsPolicySpecGenerator returns a generator of CorsPolicy_Spec instances for property testing.
func CorsPolicySpecGenerator() gopter.Gen {
	if corsPolicySpecGenerator != nil {
		return corsPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicySpec(generators)
	corsPolicySpecGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_Spec{}), generators)

	return corsPolicySpecGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicySpec(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.PtrOf(gen.AlphaString())
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicyStatus, CorsPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicyStatus runs a test to see if a specific instance of CorsPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicyStatus(subject CorsPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_Status instances for property testing - lazily instantiated by CorsPolicyStatusGenerator()
var corsPolicyStatusGenerator gopter.Gen

// CorsPolicyStatusGenerator returns a generator of CorsPolicy_Status instances for property testing.
func CorsPolicyStatusGenerator() gopter.Gen {
	if corsPolicyStatusGenerator != nil {
		return corsPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicyStatus(generators)
	corsPolicyStatusGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_Status{}), generators)

	return corsPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicyStatus(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.PtrOf(gen.AlphaString())
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_IpAddressOrRange_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRangeSpec, IpAddressOrRangeSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRangeSpec runs a test to see if a specific instance of IpAddressOrRange_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRangeSpec(subject IpAddressOrRange_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange_Spec instances for property testing - lazily instantiated by
//IpAddressOrRangeSpecGenerator()
var ipAddressOrRangeSpecGenerator gopter.Gen

// IpAddressOrRangeSpecGenerator returns a generator of IpAddressOrRange_Spec instances for property testing.
func IpAddressOrRangeSpecGenerator() gopter.Gen {
	if ipAddressOrRangeSpecGenerator != nil {
		return ipAddressOrRangeSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRangeSpec(generators)
	ipAddressOrRangeSpecGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange_Spec{}), generators)

	return ipAddressOrRangeSpecGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRangeSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRangeSpec(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpAddressOrRange_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRangeStatus, IpAddressOrRangeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRangeStatus runs a test to see if a specific instance of IpAddressOrRange_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRangeStatus(subject IpAddressOrRange_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange_Status instances for property testing - lazily instantiated by
//IpAddressOrRangeStatusGenerator()
var ipAddressOrRangeStatusGenerator gopter.Gen

// IpAddressOrRangeStatusGenerator returns a generator of IpAddressOrRange_Status instances for property testing.
func IpAddressOrRangeStatusGenerator() gopter.Gen {
	if ipAddressOrRangeStatusGenerator != nil {
		return ipAddressOrRangeStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRangeStatus(generators)
	ipAddressOrRangeStatusGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange_Status{}), generators)

	return ipAddressOrRangeStatusGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRangeStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRangeStatus(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocationSpec, LocationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocationSpec runs a test to see if a specific instance of Location_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLocationSpec(subject Location_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location_Spec instances for property testing - lazily instantiated by LocationSpecGenerator()
var locationSpecGenerator gopter.Gen

// LocationSpecGenerator returns a generator of Location_Spec instances for property testing.
func LocationSpecGenerator() gopter.Gen {
	if locationSpecGenerator != nil {
		return locationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocationSpec(generators)
	locationSpecGenerator = gen.Struct(reflect.TypeOf(Location_Spec{}), generators)

	return locationSpecGenerator
}

// AddIndependentPropertyGeneratorsForLocationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocationSpec(gens map[string]gopter.Gen) {
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocationStatus, LocationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocationStatus runs a test to see if a specific instance of Location_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLocationStatus(subject Location_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location_Status instances for property testing - lazily instantiated by LocationStatusGenerator()
var locationStatusGenerator gopter.Gen

// LocationStatusGenerator returns a generator of Location_Status instances for property testing.
func LocationStatusGenerator() gopter.Gen {
	if locationStatusGenerator != nil {
		return locationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocationStatus(generators)
	locationStatusGenerator = gen.Struct(reflect.TypeOf(Location_Status{}), generators)

	return locationStatusGenerator
}

// AddIndependentPropertyGeneratorsForLocationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocationStatus(gens map[string]gopter.Gen) {
	gens["DocumentEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentitySpec, ManagedServiceIdentitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentitySpec runs a test to see if a specific instance of ManagedServiceIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentitySpec(subject ManagedServiceIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_Spec instances for property testing - lazily instantiated by
//ManagedServiceIdentitySpecGenerator()
var managedServiceIdentitySpecGenerator gopter.Gen

// ManagedServiceIdentitySpecGenerator returns a generator of ManagedServiceIdentity_Spec instances for property testing.
func ManagedServiceIdentitySpecGenerator() gopter.Gen {
	if managedServiceIdentitySpecGenerator != nil {
		return managedServiceIdentitySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentitySpec(generators)
	managedServiceIdentitySpecGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Spec{}), generators)

	return managedServiceIdentitySpecGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentitySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentitySpec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentityStatus, ManagedServiceIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentityStatus runs a test to see if a specific instance of ManagedServiceIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentityStatus(subject ManagedServiceIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_Status instances for property testing - lazily instantiated by
//ManagedServiceIdentityStatusGenerator()
var managedServiceIdentityStatusGenerator gopter.Gen

// ManagedServiceIdentityStatusGenerator returns a generator of ManagedServiceIdentity_Status instances for property testing.
// We first initialize managedServiceIdentityStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityStatusGenerator() gopter.Gen {
	if managedServiceIdentityStatusGenerator != nil {
		return managedServiceIdentityStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentityStatus(generators)
	managedServiceIdentityStatusGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentityStatus(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentityStatus(generators)
	managedServiceIdentityStatusGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Status{}), generators)

	return managedServiceIdentityStatusGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentityStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentityStatus(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentityStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentityStatus(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), ManagedServiceIdentityStatusUserAssignedIdentitiesGenerator())
}

func Test_VirtualNetworkRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleSpec, VirtualNetworkRuleSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleSpec runs a test to see if a specific instance of VirtualNetworkRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleSpec(subject VirtualNetworkRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_Spec instances for property testing - lazily instantiated by
//VirtualNetworkRuleSpecGenerator()
var virtualNetworkRuleSpecGenerator gopter.Gen

// VirtualNetworkRuleSpecGenerator returns a generator of VirtualNetworkRule_Spec instances for property testing.
func VirtualNetworkRuleSpecGenerator() gopter.Gen {
	if virtualNetworkRuleSpecGenerator != nil {
		return virtualNetworkRuleSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpec(generators)
	virtualNetworkRuleSpecGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_Spec{}), generators)

	return virtualNetworkRuleSpecGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpec(gens map[string]gopter.Gen) {
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}

func Test_VirtualNetworkRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleStatus, VirtualNetworkRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleStatus runs a test to see if a specific instance of VirtualNetworkRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleStatus(subject VirtualNetworkRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_Status instances for property testing - lazily instantiated by
//VirtualNetworkRuleStatusGenerator()
var virtualNetworkRuleStatusGenerator gopter.Gen

// VirtualNetworkRuleStatusGenerator returns a generator of VirtualNetworkRule_Status instances for property testing.
func VirtualNetworkRuleStatusGenerator() gopter.Gen {
	if virtualNetworkRuleStatusGenerator != nil {
		return virtualNetworkRuleStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatus(generators)
	virtualNetworkRuleStatusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_Status{}), generators)

	return virtualNetworkRuleStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}

func Test_ManagedServiceIdentity_Status_UserAssignedIdentities_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_Status_UserAssignedIdentities via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentityStatusUserAssignedIdentities, ManagedServiceIdentityStatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentityStatusUserAssignedIdentities runs a test to see if a specific instance of ManagedServiceIdentity_Status_UserAssignedIdentities round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentityStatusUserAssignedIdentities(subject ManagedServiceIdentity_Status_UserAssignedIdentities) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_Status_UserAssignedIdentities
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_Status_UserAssignedIdentities instances for property testing - lazily
//instantiated by ManagedServiceIdentityStatusUserAssignedIdentitiesGenerator()
var managedServiceIdentityStatusUserAssignedIdentitiesGenerator gopter.Gen

// ManagedServiceIdentityStatusUserAssignedIdentitiesGenerator returns a generator of ManagedServiceIdentity_Status_UserAssignedIdentities instances for property testing.
func ManagedServiceIdentityStatusUserAssignedIdentitiesGenerator() gopter.Gen {
	if managedServiceIdentityStatusUserAssignedIdentitiesGenerator != nil {
		return managedServiceIdentityStatusUserAssignedIdentitiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentityStatusUserAssignedIdentities(generators)
	managedServiceIdentityStatusUserAssignedIdentitiesGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Status_UserAssignedIdentities{}), generators)

	return managedServiceIdentityStatusUserAssignedIdentitiesGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentityStatusUserAssignedIdentities is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentityStatusUserAssignedIdentities(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}
