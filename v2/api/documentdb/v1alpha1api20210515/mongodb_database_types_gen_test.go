// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/documentdb/v1alpha1api20210515storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_MongodbDatabase_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MongodbDatabase to hub returns original",
		prop.ForAll(RunResourceConversionTestForMongodbDatabase, MongodbDatabaseGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForMongodbDatabase tests if a specific instance of MongodbDatabase round trips to the hub storage version and back losslessly
func RunResourceConversionTestForMongodbDatabase(subject MongodbDatabase) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20210515storage.MongodbDatabase
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual MongodbDatabase
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MongodbDatabase_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MongodbDatabase to MongodbDatabase via AssignPropertiesToMongodbDatabase & AssignPropertiesFromMongodbDatabase returns original",
		prop.ForAll(RunPropertyAssignmentTestForMongodbDatabase, MongodbDatabaseGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMongodbDatabase tests if a specific instance of MongodbDatabase can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForMongodbDatabase(subject MongodbDatabase) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.MongodbDatabase
	err := copied.AssignPropertiesToMongodbDatabase(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MongodbDatabase
	err = actual.AssignPropertiesFromMongodbDatabase(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MongodbDatabase_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongodbDatabase via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongodbDatabase, MongodbDatabaseGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongodbDatabase runs a test to see if a specific instance of MongodbDatabase round trips to JSON and back losslessly
func RunJSONSerializationTestForMongodbDatabase(subject MongodbDatabase) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongodbDatabase
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongodbDatabase instances for property testing - lazily instantiated by MongodbDatabaseGenerator()
var mongodbDatabaseGenerator gopter.Gen

// MongodbDatabaseGenerator returns a generator of MongodbDatabase instances for property testing.
func MongodbDatabaseGenerator() gopter.Gen {
	if mongodbDatabaseGenerator != nil {
		return mongodbDatabaseGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMongodbDatabase(generators)
	mongodbDatabaseGenerator = gen.Struct(reflect.TypeOf(MongodbDatabase{}), generators)

	return mongodbDatabaseGenerator
}

// AddRelatedPropertyGeneratorsForMongodbDatabase is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMongodbDatabase(gens map[string]gopter.Gen) {
	gens["Spec"] = DatabaseAccountsMongodbDatabasesSPECGenerator()
	gens["Status"] = MongoDBDatabaseCreateUpdateParametersStatusGenerator()
}

func Test_DatabaseAccountsMongodbDatabases_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccountsMongodbDatabases_SPEC to DatabaseAccountsMongodbDatabases_SPEC via AssignPropertiesToDatabaseAccountsMongodbDatabasesSPEC & AssignPropertiesFromDatabaseAccountsMongodbDatabasesSPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatabaseAccountsMongodbDatabasesSPEC, DatabaseAccountsMongodbDatabasesSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatabaseAccountsMongodbDatabasesSPEC tests if a specific instance of DatabaseAccountsMongodbDatabases_SPEC can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForDatabaseAccountsMongodbDatabasesSPEC(subject DatabaseAccountsMongodbDatabases_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.DatabaseAccountsMongodbDatabases_SPEC
	err := copied.AssignPropertiesToDatabaseAccountsMongodbDatabasesSPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatabaseAccountsMongodbDatabases_SPEC
	err = actual.AssignPropertiesFromDatabaseAccountsMongodbDatabasesSPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccountsMongodbDatabases_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountsMongodbDatabases_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountsMongodbDatabasesSPEC, DatabaseAccountsMongodbDatabasesSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountsMongodbDatabasesSPEC runs a test to see if a specific instance of DatabaseAccountsMongodbDatabases_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountsMongodbDatabasesSPEC(subject DatabaseAccountsMongodbDatabases_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountsMongodbDatabases_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountsMongodbDatabases_SPEC instances for property testing - lazily instantiated by
//DatabaseAccountsMongodbDatabasesSPECGenerator()
var databaseAccountsMongodbDatabasesSPECGenerator gopter.Gen

// DatabaseAccountsMongodbDatabasesSPECGenerator returns a generator of DatabaseAccountsMongodbDatabases_SPEC instances for property testing.
// We first initialize databaseAccountsMongodbDatabasesSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountsMongodbDatabasesSPECGenerator() gopter.Gen {
	if databaseAccountsMongodbDatabasesSPECGenerator != nil {
		return databaseAccountsMongodbDatabasesSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsMongodbDatabasesSPEC(generators)
	databaseAccountsMongodbDatabasesSPECGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountsMongodbDatabases_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsMongodbDatabasesSPEC(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountsMongodbDatabasesSPEC(generators)
	databaseAccountsMongodbDatabasesSPECGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountsMongodbDatabases_SPEC{}), generators)

	return databaseAccountsMongodbDatabasesSPECGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountsMongodbDatabasesSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountsMongodbDatabasesSPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountsMongodbDatabasesSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountsMongodbDatabasesSPEC(gens map[string]gopter.Gen) {
	gens["Options"] = gen.PtrOf(CreateUpdateOptionsSpecGenerator())
	gens["Resource"] = MongoDBDatabaseResourceSpecGenerator()
}

func Test_MongoDBDatabaseCreateUpdateParameters_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MongoDBDatabaseCreateUpdateParameters_Status to MongoDBDatabaseCreateUpdateParameters_Status via AssignPropertiesToMongoDBDatabaseCreateUpdateParametersStatus & AssignPropertiesFromMongoDBDatabaseCreateUpdateParametersStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForMongoDBDatabaseCreateUpdateParametersStatus, MongoDBDatabaseCreateUpdateParametersStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMongoDBDatabaseCreateUpdateParametersStatus tests if a specific instance of MongoDBDatabaseCreateUpdateParameters_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForMongoDBDatabaseCreateUpdateParametersStatus(subject MongoDBDatabaseCreateUpdateParameters_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.MongoDBDatabaseCreateUpdateParameters_Status
	err := copied.AssignPropertiesToMongoDBDatabaseCreateUpdateParametersStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MongoDBDatabaseCreateUpdateParameters_Status
	err = actual.AssignPropertiesFromMongoDBDatabaseCreateUpdateParametersStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MongoDBDatabaseCreateUpdateParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoDBDatabaseCreateUpdateParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoDBDatabaseCreateUpdateParametersStatus, MongoDBDatabaseCreateUpdateParametersStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoDBDatabaseCreateUpdateParametersStatus runs a test to see if a specific instance of MongoDBDatabaseCreateUpdateParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoDBDatabaseCreateUpdateParametersStatus(subject MongoDBDatabaseCreateUpdateParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoDBDatabaseCreateUpdateParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoDBDatabaseCreateUpdateParameters_Status instances for property testing - lazily instantiated by
//MongoDBDatabaseCreateUpdateParametersStatusGenerator()
var mongoDBDatabaseCreateUpdateParametersStatusGenerator gopter.Gen

// MongoDBDatabaseCreateUpdateParametersStatusGenerator returns a generator of MongoDBDatabaseCreateUpdateParameters_Status instances for property testing.
// We first initialize mongoDBDatabaseCreateUpdateParametersStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MongoDBDatabaseCreateUpdateParametersStatusGenerator() gopter.Gen {
	if mongoDBDatabaseCreateUpdateParametersStatusGenerator != nil {
		return mongoDBDatabaseCreateUpdateParametersStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoDBDatabaseCreateUpdateParametersStatus(generators)
	mongoDBDatabaseCreateUpdateParametersStatusGenerator = gen.Struct(reflect.TypeOf(MongoDBDatabaseCreateUpdateParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoDBDatabaseCreateUpdateParametersStatus(generators)
	AddRelatedPropertyGeneratorsForMongoDBDatabaseCreateUpdateParametersStatus(generators)
	mongoDBDatabaseCreateUpdateParametersStatusGenerator = gen.Struct(reflect.TypeOf(MongoDBDatabaseCreateUpdateParameters_Status{}), generators)

	return mongoDBDatabaseCreateUpdateParametersStatusGenerator
}

// AddIndependentPropertyGeneratorsForMongoDBDatabaseCreateUpdateParametersStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoDBDatabaseCreateUpdateParametersStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMongoDBDatabaseCreateUpdateParametersStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMongoDBDatabaseCreateUpdateParametersStatus(gens map[string]gopter.Gen) {
	gens["Options"] = gen.PtrOf(CreateUpdateOptionsStatusGenerator())
	gens["Resource"] = gen.PtrOf(MongoDBDatabaseResourceStatusGenerator())
}

func Test_CreateUpdateOptions_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CreateUpdateOptions_Spec to CreateUpdateOptions_Spec via AssignPropertiesToCreateUpdateOptionsSpec & AssignPropertiesFromCreateUpdateOptionsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForCreateUpdateOptionsSpec, CreateUpdateOptionsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCreateUpdateOptionsSpec tests if a specific instance of CreateUpdateOptions_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCreateUpdateOptionsSpec(subject CreateUpdateOptions_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.CreateUpdateOptions_Spec
	err := copied.AssignPropertiesToCreateUpdateOptionsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CreateUpdateOptions_Spec
	err = actual.AssignPropertiesFromCreateUpdateOptionsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CreateUpdateOptions_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreateUpdateOptions_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreateUpdateOptionsSpec, CreateUpdateOptionsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreateUpdateOptionsSpec runs a test to see if a specific instance of CreateUpdateOptions_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCreateUpdateOptionsSpec(subject CreateUpdateOptions_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreateUpdateOptions_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreateUpdateOptions_Spec instances for property testing - lazily instantiated by
//CreateUpdateOptionsSpecGenerator()
var createUpdateOptionsSpecGenerator gopter.Gen

// CreateUpdateOptionsSpecGenerator returns a generator of CreateUpdateOptions_Spec instances for property testing.
// We first initialize createUpdateOptionsSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreateUpdateOptionsSpecGenerator() gopter.Gen {
	if createUpdateOptionsSpecGenerator != nil {
		return createUpdateOptionsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreateUpdateOptionsSpec(generators)
	createUpdateOptionsSpecGenerator = gen.Struct(reflect.TypeOf(CreateUpdateOptions_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreateUpdateOptionsSpec(generators)
	AddRelatedPropertyGeneratorsForCreateUpdateOptionsSpec(generators)
	createUpdateOptionsSpecGenerator = gen.Struct(reflect.TypeOf(CreateUpdateOptions_Spec{}), generators)

	return createUpdateOptionsSpecGenerator
}

// AddIndependentPropertyGeneratorsForCreateUpdateOptionsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreateUpdateOptionsSpec(gens map[string]gopter.Gen) {
	gens["Throughput"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreateUpdateOptionsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreateUpdateOptionsSpec(gens map[string]gopter.Gen) {
	gens["AutoscaleSettings"] = gen.PtrOf(AutoscaleSettingsSpecGenerator())
}

func Test_CreateUpdateOptions_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CreateUpdateOptions_Status to CreateUpdateOptions_Status via AssignPropertiesToCreateUpdateOptionsStatus & AssignPropertiesFromCreateUpdateOptionsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForCreateUpdateOptionsStatus, CreateUpdateOptionsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCreateUpdateOptionsStatus tests if a specific instance of CreateUpdateOptions_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCreateUpdateOptionsStatus(subject CreateUpdateOptions_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.CreateUpdateOptions_Status
	err := copied.AssignPropertiesToCreateUpdateOptionsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CreateUpdateOptions_Status
	err = actual.AssignPropertiesFromCreateUpdateOptionsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CreateUpdateOptions_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreateUpdateOptions_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreateUpdateOptionsStatus, CreateUpdateOptionsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreateUpdateOptionsStatus runs a test to see if a specific instance of CreateUpdateOptions_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCreateUpdateOptionsStatus(subject CreateUpdateOptions_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreateUpdateOptions_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreateUpdateOptions_Status instances for property testing - lazily instantiated by
//CreateUpdateOptionsStatusGenerator()
var createUpdateOptionsStatusGenerator gopter.Gen

// CreateUpdateOptionsStatusGenerator returns a generator of CreateUpdateOptions_Status instances for property testing.
// We first initialize createUpdateOptionsStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreateUpdateOptionsStatusGenerator() gopter.Gen {
	if createUpdateOptionsStatusGenerator != nil {
		return createUpdateOptionsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreateUpdateOptionsStatus(generators)
	createUpdateOptionsStatusGenerator = gen.Struct(reflect.TypeOf(CreateUpdateOptions_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreateUpdateOptionsStatus(generators)
	AddRelatedPropertyGeneratorsForCreateUpdateOptionsStatus(generators)
	createUpdateOptionsStatusGenerator = gen.Struct(reflect.TypeOf(CreateUpdateOptions_Status{}), generators)

	return createUpdateOptionsStatusGenerator
}

// AddIndependentPropertyGeneratorsForCreateUpdateOptionsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreateUpdateOptionsStatus(gens map[string]gopter.Gen) {
	gens["Throughput"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreateUpdateOptionsStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreateUpdateOptionsStatus(gens map[string]gopter.Gen) {
	gens["AutoscaleSettings"] = gen.PtrOf(AutoscaleSettingsStatusGenerator())
}

func Test_MongoDBDatabaseResource_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MongoDBDatabaseResource_Spec to MongoDBDatabaseResource_Spec via AssignPropertiesToMongoDBDatabaseResourceSpec & AssignPropertiesFromMongoDBDatabaseResourceSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForMongoDBDatabaseResourceSpec, MongoDBDatabaseResourceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMongoDBDatabaseResourceSpec tests if a specific instance of MongoDBDatabaseResource_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForMongoDBDatabaseResourceSpec(subject MongoDBDatabaseResource_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.MongoDBDatabaseResource_Spec
	err := copied.AssignPropertiesToMongoDBDatabaseResourceSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MongoDBDatabaseResource_Spec
	err = actual.AssignPropertiesFromMongoDBDatabaseResourceSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MongoDBDatabaseResource_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoDBDatabaseResource_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoDBDatabaseResourceSpec, MongoDBDatabaseResourceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoDBDatabaseResourceSpec runs a test to see if a specific instance of MongoDBDatabaseResource_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoDBDatabaseResourceSpec(subject MongoDBDatabaseResource_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoDBDatabaseResource_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoDBDatabaseResource_Spec instances for property testing - lazily instantiated by
//MongoDBDatabaseResourceSpecGenerator()
var mongoDBDatabaseResourceSpecGenerator gopter.Gen

// MongoDBDatabaseResourceSpecGenerator returns a generator of MongoDBDatabaseResource_Spec instances for property testing.
func MongoDBDatabaseResourceSpecGenerator() gopter.Gen {
	if mongoDBDatabaseResourceSpecGenerator != nil {
		return mongoDBDatabaseResourceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoDBDatabaseResourceSpec(generators)
	mongoDBDatabaseResourceSpecGenerator = gen.Struct(reflect.TypeOf(MongoDBDatabaseResource_Spec{}), generators)

	return mongoDBDatabaseResourceSpecGenerator
}

// AddIndependentPropertyGeneratorsForMongoDBDatabaseResourceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoDBDatabaseResourceSpec(gens map[string]gopter.Gen) {
	gens["Id"] = gen.AlphaString()
}

func Test_MongoDBDatabaseResource_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MongoDBDatabaseResource_Status to MongoDBDatabaseResource_Status via AssignPropertiesToMongoDBDatabaseResourceStatus & AssignPropertiesFromMongoDBDatabaseResourceStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForMongoDBDatabaseResourceStatus, MongoDBDatabaseResourceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMongoDBDatabaseResourceStatus tests if a specific instance of MongoDBDatabaseResource_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForMongoDBDatabaseResourceStatus(subject MongoDBDatabaseResource_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.MongoDBDatabaseResource_Status
	err := copied.AssignPropertiesToMongoDBDatabaseResourceStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MongoDBDatabaseResource_Status
	err = actual.AssignPropertiesFromMongoDBDatabaseResourceStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MongoDBDatabaseResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoDBDatabaseResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoDBDatabaseResourceStatus, MongoDBDatabaseResourceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoDBDatabaseResourceStatus runs a test to see if a specific instance of MongoDBDatabaseResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoDBDatabaseResourceStatus(subject MongoDBDatabaseResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoDBDatabaseResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoDBDatabaseResource_Status instances for property testing - lazily instantiated by
//MongoDBDatabaseResourceStatusGenerator()
var mongoDBDatabaseResourceStatusGenerator gopter.Gen

// MongoDBDatabaseResourceStatusGenerator returns a generator of MongoDBDatabaseResource_Status instances for property testing.
func MongoDBDatabaseResourceStatusGenerator() gopter.Gen {
	if mongoDBDatabaseResourceStatusGenerator != nil {
		return mongoDBDatabaseResourceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoDBDatabaseResourceStatus(generators)
	mongoDBDatabaseResourceStatusGenerator = gen.Struct(reflect.TypeOf(MongoDBDatabaseResource_Status{}), generators)

	return mongoDBDatabaseResourceStatusGenerator
}

// AddIndependentPropertyGeneratorsForMongoDBDatabaseResourceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoDBDatabaseResourceStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.AlphaString()
}

func Test_AutoscaleSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoscaleSettings_Spec to AutoscaleSettings_Spec via AssignPropertiesToAutoscaleSettingsSpec & AssignPropertiesFromAutoscaleSettingsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoscaleSettingsSpec, AutoscaleSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoscaleSettingsSpec tests if a specific instance of AutoscaleSettings_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForAutoscaleSettingsSpec(subject AutoscaleSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.AutoscaleSettings_Spec
	err := copied.AssignPropertiesToAutoscaleSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoscaleSettings_Spec
	err = actual.AssignPropertiesFromAutoscaleSettingsSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoscaleSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleSettingsSpec, AutoscaleSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleSettingsSpec runs a test to see if a specific instance of AutoscaleSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleSettingsSpec(subject AutoscaleSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleSettings_Spec instances for property testing - lazily instantiated by
//AutoscaleSettingsSpecGenerator()
var autoscaleSettingsSpecGenerator gopter.Gen

// AutoscaleSettingsSpecGenerator returns a generator of AutoscaleSettings_Spec instances for property testing.
func AutoscaleSettingsSpecGenerator() gopter.Gen {
	if autoscaleSettingsSpecGenerator != nil {
		return autoscaleSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSettingsSpec(generators)
	autoscaleSettingsSpecGenerator = gen.Struct(reflect.TypeOf(AutoscaleSettings_Spec{}), generators)

	return autoscaleSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleSettingsSpec(gens map[string]gopter.Gen) {
	gens["MaxThroughput"] = gen.PtrOf(gen.Int())
}

func Test_AutoscaleSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoscaleSettings_Status to AutoscaleSettings_Status via AssignPropertiesToAutoscaleSettingsStatus & AssignPropertiesFromAutoscaleSettingsStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoscaleSettingsStatus, AutoscaleSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoscaleSettingsStatus tests if a specific instance of AutoscaleSettings_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForAutoscaleSettingsStatus(subject AutoscaleSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.AutoscaleSettings_Status
	err := copied.AssignPropertiesToAutoscaleSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoscaleSettings_Status
	err = actual.AssignPropertiesFromAutoscaleSettingsStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoscaleSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleSettingsStatus, AutoscaleSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleSettingsStatus runs a test to see if a specific instance of AutoscaleSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleSettingsStatus(subject AutoscaleSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleSettings_Status instances for property testing - lazily instantiated by
//AutoscaleSettingsStatusGenerator()
var autoscaleSettingsStatusGenerator gopter.Gen

// AutoscaleSettingsStatusGenerator returns a generator of AutoscaleSettings_Status instances for property testing.
func AutoscaleSettingsStatusGenerator() gopter.Gen {
	if autoscaleSettingsStatusGenerator != nil {
		return autoscaleSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSettingsStatus(generators)
	autoscaleSettingsStatusGenerator = gen.Struct(reflect.TypeOf(AutoscaleSettings_Status{}), generators)

	return autoscaleSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleSettingsStatus(gens map[string]gopter.Gen) {
	gens["MaxThroughput"] = gen.PtrOf(gen.Int())
}
