// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/documentdb/v1alpha1api20210515storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_MongodbDatabase_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MongodbDatabase to hub returns original",
		prop.ForAll(RunResourceConversionTestForMongodbDatabase, MongodbDatabaseGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForMongodbDatabase tests if a specific instance of MongodbDatabase round trips to the hub storage version and back losslessly
func RunResourceConversionTestForMongodbDatabase(subject MongodbDatabase) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20210515storage.MongodbDatabase
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual MongodbDatabase
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MongodbDatabase_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MongodbDatabase to MongodbDatabase via AssignPropertiesToMongodbDatabase & AssignPropertiesFromMongodbDatabase returns original",
		prop.ForAll(RunPropertyAssignmentTestForMongodbDatabase, MongodbDatabaseGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMongodbDatabase tests if a specific instance of MongodbDatabase can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForMongodbDatabase(subject MongodbDatabase) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.MongodbDatabase
	err := copied.AssignPropertiesToMongodbDatabase(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MongodbDatabase
	err = actual.AssignPropertiesFromMongodbDatabase(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MongodbDatabase_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongodbDatabase via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongodbDatabase, MongodbDatabaseGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongodbDatabase runs a test to see if a specific instance of MongodbDatabase round trips to JSON and back losslessly
func RunJSONSerializationTestForMongodbDatabase(subject MongodbDatabase) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongodbDatabase
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongodbDatabase instances for property testing - lazily instantiated by MongodbDatabaseGenerator()
var mongodbDatabaseGenerator gopter.Gen

// MongodbDatabaseGenerator returns a generator of MongodbDatabase instances for property testing.
func MongodbDatabaseGenerator() gopter.Gen {
	if mongodbDatabaseGenerator != nil {
		return mongodbDatabaseGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMongodbDatabase(generators)
	mongodbDatabaseGenerator = gen.Struct(reflect.TypeOf(MongodbDatabase{}), generators)

	return mongodbDatabaseGenerator
}

// AddRelatedPropertyGeneratorsForMongodbDatabase is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMongodbDatabase(gens map[string]gopter.Gen) {
	gens["Spec"] = DatabaseAccountsMongodbDatabases_SPECGenerator()
	gens["Status"] = MongoDBDatabaseCreateUpdateParameters_StatusGenerator()
}

func Test_DatabaseAccountsMongodbDatabases_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccountsMongodbDatabases_SPEC to DatabaseAccountsMongodbDatabases_SPEC via AssignPropertiesToDatabaseAccountsMongodbDatabases_SPEC & AssignPropertiesFromDatabaseAccountsMongodbDatabases_SPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatabaseAccountsMongodbDatabases_SPEC, DatabaseAccountsMongodbDatabases_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatabaseAccountsMongodbDatabases_SPEC tests if a specific instance of DatabaseAccountsMongodbDatabases_SPEC can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForDatabaseAccountsMongodbDatabases_SPEC(subject DatabaseAccountsMongodbDatabases_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.DatabaseAccountsMongodbDatabases_SPEC
	err := copied.AssignPropertiesToDatabaseAccountsMongodbDatabases_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatabaseAccountsMongodbDatabases_SPEC
	err = actual.AssignPropertiesFromDatabaseAccountsMongodbDatabases_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccountsMongodbDatabases_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountsMongodbDatabases_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountsMongodbDatabases_SPEC, DatabaseAccountsMongodbDatabases_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountsMongodbDatabases_SPEC runs a test to see if a specific instance of DatabaseAccountsMongodbDatabases_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountsMongodbDatabases_SPEC(subject DatabaseAccountsMongodbDatabases_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountsMongodbDatabases_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountsMongodbDatabases_SPEC instances for property testing - lazily instantiated by
//DatabaseAccountsMongodbDatabases_SPECGenerator()
var databaseAccountsMongodbDatabases_specGenerator gopter.Gen

// DatabaseAccountsMongodbDatabases_SPECGenerator returns a generator of DatabaseAccountsMongodbDatabases_SPEC instances for property testing.
// We first initialize databaseAccountsMongodbDatabases_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountsMongodbDatabases_SPECGenerator() gopter.Gen {
	if databaseAccountsMongodbDatabases_specGenerator != nil {
		return databaseAccountsMongodbDatabases_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsMongodbDatabases_SPEC(generators)
	databaseAccountsMongodbDatabases_specGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountsMongodbDatabases_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsMongodbDatabases_SPEC(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountsMongodbDatabases_SPEC(generators)
	databaseAccountsMongodbDatabases_specGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountsMongodbDatabases_SPEC{}), generators)

	return databaseAccountsMongodbDatabases_specGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountsMongodbDatabases_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountsMongodbDatabases_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountsMongodbDatabases_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountsMongodbDatabases_SPEC(gens map[string]gopter.Gen) {
	gens["Options"] = gen.PtrOf(CreateUpdateOptions_SpecGenerator())
	gens["Resource"] = MongoDBDatabaseResource_SpecGenerator()
}

func Test_MongoDBDatabaseCreateUpdateParameters_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MongoDBDatabaseCreateUpdateParameters_Status to MongoDBDatabaseCreateUpdateParameters_Status via AssignPropertiesToMongoDBDatabaseCreateUpdateParameters_Status & AssignPropertiesFromMongoDBDatabaseCreateUpdateParameters_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForMongoDBDatabaseCreateUpdateParameters_Status, MongoDBDatabaseCreateUpdateParameters_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMongoDBDatabaseCreateUpdateParameters_Status tests if a specific instance of MongoDBDatabaseCreateUpdateParameters_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForMongoDBDatabaseCreateUpdateParameters_Status(subject MongoDBDatabaseCreateUpdateParameters_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.MongoDBDatabaseCreateUpdateParameters_Status
	err := copied.AssignPropertiesToMongoDBDatabaseCreateUpdateParameters_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MongoDBDatabaseCreateUpdateParameters_Status
	err = actual.AssignPropertiesFromMongoDBDatabaseCreateUpdateParameters_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MongoDBDatabaseCreateUpdateParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoDBDatabaseCreateUpdateParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoDBDatabaseCreateUpdateParameters_Status, MongoDBDatabaseCreateUpdateParameters_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoDBDatabaseCreateUpdateParameters_Status runs a test to see if a specific instance of MongoDBDatabaseCreateUpdateParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoDBDatabaseCreateUpdateParameters_Status(subject MongoDBDatabaseCreateUpdateParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoDBDatabaseCreateUpdateParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoDBDatabaseCreateUpdateParameters_Status instances for property testing - lazily instantiated by
//MongoDBDatabaseCreateUpdateParameters_StatusGenerator()
var mongoDBDatabaseCreateUpdateParameters_statusGenerator gopter.Gen

// MongoDBDatabaseCreateUpdateParameters_StatusGenerator returns a generator of MongoDBDatabaseCreateUpdateParameters_Status instances for property testing.
// We first initialize mongoDBDatabaseCreateUpdateParameters_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MongoDBDatabaseCreateUpdateParameters_StatusGenerator() gopter.Gen {
	if mongoDBDatabaseCreateUpdateParameters_statusGenerator != nil {
		return mongoDBDatabaseCreateUpdateParameters_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoDBDatabaseCreateUpdateParameters_Status(generators)
	mongoDBDatabaseCreateUpdateParameters_statusGenerator = gen.Struct(reflect.TypeOf(MongoDBDatabaseCreateUpdateParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoDBDatabaseCreateUpdateParameters_Status(generators)
	AddRelatedPropertyGeneratorsForMongoDBDatabaseCreateUpdateParameters_Status(generators)
	mongoDBDatabaseCreateUpdateParameters_statusGenerator = gen.Struct(reflect.TypeOf(MongoDBDatabaseCreateUpdateParameters_Status{}), generators)

	return mongoDBDatabaseCreateUpdateParameters_statusGenerator
}

// AddIndependentPropertyGeneratorsForMongoDBDatabaseCreateUpdateParameters_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoDBDatabaseCreateUpdateParameters_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMongoDBDatabaseCreateUpdateParameters_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMongoDBDatabaseCreateUpdateParameters_Status(gens map[string]gopter.Gen) {
	gens["Options"] = gen.PtrOf(CreateUpdateOptions_StatusGenerator())
	gens["Resource"] = gen.PtrOf(MongoDBDatabaseResource_StatusGenerator())
}

func Test_CreateUpdateOptions_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CreateUpdateOptions_Spec to CreateUpdateOptions_Spec via AssignPropertiesToCreateUpdateOptions_Spec & AssignPropertiesFromCreateUpdateOptions_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForCreateUpdateOptions_Spec, CreateUpdateOptions_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCreateUpdateOptions_Spec tests if a specific instance of CreateUpdateOptions_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCreateUpdateOptions_Spec(subject CreateUpdateOptions_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.CreateUpdateOptions_Spec
	err := copied.AssignPropertiesToCreateUpdateOptions_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CreateUpdateOptions_Spec
	err = actual.AssignPropertiesFromCreateUpdateOptions_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CreateUpdateOptions_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreateUpdateOptions_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreateUpdateOptions_Spec, CreateUpdateOptions_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreateUpdateOptions_Spec runs a test to see if a specific instance of CreateUpdateOptions_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCreateUpdateOptions_Spec(subject CreateUpdateOptions_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreateUpdateOptions_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreateUpdateOptions_Spec instances for property testing - lazily instantiated by
//CreateUpdateOptions_SpecGenerator()
var createUpdateOptions_specGenerator gopter.Gen

// CreateUpdateOptions_SpecGenerator returns a generator of CreateUpdateOptions_Spec instances for property testing.
// We first initialize createUpdateOptions_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreateUpdateOptions_SpecGenerator() gopter.Gen {
	if createUpdateOptions_specGenerator != nil {
		return createUpdateOptions_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreateUpdateOptions_Spec(generators)
	createUpdateOptions_specGenerator = gen.Struct(reflect.TypeOf(CreateUpdateOptions_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreateUpdateOptions_Spec(generators)
	AddRelatedPropertyGeneratorsForCreateUpdateOptions_Spec(generators)
	createUpdateOptions_specGenerator = gen.Struct(reflect.TypeOf(CreateUpdateOptions_Spec{}), generators)

	return createUpdateOptions_specGenerator
}

// AddIndependentPropertyGeneratorsForCreateUpdateOptions_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreateUpdateOptions_Spec(gens map[string]gopter.Gen) {
	gens["Throughput"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreateUpdateOptions_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreateUpdateOptions_Spec(gens map[string]gopter.Gen) {
	gens["AutoscaleSettings"] = gen.PtrOf(AutoscaleSettings_SpecGenerator())
}

func Test_CreateUpdateOptions_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CreateUpdateOptions_Status to CreateUpdateOptions_Status via AssignPropertiesToCreateUpdateOptions_Status & AssignPropertiesFromCreateUpdateOptions_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForCreateUpdateOptions_Status, CreateUpdateOptions_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCreateUpdateOptions_Status tests if a specific instance of CreateUpdateOptions_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCreateUpdateOptions_Status(subject CreateUpdateOptions_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.CreateUpdateOptions_Status
	err := copied.AssignPropertiesToCreateUpdateOptions_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CreateUpdateOptions_Status
	err = actual.AssignPropertiesFromCreateUpdateOptions_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CreateUpdateOptions_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CreateUpdateOptions_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCreateUpdateOptions_Status, CreateUpdateOptions_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCreateUpdateOptions_Status runs a test to see if a specific instance of CreateUpdateOptions_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCreateUpdateOptions_Status(subject CreateUpdateOptions_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CreateUpdateOptions_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CreateUpdateOptions_Status instances for property testing - lazily instantiated by
//CreateUpdateOptions_StatusGenerator()
var createUpdateOptions_statusGenerator gopter.Gen

// CreateUpdateOptions_StatusGenerator returns a generator of CreateUpdateOptions_Status instances for property testing.
// We first initialize createUpdateOptions_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CreateUpdateOptions_StatusGenerator() gopter.Gen {
	if createUpdateOptions_statusGenerator != nil {
		return createUpdateOptions_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreateUpdateOptions_Status(generators)
	createUpdateOptions_statusGenerator = gen.Struct(reflect.TypeOf(CreateUpdateOptions_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCreateUpdateOptions_Status(generators)
	AddRelatedPropertyGeneratorsForCreateUpdateOptions_Status(generators)
	createUpdateOptions_statusGenerator = gen.Struct(reflect.TypeOf(CreateUpdateOptions_Status{}), generators)

	return createUpdateOptions_statusGenerator
}

// AddIndependentPropertyGeneratorsForCreateUpdateOptions_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCreateUpdateOptions_Status(gens map[string]gopter.Gen) {
	gens["Throughput"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForCreateUpdateOptions_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCreateUpdateOptions_Status(gens map[string]gopter.Gen) {
	gens["AutoscaleSettings"] = gen.PtrOf(AutoscaleSettings_StatusGenerator())
}

func Test_MongoDBDatabaseResource_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MongoDBDatabaseResource_Spec to MongoDBDatabaseResource_Spec via AssignPropertiesToMongoDBDatabaseResource_Spec & AssignPropertiesFromMongoDBDatabaseResource_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForMongoDBDatabaseResource_Spec, MongoDBDatabaseResource_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMongoDBDatabaseResource_Spec tests if a specific instance of MongoDBDatabaseResource_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForMongoDBDatabaseResource_Spec(subject MongoDBDatabaseResource_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.MongoDBDatabaseResource_Spec
	err := copied.AssignPropertiesToMongoDBDatabaseResource_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MongoDBDatabaseResource_Spec
	err = actual.AssignPropertiesFromMongoDBDatabaseResource_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MongoDBDatabaseResource_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoDBDatabaseResource_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoDBDatabaseResource_Spec, MongoDBDatabaseResource_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoDBDatabaseResource_Spec runs a test to see if a specific instance of MongoDBDatabaseResource_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoDBDatabaseResource_Spec(subject MongoDBDatabaseResource_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoDBDatabaseResource_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoDBDatabaseResource_Spec instances for property testing - lazily instantiated by
//MongoDBDatabaseResource_SpecGenerator()
var mongoDBDatabaseResource_specGenerator gopter.Gen

// MongoDBDatabaseResource_SpecGenerator returns a generator of MongoDBDatabaseResource_Spec instances for property testing.
func MongoDBDatabaseResource_SpecGenerator() gopter.Gen {
	if mongoDBDatabaseResource_specGenerator != nil {
		return mongoDBDatabaseResource_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoDBDatabaseResource_Spec(generators)
	mongoDBDatabaseResource_specGenerator = gen.Struct(reflect.TypeOf(MongoDBDatabaseResource_Spec{}), generators)

	return mongoDBDatabaseResource_specGenerator
}

// AddIndependentPropertyGeneratorsForMongoDBDatabaseResource_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoDBDatabaseResource_Spec(gens map[string]gopter.Gen) {
	gens["Id"] = gen.AlphaString()
}

func Test_MongoDBDatabaseResource_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from MongoDBDatabaseResource_Status to MongoDBDatabaseResource_Status via AssignPropertiesToMongoDBDatabaseResource_Status & AssignPropertiesFromMongoDBDatabaseResource_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForMongoDBDatabaseResource_Status, MongoDBDatabaseResource_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForMongoDBDatabaseResource_Status tests if a specific instance of MongoDBDatabaseResource_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForMongoDBDatabaseResource_Status(subject MongoDBDatabaseResource_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.MongoDBDatabaseResource_Status
	err := copied.AssignPropertiesToMongoDBDatabaseResource_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual MongoDBDatabaseResource_Status
	err = actual.AssignPropertiesFromMongoDBDatabaseResource_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_MongoDBDatabaseResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoDBDatabaseResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoDBDatabaseResource_Status, MongoDBDatabaseResource_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoDBDatabaseResource_Status runs a test to see if a specific instance of MongoDBDatabaseResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoDBDatabaseResource_Status(subject MongoDBDatabaseResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoDBDatabaseResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoDBDatabaseResource_Status instances for property testing - lazily instantiated by
//MongoDBDatabaseResource_StatusGenerator()
var mongoDBDatabaseResource_statusGenerator gopter.Gen

// MongoDBDatabaseResource_StatusGenerator returns a generator of MongoDBDatabaseResource_Status instances for property testing.
func MongoDBDatabaseResource_StatusGenerator() gopter.Gen {
	if mongoDBDatabaseResource_statusGenerator != nil {
		return mongoDBDatabaseResource_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoDBDatabaseResource_Status(generators)
	mongoDBDatabaseResource_statusGenerator = gen.Struct(reflect.TypeOf(MongoDBDatabaseResource_Status{}), generators)

	return mongoDBDatabaseResource_statusGenerator
}

// AddIndependentPropertyGeneratorsForMongoDBDatabaseResource_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoDBDatabaseResource_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.AlphaString()
}

func Test_AutoscaleSettings_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoscaleSettings_Spec to AutoscaleSettings_Spec via AssignPropertiesToAutoscaleSettings_Spec & AssignPropertiesFromAutoscaleSettings_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoscaleSettings_Spec, AutoscaleSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoscaleSettings_Spec tests if a specific instance of AutoscaleSettings_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForAutoscaleSettings_Spec(subject AutoscaleSettings_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.AutoscaleSettings_Spec
	err := copied.AssignPropertiesToAutoscaleSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoscaleSettings_Spec
	err = actual.AssignPropertiesFromAutoscaleSettings_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoscaleSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleSettings_Spec, AutoscaleSettings_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleSettings_Spec runs a test to see if a specific instance of AutoscaleSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleSettings_Spec(subject AutoscaleSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleSettings_Spec instances for property testing - lazily instantiated by
//AutoscaleSettings_SpecGenerator()
var autoscaleSettings_specGenerator gopter.Gen

// AutoscaleSettings_SpecGenerator returns a generator of AutoscaleSettings_Spec instances for property testing.
func AutoscaleSettings_SpecGenerator() gopter.Gen {
	if autoscaleSettings_specGenerator != nil {
		return autoscaleSettings_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSettings_Spec(generators)
	autoscaleSettings_specGenerator = gen.Struct(reflect.TypeOf(AutoscaleSettings_Spec{}), generators)

	return autoscaleSettings_specGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleSettings_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleSettings_Spec(gens map[string]gopter.Gen) {
	gens["MaxThroughput"] = gen.PtrOf(gen.Int())
}

func Test_AutoscaleSettings_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AutoscaleSettings_Status to AutoscaleSettings_Status via AssignPropertiesToAutoscaleSettings_Status & AssignPropertiesFromAutoscaleSettings_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAutoscaleSettings_Status, AutoscaleSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAutoscaleSettings_Status tests if a specific instance of AutoscaleSettings_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForAutoscaleSettings_Status(subject AutoscaleSettings_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.AutoscaleSettings_Status
	err := copied.AssignPropertiesToAutoscaleSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AutoscaleSettings_Status
	err = actual.AssignPropertiesFromAutoscaleSettings_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AutoscaleSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AutoscaleSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAutoscaleSettings_Status, AutoscaleSettings_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAutoscaleSettings_Status runs a test to see if a specific instance of AutoscaleSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAutoscaleSettings_Status(subject AutoscaleSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AutoscaleSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AutoscaleSettings_Status instances for property testing - lazily instantiated by
//AutoscaleSettings_StatusGenerator()
var autoscaleSettings_statusGenerator gopter.Gen

// AutoscaleSettings_StatusGenerator returns a generator of AutoscaleSettings_Status instances for property testing.
func AutoscaleSettings_StatusGenerator() gopter.Gen {
	if autoscaleSettings_statusGenerator != nil {
		return autoscaleSettings_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAutoscaleSettings_Status(generators)
	autoscaleSettings_statusGenerator = gen.Struct(reflect.TypeOf(AutoscaleSettings_Status{}), generators)

	return autoscaleSettings_statusGenerator
}

// AddIndependentPropertyGeneratorsForAutoscaleSettings_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAutoscaleSettings_Status(gens map[string]gopter.Gen) {
	gens["MaxThroughput"] = gen.PtrOf(gen.Int())
}
