// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DatabaseAccountsSqlDatabasesContainers_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountsSqlDatabasesContainers_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountsSqlDatabasesContainers_SPECARM, DatabaseAccountsSqlDatabasesContainers_SPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountsSqlDatabasesContainers_SPECARM runs a test to see if a specific instance of DatabaseAccountsSqlDatabasesContainers_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountsSqlDatabasesContainers_SPECARM(subject DatabaseAccountsSqlDatabasesContainers_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountsSqlDatabasesContainers_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountsSqlDatabasesContainers_SPECARM instances for property testing - lazily instantiated by
//DatabaseAccountsSqlDatabasesContainers_SPECARMGenerator()
var databaseAccountsSqlDatabasesContainers_specarmGenerator gopter.Gen

// DatabaseAccountsSqlDatabasesContainers_SPECARMGenerator returns a generator of DatabaseAccountsSqlDatabasesContainers_SPECARM instances for property testing.
// We first initialize databaseAccountsSqlDatabasesContainers_specarmGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountsSqlDatabasesContainers_SPECARMGenerator() gopter.Gen {
	if databaseAccountsSqlDatabasesContainers_specarmGenerator != nil {
		return databaseAccountsSqlDatabasesContainers_specarmGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPECARM(generators)
	databaseAccountsSqlDatabasesContainers_specarmGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountsSqlDatabasesContainers_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPECARM(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPECARM(generators)
	databaseAccountsSqlDatabasesContainers_specarmGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountsSqlDatabasesContainers_SPECARM{}), generators)

	return databaseAccountsSqlDatabasesContainers_specarmGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPECARM(gens map[string]gopter.Gen) {
	gens["Properties"] = SqlContainerCreateUpdateProperties_SpecARMGenerator()
}

func Test_SqlContainerCreateUpdateProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlContainerCreateUpdateProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlContainerCreateUpdateProperties_SpecARM, SqlContainerCreateUpdateProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlContainerCreateUpdateProperties_SpecARM runs a test to see if a specific instance of SqlContainerCreateUpdateProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlContainerCreateUpdateProperties_SpecARM(subject SqlContainerCreateUpdateProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlContainerCreateUpdateProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlContainerCreateUpdateProperties_SpecARM instances for property testing - lazily instantiated by
//SqlContainerCreateUpdateProperties_SpecARMGenerator()
var sqlContainerCreateUpdateProperties_specARMGenerator gopter.Gen

// SqlContainerCreateUpdateProperties_SpecARMGenerator returns a generator of SqlContainerCreateUpdateProperties_SpecARM instances for property testing.
func SqlContainerCreateUpdateProperties_SpecARMGenerator() gopter.Gen {
	if sqlContainerCreateUpdateProperties_specARMGenerator != nil {
		return sqlContainerCreateUpdateProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSqlContainerCreateUpdateProperties_SpecARM(generators)
	sqlContainerCreateUpdateProperties_specARMGenerator = gen.Struct(reflect.TypeOf(SqlContainerCreateUpdateProperties_SpecARM{}), generators)

	return sqlContainerCreateUpdateProperties_specARMGenerator
}

// AddRelatedPropertyGeneratorsForSqlContainerCreateUpdateProperties_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlContainerCreateUpdateProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["Options"] = gen.PtrOf(CreateUpdateOptions_SpecARMGenerator())
	gens["Resource"] = SqlContainerResource_SpecARMGenerator()
}

func Test_SqlContainerResource_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlContainerResource_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlContainerResource_SpecARM, SqlContainerResource_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlContainerResource_SpecARM runs a test to see if a specific instance of SqlContainerResource_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlContainerResource_SpecARM(subject SqlContainerResource_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlContainerResource_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlContainerResource_SpecARM instances for property testing - lazily instantiated by
//SqlContainerResource_SpecARMGenerator()
var sqlContainerResource_specARMGenerator gopter.Gen

// SqlContainerResource_SpecARMGenerator returns a generator of SqlContainerResource_SpecARM instances for property testing.
// We first initialize sqlContainerResource_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SqlContainerResource_SpecARMGenerator() gopter.Gen {
	if sqlContainerResource_specARMGenerator != nil {
		return sqlContainerResource_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerResource_SpecARM(generators)
	sqlContainerResource_specARMGenerator = gen.Struct(reflect.TypeOf(SqlContainerResource_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerResource_SpecARM(generators)
	AddRelatedPropertyGeneratorsForSqlContainerResource_SpecARM(generators)
	sqlContainerResource_specARMGenerator = gen.Struct(reflect.TypeOf(SqlContainerResource_SpecARM{}), generators)

	return sqlContainerResource_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSqlContainerResource_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSqlContainerResource_SpecARM(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageTtl"] = gen.PtrOf(gen.Int())
	gens["DefaultTtl"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForSqlContainerResource_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlContainerResource_SpecARM(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPolicy"] = gen.PtrOf(ConflictResolutionPolicy_SpecARMGenerator())
	gens["IndexingPolicy"] = gen.PtrOf(IndexingPolicy_SpecARMGenerator())
	gens["PartitionKey"] = gen.PtrOf(ContainerPartitionKey_SpecARMGenerator())
	gens["UniqueKeyPolicy"] = gen.PtrOf(UniqueKeyPolicy_SpecARMGenerator())
}

func Test_ConflictResolutionPolicy_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConflictResolutionPolicy_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConflictResolutionPolicy_SpecARM, ConflictResolutionPolicy_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConflictResolutionPolicy_SpecARM runs a test to see if a specific instance of ConflictResolutionPolicy_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForConflictResolutionPolicy_SpecARM(subject ConflictResolutionPolicy_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConflictResolutionPolicy_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConflictResolutionPolicy_SpecARM instances for property testing - lazily instantiated by
//ConflictResolutionPolicy_SpecARMGenerator()
var conflictResolutionPolicy_specARMGenerator gopter.Gen

// ConflictResolutionPolicy_SpecARMGenerator returns a generator of ConflictResolutionPolicy_SpecARM instances for property testing.
func ConflictResolutionPolicy_SpecARMGenerator() gopter.Gen {
	if conflictResolutionPolicy_specARMGenerator != nil {
		return conflictResolutionPolicy_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConflictResolutionPolicy_SpecARM(generators)
	conflictResolutionPolicy_specARMGenerator = gen.Struct(reflect.TypeOf(ConflictResolutionPolicy_SpecARM{}), generators)

	return conflictResolutionPolicy_specARMGenerator
}

// AddIndependentPropertyGeneratorsForConflictResolutionPolicy_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConflictResolutionPolicy_SpecARM(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPath"] = gen.PtrOf(gen.AlphaString())
	gens["ConflictResolutionProcedure"] = gen.PtrOf(gen.AlphaString())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(ConflictResolutionPolicy_Mode_SpecCustom, ConflictResolutionPolicy_Mode_SpecLastWriterWins))
}

func Test_ContainerPartitionKey_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPartitionKey_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPartitionKey_SpecARM, ContainerPartitionKey_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPartitionKey_SpecARM runs a test to see if a specific instance of ContainerPartitionKey_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPartitionKey_SpecARM(subject ContainerPartitionKey_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPartitionKey_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPartitionKey_SpecARM instances for property testing - lazily instantiated by
//ContainerPartitionKey_SpecARMGenerator()
var containerPartitionKey_specARMGenerator gopter.Gen

// ContainerPartitionKey_SpecARMGenerator returns a generator of ContainerPartitionKey_SpecARM instances for property testing.
func ContainerPartitionKey_SpecARMGenerator() gopter.Gen {
	if containerPartitionKey_specARMGenerator != nil {
		return containerPartitionKey_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPartitionKey_SpecARM(generators)
	containerPartitionKey_specARMGenerator = gen.Struct(reflect.TypeOf(ContainerPartitionKey_SpecARM{}), generators)

	return containerPartitionKey_specARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerPartitionKey_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPartitionKey_SpecARM(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ContainerPartitionKey_Kind_SpecHash, ContainerPartitionKey_Kind_SpecMultiHash, ContainerPartitionKey_Kind_SpecRange))
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.Int())
}

func Test_IndexingPolicy_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IndexingPolicy_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexingPolicy_SpecARM, IndexingPolicy_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexingPolicy_SpecARM runs a test to see if a specific instance of IndexingPolicy_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexingPolicy_SpecARM(subject IndexingPolicy_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IndexingPolicy_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IndexingPolicy_SpecARM instances for property testing - lazily instantiated by
//IndexingPolicy_SpecARMGenerator()
var indexingPolicy_specARMGenerator gopter.Gen

// IndexingPolicy_SpecARMGenerator returns a generator of IndexingPolicy_SpecARM instances for property testing.
// We first initialize indexingPolicy_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IndexingPolicy_SpecARMGenerator() gopter.Gen {
	if indexingPolicy_specARMGenerator != nil {
		return indexingPolicy_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicy_SpecARM(generators)
	indexingPolicy_specARMGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicy_SpecARM(generators)
	AddRelatedPropertyGeneratorsForIndexingPolicy_SpecARM(generators)
	indexingPolicy_specARMGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_SpecARM{}), generators)

	return indexingPolicy_specARMGenerator
}

// AddIndependentPropertyGeneratorsForIndexingPolicy_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexingPolicy_SpecARM(gens map[string]gopter.Gen) {
	gens["Automatic"] = gen.PtrOf(gen.Bool())
	gens["IndexingMode"] = gen.PtrOf(gen.OneConstOf(IndexingPolicy_IndexingMode_SpecConsistent, IndexingPolicy_IndexingMode_SpecLazy, IndexingPolicy_IndexingMode_SpecNone))
}

// AddRelatedPropertyGeneratorsForIndexingPolicy_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIndexingPolicy_SpecARM(gens map[string]gopter.Gen) {
	gens["CompositeIndexes"] = gen.SliceOf(gen.SliceOf(CompositePath_SpecARMGenerator()))
	gens["ExcludedPaths"] = gen.SliceOf(ExcludedPath_SpecARMGenerator())
	gens["IncludedPaths"] = gen.SliceOf(IncludedPath_SpecARMGenerator())
	gens["SpatialIndexes"] = gen.SliceOf(SpatialSpec_SpecARMGenerator())
}

func Test_UniqueKeyPolicy_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKeyPolicy_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKeyPolicy_SpecARM, UniqueKeyPolicy_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKeyPolicy_SpecARM runs a test to see if a specific instance of UniqueKeyPolicy_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKeyPolicy_SpecARM(subject UniqueKeyPolicy_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKeyPolicy_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKeyPolicy_SpecARM instances for property testing - lazily instantiated by
//UniqueKeyPolicy_SpecARMGenerator()
var uniqueKeyPolicy_specARMGenerator gopter.Gen

// UniqueKeyPolicy_SpecARMGenerator returns a generator of UniqueKeyPolicy_SpecARM instances for property testing.
func UniqueKeyPolicy_SpecARMGenerator() gopter.Gen {
	if uniqueKeyPolicy_specARMGenerator != nil {
		return uniqueKeyPolicy_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForUniqueKeyPolicy_SpecARM(generators)
	uniqueKeyPolicy_specARMGenerator = gen.Struct(reflect.TypeOf(UniqueKeyPolicy_SpecARM{}), generators)

	return uniqueKeyPolicy_specARMGenerator
}

// AddRelatedPropertyGeneratorsForUniqueKeyPolicy_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUniqueKeyPolicy_SpecARM(gens map[string]gopter.Gen) {
	gens["UniqueKeys"] = gen.SliceOf(UniqueKey_SpecARMGenerator())
}

func Test_CompositePath_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CompositePath_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompositePath_SpecARM, CompositePath_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompositePath_SpecARM runs a test to see if a specific instance of CompositePath_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCompositePath_SpecARM(subject CompositePath_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CompositePath_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CompositePath_SpecARM instances for property testing - lazily instantiated by
//CompositePath_SpecARMGenerator()
var compositePath_specARMGenerator gopter.Gen

// CompositePath_SpecARMGenerator returns a generator of CompositePath_SpecARM instances for property testing.
func CompositePath_SpecARMGenerator() gopter.Gen {
	if compositePath_specARMGenerator != nil {
		return compositePath_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompositePath_SpecARM(generators)
	compositePath_specARMGenerator = gen.Struct(reflect.TypeOf(CompositePath_SpecARM{}), generators)

	return compositePath_specARMGenerator
}

// AddIndependentPropertyGeneratorsForCompositePath_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompositePath_SpecARM(gens map[string]gopter.Gen) {
	gens["Order"] = gen.PtrOf(gen.OneConstOf(CompositePath_Order_SpecAscending, CompositePath_Order_SpecDescending))
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExcludedPath_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExcludedPath_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExcludedPath_SpecARM, ExcludedPath_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExcludedPath_SpecARM runs a test to see if a specific instance of ExcludedPath_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExcludedPath_SpecARM(subject ExcludedPath_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExcludedPath_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExcludedPath_SpecARM instances for property testing - lazily instantiated by
//ExcludedPath_SpecARMGenerator()
var excludedPath_specARMGenerator gopter.Gen

// ExcludedPath_SpecARMGenerator returns a generator of ExcludedPath_SpecARM instances for property testing.
func ExcludedPath_SpecARMGenerator() gopter.Gen {
	if excludedPath_specARMGenerator != nil {
		return excludedPath_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExcludedPath_SpecARM(generators)
	excludedPath_specARMGenerator = gen.Struct(reflect.TypeOf(ExcludedPath_SpecARM{}), generators)

	return excludedPath_specARMGenerator
}

// AddIndependentPropertyGeneratorsForExcludedPath_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExcludedPath_SpecARM(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_IncludedPath_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IncludedPath_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIncludedPath_SpecARM, IncludedPath_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIncludedPath_SpecARM runs a test to see if a specific instance of IncludedPath_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIncludedPath_SpecARM(subject IncludedPath_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IncludedPath_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IncludedPath_SpecARM instances for property testing - lazily instantiated by
//IncludedPath_SpecARMGenerator()
var includedPath_specARMGenerator gopter.Gen

// IncludedPath_SpecARMGenerator returns a generator of IncludedPath_SpecARM instances for property testing.
// We first initialize includedPath_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IncludedPath_SpecARMGenerator() gopter.Gen {
	if includedPath_specARMGenerator != nil {
		return includedPath_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPath_SpecARM(generators)
	includedPath_specARMGenerator = gen.Struct(reflect.TypeOf(IncludedPath_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPath_SpecARM(generators)
	AddRelatedPropertyGeneratorsForIncludedPath_SpecARM(generators)
	includedPath_specARMGenerator = gen.Struct(reflect.TypeOf(IncludedPath_SpecARM{}), generators)

	return includedPath_specARMGenerator
}

// AddIndependentPropertyGeneratorsForIncludedPath_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIncludedPath_SpecARM(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIncludedPath_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIncludedPath_SpecARM(gens map[string]gopter.Gen) {
	gens["Indexes"] = gen.SliceOf(Indexes_SpecARMGenerator())
}

func Test_SpatialSpec_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SpatialSpec_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSpatialSpec_SpecARM, SpatialSpec_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSpatialSpec_SpecARM runs a test to see if a specific instance of SpatialSpec_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSpatialSpec_SpecARM(subject SpatialSpec_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SpatialSpec_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SpatialSpec_SpecARM instances for property testing - lazily instantiated by
//SpatialSpec_SpecARMGenerator()
var spatialSpec_specARMGenerator gopter.Gen

// SpatialSpec_SpecARMGenerator returns a generator of SpatialSpec_SpecARM instances for property testing.
func SpatialSpec_SpecARMGenerator() gopter.Gen {
	if spatialSpec_specARMGenerator != nil {
		return spatialSpec_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSpatialSpec_SpecARM(generators)
	spatialSpec_specARMGenerator = gen.Struct(reflect.TypeOf(SpatialSpec_SpecARM{}), generators)

	return spatialSpec_specARMGenerator
}

// AddIndependentPropertyGeneratorsForSpatialSpec_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSpatialSpec_SpecARM(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Types"] = gen.SliceOf(gen.OneConstOf(
		SpatialType_SpecLineString,
		SpatialType_SpecMultiPolygon,
		SpatialType_SpecPoint,
		SpatialType_SpecPolygon))
}

func Test_UniqueKey_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKey_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKey_SpecARM, UniqueKey_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKey_SpecARM runs a test to see if a specific instance of UniqueKey_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKey_SpecARM(subject UniqueKey_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKey_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKey_SpecARM instances for property testing - lazily instantiated by UniqueKey_SpecARMGenerator()
var uniqueKey_specARMGenerator gopter.Gen

// UniqueKey_SpecARMGenerator returns a generator of UniqueKey_SpecARM instances for property testing.
func UniqueKey_SpecARMGenerator() gopter.Gen {
	if uniqueKey_specARMGenerator != nil {
		return uniqueKey_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUniqueKey_SpecARM(generators)
	uniqueKey_specARMGenerator = gen.Struct(reflect.TypeOf(UniqueKey_SpecARM{}), generators)

	return uniqueKey_specARMGenerator
}

// AddIndependentPropertyGeneratorsForUniqueKey_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUniqueKey_SpecARM(gens map[string]gopter.Gen) {
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
}

func Test_Indexes_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Indexes_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexes_SpecARM, Indexes_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexes_SpecARM runs a test to see if a specific instance of Indexes_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexes_SpecARM(subject Indexes_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Indexes_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Indexes_SpecARM instances for property testing - lazily instantiated by Indexes_SpecARMGenerator()
var indexes_specARMGenerator gopter.Gen

// Indexes_SpecARMGenerator returns a generator of Indexes_SpecARM instances for property testing.
func Indexes_SpecARMGenerator() gopter.Gen {
	if indexes_specARMGenerator != nil {
		return indexes_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexes_SpecARM(generators)
	indexes_specARMGenerator = gen.Struct(reflect.TypeOf(Indexes_SpecARM{}), generators)

	return indexes_specARMGenerator
}

// AddIndependentPropertyGeneratorsForIndexes_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexes_SpecARM(gens map[string]gopter.Gen) {
	gens["DataType"] = gen.PtrOf(gen.OneConstOf(
		Indexes_DataType_SpecLineString,
		Indexes_DataType_SpecMultiPolygon,
		Indexes_DataType_SpecNumber,
		Indexes_DataType_SpecPoint,
		Indexes_DataType_SpecPolygon,
		Indexes_DataType_SpecString))
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(Indexes_Kind_SpecHash, Indexes_Kind_SpecRange, Indexes_Kind_SpecSpatial))
	gens["Precision"] = gen.PtrOf(gen.Int())
}
