// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DatabaseAccounts_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccounts_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountsSPECARM, DatabaseAccountsSPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountsSPECARM runs a test to see if a specific instance of DatabaseAccounts_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountsSPECARM(subject DatabaseAccounts_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccounts_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccounts_SPECARM instances for property testing - lazily instantiated by
//DatabaseAccountsSPECARMGenerator()
var databaseAccountsSPECARMGenerator gopter.Gen

// DatabaseAccountsSPECARMGenerator returns a generator of DatabaseAccounts_SPECARM instances for property testing.
// We first initialize databaseAccountsSPECARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountsSPECARMGenerator() gopter.Gen {
	if databaseAccountsSPECARMGenerator != nil {
		return databaseAccountsSPECARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsSPECARM(generators)
	databaseAccountsSPECARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccounts_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsSPECARM(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountsSPECARM(generators)
	databaseAccountsSPECARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccounts_SPECARM{}), generators)

	return databaseAccountsSPECARMGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountsSPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountsSPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(DatabaseAccountsSPECKindGlobalDocumentDB, DatabaseAccountsSPECKindMongoDB, DatabaseAccountsSPECKindParse))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountsSPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountsSPECARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentitySpecARMGenerator())
	gens["Properties"] = DatabaseAccountCreateUpdatePropertiesSpecARMGenerator()
}

func Test_DatabaseAccountCreateUpdateProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountCreateUpdateProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountCreateUpdatePropertiesSpecARM, DatabaseAccountCreateUpdatePropertiesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountCreateUpdatePropertiesSpecARM runs a test to see if a specific instance of DatabaseAccountCreateUpdateProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountCreateUpdatePropertiesSpecARM(subject DatabaseAccountCreateUpdateProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountCreateUpdateProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountCreateUpdateProperties_SpecARM instances for property testing - lazily instantiated by
//DatabaseAccountCreateUpdatePropertiesSpecARMGenerator()
var databaseAccountCreateUpdatePropertiesSpecARMGenerator gopter.Gen

// DatabaseAccountCreateUpdatePropertiesSpecARMGenerator returns a generator of DatabaseAccountCreateUpdateProperties_SpecARM instances for property testing.
// We first initialize databaseAccountCreateUpdatePropertiesSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountCreateUpdatePropertiesSpecARMGenerator() gopter.Gen {
	if databaseAccountCreateUpdatePropertiesSpecARMGenerator != nil {
		return databaseAccountCreateUpdatePropertiesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdatePropertiesSpecARM(generators)
	databaseAccountCreateUpdatePropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountCreateUpdateProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdatePropertiesSpecARM(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountCreateUpdatePropertiesSpecARM(generators)
	databaseAccountCreateUpdatePropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountCreateUpdateProperties_SpecARM{}), generators)

	return databaseAccountCreateUpdatePropertiesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdatePropertiesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdatePropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["ConnectorOffer"] = gen.PtrOf(gen.OneConstOf(ConnectorOffer_SpecSmall))
	gens["DatabaseAccountOfferType"] = gen.OneConstOf(DatabaseAccountOfferType_SpecStandard)
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.OneConstOf(NetworkAclBypass_SpecAzureServices, NetworkAclBypass_SpecNone))
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccess_SpecDisabled, PublicNetworkAccess_SpecEnabled))
}

// AddRelatedPropertyGeneratorsForDatabaseAccountCreateUpdatePropertiesSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountCreateUpdatePropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfigurationSpecARMGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiPropertiesSpecARMGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicySpecARMGenerator())
	gens["Capabilities"] = gen.SliceOf(CapabilitySpecARMGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicySpecARMGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicySpecARMGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRangeSpecARMGenerator())
	gens["Locations"] = gen.SliceOf(LocationSpecARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleSpecARMGenerator())
}

func Test_ManagedServiceIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentitySpecARM, ManagedServiceIdentitySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentitySpecARM runs a test to see if a specific instance of ManagedServiceIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentitySpecARM(subject ManagedServiceIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_SpecARM instances for property testing - lazily instantiated by
//ManagedServiceIdentitySpecARMGenerator()
var managedServiceIdentitySpecARMGenerator gopter.Gen

// ManagedServiceIdentitySpecARMGenerator returns a generator of ManagedServiceIdentity_SpecARM instances for property testing.
func ManagedServiceIdentitySpecARMGenerator() gopter.Gen {
	if managedServiceIdentitySpecARMGenerator != nil {
		return managedServiceIdentitySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentitySpecARM(generators)
	managedServiceIdentitySpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_SpecARM{}), generators)

	return managedServiceIdentitySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentitySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentitySpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentitySpecTypeNone,
		ManagedServiceIdentitySpecTypeSystemAssigned,
		ManagedServiceIdentitySpecTypeSystemAssignedUserAssigned,
		ManagedServiceIdentitySpecTypeUserAssigned))
}

func Test_AnalyticalStorageConfiguration_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfigurationSpecARM, AnalyticalStorageConfigurationSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfigurationSpecARM runs a test to see if a specific instance of AnalyticalStorageConfiguration_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfigurationSpecARM(subject AnalyticalStorageConfiguration_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration_SpecARM instances for property testing - lazily instantiated by
//AnalyticalStorageConfigurationSpecARMGenerator()
var analyticalStorageConfigurationSpecARMGenerator gopter.Gen

// AnalyticalStorageConfigurationSpecARMGenerator returns a generator of AnalyticalStorageConfiguration_SpecARM instances for property testing.
func AnalyticalStorageConfigurationSpecARMGenerator() gopter.Gen {
	if analyticalStorageConfigurationSpecARMGenerator != nil {
		return analyticalStorageConfigurationSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationSpecARM(generators)
	analyticalStorageConfigurationSpecARMGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration_SpecARM{}), generators)

	return analyticalStorageConfigurationSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationSpecARM(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.OneConstOf(AnalyticalStorageSchemaType_SpecFullFidelity, AnalyticalStorageSchemaType_SpecWellDefined))
}

func Test_ApiProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiPropertiesSpecARM, ApiPropertiesSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiPropertiesSpecARM runs a test to see if a specific instance of ApiProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiPropertiesSpecARM(subject ApiProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_SpecARM instances for property testing - lazily instantiated by
//ApiPropertiesSpecARMGenerator()
var apiPropertiesSpecARMGenerator gopter.Gen

// ApiPropertiesSpecARMGenerator returns a generator of ApiProperties_SpecARM instances for property testing.
func ApiPropertiesSpecARMGenerator() gopter.Gen {
	if apiPropertiesSpecARMGenerator != nil {
		return apiPropertiesSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiPropertiesSpecARM(generators)
	apiPropertiesSpecARMGenerator = gen.Struct(reflect.TypeOf(ApiProperties_SpecARM{}), generators)

	return apiPropertiesSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForApiPropertiesSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiPropertiesSpecARM(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.OneConstOf(ApiPropertiesSpecServerVersion32, ApiPropertiesSpecServerVersion36, ApiPropertiesSpecServerVersion40))
}

func Test_BackupPolicy_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicySpecARM, BackupPolicySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicySpecARM runs a test to see if a specific instance of BackupPolicy_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicySpecARM(subject BackupPolicy_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_SpecARM instances for property testing - lazily instantiated by
//BackupPolicySpecARMGenerator()
var backupPolicySpecARMGenerator gopter.Gen

// BackupPolicySpecARMGenerator returns a generator of BackupPolicy_SpecARM instances for property testing.
func BackupPolicySpecARMGenerator() gopter.Gen {
	if backupPolicySpecARMGenerator != nil {
		return backupPolicySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicySpecARM(generators)
	backupPolicySpecARMGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_SpecARM{}), generators)

	return backupPolicySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicySpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(BackupPolicyType_SpecContinuous, BackupPolicyType_SpecPeriodic)
}

func Test_Capability_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapabilitySpecARM, CapabilitySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapabilitySpecARM runs a test to see if a specific instance of Capability_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCapabilitySpecARM(subject Capability_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability_SpecARM instances for property testing - lazily instantiated by CapabilitySpecARMGenerator()
var capabilitySpecARMGenerator gopter.Gen

// CapabilitySpecARMGenerator returns a generator of Capability_SpecARM instances for property testing.
func CapabilitySpecARMGenerator() gopter.Gen {
	if capabilitySpecARMGenerator != nil {
		return capabilitySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapabilitySpecARM(generators)
	capabilitySpecARMGenerator = gen.Struct(reflect.TypeOf(Capability_SpecARM{}), generators)

	return capabilitySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForCapabilitySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapabilitySpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ConsistencyPolicy_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicySpecARM, ConsistencyPolicySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicySpecARM runs a test to see if a specific instance of ConsistencyPolicy_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicySpecARM(subject ConsistencyPolicy_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy_SpecARM instances for property testing - lazily instantiated by
//ConsistencyPolicySpecARMGenerator()
var consistencyPolicySpecARMGenerator gopter.Gen

// ConsistencyPolicySpecARMGenerator returns a generator of ConsistencyPolicy_SpecARM instances for property testing.
func ConsistencyPolicySpecARMGenerator() gopter.Gen {
	if consistencyPolicySpecARMGenerator != nil {
		return consistencyPolicySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicySpecARM(generators)
	consistencyPolicySpecARMGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy_SpecARM{}), generators)

	return consistencyPolicySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicySpecARM(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.OneConstOf(
		ConsistencyPolicySpecDefaultConsistencyLevelBoundedStaleness,
		ConsistencyPolicySpecDefaultConsistencyLevelConsistentPrefix,
		ConsistencyPolicySpecDefaultConsistencyLevelEventual,
		ConsistencyPolicySpecDefaultConsistencyLevelSession,
		ConsistencyPolicySpecDefaultConsistencyLevelStrong)
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicySpecARM, CorsPolicySpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicySpecARM runs a test to see if a specific instance of CorsPolicy_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicySpecARM(subject CorsPolicy_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_SpecARM instances for property testing - lazily instantiated by CorsPolicySpecARMGenerator()
var corsPolicySpecARMGenerator gopter.Gen

// CorsPolicySpecARMGenerator returns a generator of CorsPolicy_SpecARM instances for property testing.
func CorsPolicySpecARMGenerator() gopter.Gen {
	if corsPolicySpecARMGenerator != nil {
		return corsPolicySpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicySpecARM(generators)
	corsPolicySpecARMGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_SpecARM{}), generators)

	return corsPolicySpecARMGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicySpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicySpecARM(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.AlphaString()
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_IpAddressOrRange_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRangeSpecARM, IpAddressOrRangeSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRangeSpecARM runs a test to see if a specific instance of IpAddressOrRange_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRangeSpecARM(subject IpAddressOrRange_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange_SpecARM instances for property testing - lazily instantiated by
//IpAddressOrRangeSpecARMGenerator()
var ipAddressOrRangeSpecARMGenerator gopter.Gen

// IpAddressOrRangeSpecARMGenerator returns a generator of IpAddressOrRange_SpecARM instances for property testing.
func IpAddressOrRangeSpecARMGenerator() gopter.Gen {
	if ipAddressOrRangeSpecARMGenerator != nil {
		return ipAddressOrRangeSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRangeSpecARM(generators)
	ipAddressOrRangeSpecARMGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange_SpecARM{}), generators)

	return ipAddressOrRangeSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRangeSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRangeSpecARM(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocationSpecARM, LocationSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocationSpecARM runs a test to see if a specific instance of Location_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLocationSpecARM(subject Location_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location_SpecARM instances for property testing - lazily instantiated by LocationSpecARMGenerator()
var locationSpecARMGenerator gopter.Gen

// LocationSpecARMGenerator returns a generator of Location_SpecARM instances for property testing.
func LocationSpecARMGenerator() gopter.Gen {
	if locationSpecARMGenerator != nil {
		return locationSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocationSpecARM(generators)
	locationSpecARMGenerator = gen.Struct(reflect.TypeOf(Location_SpecARM{}), generators)

	return locationSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForLocationSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocationSpecARM(gens map[string]gopter.Gen) {
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleSpecARM, VirtualNetworkRuleSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleSpecARM runs a test to see if a specific instance of VirtualNetworkRule_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleSpecARM(subject VirtualNetworkRule_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_SpecARM instances for property testing - lazily instantiated by
//VirtualNetworkRuleSpecARMGenerator()
var virtualNetworkRuleSpecARMGenerator gopter.Gen

// VirtualNetworkRuleSpecARMGenerator returns a generator of VirtualNetworkRule_SpecARM instances for property testing.
func VirtualNetworkRuleSpecARMGenerator() gopter.Gen {
	if virtualNetworkRuleSpecARMGenerator != nil {
		return virtualNetworkRuleSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpecARM(generators)
	virtualNetworkRuleSpecARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_SpecARM{}), generators)

	return virtualNetworkRuleSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}
