// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DatabaseAccounts_SPECARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccounts_SPECARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccounts_SPECARM, DatabaseAccounts_SPECARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccounts_SPECARM runs a test to see if a specific instance of DatabaseAccounts_SPECARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccounts_SPECARM(subject DatabaseAccounts_SPECARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccounts_SPECARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccounts_SPECARM instances for property testing - lazily instantiated by
//DatabaseAccounts_SPECARMGenerator()
var databaseAccounts_specarmGenerator gopter.Gen

// DatabaseAccounts_SPECARMGenerator returns a generator of DatabaseAccounts_SPECARM instances for property testing.
// We first initialize databaseAccounts_specarmGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccounts_SPECARMGenerator() gopter.Gen {
	if databaseAccounts_specarmGenerator != nil {
		return databaseAccounts_specarmGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccounts_SPECARM(generators)
	databaseAccounts_specarmGenerator = gen.Struct(reflect.TypeOf(DatabaseAccounts_SPECARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccounts_SPECARM(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccounts_SPECARM(generators)
	databaseAccounts_specarmGenerator = gen.Struct(reflect.TypeOf(DatabaseAccounts_SPECARM{}), generators)

	return databaseAccounts_specarmGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccounts_SPECARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccounts_SPECARM(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(DatabaseAccounts_Kind_SPECGlobalDocumentDB, DatabaseAccounts_Kind_SPECMongoDB, DatabaseAccounts_Kind_SPECParse))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccounts_SPECARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccounts_SPECARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_SpecARMGenerator())
	gens["Properties"] = DatabaseAccountProperties_SpecARMGenerator()
}

func Test_DatabaseAccountProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountProperties_SpecARM, DatabaseAccountProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountProperties_SpecARM runs a test to see if a specific instance of DatabaseAccountProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountProperties_SpecARM(subject DatabaseAccountProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountProperties_SpecARM instances for property testing - lazily instantiated by
//DatabaseAccountProperties_SpecARMGenerator()
var databaseAccountProperties_specARMGenerator gopter.Gen

// DatabaseAccountProperties_SpecARMGenerator returns a generator of DatabaseAccountProperties_SpecARM instances for property testing.
// We first initialize databaseAccountProperties_specARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountProperties_SpecARMGenerator() gopter.Gen {
	if databaseAccountProperties_specARMGenerator != nil {
		return databaseAccountProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountProperties_SpecARM(generators)
	databaseAccountProperties_specARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountProperties_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountProperties_SpecARM(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountProperties_SpecARM(generators)
	databaseAccountProperties_specARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountProperties_SpecARM{}), generators)

	return databaseAccountProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["ConnectorOffer"] = gen.PtrOf(gen.OneConstOf(ConnectorOffer_SpecSmall))
	gens["DatabaseAccountOfferType"] = gen.OneConstOf(DatabaseAccountOfferType_SpecStandard)
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.OneConstOf(NetworkAclBypass_SpecAzureServices, NetworkAclBypass_SpecNone))
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccess_SpecDisabled, PublicNetworkAccess_SpecEnabled))
}

// AddRelatedPropertyGeneratorsForDatabaseAccountProperties_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfiguration_SpecARMGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiProperties_SpecARMGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicy_SpecARMGenerator())
	gens["Capabilities"] = gen.SliceOf(Capability_SpecARMGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicy_SpecARMGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicy_SpecARMGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRange_SpecARMGenerator())
	gens["Locations"] = gen.SliceOf(Location_SpecARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_SpecARMGenerator())
}

func Test_ManagedServiceIdentity_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_SpecARM, ManagedServiceIdentity_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_SpecARM runs a test to see if a specific instance of ManagedServiceIdentity_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_SpecARM(subject ManagedServiceIdentity_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_SpecARM instances for property testing - lazily instantiated by
//ManagedServiceIdentity_SpecARMGenerator()
var managedServiceIdentity_specARMGenerator gopter.Gen

// ManagedServiceIdentity_SpecARMGenerator returns a generator of ManagedServiceIdentity_SpecARM instances for property testing.
func ManagedServiceIdentity_SpecARMGenerator() gopter.Gen {
	if managedServiceIdentity_specARMGenerator != nil {
		return managedServiceIdentity_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_SpecARM(generators)
	managedServiceIdentity_specARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_SpecARM{}), generators)

	return managedServiceIdentity_specARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_SpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentity_Type_SpecNone,
		ManagedServiceIdentity_Type_SpecSystemAssigned,
		ManagedServiceIdentity_Type_SpecSystemAssignedUserAssigned,
		ManagedServiceIdentity_Type_SpecUserAssigned))
}

func Test_AnalyticalStorageConfiguration_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfiguration_SpecARM, AnalyticalStorageConfiguration_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfiguration_SpecARM runs a test to see if a specific instance of AnalyticalStorageConfiguration_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfiguration_SpecARM(subject AnalyticalStorageConfiguration_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration_SpecARM instances for property testing - lazily instantiated by
//AnalyticalStorageConfiguration_SpecARMGenerator()
var analyticalStorageConfiguration_specARMGenerator gopter.Gen

// AnalyticalStorageConfiguration_SpecARMGenerator returns a generator of AnalyticalStorageConfiguration_SpecARM instances for property testing.
func AnalyticalStorageConfiguration_SpecARMGenerator() gopter.Gen {
	if analyticalStorageConfiguration_specARMGenerator != nil {
		return analyticalStorageConfiguration_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_SpecARM(generators)
	analyticalStorageConfiguration_specARMGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration_SpecARM{}), generators)

	return analyticalStorageConfiguration_specARMGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_SpecARM(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.OneConstOf(AnalyticalStorageSchemaType_SpecFullFidelity, AnalyticalStorageSchemaType_SpecWellDefined))
}

func Test_ApiProperties_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProperties_SpecARM, ApiProperties_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProperties_SpecARM runs a test to see if a specific instance of ApiProperties_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProperties_SpecARM(subject ApiProperties_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_SpecARM instances for property testing - lazily instantiated by
//ApiProperties_SpecARMGenerator()
var apiProperties_specARMGenerator gopter.Gen

// ApiProperties_SpecARMGenerator returns a generator of ApiProperties_SpecARM instances for property testing.
func ApiProperties_SpecARMGenerator() gopter.Gen {
	if apiProperties_specARMGenerator != nil {
		return apiProperties_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProperties_SpecARM(generators)
	apiProperties_specARMGenerator = gen.Struct(reflect.TypeOf(ApiProperties_SpecARM{}), generators)

	return apiProperties_specARMGenerator
}

// AddIndependentPropertyGeneratorsForApiProperties_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProperties_SpecARM(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.OneConstOf(ApiProperties_ServerVersion_Spec32, ApiProperties_ServerVersion_Spec36, ApiProperties_ServerVersion_Spec40))
}

func Test_BackupPolicy_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicy_SpecARM, BackupPolicy_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicy_SpecARM runs a test to see if a specific instance of BackupPolicy_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicy_SpecARM(subject BackupPolicy_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_SpecARM instances for property testing - lazily instantiated by
//BackupPolicy_SpecARMGenerator()
var backupPolicy_specARMGenerator gopter.Gen

// BackupPolicy_SpecARMGenerator returns a generator of BackupPolicy_SpecARM instances for property testing.
func BackupPolicy_SpecARMGenerator() gopter.Gen {
	if backupPolicy_specARMGenerator != nil {
		return backupPolicy_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicy_SpecARM(generators)
	backupPolicy_specARMGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_SpecARM{}), generators)

	return backupPolicy_specARMGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicy_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicy_SpecARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(BackupPolicyType_SpecContinuous, BackupPolicyType_SpecPeriodic)
}

func Test_Capability_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapability_SpecARM, Capability_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapability_SpecARM runs a test to see if a specific instance of Capability_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCapability_SpecARM(subject Capability_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability_SpecARM instances for property testing - lazily instantiated by Capability_SpecARMGenerator()
var capability_specARMGenerator gopter.Gen

// Capability_SpecARMGenerator returns a generator of Capability_SpecARM instances for property testing.
func Capability_SpecARMGenerator() gopter.Gen {
	if capability_specARMGenerator != nil {
		return capability_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapability_SpecARM(generators)
	capability_specARMGenerator = gen.Struct(reflect.TypeOf(Capability_SpecARM{}), generators)

	return capability_specARMGenerator
}

// AddIndependentPropertyGeneratorsForCapability_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapability_SpecARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ConsistencyPolicy_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicy_SpecARM, ConsistencyPolicy_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicy_SpecARM runs a test to see if a specific instance of ConsistencyPolicy_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicy_SpecARM(subject ConsistencyPolicy_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy_SpecARM instances for property testing - lazily instantiated by
//ConsistencyPolicy_SpecARMGenerator()
var consistencyPolicy_specARMGenerator gopter.Gen

// ConsistencyPolicy_SpecARMGenerator returns a generator of ConsistencyPolicy_SpecARM instances for property testing.
func ConsistencyPolicy_SpecARMGenerator() gopter.Gen {
	if consistencyPolicy_specARMGenerator != nil {
		return consistencyPolicy_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicy_SpecARM(generators)
	consistencyPolicy_specARMGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy_SpecARM{}), generators)

	return consistencyPolicy_specARMGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicy_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicy_SpecARM(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.OneConstOf(
		ConsistencyPolicy_DefaultConsistencyLevel_SpecBoundedStaleness,
		ConsistencyPolicy_DefaultConsistencyLevel_SpecConsistentPrefix,
		ConsistencyPolicy_DefaultConsistencyLevel_SpecEventual,
		ConsistencyPolicy_DefaultConsistencyLevel_SpecSession,
		ConsistencyPolicy_DefaultConsistencyLevel_SpecStrong)
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicy_SpecARM, CorsPolicy_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicy_SpecARM runs a test to see if a specific instance of CorsPolicy_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicy_SpecARM(subject CorsPolicy_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_SpecARM instances for property testing - lazily instantiated by CorsPolicy_SpecARMGenerator()
var corsPolicy_specARMGenerator gopter.Gen

// CorsPolicy_SpecARMGenerator returns a generator of CorsPolicy_SpecARM instances for property testing.
func CorsPolicy_SpecARMGenerator() gopter.Gen {
	if corsPolicy_specARMGenerator != nil {
		return corsPolicy_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicy_SpecARM(generators)
	corsPolicy_specARMGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_SpecARM{}), generators)

	return corsPolicy_specARMGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicy_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicy_SpecARM(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.AlphaString()
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_IpAddressOrRange_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRange_SpecARM, IpAddressOrRange_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRange_SpecARM runs a test to see if a specific instance of IpAddressOrRange_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRange_SpecARM(subject IpAddressOrRange_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange_SpecARM instances for property testing - lazily instantiated by
//IpAddressOrRange_SpecARMGenerator()
var ipAddressOrRange_specARMGenerator gopter.Gen

// IpAddressOrRange_SpecARMGenerator returns a generator of IpAddressOrRange_SpecARM instances for property testing.
func IpAddressOrRange_SpecARMGenerator() gopter.Gen {
	if ipAddressOrRange_specARMGenerator != nil {
		return ipAddressOrRange_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRange_SpecARM(generators)
	ipAddressOrRange_specARMGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange_SpecARM{}), generators)

	return ipAddressOrRange_specARMGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRange_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRange_SpecARM(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocation_SpecARM, Location_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocation_SpecARM runs a test to see if a specific instance of Location_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLocation_SpecARM(subject Location_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location_SpecARM instances for property testing - lazily instantiated by Location_SpecARMGenerator()
var location_specARMGenerator gopter.Gen

// Location_SpecARMGenerator returns a generator of Location_SpecARM instances for property testing.
func Location_SpecARMGenerator() gopter.Gen {
	if location_specARMGenerator != nil {
		return location_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocation_SpecARM(generators)
	location_specARMGenerator = gen.Struct(reflect.TypeOf(Location_SpecARM{}), generators)

	return location_specARMGenerator
}

// AddIndependentPropertyGeneratorsForLocation_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocation_SpecARM(gens map[string]gopter.Gen) {
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_SpecARM, VirtualNetworkRule_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_SpecARM runs a test to see if a specific instance of VirtualNetworkRule_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_SpecARM(subject VirtualNetworkRule_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_SpecARM instances for property testing - lazily instantiated by
//VirtualNetworkRule_SpecARMGenerator()
var virtualNetworkRule_specARMGenerator gopter.Gen

// VirtualNetworkRule_SpecARMGenerator returns a generator of VirtualNetworkRule_SpecARM instances for property testing.
func VirtualNetworkRule_SpecARMGenerator() gopter.Gen {
	if virtualNetworkRule_specARMGenerator != nil {
		return virtualNetworkRule_specARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_SpecARM(generators)
	virtualNetworkRule_specARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_SpecARM{}), generators)

	return virtualNetworkRule_specARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_SpecARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}
