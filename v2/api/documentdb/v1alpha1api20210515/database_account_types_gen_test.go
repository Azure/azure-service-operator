// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/documentdb/v1alpha1api20210515storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DatabaseAccount_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccount to hub returns original",
		prop.ForAll(RunResourceConversionTestForDatabaseAccount, DatabaseAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForDatabaseAccount tests if a specific instance of DatabaseAccount round trips to the hub storage version and back losslessly
func RunResourceConversionTestForDatabaseAccount(subject DatabaseAccount) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20210515storage.DatabaseAccount
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual DatabaseAccount
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccount_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccount to DatabaseAccount via AssignPropertiesToDatabaseAccount & AssignPropertiesFromDatabaseAccount returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatabaseAccount, DatabaseAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatabaseAccount tests if a specific instance of DatabaseAccount can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForDatabaseAccount(subject DatabaseAccount) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.DatabaseAccount
	err := copied.AssignPropertiesToDatabaseAccount(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatabaseAccount
	err = actual.AssignPropertiesFromDatabaseAccount(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccount, DatabaseAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccount runs a test to see if a specific instance of DatabaseAccount round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccount(subject DatabaseAccount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccount instances for property testing - lazily instantiated by DatabaseAccountGenerator()
var databaseAccountGenerator gopter.Gen

// DatabaseAccountGenerator returns a generator of DatabaseAccount instances for property testing.
func DatabaseAccountGenerator() gopter.Gen {
	if databaseAccountGenerator != nil {
		return databaseAccountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDatabaseAccount(generators)
	databaseAccountGenerator = gen.Struct(reflect.TypeOf(DatabaseAccount{}), generators)

	return databaseAccountGenerator
}

// AddRelatedPropertyGeneratorsForDatabaseAccount is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccount(gens map[string]gopter.Gen) {
	gens["Spec"] = DatabaseAccounts_SPECGenerator()
	gens["Status"] = DatabaseAccount_StatusGenerator()
}

func Test_DatabaseAccount_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccount_Status to DatabaseAccount_Status via AssignPropertiesToDatabaseAccount_Status & AssignPropertiesFromDatabaseAccount_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatabaseAccount_Status, DatabaseAccount_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatabaseAccount_Status tests if a specific instance of DatabaseAccount_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForDatabaseAccount_Status(subject DatabaseAccount_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.DatabaseAccount_Status
	err := copied.AssignPropertiesToDatabaseAccount_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatabaseAccount_Status
	err = actual.AssignPropertiesFromDatabaseAccount_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccount_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccount_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccount_Status, DatabaseAccount_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccount_Status runs a test to see if a specific instance of DatabaseAccount_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccount_Status(subject DatabaseAccount_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccount_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccount_Status instances for property testing - lazily instantiated by
//DatabaseAccount_StatusGenerator()
var databaseAccount_statusGenerator gopter.Gen

// DatabaseAccount_StatusGenerator returns a generator of DatabaseAccount_Status instances for property testing.
// We first initialize databaseAccount_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccount_StatusGenerator() gopter.Gen {
	if databaseAccount_statusGenerator != nil {
		return databaseAccount_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccount_Status(generators)
	databaseAccount_statusGenerator = gen.Struct(reflect.TypeOf(DatabaseAccount_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccount_Status(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccount_Status(generators)
	databaseAccount_statusGenerator = gen.Struct(reflect.TypeOf(DatabaseAccount_Status{}), generators)

	return databaseAccount_statusGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccount_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccount_Status(gens map[string]gopter.Gen) {
	gens["ConnectorOffer"] = gen.PtrOf(gen.OneConstOf(ConnectorOffer_StatusSmall))
	gens["DatabaseAccountOfferType"] = gen.PtrOf(gen.OneConstOf(DatabaseAccountOfferType_StatusStandard))
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(DatabaseAccount_Kind_StatusGlobalDocumentDB, DatabaseAccount_Kind_StatusMongoDB, DatabaseAccount_Kind_StatusParse))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.OneConstOf(NetworkAclBypass_StatusAzureServices, NetworkAclBypass_StatusNone))
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccess_StatusDisabled, PublicNetworkAccess_StatusEnabled))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccount_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccount_Status(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfiguration_StatusGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiProperties_StatusGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicy_StatusGenerator())
	gens["Capabilities"] = gen.SliceOf(Capability_StatusGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicy_StatusGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicy_StatusGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_StatusGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRange_StatusGenerator())
	gens["Locations"] = gen.SliceOf(Location_StatusGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_StatusGenerator())
}

func Test_DatabaseAccounts_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccounts_SPEC to DatabaseAccounts_SPEC via AssignPropertiesToDatabaseAccounts_SPEC & AssignPropertiesFromDatabaseAccounts_SPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatabaseAccounts_SPEC, DatabaseAccounts_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatabaseAccounts_SPEC tests if a specific instance of DatabaseAccounts_SPEC can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForDatabaseAccounts_SPEC(subject DatabaseAccounts_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.DatabaseAccounts_SPEC
	err := copied.AssignPropertiesToDatabaseAccounts_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatabaseAccounts_SPEC
	err = actual.AssignPropertiesFromDatabaseAccounts_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccounts_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccounts_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccounts_SPEC, DatabaseAccounts_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccounts_SPEC runs a test to see if a specific instance of DatabaseAccounts_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccounts_SPEC(subject DatabaseAccounts_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccounts_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccounts_SPEC instances for property testing - lazily instantiated by
//DatabaseAccounts_SPECGenerator()
var databaseAccounts_specGenerator gopter.Gen

// DatabaseAccounts_SPECGenerator returns a generator of DatabaseAccounts_SPEC instances for property testing.
// We first initialize databaseAccounts_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccounts_SPECGenerator() gopter.Gen {
	if databaseAccounts_specGenerator != nil {
		return databaseAccounts_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccounts_SPEC(generators)
	databaseAccounts_specGenerator = gen.Struct(reflect.TypeOf(DatabaseAccounts_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccounts_SPEC(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccounts_SPEC(generators)
	databaseAccounts_specGenerator = gen.Struct(reflect.TypeOf(DatabaseAccounts_SPEC{}), generators)

	return databaseAccounts_specGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccounts_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccounts_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["ConnectorOffer"] = gen.PtrOf(gen.OneConstOf(ConnectorOffer_SpecSmall))
	gens["DatabaseAccountOfferType"] = gen.OneConstOf(DatabaseAccountOfferType_SpecStandard)
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(DatabaseAccounts_Kind_SPECGlobalDocumentDB, DatabaseAccounts_Kind_SPECMongoDB, DatabaseAccounts_Kind_SPECParse))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.OneConstOf(NetworkAclBypass_SpecAzureServices, NetworkAclBypass_SpecNone))
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccess_SpecDisabled, PublicNetworkAccess_SpecEnabled))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccounts_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccounts_SPEC(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfiguration_SpecGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiProperties_SpecGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicy_SpecGenerator())
	gens["Capabilities"] = gen.SliceOf(Capability_SpecGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicy_SpecGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicy_SpecGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_SpecGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRange_SpecGenerator())
	gens["Locations"] = gen.SliceOf(Location_SpecGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_SpecGenerator())
}

func Test_AnalyticalStorageConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AnalyticalStorageConfiguration_Spec to AnalyticalStorageConfiguration_Spec via AssignPropertiesToAnalyticalStorageConfiguration_Spec & AssignPropertiesFromAnalyticalStorageConfiguration_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAnalyticalStorageConfiguration_Spec, AnalyticalStorageConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAnalyticalStorageConfiguration_Spec tests if a specific instance of AnalyticalStorageConfiguration_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForAnalyticalStorageConfiguration_Spec(subject AnalyticalStorageConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.AnalyticalStorageConfiguration_Spec
	err := copied.AssignPropertiesToAnalyticalStorageConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AnalyticalStorageConfiguration_Spec
	err = actual.AssignPropertiesFromAnalyticalStorageConfiguration_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AnalyticalStorageConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfiguration_Spec, AnalyticalStorageConfiguration_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfiguration_Spec runs a test to see if a specific instance of AnalyticalStorageConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfiguration_Spec(subject AnalyticalStorageConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration_Spec instances for property testing - lazily instantiated by
//AnalyticalStorageConfiguration_SpecGenerator()
var analyticalStorageConfiguration_specGenerator gopter.Gen

// AnalyticalStorageConfiguration_SpecGenerator returns a generator of AnalyticalStorageConfiguration_Spec instances for property testing.
func AnalyticalStorageConfiguration_SpecGenerator() gopter.Gen {
	if analyticalStorageConfiguration_specGenerator != nil {
		return analyticalStorageConfiguration_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Spec(generators)
	analyticalStorageConfiguration_specGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration_Spec{}), generators)

	return analyticalStorageConfiguration_specGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Spec(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.OneConstOf(AnalyticalStorageSchemaType_SpecFullFidelity, AnalyticalStorageSchemaType_SpecWellDefined))
}

func Test_AnalyticalStorageConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AnalyticalStorageConfiguration_Status to AnalyticalStorageConfiguration_Status via AssignPropertiesToAnalyticalStorageConfiguration_Status & AssignPropertiesFromAnalyticalStorageConfiguration_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAnalyticalStorageConfiguration_Status, AnalyticalStorageConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAnalyticalStorageConfiguration_Status tests if a specific instance of AnalyticalStorageConfiguration_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForAnalyticalStorageConfiguration_Status(subject AnalyticalStorageConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.AnalyticalStorageConfiguration_Status
	err := copied.AssignPropertiesToAnalyticalStorageConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AnalyticalStorageConfiguration_Status
	err = actual.AssignPropertiesFromAnalyticalStorageConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AnalyticalStorageConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfiguration_Status, AnalyticalStorageConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfiguration_Status runs a test to see if a specific instance of AnalyticalStorageConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfiguration_Status(subject AnalyticalStorageConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration_Status instances for property testing - lazily instantiated by
//AnalyticalStorageConfiguration_StatusGenerator()
var analyticalStorageConfiguration_statusGenerator gopter.Gen

// AnalyticalStorageConfiguration_StatusGenerator returns a generator of AnalyticalStorageConfiguration_Status instances for property testing.
func AnalyticalStorageConfiguration_StatusGenerator() gopter.Gen {
	if analyticalStorageConfiguration_statusGenerator != nil {
		return analyticalStorageConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Status(generators)
	analyticalStorageConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration_Status{}), generators)

	return analyticalStorageConfiguration_statusGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Status(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.OneConstOf(AnalyticalStorageSchemaType_StatusFullFidelity, AnalyticalStorageSchemaType_StatusWellDefined))
}

func Test_ApiProperties_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiProperties_Spec to ApiProperties_Spec via AssignPropertiesToApiProperties_Spec & AssignPropertiesFromApiProperties_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiProperties_Spec, ApiProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiProperties_Spec tests if a specific instance of ApiProperties_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForApiProperties_Spec(subject ApiProperties_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ApiProperties_Spec
	err := copied.AssignPropertiesToApiProperties_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiProperties_Spec
	err = actual.AssignPropertiesFromApiProperties_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProperties_Spec, ApiProperties_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProperties_Spec runs a test to see if a specific instance of ApiProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProperties_Spec(subject ApiProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_Spec instances for property testing - lazily instantiated by ApiProperties_SpecGenerator()
var apiProperties_specGenerator gopter.Gen

// ApiProperties_SpecGenerator returns a generator of ApiProperties_Spec instances for property testing.
func ApiProperties_SpecGenerator() gopter.Gen {
	if apiProperties_specGenerator != nil {
		return apiProperties_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProperties_Spec(generators)
	apiProperties_specGenerator = gen.Struct(reflect.TypeOf(ApiProperties_Spec{}), generators)

	return apiProperties_specGenerator
}

// AddIndependentPropertyGeneratorsForApiProperties_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProperties_Spec(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.OneConstOf(ApiProperties_ServerVersion_Spec32, ApiProperties_ServerVersion_Spec36, ApiProperties_ServerVersion_Spec40))
}

func Test_ApiProperties_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiProperties_Status to ApiProperties_Status via AssignPropertiesToApiProperties_Status & AssignPropertiesFromApiProperties_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiProperties_Status, ApiProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiProperties_Status tests if a specific instance of ApiProperties_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForApiProperties_Status(subject ApiProperties_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ApiProperties_Status
	err := copied.AssignPropertiesToApiProperties_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiProperties_Status
	err = actual.AssignPropertiesFromApiProperties_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProperties_Status, ApiProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProperties_Status runs a test to see if a specific instance of ApiProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProperties_Status(subject ApiProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_Status instances for property testing - lazily instantiated by
//ApiProperties_StatusGenerator()
var apiProperties_statusGenerator gopter.Gen

// ApiProperties_StatusGenerator returns a generator of ApiProperties_Status instances for property testing.
func ApiProperties_StatusGenerator() gopter.Gen {
	if apiProperties_statusGenerator != nil {
		return apiProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProperties_Status(generators)
	apiProperties_statusGenerator = gen.Struct(reflect.TypeOf(ApiProperties_Status{}), generators)

	return apiProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForApiProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProperties_Status(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.OneConstOf(ApiProperties_ServerVersion_Status32, ApiProperties_ServerVersion_Status36, ApiProperties_ServerVersion_Status40))
}

func Test_BackupPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackupPolicy_Spec to BackupPolicy_Spec via AssignPropertiesToBackupPolicy_Spec & AssignPropertiesFromBackupPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackupPolicy_Spec, BackupPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackupPolicy_Spec tests if a specific instance of BackupPolicy_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForBackupPolicy_Spec(subject BackupPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.BackupPolicy_Spec
	err := copied.AssignPropertiesToBackupPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackupPolicy_Spec
	err = actual.AssignPropertiesFromBackupPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackupPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicy_Spec, BackupPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicy_Spec runs a test to see if a specific instance of BackupPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicy_Spec(subject BackupPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_Spec instances for property testing - lazily instantiated by BackupPolicy_SpecGenerator()
var backupPolicy_specGenerator gopter.Gen

// BackupPolicy_SpecGenerator returns a generator of BackupPolicy_Spec instances for property testing.
func BackupPolicy_SpecGenerator() gopter.Gen {
	if backupPolicy_specGenerator != nil {
		return backupPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicy_Spec(generators)
	backupPolicy_specGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_Spec{}), generators)

	return backupPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicy_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(BackupPolicyType_SpecContinuous, BackupPolicyType_SpecPeriodic)
}

func Test_BackupPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackupPolicy_Status to BackupPolicy_Status via AssignPropertiesToBackupPolicy_Status & AssignPropertiesFromBackupPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackupPolicy_Status, BackupPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackupPolicy_Status tests if a specific instance of BackupPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForBackupPolicy_Status(subject BackupPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.BackupPolicy_Status
	err := copied.AssignPropertiesToBackupPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackupPolicy_Status
	err = actual.AssignPropertiesFromBackupPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackupPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicy_Status, BackupPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicy_Status runs a test to see if a specific instance of BackupPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicy_Status(subject BackupPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_Status instances for property testing - lazily instantiated by
//BackupPolicy_StatusGenerator()
var backupPolicy_statusGenerator gopter.Gen

// BackupPolicy_StatusGenerator returns a generator of BackupPolicy_Status instances for property testing.
func BackupPolicy_StatusGenerator() gopter.Gen {
	if backupPolicy_statusGenerator != nil {
		return backupPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicy_Status(generators)
	backupPolicy_statusGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_Status{}), generators)

	return backupPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicy_Status(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(BackupPolicyType_StatusContinuous, BackupPolicyType_StatusPeriodic)
}

func Test_Capability_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Capability_Spec to Capability_Spec via AssignPropertiesToCapability_Spec & AssignPropertiesFromCapability_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForCapability_Spec, Capability_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCapability_Spec tests if a specific instance of Capability_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCapability_Spec(subject Capability_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Capability_Spec
	err := copied.AssignPropertiesToCapability_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Capability_Spec
	err = actual.AssignPropertiesFromCapability_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Capability_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapability_Spec, Capability_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapability_Spec runs a test to see if a specific instance of Capability_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCapability_Spec(subject Capability_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability_Spec instances for property testing - lazily instantiated by Capability_SpecGenerator()
var capability_specGenerator gopter.Gen

// Capability_SpecGenerator returns a generator of Capability_Spec instances for property testing.
func Capability_SpecGenerator() gopter.Gen {
	if capability_specGenerator != nil {
		return capability_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapability_Spec(generators)
	capability_specGenerator = gen.Struct(reflect.TypeOf(Capability_Spec{}), generators)

	return capability_specGenerator
}

// AddIndependentPropertyGeneratorsForCapability_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapability_Spec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_Capability_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Capability_Status to Capability_Status via AssignPropertiesToCapability_Status & AssignPropertiesFromCapability_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForCapability_Status, Capability_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCapability_Status tests if a specific instance of Capability_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCapability_Status(subject Capability_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Capability_Status
	err := copied.AssignPropertiesToCapability_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Capability_Status
	err = actual.AssignPropertiesFromCapability_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Capability_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapability_Status, Capability_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapability_Status runs a test to see if a specific instance of Capability_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCapability_Status(subject Capability_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability_Status instances for property testing - lazily instantiated by Capability_StatusGenerator()
var capability_statusGenerator gopter.Gen

// Capability_StatusGenerator returns a generator of Capability_Status instances for property testing.
func Capability_StatusGenerator() gopter.Gen {
	if capability_statusGenerator != nil {
		return capability_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapability_Status(generators)
	capability_statusGenerator = gen.Struct(reflect.TypeOf(Capability_Status{}), generators)

	return capability_statusGenerator
}

// AddIndependentPropertyGeneratorsForCapability_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapability_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ConsistencyPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConsistencyPolicy_Spec to ConsistencyPolicy_Spec via AssignPropertiesToConsistencyPolicy_Spec & AssignPropertiesFromConsistencyPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForConsistencyPolicy_Spec, ConsistencyPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConsistencyPolicy_Spec tests if a specific instance of ConsistencyPolicy_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForConsistencyPolicy_Spec(subject ConsistencyPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ConsistencyPolicy_Spec
	err := copied.AssignPropertiesToConsistencyPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConsistencyPolicy_Spec
	err = actual.AssignPropertiesFromConsistencyPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConsistencyPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicy_Spec, ConsistencyPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicy_Spec runs a test to see if a specific instance of ConsistencyPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicy_Spec(subject ConsistencyPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy_Spec instances for property testing - lazily instantiated by
//ConsistencyPolicy_SpecGenerator()
var consistencyPolicy_specGenerator gopter.Gen

// ConsistencyPolicy_SpecGenerator returns a generator of ConsistencyPolicy_Spec instances for property testing.
func ConsistencyPolicy_SpecGenerator() gopter.Gen {
	if consistencyPolicy_specGenerator != nil {
		return consistencyPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicy_Spec(generators)
	consistencyPolicy_specGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy_Spec{}), generators)

	return consistencyPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicy_Spec(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.OneConstOf(
		ConsistencyPolicy_DefaultConsistencyLevel_SpecBoundedStaleness,
		ConsistencyPolicy_DefaultConsistencyLevel_SpecConsistentPrefix,
		ConsistencyPolicy_DefaultConsistencyLevel_SpecEventual,
		ConsistencyPolicy_DefaultConsistencyLevel_SpecSession,
		ConsistencyPolicy_DefaultConsistencyLevel_SpecStrong)
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_ConsistencyPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConsistencyPolicy_Status to ConsistencyPolicy_Status via AssignPropertiesToConsistencyPolicy_Status & AssignPropertiesFromConsistencyPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForConsistencyPolicy_Status, ConsistencyPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConsistencyPolicy_Status tests if a specific instance of ConsistencyPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForConsistencyPolicy_Status(subject ConsistencyPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ConsistencyPolicy_Status
	err := copied.AssignPropertiesToConsistencyPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConsistencyPolicy_Status
	err = actual.AssignPropertiesFromConsistencyPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConsistencyPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicy_Status, ConsistencyPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicy_Status runs a test to see if a specific instance of ConsistencyPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicy_Status(subject ConsistencyPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy_Status instances for property testing - lazily instantiated by
//ConsistencyPolicy_StatusGenerator()
var consistencyPolicy_statusGenerator gopter.Gen

// ConsistencyPolicy_StatusGenerator returns a generator of ConsistencyPolicy_Status instances for property testing.
func ConsistencyPolicy_StatusGenerator() gopter.Gen {
	if consistencyPolicy_statusGenerator != nil {
		return consistencyPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicy_Status(generators)
	consistencyPolicy_statusGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy_Status{}), generators)

	return consistencyPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicy_Status(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.OneConstOf(
		ConsistencyPolicy_DefaultConsistencyLevel_StatusBoundedStaleness,
		ConsistencyPolicy_DefaultConsistencyLevel_StatusConsistentPrefix,
		ConsistencyPolicy_DefaultConsistencyLevel_StatusEventual,
		ConsistencyPolicy_DefaultConsistencyLevel_StatusSession,
		ConsistencyPolicy_DefaultConsistencyLevel_StatusStrong)
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CorsPolicy_Spec to CorsPolicy_Spec via AssignPropertiesToCorsPolicy_Spec & AssignPropertiesFromCorsPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForCorsPolicy_Spec, CorsPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCorsPolicy_Spec tests if a specific instance of CorsPolicy_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCorsPolicy_Spec(subject CorsPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.CorsPolicy_Spec
	err := copied.AssignPropertiesToCorsPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CorsPolicy_Spec
	err = actual.AssignPropertiesFromCorsPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CorsPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicy_Spec, CorsPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicy_Spec runs a test to see if a specific instance of CorsPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicy_Spec(subject CorsPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_Spec instances for property testing - lazily instantiated by CorsPolicy_SpecGenerator()
var corsPolicy_specGenerator gopter.Gen

// CorsPolicy_SpecGenerator returns a generator of CorsPolicy_Spec instances for property testing.
func CorsPolicy_SpecGenerator() gopter.Gen {
	if corsPolicy_specGenerator != nil {
		return corsPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicy_Spec(generators)
	corsPolicy_specGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_Spec{}), generators)

	return corsPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicy_Spec(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.AlphaString()
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CorsPolicy_Status to CorsPolicy_Status via AssignPropertiesToCorsPolicy_Status & AssignPropertiesFromCorsPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForCorsPolicy_Status, CorsPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCorsPolicy_Status tests if a specific instance of CorsPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCorsPolicy_Status(subject CorsPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.CorsPolicy_Status
	err := copied.AssignPropertiesToCorsPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CorsPolicy_Status
	err = actual.AssignPropertiesFromCorsPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CorsPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicy_Status, CorsPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicy_Status runs a test to see if a specific instance of CorsPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicy_Status(subject CorsPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_Status instances for property testing - lazily instantiated by CorsPolicy_StatusGenerator()
var corsPolicy_statusGenerator gopter.Gen

// CorsPolicy_StatusGenerator returns a generator of CorsPolicy_Status instances for property testing.
func CorsPolicy_StatusGenerator() gopter.Gen {
	if corsPolicy_statusGenerator != nil {
		return corsPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicy_Status(generators)
	corsPolicy_statusGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_Status{}), generators)

	return corsPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicy_Status(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.AlphaString()
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_IpAddressOrRange_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpAddressOrRange_Spec to IpAddressOrRange_Spec via AssignPropertiesToIpAddressOrRange_Spec & AssignPropertiesFromIpAddressOrRange_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpAddressOrRange_Spec, IpAddressOrRange_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpAddressOrRange_Spec tests if a specific instance of IpAddressOrRange_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIpAddressOrRange_Spec(subject IpAddressOrRange_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.IpAddressOrRange_Spec
	err := copied.AssignPropertiesToIpAddressOrRange_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpAddressOrRange_Spec
	err = actual.AssignPropertiesFromIpAddressOrRange_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpAddressOrRange_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRange_Spec, IpAddressOrRange_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRange_Spec runs a test to see if a specific instance of IpAddressOrRange_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRange_Spec(subject IpAddressOrRange_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange_Spec instances for property testing - lazily instantiated by
//IpAddressOrRange_SpecGenerator()
var ipAddressOrRange_specGenerator gopter.Gen

// IpAddressOrRange_SpecGenerator returns a generator of IpAddressOrRange_Spec instances for property testing.
func IpAddressOrRange_SpecGenerator() gopter.Gen {
	if ipAddressOrRange_specGenerator != nil {
		return ipAddressOrRange_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRange_Spec(generators)
	ipAddressOrRange_specGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange_Spec{}), generators)

	return ipAddressOrRange_specGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRange_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRange_Spec(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpAddressOrRange_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpAddressOrRange_Status to IpAddressOrRange_Status via AssignPropertiesToIpAddressOrRange_Status & AssignPropertiesFromIpAddressOrRange_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpAddressOrRange_Status, IpAddressOrRange_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpAddressOrRange_Status tests if a specific instance of IpAddressOrRange_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIpAddressOrRange_Status(subject IpAddressOrRange_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.IpAddressOrRange_Status
	err := copied.AssignPropertiesToIpAddressOrRange_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpAddressOrRange_Status
	err = actual.AssignPropertiesFromIpAddressOrRange_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpAddressOrRange_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRange_Status, IpAddressOrRange_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRange_Status runs a test to see if a specific instance of IpAddressOrRange_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRange_Status(subject IpAddressOrRange_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange_Status instances for property testing - lazily instantiated by
//IpAddressOrRange_StatusGenerator()
var ipAddressOrRange_statusGenerator gopter.Gen

// IpAddressOrRange_StatusGenerator returns a generator of IpAddressOrRange_Status instances for property testing.
func IpAddressOrRange_StatusGenerator() gopter.Gen {
	if ipAddressOrRange_statusGenerator != nil {
		return ipAddressOrRange_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRange_Status(generators)
	ipAddressOrRange_statusGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange_Status{}), generators)

	return ipAddressOrRange_statusGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRange_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRange_Status(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Location_Spec to Location_Spec via AssignPropertiesToLocation_Spec & AssignPropertiesFromLocation_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForLocation_Spec, Location_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLocation_Spec tests if a specific instance of Location_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForLocation_Spec(subject Location_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Location_Spec
	err := copied.AssignPropertiesToLocation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Location_Spec
	err = actual.AssignPropertiesFromLocation_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Location_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocation_Spec, Location_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocation_Spec runs a test to see if a specific instance of Location_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLocation_Spec(subject Location_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location_Spec instances for property testing - lazily instantiated by Location_SpecGenerator()
var location_specGenerator gopter.Gen

// Location_SpecGenerator returns a generator of Location_Spec instances for property testing.
func Location_SpecGenerator() gopter.Gen {
	if location_specGenerator != nil {
		return location_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocation_Spec(generators)
	location_specGenerator = gen.Struct(reflect.TypeOf(Location_Spec{}), generators)

	return location_specGenerator
}

// AddIndependentPropertyGeneratorsForLocation_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocation_Spec(gens map[string]gopter.Gen) {
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Location_Status to Location_Status via AssignPropertiesToLocation_Status & AssignPropertiesFromLocation_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForLocation_Status, Location_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLocation_Status tests if a specific instance of Location_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForLocation_Status(subject Location_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Location_Status
	err := copied.AssignPropertiesToLocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Location_Status
	err = actual.AssignPropertiesFromLocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Location_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocation_Status, Location_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocation_Status runs a test to see if a specific instance of Location_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLocation_Status(subject Location_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location_Status instances for property testing - lazily instantiated by Location_StatusGenerator()
var location_statusGenerator gopter.Gen

// Location_StatusGenerator returns a generator of Location_Status instances for property testing.
func Location_StatusGenerator() gopter.Gen {
	if location_statusGenerator != nil {
		return location_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocation_Status(generators)
	location_statusGenerator = gen.Struct(reflect.TypeOf(Location_Status{}), generators)

	return location_statusGenerator
}

// AddIndependentPropertyGeneratorsForLocation_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocation_Status(gens map[string]gopter.Gen) {
	gens["DocumentEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_Spec to ManagedServiceIdentity_Spec via AssignPropertiesToManagedServiceIdentity_Spec & AssignPropertiesFromManagedServiceIdentity_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity_Spec, ManagedServiceIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity_Spec tests if a specific instance of ManagedServiceIdentity_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity_Spec(subject ManagedServiceIdentity_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ManagedServiceIdentity_Spec
	err := copied.AssignPropertiesToManagedServiceIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_Spec
	err = actual.AssignPropertiesFromManagedServiceIdentity_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_Spec, ManagedServiceIdentity_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_Spec runs a test to see if a specific instance of ManagedServiceIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_Spec(subject ManagedServiceIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_Spec instances for property testing - lazily instantiated by
//ManagedServiceIdentity_SpecGenerator()
var managedServiceIdentity_specGenerator gopter.Gen

// ManagedServiceIdentity_SpecGenerator returns a generator of ManagedServiceIdentity_Spec instances for property testing.
func ManagedServiceIdentity_SpecGenerator() gopter.Gen {
	if managedServiceIdentity_specGenerator != nil {
		return managedServiceIdentity_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_Spec(generators)
	managedServiceIdentity_specGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Spec{}), generators)

	return managedServiceIdentity_specGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_Spec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentity_Type_SpecNone,
		ManagedServiceIdentity_Type_SpecSystemAssigned,
		ManagedServiceIdentity_Type_SpecSystemAssignedUserAssigned,
		ManagedServiceIdentity_Type_SpecUserAssigned))
}

func Test_ManagedServiceIdentity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_Status to ManagedServiceIdentity_Status via AssignPropertiesToManagedServiceIdentity_Status & AssignPropertiesFromManagedServiceIdentity_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity_Status, ManagedServiceIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity_Status tests if a specific instance of ManagedServiceIdentity_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity_Status(subject ManagedServiceIdentity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ManagedServiceIdentity_Status
	err := copied.AssignPropertiesToManagedServiceIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_Status
	err = actual.AssignPropertiesFromManagedServiceIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_Status, ManagedServiceIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_Status runs a test to see if a specific instance of ManagedServiceIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_Status(subject ManagedServiceIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_Status instances for property testing - lazily instantiated by
//ManagedServiceIdentity_StatusGenerator()
var managedServiceIdentity_statusGenerator gopter.Gen

// ManagedServiceIdentity_StatusGenerator returns a generator of ManagedServiceIdentity_Status instances for property testing.
// We first initialize managedServiceIdentity_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_StatusGenerator() gopter.Gen {
	if managedServiceIdentity_statusGenerator != nil {
		return managedServiceIdentity_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_Status(generators)
	managedServiceIdentity_statusGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_Status(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_Status(generators)
	managedServiceIdentity_statusGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Status{}), generators)

	return managedServiceIdentity_statusGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_Status(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentity_Type_StatusNone,
		ManagedServiceIdentity_Type_StatusSystemAssigned,
		ManagedServiceIdentity_Type_StatusSystemAssignedUserAssigned,
		ManagedServiceIdentity_Type_StatusUserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_Status(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), ManagedServiceIdentity_UserAssignedIdentities_StatusGenerator())
}

func Test_VirtualNetworkRule_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkRule_Spec to VirtualNetworkRule_Spec via AssignPropertiesToVirtualNetworkRule_Spec & AssignPropertiesFromVirtualNetworkRule_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkRule_Spec, VirtualNetworkRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkRule_Spec tests if a specific instance of VirtualNetworkRule_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkRule_Spec(subject VirtualNetworkRule_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.VirtualNetworkRule_Spec
	err := copied.AssignPropertiesToVirtualNetworkRule_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkRule_Spec
	err = actual.AssignPropertiesFromVirtualNetworkRule_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_Spec, VirtualNetworkRule_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_Spec runs a test to see if a specific instance of VirtualNetworkRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_Spec(subject VirtualNetworkRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_Spec instances for property testing - lazily instantiated by
//VirtualNetworkRule_SpecGenerator()
var virtualNetworkRule_specGenerator gopter.Gen

// VirtualNetworkRule_SpecGenerator returns a generator of VirtualNetworkRule_Spec instances for property testing.
func VirtualNetworkRule_SpecGenerator() gopter.Gen {
	if virtualNetworkRule_specGenerator != nil {
		return virtualNetworkRule_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_Spec(generators)
	virtualNetworkRule_specGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_Spec{}), generators)

	return virtualNetworkRule_specGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_Spec(gens map[string]gopter.Gen) {
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}

func Test_VirtualNetworkRule_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkRule_Status to VirtualNetworkRule_Status via AssignPropertiesToVirtualNetworkRule_Status & AssignPropertiesFromVirtualNetworkRule_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkRule_Status, VirtualNetworkRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkRule_Status tests if a specific instance of VirtualNetworkRule_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkRule_Status(subject VirtualNetworkRule_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.VirtualNetworkRule_Status
	err := copied.AssignPropertiesToVirtualNetworkRule_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkRule_Status
	err = actual.AssignPropertiesFromVirtualNetworkRule_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_Status, VirtualNetworkRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_Status runs a test to see if a specific instance of VirtualNetworkRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_Status(subject VirtualNetworkRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_Status instances for property testing - lazily instantiated by
//VirtualNetworkRule_StatusGenerator()
var virtualNetworkRule_statusGenerator gopter.Gen

// VirtualNetworkRule_StatusGenerator returns a generator of VirtualNetworkRule_Status instances for property testing.
func VirtualNetworkRule_StatusGenerator() gopter.Gen {
	if virtualNetworkRule_statusGenerator != nil {
		return virtualNetworkRule_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_Status(generators)
	virtualNetworkRule_statusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_Status{}), generators)

	return virtualNetworkRule_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}

func Test_ManagedServiceIdentity_UserAssignedIdentities_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_UserAssignedIdentities_Status to ManagedServiceIdentity_UserAssignedIdentities_Status via AssignPropertiesToManagedServiceIdentity_UserAssignedIdentities_Status & AssignPropertiesFromManagedServiceIdentity_UserAssignedIdentities_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity_UserAssignedIdentities_Status, ManagedServiceIdentity_UserAssignedIdentities_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity_UserAssignedIdentities_Status tests if a specific instance of ManagedServiceIdentity_UserAssignedIdentities_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity_UserAssignedIdentities_Status(subject ManagedServiceIdentity_UserAssignedIdentities_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ManagedServiceIdentity_UserAssignedIdentities_Status
	err := copied.AssignPropertiesToManagedServiceIdentity_UserAssignedIdentities_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_UserAssignedIdentities_Status
	err = actual.AssignPropertiesFromManagedServiceIdentity_UserAssignedIdentities_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_UserAssignedIdentities_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_UserAssignedIdentities_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_Status, ManagedServiceIdentity_UserAssignedIdentities_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_Status runs a test to see if a specific instance of ManagedServiceIdentity_UserAssignedIdentities_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_Status(subject ManagedServiceIdentity_UserAssignedIdentities_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_UserAssignedIdentities_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_UserAssignedIdentities_Status instances for property testing - lazily
//instantiated by ManagedServiceIdentity_UserAssignedIdentities_StatusGenerator()
var managedServiceIdentity_userAssignedIdentities_statusGenerator gopter.Gen

// ManagedServiceIdentity_UserAssignedIdentities_StatusGenerator returns a generator of ManagedServiceIdentity_UserAssignedIdentities_Status instances for property testing.
func ManagedServiceIdentity_UserAssignedIdentities_StatusGenerator() gopter.Gen {
	if managedServiceIdentity_userAssignedIdentities_statusGenerator != nil {
		return managedServiceIdentity_userAssignedIdentities_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_Status(generators)
	managedServiceIdentity_userAssignedIdentities_statusGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_UserAssignedIdentities_Status{}), generators)

	return managedServiceIdentity_userAssignedIdentities_statusGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_Status(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}
