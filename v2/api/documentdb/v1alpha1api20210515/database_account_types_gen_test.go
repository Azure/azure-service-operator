// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/documentdb/v1alpha1api20210515storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DatabaseAccount_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccount to hub returns original",
		prop.ForAll(RunResourceConversionTestForDatabaseAccount, DatabaseAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForDatabaseAccount tests if a specific instance of DatabaseAccount round trips to the hub storage version and back losslessly
func RunResourceConversionTestForDatabaseAccount(subject DatabaseAccount) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20210515storage.DatabaseAccount
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual DatabaseAccount
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccount_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccount to DatabaseAccount via AssignPropertiesToDatabaseAccount & AssignPropertiesFromDatabaseAccount returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatabaseAccount, DatabaseAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatabaseAccount tests if a specific instance of DatabaseAccount can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForDatabaseAccount(subject DatabaseAccount) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.DatabaseAccount
	err := copied.AssignPropertiesToDatabaseAccount(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatabaseAccount
	err = actual.AssignPropertiesFromDatabaseAccount(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccount, DatabaseAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccount runs a test to see if a specific instance of DatabaseAccount round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccount(subject DatabaseAccount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccount instances for property testing - lazily instantiated by DatabaseAccountGenerator()
var databaseAccountGenerator gopter.Gen

// DatabaseAccountGenerator returns a generator of DatabaseAccount instances for property testing.
func DatabaseAccountGenerator() gopter.Gen {
	if databaseAccountGenerator != nil {
		return databaseAccountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDatabaseAccount(generators)
	databaseAccountGenerator = gen.Struct(reflect.TypeOf(DatabaseAccount{}), generators)

	return databaseAccountGenerator
}

// AddRelatedPropertyGeneratorsForDatabaseAccount is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccount(gens map[string]gopter.Gen) {
	gens["Spec"] = DatabaseAccount_SpecGenerator()
	gens["Status"] = DatabaseAccount_StatusGenerator()
}

func Test_DatabaseAccount_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccount_Spec to DatabaseAccount_Spec via AssignPropertiesToDatabaseAccount_Spec & AssignPropertiesFromDatabaseAccount_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatabaseAccount_Spec, DatabaseAccount_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatabaseAccount_Spec tests if a specific instance of DatabaseAccount_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForDatabaseAccount_Spec(subject DatabaseAccount_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.DatabaseAccount_Spec
	err := copied.AssignPropertiesToDatabaseAccount_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatabaseAccount_Spec
	err = actual.AssignPropertiesFromDatabaseAccount_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccount_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccount_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccount_Spec, DatabaseAccount_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccount_Spec runs a test to see if a specific instance of DatabaseAccount_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccount_Spec(subject DatabaseAccount_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccount_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccount_Spec instances for property testing - lazily instantiated by
//DatabaseAccount_SpecGenerator()
var databaseAccount_specGenerator gopter.Gen

// DatabaseAccount_SpecGenerator returns a generator of DatabaseAccount_Spec instances for property testing.
// We first initialize databaseAccount_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccount_SpecGenerator() gopter.Gen {
	if databaseAccount_specGenerator != nil {
		return databaseAccount_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccount_Spec(generators)
	databaseAccount_specGenerator = gen.Struct(reflect.TypeOf(DatabaseAccount_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccount_Spec(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccount_Spec(generators)
	databaseAccount_specGenerator = gen.Struct(reflect.TypeOf(DatabaseAccount_Spec{}), generators)

	return databaseAccount_specGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccount_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccount_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["ConnectorOffer"] = gen.PtrOf(gen.OneConstOf(ConnectorOfferSmall))
	gens["DatabaseAccountOfferType"] = gen.OneConstOf(DatabaseAccountOfferTypeStandard)
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(DatabaseAccount_SpecKindGlobalDocumentDB, DatabaseAccount_SpecKindMongoDB, DatabaseAccount_SpecKindParse))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.OneConstOf(NetworkAclBypassAzureServices, NetworkAclBypassNone))
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccessDisabled, PublicNetworkAccessEnabled))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccount_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccount_Spec(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfigurationGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiPropertiesGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicyGenerator())
	gens["Capabilities"] = gen.SliceOf(CapabilityGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicyGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicyGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRangeGenerator())
	gens["Locations"] = gen.SliceOf(LocationGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleGenerator())
}

func Test_DatabaseAccount_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccount_Status to DatabaseAccount_Status via AssignPropertiesToDatabaseAccount_Status & AssignPropertiesFromDatabaseAccount_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatabaseAccount_Status, DatabaseAccount_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatabaseAccount_Status tests if a specific instance of DatabaseAccount_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForDatabaseAccount_Status(subject DatabaseAccount_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.DatabaseAccount_Status
	err := copied.AssignPropertiesToDatabaseAccount_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatabaseAccount_Status
	err = actual.AssignPropertiesFromDatabaseAccount_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccount_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccount_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccount_Status, DatabaseAccount_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccount_Status runs a test to see if a specific instance of DatabaseAccount_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccount_Status(subject DatabaseAccount_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccount_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccount_Status instances for property testing - lazily instantiated by
//DatabaseAccount_StatusGenerator()
var databaseAccount_statusGenerator gopter.Gen

// DatabaseAccount_StatusGenerator returns a generator of DatabaseAccount_Status instances for property testing.
// We first initialize databaseAccount_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccount_StatusGenerator() gopter.Gen {
	if databaseAccount_statusGenerator != nil {
		return databaseAccount_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccount_Status(generators)
	databaseAccount_statusGenerator = gen.Struct(reflect.TypeOf(DatabaseAccount_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccount_Status(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccount_Status(generators)
	databaseAccount_statusGenerator = gen.Struct(reflect.TypeOf(DatabaseAccount_Status{}), generators)

	return databaseAccount_statusGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccount_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccount_Status(gens map[string]gopter.Gen) {
	gens["ConnectorOffer"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseAccountOfferType"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccount_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccount_Status(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfiguration_StatusGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiProperties_StatusGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicy_StatusGenerator())
	gens["Capabilities"] = gen.SliceOf(Capability_StatusGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicy_StatusGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicy_StatusGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_StatusGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRange_StatusGenerator())
	gens["Locations"] = gen.SliceOf(Location_StatusGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_StatusGenerator())
}

func Test_AnalyticalStorageConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AnalyticalStorageConfiguration to AnalyticalStorageConfiguration via AssignPropertiesToAnalyticalStorageConfiguration & AssignPropertiesFromAnalyticalStorageConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForAnalyticalStorageConfiguration, AnalyticalStorageConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAnalyticalStorageConfiguration tests if a specific instance of AnalyticalStorageConfiguration can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForAnalyticalStorageConfiguration(subject AnalyticalStorageConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.AnalyticalStorageConfiguration
	err := copied.AssignPropertiesToAnalyticalStorageConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AnalyticalStorageConfiguration
	err = actual.AssignPropertiesFromAnalyticalStorageConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AnalyticalStorageConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfiguration, AnalyticalStorageConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfiguration runs a test to see if a specific instance of AnalyticalStorageConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfiguration(subject AnalyticalStorageConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration instances for property testing - lazily instantiated by
//AnalyticalStorageConfigurationGenerator()
var analyticalStorageConfigurationGenerator gopter.Gen

// AnalyticalStorageConfigurationGenerator returns a generator of AnalyticalStorageConfiguration instances for property testing.
func AnalyticalStorageConfigurationGenerator() gopter.Gen {
	if analyticalStorageConfigurationGenerator != nil {
		return analyticalStorageConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration(generators)
	analyticalStorageConfigurationGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration{}), generators)

	return analyticalStorageConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.OneConstOf(AnalyticalStorageSchemaTypeFullFidelity, AnalyticalStorageSchemaTypeWellDefined))
}

func Test_AnalyticalStorageConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AnalyticalStorageConfiguration_Status to AnalyticalStorageConfiguration_Status via AssignPropertiesToAnalyticalStorageConfiguration_Status & AssignPropertiesFromAnalyticalStorageConfiguration_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForAnalyticalStorageConfiguration_Status, AnalyticalStorageConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAnalyticalStorageConfiguration_Status tests if a specific instance of AnalyticalStorageConfiguration_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForAnalyticalStorageConfiguration_Status(subject AnalyticalStorageConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.AnalyticalStorageConfiguration_Status
	err := copied.AssignPropertiesToAnalyticalStorageConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AnalyticalStorageConfiguration_Status
	err = actual.AssignPropertiesFromAnalyticalStorageConfiguration_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AnalyticalStorageConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfiguration_Status, AnalyticalStorageConfiguration_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfiguration_Status runs a test to see if a specific instance of AnalyticalStorageConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfiguration_Status(subject AnalyticalStorageConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration_Status instances for property testing - lazily instantiated by
//AnalyticalStorageConfiguration_StatusGenerator()
var analyticalStorageConfiguration_statusGenerator gopter.Gen

// AnalyticalStorageConfiguration_StatusGenerator returns a generator of AnalyticalStorageConfiguration_Status instances for property testing.
func AnalyticalStorageConfiguration_StatusGenerator() gopter.Gen {
	if analyticalStorageConfiguration_statusGenerator != nil {
		return analyticalStorageConfiguration_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Status(generators)
	analyticalStorageConfiguration_statusGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration_Status{}), generators)

	return analyticalStorageConfiguration_statusGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_Status(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiProperties_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiProperties to ApiProperties via AssignPropertiesToApiProperties & AssignPropertiesFromApiProperties returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiProperties, ApiPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiProperties tests if a specific instance of ApiProperties can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForApiProperties(subject ApiProperties) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ApiProperties
	err := copied.AssignPropertiesToApiProperties(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiProperties
	err = actual.AssignPropertiesFromApiProperties(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProperties, ApiPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProperties runs a test to see if a specific instance of ApiProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProperties(subject ApiProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties instances for property testing - lazily instantiated by ApiPropertiesGenerator()
var apiPropertiesGenerator gopter.Gen

// ApiPropertiesGenerator returns a generator of ApiProperties instances for property testing.
func ApiPropertiesGenerator() gopter.Gen {
	if apiPropertiesGenerator != nil {
		return apiPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProperties(generators)
	apiPropertiesGenerator = gen.Struct(reflect.TypeOf(ApiProperties{}), generators)

	return apiPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForApiProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProperties(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.OneConstOf(ApiPropertiesServerVersion32, ApiPropertiesServerVersion36, ApiPropertiesServerVersion40))
}

func Test_ApiProperties_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiProperties_Status to ApiProperties_Status via AssignPropertiesToApiProperties_Status & AssignPropertiesFromApiProperties_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiProperties_Status, ApiProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiProperties_Status tests if a specific instance of ApiProperties_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForApiProperties_Status(subject ApiProperties_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ApiProperties_Status
	err := copied.AssignPropertiesToApiProperties_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiProperties_Status
	err = actual.AssignPropertiesFromApiProperties_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProperties_Status, ApiProperties_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProperties_Status runs a test to see if a specific instance of ApiProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProperties_Status(subject ApiProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_Status instances for property testing - lazily instantiated by
//ApiProperties_StatusGenerator()
var apiProperties_statusGenerator gopter.Gen

// ApiProperties_StatusGenerator returns a generator of ApiProperties_Status instances for property testing.
func ApiProperties_StatusGenerator() gopter.Gen {
	if apiProperties_statusGenerator != nil {
		return apiProperties_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProperties_Status(generators)
	apiProperties_statusGenerator = gen.Struct(reflect.TypeOf(ApiProperties_Status{}), generators)

	return apiProperties_statusGenerator
}

// AddIndependentPropertyGeneratorsForApiProperties_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProperties_Status(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackupPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackupPolicy to BackupPolicy via AssignPropertiesToBackupPolicy & AssignPropertiesFromBackupPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackupPolicy, BackupPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackupPolicy tests if a specific instance of BackupPolicy can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForBackupPolicy(subject BackupPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.BackupPolicy
	err := copied.AssignPropertiesToBackupPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackupPolicy
	err = actual.AssignPropertiesFromBackupPolicy(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackupPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicy, BackupPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicy runs a test to see if a specific instance of BackupPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicy(subject BackupPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy instances for property testing - lazily instantiated by BackupPolicyGenerator()
var backupPolicyGenerator gopter.Gen

// BackupPolicyGenerator returns a generator of BackupPolicy instances for property testing.
func BackupPolicyGenerator() gopter.Gen {
	if backupPolicyGenerator != nil {
		return backupPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicy(generators)
	backupPolicyGenerator = gen.Struct(reflect.TypeOf(BackupPolicy{}), generators)

	return backupPolicyGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicy(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(BackupPolicyTypeContinuous, BackupPolicyTypePeriodic)
}

func Test_BackupPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackupPolicy_Status to BackupPolicy_Status via AssignPropertiesToBackupPolicy_Status & AssignPropertiesFromBackupPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackupPolicy_Status, BackupPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackupPolicy_Status tests if a specific instance of BackupPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForBackupPolicy_Status(subject BackupPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.BackupPolicy_Status
	err := copied.AssignPropertiesToBackupPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackupPolicy_Status
	err = actual.AssignPropertiesFromBackupPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackupPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicy_Status, BackupPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicy_Status runs a test to see if a specific instance of BackupPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicy_Status(subject BackupPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_Status instances for property testing - lazily instantiated by
//BackupPolicy_StatusGenerator()
var backupPolicy_statusGenerator gopter.Gen

// BackupPolicy_StatusGenerator returns a generator of BackupPolicy_Status instances for property testing.
func BackupPolicy_StatusGenerator() gopter.Gen {
	if backupPolicy_statusGenerator != nil {
		return backupPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicy_Status(generators)
	backupPolicy_statusGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_Status{}), generators)

	return backupPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicy_Status(gens map[string]gopter.Gen) {
	gens["Type"] = gen.AlphaString()
}

func Test_Capability_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Capability to Capability via AssignPropertiesToCapability & AssignPropertiesFromCapability returns original",
		prop.ForAll(RunPropertyAssignmentTestForCapability, CapabilityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCapability tests if a specific instance of Capability can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCapability(subject Capability) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Capability
	err := copied.AssignPropertiesToCapability(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Capability
	err = actual.AssignPropertiesFromCapability(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Capability_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapability, CapabilityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapability runs a test to see if a specific instance of Capability round trips to JSON and back losslessly
func RunJSONSerializationTestForCapability(subject Capability) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability instances for property testing - lazily instantiated by CapabilityGenerator()
var capabilityGenerator gopter.Gen

// CapabilityGenerator returns a generator of Capability instances for property testing.
func CapabilityGenerator() gopter.Gen {
	if capabilityGenerator != nil {
		return capabilityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapability(generators)
	capabilityGenerator = gen.Struct(reflect.TypeOf(Capability{}), generators)

	return capabilityGenerator
}

// AddIndependentPropertyGeneratorsForCapability is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapability(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_Capability_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Capability_Status to Capability_Status via AssignPropertiesToCapability_Status & AssignPropertiesFromCapability_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForCapability_Status, Capability_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCapability_Status tests if a specific instance of Capability_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCapability_Status(subject Capability_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Capability_Status
	err := copied.AssignPropertiesToCapability_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Capability_Status
	err = actual.AssignPropertiesFromCapability_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Capability_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapability_Status, Capability_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapability_Status runs a test to see if a specific instance of Capability_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCapability_Status(subject Capability_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability_Status instances for property testing - lazily instantiated by Capability_StatusGenerator()
var capability_statusGenerator gopter.Gen

// Capability_StatusGenerator returns a generator of Capability_Status instances for property testing.
func Capability_StatusGenerator() gopter.Gen {
	if capability_statusGenerator != nil {
		return capability_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapability_Status(generators)
	capability_statusGenerator = gen.Struct(reflect.TypeOf(Capability_Status{}), generators)

	return capability_statusGenerator
}

// AddIndependentPropertyGeneratorsForCapability_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapability_Status(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ConsistencyPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConsistencyPolicy to ConsistencyPolicy via AssignPropertiesToConsistencyPolicy & AssignPropertiesFromConsistencyPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForConsistencyPolicy, ConsistencyPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConsistencyPolicy tests if a specific instance of ConsistencyPolicy can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForConsistencyPolicy(subject ConsistencyPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ConsistencyPolicy
	err := copied.AssignPropertiesToConsistencyPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConsistencyPolicy
	err = actual.AssignPropertiesFromConsistencyPolicy(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConsistencyPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicy, ConsistencyPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicy runs a test to see if a specific instance of ConsistencyPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicy(subject ConsistencyPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy instances for property testing - lazily instantiated by ConsistencyPolicyGenerator()
var consistencyPolicyGenerator gopter.Gen

// ConsistencyPolicyGenerator returns a generator of ConsistencyPolicy instances for property testing.
func ConsistencyPolicyGenerator() gopter.Gen {
	if consistencyPolicyGenerator != nil {
		return consistencyPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicy(generators)
	consistencyPolicyGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy{}), generators)

	return consistencyPolicyGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicy(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.OneConstOf(
		ConsistencyPolicyDefaultConsistencyLevelBoundedStaleness,
		ConsistencyPolicyDefaultConsistencyLevelConsistentPrefix,
		ConsistencyPolicyDefaultConsistencyLevelEventual,
		ConsistencyPolicyDefaultConsistencyLevelSession,
		ConsistencyPolicyDefaultConsistencyLevelStrong)
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_ConsistencyPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConsistencyPolicy_Status to ConsistencyPolicy_Status via AssignPropertiesToConsistencyPolicy_Status & AssignPropertiesFromConsistencyPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForConsistencyPolicy_Status, ConsistencyPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConsistencyPolicy_Status tests if a specific instance of ConsistencyPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForConsistencyPolicy_Status(subject ConsistencyPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ConsistencyPolicy_Status
	err := copied.AssignPropertiesToConsistencyPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConsistencyPolicy_Status
	err = actual.AssignPropertiesFromConsistencyPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConsistencyPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicy_Status, ConsistencyPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicy_Status runs a test to see if a specific instance of ConsistencyPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicy_Status(subject ConsistencyPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy_Status instances for property testing - lazily instantiated by
//ConsistencyPolicy_StatusGenerator()
var consistencyPolicy_statusGenerator gopter.Gen

// ConsistencyPolicy_StatusGenerator returns a generator of ConsistencyPolicy_Status instances for property testing.
func ConsistencyPolicy_StatusGenerator() gopter.Gen {
	if consistencyPolicy_statusGenerator != nil {
		return consistencyPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicy_Status(generators)
	consistencyPolicy_statusGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy_Status{}), generators)

	return consistencyPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicy_Status(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.AlphaString()
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CorsPolicy to CorsPolicy via AssignPropertiesToCorsPolicy & AssignPropertiesFromCorsPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForCorsPolicy, CorsPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCorsPolicy tests if a specific instance of CorsPolicy can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCorsPolicy(subject CorsPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.CorsPolicy
	err := copied.AssignPropertiesToCorsPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CorsPolicy
	err = actual.AssignPropertiesFromCorsPolicy(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CorsPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicy, CorsPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicy runs a test to see if a specific instance of CorsPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicy(subject CorsPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy instances for property testing - lazily instantiated by CorsPolicyGenerator()
var corsPolicyGenerator gopter.Gen

// CorsPolicyGenerator returns a generator of CorsPolicy instances for property testing.
func CorsPolicyGenerator() gopter.Gen {
	if corsPolicyGenerator != nil {
		return corsPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicy(generators)
	corsPolicyGenerator = gen.Struct(reflect.TypeOf(CorsPolicy{}), generators)

	return corsPolicyGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicy(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.AlphaString()
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CorsPolicy_Status to CorsPolicy_Status via AssignPropertiesToCorsPolicy_Status & AssignPropertiesFromCorsPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForCorsPolicy_Status, CorsPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCorsPolicy_Status tests if a specific instance of CorsPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCorsPolicy_Status(subject CorsPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.CorsPolicy_Status
	err := copied.AssignPropertiesToCorsPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CorsPolicy_Status
	err = actual.AssignPropertiesFromCorsPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CorsPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicy_Status, CorsPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicy_Status runs a test to see if a specific instance of CorsPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicy_Status(subject CorsPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_Status instances for property testing - lazily instantiated by CorsPolicy_StatusGenerator()
var corsPolicy_statusGenerator gopter.Gen

// CorsPolicy_StatusGenerator returns a generator of CorsPolicy_Status instances for property testing.
func CorsPolicy_StatusGenerator() gopter.Gen {
	if corsPolicy_statusGenerator != nil {
		return corsPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicy_Status(generators)
	corsPolicy_statusGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_Status{}), generators)

	return corsPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicy_Status(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.AlphaString()
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_IpAddressOrRange_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpAddressOrRange to IpAddressOrRange via AssignPropertiesToIpAddressOrRange & AssignPropertiesFromIpAddressOrRange returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpAddressOrRange, IpAddressOrRangeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpAddressOrRange tests if a specific instance of IpAddressOrRange can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIpAddressOrRange(subject IpAddressOrRange) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.IpAddressOrRange
	err := copied.AssignPropertiesToIpAddressOrRange(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpAddressOrRange
	err = actual.AssignPropertiesFromIpAddressOrRange(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpAddressOrRange_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRange, IpAddressOrRangeGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRange runs a test to see if a specific instance of IpAddressOrRange round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRange(subject IpAddressOrRange) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange instances for property testing - lazily instantiated by IpAddressOrRangeGenerator()
var ipAddressOrRangeGenerator gopter.Gen

// IpAddressOrRangeGenerator returns a generator of IpAddressOrRange instances for property testing.
func IpAddressOrRangeGenerator() gopter.Gen {
	if ipAddressOrRangeGenerator != nil {
		return ipAddressOrRangeGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRange(generators)
	ipAddressOrRangeGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange{}), generators)

	return ipAddressOrRangeGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRange is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRange(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpAddressOrRange_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpAddressOrRange_Status to IpAddressOrRange_Status via AssignPropertiesToIpAddressOrRange_Status & AssignPropertiesFromIpAddressOrRange_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpAddressOrRange_Status, IpAddressOrRange_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpAddressOrRange_Status tests if a specific instance of IpAddressOrRange_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIpAddressOrRange_Status(subject IpAddressOrRange_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.IpAddressOrRange_Status
	err := copied.AssignPropertiesToIpAddressOrRange_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpAddressOrRange_Status
	err = actual.AssignPropertiesFromIpAddressOrRange_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpAddressOrRange_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRange_Status, IpAddressOrRange_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRange_Status runs a test to see if a specific instance of IpAddressOrRange_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRange_Status(subject IpAddressOrRange_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange_Status instances for property testing - lazily instantiated by
//IpAddressOrRange_StatusGenerator()
var ipAddressOrRange_statusGenerator gopter.Gen

// IpAddressOrRange_StatusGenerator returns a generator of IpAddressOrRange_Status instances for property testing.
func IpAddressOrRange_StatusGenerator() gopter.Gen {
	if ipAddressOrRange_statusGenerator != nil {
		return ipAddressOrRange_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRange_Status(generators)
	ipAddressOrRange_statusGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange_Status{}), generators)

	return ipAddressOrRange_statusGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRange_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRange_Status(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Location to Location via AssignPropertiesToLocation & AssignPropertiesFromLocation returns original",
		prop.ForAll(RunPropertyAssignmentTestForLocation, LocationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLocation tests if a specific instance of Location can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForLocation(subject Location) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Location
	err := copied.AssignPropertiesToLocation(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Location
	err = actual.AssignPropertiesFromLocation(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Location_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocation, LocationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocation runs a test to see if a specific instance of Location round trips to JSON and back losslessly
func RunJSONSerializationTestForLocation(subject Location) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location instances for property testing - lazily instantiated by LocationGenerator()
var locationGenerator gopter.Gen

// LocationGenerator returns a generator of Location instances for property testing.
func LocationGenerator() gopter.Gen {
	if locationGenerator != nil {
		return locationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocation(generators)
	locationGenerator = gen.Struct(reflect.TypeOf(Location{}), generators)

	return locationGenerator
}

// AddIndependentPropertyGeneratorsForLocation is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocation(gens map[string]gopter.Gen) {
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Location_Status to Location_Status via AssignPropertiesToLocation_Status & AssignPropertiesFromLocation_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForLocation_Status, Location_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLocation_Status tests if a specific instance of Location_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForLocation_Status(subject Location_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Location_Status
	err := copied.AssignPropertiesToLocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Location_Status
	err = actual.AssignPropertiesFromLocation_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Location_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocation_Status, Location_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocation_Status runs a test to see if a specific instance of Location_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLocation_Status(subject Location_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location_Status instances for property testing - lazily instantiated by Location_StatusGenerator()
var location_statusGenerator gopter.Gen

// Location_StatusGenerator returns a generator of Location_Status instances for property testing.
func Location_StatusGenerator() gopter.Gen {
	if location_statusGenerator != nil {
		return location_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocation_Status(generators)
	location_statusGenerator = gen.Struct(reflect.TypeOf(Location_Status{}), generators)

	return location_statusGenerator
}

// AddIndependentPropertyGeneratorsForLocation_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocation_Status(gens map[string]gopter.Gen) {
	gens["DocumentEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity to ManagedServiceIdentity via AssignPropertiesToManagedServiceIdentity & AssignPropertiesFromManagedServiceIdentity returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity tests if a specific instance of ManagedServiceIdentity can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ManagedServiceIdentity
	err := copied.AssignPropertiesToManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity
	err = actual.AssignPropertiesFromManagedServiceIdentity(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity, ManagedServiceIdentityGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity runs a test to see if a specific instance of ManagedServiceIdentity round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity(subject ManagedServiceIdentity) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity instances for property testing - lazily instantiated by
//ManagedServiceIdentityGenerator()
var managedServiceIdentityGenerator gopter.Gen

// ManagedServiceIdentityGenerator returns a generator of ManagedServiceIdentity instances for property testing.
func ManagedServiceIdentityGenerator() gopter.Gen {
	if managedServiceIdentityGenerator != nil {
		return managedServiceIdentityGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity(generators)
	managedServiceIdentityGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity{}), generators)

	return managedServiceIdentityGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityTypeNone,
		ManagedServiceIdentityTypeSystemAssigned,
		ManagedServiceIdentityTypeSystemAssignedUserAssigned,
		ManagedServiceIdentityTypeUserAssigned))
}

func Test_ManagedServiceIdentity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_Status to ManagedServiceIdentity_Status via AssignPropertiesToManagedServiceIdentity_Status & AssignPropertiesFromManagedServiceIdentity_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity_Status, ManagedServiceIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity_Status tests if a specific instance of ManagedServiceIdentity_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity_Status(subject ManagedServiceIdentity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ManagedServiceIdentity_Status
	err := copied.AssignPropertiesToManagedServiceIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_Status
	err = actual.AssignPropertiesFromManagedServiceIdentity_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_Status, ManagedServiceIdentity_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_Status runs a test to see if a specific instance of ManagedServiceIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_Status(subject ManagedServiceIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_Status instances for property testing - lazily instantiated by
//ManagedServiceIdentity_StatusGenerator()
var managedServiceIdentity_statusGenerator gopter.Gen

// ManagedServiceIdentity_StatusGenerator returns a generator of ManagedServiceIdentity_Status instances for property testing.
// We first initialize managedServiceIdentity_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_StatusGenerator() gopter.Gen {
	if managedServiceIdentity_statusGenerator != nil {
		return managedServiceIdentity_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_Status(generators)
	managedServiceIdentity_statusGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_Status(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_Status(generators)
	managedServiceIdentity_statusGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Status{}), generators)

	return managedServiceIdentity_statusGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_Status(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_Status(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), ManagedServiceIdentity_StatusUserAssignedIdentitiesGenerator())
}

func Test_VirtualNetworkRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkRule to VirtualNetworkRule via AssignPropertiesToVirtualNetworkRule & AssignPropertiesFromVirtualNetworkRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkRule, VirtualNetworkRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkRule tests if a specific instance of VirtualNetworkRule can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkRule(subject VirtualNetworkRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.VirtualNetworkRule
	err := copied.AssignPropertiesToVirtualNetworkRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkRule
	err = actual.AssignPropertiesFromVirtualNetworkRule(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule, VirtualNetworkRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule runs a test to see if a specific instance of VirtualNetworkRule round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule(subject VirtualNetworkRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule instances for property testing - lazily instantiated by VirtualNetworkRuleGenerator()
var virtualNetworkRuleGenerator gopter.Gen

// VirtualNetworkRuleGenerator returns a generator of VirtualNetworkRule instances for property testing.
func VirtualNetworkRuleGenerator() gopter.Gen {
	if virtualNetworkRuleGenerator != nil {
		return virtualNetworkRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule(generators)
	virtualNetworkRuleGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule{}), generators)

	return virtualNetworkRuleGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule(gens map[string]gopter.Gen) {
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}

func Test_VirtualNetworkRule_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkRule_Status to VirtualNetworkRule_Status via AssignPropertiesToVirtualNetworkRule_Status & AssignPropertiesFromVirtualNetworkRule_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkRule_Status, VirtualNetworkRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkRule_Status tests if a specific instance of VirtualNetworkRule_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkRule_Status(subject VirtualNetworkRule_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.VirtualNetworkRule_Status
	err := copied.AssignPropertiesToVirtualNetworkRule_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkRule_Status
	err = actual.AssignPropertiesFromVirtualNetworkRule_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_Status, VirtualNetworkRule_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_Status runs a test to see if a specific instance of VirtualNetworkRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_Status(subject VirtualNetworkRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_Status instances for property testing - lazily instantiated by
//VirtualNetworkRule_StatusGenerator()
var virtualNetworkRule_statusGenerator gopter.Gen

// VirtualNetworkRule_StatusGenerator returns a generator of VirtualNetworkRule_Status instances for property testing.
func VirtualNetworkRule_StatusGenerator() gopter.Gen {
	if virtualNetworkRule_statusGenerator != nil {
		return virtualNetworkRule_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_Status(generators)
	virtualNetworkRule_statusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_Status{}), generators)

	return virtualNetworkRule_statusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}

func Test_ManagedServiceIdentity_StatusUserAssignedIdentities_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_StatusUserAssignedIdentities to ManagedServiceIdentity_StatusUserAssignedIdentities via AssignPropertiesToManagedServiceIdentity_StatusUserAssignedIdentities & AssignPropertiesFromManagedServiceIdentity_StatusUserAssignedIdentities returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentity_StatusUserAssignedIdentities, ManagedServiceIdentity_StatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentity_StatusUserAssignedIdentities tests if a specific instance of ManagedServiceIdentity_StatusUserAssignedIdentities can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentity_StatusUserAssignedIdentities(subject ManagedServiceIdentity_StatusUserAssignedIdentities) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ManagedServiceIdentity_StatusUserAssignedIdentities
	err := copied.AssignPropertiesToManagedServiceIdentity_StatusUserAssignedIdentities(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_StatusUserAssignedIdentities
	err = actual.AssignPropertiesFromManagedServiceIdentity_StatusUserAssignedIdentities(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_StatusUserAssignedIdentities_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_StatusUserAssignedIdentities via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_StatusUserAssignedIdentities, ManagedServiceIdentity_StatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_StatusUserAssignedIdentities runs a test to see if a specific instance of ManagedServiceIdentity_StatusUserAssignedIdentities round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_StatusUserAssignedIdentities(subject ManagedServiceIdentity_StatusUserAssignedIdentities) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_StatusUserAssignedIdentities
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_StatusUserAssignedIdentities instances for property testing - lazily instantiated
//by ManagedServiceIdentity_StatusUserAssignedIdentitiesGenerator()
var managedServiceIdentity_statusUserAssignedIdentitiesGenerator gopter.Gen

// ManagedServiceIdentity_StatusUserAssignedIdentitiesGenerator returns a generator of ManagedServiceIdentity_StatusUserAssignedIdentities instances for property testing.
func ManagedServiceIdentity_StatusUserAssignedIdentitiesGenerator() gopter.Gen {
	if managedServiceIdentity_statusUserAssignedIdentitiesGenerator != nil {
		return managedServiceIdentity_statusUserAssignedIdentitiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_StatusUserAssignedIdentities(generators)
	managedServiceIdentity_statusUserAssignedIdentitiesGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_StatusUserAssignedIdentities{}), generators)

	return managedServiceIdentity_statusUserAssignedIdentitiesGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_StatusUserAssignedIdentities is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_StatusUserAssignedIdentities(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}
