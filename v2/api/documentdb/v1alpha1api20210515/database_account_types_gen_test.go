// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/documentdb/v1alpha1api20210515storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DatabaseAccount_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccount to hub returns original",
		prop.ForAll(RunResourceConversionTestForDatabaseAccount, DatabaseAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForDatabaseAccount tests if a specific instance of DatabaseAccount round trips to the hub storage version and back losslessly
func RunResourceConversionTestForDatabaseAccount(subject DatabaseAccount) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20210515storage.DatabaseAccount
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual DatabaseAccount
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccount_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccount to DatabaseAccount via AssignPropertiesToDatabaseAccount & AssignPropertiesFromDatabaseAccount returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatabaseAccount, DatabaseAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatabaseAccount tests if a specific instance of DatabaseAccount can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForDatabaseAccount(subject DatabaseAccount) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.DatabaseAccount
	err := copied.AssignPropertiesToDatabaseAccount(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatabaseAccount
	err = actual.AssignPropertiesFromDatabaseAccount(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccount_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccount via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccount, DatabaseAccountGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccount runs a test to see if a specific instance of DatabaseAccount round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccount(subject DatabaseAccount) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccount
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccount instances for property testing - lazily instantiated by DatabaseAccountGenerator()
var databaseAccountGenerator gopter.Gen

// DatabaseAccountGenerator returns a generator of DatabaseAccount instances for property testing.
func DatabaseAccountGenerator() gopter.Gen {
	if databaseAccountGenerator != nil {
		return databaseAccountGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDatabaseAccount(generators)
	databaseAccountGenerator = gen.Struct(reflect.TypeOf(DatabaseAccount{}), generators)

	return databaseAccountGenerator
}

// AddRelatedPropertyGeneratorsForDatabaseAccount is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccount(gens map[string]gopter.Gen) {
	gens["Spec"] = DatabaseAccountsSPECGenerator()
	gens["Status"] = DatabaseAccountCreateUpdateParametersStatusGenerator()
}

func Test_DatabaseAccountCreateUpdateParameters_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccountCreateUpdateParameters_Status to DatabaseAccountCreateUpdateParameters_Status via AssignPropertiesToDatabaseAccountCreateUpdateParametersStatus & AssignPropertiesFromDatabaseAccountCreateUpdateParametersStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatabaseAccountCreateUpdateParametersStatus, DatabaseAccountCreateUpdateParametersStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatabaseAccountCreateUpdateParametersStatus tests if a specific instance of DatabaseAccountCreateUpdateParameters_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForDatabaseAccountCreateUpdateParametersStatus(subject DatabaseAccountCreateUpdateParameters_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.DatabaseAccountCreateUpdateParameters_Status
	err := copied.AssignPropertiesToDatabaseAccountCreateUpdateParametersStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatabaseAccountCreateUpdateParameters_Status
	err = actual.AssignPropertiesFromDatabaseAccountCreateUpdateParametersStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccountCreateUpdateParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountCreateUpdateParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountCreateUpdateParametersStatus, DatabaseAccountCreateUpdateParametersStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountCreateUpdateParametersStatus runs a test to see if a specific instance of DatabaseAccountCreateUpdateParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountCreateUpdateParametersStatus(subject DatabaseAccountCreateUpdateParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountCreateUpdateParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountCreateUpdateParameters_Status instances for property testing - lazily instantiated by
//DatabaseAccountCreateUpdateParametersStatusGenerator()
var databaseAccountCreateUpdateParametersStatusGenerator gopter.Gen

// DatabaseAccountCreateUpdateParametersStatusGenerator returns a generator of DatabaseAccountCreateUpdateParameters_Status instances for property testing.
// We first initialize databaseAccountCreateUpdateParametersStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountCreateUpdateParametersStatusGenerator() gopter.Gen {
	if databaseAccountCreateUpdateParametersStatusGenerator != nil {
		return databaseAccountCreateUpdateParametersStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdateParametersStatus(generators)
	databaseAccountCreateUpdateParametersStatusGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountCreateUpdateParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdateParametersStatus(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountCreateUpdateParametersStatus(generators)
	databaseAccountCreateUpdateParametersStatusGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountCreateUpdateParameters_Status{}), generators)

	return databaseAccountCreateUpdateParametersStatusGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdateParametersStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountCreateUpdateParametersStatus(gens map[string]gopter.Gen) {
	gens["ConnectorOffer"] = gen.PtrOf(gen.OneConstOf(ConnectorOffer_StatusSmall))
	gens["DatabaseAccountOfferType"] = gen.PtrOf(gen.OneConstOf(DatabaseAccountOfferType_StatusStandard))
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(DatabaseAccountCreateUpdateParametersStatusKindGlobalDocumentDB, DatabaseAccountCreateUpdateParametersStatusKindMongoDB, DatabaseAccountCreateUpdateParametersStatusKindParse))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.OneConstOf(NetworkAclBypass_StatusAzureServices, NetworkAclBypass_StatusNone))
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccess_StatusDisabled, PublicNetworkAccess_StatusEnabled))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountCreateUpdateParametersStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountCreateUpdateParametersStatus(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfigurationStatusGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiPropertiesStatusGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicyStatusGenerator())
	gens["Capabilities"] = gen.SliceOf(CapabilityStatusGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicyStatusGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicyStatusGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityStatusGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRangeStatusGenerator())
	gens["Locations"] = gen.SliceOf(LocationStatusGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleStatusGenerator())
}

func Test_DatabaseAccounts_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccounts_SPEC to DatabaseAccounts_SPEC via AssignPropertiesToDatabaseAccountsSPEC & AssignPropertiesFromDatabaseAccountsSPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatabaseAccountsSPEC, DatabaseAccountsSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatabaseAccountsSPEC tests if a specific instance of DatabaseAccounts_SPEC can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForDatabaseAccountsSPEC(subject DatabaseAccounts_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.DatabaseAccounts_SPEC
	err := copied.AssignPropertiesToDatabaseAccountsSPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatabaseAccounts_SPEC
	err = actual.AssignPropertiesFromDatabaseAccountsSPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccounts_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccounts_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountsSPEC, DatabaseAccountsSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountsSPEC runs a test to see if a specific instance of DatabaseAccounts_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountsSPEC(subject DatabaseAccounts_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccounts_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccounts_SPEC instances for property testing - lazily instantiated by
//DatabaseAccountsSPECGenerator()
var databaseAccountsSPECGenerator gopter.Gen

// DatabaseAccountsSPECGenerator returns a generator of DatabaseAccounts_SPEC instances for property testing.
// We first initialize databaseAccountsSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountsSPECGenerator() gopter.Gen {
	if databaseAccountsSPECGenerator != nil {
		return databaseAccountsSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsSPEC(generators)
	databaseAccountsSPECGenerator = gen.Struct(reflect.TypeOf(DatabaseAccounts_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsSPEC(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountsSPEC(generators)
	databaseAccountsSPECGenerator = gen.Struct(reflect.TypeOf(DatabaseAccounts_SPEC{}), generators)

	return databaseAccountsSPECGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountsSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountsSPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["ConnectorOffer"] = gen.PtrOf(gen.OneConstOf(ConnectorOffer_SpecSmall))
	gens["DatabaseAccountOfferType"] = gen.OneConstOf(DatabaseAccountOfferType_SpecStandard)
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(DatabaseAccountsSPECKindGlobalDocumentDB, DatabaseAccountsSPECKindMongoDB, DatabaseAccountsSPECKindParse))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.OneConstOf(NetworkAclBypass_SpecAzureServices, NetworkAclBypass_SpecNone))
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccess_SpecDisabled, PublicNetworkAccess_SpecEnabled))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountsSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountsSPEC(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfigurationSpecGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiPropertiesSpecGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicySpecGenerator())
	gens["Capabilities"] = gen.SliceOf(CapabilitySpecGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicySpecGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicySpecGenerator())
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentitySpecGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRangeSpecGenerator())
	gens["Locations"] = gen.SliceOf(LocationSpecGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleSpecGenerator())
}

func Test_AnalyticalStorageConfiguration_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AnalyticalStorageConfiguration_Spec to AnalyticalStorageConfiguration_Spec via AssignPropertiesToAnalyticalStorageConfigurationSpec & AssignPropertiesFromAnalyticalStorageConfigurationSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForAnalyticalStorageConfigurationSpec, AnalyticalStorageConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAnalyticalStorageConfigurationSpec tests if a specific instance of AnalyticalStorageConfiguration_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForAnalyticalStorageConfigurationSpec(subject AnalyticalStorageConfiguration_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.AnalyticalStorageConfiguration_Spec
	err := copied.AssignPropertiesToAnalyticalStorageConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AnalyticalStorageConfiguration_Spec
	err = actual.AssignPropertiesFromAnalyticalStorageConfigurationSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AnalyticalStorageConfiguration_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfigurationSpec, AnalyticalStorageConfigurationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfigurationSpec runs a test to see if a specific instance of AnalyticalStorageConfiguration_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfigurationSpec(subject AnalyticalStorageConfiguration_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration_Spec instances for property testing - lazily instantiated by
//AnalyticalStorageConfigurationSpecGenerator()
var analyticalStorageConfigurationSpecGenerator gopter.Gen

// AnalyticalStorageConfigurationSpecGenerator returns a generator of AnalyticalStorageConfiguration_Spec instances for property testing.
func AnalyticalStorageConfigurationSpecGenerator() gopter.Gen {
	if analyticalStorageConfigurationSpecGenerator != nil {
		return analyticalStorageConfigurationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationSpec(generators)
	analyticalStorageConfigurationSpecGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration_Spec{}), generators)

	return analyticalStorageConfigurationSpecGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationSpec(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.OneConstOf(AnalyticalStorageSchemaType_SpecFullFidelity, AnalyticalStorageSchemaType_SpecWellDefined))
}

func Test_AnalyticalStorageConfiguration_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from AnalyticalStorageConfiguration_Status to AnalyticalStorageConfiguration_Status via AssignPropertiesToAnalyticalStorageConfigurationStatus & AssignPropertiesFromAnalyticalStorageConfigurationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForAnalyticalStorageConfigurationStatus, AnalyticalStorageConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForAnalyticalStorageConfigurationStatus tests if a specific instance of AnalyticalStorageConfiguration_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForAnalyticalStorageConfigurationStatus(subject AnalyticalStorageConfiguration_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.AnalyticalStorageConfiguration_Status
	err := copied.AssignPropertiesToAnalyticalStorageConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual AnalyticalStorageConfiguration_Status
	err = actual.AssignPropertiesFromAnalyticalStorageConfigurationStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_AnalyticalStorageConfiguration_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfigurationStatus, AnalyticalStorageConfigurationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfigurationStatus runs a test to see if a specific instance of AnalyticalStorageConfiguration_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfigurationStatus(subject AnalyticalStorageConfiguration_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration_Status instances for property testing - lazily instantiated by
//AnalyticalStorageConfigurationStatusGenerator()
var analyticalStorageConfigurationStatusGenerator gopter.Gen

// AnalyticalStorageConfigurationStatusGenerator returns a generator of AnalyticalStorageConfiguration_Status instances for property testing.
func AnalyticalStorageConfigurationStatusGenerator() gopter.Gen {
	if analyticalStorageConfigurationStatusGenerator != nil {
		return analyticalStorageConfigurationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationStatus(generators)
	analyticalStorageConfigurationStatusGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration_Status{}), generators)

	return analyticalStorageConfigurationStatusGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationStatus(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.OneConstOf(AnalyticalStorageSchemaType_StatusFullFidelity, AnalyticalStorageSchemaType_StatusWellDefined))
}

func Test_ApiProperties_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiProperties_Spec to ApiProperties_Spec via AssignPropertiesToApiPropertiesSpec & AssignPropertiesFromApiPropertiesSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiPropertiesSpec, ApiPropertiesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiPropertiesSpec tests if a specific instance of ApiProperties_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForApiPropertiesSpec(subject ApiProperties_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ApiProperties_Spec
	err := copied.AssignPropertiesToApiPropertiesSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiProperties_Spec
	err = actual.AssignPropertiesFromApiPropertiesSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiProperties_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiPropertiesSpec, ApiPropertiesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiPropertiesSpec runs a test to see if a specific instance of ApiProperties_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForApiPropertiesSpec(subject ApiProperties_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_Spec instances for property testing - lazily instantiated by ApiPropertiesSpecGenerator()
var apiPropertiesSpecGenerator gopter.Gen

// ApiPropertiesSpecGenerator returns a generator of ApiProperties_Spec instances for property testing.
func ApiPropertiesSpecGenerator() gopter.Gen {
	if apiPropertiesSpecGenerator != nil {
		return apiPropertiesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiPropertiesSpec(generators)
	apiPropertiesSpecGenerator = gen.Struct(reflect.TypeOf(ApiProperties_Spec{}), generators)

	return apiPropertiesSpecGenerator
}

// AddIndependentPropertyGeneratorsForApiPropertiesSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiPropertiesSpec(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.OneConstOf(ApiPropertiesSpecServerVersion32, ApiPropertiesSpecServerVersion36, ApiPropertiesSpecServerVersion40))
}

func Test_ApiProperties_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ApiProperties_Status to ApiProperties_Status via AssignPropertiesToApiPropertiesStatus & AssignPropertiesFromApiPropertiesStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForApiPropertiesStatus, ApiPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForApiPropertiesStatus tests if a specific instance of ApiProperties_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForApiPropertiesStatus(subject ApiProperties_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ApiProperties_Status
	err := copied.AssignPropertiesToApiPropertiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ApiProperties_Status
	err = actual.AssignPropertiesFromApiPropertiesStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ApiProperties_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiPropertiesStatus, ApiPropertiesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiPropertiesStatus runs a test to see if a specific instance of ApiProperties_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForApiPropertiesStatus(subject ApiProperties_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_Status instances for property testing - lazily instantiated by
//ApiPropertiesStatusGenerator()
var apiPropertiesStatusGenerator gopter.Gen

// ApiPropertiesStatusGenerator returns a generator of ApiProperties_Status instances for property testing.
func ApiPropertiesStatusGenerator() gopter.Gen {
	if apiPropertiesStatusGenerator != nil {
		return apiPropertiesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiPropertiesStatus(generators)
	apiPropertiesStatusGenerator = gen.Struct(reflect.TypeOf(ApiProperties_Status{}), generators)

	return apiPropertiesStatusGenerator
}

// AddIndependentPropertyGeneratorsForApiPropertiesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiPropertiesStatus(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.OneConstOf(ApiPropertiesStatusServerVersion32, ApiPropertiesStatusServerVersion36, ApiPropertiesStatusServerVersion40))
}

func Test_BackupPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackupPolicy_Spec to BackupPolicy_Spec via AssignPropertiesToBackupPolicySpec & AssignPropertiesFromBackupPolicySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackupPolicySpec, BackupPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackupPolicySpec tests if a specific instance of BackupPolicy_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForBackupPolicySpec(subject BackupPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.BackupPolicy_Spec
	err := copied.AssignPropertiesToBackupPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackupPolicy_Spec
	err = actual.AssignPropertiesFromBackupPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackupPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicySpec, BackupPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicySpec runs a test to see if a specific instance of BackupPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicySpec(subject BackupPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_Spec instances for property testing - lazily instantiated by BackupPolicySpecGenerator()
var backupPolicySpecGenerator gopter.Gen

// BackupPolicySpecGenerator returns a generator of BackupPolicy_Spec instances for property testing.
func BackupPolicySpecGenerator() gopter.Gen {
	if backupPolicySpecGenerator != nil {
		return backupPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicySpec(generators)
	backupPolicySpecGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_Spec{}), generators)

	return backupPolicySpecGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicySpec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(BackupPolicyType_SpecContinuous, BackupPolicyType_SpecPeriodic)
}

func Test_BackupPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from BackupPolicy_Status to BackupPolicy_Status via AssignPropertiesToBackupPolicyStatus & AssignPropertiesFromBackupPolicyStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForBackupPolicyStatus, BackupPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForBackupPolicyStatus tests if a specific instance of BackupPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForBackupPolicyStatus(subject BackupPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.BackupPolicy_Status
	err := copied.AssignPropertiesToBackupPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual BackupPolicy_Status
	err = actual.AssignPropertiesFromBackupPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_BackupPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicyStatus, BackupPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicyStatus runs a test to see if a specific instance of BackupPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicyStatus(subject BackupPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_Status instances for property testing - lazily instantiated by BackupPolicyStatusGenerator()
var backupPolicyStatusGenerator gopter.Gen

// BackupPolicyStatusGenerator returns a generator of BackupPolicy_Status instances for property testing.
func BackupPolicyStatusGenerator() gopter.Gen {
	if backupPolicyStatusGenerator != nil {
		return backupPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicyStatus(generators)
	backupPolicyStatusGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_Status{}), generators)

	return backupPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicyStatus(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(BackupPolicyType_StatusContinuous, BackupPolicyType_StatusPeriodic)
}

func Test_Capability_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Capability_Spec to Capability_Spec via AssignPropertiesToCapabilitySpec & AssignPropertiesFromCapabilitySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForCapabilitySpec, CapabilitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCapabilitySpec tests if a specific instance of Capability_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCapabilitySpec(subject Capability_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Capability_Spec
	err := copied.AssignPropertiesToCapabilitySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Capability_Spec
	err = actual.AssignPropertiesFromCapabilitySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Capability_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapabilitySpec, CapabilitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapabilitySpec runs a test to see if a specific instance of Capability_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCapabilitySpec(subject Capability_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability_Spec instances for property testing - lazily instantiated by CapabilitySpecGenerator()
var capabilitySpecGenerator gopter.Gen

// CapabilitySpecGenerator returns a generator of Capability_Spec instances for property testing.
func CapabilitySpecGenerator() gopter.Gen {
	if capabilitySpecGenerator != nil {
		return capabilitySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapabilitySpec(generators)
	capabilitySpecGenerator = gen.Struct(reflect.TypeOf(Capability_Spec{}), generators)

	return capabilitySpecGenerator
}

// AddIndependentPropertyGeneratorsForCapabilitySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapabilitySpec(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_Capability_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Capability_Status to Capability_Status via AssignPropertiesToCapabilityStatus & AssignPropertiesFromCapabilityStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForCapabilityStatus, CapabilityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCapabilityStatus tests if a specific instance of Capability_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCapabilityStatus(subject Capability_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Capability_Status
	err := copied.AssignPropertiesToCapabilityStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Capability_Status
	err = actual.AssignPropertiesFromCapabilityStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Capability_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapabilityStatus, CapabilityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapabilityStatus runs a test to see if a specific instance of Capability_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCapabilityStatus(subject Capability_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability_Status instances for property testing - lazily instantiated by CapabilityStatusGenerator()
var capabilityStatusGenerator gopter.Gen

// CapabilityStatusGenerator returns a generator of Capability_Status instances for property testing.
func CapabilityStatusGenerator() gopter.Gen {
	if capabilityStatusGenerator != nil {
		return capabilityStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapabilityStatus(generators)
	capabilityStatusGenerator = gen.Struct(reflect.TypeOf(Capability_Status{}), generators)

	return capabilityStatusGenerator
}

// AddIndependentPropertyGeneratorsForCapabilityStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapabilityStatus(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ConsistencyPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConsistencyPolicy_Spec to ConsistencyPolicy_Spec via AssignPropertiesToConsistencyPolicySpec & AssignPropertiesFromConsistencyPolicySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForConsistencyPolicySpec, ConsistencyPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConsistencyPolicySpec tests if a specific instance of ConsistencyPolicy_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForConsistencyPolicySpec(subject ConsistencyPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ConsistencyPolicy_Spec
	err := copied.AssignPropertiesToConsistencyPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConsistencyPolicy_Spec
	err = actual.AssignPropertiesFromConsistencyPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConsistencyPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicySpec, ConsistencyPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicySpec runs a test to see if a specific instance of ConsistencyPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicySpec(subject ConsistencyPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy_Spec instances for property testing - lazily instantiated by
//ConsistencyPolicySpecGenerator()
var consistencyPolicySpecGenerator gopter.Gen

// ConsistencyPolicySpecGenerator returns a generator of ConsistencyPolicy_Spec instances for property testing.
func ConsistencyPolicySpecGenerator() gopter.Gen {
	if consistencyPolicySpecGenerator != nil {
		return consistencyPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicySpec(generators)
	consistencyPolicySpecGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy_Spec{}), generators)

	return consistencyPolicySpecGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicySpec(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.OneConstOf(
		ConsistencyPolicySpecDefaultConsistencyLevelBoundedStaleness,
		ConsistencyPolicySpecDefaultConsistencyLevelConsistentPrefix,
		ConsistencyPolicySpecDefaultConsistencyLevelEventual,
		ConsistencyPolicySpecDefaultConsistencyLevelSession,
		ConsistencyPolicySpecDefaultConsistencyLevelStrong)
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_ConsistencyPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConsistencyPolicy_Status to ConsistencyPolicy_Status via AssignPropertiesToConsistencyPolicyStatus & AssignPropertiesFromConsistencyPolicyStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForConsistencyPolicyStatus, ConsistencyPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConsistencyPolicyStatus tests if a specific instance of ConsistencyPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForConsistencyPolicyStatus(subject ConsistencyPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ConsistencyPolicy_Status
	err := copied.AssignPropertiesToConsistencyPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConsistencyPolicy_Status
	err = actual.AssignPropertiesFromConsistencyPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConsistencyPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicyStatus, ConsistencyPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicyStatus runs a test to see if a specific instance of ConsistencyPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicyStatus(subject ConsistencyPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy_Status instances for property testing - lazily instantiated by
//ConsistencyPolicyStatusGenerator()
var consistencyPolicyStatusGenerator gopter.Gen

// ConsistencyPolicyStatusGenerator returns a generator of ConsistencyPolicy_Status instances for property testing.
func ConsistencyPolicyStatusGenerator() gopter.Gen {
	if consistencyPolicyStatusGenerator != nil {
		return consistencyPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicyStatus(generators)
	consistencyPolicyStatusGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy_Status{}), generators)

	return consistencyPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicyStatus(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.OneConstOf(
		ConsistencyPolicyStatusDefaultConsistencyLevelBoundedStaleness,
		ConsistencyPolicyStatusDefaultConsistencyLevelConsistentPrefix,
		ConsistencyPolicyStatusDefaultConsistencyLevelEventual,
		ConsistencyPolicyStatusDefaultConsistencyLevelSession,
		ConsistencyPolicyStatusDefaultConsistencyLevelStrong)
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CorsPolicy_Spec to CorsPolicy_Spec via AssignPropertiesToCorsPolicySpec & AssignPropertiesFromCorsPolicySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForCorsPolicySpec, CorsPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCorsPolicySpec tests if a specific instance of CorsPolicy_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCorsPolicySpec(subject CorsPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.CorsPolicy_Spec
	err := copied.AssignPropertiesToCorsPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CorsPolicy_Spec
	err = actual.AssignPropertiesFromCorsPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CorsPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicySpec, CorsPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicySpec runs a test to see if a specific instance of CorsPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicySpec(subject CorsPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_Spec instances for property testing - lazily instantiated by CorsPolicySpecGenerator()
var corsPolicySpecGenerator gopter.Gen

// CorsPolicySpecGenerator returns a generator of CorsPolicy_Spec instances for property testing.
func CorsPolicySpecGenerator() gopter.Gen {
	if corsPolicySpecGenerator != nil {
		return corsPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicySpec(generators)
	corsPolicySpecGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_Spec{}), generators)

	return corsPolicySpecGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicySpec(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.AlphaString()
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CorsPolicy_Status to CorsPolicy_Status via AssignPropertiesToCorsPolicyStatus & AssignPropertiesFromCorsPolicyStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForCorsPolicyStatus, CorsPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCorsPolicyStatus tests if a specific instance of CorsPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCorsPolicyStatus(subject CorsPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.CorsPolicy_Status
	err := copied.AssignPropertiesToCorsPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CorsPolicy_Status
	err = actual.AssignPropertiesFromCorsPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CorsPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicyStatus, CorsPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicyStatus runs a test to see if a specific instance of CorsPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicyStatus(subject CorsPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_Status instances for property testing - lazily instantiated by CorsPolicyStatusGenerator()
var corsPolicyStatusGenerator gopter.Gen

// CorsPolicyStatusGenerator returns a generator of CorsPolicy_Status instances for property testing.
func CorsPolicyStatusGenerator() gopter.Gen {
	if corsPolicyStatusGenerator != nil {
		return corsPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicyStatus(generators)
	corsPolicyStatusGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_Status{}), generators)

	return corsPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicyStatus(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.AlphaString()
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_IpAddressOrRange_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpAddressOrRange_Spec to IpAddressOrRange_Spec via AssignPropertiesToIpAddressOrRangeSpec & AssignPropertiesFromIpAddressOrRangeSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpAddressOrRangeSpec, IpAddressOrRangeSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpAddressOrRangeSpec tests if a specific instance of IpAddressOrRange_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIpAddressOrRangeSpec(subject IpAddressOrRange_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.IpAddressOrRange_Spec
	err := copied.AssignPropertiesToIpAddressOrRangeSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpAddressOrRange_Spec
	err = actual.AssignPropertiesFromIpAddressOrRangeSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpAddressOrRange_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRangeSpec, IpAddressOrRangeSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRangeSpec runs a test to see if a specific instance of IpAddressOrRange_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRangeSpec(subject IpAddressOrRange_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange_Spec instances for property testing - lazily instantiated by
//IpAddressOrRangeSpecGenerator()
var ipAddressOrRangeSpecGenerator gopter.Gen

// IpAddressOrRangeSpecGenerator returns a generator of IpAddressOrRange_Spec instances for property testing.
func IpAddressOrRangeSpecGenerator() gopter.Gen {
	if ipAddressOrRangeSpecGenerator != nil {
		return ipAddressOrRangeSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRangeSpec(generators)
	ipAddressOrRangeSpecGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange_Spec{}), generators)

	return ipAddressOrRangeSpecGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRangeSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRangeSpec(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpAddressOrRange_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IpAddressOrRange_Status to IpAddressOrRange_Status via AssignPropertiesToIpAddressOrRangeStatus & AssignPropertiesFromIpAddressOrRangeStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForIpAddressOrRangeStatus, IpAddressOrRangeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIpAddressOrRangeStatus tests if a specific instance of IpAddressOrRange_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIpAddressOrRangeStatus(subject IpAddressOrRange_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.IpAddressOrRange_Status
	err := copied.AssignPropertiesToIpAddressOrRangeStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IpAddressOrRange_Status
	err = actual.AssignPropertiesFromIpAddressOrRangeStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IpAddressOrRange_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRangeStatus, IpAddressOrRangeStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRangeStatus runs a test to see if a specific instance of IpAddressOrRange_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRangeStatus(subject IpAddressOrRange_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange_Status instances for property testing - lazily instantiated by
//IpAddressOrRangeStatusGenerator()
var ipAddressOrRangeStatusGenerator gopter.Gen

// IpAddressOrRangeStatusGenerator returns a generator of IpAddressOrRange_Status instances for property testing.
func IpAddressOrRangeStatusGenerator() gopter.Gen {
	if ipAddressOrRangeStatusGenerator != nil {
		return ipAddressOrRangeStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRangeStatus(generators)
	ipAddressOrRangeStatusGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange_Status{}), generators)

	return ipAddressOrRangeStatusGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRangeStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRangeStatus(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Location_Spec to Location_Spec via AssignPropertiesToLocationSpec & AssignPropertiesFromLocationSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForLocationSpec, LocationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLocationSpec tests if a specific instance of Location_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForLocationSpec(subject Location_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Location_Spec
	err := copied.AssignPropertiesToLocationSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Location_Spec
	err = actual.AssignPropertiesFromLocationSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Location_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocationSpec, LocationSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocationSpec runs a test to see if a specific instance of Location_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLocationSpec(subject Location_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location_Spec instances for property testing - lazily instantiated by LocationSpecGenerator()
var locationSpecGenerator gopter.Gen

// LocationSpecGenerator returns a generator of Location_Spec instances for property testing.
func LocationSpecGenerator() gopter.Gen {
	if locationSpecGenerator != nil {
		return locationSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocationSpec(generators)
	locationSpecGenerator = gen.Struct(reflect.TypeOf(Location_Spec{}), generators)

	return locationSpecGenerator
}

// AddIndependentPropertyGeneratorsForLocationSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocationSpec(gens map[string]gopter.Gen) {
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Location_Status to Location_Status via AssignPropertiesToLocationStatus & AssignPropertiesFromLocationStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForLocationStatus, LocationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForLocationStatus tests if a specific instance of Location_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForLocationStatus(subject Location_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Location_Status
	err := copied.AssignPropertiesToLocationStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Location_Status
	err = actual.AssignPropertiesFromLocationStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Location_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocationStatus, LocationStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocationStatus runs a test to see if a specific instance of Location_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLocationStatus(subject Location_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location_Status instances for property testing - lazily instantiated by LocationStatusGenerator()
var locationStatusGenerator gopter.Gen

// LocationStatusGenerator returns a generator of Location_Status instances for property testing.
func LocationStatusGenerator() gopter.Gen {
	if locationStatusGenerator != nil {
		return locationStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocationStatus(generators)
	locationStatusGenerator = gen.Struct(reflect.TypeOf(Location_Status{}), generators)

	return locationStatusGenerator
}

// AddIndependentPropertyGeneratorsForLocationStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocationStatus(gens map[string]gopter.Gen) {
	gens["DocumentEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_Spec to ManagedServiceIdentity_Spec via AssignPropertiesToManagedServiceIdentitySpec & AssignPropertiesFromManagedServiceIdentitySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentitySpec, ManagedServiceIdentitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentitySpec tests if a specific instance of ManagedServiceIdentity_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentitySpec(subject ManagedServiceIdentity_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ManagedServiceIdentity_Spec
	err := copied.AssignPropertiesToManagedServiceIdentitySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_Spec
	err = actual.AssignPropertiesFromManagedServiceIdentitySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentitySpec, ManagedServiceIdentitySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentitySpec runs a test to see if a specific instance of ManagedServiceIdentity_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentitySpec(subject ManagedServiceIdentity_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_Spec instances for property testing - lazily instantiated by
//ManagedServiceIdentitySpecGenerator()
var managedServiceIdentitySpecGenerator gopter.Gen

// ManagedServiceIdentitySpecGenerator returns a generator of ManagedServiceIdentity_Spec instances for property testing.
func ManagedServiceIdentitySpecGenerator() gopter.Gen {
	if managedServiceIdentitySpecGenerator != nil {
		return managedServiceIdentitySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentitySpec(generators)
	managedServiceIdentitySpecGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Spec{}), generators)

	return managedServiceIdentitySpecGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentitySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentitySpec(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentitySpecTypeNone,
		ManagedServiceIdentitySpecTypeSystemAssigned,
		ManagedServiceIdentitySpecTypeSystemAssignedUserAssigned,
		ManagedServiceIdentitySpecTypeUserAssigned))
}

func Test_ManagedServiceIdentity_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_Status to ManagedServiceIdentity_Status via AssignPropertiesToManagedServiceIdentityStatus & AssignPropertiesFromManagedServiceIdentityStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentityStatus, ManagedServiceIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentityStatus tests if a specific instance of ManagedServiceIdentity_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentityStatus(subject ManagedServiceIdentity_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ManagedServiceIdentity_Status
	err := copied.AssignPropertiesToManagedServiceIdentityStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_Status
	err = actual.AssignPropertiesFromManagedServiceIdentityStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentityStatus, ManagedServiceIdentityStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentityStatus runs a test to see if a specific instance of ManagedServiceIdentity_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentityStatus(subject ManagedServiceIdentity_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_Status instances for property testing - lazily instantiated by
//ManagedServiceIdentityStatusGenerator()
var managedServiceIdentityStatusGenerator gopter.Gen

// ManagedServiceIdentityStatusGenerator returns a generator of ManagedServiceIdentity_Status instances for property testing.
// We first initialize managedServiceIdentityStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityStatusGenerator() gopter.Gen {
	if managedServiceIdentityStatusGenerator != nil {
		return managedServiceIdentityStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentityStatus(generators)
	managedServiceIdentityStatusGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentityStatus(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentityStatus(generators)
	managedServiceIdentityStatusGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Status{}), generators)

	return managedServiceIdentityStatusGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentityStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentityStatus(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentityStatusTypeNone,
		ManagedServiceIdentityStatusTypeSystemAssigned,
		ManagedServiceIdentityStatusTypeSystemAssignedUserAssigned,
		ManagedServiceIdentityStatusTypeUserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentityStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentityStatus(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), ManagedServiceIdentityStatusUserAssignedIdentitiesGenerator())
}

func Test_VirtualNetworkRule_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkRule_Spec to VirtualNetworkRule_Spec via AssignPropertiesToVirtualNetworkRuleSpec & AssignPropertiesFromVirtualNetworkRuleSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkRuleSpec, VirtualNetworkRuleSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkRuleSpec tests if a specific instance of VirtualNetworkRule_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkRuleSpec(subject VirtualNetworkRule_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.VirtualNetworkRule_Spec
	err := copied.AssignPropertiesToVirtualNetworkRuleSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkRule_Spec
	err = actual.AssignPropertiesFromVirtualNetworkRuleSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkRule_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleSpec, VirtualNetworkRuleSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleSpec runs a test to see if a specific instance of VirtualNetworkRule_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleSpec(subject VirtualNetworkRule_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_Spec instances for property testing - lazily instantiated by
//VirtualNetworkRuleSpecGenerator()
var virtualNetworkRuleSpecGenerator gopter.Gen

// VirtualNetworkRuleSpecGenerator returns a generator of VirtualNetworkRule_Spec instances for property testing.
func VirtualNetworkRuleSpecGenerator() gopter.Gen {
	if virtualNetworkRuleSpecGenerator != nil {
		return virtualNetworkRuleSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpec(generators)
	virtualNetworkRuleSpecGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_Spec{}), generators)

	return virtualNetworkRuleSpecGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleSpec(gens map[string]gopter.Gen) {
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}

func Test_VirtualNetworkRule_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from VirtualNetworkRule_Status to VirtualNetworkRule_Status via AssignPropertiesToVirtualNetworkRuleStatus & AssignPropertiesFromVirtualNetworkRuleStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForVirtualNetworkRuleStatus, VirtualNetworkRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForVirtualNetworkRuleStatus tests if a specific instance of VirtualNetworkRule_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForVirtualNetworkRuleStatus(subject VirtualNetworkRule_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.VirtualNetworkRule_Status
	err := copied.AssignPropertiesToVirtualNetworkRuleStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual VirtualNetworkRule_Status
	err = actual.AssignPropertiesFromVirtualNetworkRuleStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_VirtualNetworkRule_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleStatus, VirtualNetworkRuleStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleStatus runs a test to see if a specific instance of VirtualNetworkRule_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleStatus(subject VirtualNetworkRule_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_Status instances for property testing - lazily instantiated by
//VirtualNetworkRuleStatusGenerator()
var virtualNetworkRuleStatusGenerator gopter.Gen

// VirtualNetworkRuleStatusGenerator returns a generator of VirtualNetworkRule_Status instances for property testing.
func VirtualNetworkRuleStatusGenerator() gopter.Gen {
	if virtualNetworkRuleStatusGenerator != nil {
		return virtualNetworkRuleStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatus(generators)
	virtualNetworkRuleStatusGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_Status{}), generators)

	return virtualNetworkRuleStatusGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}

func Test_ManagedServiceIdentity_Status_UserAssignedIdentities_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ManagedServiceIdentity_Status_UserAssignedIdentities to ManagedServiceIdentity_Status_UserAssignedIdentities via AssignPropertiesToManagedServiceIdentityStatusUserAssignedIdentities & AssignPropertiesFromManagedServiceIdentityStatusUserAssignedIdentities returns original",
		prop.ForAll(RunPropertyAssignmentTestForManagedServiceIdentityStatusUserAssignedIdentities, ManagedServiceIdentityStatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForManagedServiceIdentityStatusUserAssignedIdentities tests if a specific instance of ManagedServiceIdentity_Status_UserAssignedIdentities can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForManagedServiceIdentityStatusUserAssignedIdentities(subject ManagedServiceIdentity_Status_UserAssignedIdentities) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ManagedServiceIdentity_Status_UserAssignedIdentities
	err := copied.AssignPropertiesToManagedServiceIdentityStatusUserAssignedIdentities(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ManagedServiceIdentity_Status_UserAssignedIdentities
	err = actual.AssignPropertiesFromManagedServiceIdentityStatusUserAssignedIdentities(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ManagedServiceIdentity_Status_UserAssignedIdentities_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_Status_UserAssignedIdentities via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentityStatusUserAssignedIdentities, ManagedServiceIdentityStatusUserAssignedIdentitiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentityStatusUserAssignedIdentities runs a test to see if a specific instance of ManagedServiceIdentity_Status_UserAssignedIdentities round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentityStatusUserAssignedIdentities(subject ManagedServiceIdentity_Status_UserAssignedIdentities) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_Status_UserAssignedIdentities
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_Status_UserAssignedIdentities instances for property testing - lazily
//instantiated by ManagedServiceIdentityStatusUserAssignedIdentitiesGenerator()
var managedServiceIdentityStatusUserAssignedIdentitiesGenerator gopter.Gen

// ManagedServiceIdentityStatusUserAssignedIdentitiesGenerator returns a generator of ManagedServiceIdentity_Status_UserAssignedIdentities instances for property testing.
func ManagedServiceIdentityStatusUserAssignedIdentitiesGenerator() gopter.Gen {
	if managedServiceIdentityStatusUserAssignedIdentitiesGenerator != nil {
		return managedServiceIdentityStatusUserAssignedIdentitiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentityStatusUserAssignedIdentities(generators)
	managedServiceIdentityStatusUserAssignedIdentitiesGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Status_UserAssignedIdentities{}), generators)

	return managedServiceIdentityStatusUserAssignedIdentitiesGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentityStatusUserAssignedIdentities is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentityStatusUserAssignedIdentities(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}
