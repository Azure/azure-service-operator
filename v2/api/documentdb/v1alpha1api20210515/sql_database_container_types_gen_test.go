// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/documentdb/v1alpha1api20210515storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_SqlDatabaseContainer_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SqlDatabaseContainer to hub returns original",
		prop.ForAll(RunResourceConversionTestForSqlDatabaseContainer, SqlDatabaseContainerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForSqlDatabaseContainer tests if a specific instance of SqlDatabaseContainer round trips to the hub storage version and back losslessly
func RunResourceConversionTestForSqlDatabaseContainer(subject SqlDatabaseContainer) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20210515storage.SqlDatabaseContainer
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual SqlDatabaseContainer
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SqlDatabaseContainer_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SqlDatabaseContainer to SqlDatabaseContainer via AssignPropertiesToSqlDatabaseContainer & AssignPropertiesFromSqlDatabaseContainer returns original",
		prop.ForAll(RunPropertyAssignmentTestForSqlDatabaseContainer, SqlDatabaseContainerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSqlDatabaseContainer tests if a specific instance of SqlDatabaseContainer can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForSqlDatabaseContainer(subject SqlDatabaseContainer) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.SqlDatabaseContainer
	err := copied.AssignPropertiesToSqlDatabaseContainer(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SqlDatabaseContainer
	err = actual.AssignPropertiesFromSqlDatabaseContainer(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SqlDatabaseContainer_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlDatabaseContainer via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlDatabaseContainer, SqlDatabaseContainerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlDatabaseContainer runs a test to see if a specific instance of SqlDatabaseContainer round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlDatabaseContainer(subject SqlDatabaseContainer) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlDatabaseContainer
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlDatabaseContainer instances for property testing - lazily instantiated by
//SqlDatabaseContainerGenerator()
var sqlDatabaseContainerGenerator gopter.Gen

// SqlDatabaseContainerGenerator returns a generator of SqlDatabaseContainer instances for property testing.
func SqlDatabaseContainerGenerator() gopter.Gen {
	if sqlDatabaseContainerGenerator != nil {
		return sqlDatabaseContainerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSqlDatabaseContainer(generators)
	sqlDatabaseContainerGenerator = gen.Struct(reflect.TypeOf(SqlDatabaseContainer{}), generators)

	return sqlDatabaseContainerGenerator
}

// AddRelatedPropertyGeneratorsForSqlDatabaseContainer is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlDatabaseContainer(gens map[string]gopter.Gen) {
	gens["Spec"] = DatabaseAccountsSqlDatabasesContainersSPECGenerator()
	gens["Status"] = SqlContainerCreateUpdateParametersStatusGenerator()
}

func Test_DatabaseAccountsSqlDatabasesContainers_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccountsSqlDatabasesContainers_SPEC to DatabaseAccountsSqlDatabasesContainers_SPEC via AssignPropertiesToDatabaseAccountsSqlDatabasesContainersSPEC & AssignPropertiesFromDatabaseAccountsSqlDatabasesContainersSPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatabaseAccountsSqlDatabasesContainersSPEC, DatabaseAccountsSqlDatabasesContainersSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatabaseAccountsSqlDatabasesContainersSPEC tests if a specific instance of DatabaseAccountsSqlDatabasesContainers_SPEC can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForDatabaseAccountsSqlDatabasesContainersSPEC(subject DatabaseAccountsSqlDatabasesContainers_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.DatabaseAccountsSqlDatabasesContainers_SPEC
	err := copied.AssignPropertiesToDatabaseAccountsSqlDatabasesContainersSPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatabaseAccountsSqlDatabasesContainers_SPEC
	err = actual.AssignPropertiesFromDatabaseAccountsSqlDatabasesContainersSPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccountsSqlDatabasesContainers_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountsSqlDatabasesContainers_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountsSqlDatabasesContainersSPEC, DatabaseAccountsSqlDatabasesContainersSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountsSqlDatabasesContainersSPEC runs a test to see if a specific instance of DatabaseAccountsSqlDatabasesContainers_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountsSqlDatabasesContainersSPEC(subject DatabaseAccountsSqlDatabasesContainers_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountsSqlDatabasesContainers_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountsSqlDatabasesContainers_SPEC instances for property testing - lazily instantiated by
//DatabaseAccountsSqlDatabasesContainersSPECGenerator()
var databaseAccountsSqlDatabasesContainersSPECGenerator gopter.Gen

// DatabaseAccountsSqlDatabasesContainersSPECGenerator returns a generator of DatabaseAccountsSqlDatabasesContainers_SPEC instances for property testing.
// We first initialize databaseAccountsSqlDatabasesContainersSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountsSqlDatabasesContainersSPECGenerator() gopter.Gen {
	if databaseAccountsSqlDatabasesContainersSPECGenerator != nil {
		return databaseAccountsSqlDatabasesContainersSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainersSPEC(generators)
	databaseAccountsSqlDatabasesContainersSPECGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountsSqlDatabasesContainers_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainersSPEC(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainersSPEC(generators)
	databaseAccountsSqlDatabasesContainersSPECGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountsSqlDatabasesContainers_SPEC{}), generators)

	return databaseAccountsSqlDatabasesContainersSPECGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainersSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainersSPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainersSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainersSPEC(gens map[string]gopter.Gen) {
	gens["Options"] = gen.PtrOf(CreateUpdateOptionsSpecGenerator())
	gens["Resource"] = SqlContainerResourceSpecGenerator()
}

func Test_SqlContainerCreateUpdateParameters_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SqlContainerCreateUpdateParameters_Status to SqlContainerCreateUpdateParameters_Status via AssignPropertiesToSqlContainerCreateUpdateParametersStatus & AssignPropertiesFromSqlContainerCreateUpdateParametersStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSqlContainerCreateUpdateParametersStatus, SqlContainerCreateUpdateParametersStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSqlContainerCreateUpdateParametersStatus tests if a specific instance of SqlContainerCreateUpdateParameters_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForSqlContainerCreateUpdateParametersStatus(subject SqlContainerCreateUpdateParameters_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.SqlContainerCreateUpdateParameters_Status
	err := copied.AssignPropertiesToSqlContainerCreateUpdateParametersStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SqlContainerCreateUpdateParameters_Status
	err = actual.AssignPropertiesFromSqlContainerCreateUpdateParametersStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SqlContainerCreateUpdateParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlContainerCreateUpdateParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlContainerCreateUpdateParametersStatus, SqlContainerCreateUpdateParametersStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlContainerCreateUpdateParametersStatus runs a test to see if a specific instance of SqlContainerCreateUpdateParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlContainerCreateUpdateParametersStatus(subject SqlContainerCreateUpdateParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlContainerCreateUpdateParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlContainerCreateUpdateParameters_Status instances for property testing - lazily instantiated by
//SqlContainerCreateUpdateParametersStatusGenerator()
var sqlContainerCreateUpdateParametersStatusGenerator gopter.Gen

// SqlContainerCreateUpdateParametersStatusGenerator returns a generator of SqlContainerCreateUpdateParameters_Status instances for property testing.
// We first initialize sqlContainerCreateUpdateParametersStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SqlContainerCreateUpdateParametersStatusGenerator() gopter.Gen {
	if sqlContainerCreateUpdateParametersStatusGenerator != nil {
		return sqlContainerCreateUpdateParametersStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerCreateUpdateParametersStatus(generators)
	sqlContainerCreateUpdateParametersStatusGenerator = gen.Struct(reflect.TypeOf(SqlContainerCreateUpdateParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerCreateUpdateParametersStatus(generators)
	AddRelatedPropertyGeneratorsForSqlContainerCreateUpdateParametersStatus(generators)
	sqlContainerCreateUpdateParametersStatusGenerator = gen.Struct(reflect.TypeOf(SqlContainerCreateUpdateParameters_Status{}), generators)

	return sqlContainerCreateUpdateParametersStatusGenerator
}

// AddIndependentPropertyGeneratorsForSqlContainerCreateUpdateParametersStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSqlContainerCreateUpdateParametersStatus(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSqlContainerCreateUpdateParametersStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlContainerCreateUpdateParametersStatus(gens map[string]gopter.Gen) {
	gens["Options"] = gen.PtrOf(CreateUpdateOptionsStatusGenerator())
	gens["Resource"] = gen.PtrOf(SqlContainerResourceStatusGenerator())
}

func Test_SqlContainerResource_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SqlContainerResource_Spec to SqlContainerResource_Spec via AssignPropertiesToSqlContainerResourceSpec & AssignPropertiesFromSqlContainerResourceSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSqlContainerResourceSpec, SqlContainerResourceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSqlContainerResourceSpec tests if a specific instance of SqlContainerResource_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForSqlContainerResourceSpec(subject SqlContainerResource_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.SqlContainerResource_Spec
	err := copied.AssignPropertiesToSqlContainerResourceSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SqlContainerResource_Spec
	err = actual.AssignPropertiesFromSqlContainerResourceSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SqlContainerResource_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlContainerResource_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlContainerResourceSpec, SqlContainerResourceSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlContainerResourceSpec runs a test to see if a specific instance of SqlContainerResource_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlContainerResourceSpec(subject SqlContainerResource_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlContainerResource_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlContainerResource_Spec instances for property testing - lazily instantiated by
//SqlContainerResourceSpecGenerator()
var sqlContainerResourceSpecGenerator gopter.Gen

// SqlContainerResourceSpecGenerator returns a generator of SqlContainerResource_Spec instances for property testing.
// We first initialize sqlContainerResourceSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SqlContainerResourceSpecGenerator() gopter.Gen {
	if sqlContainerResourceSpecGenerator != nil {
		return sqlContainerResourceSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerResourceSpec(generators)
	sqlContainerResourceSpecGenerator = gen.Struct(reflect.TypeOf(SqlContainerResource_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerResourceSpec(generators)
	AddRelatedPropertyGeneratorsForSqlContainerResourceSpec(generators)
	sqlContainerResourceSpecGenerator = gen.Struct(reflect.TypeOf(SqlContainerResource_Spec{}), generators)

	return sqlContainerResourceSpecGenerator
}

// AddIndependentPropertyGeneratorsForSqlContainerResourceSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSqlContainerResourceSpec(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageTtl"] = gen.PtrOf(gen.Int())
	gens["DefaultTtl"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForSqlContainerResourceSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlContainerResourceSpec(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPolicy"] = gen.PtrOf(ConflictResolutionPolicySpecGenerator())
	gens["IndexingPolicy"] = gen.PtrOf(IndexingPolicySpecGenerator())
	gens["PartitionKey"] = gen.PtrOf(ContainerPartitionKeySpecGenerator())
	gens["UniqueKeyPolicy"] = gen.PtrOf(UniqueKeyPolicySpecGenerator())
}

func Test_SqlContainerResource_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SqlContainerResource_Status to SqlContainerResource_Status via AssignPropertiesToSqlContainerResourceStatus & AssignPropertiesFromSqlContainerResourceStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSqlContainerResourceStatus, SqlContainerResourceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSqlContainerResourceStatus tests if a specific instance of SqlContainerResource_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForSqlContainerResourceStatus(subject SqlContainerResource_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.SqlContainerResource_Status
	err := copied.AssignPropertiesToSqlContainerResourceStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SqlContainerResource_Status
	err = actual.AssignPropertiesFromSqlContainerResourceStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SqlContainerResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlContainerResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlContainerResourceStatus, SqlContainerResourceStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlContainerResourceStatus runs a test to see if a specific instance of SqlContainerResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlContainerResourceStatus(subject SqlContainerResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlContainerResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlContainerResource_Status instances for property testing - lazily instantiated by
//SqlContainerResourceStatusGenerator()
var sqlContainerResourceStatusGenerator gopter.Gen

// SqlContainerResourceStatusGenerator returns a generator of SqlContainerResource_Status instances for property testing.
// We first initialize sqlContainerResourceStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SqlContainerResourceStatusGenerator() gopter.Gen {
	if sqlContainerResourceStatusGenerator != nil {
		return sqlContainerResourceStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerResourceStatus(generators)
	sqlContainerResourceStatusGenerator = gen.Struct(reflect.TypeOf(SqlContainerResource_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerResourceStatus(generators)
	AddRelatedPropertyGeneratorsForSqlContainerResourceStatus(generators)
	sqlContainerResourceStatusGenerator = gen.Struct(reflect.TypeOf(SqlContainerResource_Status{}), generators)

	return sqlContainerResourceStatusGenerator
}

// AddIndependentPropertyGeneratorsForSqlContainerResourceStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSqlContainerResourceStatus(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageTtl"] = gen.PtrOf(gen.Int())
	gens["DefaultTtl"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForSqlContainerResourceStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlContainerResourceStatus(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPolicy"] = gen.PtrOf(ConflictResolutionPolicyStatusGenerator())
	gens["IndexingPolicy"] = gen.PtrOf(IndexingPolicyStatusGenerator())
	gens["PartitionKey"] = gen.PtrOf(ContainerPartitionKeyStatusGenerator())
	gens["UniqueKeyPolicy"] = gen.PtrOf(UniqueKeyPolicyStatusGenerator())
}

func Test_ConflictResolutionPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConflictResolutionPolicy_Spec to ConflictResolutionPolicy_Spec via AssignPropertiesToConflictResolutionPolicySpec & AssignPropertiesFromConflictResolutionPolicySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForConflictResolutionPolicySpec, ConflictResolutionPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConflictResolutionPolicySpec tests if a specific instance of ConflictResolutionPolicy_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForConflictResolutionPolicySpec(subject ConflictResolutionPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ConflictResolutionPolicy_Spec
	err := copied.AssignPropertiesToConflictResolutionPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConflictResolutionPolicy_Spec
	err = actual.AssignPropertiesFromConflictResolutionPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConflictResolutionPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConflictResolutionPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConflictResolutionPolicySpec, ConflictResolutionPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConflictResolutionPolicySpec runs a test to see if a specific instance of ConflictResolutionPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForConflictResolutionPolicySpec(subject ConflictResolutionPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConflictResolutionPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConflictResolutionPolicy_Spec instances for property testing - lazily instantiated by
//ConflictResolutionPolicySpecGenerator()
var conflictResolutionPolicySpecGenerator gopter.Gen

// ConflictResolutionPolicySpecGenerator returns a generator of ConflictResolutionPolicy_Spec instances for property testing.
func ConflictResolutionPolicySpecGenerator() gopter.Gen {
	if conflictResolutionPolicySpecGenerator != nil {
		return conflictResolutionPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConflictResolutionPolicySpec(generators)
	conflictResolutionPolicySpecGenerator = gen.Struct(reflect.TypeOf(ConflictResolutionPolicy_Spec{}), generators)

	return conflictResolutionPolicySpecGenerator
}

// AddIndependentPropertyGeneratorsForConflictResolutionPolicySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConflictResolutionPolicySpec(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPath"] = gen.PtrOf(gen.AlphaString())
	gens["ConflictResolutionProcedure"] = gen.PtrOf(gen.AlphaString())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(ConflictResolutionPolicySpecModeCustom, ConflictResolutionPolicySpecModeLastWriterWins))
}

func Test_ConflictResolutionPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConflictResolutionPolicy_Status to ConflictResolutionPolicy_Status via AssignPropertiesToConflictResolutionPolicyStatus & AssignPropertiesFromConflictResolutionPolicyStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForConflictResolutionPolicyStatus, ConflictResolutionPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConflictResolutionPolicyStatus tests if a specific instance of ConflictResolutionPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForConflictResolutionPolicyStatus(subject ConflictResolutionPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ConflictResolutionPolicy_Status
	err := copied.AssignPropertiesToConflictResolutionPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConflictResolutionPolicy_Status
	err = actual.AssignPropertiesFromConflictResolutionPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConflictResolutionPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConflictResolutionPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConflictResolutionPolicyStatus, ConflictResolutionPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConflictResolutionPolicyStatus runs a test to see if a specific instance of ConflictResolutionPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForConflictResolutionPolicyStatus(subject ConflictResolutionPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConflictResolutionPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConflictResolutionPolicy_Status instances for property testing - lazily instantiated by
//ConflictResolutionPolicyStatusGenerator()
var conflictResolutionPolicyStatusGenerator gopter.Gen

// ConflictResolutionPolicyStatusGenerator returns a generator of ConflictResolutionPolicy_Status instances for property testing.
func ConflictResolutionPolicyStatusGenerator() gopter.Gen {
	if conflictResolutionPolicyStatusGenerator != nil {
		return conflictResolutionPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConflictResolutionPolicyStatus(generators)
	conflictResolutionPolicyStatusGenerator = gen.Struct(reflect.TypeOf(ConflictResolutionPolicy_Status{}), generators)

	return conflictResolutionPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForConflictResolutionPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConflictResolutionPolicyStatus(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPath"] = gen.PtrOf(gen.AlphaString())
	gens["ConflictResolutionProcedure"] = gen.PtrOf(gen.AlphaString())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(ConflictResolutionPolicyStatusModeCustom, ConflictResolutionPolicyStatusModeLastWriterWins))
}

func Test_ContainerPartitionKey_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerPartitionKey_Spec to ContainerPartitionKey_Spec via AssignPropertiesToContainerPartitionKeySpec & AssignPropertiesFromContainerPartitionKeySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerPartitionKeySpec, ContainerPartitionKeySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerPartitionKeySpec tests if a specific instance of ContainerPartitionKey_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForContainerPartitionKeySpec(subject ContainerPartitionKey_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ContainerPartitionKey_Spec
	err := copied.AssignPropertiesToContainerPartitionKeySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerPartitionKey_Spec
	err = actual.AssignPropertiesFromContainerPartitionKeySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerPartitionKey_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPartitionKey_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPartitionKeySpec, ContainerPartitionKeySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPartitionKeySpec runs a test to see if a specific instance of ContainerPartitionKey_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPartitionKeySpec(subject ContainerPartitionKey_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPartitionKey_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPartitionKey_Spec instances for property testing - lazily instantiated by
//ContainerPartitionKeySpecGenerator()
var containerPartitionKeySpecGenerator gopter.Gen

// ContainerPartitionKeySpecGenerator returns a generator of ContainerPartitionKey_Spec instances for property testing.
func ContainerPartitionKeySpecGenerator() gopter.Gen {
	if containerPartitionKeySpecGenerator != nil {
		return containerPartitionKeySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPartitionKeySpec(generators)
	containerPartitionKeySpecGenerator = gen.Struct(reflect.TypeOf(ContainerPartitionKey_Spec{}), generators)

	return containerPartitionKeySpecGenerator
}

// AddIndependentPropertyGeneratorsForContainerPartitionKeySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPartitionKeySpec(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ContainerPartitionKeySpecKindHash, ContainerPartitionKeySpecKindMultiHash, ContainerPartitionKeySpecKindRange))
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.Int())
}

func Test_ContainerPartitionKey_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerPartitionKey_Status to ContainerPartitionKey_Status via AssignPropertiesToContainerPartitionKeyStatus & AssignPropertiesFromContainerPartitionKeyStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerPartitionKeyStatus, ContainerPartitionKeyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerPartitionKeyStatus tests if a specific instance of ContainerPartitionKey_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForContainerPartitionKeyStatus(subject ContainerPartitionKey_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ContainerPartitionKey_Status
	err := copied.AssignPropertiesToContainerPartitionKeyStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerPartitionKey_Status
	err = actual.AssignPropertiesFromContainerPartitionKeyStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerPartitionKey_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPartitionKey_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPartitionKeyStatus, ContainerPartitionKeyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPartitionKeyStatus runs a test to see if a specific instance of ContainerPartitionKey_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPartitionKeyStatus(subject ContainerPartitionKey_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPartitionKey_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPartitionKey_Status instances for property testing - lazily instantiated by
//ContainerPartitionKeyStatusGenerator()
var containerPartitionKeyStatusGenerator gopter.Gen

// ContainerPartitionKeyStatusGenerator returns a generator of ContainerPartitionKey_Status instances for property testing.
func ContainerPartitionKeyStatusGenerator() gopter.Gen {
	if containerPartitionKeyStatusGenerator != nil {
		return containerPartitionKeyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPartitionKeyStatus(generators)
	containerPartitionKeyStatusGenerator = gen.Struct(reflect.TypeOf(ContainerPartitionKey_Status{}), generators)

	return containerPartitionKeyStatusGenerator
}

// AddIndependentPropertyGeneratorsForContainerPartitionKeyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPartitionKeyStatus(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ContainerPartitionKeyStatusKindHash, ContainerPartitionKeyStatusKindMultiHash, ContainerPartitionKeyStatusKindRange))
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
	gens["SystemKey"] = gen.PtrOf(gen.Bool())
	gens["Version"] = gen.PtrOf(gen.Int())
}

func Test_IndexingPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IndexingPolicy_Spec to IndexingPolicy_Spec via AssignPropertiesToIndexingPolicySpec & AssignPropertiesFromIndexingPolicySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForIndexingPolicySpec, IndexingPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIndexingPolicySpec tests if a specific instance of IndexingPolicy_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIndexingPolicySpec(subject IndexingPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.IndexingPolicy_Spec
	err := copied.AssignPropertiesToIndexingPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IndexingPolicy_Spec
	err = actual.AssignPropertiesFromIndexingPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IndexingPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IndexingPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexingPolicySpec, IndexingPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexingPolicySpec runs a test to see if a specific instance of IndexingPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexingPolicySpec(subject IndexingPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IndexingPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IndexingPolicy_Spec instances for property testing - lazily instantiated by IndexingPolicySpecGenerator()
var indexingPolicySpecGenerator gopter.Gen

// IndexingPolicySpecGenerator returns a generator of IndexingPolicy_Spec instances for property testing.
// We first initialize indexingPolicySpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IndexingPolicySpecGenerator() gopter.Gen {
	if indexingPolicySpecGenerator != nil {
		return indexingPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicySpec(generators)
	indexingPolicySpecGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicySpec(generators)
	AddRelatedPropertyGeneratorsForIndexingPolicySpec(generators)
	indexingPolicySpecGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_Spec{}), generators)

	return indexingPolicySpecGenerator
}

// AddIndependentPropertyGeneratorsForIndexingPolicySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexingPolicySpec(gens map[string]gopter.Gen) {
	gens["Automatic"] = gen.PtrOf(gen.Bool())
	gens["IndexingMode"] = gen.PtrOf(gen.OneConstOf(IndexingPolicySpecIndexingModeConsistent, IndexingPolicySpecIndexingModeLazy, IndexingPolicySpecIndexingModeNone))
}

// AddRelatedPropertyGeneratorsForIndexingPolicySpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIndexingPolicySpec(gens map[string]gopter.Gen) {
	gens["CompositeIndexes"] = gen.SliceOf(gen.SliceOf(CompositePathSpecGenerator()))
	gens["ExcludedPaths"] = gen.SliceOf(ExcludedPathSpecGenerator())
	gens["IncludedPaths"] = gen.SliceOf(IncludedPathSpecGenerator())
	gens["SpatialIndexes"] = gen.SliceOf(SpatialSpecSpecGenerator())
}

func Test_IndexingPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IndexingPolicy_Status to IndexingPolicy_Status via AssignPropertiesToIndexingPolicyStatus & AssignPropertiesFromIndexingPolicyStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForIndexingPolicyStatus, IndexingPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIndexingPolicyStatus tests if a specific instance of IndexingPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIndexingPolicyStatus(subject IndexingPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.IndexingPolicy_Status
	err := copied.AssignPropertiesToIndexingPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IndexingPolicy_Status
	err = actual.AssignPropertiesFromIndexingPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IndexingPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IndexingPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexingPolicyStatus, IndexingPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexingPolicyStatus runs a test to see if a specific instance of IndexingPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexingPolicyStatus(subject IndexingPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IndexingPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IndexingPolicy_Status instances for property testing - lazily instantiated by
//IndexingPolicyStatusGenerator()
var indexingPolicyStatusGenerator gopter.Gen

// IndexingPolicyStatusGenerator returns a generator of IndexingPolicy_Status instances for property testing.
// We first initialize indexingPolicyStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IndexingPolicyStatusGenerator() gopter.Gen {
	if indexingPolicyStatusGenerator != nil {
		return indexingPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicyStatus(generators)
	indexingPolicyStatusGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicyStatus(generators)
	AddRelatedPropertyGeneratorsForIndexingPolicyStatus(generators)
	indexingPolicyStatusGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_Status{}), generators)

	return indexingPolicyStatusGenerator
}

// AddIndependentPropertyGeneratorsForIndexingPolicyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexingPolicyStatus(gens map[string]gopter.Gen) {
	gens["Automatic"] = gen.PtrOf(gen.Bool())
	gens["IndexingMode"] = gen.PtrOf(gen.OneConstOf(IndexingPolicyStatusIndexingModeConsistent, IndexingPolicyStatusIndexingModeLazy, IndexingPolicyStatusIndexingModeNone))
}

// AddRelatedPropertyGeneratorsForIndexingPolicyStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIndexingPolicyStatus(gens map[string]gopter.Gen) {
	gens["CompositeIndexes"] = gen.SliceOf(gen.SliceOf(CompositePathStatusGenerator()))
	gens["ExcludedPaths"] = gen.SliceOf(ExcludedPathStatusGenerator())
	gens["IncludedPaths"] = gen.SliceOf(IncludedPathStatusGenerator())
	gens["SpatialIndexes"] = gen.SliceOf(SpatialSpecStatusGenerator())
}

func Test_UniqueKeyPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UniqueKeyPolicy_Spec to UniqueKeyPolicy_Spec via AssignPropertiesToUniqueKeyPolicySpec & AssignPropertiesFromUniqueKeyPolicySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForUniqueKeyPolicySpec, UniqueKeyPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUniqueKeyPolicySpec tests if a specific instance of UniqueKeyPolicy_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForUniqueKeyPolicySpec(subject UniqueKeyPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.UniqueKeyPolicy_Spec
	err := copied.AssignPropertiesToUniqueKeyPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UniqueKeyPolicy_Spec
	err = actual.AssignPropertiesFromUniqueKeyPolicySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UniqueKeyPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKeyPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKeyPolicySpec, UniqueKeyPolicySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKeyPolicySpec runs a test to see if a specific instance of UniqueKeyPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKeyPolicySpec(subject UniqueKeyPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKeyPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKeyPolicy_Spec instances for property testing - lazily instantiated by
//UniqueKeyPolicySpecGenerator()
var uniqueKeyPolicySpecGenerator gopter.Gen

// UniqueKeyPolicySpecGenerator returns a generator of UniqueKeyPolicy_Spec instances for property testing.
func UniqueKeyPolicySpecGenerator() gopter.Gen {
	if uniqueKeyPolicySpecGenerator != nil {
		return uniqueKeyPolicySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForUniqueKeyPolicySpec(generators)
	uniqueKeyPolicySpecGenerator = gen.Struct(reflect.TypeOf(UniqueKeyPolicy_Spec{}), generators)

	return uniqueKeyPolicySpecGenerator
}

// AddRelatedPropertyGeneratorsForUniqueKeyPolicySpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUniqueKeyPolicySpec(gens map[string]gopter.Gen) {
	gens["UniqueKeys"] = gen.SliceOf(UniqueKeySpecGenerator())
}

func Test_UniqueKeyPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UniqueKeyPolicy_Status to UniqueKeyPolicy_Status via AssignPropertiesToUniqueKeyPolicyStatus & AssignPropertiesFromUniqueKeyPolicyStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForUniqueKeyPolicyStatus, UniqueKeyPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUniqueKeyPolicyStatus tests if a specific instance of UniqueKeyPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForUniqueKeyPolicyStatus(subject UniqueKeyPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.UniqueKeyPolicy_Status
	err := copied.AssignPropertiesToUniqueKeyPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UniqueKeyPolicy_Status
	err = actual.AssignPropertiesFromUniqueKeyPolicyStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UniqueKeyPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKeyPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKeyPolicyStatus, UniqueKeyPolicyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKeyPolicyStatus runs a test to see if a specific instance of UniqueKeyPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKeyPolicyStatus(subject UniqueKeyPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKeyPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKeyPolicy_Status instances for property testing - lazily instantiated by
//UniqueKeyPolicyStatusGenerator()
var uniqueKeyPolicyStatusGenerator gopter.Gen

// UniqueKeyPolicyStatusGenerator returns a generator of UniqueKeyPolicy_Status instances for property testing.
func UniqueKeyPolicyStatusGenerator() gopter.Gen {
	if uniqueKeyPolicyStatusGenerator != nil {
		return uniqueKeyPolicyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForUniqueKeyPolicyStatus(generators)
	uniqueKeyPolicyStatusGenerator = gen.Struct(reflect.TypeOf(UniqueKeyPolicy_Status{}), generators)

	return uniqueKeyPolicyStatusGenerator
}

// AddRelatedPropertyGeneratorsForUniqueKeyPolicyStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUniqueKeyPolicyStatus(gens map[string]gopter.Gen) {
	gens["UniqueKeys"] = gen.SliceOf(UniqueKeyStatusGenerator())
}

func Test_CompositePath_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CompositePath_Spec to CompositePath_Spec via AssignPropertiesToCompositePathSpec & AssignPropertiesFromCompositePathSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompositePathSpec, CompositePathSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompositePathSpec tests if a specific instance of CompositePath_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCompositePathSpec(subject CompositePath_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.CompositePath_Spec
	err := copied.AssignPropertiesToCompositePathSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CompositePath_Spec
	err = actual.AssignPropertiesFromCompositePathSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CompositePath_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CompositePath_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompositePathSpec, CompositePathSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompositePathSpec runs a test to see if a specific instance of CompositePath_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCompositePathSpec(subject CompositePath_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CompositePath_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CompositePath_Spec instances for property testing - lazily instantiated by CompositePathSpecGenerator()
var compositePathSpecGenerator gopter.Gen

// CompositePathSpecGenerator returns a generator of CompositePath_Spec instances for property testing.
func CompositePathSpecGenerator() gopter.Gen {
	if compositePathSpecGenerator != nil {
		return compositePathSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompositePathSpec(generators)
	compositePathSpecGenerator = gen.Struct(reflect.TypeOf(CompositePath_Spec{}), generators)

	return compositePathSpecGenerator
}

// AddIndependentPropertyGeneratorsForCompositePathSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompositePathSpec(gens map[string]gopter.Gen) {
	gens["Order"] = gen.PtrOf(gen.OneConstOf(CompositePathSpecOrderAscending, CompositePathSpecOrderDescending))
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_CompositePath_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CompositePath_Status to CompositePath_Status via AssignPropertiesToCompositePathStatus & AssignPropertiesFromCompositePathStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompositePathStatus, CompositePathStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompositePathStatus tests if a specific instance of CompositePath_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCompositePathStatus(subject CompositePath_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.CompositePath_Status
	err := copied.AssignPropertiesToCompositePathStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CompositePath_Status
	err = actual.AssignPropertiesFromCompositePathStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CompositePath_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CompositePath_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompositePathStatus, CompositePathStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompositePathStatus runs a test to see if a specific instance of CompositePath_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCompositePathStatus(subject CompositePath_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CompositePath_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CompositePath_Status instances for property testing - lazily instantiated by
//CompositePathStatusGenerator()
var compositePathStatusGenerator gopter.Gen

// CompositePathStatusGenerator returns a generator of CompositePath_Status instances for property testing.
func CompositePathStatusGenerator() gopter.Gen {
	if compositePathStatusGenerator != nil {
		return compositePathStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompositePathStatus(generators)
	compositePathStatusGenerator = gen.Struct(reflect.TypeOf(CompositePath_Status{}), generators)

	return compositePathStatusGenerator
}

// AddIndependentPropertyGeneratorsForCompositePathStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompositePathStatus(gens map[string]gopter.Gen) {
	gens["Order"] = gen.PtrOf(gen.OneConstOf(CompositePathStatusOrderAscending, CompositePathStatusOrderDescending))
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExcludedPath_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExcludedPath_Spec to ExcludedPath_Spec via AssignPropertiesToExcludedPathSpec & AssignPropertiesFromExcludedPathSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForExcludedPathSpec, ExcludedPathSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExcludedPathSpec tests if a specific instance of ExcludedPath_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForExcludedPathSpec(subject ExcludedPath_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ExcludedPath_Spec
	err := copied.AssignPropertiesToExcludedPathSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExcludedPath_Spec
	err = actual.AssignPropertiesFromExcludedPathSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExcludedPath_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExcludedPath_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExcludedPathSpec, ExcludedPathSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExcludedPathSpec runs a test to see if a specific instance of ExcludedPath_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExcludedPathSpec(subject ExcludedPath_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExcludedPath_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExcludedPath_Spec instances for property testing - lazily instantiated by ExcludedPathSpecGenerator()
var excludedPathSpecGenerator gopter.Gen

// ExcludedPathSpecGenerator returns a generator of ExcludedPath_Spec instances for property testing.
func ExcludedPathSpecGenerator() gopter.Gen {
	if excludedPathSpecGenerator != nil {
		return excludedPathSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExcludedPathSpec(generators)
	excludedPathSpecGenerator = gen.Struct(reflect.TypeOf(ExcludedPath_Spec{}), generators)

	return excludedPathSpecGenerator
}

// AddIndependentPropertyGeneratorsForExcludedPathSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExcludedPathSpec(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExcludedPath_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExcludedPath_Status to ExcludedPath_Status via AssignPropertiesToExcludedPathStatus & AssignPropertiesFromExcludedPathStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForExcludedPathStatus, ExcludedPathStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExcludedPathStatus tests if a specific instance of ExcludedPath_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForExcludedPathStatus(subject ExcludedPath_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ExcludedPath_Status
	err := copied.AssignPropertiesToExcludedPathStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExcludedPath_Status
	err = actual.AssignPropertiesFromExcludedPathStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExcludedPath_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExcludedPath_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExcludedPathStatus, ExcludedPathStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExcludedPathStatus runs a test to see if a specific instance of ExcludedPath_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForExcludedPathStatus(subject ExcludedPath_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExcludedPath_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExcludedPath_Status instances for property testing - lazily instantiated by ExcludedPathStatusGenerator()
var excludedPathStatusGenerator gopter.Gen

// ExcludedPathStatusGenerator returns a generator of ExcludedPath_Status instances for property testing.
func ExcludedPathStatusGenerator() gopter.Gen {
	if excludedPathStatusGenerator != nil {
		return excludedPathStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExcludedPathStatus(generators)
	excludedPathStatusGenerator = gen.Struct(reflect.TypeOf(ExcludedPath_Status{}), generators)

	return excludedPathStatusGenerator
}

// AddIndependentPropertyGeneratorsForExcludedPathStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExcludedPathStatus(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_IncludedPath_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IncludedPath_Spec to IncludedPath_Spec via AssignPropertiesToIncludedPathSpec & AssignPropertiesFromIncludedPathSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForIncludedPathSpec, IncludedPathSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIncludedPathSpec tests if a specific instance of IncludedPath_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIncludedPathSpec(subject IncludedPath_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.IncludedPath_Spec
	err := copied.AssignPropertiesToIncludedPathSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IncludedPath_Spec
	err = actual.AssignPropertiesFromIncludedPathSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IncludedPath_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IncludedPath_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIncludedPathSpec, IncludedPathSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIncludedPathSpec runs a test to see if a specific instance of IncludedPath_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIncludedPathSpec(subject IncludedPath_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IncludedPath_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IncludedPath_Spec instances for property testing - lazily instantiated by IncludedPathSpecGenerator()
var includedPathSpecGenerator gopter.Gen

// IncludedPathSpecGenerator returns a generator of IncludedPath_Spec instances for property testing.
// We first initialize includedPathSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IncludedPathSpecGenerator() gopter.Gen {
	if includedPathSpecGenerator != nil {
		return includedPathSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPathSpec(generators)
	includedPathSpecGenerator = gen.Struct(reflect.TypeOf(IncludedPath_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPathSpec(generators)
	AddRelatedPropertyGeneratorsForIncludedPathSpec(generators)
	includedPathSpecGenerator = gen.Struct(reflect.TypeOf(IncludedPath_Spec{}), generators)

	return includedPathSpecGenerator
}

// AddIndependentPropertyGeneratorsForIncludedPathSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIncludedPathSpec(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIncludedPathSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIncludedPathSpec(gens map[string]gopter.Gen) {
	gens["Indexes"] = gen.SliceOf(IndexesSpecGenerator())
}

func Test_IncludedPath_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IncludedPath_Status to IncludedPath_Status via AssignPropertiesToIncludedPathStatus & AssignPropertiesFromIncludedPathStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForIncludedPathStatus, IncludedPathStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIncludedPathStatus tests if a specific instance of IncludedPath_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIncludedPathStatus(subject IncludedPath_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.IncludedPath_Status
	err := copied.AssignPropertiesToIncludedPathStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IncludedPath_Status
	err = actual.AssignPropertiesFromIncludedPathStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IncludedPath_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IncludedPath_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIncludedPathStatus, IncludedPathStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIncludedPathStatus runs a test to see if a specific instance of IncludedPath_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIncludedPathStatus(subject IncludedPath_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IncludedPath_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IncludedPath_Status instances for property testing - lazily instantiated by IncludedPathStatusGenerator()
var includedPathStatusGenerator gopter.Gen

// IncludedPathStatusGenerator returns a generator of IncludedPath_Status instances for property testing.
// We first initialize includedPathStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IncludedPathStatusGenerator() gopter.Gen {
	if includedPathStatusGenerator != nil {
		return includedPathStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPathStatus(generators)
	includedPathStatusGenerator = gen.Struct(reflect.TypeOf(IncludedPath_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPathStatus(generators)
	AddRelatedPropertyGeneratorsForIncludedPathStatus(generators)
	includedPathStatusGenerator = gen.Struct(reflect.TypeOf(IncludedPath_Status{}), generators)

	return includedPathStatusGenerator
}

// AddIndependentPropertyGeneratorsForIncludedPathStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIncludedPathStatus(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIncludedPathStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIncludedPathStatus(gens map[string]gopter.Gen) {
	gens["Indexes"] = gen.SliceOf(IndexesStatusGenerator())
}

func Test_SpatialSpec_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SpatialSpec_Spec to SpatialSpec_Spec via AssignPropertiesToSpatialSpecSpec & AssignPropertiesFromSpatialSpecSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSpatialSpecSpec, SpatialSpecSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSpatialSpecSpec tests if a specific instance of SpatialSpec_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForSpatialSpecSpec(subject SpatialSpec_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.SpatialSpec_Spec
	err := copied.AssignPropertiesToSpatialSpecSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SpatialSpec_Spec
	err = actual.AssignPropertiesFromSpatialSpecSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SpatialSpec_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SpatialSpec_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSpatialSpecSpec, SpatialSpecSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSpatialSpecSpec runs a test to see if a specific instance of SpatialSpec_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSpatialSpecSpec(subject SpatialSpec_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SpatialSpec_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SpatialSpec_Spec instances for property testing - lazily instantiated by SpatialSpecSpecGenerator()
var spatialSpecSpecGenerator gopter.Gen

// SpatialSpecSpecGenerator returns a generator of SpatialSpec_Spec instances for property testing.
func SpatialSpecSpecGenerator() gopter.Gen {
	if spatialSpecSpecGenerator != nil {
		return spatialSpecSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSpatialSpecSpec(generators)
	spatialSpecSpecGenerator = gen.Struct(reflect.TypeOf(SpatialSpec_Spec{}), generators)

	return spatialSpecSpecGenerator
}

// AddIndependentPropertyGeneratorsForSpatialSpecSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSpatialSpecSpec(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Types"] = gen.SliceOf(gen.OneConstOf(
		SpatialType_SpecLineString,
		SpatialType_SpecMultiPolygon,
		SpatialType_SpecPoint,
		SpatialType_SpecPolygon))
}

func Test_SpatialSpec_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SpatialSpec_Status to SpatialSpec_Status via AssignPropertiesToSpatialSpecStatus & AssignPropertiesFromSpatialSpecStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForSpatialSpecStatus, SpatialSpecStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSpatialSpecStatus tests if a specific instance of SpatialSpec_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForSpatialSpecStatus(subject SpatialSpec_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.SpatialSpec_Status
	err := copied.AssignPropertiesToSpatialSpecStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SpatialSpec_Status
	err = actual.AssignPropertiesFromSpatialSpecStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SpatialSpec_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SpatialSpec_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSpatialSpecStatus, SpatialSpecStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSpatialSpecStatus runs a test to see if a specific instance of SpatialSpec_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSpatialSpecStatus(subject SpatialSpec_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SpatialSpec_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SpatialSpec_Status instances for property testing - lazily instantiated by SpatialSpecStatusGenerator()
var spatialSpecStatusGenerator gopter.Gen

// SpatialSpecStatusGenerator returns a generator of SpatialSpec_Status instances for property testing.
func SpatialSpecStatusGenerator() gopter.Gen {
	if spatialSpecStatusGenerator != nil {
		return spatialSpecStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSpatialSpecStatus(generators)
	spatialSpecStatusGenerator = gen.Struct(reflect.TypeOf(SpatialSpec_Status{}), generators)

	return spatialSpecStatusGenerator
}

// AddIndependentPropertyGeneratorsForSpatialSpecStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSpatialSpecStatus(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Types"] = gen.SliceOf(gen.OneConstOf(
		SpatialType_StatusLineString,
		SpatialType_StatusMultiPolygon,
		SpatialType_StatusPoint,
		SpatialType_StatusPolygon))
}

func Test_UniqueKey_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UniqueKey_Spec to UniqueKey_Spec via AssignPropertiesToUniqueKeySpec & AssignPropertiesFromUniqueKeySpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForUniqueKeySpec, UniqueKeySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUniqueKeySpec tests if a specific instance of UniqueKey_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForUniqueKeySpec(subject UniqueKey_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.UniqueKey_Spec
	err := copied.AssignPropertiesToUniqueKeySpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UniqueKey_Spec
	err = actual.AssignPropertiesFromUniqueKeySpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UniqueKey_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKey_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKeySpec, UniqueKeySpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKeySpec runs a test to see if a specific instance of UniqueKey_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKeySpec(subject UniqueKey_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKey_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKey_Spec instances for property testing - lazily instantiated by UniqueKeySpecGenerator()
var uniqueKeySpecGenerator gopter.Gen

// UniqueKeySpecGenerator returns a generator of UniqueKey_Spec instances for property testing.
func UniqueKeySpecGenerator() gopter.Gen {
	if uniqueKeySpecGenerator != nil {
		return uniqueKeySpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUniqueKeySpec(generators)
	uniqueKeySpecGenerator = gen.Struct(reflect.TypeOf(UniqueKey_Spec{}), generators)

	return uniqueKeySpecGenerator
}

// AddIndependentPropertyGeneratorsForUniqueKeySpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUniqueKeySpec(gens map[string]gopter.Gen) {
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
}

func Test_UniqueKey_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UniqueKey_Status to UniqueKey_Status via AssignPropertiesToUniqueKeyStatus & AssignPropertiesFromUniqueKeyStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForUniqueKeyStatus, UniqueKeyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUniqueKeyStatus tests if a specific instance of UniqueKey_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForUniqueKeyStatus(subject UniqueKey_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.UniqueKey_Status
	err := copied.AssignPropertiesToUniqueKeyStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UniqueKey_Status
	err = actual.AssignPropertiesFromUniqueKeyStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UniqueKey_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKey_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKeyStatus, UniqueKeyStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKeyStatus runs a test to see if a specific instance of UniqueKey_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKeyStatus(subject UniqueKey_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKey_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKey_Status instances for property testing - lazily instantiated by UniqueKeyStatusGenerator()
var uniqueKeyStatusGenerator gopter.Gen

// UniqueKeyStatusGenerator returns a generator of UniqueKey_Status instances for property testing.
func UniqueKeyStatusGenerator() gopter.Gen {
	if uniqueKeyStatusGenerator != nil {
		return uniqueKeyStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUniqueKeyStatus(generators)
	uniqueKeyStatusGenerator = gen.Struct(reflect.TypeOf(UniqueKey_Status{}), generators)

	return uniqueKeyStatusGenerator
}

// AddIndependentPropertyGeneratorsForUniqueKeyStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUniqueKeyStatus(gens map[string]gopter.Gen) {
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
}

func Test_Indexes_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Indexes_Spec to Indexes_Spec via AssignPropertiesToIndexesSpec & AssignPropertiesFromIndexesSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForIndexesSpec, IndexesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIndexesSpec tests if a specific instance of Indexes_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIndexesSpec(subject Indexes_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Indexes_Spec
	err := copied.AssignPropertiesToIndexesSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Indexes_Spec
	err = actual.AssignPropertiesFromIndexesSpec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Indexes_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Indexes_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexesSpec, IndexesSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexesSpec runs a test to see if a specific instance of Indexes_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexesSpec(subject Indexes_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Indexes_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Indexes_Spec instances for property testing - lazily instantiated by IndexesSpecGenerator()
var indexesSpecGenerator gopter.Gen

// IndexesSpecGenerator returns a generator of Indexes_Spec instances for property testing.
func IndexesSpecGenerator() gopter.Gen {
	if indexesSpecGenerator != nil {
		return indexesSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexesSpec(generators)
	indexesSpecGenerator = gen.Struct(reflect.TypeOf(Indexes_Spec{}), generators)

	return indexesSpecGenerator
}

// AddIndependentPropertyGeneratorsForIndexesSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexesSpec(gens map[string]gopter.Gen) {
	gens["DataType"] = gen.PtrOf(gen.OneConstOf(
		IndexesSpecDataTypeLineString,
		IndexesSpecDataTypeMultiPolygon,
		IndexesSpecDataTypeNumber,
		IndexesSpecDataTypePoint,
		IndexesSpecDataTypePolygon,
		IndexesSpecDataTypeString))
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(IndexesSpecKindHash, IndexesSpecKindRange, IndexesSpecKindSpatial))
	gens["Precision"] = gen.PtrOf(gen.Int())
}

func Test_Indexes_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Indexes_Status to Indexes_Status via AssignPropertiesToIndexesStatus & AssignPropertiesFromIndexesStatus returns original",
		prop.ForAll(RunPropertyAssignmentTestForIndexesStatus, IndexesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIndexesStatus tests if a specific instance of Indexes_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIndexesStatus(subject Indexes_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Indexes_Status
	err := copied.AssignPropertiesToIndexesStatus(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Indexes_Status
	err = actual.AssignPropertiesFromIndexesStatus(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Indexes_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Indexes_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexesStatus, IndexesStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexesStatus runs a test to see if a specific instance of Indexes_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexesStatus(subject Indexes_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Indexes_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Indexes_Status instances for property testing - lazily instantiated by IndexesStatusGenerator()
var indexesStatusGenerator gopter.Gen

// IndexesStatusGenerator returns a generator of Indexes_Status instances for property testing.
func IndexesStatusGenerator() gopter.Gen {
	if indexesStatusGenerator != nil {
		return indexesStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexesStatus(generators)
	indexesStatusGenerator = gen.Struct(reflect.TypeOf(Indexes_Status{}), generators)

	return indexesStatusGenerator
}

// AddIndependentPropertyGeneratorsForIndexesStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexesStatus(gens map[string]gopter.Gen) {
	gens["DataType"] = gen.PtrOf(gen.OneConstOf(
		IndexesStatusDataTypeLineString,
		IndexesStatusDataTypeMultiPolygon,
		IndexesStatusDataTypeNumber,
		IndexesStatusDataTypePoint,
		IndexesStatusDataTypePolygon,
		IndexesStatusDataTypeString))
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(IndexesStatusKindHash, IndexesStatusKindRange, IndexesStatusKindSpatial))
	gens["Precision"] = gen.PtrOf(gen.Int())
}
