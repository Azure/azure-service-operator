// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515

import (
	"encoding/json"
	"github.com/Azure/azure-service-operator/v2/api/documentdb/v1alpha1api20210515storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_SqlDatabaseContainer_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SqlDatabaseContainer to hub returns original",
		prop.ForAll(RunResourceConversionTestForSqlDatabaseContainer, SqlDatabaseContainerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForSqlDatabaseContainer tests if a specific instance of SqlDatabaseContainer round trips to the hub storage version and back losslessly
func RunResourceConversionTestForSqlDatabaseContainer(subject SqlDatabaseContainer) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v1alpha1api20210515storage.SqlDatabaseContainer
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual SqlDatabaseContainer
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SqlDatabaseContainer_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SqlDatabaseContainer to SqlDatabaseContainer via AssignPropertiesToSqlDatabaseContainer & AssignPropertiesFromSqlDatabaseContainer returns original",
		prop.ForAll(RunPropertyAssignmentTestForSqlDatabaseContainer, SqlDatabaseContainerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSqlDatabaseContainer tests if a specific instance of SqlDatabaseContainer can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForSqlDatabaseContainer(subject SqlDatabaseContainer) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.SqlDatabaseContainer
	err := copied.AssignPropertiesToSqlDatabaseContainer(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SqlDatabaseContainer
	err = actual.AssignPropertiesFromSqlDatabaseContainer(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SqlDatabaseContainer_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlDatabaseContainer via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlDatabaseContainer, SqlDatabaseContainerGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlDatabaseContainer runs a test to see if a specific instance of SqlDatabaseContainer round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlDatabaseContainer(subject SqlDatabaseContainer) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlDatabaseContainer
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlDatabaseContainer instances for property testing - lazily instantiated by
//SqlDatabaseContainerGenerator()
var sqlDatabaseContainerGenerator gopter.Gen

// SqlDatabaseContainerGenerator returns a generator of SqlDatabaseContainer instances for property testing.
func SqlDatabaseContainerGenerator() gopter.Gen {
	if sqlDatabaseContainerGenerator != nil {
		return sqlDatabaseContainerGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSqlDatabaseContainer(generators)
	sqlDatabaseContainerGenerator = gen.Struct(reflect.TypeOf(SqlDatabaseContainer{}), generators)

	return sqlDatabaseContainerGenerator
}

// AddRelatedPropertyGeneratorsForSqlDatabaseContainer is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlDatabaseContainer(gens map[string]gopter.Gen) {
	gens["Spec"] = DatabaseAccountsSqlDatabasesContainers_SPECGenerator()
	gens["Status"] = SqlContainerCreateUpdateParameters_StatusGenerator()
}

func Test_DatabaseAccountsSqlDatabasesContainers_SPEC_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DatabaseAccountsSqlDatabasesContainers_SPEC to DatabaseAccountsSqlDatabasesContainers_SPEC via AssignPropertiesToDatabaseAccountsSqlDatabasesContainers_SPEC & AssignPropertiesFromDatabaseAccountsSqlDatabasesContainers_SPEC returns original",
		prop.ForAll(RunPropertyAssignmentTestForDatabaseAccountsSqlDatabasesContainers_SPEC, DatabaseAccountsSqlDatabasesContainers_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDatabaseAccountsSqlDatabasesContainers_SPEC tests if a specific instance of DatabaseAccountsSqlDatabasesContainers_SPEC can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForDatabaseAccountsSqlDatabasesContainers_SPEC(subject DatabaseAccountsSqlDatabasesContainers_SPEC) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.DatabaseAccountsSqlDatabasesContainers_SPEC
	err := copied.AssignPropertiesToDatabaseAccountsSqlDatabasesContainers_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DatabaseAccountsSqlDatabasesContainers_SPEC
	err = actual.AssignPropertiesFromDatabaseAccountsSqlDatabasesContainers_SPEC(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DatabaseAccountsSqlDatabasesContainers_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountsSqlDatabasesContainers_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountsSqlDatabasesContainers_SPEC, DatabaseAccountsSqlDatabasesContainers_SPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountsSqlDatabasesContainers_SPEC runs a test to see if a specific instance of DatabaseAccountsSqlDatabasesContainers_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountsSqlDatabasesContainers_SPEC(subject DatabaseAccountsSqlDatabasesContainers_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountsSqlDatabasesContainers_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountsSqlDatabasesContainers_SPEC instances for property testing - lazily instantiated by
//DatabaseAccountsSqlDatabasesContainers_SPECGenerator()
var databaseAccountsSqlDatabasesContainers_specGenerator gopter.Gen

// DatabaseAccountsSqlDatabasesContainers_SPECGenerator returns a generator of DatabaseAccountsSqlDatabasesContainers_SPEC instances for property testing.
// We first initialize databaseAccountsSqlDatabasesContainers_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountsSqlDatabasesContainers_SPECGenerator() gopter.Gen {
	if databaseAccountsSqlDatabasesContainers_specGenerator != nil {
		return databaseAccountsSqlDatabasesContainers_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPEC(generators)
	databaseAccountsSqlDatabasesContainers_specGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountsSqlDatabasesContainers_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPEC(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPEC(generators)
	databaseAccountsSqlDatabasesContainers_specGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountsSqlDatabasesContainers_SPEC{}), generators)

	return databaseAccountsSqlDatabasesContainers_specGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPEC(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountsSqlDatabasesContainers_SPEC(gens map[string]gopter.Gen) {
	gens["Options"] = gen.PtrOf(CreateUpdateOptions_SpecGenerator())
	gens["Resource"] = SqlContainerResource_SpecGenerator()
}

func Test_SqlContainerCreateUpdateParameters_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SqlContainerCreateUpdateParameters_Status to SqlContainerCreateUpdateParameters_Status via AssignPropertiesToSqlContainerCreateUpdateParameters_Status & AssignPropertiesFromSqlContainerCreateUpdateParameters_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSqlContainerCreateUpdateParameters_Status, SqlContainerCreateUpdateParameters_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSqlContainerCreateUpdateParameters_Status tests if a specific instance of SqlContainerCreateUpdateParameters_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForSqlContainerCreateUpdateParameters_Status(subject SqlContainerCreateUpdateParameters_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.SqlContainerCreateUpdateParameters_Status
	err := copied.AssignPropertiesToSqlContainerCreateUpdateParameters_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SqlContainerCreateUpdateParameters_Status
	err = actual.AssignPropertiesFromSqlContainerCreateUpdateParameters_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SqlContainerCreateUpdateParameters_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlContainerCreateUpdateParameters_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlContainerCreateUpdateParameters_Status, SqlContainerCreateUpdateParameters_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlContainerCreateUpdateParameters_Status runs a test to see if a specific instance of SqlContainerCreateUpdateParameters_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlContainerCreateUpdateParameters_Status(subject SqlContainerCreateUpdateParameters_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlContainerCreateUpdateParameters_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlContainerCreateUpdateParameters_Status instances for property testing - lazily instantiated by
//SqlContainerCreateUpdateParameters_StatusGenerator()
var sqlContainerCreateUpdateParameters_statusGenerator gopter.Gen

// SqlContainerCreateUpdateParameters_StatusGenerator returns a generator of SqlContainerCreateUpdateParameters_Status instances for property testing.
// We first initialize sqlContainerCreateUpdateParameters_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SqlContainerCreateUpdateParameters_StatusGenerator() gopter.Gen {
	if sqlContainerCreateUpdateParameters_statusGenerator != nil {
		return sqlContainerCreateUpdateParameters_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerCreateUpdateParameters_Status(generators)
	sqlContainerCreateUpdateParameters_statusGenerator = gen.Struct(reflect.TypeOf(SqlContainerCreateUpdateParameters_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerCreateUpdateParameters_Status(generators)
	AddRelatedPropertyGeneratorsForSqlContainerCreateUpdateParameters_Status(generators)
	sqlContainerCreateUpdateParameters_statusGenerator = gen.Struct(reflect.TypeOf(SqlContainerCreateUpdateParameters_Status{}), generators)

	return sqlContainerCreateUpdateParameters_statusGenerator
}

// AddIndependentPropertyGeneratorsForSqlContainerCreateUpdateParameters_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSqlContainerCreateUpdateParameters_Status(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSqlContainerCreateUpdateParameters_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlContainerCreateUpdateParameters_Status(gens map[string]gopter.Gen) {
	gens["Options"] = gen.PtrOf(CreateUpdateOptions_StatusGenerator())
	gens["Resource"] = gen.PtrOf(SqlContainerResource_StatusGenerator())
}

func Test_SqlContainerResource_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SqlContainerResource_Spec to SqlContainerResource_Spec via AssignPropertiesToSqlContainerResource_Spec & AssignPropertiesFromSqlContainerResource_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSqlContainerResource_Spec, SqlContainerResource_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSqlContainerResource_Spec tests if a specific instance of SqlContainerResource_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForSqlContainerResource_Spec(subject SqlContainerResource_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.SqlContainerResource_Spec
	err := copied.AssignPropertiesToSqlContainerResource_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SqlContainerResource_Spec
	err = actual.AssignPropertiesFromSqlContainerResource_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SqlContainerResource_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlContainerResource_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlContainerResource_Spec, SqlContainerResource_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlContainerResource_Spec runs a test to see if a specific instance of SqlContainerResource_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlContainerResource_Spec(subject SqlContainerResource_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlContainerResource_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlContainerResource_Spec instances for property testing - lazily instantiated by
//SqlContainerResource_SpecGenerator()
var sqlContainerResource_specGenerator gopter.Gen

// SqlContainerResource_SpecGenerator returns a generator of SqlContainerResource_Spec instances for property testing.
// We first initialize sqlContainerResource_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SqlContainerResource_SpecGenerator() gopter.Gen {
	if sqlContainerResource_specGenerator != nil {
		return sqlContainerResource_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerResource_Spec(generators)
	sqlContainerResource_specGenerator = gen.Struct(reflect.TypeOf(SqlContainerResource_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerResource_Spec(generators)
	AddRelatedPropertyGeneratorsForSqlContainerResource_Spec(generators)
	sqlContainerResource_specGenerator = gen.Struct(reflect.TypeOf(SqlContainerResource_Spec{}), generators)

	return sqlContainerResource_specGenerator
}

// AddIndependentPropertyGeneratorsForSqlContainerResource_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSqlContainerResource_Spec(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageTtl"] = gen.PtrOf(gen.Int())
	gens["DefaultTtl"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForSqlContainerResource_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlContainerResource_Spec(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPolicy"] = gen.PtrOf(ConflictResolutionPolicy_SpecGenerator())
	gens["IndexingPolicy"] = gen.PtrOf(IndexingPolicy_SpecGenerator())
	gens["PartitionKey"] = gen.PtrOf(ContainerPartitionKey_SpecGenerator())
	gens["UniqueKeyPolicy"] = gen.PtrOf(UniqueKeyPolicy_SpecGenerator())
}

func Test_SqlContainerResource_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SqlContainerResource_Status to SqlContainerResource_Status via AssignPropertiesToSqlContainerResource_Status & AssignPropertiesFromSqlContainerResource_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSqlContainerResource_Status, SqlContainerResource_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSqlContainerResource_Status tests if a specific instance of SqlContainerResource_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForSqlContainerResource_Status(subject SqlContainerResource_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.SqlContainerResource_Status
	err := copied.AssignPropertiesToSqlContainerResource_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SqlContainerResource_Status
	err = actual.AssignPropertiesFromSqlContainerResource_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SqlContainerResource_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlContainerResource_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlContainerResource_Status, SqlContainerResource_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlContainerResource_Status runs a test to see if a specific instance of SqlContainerResource_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlContainerResource_Status(subject SqlContainerResource_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlContainerResource_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlContainerResource_Status instances for property testing - lazily instantiated by
//SqlContainerResource_StatusGenerator()
var sqlContainerResource_statusGenerator gopter.Gen

// SqlContainerResource_StatusGenerator returns a generator of SqlContainerResource_Status instances for property testing.
// We first initialize sqlContainerResource_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SqlContainerResource_StatusGenerator() gopter.Gen {
	if sqlContainerResource_statusGenerator != nil {
		return sqlContainerResource_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerResource_Status(generators)
	sqlContainerResource_statusGenerator = gen.Struct(reflect.TypeOf(SqlContainerResource_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerResource_Status(generators)
	AddRelatedPropertyGeneratorsForSqlContainerResource_Status(generators)
	sqlContainerResource_statusGenerator = gen.Struct(reflect.TypeOf(SqlContainerResource_Status{}), generators)

	return sqlContainerResource_statusGenerator
}

// AddIndependentPropertyGeneratorsForSqlContainerResource_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSqlContainerResource_Status(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageTtl"] = gen.PtrOf(gen.Int())
	gens["DefaultTtl"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForSqlContainerResource_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlContainerResource_Status(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPolicy"] = gen.PtrOf(ConflictResolutionPolicy_StatusGenerator())
	gens["IndexingPolicy"] = gen.PtrOf(IndexingPolicy_StatusGenerator())
	gens["PartitionKey"] = gen.PtrOf(ContainerPartitionKey_StatusGenerator())
	gens["UniqueKeyPolicy"] = gen.PtrOf(UniqueKeyPolicy_StatusGenerator())
}

func Test_ConflictResolutionPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConflictResolutionPolicy_Spec to ConflictResolutionPolicy_Spec via AssignPropertiesToConflictResolutionPolicy_Spec & AssignPropertiesFromConflictResolutionPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForConflictResolutionPolicy_Spec, ConflictResolutionPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConflictResolutionPolicy_Spec tests if a specific instance of ConflictResolutionPolicy_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForConflictResolutionPolicy_Spec(subject ConflictResolutionPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ConflictResolutionPolicy_Spec
	err := copied.AssignPropertiesToConflictResolutionPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConflictResolutionPolicy_Spec
	err = actual.AssignPropertiesFromConflictResolutionPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConflictResolutionPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConflictResolutionPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConflictResolutionPolicy_Spec, ConflictResolutionPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConflictResolutionPolicy_Spec runs a test to see if a specific instance of ConflictResolutionPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForConflictResolutionPolicy_Spec(subject ConflictResolutionPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConflictResolutionPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConflictResolutionPolicy_Spec instances for property testing - lazily instantiated by
//ConflictResolutionPolicy_SpecGenerator()
var conflictResolutionPolicy_specGenerator gopter.Gen

// ConflictResolutionPolicy_SpecGenerator returns a generator of ConflictResolutionPolicy_Spec instances for property testing.
func ConflictResolutionPolicy_SpecGenerator() gopter.Gen {
	if conflictResolutionPolicy_specGenerator != nil {
		return conflictResolutionPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConflictResolutionPolicy_Spec(generators)
	conflictResolutionPolicy_specGenerator = gen.Struct(reflect.TypeOf(ConflictResolutionPolicy_Spec{}), generators)

	return conflictResolutionPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForConflictResolutionPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConflictResolutionPolicy_Spec(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPath"] = gen.PtrOf(gen.AlphaString())
	gens["ConflictResolutionProcedure"] = gen.PtrOf(gen.AlphaString())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(ConflictResolutionPolicy_Mode_SpecCustom, ConflictResolutionPolicy_Mode_SpecLastWriterWins))
}

func Test_ConflictResolutionPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ConflictResolutionPolicy_Status to ConflictResolutionPolicy_Status via AssignPropertiesToConflictResolutionPolicy_Status & AssignPropertiesFromConflictResolutionPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForConflictResolutionPolicy_Status, ConflictResolutionPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForConflictResolutionPolicy_Status tests if a specific instance of ConflictResolutionPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForConflictResolutionPolicy_Status(subject ConflictResolutionPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ConflictResolutionPolicy_Status
	err := copied.AssignPropertiesToConflictResolutionPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ConflictResolutionPolicy_Status
	err = actual.AssignPropertiesFromConflictResolutionPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ConflictResolutionPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConflictResolutionPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConflictResolutionPolicy_Status, ConflictResolutionPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConflictResolutionPolicy_Status runs a test to see if a specific instance of ConflictResolutionPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForConflictResolutionPolicy_Status(subject ConflictResolutionPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConflictResolutionPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConflictResolutionPolicy_Status instances for property testing - lazily instantiated by
//ConflictResolutionPolicy_StatusGenerator()
var conflictResolutionPolicy_statusGenerator gopter.Gen

// ConflictResolutionPolicy_StatusGenerator returns a generator of ConflictResolutionPolicy_Status instances for property testing.
func ConflictResolutionPolicy_StatusGenerator() gopter.Gen {
	if conflictResolutionPolicy_statusGenerator != nil {
		return conflictResolutionPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConflictResolutionPolicy_Status(generators)
	conflictResolutionPolicy_statusGenerator = gen.Struct(reflect.TypeOf(ConflictResolutionPolicy_Status{}), generators)

	return conflictResolutionPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForConflictResolutionPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConflictResolutionPolicy_Status(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPath"] = gen.PtrOf(gen.AlphaString())
	gens["ConflictResolutionProcedure"] = gen.PtrOf(gen.AlphaString())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(ConflictResolutionPolicy_Mode_StatusCustom, ConflictResolutionPolicy_Mode_StatusLastWriterWins))
}

func Test_ContainerPartitionKey_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerPartitionKey_Spec to ContainerPartitionKey_Spec via AssignPropertiesToContainerPartitionKey_Spec & AssignPropertiesFromContainerPartitionKey_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerPartitionKey_Spec, ContainerPartitionKey_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerPartitionKey_Spec tests if a specific instance of ContainerPartitionKey_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForContainerPartitionKey_Spec(subject ContainerPartitionKey_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ContainerPartitionKey_Spec
	err := copied.AssignPropertiesToContainerPartitionKey_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerPartitionKey_Spec
	err = actual.AssignPropertiesFromContainerPartitionKey_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerPartitionKey_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPartitionKey_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPartitionKey_Spec, ContainerPartitionKey_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPartitionKey_Spec runs a test to see if a specific instance of ContainerPartitionKey_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPartitionKey_Spec(subject ContainerPartitionKey_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPartitionKey_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPartitionKey_Spec instances for property testing - lazily instantiated by
//ContainerPartitionKey_SpecGenerator()
var containerPartitionKey_specGenerator gopter.Gen

// ContainerPartitionKey_SpecGenerator returns a generator of ContainerPartitionKey_Spec instances for property testing.
func ContainerPartitionKey_SpecGenerator() gopter.Gen {
	if containerPartitionKey_specGenerator != nil {
		return containerPartitionKey_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPartitionKey_Spec(generators)
	containerPartitionKey_specGenerator = gen.Struct(reflect.TypeOf(ContainerPartitionKey_Spec{}), generators)

	return containerPartitionKey_specGenerator
}

// AddIndependentPropertyGeneratorsForContainerPartitionKey_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPartitionKey_Spec(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ContainerPartitionKey_Kind_SpecHash, ContainerPartitionKey_Kind_SpecMultiHash, ContainerPartitionKey_Kind_SpecRange))
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
	gens["Version"] = gen.PtrOf(gen.Int())
}

func Test_ContainerPartitionKey_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ContainerPartitionKey_Status to ContainerPartitionKey_Status via AssignPropertiesToContainerPartitionKey_Status & AssignPropertiesFromContainerPartitionKey_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForContainerPartitionKey_Status, ContainerPartitionKey_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForContainerPartitionKey_Status tests if a specific instance of ContainerPartitionKey_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForContainerPartitionKey_Status(subject ContainerPartitionKey_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ContainerPartitionKey_Status
	err := copied.AssignPropertiesToContainerPartitionKey_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ContainerPartitionKey_Status
	err = actual.AssignPropertiesFromContainerPartitionKey_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ContainerPartitionKey_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPartitionKey_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPartitionKey_Status, ContainerPartitionKey_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPartitionKey_Status runs a test to see if a specific instance of ContainerPartitionKey_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPartitionKey_Status(subject ContainerPartitionKey_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPartitionKey_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPartitionKey_Status instances for property testing - lazily instantiated by
//ContainerPartitionKey_StatusGenerator()
var containerPartitionKey_statusGenerator gopter.Gen

// ContainerPartitionKey_StatusGenerator returns a generator of ContainerPartitionKey_Status instances for property testing.
func ContainerPartitionKey_StatusGenerator() gopter.Gen {
	if containerPartitionKey_statusGenerator != nil {
		return containerPartitionKey_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPartitionKey_Status(generators)
	containerPartitionKey_statusGenerator = gen.Struct(reflect.TypeOf(ContainerPartitionKey_Status{}), generators)

	return containerPartitionKey_statusGenerator
}

// AddIndependentPropertyGeneratorsForContainerPartitionKey_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPartitionKey_Status(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ContainerPartitionKey_Kind_StatusHash, ContainerPartitionKey_Kind_StatusMultiHash, ContainerPartitionKey_Kind_StatusRange))
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
	gens["SystemKey"] = gen.PtrOf(gen.Bool())
	gens["Version"] = gen.PtrOf(gen.Int())
}

func Test_IndexingPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IndexingPolicy_Spec to IndexingPolicy_Spec via AssignPropertiesToIndexingPolicy_Spec & AssignPropertiesFromIndexingPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForIndexingPolicy_Spec, IndexingPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIndexingPolicy_Spec tests if a specific instance of IndexingPolicy_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIndexingPolicy_Spec(subject IndexingPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.IndexingPolicy_Spec
	err := copied.AssignPropertiesToIndexingPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IndexingPolicy_Spec
	err = actual.AssignPropertiesFromIndexingPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IndexingPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IndexingPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexingPolicy_Spec, IndexingPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexingPolicy_Spec runs a test to see if a specific instance of IndexingPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexingPolicy_Spec(subject IndexingPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IndexingPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IndexingPolicy_Spec instances for property testing - lazily instantiated by
//IndexingPolicy_SpecGenerator()
var indexingPolicy_specGenerator gopter.Gen

// IndexingPolicy_SpecGenerator returns a generator of IndexingPolicy_Spec instances for property testing.
// We first initialize indexingPolicy_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IndexingPolicy_SpecGenerator() gopter.Gen {
	if indexingPolicy_specGenerator != nil {
		return indexingPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicy_Spec(generators)
	indexingPolicy_specGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicy_Spec(generators)
	AddRelatedPropertyGeneratorsForIndexingPolicy_Spec(generators)
	indexingPolicy_specGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_Spec{}), generators)

	return indexingPolicy_specGenerator
}

// AddIndependentPropertyGeneratorsForIndexingPolicy_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexingPolicy_Spec(gens map[string]gopter.Gen) {
	gens["Automatic"] = gen.PtrOf(gen.Bool())
	gens["IndexingMode"] = gen.PtrOf(gen.OneConstOf(IndexingPolicy_IndexingMode_SpecConsistent, IndexingPolicy_IndexingMode_SpecLazy, IndexingPolicy_IndexingMode_SpecNone))
}

// AddRelatedPropertyGeneratorsForIndexingPolicy_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIndexingPolicy_Spec(gens map[string]gopter.Gen) {
	gens["CompositeIndexes"] = gen.SliceOf(gen.SliceOf(CompositePath_SpecGenerator()))
	gens["ExcludedPaths"] = gen.SliceOf(ExcludedPath_SpecGenerator())
	gens["IncludedPaths"] = gen.SliceOf(IncludedPath_SpecGenerator())
	gens["SpatialIndexes"] = gen.SliceOf(SpatialSpec_SpecGenerator())
}

func Test_IndexingPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IndexingPolicy_Status to IndexingPolicy_Status via AssignPropertiesToIndexingPolicy_Status & AssignPropertiesFromIndexingPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForIndexingPolicy_Status, IndexingPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIndexingPolicy_Status tests if a specific instance of IndexingPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIndexingPolicy_Status(subject IndexingPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.IndexingPolicy_Status
	err := copied.AssignPropertiesToIndexingPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IndexingPolicy_Status
	err = actual.AssignPropertiesFromIndexingPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IndexingPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IndexingPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexingPolicy_Status, IndexingPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexingPolicy_Status runs a test to see if a specific instance of IndexingPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexingPolicy_Status(subject IndexingPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IndexingPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IndexingPolicy_Status instances for property testing - lazily instantiated by
//IndexingPolicy_StatusGenerator()
var indexingPolicy_statusGenerator gopter.Gen

// IndexingPolicy_StatusGenerator returns a generator of IndexingPolicy_Status instances for property testing.
// We first initialize indexingPolicy_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IndexingPolicy_StatusGenerator() gopter.Gen {
	if indexingPolicy_statusGenerator != nil {
		return indexingPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicy_Status(generators)
	indexingPolicy_statusGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicy_Status(generators)
	AddRelatedPropertyGeneratorsForIndexingPolicy_Status(generators)
	indexingPolicy_statusGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_Status{}), generators)

	return indexingPolicy_statusGenerator
}

// AddIndependentPropertyGeneratorsForIndexingPolicy_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexingPolicy_Status(gens map[string]gopter.Gen) {
	gens["Automatic"] = gen.PtrOf(gen.Bool())
	gens["IndexingMode"] = gen.PtrOf(gen.OneConstOf(IndexingPolicy_IndexingMode_StatusConsistent, IndexingPolicy_IndexingMode_StatusLazy, IndexingPolicy_IndexingMode_StatusNone))
}

// AddRelatedPropertyGeneratorsForIndexingPolicy_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIndexingPolicy_Status(gens map[string]gopter.Gen) {
	gens["CompositeIndexes"] = gen.SliceOf(gen.SliceOf(CompositePath_StatusGenerator()))
	gens["ExcludedPaths"] = gen.SliceOf(ExcludedPath_StatusGenerator())
	gens["IncludedPaths"] = gen.SliceOf(IncludedPath_StatusGenerator())
	gens["SpatialIndexes"] = gen.SliceOf(SpatialSpec_StatusGenerator())
}

func Test_UniqueKeyPolicy_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UniqueKeyPolicy_Spec to UniqueKeyPolicy_Spec via AssignPropertiesToUniqueKeyPolicy_Spec & AssignPropertiesFromUniqueKeyPolicy_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForUniqueKeyPolicy_Spec, UniqueKeyPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUniqueKeyPolicy_Spec tests if a specific instance of UniqueKeyPolicy_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForUniqueKeyPolicy_Spec(subject UniqueKeyPolicy_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.UniqueKeyPolicy_Spec
	err := copied.AssignPropertiesToUniqueKeyPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UniqueKeyPolicy_Spec
	err = actual.AssignPropertiesFromUniqueKeyPolicy_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UniqueKeyPolicy_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKeyPolicy_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKeyPolicy_Spec, UniqueKeyPolicy_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKeyPolicy_Spec runs a test to see if a specific instance of UniqueKeyPolicy_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKeyPolicy_Spec(subject UniqueKeyPolicy_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKeyPolicy_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKeyPolicy_Spec instances for property testing - lazily instantiated by
//UniqueKeyPolicy_SpecGenerator()
var uniqueKeyPolicy_specGenerator gopter.Gen

// UniqueKeyPolicy_SpecGenerator returns a generator of UniqueKeyPolicy_Spec instances for property testing.
func UniqueKeyPolicy_SpecGenerator() gopter.Gen {
	if uniqueKeyPolicy_specGenerator != nil {
		return uniqueKeyPolicy_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForUniqueKeyPolicy_Spec(generators)
	uniqueKeyPolicy_specGenerator = gen.Struct(reflect.TypeOf(UniqueKeyPolicy_Spec{}), generators)

	return uniqueKeyPolicy_specGenerator
}

// AddRelatedPropertyGeneratorsForUniqueKeyPolicy_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUniqueKeyPolicy_Spec(gens map[string]gopter.Gen) {
	gens["UniqueKeys"] = gen.SliceOf(UniqueKey_SpecGenerator())
}

func Test_UniqueKeyPolicy_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UniqueKeyPolicy_Status to UniqueKeyPolicy_Status via AssignPropertiesToUniqueKeyPolicy_Status & AssignPropertiesFromUniqueKeyPolicy_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForUniqueKeyPolicy_Status, UniqueKeyPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUniqueKeyPolicy_Status tests if a specific instance of UniqueKeyPolicy_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForUniqueKeyPolicy_Status(subject UniqueKeyPolicy_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.UniqueKeyPolicy_Status
	err := copied.AssignPropertiesToUniqueKeyPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UniqueKeyPolicy_Status
	err = actual.AssignPropertiesFromUniqueKeyPolicy_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UniqueKeyPolicy_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKeyPolicy_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKeyPolicy_Status, UniqueKeyPolicy_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKeyPolicy_Status runs a test to see if a specific instance of UniqueKeyPolicy_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKeyPolicy_Status(subject UniqueKeyPolicy_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKeyPolicy_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKeyPolicy_Status instances for property testing - lazily instantiated by
//UniqueKeyPolicy_StatusGenerator()
var uniqueKeyPolicy_statusGenerator gopter.Gen

// UniqueKeyPolicy_StatusGenerator returns a generator of UniqueKeyPolicy_Status instances for property testing.
func UniqueKeyPolicy_StatusGenerator() gopter.Gen {
	if uniqueKeyPolicy_statusGenerator != nil {
		return uniqueKeyPolicy_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForUniqueKeyPolicy_Status(generators)
	uniqueKeyPolicy_statusGenerator = gen.Struct(reflect.TypeOf(UniqueKeyPolicy_Status{}), generators)

	return uniqueKeyPolicy_statusGenerator
}

// AddRelatedPropertyGeneratorsForUniqueKeyPolicy_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUniqueKeyPolicy_Status(gens map[string]gopter.Gen) {
	gens["UniqueKeys"] = gen.SliceOf(UniqueKey_StatusGenerator())
}

func Test_CompositePath_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CompositePath_Spec to CompositePath_Spec via AssignPropertiesToCompositePath_Spec & AssignPropertiesFromCompositePath_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompositePath_Spec, CompositePath_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompositePath_Spec tests if a specific instance of CompositePath_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCompositePath_Spec(subject CompositePath_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.CompositePath_Spec
	err := copied.AssignPropertiesToCompositePath_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CompositePath_Spec
	err = actual.AssignPropertiesFromCompositePath_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CompositePath_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CompositePath_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompositePath_Spec, CompositePath_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompositePath_Spec runs a test to see if a specific instance of CompositePath_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForCompositePath_Spec(subject CompositePath_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CompositePath_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CompositePath_Spec instances for property testing - lazily instantiated by CompositePath_SpecGenerator()
var compositePath_specGenerator gopter.Gen

// CompositePath_SpecGenerator returns a generator of CompositePath_Spec instances for property testing.
func CompositePath_SpecGenerator() gopter.Gen {
	if compositePath_specGenerator != nil {
		return compositePath_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompositePath_Spec(generators)
	compositePath_specGenerator = gen.Struct(reflect.TypeOf(CompositePath_Spec{}), generators)

	return compositePath_specGenerator
}

// AddIndependentPropertyGeneratorsForCompositePath_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompositePath_Spec(gens map[string]gopter.Gen) {
	gens["Order"] = gen.PtrOf(gen.OneConstOf(CompositePath_Order_SpecAscending, CompositePath_Order_SpecDescending))
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_CompositePath_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CompositePath_Status to CompositePath_Status via AssignPropertiesToCompositePath_Status & AssignPropertiesFromCompositePath_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForCompositePath_Status, CompositePath_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCompositePath_Status tests if a specific instance of CompositePath_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForCompositePath_Status(subject CompositePath_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.CompositePath_Status
	err := copied.AssignPropertiesToCompositePath_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CompositePath_Status
	err = actual.AssignPropertiesFromCompositePath_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CompositePath_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CompositePath_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompositePath_Status, CompositePath_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompositePath_Status runs a test to see if a specific instance of CompositePath_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForCompositePath_Status(subject CompositePath_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CompositePath_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CompositePath_Status instances for property testing - lazily instantiated by
//CompositePath_StatusGenerator()
var compositePath_statusGenerator gopter.Gen

// CompositePath_StatusGenerator returns a generator of CompositePath_Status instances for property testing.
func CompositePath_StatusGenerator() gopter.Gen {
	if compositePath_statusGenerator != nil {
		return compositePath_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompositePath_Status(generators)
	compositePath_statusGenerator = gen.Struct(reflect.TypeOf(CompositePath_Status{}), generators)

	return compositePath_statusGenerator
}

// AddIndependentPropertyGeneratorsForCompositePath_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompositePath_Status(gens map[string]gopter.Gen) {
	gens["Order"] = gen.PtrOf(gen.OneConstOf(CompositePath_Order_StatusAscending, CompositePath_Order_StatusDescending))
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExcludedPath_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExcludedPath_Spec to ExcludedPath_Spec via AssignPropertiesToExcludedPath_Spec & AssignPropertiesFromExcludedPath_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForExcludedPath_Spec, ExcludedPath_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExcludedPath_Spec tests if a specific instance of ExcludedPath_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForExcludedPath_Spec(subject ExcludedPath_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ExcludedPath_Spec
	err := copied.AssignPropertiesToExcludedPath_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExcludedPath_Spec
	err = actual.AssignPropertiesFromExcludedPath_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExcludedPath_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExcludedPath_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExcludedPath_Spec, ExcludedPath_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExcludedPath_Spec runs a test to see if a specific instance of ExcludedPath_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForExcludedPath_Spec(subject ExcludedPath_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExcludedPath_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExcludedPath_Spec instances for property testing - lazily instantiated by ExcludedPath_SpecGenerator()
var excludedPath_specGenerator gopter.Gen

// ExcludedPath_SpecGenerator returns a generator of ExcludedPath_Spec instances for property testing.
func ExcludedPath_SpecGenerator() gopter.Gen {
	if excludedPath_specGenerator != nil {
		return excludedPath_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExcludedPath_Spec(generators)
	excludedPath_specGenerator = gen.Struct(reflect.TypeOf(ExcludedPath_Spec{}), generators)

	return excludedPath_specGenerator
}

// AddIndependentPropertyGeneratorsForExcludedPath_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExcludedPath_Spec(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExcludedPath_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ExcludedPath_Status to ExcludedPath_Status via AssignPropertiesToExcludedPath_Status & AssignPropertiesFromExcludedPath_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForExcludedPath_Status, ExcludedPath_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForExcludedPath_Status tests if a specific instance of ExcludedPath_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForExcludedPath_Status(subject ExcludedPath_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.ExcludedPath_Status
	err := copied.AssignPropertiesToExcludedPath_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ExcludedPath_Status
	err = actual.AssignPropertiesFromExcludedPath_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ExcludedPath_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExcludedPath_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExcludedPath_Status, ExcludedPath_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExcludedPath_Status runs a test to see if a specific instance of ExcludedPath_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForExcludedPath_Status(subject ExcludedPath_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExcludedPath_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExcludedPath_Status instances for property testing - lazily instantiated by
//ExcludedPath_StatusGenerator()
var excludedPath_statusGenerator gopter.Gen

// ExcludedPath_StatusGenerator returns a generator of ExcludedPath_Status instances for property testing.
func ExcludedPath_StatusGenerator() gopter.Gen {
	if excludedPath_statusGenerator != nil {
		return excludedPath_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExcludedPath_Status(generators)
	excludedPath_statusGenerator = gen.Struct(reflect.TypeOf(ExcludedPath_Status{}), generators)

	return excludedPath_statusGenerator
}

// AddIndependentPropertyGeneratorsForExcludedPath_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExcludedPath_Status(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_IncludedPath_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IncludedPath_Spec to IncludedPath_Spec via AssignPropertiesToIncludedPath_Spec & AssignPropertiesFromIncludedPath_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForIncludedPath_Spec, IncludedPath_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIncludedPath_Spec tests if a specific instance of IncludedPath_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIncludedPath_Spec(subject IncludedPath_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.IncludedPath_Spec
	err := copied.AssignPropertiesToIncludedPath_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IncludedPath_Spec
	err = actual.AssignPropertiesFromIncludedPath_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IncludedPath_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IncludedPath_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIncludedPath_Spec, IncludedPath_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIncludedPath_Spec runs a test to see if a specific instance of IncludedPath_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIncludedPath_Spec(subject IncludedPath_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IncludedPath_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IncludedPath_Spec instances for property testing - lazily instantiated by IncludedPath_SpecGenerator()
var includedPath_specGenerator gopter.Gen

// IncludedPath_SpecGenerator returns a generator of IncludedPath_Spec instances for property testing.
// We first initialize includedPath_specGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IncludedPath_SpecGenerator() gopter.Gen {
	if includedPath_specGenerator != nil {
		return includedPath_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPath_Spec(generators)
	includedPath_specGenerator = gen.Struct(reflect.TypeOf(IncludedPath_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPath_Spec(generators)
	AddRelatedPropertyGeneratorsForIncludedPath_Spec(generators)
	includedPath_specGenerator = gen.Struct(reflect.TypeOf(IncludedPath_Spec{}), generators)

	return includedPath_specGenerator
}

// AddIndependentPropertyGeneratorsForIncludedPath_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIncludedPath_Spec(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIncludedPath_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIncludedPath_Spec(gens map[string]gopter.Gen) {
	gens["Indexes"] = gen.SliceOf(Indexes_SpecGenerator())
}

func Test_IncludedPath_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IncludedPath_Status to IncludedPath_Status via AssignPropertiesToIncludedPath_Status & AssignPropertiesFromIncludedPath_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForIncludedPath_Status, IncludedPath_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIncludedPath_Status tests if a specific instance of IncludedPath_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIncludedPath_Status(subject IncludedPath_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.IncludedPath_Status
	err := copied.AssignPropertiesToIncludedPath_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IncludedPath_Status
	err = actual.AssignPropertiesFromIncludedPath_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IncludedPath_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IncludedPath_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIncludedPath_Status, IncludedPath_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIncludedPath_Status runs a test to see if a specific instance of IncludedPath_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIncludedPath_Status(subject IncludedPath_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IncludedPath_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IncludedPath_Status instances for property testing - lazily instantiated by
//IncludedPath_StatusGenerator()
var includedPath_statusGenerator gopter.Gen

// IncludedPath_StatusGenerator returns a generator of IncludedPath_Status instances for property testing.
// We first initialize includedPath_statusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IncludedPath_StatusGenerator() gopter.Gen {
	if includedPath_statusGenerator != nil {
		return includedPath_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPath_Status(generators)
	includedPath_statusGenerator = gen.Struct(reflect.TypeOf(IncludedPath_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPath_Status(generators)
	AddRelatedPropertyGeneratorsForIncludedPath_Status(generators)
	includedPath_statusGenerator = gen.Struct(reflect.TypeOf(IncludedPath_Status{}), generators)

	return includedPath_statusGenerator
}

// AddIndependentPropertyGeneratorsForIncludedPath_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIncludedPath_Status(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIncludedPath_Status is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIncludedPath_Status(gens map[string]gopter.Gen) {
	gens["Indexes"] = gen.SliceOf(Indexes_StatusGenerator())
}

func Test_SpatialSpec_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SpatialSpec_Spec to SpatialSpec_Spec via AssignPropertiesToSpatialSpec_Spec & AssignPropertiesFromSpatialSpec_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForSpatialSpec_Spec, SpatialSpec_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSpatialSpec_Spec tests if a specific instance of SpatialSpec_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForSpatialSpec_Spec(subject SpatialSpec_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.SpatialSpec_Spec
	err := copied.AssignPropertiesToSpatialSpec_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SpatialSpec_Spec
	err = actual.AssignPropertiesFromSpatialSpec_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SpatialSpec_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SpatialSpec_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSpatialSpec_Spec, SpatialSpec_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSpatialSpec_Spec runs a test to see if a specific instance of SpatialSpec_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSpatialSpec_Spec(subject SpatialSpec_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SpatialSpec_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SpatialSpec_Spec instances for property testing - lazily instantiated by SpatialSpec_SpecGenerator()
var spatialSpec_specGenerator gopter.Gen

// SpatialSpec_SpecGenerator returns a generator of SpatialSpec_Spec instances for property testing.
func SpatialSpec_SpecGenerator() gopter.Gen {
	if spatialSpec_specGenerator != nil {
		return spatialSpec_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSpatialSpec_Spec(generators)
	spatialSpec_specGenerator = gen.Struct(reflect.TypeOf(SpatialSpec_Spec{}), generators)

	return spatialSpec_specGenerator
}

// AddIndependentPropertyGeneratorsForSpatialSpec_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSpatialSpec_Spec(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Types"] = gen.SliceOf(gen.OneConstOf(
		SpatialType_SpecLineString,
		SpatialType_SpecMultiPolygon,
		SpatialType_SpecPoint,
		SpatialType_SpecPolygon))
}

func Test_SpatialSpec_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SpatialSpec_Status to SpatialSpec_Status via AssignPropertiesToSpatialSpec_Status & AssignPropertiesFromSpatialSpec_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForSpatialSpec_Status, SpatialSpec_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSpatialSpec_Status tests if a specific instance of SpatialSpec_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForSpatialSpec_Status(subject SpatialSpec_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.SpatialSpec_Status
	err := copied.AssignPropertiesToSpatialSpec_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SpatialSpec_Status
	err = actual.AssignPropertiesFromSpatialSpec_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SpatialSpec_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SpatialSpec_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSpatialSpec_Status, SpatialSpec_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSpatialSpec_Status runs a test to see if a specific instance of SpatialSpec_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSpatialSpec_Status(subject SpatialSpec_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SpatialSpec_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SpatialSpec_Status instances for property testing - lazily instantiated by SpatialSpec_StatusGenerator()
var spatialSpec_statusGenerator gopter.Gen

// SpatialSpec_StatusGenerator returns a generator of SpatialSpec_Status instances for property testing.
func SpatialSpec_StatusGenerator() gopter.Gen {
	if spatialSpec_statusGenerator != nil {
		return spatialSpec_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSpatialSpec_Status(generators)
	spatialSpec_statusGenerator = gen.Struct(reflect.TypeOf(SpatialSpec_Status{}), generators)

	return spatialSpec_statusGenerator
}

// AddIndependentPropertyGeneratorsForSpatialSpec_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSpatialSpec_Status(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Types"] = gen.SliceOf(gen.OneConstOf(
		SpatialType_StatusLineString,
		SpatialType_StatusMultiPolygon,
		SpatialType_StatusPoint,
		SpatialType_StatusPolygon))
}

func Test_UniqueKey_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UniqueKey_Spec to UniqueKey_Spec via AssignPropertiesToUniqueKey_Spec & AssignPropertiesFromUniqueKey_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForUniqueKey_Spec, UniqueKey_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUniqueKey_Spec tests if a specific instance of UniqueKey_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForUniqueKey_Spec(subject UniqueKey_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.UniqueKey_Spec
	err := copied.AssignPropertiesToUniqueKey_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UniqueKey_Spec
	err = actual.AssignPropertiesFromUniqueKey_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UniqueKey_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKey_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKey_Spec, UniqueKey_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKey_Spec runs a test to see if a specific instance of UniqueKey_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKey_Spec(subject UniqueKey_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKey_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKey_Spec instances for property testing - lazily instantiated by UniqueKey_SpecGenerator()
var uniqueKey_specGenerator gopter.Gen

// UniqueKey_SpecGenerator returns a generator of UniqueKey_Spec instances for property testing.
func UniqueKey_SpecGenerator() gopter.Gen {
	if uniqueKey_specGenerator != nil {
		return uniqueKey_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUniqueKey_Spec(generators)
	uniqueKey_specGenerator = gen.Struct(reflect.TypeOf(UniqueKey_Spec{}), generators)

	return uniqueKey_specGenerator
}

// AddIndependentPropertyGeneratorsForUniqueKey_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUniqueKey_Spec(gens map[string]gopter.Gen) {
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
}

func Test_UniqueKey_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UniqueKey_Status to UniqueKey_Status via AssignPropertiesToUniqueKey_Status & AssignPropertiesFromUniqueKey_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForUniqueKey_Status, UniqueKey_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUniqueKey_Status tests if a specific instance of UniqueKey_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForUniqueKey_Status(subject UniqueKey_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.UniqueKey_Status
	err := copied.AssignPropertiesToUniqueKey_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UniqueKey_Status
	err = actual.AssignPropertiesFromUniqueKey_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UniqueKey_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKey_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKey_Status, UniqueKey_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKey_Status runs a test to see if a specific instance of UniqueKey_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKey_Status(subject UniqueKey_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKey_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKey_Status instances for property testing - lazily instantiated by UniqueKey_StatusGenerator()
var uniqueKey_statusGenerator gopter.Gen

// UniqueKey_StatusGenerator returns a generator of UniqueKey_Status instances for property testing.
func UniqueKey_StatusGenerator() gopter.Gen {
	if uniqueKey_statusGenerator != nil {
		return uniqueKey_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUniqueKey_Status(generators)
	uniqueKey_statusGenerator = gen.Struct(reflect.TypeOf(UniqueKey_Status{}), generators)

	return uniqueKey_statusGenerator
}

// AddIndependentPropertyGeneratorsForUniqueKey_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUniqueKey_Status(gens map[string]gopter.Gen) {
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
}

func Test_Indexes_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Indexes_Spec to Indexes_Spec via AssignPropertiesToIndexes_Spec & AssignPropertiesFromIndexes_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForIndexes_Spec, Indexes_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIndexes_Spec tests if a specific instance of Indexes_Spec can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIndexes_Spec(subject Indexes_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Indexes_Spec
	err := copied.AssignPropertiesToIndexes_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Indexes_Spec
	err = actual.AssignPropertiesFromIndexes_Spec(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Indexes_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Indexes_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexes_Spec, Indexes_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexes_Spec runs a test to see if a specific instance of Indexes_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexes_Spec(subject Indexes_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Indexes_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Indexes_Spec instances for property testing - lazily instantiated by Indexes_SpecGenerator()
var indexes_specGenerator gopter.Gen

// Indexes_SpecGenerator returns a generator of Indexes_Spec instances for property testing.
func Indexes_SpecGenerator() gopter.Gen {
	if indexes_specGenerator != nil {
		return indexes_specGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexes_Spec(generators)
	indexes_specGenerator = gen.Struct(reflect.TypeOf(Indexes_Spec{}), generators)

	return indexes_specGenerator
}

// AddIndependentPropertyGeneratorsForIndexes_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexes_Spec(gens map[string]gopter.Gen) {
	gens["DataType"] = gen.PtrOf(gen.OneConstOf(
		Indexes_DataType_SpecLineString,
		Indexes_DataType_SpecMultiPolygon,
		Indexes_DataType_SpecNumber,
		Indexes_DataType_SpecPoint,
		Indexes_DataType_SpecPolygon,
		Indexes_DataType_SpecString))
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(Indexes_Kind_SpecHash, Indexes_Kind_SpecRange, Indexes_Kind_SpecSpatial))
	gens["Precision"] = gen.PtrOf(gen.Int())
}

func Test_Indexes_Status_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Indexes_Status to Indexes_Status via AssignPropertiesToIndexes_Status & AssignPropertiesFromIndexes_Status returns original",
		prop.ForAll(RunPropertyAssignmentTestForIndexes_Status, Indexes_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIndexes_Status tests if a specific instance of Indexes_Status can be assigned to v1alpha1api20210515storage and back losslessly
func RunPropertyAssignmentTestForIndexes_Status(subject Indexes_Status) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v1alpha1api20210515storage.Indexes_Status
	err := copied.AssignPropertiesToIndexes_Status(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Indexes_Status
	err = actual.AssignPropertiesFromIndexes_Status(&other)
	if err != nil {
		return err.Error()
	}

	//Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Indexes_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Indexes_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexes_Status, Indexes_StatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexes_Status runs a test to see if a specific instance of Indexes_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexes_Status(subject Indexes_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Indexes_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Indexes_Status instances for property testing - lazily instantiated by Indexes_StatusGenerator()
var indexes_statusGenerator gopter.Gen

// Indexes_StatusGenerator returns a generator of Indexes_Status instances for property testing.
func Indexes_StatusGenerator() gopter.Gen {
	if indexes_statusGenerator != nil {
		return indexes_statusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexes_Status(generators)
	indexes_statusGenerator = gen.Struct(reflect.TypeOf(Indexes_Status{}), generators)

	return indexes_statusGenerator
}

// AddIndependentPropertyGeneratorsForIndexes_Status is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexes_Status(gens map[string]gopter.Gen) {
	gens["DataType"] = gen.PtrOf(gen.OneConstOf(
		Indexes_DataType_StatusLineString,
		Indexes_DataType_StatusMultiPolygon,
		Indexes_DataType_StatusNumber,
		Indexes_DataType_StatusPoint,
		Indexes_DataType_StatusPolygon,
		Indexes_DataType_StatusString))
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(Indexes_Kind_StatusHash, Indexes_Kind_StatusRange, Indexes_Kind_StatusSpatial))
	gens["Precision"] = gen.PtrOf(gen.Int())
}
