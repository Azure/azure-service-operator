// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DatabaseAccount_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccount_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccount_StatusARM, DatabaseAccount_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccount_StatusARM runs a test to see if a specific instance of DatabaseAccount_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccount_StatusARM(subject DatabaseAccount_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccount_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccount_StatusARM instances for property testing - lazily instantiated by
//DatabaseAccount_StatusARMGenerator()
var databaseAccount_statusARMGenerator gopter.Gen

// DatabaseAccount_StatusARMGenerator returns a generator of DatabaseAccount_StatusARM instances for property testing.
// We first initialize databaseAccount_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccount_StatusARMGenerator() gopter.Gen {
	if databaseAccount_statusARMGenerator != nil {
		return databaseAccount_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccount_StatusARM(generators)
	databaseAccount_statusARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccount_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccount_StatusARM(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccount_StatusARM(generators)
	databaseAccount_statusARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccount_StatusARM{}), generators)

	return databaseAccount_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccount_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccount_StatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(DatabaseAccount_Kind_StatusGlobalDocumentDB, DatabaseAccount_Kind_StatusMongoDB, DatabaseAccount_Kind_StatusParse))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccount_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccount_StatusARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_StatusARMGenerator())
	gens["Properties"] = gen.PtrOf(DatabaseAccountProperties_StatusARMGenerator())
}

func Test_DatabaseAccountProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountProperties_StatusARM, DatabaseAccountProperties_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountProperties_StatusARM runs a test to see if a specific instance of DatabaseAccountProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountProperties_StatusARM(subject DatabaseAccountProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountProperties_StatusARM instances for property testing - lazily instantiated by
//DatabaseAccountProperties_StatusARMGenerator()
var databaseAccountProperties_statusARMGenerator gopter.Gen

// DatabaseAccountProperties_StatusARMGenerator returns a generator of DatabaseAccountProperties_StatusARM instances for property testing.
// We first initialize databaseAccountProperties_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountProperties_StatusARMGenerator() gopter.Gen {
	if databaseAccountProperties_statusARMGenerator != nil {
		return databaseAccountProperties_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountProperties_StatusARM(generators)
	databaseAccountProperties_statusARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountProperties_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountProperties_StatusARM(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountProperties_StatusARM(generators)
	databaseAccountProperties_statusARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountProperties_StatusARM{}), generators)

	return databaseAccountProperties_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountProperties_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountProperties_StatusARM(gens map[string]gopter.Gen) {
	gens["ConnectorOffer"] = gen.PtrOf(gen.OneConstOf(ConnectorOffer_StatusSmall))
	gens["DatabaseAccountOfferType"] = gen.OneConstOf(DatabaseAccountOfferType_StatusStandard)
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.OneConstOf(NetworkAclBypass_StatusAzureServices, NetworkAclBypass_StatusNone))
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccess_StatusDisabled, PublicNetworkAccess_StatusEnabled))
}

// AddRelatedPropertyGeneratorsForDatabaseAccountProperties_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountProperties_StatusARM(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfiguration_StatusARMGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiProperties_StatusARMGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicy_StatusARMGenerator())
	gens["Capabilities"] = gen.SliceOf(Capability_StatusARMGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicy_StatusARMGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicy_StatusARMGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRange_StatusARMGenerator())
	gens["Locations"] = gen.SliceOf(Location_StatusARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_StatusARMGenerator())
}

func Test_ManagedServiceIdentity_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_StatusARM, ManagedServiceIdentity_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_StatusARM runs a test to see if a specific instance of ManagedServiceIdentity_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_StatusARM(subject ManagedServiceIdentity_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_StatusARM instances for property testing - lazily instantiated by
//ManagedServiceIdentity_StatusARMGenerator()
var managedServiceIdentity_statusARMGenerator gopter.Gen

// ManagedServiceIdentity_StatusARMGenerator returns a generator of ManagedServiceIdentity_StatusARM instances for property testing.
// We first initialize managedServiceIdentity_statusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_StatusARMGenerator() gopter.Gen {
	if managedServiceIdentity_statusARMGenerator != nil {
		return managedServiceIdentity_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_StatusARM(generators)
	managedServiceIdentity_statusARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_StatusARM(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_StatusARM(generators)
	managedServiceIdentity_statusARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_StatusARM{}), generators)

	return managedServiceIdentity_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_StatusARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentity_Type_StatusNone,
		ManagedServiceIdentity_Type_StatusSystemAssigned,
		ManagedServiceIdentity_Type_StatusSystemAssignedUserAssigned,
		ManagedServiceIdentity_Type_StatusUserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_StatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_StatusARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), ManagedServiceIdentity_UserAssignedIdentities_StatusARMGenerator())
}

func Test_AnalyticalStorageConfiguration_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfiguration_StatusARM, AnalyticalStorageConfiguration_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfiguration_StatusARM runs a test to see if a specific instance of AnalyticalStorageConfiguration_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfiguration_StatusARM(subject AnalyticalStorageConfiguration_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration_StatusARM instances for property testing - lazily instantiated by
//AnalyticalStorageConfiguration_StatusARMGenerator()
var analyticalStorageConfiguration_statusARMGenerator gopter.Gen

// AnalyticalStorageConfiguration_StatusARMGenerator returns a generator of AnalyticalStorageConfiguration_StatusARM instances for property testing.
func AnalyticalStorageConfiguration_StatusARMGenerator() gopter.Gen {
	if analyticalStorageConfiguration_statusARMGenerator != nil {
		return analyticalStorageConfiguration_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_StatusARM(generators)
	analyticalStorageConfiguration_statusARMGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration_StatusARM{}), generators)

	return analyticalStorageConfiguration_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_StatusARM(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.OneConstOf(AnalyticalStorageSchemaType_StatusFullFidelity, AnalyticalStorageSchemaType_StatusWellDefined))
}

func Test_ApiProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProperties_StatusARM, ApiProperties_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProperties_StatusARM runs a test to see if a specific instance of ApiProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProperties_StatusARM(subject ApiProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_StatusARM instances for property testing - lazily instantiated by
//ApiProperties_StatusARMGenerator()
var apiProperties_statusARMGenerator gopter.Gen

// ApiProperties_StatusARMGenerator returns a generator of ApiProperties_StatusARM instances for property testing.
func ApiProperties_StatusARMGenerator() gopter.Gen {
	if apiProperties_statusARMGenerator != nil {
		return apiProperties_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProperties_StatusARM(generators)
	apiProperties_statusARMGenerator = gen.Struct(reflect.TypeOf(ApiProperties_StatusARM{}), generators)

	return apiProperties_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForApiProperties_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProperties_StatusARM(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.OneConstOf(ApiProperties_ServerVersion_Status32, ApiProperties_ServerVersion_Status36, ApiProperties_ServerVersion_Status40))
}

func Test_BackupPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicy_StatusARM, BackupPolicy_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicy_StatusARM runs a test to see if a specific instance of BackupPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicy_StatusARM(subject BackupPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_StatusARM instances for property testing - lazily instantiated by
//BackupPolicy_StatusARMGenerator()
var backupPolicy_statusARMGenerator gopter.Gen

// BackupPolicy_StatusARMGenerator returns a generator of BackupPolicy_StatusARM instances for property testing.
func BackupPolicy_StatusARMGenerator() gopter.Gen {
	if backupPolicy_statusARMGenerator != nil {
		return backupPolicy_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicy_StatusARM(generators)
	backupPolicy_statusARMGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_StatusARM{}), generators)

	return backupPolicy_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicy_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicy_StatusARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.OneConstOf(BackupPolicyType_StatusContinuous, BackupPolicyType_StatusPeriodic)
}

func Test_Capability_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapability_StatusARM, Capability_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapability_StatusARM runs a test to see if a specific instance of Capability_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCapability_StatusARM(subject Capability_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability_StatusARM instances for property testing - lazily instantiated by
//Capability_StatusARMGenerator()
var capability_statusARMGenerator gopter.Gen

// Capability_StatusARMGenerator returns a generator of Capability_StatusARM instances for property testing.
func Capability_StatusARMGenerator() gopter.Gen {
	if capability_statusARMGenerator != nil {
		return capability_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapability_StatusARM(generators)
	capability_statusARMGenerator = gen.Struct(reflect.TypeOf(Capability_StatusARM{}), generators)

	return capability_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForCapability_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapability_StatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ConsistencyPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicy_StatusARM, ConsistencyPolicy_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicy_StatusARM runs a test to see if a specific instance of ConsistencyPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicy_StatusARM(subject ConsistencyPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy_StatusARM instances for property testing - lazily instantiated by
//ConsistencyPolicy_StatusARMGenerator()
var consistencyPolicy_statusARMGenerator gopter.Gen

// ConsistencyPolicy_StatusARMGenerator returns a generator of ConsistencyPolicy_StatusARM instances for property testing.
func ConsistencyPolicy_StatusARMGenerator() gopter.Gen {
	if consistencyPolicy_statusARMGenerator != nil {
		return consistencyPolicy_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicy_StatusARM(generators)
	consistencyPolicy_statusARMGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy_StatusARM{}), generators)

	return consistencyPolicy_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicy_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicy_StatusARM(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.OneConstOf(
		ConsistencyPolicy_DefaultConsistencyLevel_StatusBoundedStaleness,
		ConsistencyPolicy_DefaultConsistencyLevel_StatusConsistentPrefix,
		ConsistencyPolicy_DefaultConsistencyLevel_StatusEventual,
		ConsistencyPolicy_DefaultConsistencyLevel_StatusSession,
		ConsistencyPolicy_DefaultConsistencyLevel_StatusStrong)
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicy_StatusARM, CorsPolicy_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicy_StatusARM runs a test to see if a specific instance of CorsPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicy_StatusARM(subject CorsPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_StatusARM instances for property testing - lazily instantiated by
//CorsPolicy_StatusARMGenerator()
var corsPolicy_statusARMGenerator gopter.Gen

// CorsPolicy_StatusARMGenerator returns a generator of CorsPolicy_StatusARM instances for property testing.
func CorsPolicy_StatusARMGenerator() gopter.Gen {
	if corsPolicy_statusARMGenerator != nil {
		return corsPolicy_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicy_StatusARM(generators)
	corsPolicy_statusARMGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_StatusARM{}), generators)

	return corsPolicy_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicy_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicy_StatusARM(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.AlphaString()
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_IpAddressOrRange_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRange_StatusARM, IpAddressOrRange_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRange_StatusARM runs a test to see if a specific instance of IpAddressOrRange_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRange_StatusARM(subject IpAddressOrRange_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange_StatusARM instances for property testing - lazily instantiated by
//IpAddressOrRange_StatusARMGenerator()
var ipAddressOrRange_statusARMGenerator gopter.Gen

// IpAddressOrRange_StatusARMGenerator returns a generator of IpAddressOrRange_StatusARM instances for property testing.
func IpAddressOrRange_StatusARMGenerator() gopter.Gen {
	if ipAddressOrRange_statusARMGenerator != nil {
		return ipAddressOrRange_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRange_StatusARM(generators)
	ipAddressOrRange_statusARMGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange_StatusARM{}), generators)

	return ipAddressOrRange_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRange_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRange_StatusARM(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocation_StatusARM, Location_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocation_StatusARM runs a test to see if a specific instance of Location_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLocation_StatusARM(subject Location_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location_StatusARM instances for property testing - lazily instantiated by Location_StatusARMGenerator()
var location_statusARMGenerator gopter.Gen

// Location_StatusARMGenerator returns a generator of Location_StatusARM instances for property testing.
func Location_StatusARMGenerator() gopter.Gen {
	if location_statusARMGenerator != nil {
		return location_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocation_StatusARM(generators)
	location_statusARMGenerator = gen.Struct(reflect.TypeOf(Location_StatusARM{}), generators)

	return location_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForLocation_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocation_StatusARM(gens map[string]gopter.Gen) {
	gens["DocumentEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_UserAssignedIdentities_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_UserAssignedIdentities_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_StatusARM, ManagedServiceIdentity_UserAssignedIdentities_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_StatusARM runs a test to see if a specific instance of ManagedServiceIdentity_UserAssignedIdentities_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_UserAssignedIdentities_StatusARM(subject ManagedServiceIdentity_UserAssignedIdentities_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_UserAssignedIdentities_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_UserAssignedIdentities_StatusARM instances for property testing - lazily
//instantiated by ManagedServiceIdentity_UserAssignedIdentities_StatusARMGenerator()
var managedServiceIdentity_userAssignedIdentities_statusARMGenerator gopter.Gen

// ManagedServiceIdentity_UserAssignedIdentities_StatusARMGenerator returns a generator of ManagedServiceIdentity_UserAssignedIdentities_StatusARM instances for property testing.
func ManagedServiceIdentity_UserAssignedIdentities_StatusARMGenerator() gopter.Gen {
	if managedServiceIdentity_userAssignedIdentities_statusARMGenerator != nil {
		return managedServiceIdentity_userAssignedIdentities_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_StatusARM(generators)
	managedServiceIdentity_userAssignedIdentities_statusARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_UserAssignedIdentities_StatusARM{}), generators)

	return managedServiceIdentity_userAssignedIdentities_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_UserAssignedIdentities_StatusARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_StatusARM, VirtualNetworkRule_StatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_StatusARM runs a test to see if a specific instance of VirtualNetworkRule_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_StatusARM(subject VirtualNetworkRule_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_StatusARM instances for property testing - lazily instantiated by
//VirtualNetworkRule_StatusARMGenerator()
var virtualNetworkRule_statusARMGenerator gopter.Gen

// VirtualNetworkRule_StatusARMGenerator returns a generator of VirtualNetworkRule_StatusARM instances for property testing.
func VirtualNetworkRule_StatusARMGenerator() gopter.Gen {
	if virtualNetworkRule_statusARMGenerator != nil {
		return virtualNetworkRule_statusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_StatusARM(generators)
	virtualNetworkRule_statusARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_StatusARM{}), generators)

	return virtualNetworkRule_statusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_StatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_StatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}
