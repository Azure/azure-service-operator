// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210515

import (
	"fmt"
	"github.com/Azure/azure-service-operator/v2/api/documentdb/v1alpha1api20210515storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
type SqlDatabaseContainer struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              DatabaseAccountsSqlDatabasesContainers_SPEC `json:"spec,omitempty"`
	Status            SqlContainerCreateUpdateParameters_Status   `json:"status,omitempty"`
}

var _ conditions.Conditioner = &SqlDatabaseContainer{}

// GetConditions returns the conditions of the resource
func (container *SqlDatabaseContainer) GetConditions() conditions.Conditions {
	return container.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (container *SqlDatabaseContainer) SetConditions(conditions conditions.Conditions) {
	container.Status.Conditions = conditions
}

var _ conversion.Convertible = &SqlDatabaseContainer{}

// ConvertFrom populates our SqlDatabaseContainer from the provided hub SqlDatabaseContainer
func (container *SqlDatabaseContainer) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v1alpha1api20210515storage.SqlDatabaseContainer)
	if !ok {
		return fmt.Errorf("expected storage:documentdb/v1alpha1api20210515storage/SqlDatabaseContainer but received %T instead", hub)
	}

	return container.AssignPropertiesFromSqlDatabaseContainer(source)
}

// ConvertTo populates the provided hub SqlDatabaseContainer from our SqlDatabaseContainer
func (container *SqlDatabaseContainer) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v1alpha1api20210515storage.SqlDatabaseContainer)
	if !ok {
		return fmt.Errorf("expected storage:documentdb/v1alpha1api20210515storage/SqlDatabaseContainer but received %T instead", hub)
	}

	return container.AssignPropertiesToSqlDatabaseContainer(destination)
}

// +kubebuilder:webhook:path=/mutate-documentdb-azure-com-v1alpha1api20210515-sqldatabasecontainer,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=documentdb.azure.com,resources=sqldatabasecontainers,verbs=create;update,versions=v1alpha1api20210515,name=default.v1alpha1api20210515.sqldatabasecontainers.documentdb.azure.com,admissionReviewVersions=v1beta1

var _ admission.Defaulter = &SqlDatabaseContainer{}

// Default applies defaults to the SqlDatabaseContainer resource
func (container *SqlDatabaseContainer) Default() {
	container.defaultImpl()
	var temp interface{} = container
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (container *SqlDatabaseContainer) defaultAzureName() {
	if container.Spec.AzureName == "" {
		container.Spec.AzureName = container.Name
	}
}

// defaultImpl applies the code generated defaults to the SqlDatabaseContainer resource
func (container *SqlDatabaseContainer) defaultImpl() { container.defaultAzureName() }

var _ genruntime.KubernetesResource = &SqlDatabaseContainer{}

// AzureName returns the Azure name of the resource
func (container *SqlDatabaseContainer) AzureName() string {
	return container.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-05-15"
func (container SqlDatabaseContainer) GetAPIVersion() string {
	return string(APIVersionValue)
}

// GetResourceKind returns the kind of the resource
func (container *SqlDatabaseContainer) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (container *SqlDatabaseContainer) GetSpec() genruntime.ConvertibleSpec {
	return &container.Spec
}

// GetStatus returns the status of this resource
func (container *SqlDatabaseContainer) GetStatus() genruntime.ConvertibleStatus {
	return &container.Status
}

// GetType returns the ARM Type of the resource. This is always ""
func (container *SqlDatabaseContainer) GetType() string {
	return ""
}

// NewEmptyStatus returns a new empty (blank) status
func (container *SqlDatabaseContainer) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &SqlContainerCreateUpdateParameters_Status{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (container *SqlDatabaseContainer) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(container.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  container.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (container *SqlDatabaseContainer) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*SqlContainerCreateUpdateParameters_Status); ok {
		container.Status = *st
		return nil
	}

	// Convert status to required version
	var st SqlContainerCreateUpdateParameters_Status
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	container.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-documentdb-azure-com-v1alpha1api20210515-sqldatabasecontainer,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=documentdb.azure.com,resources=sqldatabasecontainers,verbs=create;update,versions=v1alpha1api20210515,name=validate.v1alpha1api20210515.sqldatabasecontainers.documentdb.azure.com,admissionReviewVersions=v1beta1

var _ admission.Validator = &SqlDatabaseContainer{}

// ValidateCreate validates the creation of the resource
func (container *SqlDatabaseContainer) ValidateCreate() error {
	validations := container.createValidations()
	var temp interface{} = container
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (container *SqlDatabaseContainer) ValidateDelete() error {
	validations := container.deleteValidations()
	var temp interface{} = container
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (container *SqlDatabaseContainer) ValidateUpdate(old runtime.Object) error {
	validations := container.updateValidations()
	var temp interface{} = container
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (container *SqlDatabaseContainer) createValidations() []func() error {
	return []func() error{container.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (container *SqlDatabaseContainer) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (container *SqlDatabaseContainer) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return container.validateResourceReferences()
		},
	}
}

// validateResourceReferences validates all resource references
func (container *SqlDatabaseContainer) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&container.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// AssignPropertiesFromSqlDatabaseContainer populates our SqlDatabaseContainer from the provided source SqlDatabaseContainer
func (container *SqlDatabaseContainer) AssignPropertiesFromSqlDatabaseContainer(source *v1alpha1api20210515storage.SqlDatabaseContainer) error {

	// ObjectMeta
	container.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec DatabaseAccountsSqlDatabasesContainers_SPEC
	err := spec.AssignPropertiesFromDatabaseAccountsSqlDatabasesContainersSPEC(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromDatabaseAccountsSqlDatabasesContainersSPEC() to populate field Spec")
	}
	container.Spec = spec

	// Status
	var status SqlContainerCreateUpdateParameters_Status
	err = status.AssignPropertiesFromSqlContainerCreateUpdateParametersStatus(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromSqlContainerCreateUpdateParametersStatus() to populate field Status")
	}
	container.Status = status

	// No error
	return nil
}

// AssignPropertiesToSqlDatabaseContainer populates the provided destination SqlDatabaseContainer from our SqlDatabaseContainer
func (container *SqlDatabaseContainer) AssignPropertiesToSqlDatabaseContainer(destination *v1alpha1api20210515storage.SqlDatabaseContainer) error {

	// ObjectMeta
	destination.ObjectMeta = *container.ObjectMeta.DeepCopy()

	// Spec
	var spec v1alpha1api20210515storage.DatabaseAccountsSqlDatabasesContainers_SPEC
	err := container.Spec.AssignPropertiesToDatabaseAccountsSqlDatabasesContainersSPEC(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToDatabaseAccountsSqlDatabasesContainersSPEC() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v1alpha1api20210515storage.SqlContainerCreateUpdateParameters_Status
	err = container.Status.AssignPropertiesToSqlContainerCreateUpdateParametersStatus(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToSqlContainerCreateUpdateParametersStatus() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (container *SqlDatabaseContainer) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: container.Spec.OriginalVersion(),
		Kind:    "SqlDatabaseContainer",
	}
}

// +kubebuilder:object:root=true
type SqlDatabaseContainerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SqlDatabaseContainer `json:"items"`
}

type DatabaseAccountsSqlDatabasesContainers_SPEC struct {
	//AzureName: The name of the resource in Azure. This is often the same as the name
	//of the resource in Kubernetes but it doesn't have to be.
	AzureName string `json:"azureName"`

	//Location: The location of the resource group to which the resource belongs.
	Location *string `json:"location,omitempty"`

	//Options: A key-value pair of options to be applied for the request. This
	//corresponds to the headers sent with the request.
	Options *CreateUpdateOptions_Spec `json:"options,omitempty"`

	// +kubebuilder:validation:Required
	Owner genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner" kind:"ResourceGroup"`

	// +kubebuilder:validation:Required
	//Resource: The standard JSON format of a container
	Resource SqlContainerResource_Spec `json:"resource"`
	Tags     map[string]string         `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &DatabaseAccountsSqlDatabasesContainers_SPEC{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (spec *DatabaseAccountsSqlDatabasesContainers_SPEC) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if spec == nil {
		return nil, nil
	}
	var result DatabaseAccountsSqlDatabasesContainers_SPECARM

	// Set property ‘AzureName’:
	result.AzureName = spec.AzureName

	// Set property ‘Location’:
	if spec.Location != nil {
		location := *spec.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if spec.Options != nil {
		optionsARM, err := (*spec.Options).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		options := optionsARM.(CreateUpdateOptions_SpecARM)
		result.Properties.Options = &options
	}
	resourceARM, err := spec.Resource.ConvertToARM(resolved)
	if err != nil {
		return nil, err
	}
	result.Properties.Resource = resourceARM.(SqlContainerResource_SpecARM)

	// Set property ‘Tags’:
	if spec.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range spec.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (spec *DatabaseAccountsSqlDatabasesContainers_SPEC) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DatabaseAccountsSqlDatabasesContainers_SPECARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (spec *DatabaseAccountsSqlDatabasesContainers_SPEC) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DatabaseAccountsSqlDatabasesContainers_SPECARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DatabaseAccountsSqlDatabasesContainers_SPECARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	spec.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		spec.Location = &location
	}

	// Set property ‘Options’:
	// copying flattened property:
	if typedInput.Properties.Options != nil {
		var options1 CreateUpdateOptions_Spec
		err := options1.PopulateFromARM(owner, *typedInput.Properties.Options)
		if err != nil {
			return err
		}
		options := options1
		spec.Options = &options
	}

	// Set property ‘Owner’:
	spec.Owner = genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘Resource’:
	// copying flattened property:
	var resource SqlContainerResource_Spec
	err := resource.PopulateFromARM(owner, typedInput.Properties.Resource)
	if err != nil {
		return err
	}
	spec.Resource = resource

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		spec.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			spec.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &DatabaseAccountsSqlDatabasesContainers_SPEC{}

// ConvertSpecFrom populates our DatabaseAccountsSqlDatabasesContainers_SPEC from the provided source
func (spec *DatabaseAccountsSqlDatabasesContainers_SPEC) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1alpha1api20210515storage.DatabaseAccountsSqlDatabasesContainers_SPEC)
	if ok {
		// Populate our instance from source
		return spec.AssignPropertiesFromDatabaseAccountsSqlDatabasesContainersSPEC(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20210515storage.DatabaseAccountsSqlDatabasesContainers_SPEC{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = spec.AssignPropertiesFromDatabaseAccountsSqlDatabasesContainersSPEC(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our DatabaseAccountsSqlDatabasesContainers_SPEC
func (spec *DatabaseAccountsSqlDatabasesContainers_SPEC) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1alpha1api20210515storage.DatabaseAccountsSqlDatabasesContainers_SPEC)
	if ok {
		// Populate destination from our instance
		return spec.AssignPropertiesToDatabaseAccountsSqlDatabasesContainersSPEC(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20210515storage.DatabaseAccountsSqlDatabasesContainers_SPEC{}
	err := spec.AssignPropertiesToDatabaseAccountsSqlDatabasesContainersSPEC(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromDatabaseAccountsSqlDatabasesContainersSPEC populates our DatabaseAccountsSqlDatabasesContainers_SPEC from the provided source DatabaseAccountsSqlDatabasesContainers_SPEC
func (spec *DatabaseAccountsSqlDatabasesContainers_SPEC) AssignPropertiesFromDatabaseAccountsSqlDatabasesContainersSPEC(source *v1alpha1api20210515storage.DatabaseAccountsSqlDatabasesContainers_SPEC) error {

	// AzureName
	spec.AzureName = source.AzureName

	// Location
	spec.Location = genruntime.ClonePointerToString(source.Location)

	// Options
	if source.Options != nil {
		var option CreateUpdateOptions_Spec
		err := option.AssignPropertiesFromCreateUpdateOptionsSpec(source.Options)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromCreateUpdateOptionsSpec() to populate field Options")
		}
		spec.Options = &option
	} else {
		spec.Options = nil
	}

	// Owner
	spec.Owner = source.Owner.Copy()

	// Resource
	if source.Resource != nil {
		var resource SqlContainerResource_Spec
		err := resource.AssignPropertiesFromSqlContainerResourceSpec(source.Resource)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSqlContainerResourceSpec() to populate field Resource")
		}
		spec.Resource = resource
	} else {
		spec.Resource = SqlContainerResource_Spec{}
	}

	// Tags
	spec.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignPropertiesToDatabaseAccountsSqlDatabasesContainersSPEC populates the provided destination DatabaseAccountsSqlDatabasesContainers_SPEC from our DatabaseAccountsSqlDatabasesContainers_SPEC
func (spec *DatabaseAccountsSqlDatabasesContainers_SPEC) AssignPropertiesToDatabaseAccountsSqlDatabasesContainersSPEC(destination *v1alpha1api20210515storage.DatabaseAccountsSqlDatabasesContainers_SPEC) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = spec.AzureName

	// Location
	destination.Location = genruntime.ClonePointerToString(spec.Location)

	// Options
	if spec.Options != nil {
		var option v1alpha1api20210515storage.CreateUpdateOptions_Spec
		err := spec.Options.AssignPropertiesToCreateUpdateOptionsSpec(&option)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToCreateUpdateOptionsSpec() to populate field Options")
		}
		destination.Options = &option
	} else {
		destination.Options = nil
	}

	// OriginalVersion
	destination.OriginalVersion = spec.OriginalVersion()

	// Owner
	destination.Owner = spec.Owner.Copy()

	// Resource
	var resource v1alpha1api20210515storage.SqlContainerResource_Spec
	err := spec.Resource.AssignPropertiesToSqlContainerResourceSpec(&resource)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToSqlContainerResourceSpec() to populate field Resource")
	}
	destination.Resource = &resource

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(spec.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (spec *DatabaseAccountsSqlDatabasesContainers_SPEC) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (spec *DatabaseAccountsSqlDatabasesContainers_SPEC) SetAzureName(azureName string) {
	spec.AzureName = azureName
}

type SqlContainerCreateUpdateParameters_Status struct {
	//Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	//Id: The unique resource identifier of the ARM resource.
	Id *string `json:"id,omitempty"`

	//Location: The location of the resource group to which the resource belongs.
	Location *string `json:"location,omitempty"`

	//Name: The name of the ARM resource.
	Name *string `json:"name,omitempty"`

	//Options: A key-value pair of options to be applied for the request. This
	//corresponds to the headers sent with the request.
	Options *CreateUpdateOptions_Status `json:"options,omitempty"`

	//Resource: The standard JSON format of a container
	Resource *SqlContainerResource_Status `json:"resource,omitempty"`
	Tags     map[string]string            `json:"tags,omitempty"`

	//Type: The type of Azure resource.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &SqlContainerCreateUpdateParameters_Status{}

// ConvertStatusFrom populates our SqlContainerCreateUpdateParameters_Status from the provided source
func (parameters *SqlContainerCreateUpdateParameters_Status) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1alpha1api20210515storage.SqlContainerCreateUpdateParameters_Status)
	if ok {
		// Populate our instance from source
		return parameters.AssignPropertiesFromSqlContainerCreateUpdateParametersStatus(src)
	}

	// Convert to an intermediate form
	src = &v1alpha1api20210515storage.SqlContainerCreateUpdateParameters_Status{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = parameters.AssignPropertiesFromSqlContainerCreateUpdateParametersStatus(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our SqlContainerCreateUpdateParameters_Status
func (parameters *SqlContainerCreateUpdateParameters_Status) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1alpha1api20210515storage.SqlContainerCreateUpdateParameters_Status)
	if ok {
		// Populate destination from our instance
		return parameters.AssignPropertiesToSqlContainerCreateUpdateParametersStatus(dst)
	}

	// Convert to an intermediate form
	dst = &v1alpha1api20210515storage.SqlContainerCreateUpdateParameters_Status{}
	err := parameters.AssignPropertiesToSqlContainerCreateUpdateParametersStatus(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &SqlContainerCreateUpdateParameters_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *SqlContainerCreateUpdateParameters_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SqlContainerCreateUpdateParameters_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *SqlContainerCreateUpdateParameters_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SqlContainerCreateUpdateParameters_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SqlContainerCreateUpdateParameters_StatusARM, got %T", armInput)
	}

	// no assignment for property ‘Conditions’

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		parameters.Id = &id
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		parameters.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		parameters.Name = &name
	}

	// Set property ‘Options’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Options != nil {
			var options1 CreateUpdateOptions_Status
			err := options1.PopulateFromARM(owner, *typedInput.Properties.Options)
			if err != nil {
				return err
			}
			options := options1
			parameters.Options = &options
		}
	}

	// Set property ‘Resource’:
	// copying flattened property:
	if typedInput.Properties != nil {
		var temp SqlContainerResource_Status
		var temp1 SqlContainerResource_Status
		err := temp1.PopulateFromARM(owner, typedInput.Properties.Resource)
		if err != nil {
			return err
		}
		temp = temp1
		parameters.Resource = &temp
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		parameters.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			parameters.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		parameters.Type = &typeVar
	}

	// No error
	return nil
}

// AssignPropertiesFromSqlContainerCreateUpdateParametersStatus populates our SqlContainerCreateUpdateParameters_Status from the provided source SqlContainerCreateUpdateParameters_Status
func (parameters *SqlContainerCreateUpdateParameters_Status) AssignPropertiesFromSqlContainerCreateUpdateParametersStatus(source *v1alpha1api20210515storage.SqlContainerCreateUpdateParameters_Status) error {

	// Conditions
	parameters.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// Id
	parameters.Id = genruntime.ClonePointerToString(source.Id)

	// Location
	parameters.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	parameters.Name = genruntime.ClonePointerToString(source.Name)

	// Options
	if source.Options != nil {
		var option CreateUpdateOptions_Status
		err := option.AssignPropertiesFromCreateUpdateOptionsStatus(source.Options)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromCreateUpdateOptionsStatus() to populate field Options")
		}
		parameters.Options = &option
	} else {
		parameters.Options = nil
	}

	// Resource
	if source.Resource != nil {
		var resource SqlContainerResource_Status
		err := resource.AssignPropertiesFromSqlContainerResourceStatus(source.Resource)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSqlContainerResourceStatus() to populate field Resource")
		}
		parameters.Resource = &resource
	} else {
		parameters.Resource = nil
	}

	// Tags
	parameters.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	parameters.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignPropertiesToSqlContainerCreateUpdateParametersStatus populates the provided destination SqlContainerCreateUpdateParameters_Status from our SqlContainerCreateUpdateParameters_Status
func (parameters *SqlContainerCreateUpdateParameters_Status) AssignPropertiesToSqlContainerCreateUpdateParametersStatus(destination *v1alpha1api20210515storage.SqlContainerCreateUpdateParameters_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(parameters.Conditions)

	// Id
	destination.Id = genruntime.ClonePointerToString(parameters.Id)

	// Location
	destination.Location = genruntime.ClonePointerToString(parameters.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(parameters.Name)

	// Options
	if parameters.Options != nil {
		var option v1alpha1api20210515storage.CreateUpdateOptions_Status
		err := parameters.Options.AssignPropertiesToCreateUpdateOptionsStatus(&option)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToCreateUpdateOptionsStatus() to populate field Options")
		}
		destination.Options = &option
	} else {
		destination.Options = nil
	}

	// Resource
	if parameters.Resource != nil {
		var resource v1alpha1api20210515storage.SqlContainerResource_Status
		err := parameters.Resource.AssignPropertiesToSqlContainerResourceStatus(&resource)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSqlContainerResourceStatus() to populate field Resource")
		}
		destination.Resource = &resource
	} else {
		destination.Resource = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(parameters.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(parameters.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SqlContainerResource_Spec struct {
	//AnalyticalStorageTtl: Analytical TTL.
	AnalyticalStorageTtl *int `json:"analyticalStorageTtl,omitempty"`

	//ConflictResolutionPolicy: The conflict resolution policy for the container.
	ConflictResolutionPolicy *ConflictResolutionPolicy_Spec `json:"conflictResolutionPolicy,omitempty"`

	//DefaultTtl: Default time to live
	DefaultTtl *int `json:"defaultTtl,omitempty"`

	// +kubebuilder:validation:Required
	//Id: Name of the Cosmos DB SQL container
	Id string `json:"id"`

	//IndexingPolicy: The configuration of the indexing policy. By default, the
	//indexing is automatic for all document paths within the container
	IndexingPolicy *IndexingPolicy_Spec `json:"indexingPolicy,omitempty"`

	//PartitionKey: The configuration of the partition key to be used for partitioning
	//data into multiple partitions
	PartitionKey *ContainerPartitionKey_Spec `json:"partitionKey,omitempty"`

	//UniqueKeyPolicy: The unique key policy configuration for specifying uniqueness
	//constraints on documents in the collection in the Azure Cosmos DB service.
	UniqueKeyPolicy *UniqueKeyPolicy_Spec `json:"uniqueKeyPolicy,omitempty"`
}

var _ genruntime.ARMTransformer = &SqlContainerResource_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (resource *SqlContainerResource_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if resource == nil {
		return nil, nil
	}
	var result SqlContainerResource_SpecARM

	// Set property ‘AnalyticalStorageTtl’:
	if resource.AnalyticalStorageTtl != nil {
		analyticalStorageTtl := *resource.AnalyticalStorageTtl
		result.AnalyticalStorageTtl = &analyticalStorageTtl
	}

	// Set property ‘ConflictResolutionPolicy’:
	if resource.ConflictResolutionPolicy != nil {
		conflictResolutionPolicyARM, err := (*resource.ConflictResolutionPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		conflictResolutionPolicy := conflictResolutionPolicyARM.(ConflictResolutionPolicy_SpecARM)
		result.ConflictResolutionPolicy = &conflictResolutionPolicy
	}

	// Set property ‘DefaultTtl’:
	if resource.DefaultTtl != nil {
		defaultTtl := *resource.DefaultTtl
		result.DefaultTtl = &defaultTtl
	}

	// Set property ‘Id’:
	result.Id = resource.Id

	// Set property ‘IndexingPolicy’:
	if resource.IndexingPolicy != nil {
		indexingPolicyARM, err := (*resource.IndexingPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		indexingPolicy := indexingPolicyARM.(IndexingPolicy_SpecARM)
		result.IndexingPolicy = &indexingPolicy
	}

	// Set property ‘PartitionKey’:
	if resource.PartitionKey != nil {
		partitionKeyARM, err := (*resource.PartitionKey).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		partitionKey := partitionKeyARM.(ContainerPartitionKey_SpecARM)
		result.PartitionKey = &partitionKey
	}

	// Set property ‘UniqueKeyPolicy’:
	if resource.UniqueKeyPolicy != nil {
		uniqueKeyPolicyARM, err := (*resource.UniqueKeyPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		uniqueKeyPolicy := uniqueKeyPolicyARM.(UniqueKeyPolicy_SpecARM)
		result.UniqueKeyPolicy = &uniqueKeyPolicy
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SqlContainerResource_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SqlContainerResource_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SqlContainerResource_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SqlContainerResource_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SqlContainerResource_SpecARM, got %T", armInput)
	}

	// Set property ‘AnalyticalStorageTtl’:
	if typedInput.AnalyticalStorageTtl != nil {
		analyticalStorageTtl := *typedInput.AnalyticalStorageTtl
		resource.AnalyticalStorageTtl = &analyticalStorageTtl
	}

	// Set property ‘ConflictResolutionPolicy’:
	if typedInput.ConflictResolutionPolicy != nil {
		var conflictResolutionPolicy1 ConflictResolutionPolicy_Spec
		err := conflictResolutionPolicy1.PopulateFromARM(owner, *typedInput.ConflictResolutionPolicy)
		if err != nil {
			return err
		}
		conflictResolutionPolicy := conflictResolutionPolicy1
		resource.ConflictResolutionPolicy = &conflictResolutionPolicy
	}

	// Set property ‘DefaultTtl’:
	if typedInput.DefaultTtl != nil {
		defaultTtl := *typedInput.DefaultTtl
		resource.DefaultTtl = &defaultTtl
	}

	// Set property ‘Id’:
	resource.Id = typedInput.Id

	// Set property ‘IndexingPolicy’:
	if typedInput.IndexingPolicy != nil {
		var indexingPolicy1 IndexingPolicy_Spec
		err := indexingPolicy1.PopulateFromARM(owner, *typedInput.IndexingPolicy)
		if err != nil {
			return err
		}
		indexingPolicy := indexingPolicy1
		resource.IndexingPolicy = &indexingPolicy
	}

	// Set property ‘PartitionKey’:
	if typedInput.PartitionKey != nil {
		var partitionKey1 ContainerPartitionKey_Spec
		err := partitionKey1.PopulateFromARM(owner, *typedInput.PartitionKey)
		if err != nil {
			return err
		}
		partitionKey := partitionKey1
		resource.PartitionKey = &partitionKey
	}

	// Set property ‘UniqueKeyPolicy’:
	if typedInput.UniqueKeyPolicy != nil {
		var uniqueKeyPolicy1 UniqueKeyPolicy_Spec
		err := uniqueKeyPolicy1.PopulateFromARM(owner, *typedInput.UniqueKeyPolicy)
		if err != nil {
			return err
		}
		uniqueKeyPolicy := uniqueKeyPolicy1
		resource.UniqueKeyPolicy = &uniqueKeyPolicy
	}

	// No error
	return nil
}

// AssignPropertiesFromSqlContainerResourceSpec populates our SqlContainerResource_Spec from the provided source SqlContainerResource_Spec
func (resource *SqlContainerResource_Spec) AssignPropertiesFromSqlContainerResourceSpec(source *v1alpha1api20210515storage.SqlContainerResource_Spec) error {

	// AnalyticalStorageTtl
	resource.AnalyticalStorageTtl = genruntime.ClonePointerToInt(source.AnalyticalStorageTtl)

	// ConflictResolutionPolicy
	if source.ConflictResolutionPolicy != nil {
		var conflictResolutionPolicy ConflictResolutionPolicy_Spec
		err := conflictResolutionPolicy.AssignPropertiesFromConflictResolutionPolicySpec(source.ConflictResolutionPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromConflictResolutionPolicySpec() to populate field ConflictResolutionPolicy")
		}
		resource.ConflictResolutionPolicy = &conflictResolutionPolicy
	} else {
		resource.ConflictResolutionPolicy = nil
	}

	// DefaultTtl
	resource.DefaultTtl = genruntime.ClonePointerToInt(source.DefaultTtl)

	// Id
	resource.Id = genruntime.GetOptionalStringValue(source.Id)

	// IndexingPolicy
	if source.IndexingPolicy != nil {
		var indexingPolicy IndexingPolicy_Spec
		err := indexingPolicy.AssignPropertiesFromIndexingPolicySpec(source.IndexingPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromIndexingPolicySpec() to populate field IndexingPolicy")
		}
		resource.IndexingPolicy = &indexingPolicy
	} else {
		resource.IndexingPolicy = nil
	}

	// PartitionKey
	if source.PartitionKey != nil {
		var partitionKey ContainerPartitionKey_Spec
		err := partitionKey.AssignPropertiesFromContainerPartitionKeySpec(source.PartitionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerPartitionKeySpec() to populate field PartitionKey")
		}
		resource.PartitionKey = &partitionKey
	} else {
		resource.PartitionKey = nil
	}

	// UniqueKeyPolicy
	if source.UniqueKeyPolicy != nil {
		var uniqueKeyPolicy UniqueKeyPolicy_Spec
		err := uniqueKeyPolicy.AssignPropertiesFromUniqueKeyPolicySpec(source.UniqueKeyPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUniqueKeyPolicySpec() to populate field UniqueKeyPolicy")
		}
		resource.UniqueKeyPolicy = &uniqueKeyPolicy
	} else {
		resource.UniqueKeyPolicy = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSqlContainerResourceSpec populates the provided destination SqlContainerResource_Spec from our SqlContainerResource_Spec
func (resource *SqlContainerResource_Spec) AssignPropertiesToSqlContainerResourceSpec(destination *v1alpha1api20210515storage.SqlContainerResource_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AnalyticalStorageTtl
	destination.AnalyticalStorageTtl = genruntime.ClonePointerToInt(resource.AnalyticalStorageTtl)

	// ConflictResolutionPolicy
	if resource.ConflictResolutionPolicy != nil {
		var conflictResolutionPolicy v1alpha1api20210515storage.ConflictResolutionPolicy_Spec
		err := resource.ConflictResolutionPolicy.AssignPropertiesToConflictResolutionPolicySpec(&conflictResolutionPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToConflictResolutionPolicySpec() to populate field ConflictResolutionPolicy")
		}
		destination.ConflictResolutionPolicy = &conflictResolutionPolicy
	} else {
		destination.ConflictResolutionPolicy = nil
	}

	// DefaultTtl
	destination.DefaultTtl = genruntime.ClonePointerToInt(resource.DefaultTtl)

	// Id
	id := resource.Id
	destination.Id = &id

	// IndexingPolicy
	if resource.IndexingPolicy != nil {
		var indexingPolicy v1alpha1api20210515storage.IndexingPolicy_Spec
		err := resource.IndexingPolicy.AssignPropertiesToIndexingPolicySpec(&indexingPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToIndexingPolicySpec() to populate field IndexingPolicy")
		}
		destination.IndexingPolicy = &indexingPolicy
	} else {
		destination.IndexingPolicy = nil
	}

	// PartitionKey
	if resource.PartitionKey != nil {
		var partitionKey v1alpha1api20210515storage.ContainerPartitionKey_Spec
		err := resource.PartitionKey.AssignPropertiesToContainerPartitionKeySpec(&partitionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerPartitionKeySpec() to populate field PartitionKey")
		}
		destination.PartitionKey = &partitionKey
	} else {
		destination.PartitionKey = nil
	}

	// UniqueKeyPolicy
	if resource.UniqueKeyPolicy != nil {
		var uniqueKeyPolicy v1alpha1api20210515storage.UniqueKeyPolicy_Spec
		err := resource.UniqueKeyPolicy.AssignPropertiesToUniqueKeyPolicySpec(&uniqueKeyPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUniqueKeyPolicySpec() to populate field UniqueKeyPolicy")
		}
		destination.UniqueKeyPolicy = &uniqueKeyPolicy
	} else {
		destination.UniqueKeyPolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SqlContainerResource_Status struct {
	//AnalyticalStorageTtl: Analytical TTL.
	AnalyticalStorageTtl *int `json:"analyticalStorageTtl,omitempty"`

	//ConflictResolutionPolicy: The conflict resolution policy for the container.
	ConflictResolutionPolicy *ConflictResolutionPolicy_Status `json:"conflictResolutionPolicy,omitempty"`

	//DefaultTtl: Default time to live
	DefaultTtl *int `json:"defaultTtl,omitempty"`

	// +kubebuilder:validation:Required
	//Id: Name of the Cosmos DB SQL container
	Id string `json:"id"`

	//IndexingPolicy: The configuration of the indexing policy. By default, the
	//indexing is automatic for all document paths within the container
	IndexingPolicy *IndexingPolicy_Status `json:"indexingPolicy,omitempty"`

	//PartitionKey: The configuration of the partition key to be used for partitioning
	//data into multiple partitions
	PartitionKey *ContainerPartitionKey_Status `json:"partitionKey,omitempty"`

	//UniqueKeyPolicy: The unique key policy configuration for specifying uniqueness
	//constraints on documents in the collection in the Azure Cosmos DB service.
	UniqueKeyPolicy *UniqueKeyPolicy_Status `json:"uniqueKeyPolicy,omitempty"`
}

var _ genruntime.FromARMConverter = &SqlContainerResource_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SqlContainerResource_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SqlContainerResource_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SqlContainerResource_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SqlContainerResource_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SqlContainerResource_StatusARM, got %T", armInput)
	}

	// Set property ‘AnalyticalStorageTtl’:
	if typedInput.AnalyticalStorageTtl != nil {
		analyticalStorageTtl := *typedInput.AnalyticalStorageTtl
		resource.AnalyticalStorageTtl = &analyticalStorageTtl
	}

	// Set property ‘ConflictResolutionPolicy’:
	if typedInput.ConflictResolutionPolicy != nil {
		var conflictResolutionPolicy1 ConflictResolutionPolicy_Status
		err := conflictResolutionPolicy1.PopulateFromARM(owner, *typedInput.ConflictResolutionPolicy)
		if err != nil {
			return err
		}
		conflictResolutionPolicy := conflictResolutionPolicy1
		resource.ConflictResolutionPolicy = &conflictResolutionPolicy
	}

	// Set property ‘DefaultTtl’:
	if typedInput.DefaultTtl != nil {
		defaultTtl := *typedInput.DefaultTtl
		resource.DefaultTtl = &defaultTtl
	}

	// Set property ‘Id’:
	resource.Id = typedInput.Id

	// Set property ‘IndexingPolicy’:
	if typedInput.IndexingPolicy != nil {
		var indexingPolicy1 IndexingPolicy_Status
		err := indexingPolicy1.PopulateFromARM(owner, *typedInput.IndexingPolicy)
		if err != nil {
			return err
		}
		indexingPolicy := indexingPolicy1
		resource.IndexingPolicy = &indexingPolicy
	}

	// Set property ‘PartitionKey’:
	if typedInput.PartitionKey != nil {
		var partitionKey1 ContainerPartitionKey_Status
		err := partitionKey1.PopulateFromARM(owner, *typedInput.PartitionKey)
		if err != nil {
			return err
		}
		partitionKey := partitionKey1
		resource.PartitionKey = &partitionKey
	}

	// Set property ‘UniqueKeyPolicy’:
	if typedInput.UniqueKeyPolicy != nil {
		var uniqueKeyPolicy1 UniqueKeyPolicy_Status
		err := uniqueKeyPolicy1.PopulateFromARM(owner, *typedInput.UniqueKeyPolicy)
		if err != nil {
			return err
		}
		uniqueKeyPolicy := uniqueKeyPolicy1
		resource.UniqueKeyPolicy = &uniqueKeyPolicy
	}

	// No error
	return nil
}

// AssignPropertiesFromSqlContainerResourceStatus populates our SqlContainerResource_Status from the provided source SqlContainerResource_Status
func (resource *SqlContainerResource_Status) AssignPropertiesFromSqlContainerResourceStatus(source *v1alpha1api20210515storage.SqlContainerResource_Status) error {

	// AnalyticalStorageTtl
	resource.AnalyticalStorageTtl = genruntime.ClonePointerToInt(source.AnalyticalStorageTtl)

	// ConflictResolutionPolicy
	if source.ConflictResolutionPolicy != nil {
		var conflictResolutionPolicy ConflictResolutionPolicy_Status
		err := conflictResolutionPolicy.AssignPropertiesFromConflictResolutionPolicyStatus(source.ConflictResolutionPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromConflictResolutionPolicyStatus() to populate field ConflictResolutionPolicy")
		}
		resource.ConflictResolutionPolicy = &conflictResolutionPolicy
	} else {
		resource.ConflictResolutionPolicy = nil
	}

	// DefaultTtl
	resource.DefaultTtl = genruntime.ClonePointerToInt(source.DefaultTtl)

	// Id
	resource.Id = genruntime.GetOptionalStringValue(source.Id)

	// IndexingPolicy
	if source.IndexingPolicy != nil {
		var indexingPolicy IndexingPolicy_Status
		err := indexingPolicy.AssignPropertiesFromIndexingPolicyStatus(source.IndexingPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromIndexingPolicyStatus() to populate field IndexingPolicy")
		}
		resource.IndexingPolicy = &indexingPolicy
	} else {
		resource.IndexingPolicy = nil
	}

	// PartitionKey
	if source.PartitionKey != nil {
		var partitionKey ContainerPartitionKey_Status
		err := partitionKey.AssignPropertiesFromContainerPartitionKeyStatus(source.PartitionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerPartitionKeyStatus() to populate field PartitionKey")
		}
		resource.PartitionKey = &partitionKey
	} else {
		resource.PartitionKey = nil
	}

	// UniqueKeyPolicy
	if source.UniqueKeyPolicy != nil {
		var uniqueKeyPolicy UniqueKeyPolicy_Status
		err := uniqueKeyPolicy.AssignPropertiesFromUniqueKeyPolicyStatus(source.UniqueKeyPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUniqueKeyPolicyStatus() to populate field UniqueKeyPolicy")
		}
		resource.UniqueKeyPolicy = &uniqueKeyPolicy
	} else {
		resource.UniqueKeyPolicy = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSqlContainerResourceStatus populates the provided destination SqlContainerResource_Status from our SqlContainerResource_Status
func (resource *SqlContainerResource_Status) AssignPropertiesToSqlContainerResourceStatus(destination *v1alpha1api20210515storage.SqlContainerResource_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AnalyticalStorageTtl
	destination.AnalyticalStorageTtl = genruntime.ClonePointerToInt(resource.AnalyticalStorageTtl)

	// ConflictResolutionPolicy
	if resource.ConflictResolutionPolicy != nil {
		var conflictResolutionPolicy v1alpha1api20210515storage.ConflictResolutionPolicy_Status
		err := resource.ConflictResolutionPolicy.AssignPropertiesToConflictResolutionPolicyStatus(&conflictResolutionPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToConflictResolutionPolicyStatus() to populate field ConflictResolutionPolicy")
		}
		destination.ConflictResolutionPolicy = &conflictResolutionPolicy
	} else {
		destination.ConflictResolutionPolicy = nil
	}

	// DefaultTtl
	destination.DefaultTtl = genruntime.ClonePointerToInt(resource.DefaultTtl)

	// Id
	id := resource.Id
	destination.Id = &id

	// IndexingPolicy
	if resource.IndexingPolicy != nil {
		var indexingPolicy v1alpha1api20210515storage.IndexingPolicy_Status
		err := resource.IndexingPolicy.AssignPropertiesToIndexingPolicyStatus(&indexingPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToIndexingPolicyStatus() to populate field IndexingPolicy")
		}
		destination.IndexingPolicy = &indexingPolicy
	} else {
		destination.IndexingPolicy = nil
	}

	// PartitionKey
	if resource.PartitionKey != nil {
		var partitionKey v1alpha1api20210515storage.ContainerPartitionKey_Status
		err := resource.PartitionKey.AssignPropertiesToContainerPartitionKeyStatus(&partitionKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerPartitionKeyStatus() to populate field PartitionKey")
		}
		destination.PartitionKey = &partitionKey
	} else {
		destination.PartitionKey = nil
	}

	// UniqueKeyPolicy
	if resource.UniqueKeyPolicy != nil {
		var uniqueKeyPolicy v1alpha1api20210515storage.UniqueKeyPolicy_Status
		err := resource.UniqueKeyPolicy.AssignPropertiesToUniqueKeyPolicyStatus(&uniqueKeyPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUniqueKeyPolicyStatus() to populate field UniqueKeyPolicy")
		}
		destination.UniqueKeyPolicy = &uniqueKeyPolicy
	} else {
		destination.UniqueKeyPolicy = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ConflictResolutionPolicy_Spec struct {
	//ConflictResolutionPath: The conflict resolution path in the case of
	//LastWriterWins mode.
	ConflictResolutionPath *string `json:"conflictResolutionPath,omitempty"`

	//ConflictResolutionProcedure: The procedure to resolve conflicts in the case of
	//custom mode.
	ConflictResolutionProcedure *string `json:"conflictResolutionProcedure,omitempty"`

	//Mode: Indicates the conflict resolution mode.
	Mode *ConflictResolutionPolicySpecMode `json:"mode,omitempty"`
}

var _ genruntime.ARMTransformer = &ConflictResolutionPolicy_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *ConflictResolutionPolicy_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	var result ConflictResolutionPolicy_SpecARM

	// Set property ‘ConflictResolutionPath’:
	if policy.ConflictResolutionPath != nil {
		conflictResolutionPath := *policy.ConflictResolutionPath
		result.ConflictResolutionPath = &conflictResolutionPath
	}

	// Set property ‘ConflictResolutionProcedure’:
	if policy.ConflictResolutionProcedure != nil {
		conflictResolutionProcedure := *policy.ConflictResolutionProcedure
		result.ConflictResolutionProcedure = &conflictResolutionProcedure
	}

	// Set property ‘Mode’:
	if policy.Mode != nil {
		mode := *policy.Mode
		result.Mode = &mode
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *ConflictResolutionPolicy_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ConflictResolutionPolicy_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *ConflictResolutionPolicy_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ConflictResolutionPolicy_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ConflictResolutionPolicy_SpecARM, got %T", armInput)
	}

	// Set property ‘ConflictResolutionPath’:
	if typedInput.ConflictResolutionPath != nil {
		conflictResolutionPath := *typedInput.ConflictResolutionPath
		policy.ConflictResolutionPath = &conflictResolutionPath
	}

	// Set property ‘ConflictResolutionProcedure’:
	if typedInput.ConflictResolutionProcedure != nil {
		conflictResolutionProcedure := *typedInput.ConflictResolutionProcedure
		policy.ConflictResolutionProcedure = &conflictResolutionProcedure
	}

	// Set property ‘Mode’:
	if typedInput.Mode != nil {
		mode := *typedInput.Mode
		policy.Mode = &mode
	}

	// No error
	return nil
}

// AssignPropertiesFromConflictResolutionPolicySpec populates our ConflictResolutionPolicy_Spec from the provided source ConflictResolutionPolicy_Spec
func (policy *ConflictResolutionPolicy_Spec) AssignPropertiesFromConflictResolutionPolicySpec(source *v1alpha1api20210515storage.ConflictResolutionPolicy_Spec) error {

	// ConflictResolutionPath
	policy.ConflictResolutionPath = genruntime.ClonePointerToString(source.ConflictResolutionPath)

	// ConflictResolutionProcedure
	policy.ConflictResolutionProcedure = genruntime.ClonePointerToString(source.ConflictResolutionProcedure)

	// Mode
	if source.Mode != nil {
		mode := ConflictResolutionPolicySpecMode(*source.Mode)
		policy.Mode = &mode
	} else {
		policy.Mode = nil
	}

	// No error
	return nil
}

// AssignPropertiesToConflictResolutionPolicySpec populates the provided destination ConflictResolutionPolicy_Spec from our ConflictResolutionPolicy_Spec
func (policy *ConflictResolutionPolicy_Spec) AssignPropertiesToConflictResolutionPolicySpec(destination *v1alpha1api20210515storage.ConflictResolutionPolicy_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConflictResolutionPath
	destination.ConflictResolutionPath = genruntime.ClonePointerToString(policy.ConflictResolutionPath)

	// ConflictResolutionProcedure
	destination.ConflictResolutionProcedure = genruntime.ClonePointerToString(policy.ConflictResolutionProcedure)

	// Mode
	if policy.Mode != nil {
		mode := string(*policy.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ConflictResolutionPolicy_Status struct {
	//ConflictResolutionPath: The conflict resolution path in the case of
	//LastWriterWins mode.
	ConflictResolutionPath *string `json:"conflictResolutionPath,omitempty"`

	//ConflictResolutionProcedure: The procedure to resolve conflicts in the case of
	//custom mode.
	ConflictResolutionProcedure *string `json:"conflictResolutionProcedure,omitempty"`

	//Mode: Indicates the conflict resolution mode.
	Mode *ConflictResolutionPolicyStatusMode `json:"mode,omitempty"`
}

var _ genruntime.FromARMConverter = &ConflictResolutionPolicy_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *ConflictResolutionPolicy_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ConflictResolutionPolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *ConflictResolutionPolicy_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ConflictResolutionPolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ConflictResolutionPolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘ConflictResolutionPath’:
	if typedInput.ConflictResolutionPath != nil {
		conflictResolutionPath := *typedInput.ConflictResolutionPath
		policy.ConflictResolutionPath = &conflictResolutionPath
	}

	// Set property ‘ConflictResolutionProcedure’:
	if typedInput.ConflictResolutionProcedure != nil {
		conflictResolutionProcedure := *typedInput.ConflictResolutionProcedure
		policy.ConflictResolutionProcedure = &conflictResolutionProcedure
	}

	// Set property ‘Mode’:
	if typedInput.Mode != nil {
		mode := *typedInput.Mode
		policy.Mode = &mode
	}

	// No error
	return nil
}

// AssignPropertiesFromConflictResolutionPolicyStatus populates our ConflictResolutionPolicy_Status from the provided source ConflictResolutionPolicy_Status
func (policy *ConflictResolutionPolicy_Status) AssignPropertiesFromConflictResolutionPolicyStatus(source *v1alpha1api20210515storage.ConflictResolutionPolicy_Status) error {

	// ConflictResolutionPath
	policy.ConflictResolutionPath = genruntime.ClonePointerToString(source.ConflictResolutionPath)

	// ConflictResolutionProcedure
	policy.ConflictResolutionProcedure = genruntime.ClonePointerToString(source.ConflictResolutionProcedure)

	// Mode
	if source.Mode != nil {
		mode := ConflictResolutionPolicyStatusMode(*source.Mode)
		policy.Mode = &mode
	} else {
		policy.Mode = nil
	}

	// No error
	return nil
}

// AssignPropertiesToConflictResolutionPolicyStatus populates the provided destination ConflictResolutionPolicy_Status from our ConflictResolutionPolicy_Status
func (policy *ConflictResolutionPolicy_Status) AssignPropertiesToConflictResolutionPolicyStatus(destination *v1alpha1api20210515storage.ConflictResolutionPolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ConflictResolutionPath
	destination.ConflictResolutionPath = genruntime.ClonePointerToString(policy.ConflictResolutionPath)

	// ConflictResolutionProcedure
	destination.ConflictResolutionProcedure = genruntime.ClonePointerToString(policy.ConflictResolutionProcedure)

	// Mode
	if policy.Mode != nil {
		mode := string(*policy.Mode)
		destination.Mode = &mode
	} else {
		destination.Mode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerPartitionKey_Spec struct {
	//Kind: Indicates the kind of algorithm used for partitioning. For MultiHash,
	//multiple partition keys (upto three maximum) are supported for container create
	Kind *ContainerPartitionKeySpecKind `json:"kind,omitempty"`

	//Paths: List of paths using which data within the container can be partitioned
	Paths []string `json:"paths,omitempty"`

	// +kubebuilder:validation:Maximum=2
	// +kubebuilder:validation:Minimum=1
	//Version: Indicates the version of the partition key definition
	Version *int `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &ContainerPartitionKey_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (partitionKey *ContainerPartitionKey_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if partitionKey == nil {
		return nil, nil
	}
	var result ContainerPartitionKey_SpecARM

	// Set property ‘Kind’:
	if partitionKey.Kind != nil {
		kind := *partitionKey.Kind
		result.Kind = &kind
	}

	// Set property ‘Paths’:
	for _, item := range partitionKey.Paths {
		result.Paths = append(result.Paths, item)
	}

	// Set property ‘Version’:
	if partitionKey.Version != nil {
		version := *partitionKey.Version
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (partitionKey *ContainerPartitionKey_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerPartitionKey_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (partitionKey *ContainerPartitionKey_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerPartitionKey_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerPartitionKey_SpecARM, got %T", armInput)
	}

	// Set property ‘Kind’:
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		partitionKey.Kind = &kind
	}

	// Set property ‘Paths’:
	for _, item := range typedInput.Paths {
		partitionKey.Paths = append(partitionKey.Paths, item)
	}

	// Set property ‘Version’:
	if typedInput.Version != nil {
		version := *typedInput.Version
		partitionKey.Version = &version
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerPartitionKeySpec populates our ContainerPartitionKey_Spec from the provided source ContainerPartitionKey_Spec
func (partitionKey *ContainerPartitionKey_Spec) AssignPropertiesFromContainerPartitionKeySpec(source *v1alpha1api20210515storage.ContainerPartitionKey_Spec) error {

	// Kind
	if source.Kind != nil {
		kind := ContainerPartitionKeySpecKind(*source.Kind)
		partitionKey.Kind = &kind
	} else {
		partitionKey.Kind = nil
	}

	// Paths
	partitionKey.Paths = genruntime.CloneSliceOfString(source.Paths)

	// Version
	if source.Version != nil {
		version := *source.Version
		partitionKey.Version = &version
	} else {
		partitionKey.Version = nil
	}

	// No error
	return nil
}

// AssignPropertiesToContainerPartitionKeySpec populates the provided destination ContainerPartitionKey_Spec from our ContainerPartitionKey_Spec
func (partitionKey *ContainerPartitionKey_Spec) AssignPropertiesToContainerPartitionKeySpec(destination *v1alpha1api20210515storage.ContainerPartitionKey_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Kind
	if partitionKey.Kind != nil {
		kind := string(*partitionKey.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Paths
	destination.Paths = genruntime.CloneSliceOfString(partitionKey.Paths)

	// Version
	if partitionKey.Version != nil {
		version := *partitionKey.Version
		destination.Version = &version
	} else {
		destination.Version = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ContainerPartitionKey_Status struct {
	//Kind: Indicates the kind of algorithm used for partitioning. For MultiHash,
	//multiple partition keys (upto three maximum) are supported for container create
	Kind *ContainerPartitionKeyStatusKind `json:"kind,omitempty"`

	//Paths: List of paths using which data within the container can be partitioned
	Paths []string `json:"paths,omitempty"`

	//SystemKey: Indicates if the container is using a system generated partition key
	SystemKey *bool `json:"systemKey,omitempty"`

	//Version: Indicates the version of the partition key definition
	Version *int `json:"version,omitempty"`
}

var _ genruntime.FromARMConverter = &ContainerPartitionKey_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (partitionKey *ContainerPartitionKey_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ContainerPartitionKey_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (partitionKey *ContainerPartitionKey_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ContainerPartitionKey_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ContainerPartitionKey_StatusARM, got %T", armInput)
	}

	// Set property ‘Kind’:
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		partitionKey.Kind = &kind
	}

	// Set property ‘Paths’:
	for _, item := range typedInput.Paths {
		partitionKey.Paths = append(partitionKey.Paths, item)
	}

	// Set property ‘SystemKey’:
	if typedInput.SystemKey != nil {
		systemKey := *typedInput.SystemKey
		partitionKey.SystemKey = &systemKey
	}

	// Set property ‘Version’:
	if typedInput.Version != nil {
		version := *typedInput.Version
		partitionKey.Version = &version
	}

	// No error
	return nil
}

// AssignPropertiesFromContainerPartitionKeyStatus populates our ContainerPartitionKey_Status from the provided source ContainerPartitionKey_Status
func (partitionKey *ContainerPartitionKey_Status) AssignPropertiesFromContainerPartitionKeyStatus(source *v1alpha1api20210515storage.ContainerPartitionKey_Status) error {

	// Kind
	if source.Kind != nil {
		kind := ContainerPartitionKeyStatusKind(*source.Kind)
		partitionKey.Kind = &kind
	} else {
		partitionKey.Kind = nil
	}

	// Paths
	partitionKey.Paths = genruntime.CloneSliceOfString(source.Paths)

	// SystemKey
	if source.SystemKey != nil {
		systemKey := *source.SystemKey
		partitionKey.SystemKey = &systemKey
	} else {
		partitionKey.SystemKey = nil
	}

	// Version
	partitionKey.Version = genruntime.ClonePointerToInt(source.Version)

	// No error
	return nil
}

// AssignPropertiesToContainerPartitionKeyStatus populates the provided destination ContainerPartitionKey_Status from our ContainerPartitionKey_Status
func (partitionKey *ContainerPartitionKey_Status) AssignPropertiesToContainerPartitionKeyStatus(destination *v1alpha1api20210515storage.ContainerPartitionKey_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Kind
	if partitionKey.Kind != nil {
		kind := string(*partitionKey.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Paths
	destination.Paths = genruntime.CloneSliceOfString(partitionKey.Paths)

	// SystemKey
	if partitionKey.SystemKey != nil {
		systemKey := *partitionKey.SystemKey
		destination.SystemKey = &systemKey
	} else {
		destination.SystemKey = nil
	}

	// Version
	destination.Version = genruntime.ClonePointerToInt(partitionKey.Version)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type IndexingPolicy_Spec struct {
	//Automatic: Indicates if the indexing policy is automatic
	Automatic *bool `json:"automatic,omitempty"`

	//CompositeIndexes: List of composite path list
	CompositeIndexes [][]CompositePath_Spec `json:"compositeIndexes,omitempty"`

	//ExcludedPaths: List of paths to exclude from indexing
	ExcludedPaths []ExcludedPath_Spec `json:"excludedPaths,omitempty"`

	//IncludedPaths: List of paths to include in the indexing
	IncludedPaths []IncludedPath_Spec `json:"includedPaths,omitempty"`

	//IndexingMode: Indicates the indexing mode.
	IndexingMode *IndexingPolicySpecIndexingMode `json:"indexingMode,omitempty"`

	//SpatialIndexes: List of spatial specifics
	SpatialIndexes []SpatialSpec_Spec `json:"spatialIndexes,omitempty"`
}

var _ genruntime.ARMTransformer = &IndexingPolicy_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *IndexingPolicy_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	var result IndexingPolicy_SpecARM

	// Set property ‘Automatic’:
	if policy.Automatic != nil {
		automatic := *policy.Automatic
		result.Automatic = &automatic
	}

	// Set property ‘CompositeIndexes’:
	for _, item := range policy.CompositeIndexes {
		var itemTemp []CompositePath_SpecARM
		for _, item1 := range item {
			item1ARM, err := item1.ConvertToARM(resolved)
			if err != nil {
				return nil, err
			}
			itemTemp = append(itemTemp, item1ARM.(CompositePath_SpecARM))
		}
		result.CompositeIndexes = append(result.CompositeIndexes, itemTemp)
	}

	// Set property ‘ExcludedPaths’:
	for _, item := range policy.ExcludedPaths {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ExcludedPaths = append(result.ExcludedPaths, itemARM.(ExcludedPath_SpecARM))
	}

	// Set property ‘IncludedPaths’:
	for _, item := range policy.IncludedPaths {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.IncludedPaths = append(result.IncludedPaths, itemARM.(IncludedPath_SpecARM))
	}

	// Set property ‘IndexingMode’:
	if policy.IndexingMode != nil {
		indexingMode := *policy.IndexingMode
		result.IndexingMode = &indexingMode
	}

	// Set property ‘SpatialIndexes’:
	for _, item := range policy.SpatialIndexes {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.SpatialIndexes = append(result.SpatialIndexes, itemARM.(SpatialSpec_SpecARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *IndexingPolicy_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IndexingPolicy_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *IndexingPolicy_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IndexingPolicy_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IndexingPolicy_SpecARM, got %T", armInput)
	}

	// Set property ‘Automatic’:
	if typedInput.Automatic != nil {
		automatic := *typedInput.Automatic
		policy.Automatic = &automatic
	}

	// Set property ‘CompositeIndexes’:
	for _, item := range typedInput.CompositeIndexes {
		var itemTemp []CompositePath_Spec
		for _, item1 := range item {
			var item2 CompositePath_Spec
			err := item2.PopulateFromARM(owner, item1)
			if err != nil {
				return err
			}
			itemTemp = append(itemTemp, item2)
		}
		policy.CompositeIndexes = append(policy.CompositeIndexes, itemTemp)
	}

	// Set property ‘ExcludedPaths’:
	for _, item := range typedInput.ExcludedPaths {
		var item1 ExcludedPath_Spec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.ExcludedPaths = append(policy.ExcludedPaths, item1)
	}

	// Set property ‘IncludedPaths’:
	for _, item := range typedInput.IncludedPaths {
		var item1 IncludedPath_Spec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.IncludedPaths = append(policy.IncludedPaths, item1)
	}

	// Set property ‘IndexingMode’:
	if typedInput.IndexingMode != nil {
		indexingMode := *typedInput.IndexingMode
		policy.IndexingMode = &indexingMode
	}

	// Set property ‘SpatialIndexes’:
	for _, item := range typedInput.SpatialIndexes {
		var item1 SpatialSpec_Spec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.SpatialIndexes = append(policy.SpatialIndexes, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromIndexingPolicySpec populates our IndexingPolicy_Spec from the provided source IndexingPolicy_Spec
func (policy *IndexingPolicy_Spec) AssignPropertiesFromIndexingPolicySpec(source *v1alpha1api20210515storage.IndexingPolicy_Spec) error {

	// Automatic
	if source.Automatic != nil {
		automatic := *source.Automatic
		policy.Automatic = &automatic
	} else {
		policy.Automatic = nil
	}

	// CompositeIndexes
	if source.CompositeIndexes != nil {
		compositeIndexList := make([][]CompositePath_Spec, len(source.CompositeIndexes))
		for compositeIndex, compositeIndexItem := range source.CompositeIndexes {
			// Shadow the loop variable to avoid aliasing
			compositeIndexItem := compositeIndexItem
			if compositeIndexItem != nil {
				compositeIndexList1 := make([]CompositePath_Spec, len(compositeIndexItem))
				for compositeIndex1, compositeIndexItem1 := range compositeIndexItem {
					// Shadow the loop variable to avoid aliasing
					compositeIndexItem1 := compositeIndexItem1
					var compositeIndexLocal CompositePath_Spec
					err := compositeIndexLocal.AssignPropertiesFromCompositePathSpec(&compositeIndexItem1)
					if err != nil {
						return errors.Wrap(err, "calling AssignPropertiesFromCompositePathSpec() to populate field CompositeIndexes")
					}
					compositeIndexList1[compositeIndex1] = compositeIndexLocal
				}
				compositeIndexList[compositeIndex] = compositeIndexList1
			} else {
				compositeIndexList[compositeIndex] = nil
			}
		}
		policy.CompositeIndexes = compositeIndexList
	} else {
		policy.CompositeIndexes = nil
	}

	// ExcludedPaths
	if source.ExcludedPaths != nil {
		excludedPathList := make([]ExcludedPath_Spec, len(source.ExcludedPaths))
		for excludedPathIndex, excludedPathItem := range source.ExcludedPaths {
			// Shadow the loop variable to avoid aliasing
			excludedPathItem := excludedPathItem
			var excludedPath ExcludedPath_Spec
			err := excludedPath.AssignPropertiesFromExcludedPathSpec(&excludedPathItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromExcludedPathSpec() to populate field ExcludedPaths")
			}
			excludedPathList[excludedPathIndex] = excludedPath
		}
		policy.ExcludedPaths = excludedPathList
	} else {
		policy.ExcludedPaths = nil
	}

	// IncludedPaths
	if source.IncludedPaths != nil {
		includedPathList := make([]IncludedPath_Spec, len(source.IncludedPaths))
		for includedPathIndex, includedPathItem := range source.IncludedPaths {
			// Shadow the loop variable to avoid aliasing
			includedPathItem := includedPathItem
			var includedPath IncludedPath_Spec
			err := includedPath.AssignPropertiesFromIncludedPathSpec(&includedPathItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromIncludedPathSpec() to populate field IncludedPaths")
			}
			includedPathList[includedPathIndex] = includedPath
		}
		policy.IncludedPaths = includedPathList
	} else {
		policy.IncludedPaths = nil
	}

	// IndexingMode
	if source.IndexingMode != nil {
		indexingMode := IndexingPolicySpecIndexingMode(*source.IndexingMode)
		policy.IndexingMode = &indexingMode
	} else {
		policy.IndexingMode = nil
	}

	// SpatialIndexes
	if source.SpatialIndexes != nil {
		spatialIndexList := make([]SpatialSpec_Spec, len(source.SpatialIndexes))
		for spatialIndex, spatialIndexItem := range source.SpatialIndexes {
			// Shadow the loop variable to avoid aliasing
			spatialIndexItem := spatialIndexItem
			var spatialIndexLocal SpatialSpec_Spec
			err := spatialIndexLocal.AssignPropertiesFromSpatialSpecSpec(&spatialIndexItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSpatialSpecSpec() to populate field SpatialIndexes")
			}
			spatialIndexList[spatialIndex] = spatialIndexLocal
		}
		policy.SpatialIndexes = spatialIndexList
	} else {
		policy.SpatialIndexes = nil
	}

	// No error
	return nil
}

// AssignPropertiesToIndexingPolicySpec populates the provided destination IndexingPolicy_Spec from our IndexingPolicy_Spec
func (policy *IndexingPolicy_Spec) AssignPropertiesToIndexingPolicySpec(destination *v1alpha1api20210515storage.IndexingPolicy_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Automatic
	if policy.Automatic != nil {
		automatic := *policy.Automatic
		destination.Automatic = &automatic
	} else {
		destination.Automatic = nil
	}

	// CompositeIndexes
	if policy.CompositeIndexes != nil {
		compositeIndexList := make([][]v1alpha1api20210515storage.CompositePath_Spec, len(policy.CompositeIndexes))
		for compositeIndex, compositeIndexItem := range policy.CompositeIndexes {
			// Shadow the loop variable to avoid aliasing
			compositeIndexItem := compositeIndexItem
			if compositeIndexItem != nil {
				compositeIndexList1 := make([]v1alpha1api20210515storage.CompositePath_Spec, len(compositeIndexItem))
				for compositeIndex1, compositeIndexItem1 := range compositeIndexItem {
					// Shadow the loop variable to avoid aliasing
					compositeIndexItem1 := compositeIndexItem1
					var compositeIndexLocal v1alpha1api20210515storage.CompositePath_Spec
					err := compositeIndexItem1.AssignPropertiesToCompositePathSpec(&compositeIndexLocal)
					if err != nil {
						return errors.Wrap(err, "calling AssignPropertiesToCompositePathSpec() to populate field CompositeIndexes")
					}
					compositeIndexList1[compositeIndex1] = compositeIndexLocal
				}
				compositeIndexList[compositeIndex] = compositeIndexList1
			} else {
				compositeIndexList[compositeIndex] = nil
			}
		}
		destination.CompositeIndexes = compositeIndexList
	} else {
		destination.CompositeIndexes = nil
	}

	// ExcludedPaths
	if policy.ExcludedPaths != nil {
		excludedPathList := make([]v1alpha1api20210515storage.ExcludedPath_Spec, len(policy.ExcludedPaths))
		for excludedPathIndex, excludedPathItem := range policy.ExcludedPaths {
			// Shadow the loop variable to avoid aliasing
			excludedPathItem := excludedPathItem
			var excludedPath v1alpha1api20210515storage.ExcludedPath_Spec
			err := excludedPathItem.AssignPropertiesToExcludedPathSpec(&excludedPath)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToExcludedPathSpec() to populate field ExcludedPaths")
			}
			excludedPathList[excludedPathIndex] = excludedPath
		}
		destination.ExcludedPaths = excludedPathList
	} else {
		destination.ExcludedPaths = nil
	}

	// IncludedPaths
	if policy.IncludedPaths != nil {
		includedPathList := make([]v1alpha1api20210515storage.IncludedPath_Spec, len(policy.IncludedPaths))
		for includedPathIndex, includedPathItem := range policy.IncludedPaths {
			// Shadow the loop variable to avoid aliasing
			includedPathItem := includedPathItem
			var includedPath v1alpha1api20210515storage.IncludedPath_Spec
			err := includedPathItem.AssignPropertiesToIncludedPathSpec(&includedPath)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToIncludedPathSpec() to populate field IncludedPaths")
			}
			includedPathList[includedPathIndex] = includedPath
		}
		destination.IncludedPaths = includedPathList
	} else {
		destination.IncludedPaths = nil
	}

	// IndexingMode
	if policy.IndexingMode != nil {
		indexingMode := string(*policy.IndexingMode)
		destination.IndexingMode = &indexingMode
	} else {
		destination.IndexingMode = nil
	}

	// SpatialIndexes
	if policy.SpatialIndexes != nil {
		spatialIndexList := make([]v1alpha1api20210515storage.SpatialSpec_Spec, len(policy.SpatialIndexes))
		for spatialIndex, spatialIndexItem := range policy.SpatialIndexes {
			// Shadow the loop variable to avoid aliasing
			spatialIndexItem := spatialIndexItem
			var spatialIndexLocal v1alpha1api20210515storage.SpatialSpec_Spec
			err := spatialIndexItem.AssignPropertiesToSpatialSpecSpec(&spatialIndexLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSpatialSpecSpec() to populate field SpatialIndexes")
			}
			spatialIndexList[spatialIndex] = spatialIndexLocal
		}
		destination.SpatialIndexes = spatialIndexList
	} else {
		destination.SpatialIndexes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type IndexingPolicy_Status struct {
	//Automatic: Indicates if the indexing policy is automatic
	Automatic *bool `json:"automatic,omitempty"`

	//CompositeIndexes: List of composite path list
	CompositeIndexes [][]CompositePath_Status `json:"compositeIndexes,omitempty"`

	//ExcludedPaths: List of paths to exclude from indexing
	ExcludedPaths []ExcludedPath_Status `json:"excludedPaths,omitempty"`

	//IncludedPaths: List of paths to include in the indexing
	IncludedPaths []IncludedPath_Status `json:"includedPaths,omitempty"`

	//IndexingMode: Indicates the indexing mode.
	IndexingMode *IndexingPolicyStatusIndexingMode `json:"indexingMode,omitempty"`

	//SpatialIndexes: List of spatial specifics
	SpatialIndexes []SpatialSpec_Status `json:"spatialIndexes,omitempty"`
}

var _ genruntime.FromARMConverter = &IndexingPolicy_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *IndexingPolicy_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IndexingPolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *IndexingPolicy_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IndexingPolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IndexingPolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘Automatic’:
	if typedInput.Automatic != nil {
		automatic := *typedInput.Automatic
		policy.Automatic = &automatic
	}

	// Set property ‘CompositeIndexes’:
	for _, item := range typedInput.CompositeIndexes {
		var itemTemp []CompositePath_Status
		for _, item1 := range item {
			var item2 CompositePath_Status
			err := item2.PopulateFromARM(owner, item1)
			if err != nil {
				return err
			}
			itemTemp = append(itemTemp, item2)
		}
		policy.CompositeIndexes = append(policy.CompositeIndexes, itemTemp)
	}

	// Set property ‘ExcludedPaths’:
	for _, item := range typedInput.ExcludedPaths {
		var item1 ExcludedPath_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.ExcludedPaths = append(policy.ExcludedPaths, item1)
	}

	// Set property ‘IncludedPaths’:
	for _, item := range typedInput.IncludedPaths {
		var item1 IncludedPath_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.IncludedPaths = append(policy.IncludedPaths, item1)
	}

	// Set property ‘IndexingMode’:
	if typedInput.IndexingMode != nil {
		indexingMode := *typedInput.IndexingMode
		policy.IndexingMode = &indexingMode
	}

	// Set property ‘SpatialIndexes’:
	for _, item := range typedInput.SpatialIndexes {
		var item1 SpatialSpec_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.SpatialIndexes = append(policy.SpatialIndexes, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromIndexingPolicyStatus populates our IndexingPolicy_Status from the provided source IndexingPolicy_Status
func (policy *IndexingPolicy_Status) AssignPropertiesFromIndexingPolicyStatus(source *v1alpha1api20210515storage.IndexingPolicy_Status) error {

	// Automatic
	if source.Automatic != nil {
		automatic := *source.Automatic
		policy.Automatic = &automatic
	} else {
		policy.Automatic = nil
	}

	// CompositeIndexes
	if source.CompositeIndexes != nil {
		compositeIndexList := make([][]CompositePath_Status, len(source.CompositeIndexes))
		for compositeIndex, compositeIndexItem := range source.CompositeIndexes {
			// Shadow the loop variable to avoid aliasing
			compositeIndexItem := compositeIndexItem
			if compositeIndexItem != nil {
				compositeIndexList1 := make([]CompositePath_Status, len(compositeIndexItem))
				for compositeIndex1, compositeIndexItem1 := range compositeIndexItem {
					// Shadow the loop variable to avoid aliasing
					compositeIndexItem1 := compositeIndexItem1
					var compositeIndexLocal CompositePath_Status
					err := compositeIndexLocal.AssignPropertiesFromCompositePathStatus(&compositeIndexItem1)
					if err != nil {
						return errors.Wrap(err, "calling AssignPropertiesFromCompositePathStatus() to populate field CompositeIndexes")
					}
					compositeIndexList1[compositeIndex1] = compositeIndexLocal
				}
				compositeIndexList[compositeIndex] = compositeIndexList1
			} else {
				compositeIndexList[compositeIndex] = nil
			}
		}
		policy.CompositeIndexes = compositeIndexList
	} else {
		policy.CompositeIndexes = nil
	}

	// ExcludedPaths
	if source.ExcludedPaths != nil {
		excludedPathList := make([]ExcludedPath_Status, len(source.ExcludedPaths))
		for excludedPathIndex, excludedPathItem := range source.ExcludedPaths {
			// Shadow the loop variable to avoid aliasing
			excludedPathItem := excludedPathItem
			var excludedPath ExcludedPath_Status
			err := excludedPath.AssignPropertiesFromExcludedPathStatus(&excludedPathItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromExcludedPathStatus() to populate field ExcludedPaths")
			}
			excludedPathList[excludedPathIndex] = excludedPath
		}
		policy.ExcludedPaths = excludedPathList
	} else {
		policy.ExcludedPaths = nil
	}

	// IncludedPaths
	if source.IncludedPaths != nil {
		includedPathList := make([]IncludedPath_Status, len(source.IncludedPaths))
		for includedPathIndex, includedPathItem := range source.IncludedPaths {
			// Shadow the loop variable to avoid aliasing
			includedPathItem := includedPathItem
			var includedPath IncludedPath_Status
			err := includedPath.AssignPropertiesFromIncludedPathStatus(&includedPathItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromIncludedPathStatus() to populate field IncludedPaths")
			}
			includedPathList[includedPathIndex] = includedPath
		}
		policy.IncludedPaths = includedPathList
	} else {
		policy.IncludedPaths = nil
	}

	// IndexingMode
	if source.IndexingMode != nil {
		indexingMode := IndexingPolicyStatusIndexingMode(*source.IndexingMode)
		policy.IndexingMode = &indexingMode
	} else {
		policy.IndexingMode = nil
	}

	// SpatialIndexes
	if source.SpatialIndexes != nil {
		spatialIndexList := make([]SpatialSpec_Status, len(source.SpatialIndexes))
		for spatialIndex, spatialIndexItem := range source.SpatialIndexes {
			// Shadow the loop variable to avoid aliasing
			spatialIndexItem := spatialIndexItem
			var spatialIndexLocal SpatialSpec_Status
			err := spatialIndexLocal.AssignPropertiesFromSpatialSpecStatus(&spatialIndexItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromSpatialSpecStatus() to populate field SpatialIndexes")
			}
			spatialIndexList[spatialIndex] = spatialIndexLocal
		}
		policy.SpatialIndexes = spatialIndexList
	} else {
		policy.SpatialIndexes = nil
	}

	// No error
	return nil
}

// AssignPropertiesToIndexingPolicyStatus populates the provided destination IndexingPolicy_Status from our IndexingPolicy_Status
func (policy *IndexingPolicy_Status) AssignPropertiesToIndexingPolicyStatus(destination *v1alpha1api20210515storage.IndexingPolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Automatic
	if policy.Automatic != nil {
		automatic := *policy.Automatic
		destination.Automatic = &automatic
	} else {
		destination.Automatic = nil
	}

	// CompositeIndexes
	if policy.CompositeIndexes != nil {
		compositeIndexList := make([][]v1alpha1api20210515storage.CompositePath_Status, len(policy.CompositeIndexes))
		for compositeIndex, compositeIndexItem := range policy.CompositeIndexes {
			// Shadow the loop variable to avoid aliasing
			compositeIndexItem := compositeIndexItem
			if compositeIndexItem != nil {
				compositeIndexList1 := make([]v1alpha1api20210515storage.CompositePath_Status, len(compositeIndexItem))
				for compositeIndex1, compositeIndexItem1 := range compositeIndexItem {
					// Shadow the loop variable to avoid aliasing
					compositeIndexItem1 := compositeIndexItem1
					var compositeIndexLocal v1alpha1api20210515storage.CompositePath_Status
					err := compositeIndexItem1.AssignPropertiesToCompositePathStatus(&compositeIndexLocal)
					if err != nil {
						return errors.Wrap(err, "calling AssignPropertiesToCompositePathStatus() to populate field CompositeIndexes")
					}
					compositeIndexList1[compositeIndex1] = compositeIndexLocal
				}
				compositeIndexList[compositeIndex] = compositeIndexList1
			} else {
				compositeIndexList[compositeIndex] = nil
			}
		}
		destination.CompositeIndexes = compositeIndexList
	} else {
		destination.CompositeIndexes = nil
	}

	// ExcludedPaths
	if policy.ExcludedPaths != nil {
		excludedPathList := make([]v1alpha1api20210515storage.ExcludedPath_Status, len(policy.ExcludedPaths))
		for excludedPathIndex, excludedPathItem := range policy.ExcludedPaths {
			// Shadow the loop variable to avoid aliasing
			excludedPathItem := excludedPathItem
			var excludedPath v1alpha1api20210515storage.ExcludedPath_Status
			err := excludedPathItem.AssignPropertiesToExcludedPathStatus(&excludedPath)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToExcludedPathStatus() to populate field ExcludedPaths")
			}
			excludedPathList[excludedPathIndex] = excludedPath
		}
		destination.ExcludedPaths = excludedPathList
	} else {
		destination.ExcludedPaths = nil
	}

	// IncludedPaths
	if policy.IncludedPaths != nil {
		includedPathList := make([]v1alpha1api20210515storage.IncludedPath_Status, len(policy.IncludedPaths))
		for includedPathIndex, includedPathItem := range policy.IncludedPaths {
			// Shadow the loop variable to avoid aliasing
			includedPathItem := includedPathItem
			var includedPath v1alpha1api20210515storage.IncludedPath_Status
			err := includedPathItem.AssignPropertiesToIncludedPathStatus(&includedPath)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToIncludedPathStatus() to populate field IncludedPaths")
			}
			includedPathList[includedPathIndex] = includedPath
		}
		destination.IncludedPaths = includedPathList
	} else {
		destination.IncludedPaths = nil
	}

	// IndexingMode
	if policy.IndexingMode != nil {
		indexingMode := string(*policy.IndexingMode)
		destination.IndexingMode = &indexingMode
	} else {
		destination.IndexingMode = nil
	}

	// SpatialIndexes
	if policy.SpatialIndexes != nil {
		spatialIndexList := make([]v1alpha1api20210515storage.SpatialSpec_Status, len(policy.SpatialIndexes))
		for spatialIndex, spatialIndexItem := range policy.SpatialIndexes {
			// Shadow the loop variable to avoid aliasing
			spatialIndexItem := spatialIndexItem
			var spatialIndexLocal v1alpha1api20210515storage.SpatialSpec_Status
			err := spatialIndexItem.AssignPropertiesToSpatialSpecStatus(&spatialIndexLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToSpatialSpecStatus() to populate field SpatialIndexes")
			}
			spatialIndexList[spatialIndex] = spatialIndexLocal
		}
		destination.SpatialIndexes = spatialIndexList
	} else {
		destination.SpatialIndexes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UniqueKeyPolicy_Spec struct {
	//UniqueKeys: List of unique keys on that enforces uniqueness constraint on
	//documents in the collection in the Azure Cosmos DB service.
	UniqueKeys []UniqueKey_Spec `json:"uniqueKeys,omitempty"`
}

var _ genruntime.ARMTransformer = &UniqueKeyPolicy_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *UniqueKeyPolicy_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	var result UniqueKeyPolicy_SpecARM

	// Set property ‘UniqueKeys’:
	for _, item := range policy.UniqueKeys {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.UniqueKeys = append(result.UniqueKeys, itemARM.(UniqueKey_SpecARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *UniqueKeyPolicy_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UniqueKeyPolicy_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *UniqueKeyPolicy_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UniqueKeyPolicy_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UniqueKeyPolicy_SpecARM, got %T", armInput)
	}

	// Set property ‘UniqueKeys’:
	for _, item := range typedInput.UniqueKeys {
		var item1 UniqueKey_Spec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.UniqueKeys = append(policy.UniqueKeys, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromUniqueKeyPolicySpec populates our UniqueKeyPolicy_Spec from the provided source UniqueKeyPolicy_Spec
func (policy *UniqueKeyPolicy_Spec) AssignPropertiesFromUniqueKeyPolicySpec(source *v1alpha1api20210515storage.UniqueKeyPolicy_Spec) error {

	// UniqueKeys
	if source.UniqueKeys != nil {
		uniqueKeyList := make([]UniqueKey_Spec, len(source.UniqueKeys))
		for uniqueKeyIndex, uniqueKeyItem := range source.UniqueKeys {
			// Shadow the loop variable to avoid aliasing
			uniqueKeyItem := uniqueKeyItem
			var uniqueKey UniqueKey_Spec
			err := uniqueKey.AssignPropertiesFromUniqueKeySpec(&uniqueKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromUniqueKeySpec() to populate field UniqueKeys")
			}
			uniqueKeyList[uniqueKeyIndex] = uniqueKey
		}
		policy.UniqueKeys = uniqueKeyList
	} else {
		policy.UniqueKeys = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUniqueKeyPolicySpec populates the provided destination UniqueKeyPolicy_Spec from our UniqueKeyPolicy_Spec
func (policy *UniqueKeyPolicy_Spec) AssignPropertiesToUniqueKeyPolicySpec(destination *v1alpha1api20210515storage.UniqueKeyPolicy_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UniqueKeys
	if policy.UniqueKeys != nil {
		uniqueKeyList := make([]v1alpha1api20210515storage.UniqueKey_Spec, len(policy.UniqueKeys))
		for uniqueKeyIndex, uniqueKeyItem := range policy.UniqueKeys {
			// Shadow the loop variable to avoid aliasing
			uniqueKeyItem := uniqueKeyItem
			var uniqueKey v1alpha1api20210515storage.UniqueKey_Spec
			err := uniqueKeyItem.AssignPropertiesToUniqueKeySpec(&uniqueKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToUniqueKeySpec() to populate field UniqueKeys")
			}
			uniqueKeyList[uniqueKeyIndex] = uniqueKey
		}
		destination.UniqueKeys = uniqueKeyList
	} else {
		destination.UniqueKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UniqueKeyPolicy_Status struct {
	//UniqueKeys: List of unique keys on that enforces uniqueness constraint on
	//documents in the collection in the Azure Cosmos DB service.
	UniqueKeys []UniqueKey_Status `json:"uniqueKeys,omitempty"`
}

var _ genruntime.FromARMConverter = &UniqueKeyPolicy_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *UniqueKeyPolicy_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UniqueKeyPolicy_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *UniqueKeyPolicy_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UniqueKeyPolicy_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UniqueKeyPolicy_StatusARM, got %T", armInput)
	}

	// Set property ‘UniqueKeys’:
	for _, item := range typedInput.UniqueKeys {
		var item1 UniqueKey_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.UniqueKeys = append(policy.UniqueKeys, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromUniqueKeyPolicyStatus populates our UniqueKeyPolicy_Status from the provided source UniqueKeyPolicy_Status
func (policy *UniqueKeyPolicy_Status) AssignPropertiesFromUniqueKeyPolicyStatus(source *v1alpha1api20210515storage.UniqueKeyPolicy_Status) error {

	// UniqueKeys
	if source.UniqueKeys != nil {
		uniqueKeyList := make([]UniqueKey_Status, len(source.UniqueKeys))
		for uniqueKeyIndex, uniqueKeyItem := range source.UniqueKeys {
			// Shadow the loop variable to avoid aliasing
			uniqueKeyItem := uniqueKeyItem
			var uniqueKey UniqueKey_Status
			err := uniqueKey.AssignPropertiesFromUniqueKeyStatus(&uniqueKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromUniqueKeyStatus() to populate field UniqueKeys")
			}
			uniqueKeyList[uniqueKeyIndex] = uniqueKey
		}
		policy.UniqueKeys = uniqueKeyList
	} else {
		policy.UniqueKeys = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUniqueKeyPolicyStatus populates the provided destination UniqueKeyPolicy_Status from our UniqueKeyPolicy_Status
func (policy *UniqueKeyPolicy_Status) AssignPropertiesToUniqueKeyPolicyStatus(destination *v1alpha1api20210515storage.UniqueKeyPolicy_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// UniqueKeys
	if policy.UniqueKeys != nil {
		uniqueKeyList := make([]v1alpha1api20210515storage.UniqueKey_Status, len(policy.UniqueKeys))
		for uniqueKeyIndex, uniqueKeyItem := range policy.UniqueKeys {
			// Shadow the loop variable to avoid aliasing
			uniqueKeyItem := uniqueKeyItem
			var uniqueKey v1alpha1api20210515storage.UniqueKey_Status
			err := uniqueKeyItem.AssignPropertiesToUniqueKeyStatus(&uniqueKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToUniqueKeyStatus() to populate field UniqueKeys")
			}
			uniqueKeyList[uniqueKeyIndex] = uniqueKey
		}
		destination.UniqueKeys = uniqueKeyList
	} else {
		destination.UniqueKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CompositePath_Spec struct {
	//Order: Sort order for composite paths.
	Order *CompositePathSpecOrder `json:"order,omitempty"`

	//Path: The path for which the indexing behavior applies to. Index paths typically
	//start with root and end with wildcard (/path/*)
	Path *string `json:"path,omitempty"`
}

var _ genruntime.ARMTransformer = &CompositePath_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (path *CompositePath_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if path == nil {
		return nil, nil
	}
	var result CompositePath_SpecARM

	// Set property ‘Order’:
	if path.Order != nil {
		order := *path.Order
		result.Order = &order
	}

	// Set property ‘Path’:
	if path.Path != nil {
		path1 := *path.Path
		result.Path = &path1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (path *CompositePath_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CompositePath_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (path *CompositePath_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CompositePath_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CompositePath_SpecARM, got %T", armInput)
	}

	// Set property ‘Order’:
	if typedInput.Order != nil {
		order := *typedInput.Order
		path.Order = &order
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path1 := *typedInput.Path
		path.Path = &path1
	}

	// No error
	return nil
}

// AssignPropertiesFromCompositePathSpec populates our CompositePath_Spec from the provided source CompositePath_Spec
func (path *CompositePath_Spec) AssignPropertiesFromCompositePathSpec(source *v1alpha1api20210515storage.CompositePath_Spec) error {

	// Order
	if source.Order != nil {
		order := CompositePathSpecOrder(*source.Order)
		path.Order = &order
	} else {
		path.Order = nil
	}

	// Path
	path.Path = genruntime.ClonePointerToString(source.Path)

	// No error
	return nil
}

// AssignPropertiesToCompositePathSpec populates the provided destination CompositePath_Spec from our CompositePath_Spec
func (path *CompositePath_Spec) AssignPropertiesToCompositePathSpec(destination *v1alpha1api20210515storage.CompositePath_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Order
	if path.Order != nil {
		order := string(*path.Order)
		destination.Order = &order
	} else {
		destination.Order = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(path.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CompositePath_Status struct {
	//Order: Sort order for composite paths.
	Order *CompositePathStatusOrder `json:"order,omitempty"`

	//Path: The path for which the indexing behavior applies to. Index paths typically
	//start with root and end with wildcard (/path/*)
	Path *string `json:"path,omitempty"`
}

var _ genruntime.FromARMConverter = &CompositePath_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (path *CompositePath_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CompositePath_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (path *CompositePath_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CompositePath_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CompositePath_StatusARM, got %T", armInput)
	}

	// Set property ‘Order’:
	if typedInput.Order != nil {
		order := *typedInput.Order
		path.Order = &order
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path1 := *typedInput.Path
		path.Path = &path1
	}

	// No error
	return nil
}

// AssignPropertiesFromCompositePathStatus populates our CompositePath_Status from the provided source CompositePath_Status
func (path *CompositePath_Status) AssignPropertiesFromCompositePathStatus(source *v1alpha1api20210515storage.CompositePath_Status) error {

	// Order
	if source.Order != nil {
		order := CompositePathStatusOrder(*source.Order)
		path.Order = &order
	} else {
		path.Order = nil
	}

	// Path
	path.Path = genruntime.ClonePointerToString(source.Path)

	// No error
	return nil
}

// AssignPropertiesToCompositePathStatus populates the provided destination CompositePath_Status from our CompositePath_Status
func (path *CompositePath_Status) AssignPropertiesToCompositePathStatus(destination *v1alpha1api20210515storage.CompositePath_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Order
	if path.Order != nil {
		order := string(*path.Order)
		destination.Order = &order
	} else {
		destination.Order = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(path.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ExcludedPath_Spec struct {
	//Path: The path for which the indexing behavior applies to. Index paths typically
	//start with root and end with wildcard (/path/*)
	Path *string `json:"path,omitempty"`
}

var _ genruntime.ARMTransformer = &ExcludedPath_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (path *ExcludedPath_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if path == nil {
		return nil, nil
	}
	var result ExcludedPath_SpecARM

	// Set property ‘Path’:
	if path.Path != nil {
		path1 := *path.Path
		result.Path = &path1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (path *ExcludedPath_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExcludedPath_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (path *ExcludedPath_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExcludedPath_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExcludedPath_SpecARM, got %T", armInput)
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path1 := *typedInput.Path
		path.Path = &path1
	}

	// No error
	return nil
}

// AssignPropertiesFromExcludedPathSpec populates our ExcludedPath_Spec from the provided source ExcludedPath_Spec
func (path *ExcludedPath_Spec) AssignPropertiesFromExcludedPathSpec(source *v1alpha1api20210515storage.ExcludedPath_Spec) error {

	// Path
	path.Path = genruntime.ClonePointerToString(source.Path)

	// No error
	return nil
}

// AssignPropertiesToExcludedPathSpec populates the provided destination ExcludedPath_Spec from our ExcludedPath_Spec
func (path *ExcludedPath_Spec) AssignPropertiesToExcludedPathSpec(destination *v1alpha1api20210515storage.ExcludedPath_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Path
	destination.Path = genruntime.ClonePointerToString(path.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ExcludedPath_Status struct {
	//Path: The path for which the indexing behavior applies to. Index paths typically
	//start with root and end with wildcard (/path/*)
	Path *string `json:"path,omitempty"`
}

var _ genruntime.FromARMConverter = &ExcludedPath_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (path *ExcludedPath_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ExcludedPath_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (path *ExcludedPath_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ExcludedPath_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ExcludedPath_StatusARM, got %T", armInput)
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path1 := *typedInput.Path
		path.Path = &path1
	}

	// No error
	return nil
}

// AssignPropertiesFromExcludedPathStatus populates our ExcludedPath_Status from the provided source ExcludedPath_Status
func (path *ExcludedPath_Status) AssignPropertiesFromExcludedPathStatus(source *v1alpha1api20210515storage.ExcludedPath_Status) error {

	// Path
	path.Path = genruntime.ClonePointerToString(source.Path)

	// No error
	return nil
}

// AssignPropertiesToExcludedPathStatus populates the provided destination ExcludedPath_Status from our ExcludedPath_Status
func (path *ExcludedPath_Status) AssignPropertiesToExcludedPathStatus(destination *v1alpha1api20210515storage.ExcludedPath_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Path
	destination.Path = genruntime.ClonePointerToString(path.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type IncludedPath_Spec struct {
	//Indexes: List of indexes for this path
	Indexes []Indexes_Spec `json:"indexes,omitempty"`

	//Path: The path for which the indexing behavior applies to. Index paths typically
	//start with root and end with wildcard (/path/*)
	Path *string `json:"path,omitempty"`
}

var _ genruntime.ARMTransformer = &IncludedPath_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (path *IncludedPath_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if path == nil {
		return nil, nil
	}
	var result IncludedPath_SpecARM

	// Set property ‘Indexes’:
	for _, item := range path.Indexes {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Indexes = append(result.Indexes, itemARM.(Indexes_SpecARM))
	}

	// Set property ‘Path’:
	if path.Path != nil {
		path1 := *path.Path
		result.Path = &path1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (path *IncludedPath_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IncludedPath_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (path *IncludedPath_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IncludedPath_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IncludedPath_SpecARM, got %T", armInput)
	}

	// Set property ‘Indexes’:
	for _, item := range typedInput.Indexes {
		var item1 Indexes_Spec
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		path.Indexes = append(path.Indexes, item1)
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path1 := *typedInput.Path
		path.Path = &path1
	}

	// No error
	return nil
}

// AssignPropertiesFromIncludedPathSpec populates our IncludedPath_Spec from the provided source IncludedPath_Spec
func (path *IncludedPath_Spec) AssignPropertiesFromIncludedPathSpec(source *v1alpha1api20210515storage.IncludedPath_Spec) error {

	// Indexes
	if source.Indexes != nil {
		indexList := make([]Indexes_Spec, len(source.Indexes))
		for index, indexItem := range source.Indexes {
			// Shadow the loop variable to avoid aliasing
			indexItem := indexItem
			var indexLocal Indexes_Spec
			err := indexLocal.AssignPropertiesFromIndexesSpec(&indexItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromIndexesSpec() to populate field Indexes")
			}
			indexList[index] = indexLocal
		}
		path.Indexes = indexList
	} else {
		path.Indexes = nil
	}

	// Path
	path.Path = genruntime.ClonePointerToString(source.Path)

	// No error
	return nil
}

// AssignPropertiesToIncludedPathSpec populates the provided destination IncludedPath_Spec from our IncludedPath_Spec
func (path *IncludedPath_Spec) AssignPropertiesToIncludedPathSpec(destination *v1alpha1api20210515storage.IncludedPath_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Indexes
	if path.Indexes != nil {
		indexList := make([]v1alpha1api20210515storage.Indexes_Spec, len(path.Indexes))
		for index, indexItem := range path.Indexes {
			// Shadow the loop variable to avoid aliasing
			indexItem := indexItem
			var indexLocal v1alpha1api20210515storage.Indexes_Spec
			err := indexItem.AssignPropertiesToIndexesSpec(&indexLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToIndexesSpec() to populate field Indexes")
			}
			indexList[index] = indexLocal
		}
		destination.Indexes = indexList
	} else {
		destination.Indexes = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(path.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type IncludedPath_Status struct {
	//Indexes: List of indexes for this path
	Indexes []Indexes_Status `json:"indexes,omitempty"`

	//Path: The path for which the indexing behavior applies to. Index paths typically
	//start with root and end with wildcard (/path/*)
	Path *string `json:"path,omitempty"`
}

var _ genruntime.FromARMConverter = &IncludedPath_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (path *IncludedPath_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IncludedPath_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (path *IncludedPath_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IncludedPath_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IncludedPath_StatusARM, got %T", armInput)
	}

	// Set property ‘Indexes’:
	for _, item := range typedInput.Indexes {
		var item1 Indexes_Status
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		path.Indexes = append(path.Indexes, item1)
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path1 := *typedInput.Path
		path.Path = &path1
	}

	// No error
	return nil
}

// AssignPropertiesFromIncludedPathStatus populates our IncludedPath_Status from the provided source IncludedPath_Status
func (path *IncludedPath_Status) AssignPropertiesFromIncludedPathStatus(source *v1alpha1api20210515storage.IncludedPath_Status) error {

	// Indexes
	if source.Indexes != nil {
		indexList := make([]Indexes_Status, len(source.Indexes))
		for index, indexItem := range source.Indexes {
			// Shadow the loop variable to avoid aliasing
			indexItem := indexItem
			var indexLocal Indexes_Status
			err := indexLocal.AssignPropertiesFromIndexesStatus(&indexItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromIndexesStatus() to populate field Indexes")
			}
			indexList[index] = indexLocal
		}
		path.Indexes = indexList
	} else {
		path.Indexes = nil
	}

	// Path
	path.Path = genruntime.ClonePointerToString(source.Path)

	// No error
	return nil
}

// AssignPropertiesToIncludedPathStatus populates the provided destination IncludedPath_Status from our IncludedPath_Status
func (path *IncludedPath_Status) AssignPropertiesToIncludedPathStatus(destination *v1alpha1api20210515storage.IncludedPath_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Indexes
	if path.Indexes != nil {
		indexList := make([]v1alpha1api20210515storage.Indexes_Status, len(path.Indexes))
		for index, indexItem := range path.Indexes {
			// Shadow the loop variable to avoid aliasing
			indexItem := indexItem
			var indexLocal v1alpha1api20210515storage.Indexes_Status
			err := indexItem.AssignPropertiesToIndexesStatus(&indexLocal)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToIndexesStatus() to populate field Indexes")
			}
			indexList[index] = indexLocal
		}
		destination.Indexes = indexList
	} else {
		destination.Indexes = nil
	}

	// Path
	destination.Path = genruntime.ClonePointerToString(path.Path)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SpatialSpec_Spec struct {
	//Path: The path for which the indexing behavior applies to. Index paths typically
	//start with root and end with wildcard (/path/*)
	Path *string `json:"path,omitempty"`

	//Types: List of path's spatial type
	Types []SpatialType_Spec `json:"types,omitempty"`
}

var _ genruntime.ARMTransformer = &SpatialSpec_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (spatial *SpatialSpec_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if spatial == nil {
		return nil, nil
	}
	var result SpatialSpec_SpecARM

	// Set property ‘Path’:
	if spatial.Path != nil {
		path := *spatial.Path
		result.Path = &path
	}

	// Set property ‘Types’:
	for _, item := range spatial.Types {
		result.Types = append(result.Types, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (spatial *SpatialSpec_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SpatialSpec_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (spatial *SpatialSpec_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SpatialSpec_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SpatialSpec_SpecARM, got %T", armInput)
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		spatial.Path = &path
	}

	// Set property ‘Types’:
	for _, item := range typedInput.Types {
		spatial.Types = append(spatial.Types, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromSpatialSpecSpec populates our SpatialSpec_Spec from the provided source SpatialSpec_Spec
func (spatial *SpatialSpec_Spec) AssignPropertiesFromSpatialSpecSpec(source *v1alpha1api20210515storage.SpatialSpec_Spec) error {

	// Path
	spatial.Path = genruntime.ClonePointerToString(source.Path)

	// Types
	if source.Types != nil {
		typeList := make([]SpatialType_Spec, len(source.Types))
		for typeIndex, typeItem := range source.Types {
			// Shadow the loop variable to avoid aliasing
			typeItem := typeItem
			typeList[typeIndex] = SpatialType_Spec(typeItem)
		}
		spatial.Types = typeList
	} else {
		spatial.Types = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSpatialSpecSpec populates the provided destination SpatialSpec_Spec from our SpatialSpec_Spec
func (spatial *SpatialSpec_Spec) AssignPropertiesToSpatialSpecSpec(destination *v1alpha1api20210515storage.SpatialSpec_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Path
	destination.Path = genruntime.ClonePointerToString(spatial.Path)

	// Types
	if spatial.Types != nil {
		typeList := make([]string, len(spatial.Types))
		for typeIndex, typeItem := range spatial.Types {
			// Shadow the loop variable to avoid aliasing
			typeItem := typeItem
			typeList[typeIndex] = string(typeItem)
		}
		destination.Types = typeList
	} else {
		destination.Types = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SpatialSpec_Status struct {
	//Path: The path for which the indexing behavior applies to. Index paths typically
	//start with root and end with wildcard (/path/*)
	Path *string `json:"path,omitempty"`

	//Types: List of path's spatial type
	Types []SpatialType_Status `json:"types,omitempty"`
}

var _ genruntime.FromARMConverter = &SpatialSpec_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (spatial *SpatialSpec_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SpatialSpec_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (spatial *SpatialSpec_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SpatialSpec_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SpatialSpec_StatusARM, got %T", armInput)
	}

	// Set property ‘Path’:
	if typedInput.Path != nil {
		path := *typedInput.Path
		spatial.Path = &path
	}

	// Set property ‘Types’:
	for _, item := range typedInput.Types {
		spatial.Types = append(spatial.Types, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromSpatialSpecStatus populates our SpatialSpec_Status from the provided source SpatialSpec_Status
func (spatial *SpatialSpec_Status) AssignPropertiesFromSpatialSpecStatus(source *v1alpha1api20210515storage.SpatialSpec_Status) error {

	// Path
	spatial.Path = genruntime.ClonePointerToString(source.Path)

	// Types
	if source.Types != nil {
		typeList := make([]SpatialType_Status, len(source.Types))
		for typeIndex, typeItem := range source.Types {
			// Shadow the loop variable to avoid aliasing
			typeItem := typeItem
			typeList[typeIndex] = SpatialType_Status(typeItem)
		}
		spatial.Types = typeList
	} else {
		spatial.Types = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSpatialSpecStatus populates the provided destination SpatialSpec_Status from our SpatialSpec_Status
func (spatial *SpatialSpec_Status) AssignPropertiesToSpatialSpecStatus(destination *v1alpha1api20210515storage.SpatialSpec_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Path
	destination.Path = genruntime.ClonePointerToString(spatial.Path)

	// Types
	if spatial.Types != nil {
		typeList := make([]string, len(spatial.Types))
		for typeIndex, typeItem := range spatial.Types {
			// Shadow the loop variable to avoid aliasing
			typeItem := typeItem
			typeList[typeIndex] = string(typeItem)
		}
		destination.Types = typeList
	} else {
		destination.Types = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UniqueKey_Spec struct {
	//Paths: List of paths must be unique for each document in the Azure Cosmos DB
	//service
	Paths []string `json:"paths,omitempty"`
}

var _ genruntime.ARMTransformer = &UniqueKey_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (uniqueKey *UniqueKey_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if uniqueKey == nil {
		return nil, nil
	}
	var result UniqueKey_SpecARM

	// Set property ‘Paths’:
	for _, item := range uniqueKey.Paths {
		result.Paths = append(result.Paths, item)
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (uniqueKey *UniqueKey_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UniqueKey_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (uniqueKey *UniqueKey_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UniqueKey_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UniqueKey_SpecARM, got %T", armInput)
	}

	// Set property ‘Paths’:
	for _, item := range typedInput.Paths {
		uniqueKey.Paths = append(uniqueKey.Paths, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromUniqueKeySpec populates our UniqueKey_Spec from the provided source UniqueKey_Spec
func (uniqueKey *UniqueKey_Spec) AssignPropertiesFromUniqueKeySpec(source *v1alpha1api20210515storage.UniqueKey_Spec) error {

	// Paths
	uniqueKey.Paths = genruntime.CloneSliceOfString(source.Paths)

	// No error
	return nil
}

// AssignPropertiesToUniqueKeySpec populates the provided destination UniqueKey_Spec from our UniqueKey_Spec
func (uniqueKey *UniqueKey_Spec) AssignPropertiesToUniqueKeySpec(destination *v1alpha1api20210515storage.UniqueKey_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Paths
	destination.Paths = genruntime.CloneSliceOfString(uniqueKey.Paths)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UniqueKey_Status struct {
	//Paths: List of paths must be unique for each document in the Azure Cosmos DB
	//service
	Paths []string `json:"paths,omitempty"`
}

var _ genruntime.FromARMConverter = &UniqueKey_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (uniqueKey *UniqueKey_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UniqueKey_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (uniqueKey *UniqueKey_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UniqueKey_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UniqueKey_StatusARM, got %T", armInput)
	}

	// Set property ‘Paths’:
	for _, item := range typedInput.Paths {
		uniqueKey.Paths = append(uniqueKey.Paths, item)
	}

	// No error
	return nil
}

// AssignPropertiesFromUniqueKeyStatus populates our UniqueKey_Status from the provided source UniqueKey_Status
func (uniqueKey *UniqueKey_Status) AssignPropertiesFromUniqueKeyStatus(source *v1alpha1api20210515storage.UniqueKey_Status) error {

	// Paths
	uniqueKey.Paths = genruntime.CloneSliceOfString(source.Paths)

	// No error
	return nil
}

// AssignPropertiesToUniqueKeyStatus populates the provided destination UniqueKey_Status from our UniqueKey_Status
func (uniqueKey *UniqueKey_Status) AssignPropertiesToUniqueKeyStatus(destination *v1alpha1api20210515storage.UniqueKey_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Paths
	destination.Paths = genruntime.CloneSliceOfString(uniqueKey.Paths)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Indexes_Spec struct {
	//DataType: The datatype for which the indexing behavior is applied to.
	DataType *IndexesSpecDataType `json:"dataType,omitempty"`

	//Kind: Indicates the type of index.
	Kind *IndexesSpecKind `json:"kind,omitempty"`

	//Precision: The precision of the index. -1 is maximum precision.
	Precision *int `json:"precision,omitempty"`
}

var _ genruntime.ARMTransformer = &Indexes_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (indexes *Indexes_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if indexes == nil {
		return nil, nil
	}
	var result Indexes_SpecARM

	// Set property ‘DataType’:
	if indexes.DataType != nil {
		dataType := *indexes.DataType
		result.DataType = &dataType
	}

	// Set property ‘Kind’:
	if indexes.Kind != nil {
		kind := *indexes.Kind
		result.Kind = &kind
	}

	// Set property ‘Precision’:
	if indexes.Precision != nil {
		precision := *indexes.Precision
		result.Precision = &precision
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (indexes *Indexes_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Indexes_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (indexes *Indexes_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Indexes_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Indexes_SpecARM, got %T", armInput)
	}

	// Set property ‘DataType’:
	if typedInput.DataType != nil {
		dataType := *typedInput.DataType
		indexes.DataType = &dataType
	}

	// Set property ‘Kind’:
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		indexes.Kind = &kind
	}

	// Set property ‘Precision’:
	if typedInput.Precision != nil {
		precision := *typedInput.Precision
		indexes.Precision = &precision
	}

	// No error
	return nil
}

// AssignPropertiesFromIndexesSpec populates our Indexes_Spec from the provided source Indexes_Spec
func (indexes *Indexes_Spec) AssignPropertiesFromIndexesSpec(source *v1alpha1api20210515storage.Indexes_Spec) error {

	// DataType
	if source.DataType != nil {
		dataType := IndexesSpecDataType(*source.DataType)
		indexes.DataType = &dataType
	} else {
		indexes.DataType = nil
	}

	// Kind
	if source.Kind != nil {
		kind := IndexesSpecKind(*source.Kind)
		indexes.Kind = &kind
	} else {
		indexes.Kind = nil
	}

	// Precision
	indexes.Precision = genruntime.ClonePointerToInt(source.Precision)

	// No error
	return nil
}

// AssignPropertiesToIndexesSpec populates the provided destination Indexes_Spec from our Indexes_Spec
func (indexes *Indexes_Spec) AssignPropertiesToIndexesSpec(destination *v1alpha1api20210515storage.Indexes_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataType
	if indexes.DataType != nil {
		dataType := string(*indexes.DataType)
		destination.DataType = &dataType
	} else {
		destination.DataType = nil
	}

	// Kind
	if indexes.Kind != nil {
		kind := string(*indexes.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Precision
	destination.Precision = genruntime.ClonePointerToInt(indexes.Precision)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Indexes_Status struct {
	//DataType: The datatype for which the indexing behavior is applied to.
	DataType *IndexesStatusDataType `json:"dataType,omitempty"`

	//Kind: Indicates the type of index.
	Kind *IndexesStatusKind `json:"kind,omitempty"`

	//Precision: The precision of the index. -1 is maximum precision.
	Precision *int `json:"precision,omitempty"`
}

var _ genruntime.FromARMConverter = &Indexes_Status{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (indexes *Indexes_Status) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Indexes_StatusARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (indexes *Indexes_Status) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Indexes_StatusARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Indexes_StatusARM, got %T", armInput)
	}

	// Set property ‘DataType’:
	if typedInput.DataType != nil {
		dataType := *typedInput.DataType
		indexes.DataType = &dataType
	}

	// Set property ‘Kind’:
	if typedInput.Kind != nil {
		kind := *typedInput.Kind
		indexes.Kind = &kind
	}

	// Set property ‘Precision’:
	if typedInput.Precision != nil {
		precision := *typedInput.Precision
		indexes.Precision = &precision
	}

	// No error
	return nil
}

// AssignPropertiesFromIndexesStatus populates our Indexes_Status from the provided source Indexes_Status
func (indexes *Indexes_Status) AssignPropertiesFromIndexesStatus(source *v1alpha1api20210515storage.Indexes_Status) error {

	// DataType
	if source.DataType != nil {
		dataType := IndexesStatusDataType(*source.DataType)
		indexes.DataType = &dataType
	} else {
		indexes.DataType = nil
	}

	// Kind
	if source.Kind != nil {
		kind := IndexesStatusKind(*source.Kind)
		indexes.Kind = &kind
	} else {
		indexes.Kind = nil
	}

	// Precision
	indexes.Precision = genruntime.ClonePointerToInt(source.Precision)

	// No error
	return nil
}

// AssignPropertiesToIndexesStatus populates the provided destination Indexes_Status from our Indexes_Status
func (indexes *Indexes_Status) AssignPropertiesToIndexesStatus(destination *v1alpha1api20210515storage.Indexes_Status) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// DataType
	if indexes.DataType != nil {
		dataType := string(*indexes.DataType)
		destination.DataType = &dataType
	} else {
		destination.DataType = nil
	}

	// Kind
	if indexes.Kind != nil {
		kind := string(*indexes.Kind)
		destination.Kind = &kind
	} else {
		destination.Kind = nil
	}

	// Precision
	destination.Precision = genruntime.ClonePointerToInt(indexes.Precision)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&SqlDatabaseContainer{}, &SqlDatabaseContainerList{})
}
