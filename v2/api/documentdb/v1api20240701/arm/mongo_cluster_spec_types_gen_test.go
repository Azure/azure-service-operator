// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package arm

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AdministratorProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdministratorProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdministratorProperties, AdministratorPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdministratorProperties runs a test to see if a specific instance of AdministratorProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAdministratorProperties(subject AdministratorProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdministratorProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdministratorProperties instances for property testing - lazily instantiated by
// AdministratorPropertiesGenerator()
var administratorPropertiesGenerator gopter.Gen

// AdministratorPropertiesGenerator returns a generator of AdministratorProperties instances for property testing.
func AdministratorPropertiesGenerator() gopter.Gen {
	if administratorPropertiesGenerator != nil {
		return administratorPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdministratorProperties(generators)
	administratorPropertiesGenerator = gen.Struct(reflect.TypeOf(AdministratorProperties{}), generators)

	return administratorPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAdministratorProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdministratorProperties(gens map[string]gopter.Gen) {
	gens["Password"] = gen.PtrOf(gen.AlphaString())
	gens["UserName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ComputeProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeProperties, ComputePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeProperties runs a test to see if a specific instance of ComputeProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeProperties(subject ComputeProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeProperties instances for property testing - lazily instantiated by ComputePropertiesGenerator()
var computePropertiesGenerator gopter.Gen

// ComputePropertiesGenerator returns a generator of ComputeProperties instances for property testing.
func ComputePropertiesGenerator() gopter.Gen {
	if computePropertiesGenerator != nil {
		return computePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeProperties(generators)
	computePropertiesGenerator = gen.Struct(reflect.TypeOf(ComputeProperties{}), generators)

	return computePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForComputeProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeProperties(gens map[string]gopter.Gen) {
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_HighAvailabilityProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HighAvailabilityProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHighAvailabilityProperties, HighAvailabilityPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHighAvailabilityProperties runs a test to see if a specific instance of HighAvailabilityProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForHighAvailabilityProperties(subject HighAvailabilityProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HighAvailabilityProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HighAvailabilityProperties instances for property testing - lazily instantiated by
// HighAvailabilityPropertiesGenerator()
var highAvailabilityPropertiesGenerator gopter.Gen

// HighAvailabilityPropertiesGenerator returns a generator of HighAvailabilityProperties instances for property testing.
func HighAvailabilityPropertiesGenerator() gopter.Gen {
	if highAvailabilityPropertiesGenerator != nil {
		return highAvailabilityPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHighAvailabilityProperties(generators)
	highAvailabilityPropertiesGenerator = gen.Struct(reflect.TypeOf(HighAvailabilityProperties{}), generators)

	return highAvailabilityPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForHighAvailabilityProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHighAvailabilityProperties(gens map[string]gopter.Gen) {
	gens["TargetMode"] = gen.PtrOf(gen.OneConstOf(HighAvailabilityMode_Disabled, HighAvailabilityMode_SameZone, HighAvailabilityMode_ZoneRedundantPreferred))
}

func Test_MongoClusterProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoClusterProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoClusterProperties, MongoClusterPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoClusterProperties runs a test to see if a specific instance of MongoClusterProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoClusterProperties(subject MongoClusterProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoClusterProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoClusterProperties instances for property testing - lazily instantiated by
// MongoClusterPropertiesGenerator()
var mongoClusterPropertiesGenerator gopter.Gen

// MongoClusterPropertiesGenerator returns a generator of MongoClusterProperties instances for property testing.
// We first initialize mongoClusterPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MongoClusterPropertiesGenerator() gopter.Gen {
	if mongoClusterPropertiesGenerator != nil {
		return mongoClusterPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoClusterProperties(generators)
	mongoClusterPropertiesGenerator = gen.Struct(reflect.TypeOf(MongoClusterProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoClusterProperties(generators)
	AddRelatedPropertyGeneratorsForMongoClusterProperties(generators)
	mongoClusterPropertiesGenerator = gen.Struct(reflect.TypeOf(MongoClusterProperties{}), generators)

	return mongoClusterPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForMongoClusterProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoClusterProperties(gens map[string]gopter.Gen) {
	gens["CreateMode"] = gen.PtrOf(gen.OneConstOf(
		CreateMode_Default,
		CreateMode_GeoReplica,
		CreateMode_PointInTimeRestore,
		CreateMode_Replica))
	gens["PreviewFeatures"] = gen.SliceOf(gen.OneConstOf(PreviewFeature_GeoReplicas))
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccess_Disabled, PublicNetworkAccess_Enabled))
	gens["ServerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMongoClusterProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMongoClusterProperties(gens map[string]gopter.Gen) {
	gens["Administrator"] = gen.PtrOf(AdministratorPropertiesGenerator())
	gens["Compute"] = gen.PtrOf(ComputePropertiesGenerator())
	gens["HighAvailability"] = gen.PtrOf(HighAvailabilityPropertiesGenerator())
	gens["ReplicaParameters"] = gen.PtrOf(MongoClusterReplicaParametersGenerator())
	gens["RestoreParameters"] = gen.PtrOf(MongoClusterRestoreParametersGenerator())
	gens["Sharding"] = gen.PtrOf(ShardingPropertiesGenerator())
	gens["Storage"] = gen.PtrOf(StoragePropertiesGenerator())
}

func Test_MongoClusterReplicaParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoClusterReplicaParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoClusterReplicaParameters, MongoClusterReplicaParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoClusterReplicaParameters runs a test to see if a specific instance of MongoClusterReplicaParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoClusterReplicaParameters(subject MongoClusterReplicaParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoClusterReplicaParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoClusterReplicaParameters instances for property testing - lazily instantiated by
// MongoClusterReplicaParametersGenerator()
var mongoClusterReplicaParametersGenerator gopter.Gen

// MongoClusterReplicaParametersGenerator returns a generator of MongoClusterReplicaParameters instances for property testing.
func MongoClusterReplicaParametersGenerator() gopter.Gen {
	if mongoClusterReplicaParametersGenerator != nil {
		return mongoClusterReplicaParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoClusterReplicaParameters(generators)
	mongoClusterReplicaParametersGenerator = gen.Struct(reflect.TypeOf(MongoClusterReplicaParameters{}), generators)

	return mongoClusterReplicaParametersGenerator
}

// AddIndependentPropertyGeneratorsForMongoClusterReplicaParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoClusterReplicaParameters(gens map[string]gopter.Gen) {
	gens["SourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["SourceResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_MongoClusterRestoreParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoClusterRestoreParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoClusterRestoreParameters, MongoClusterRestoreParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoClusterRestoreParameters runs a test to see if a specific instance of MongoClusterRestoreParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoClusterRestoreParameters(subject MongoClusterRestoreParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoClusterRestoreParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoClusterRestoreParameters instances for property testing - lazily instantiated by
// MongoClusterRestoreParametersGenerator()
var mongoClusterRestoreParametersGenerator gopter.Gen

// MongoClusterRestoreParametersGenerator returns a generator of MongoClusterRestoreParameters instances for property testing.
func MongoClusterRestoreParametersGenerator() gopter.Gen {
	if mongoClusterRestoreParametersGenerator != nil {
		return mongoClusterRestoreParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoClusterRestoreParameters(generators)
	mongoClusterRestoreParametersGenerator = gen.Struct(reflect.TypeOf(MongoClusterRestoreParameters{}), generators)

	return mongoClusterRestoreParametersGenerator
}

// AddIndependentPropertyGeneratorsForMongoClusterRestoreParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoClusterRestoreParameters(gens map[string]gopter.Gen) {
	gens["PointInTimeUTC"] = gen.PtrOf(gen.AlphaString())
	gens["SourceResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_MongoCluster_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoCluster_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoCluster_Spec, MongoCluster_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoCluster_Spec runs a test to see if a specific instance of MongoCluster_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoCluster_Spec(subject MongoCluster_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoCluster_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoCluster_Spec instances for property testing - lazily instantiated by MongoCluster_SpecGenerator()
var mongoCluster_SpecGenerator gopter.Gen

// MongoCluster_SpecGenerator returns a generator of MongoCluster_Spec instances for property testing.
// We first initialize mongoCluster_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MongoCluster_SpecGenerator() gopter.Gen {
	if mongoCluster_SpecGenerator != nil {
		return mongoCluster_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoCluster_Spec(generators)
	mongoCluster_SpecGenerator = gen.Struct(reflect.TypeOf(MongoCluster_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoCluster_Spec(generators)
	AddRelatedPropertyGeneratorsForMongoCluster_Spec(generators)
	mongoCluster_SpecGenerator = gen.Struct(reflect.TypeOf(MongoCluster_Spec{}), generators)

	return mongoCluster_SpecGenerator
}

// AddIndependentPropertyGeneratorsForMongoCluster_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoCluster_Spec(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMongoCluster_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMongoCluster_Spec(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(MongoClusterPropertiesGenerator())
}

func Test_ShardingProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ShardingProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForShardingProperties, ShardingPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForShardingProperties runs a test to see if a specific instance of ShardingProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForShardingProperties(subject ShardingProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ShardingProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ShardingProperties instances for property testing - lazily instantiated by ShardingPropertiesGenerator()
var shardingPropertiesGenerator gopter.Gen

// ShardingPropertiesGenerator returns a generator of ShardingProperties instances for property testing.
func ShardingPropertiesGenerator() gopter.Gen {
	if shardingPropertiesGenerator != nil {
		return shardingPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForShardingProperties(generators)
	shardingPropertiesGenerator = gen.Struct(reflect.TypeOf(ShardingProperties{}), generators)

	return shardingPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForShardingProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForShardingProperties(gens map[string]gopter.Gen) {
	gens["ShardCount"] = gen.PtrOf(gen.Int())
}

func Test_StorageProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProperties, StoragePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProperties runs a test to see if a specific instance of StorageProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProperties(subject StorageProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProperties instances for property testing - lazily instantiated by StoragePropertiesGenerator()
var storagePropertiesGenerator gopter.Gen

// StoragePropertiesGenerator returns a generator of StorageProperties instances for property testing.
func StoragePropertiesGenerator() gopter.Gen {
	if storagePropertiesGenerator != nil {
		return storagePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageProperties(generators)
	storagePropertiesGenerator = gen.Struct(reflect.TypeOf(StorageProperties{}), generators)

	return storagePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForStorageProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageProperties(gens map[string]gopter.Gen) {
	gens["SizeGb"] = gen.PtrOf(gen.Int())
}
