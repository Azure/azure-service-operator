// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	storage "github.com/Azure/azure-service-operator/v2/api/documentdb/v1api20240815/storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AdministratorProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdministratorProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdministratorProperties, AdministratorPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdministratorProperties runs a test to see if a specific instance of AdministratorProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForAdministratorProperties(subject AdministratorProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdministratorProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdministratorProperties instances for property testing - lazily instantiated by
// AdministratorPropertiesGenerator()
var administratorPropertiesGenerator gopter.Gen

// AdministratorPropertiesGenerator returns a generator of AdministratorProperties instances for property testing.
func AdministratorPropertiesGenerator() gopter.Gen {
	if administratorPropertiesGenerator != nil {
		return administratorPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdministratorProperties(generators)
	administratorPropertiesGenerator = gen.Struct(reflect.TypeOf(AdministratorProperties{}), generators)

	return administratorPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForAdministratorProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdministratorProperties(gens map[string]gopter.Gen) {
	gens["UserName"] = gen.PtrOf(gen.AlphaString())
}

func Test_AdministratorProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AdministratorProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAdministratorProperties_STATUS, AdministratorProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAdministratorProperties_STATUS runs a test to see if a specific instance of AdministratorProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAdministratorProperties_STATUS(subject AdministratorProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AdministratorProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AdministratorProperties_STATUS instances for property testing - lazily instantiated by
// AdministratorProperties_STATUSGenerator()
var administratorProperties_STATUSGenerator gopter.Gen

// AdministratorProperties_STATUSGenerator returns a generator of AdministratorProperties_STATUS instances for property testing.
func AdministratorProperties_STATUSGenerator() gopter.Gen {
	if administratorProperties_STATUSGenerator != nil {
		return administratorProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAdministratorProperties_STATUS(generators)
	administratorProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(AdministratorProperties_STATUS{}), generators)

	return administratorProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAdministratorProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAdministratorProperties_STATUS(gens map[string]gopter.Gen) {
	gens["UserName"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackupProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupProperties_STATUS, BackupProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupProperties_STATUS runs a test to see if a specific instance of BackupProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupProperties_STATUS(subject BackupProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupProperties_STATUS instances for property testing - lazily instantiated by
// BackupProperties_STATUSGenerator()
var backupProperties_STATUSGenerator gopter.Gen

// BackupProperties_STATUSGenerator returns a generator of BackupProperties_STATUS instances for property testing.
func BackupProperties_STATUSGenerator() gopter.Gen {
	if backupProperties_STATUSGenerator != nil {
		return backupProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupProperties_STATUS(generators)
	backupProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(BackupProperties_STATUS{}), generators)

	return backupProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForBackupProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupProperties_STATUS(gens map[string]gopter.Gen) {
	gens["EarliestRestoreTime"] = gen.PtrOf(gen.AlphaString())
}

func Test_ComputeProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeProperties, ComputePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeProperties runs a test to see if a specific instance of ComputeProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeProperties(subject ComputeProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeProperties instances for property testing - lazily instantiated by ComputePropertiesGenerator()
var computePropertiesGenerator gopter.Gen

// ComputePropertiesGenerator returns a generator of ComputeProperties instances for property testing.
func ComputePropertiesGenerator() gopter.Gen {
	if computePropertiesGenerator != nil {
		return computePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeProperties(generators)
	computePropertiesGenerator = gen.Struct(reflect.TypeOf(ComputeProperties{}), generators)

	return computePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForComputeProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeProperties(gens map[string]gopter.Gen) {
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_ComputeProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ComputeProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComputeProperties_STATUS, ComputeProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComputeProperties_STATUS runs a test to see if a specific instance of ComputeProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForComputeProperties_STATUS(subject ComputeProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ComputeProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ComputeProperties_STATUS instances for property testing - lazily instantiated by
// ComputeProperties_STATUSGenerator()
var computeProperties_STATUSGenerator gopter.Gen

// ComputeProperties_STATUSGenerator returns a generator of ComputeProperties_STATUS instances for property testing.
func ComputeProperties_STATUSGenerator() gopter.Gen {
	if computeProperties_STATUSGenerator != nil {
		return computeProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComputeProperties_STATUS(generators)
	computeProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ComputeProperties_STATUS{}), generators)

	return computeProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForComputeProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComputeProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Tier"] = gen.PtrOf(gen.AlphaString())
}

func Test_HighAvailabilityProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HighAvailabilityProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHighAvailabilityProperties, HighAvailabilityPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHighAvailabilityProperties runs a test to see if a specific instance of HighAvailabilityProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForHighAvailabilityProperties(subject HighAvailabilityProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HighAvailabilityProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HighAvailabilityProperties instances for property testing - lazily instantiated by
// HighAvailabilityPropertiesGenerator()
var highAvailabilityPropertiesGenerator gopter.Gen

// HighAvailabilityPropertiesGenerator returns a generator of HighAvailabilityProperties instances for property testing.
func HighAvailabilityPropertiesGenerator() gopter.Gen {
	if highAvailabilityPropertiesGenerator != nil {
		return highAvailabilityPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHighAvailabilityProperties(generators)
	highAvailabilityPropertiesGenerator = gen.Struct(reflect.TypeOf(HighAvailabilityProperties{}), generators)

	return highAvailabilityPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForHighAvailabilityProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHighAvailabilityProperties(gens map[string]gopter.Gen) {
	gens["TargetMode"] = gen.PtrOf(gen.AlphaString())
}

func Test_HighAvailabilityProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HighAvailabilityProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHighAvailabilityProperties_STATUS, HighAvailabilityProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHighAvailabilityProperties_STATUS runs a test to see if a specific instance of HighAvailabilityProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHighAvailabilityProperties_STATUS(subject HighAvailabilityProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HighAvailabilityProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HighAvailabilityProperties_STATUS instances for property testing - lazily instantiated by
// HighAvailabilityProperties_STATUSGenerator()
var highAvailabilityProperties_STATUSGenerator gopter.Gen

// HighAvailabilityProperties_STATUSGenerator returns a generator of HighAvailabilityProperties_STATUS instances for property testing.
func HighAvailabilityProperties_STATUSGenerator() gopter.Gen {
	if highAvailabilityProperties_STATUSGenerator != nil {
		return highAvailabilityProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHighAvailabilityProperties_STATUS(generators)
	highAvailabilityProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(HighAvailabilityProperties_STATUS{}), generators)

	return highAvailabilityProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHighAvailabilityProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHighAvailabilityProperties_STATUS(gens map[string]gopter.Gen) {
	gens["TargetMode"] = gen.PtrOf(gen.AlphaString())
}

func Test_MongoCluster_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoCluster via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoCluster, MongoClusterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoCluster runs a test to see if a specific instance of MongoCluster round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoCluster(subject MongoCluster) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoCluster
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoCluster instances for property testing - lazily instantiated by MongoClusterGenerator()
var mongoClusterGenerator gopter.Gen

// MongoClusterGenerator returns a generator of MongoCluster instances for property testing.
func MongoClusterGenerator() gopter.Gen {
	if mongoClusterGenerator != nil {
		return mongoClusterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForMongoCluster(generators)
	mongoClusterGenerator = gen.Struct(reflect.TypeOf(MongoCluster{}), generators)

	return mongoClusterGenerator
}

// AddRelatedPropertyGeneratorsForMongoCluster is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMongoCluster(gens map[string]gopter.Gen) {
	gens["Spec"] = MongoCluster_SpecGenerator()
	gens["Status"] = MongoCluster_STATUSGenerator()
}

func Test_MongoClusterOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoClusterOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoClusterOperatorSpec, MongoClusterOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoClusterOperatorSpec runs a test to see if a specific instance of MongoClusterOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoClusterOperatorSpec(subject MongoClusterOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoClusterOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoClusterOperatorSpec instances for property testing - lazily instantiated by
// MongoClusterOperatorSpecGenerator()
var mongoClusterOperatorSpecGenerator gopter.Gen

// MongoClusterOperatorSpecGenerator returns a generator of MongoClusterOperatorSpec instances for property testing.
func MongoClusterOperatorSpecGenerator() gopter.Gen {
	if mongoClusterOperatorSpecGenerator != nil {
		return mongoClusterOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	mongoClusterOperatorSpecGenerator = gen.Struct(reflect.TypeOf(MongoClusterOperatorSpec{}), generators)

	return mongoClusterOperatorSpecGenerator
}

func Test_MongoClusterProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoClusterProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoClusterProperties, MongoClusterPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoClusterProperties runs a test to see if a specific instance of MongoClusterProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoClusterProperties(subject MongoClusterProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoClusterProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoClusterProperties instances for property testing - lazily instantiated by
// MongoClusterPropertiesGenerator()
var mongoClusterPropertiesGenerator gopter.Gen

// MongoClusterPropertiesGenerator returns a generator of MongoClusterProperties instances for property testing.
// We first initialize mongoClusterPropertiesGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MongoClusterPropertiesGenerator() gopter.Gen {
	if mongoClusterPropertiesGenerator != nil {
		return mongoClusterPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoClusterProperties(generators)
	mongoClusterPropertiesGenerator = gen.Struct(reflect.TypeOf(MongoClusterProperties{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoClusterProperties(generators)
	AddRelatedPropertyGeneratorsForMongoClusterProperties(generators)
	mongoClusterPropertiesGenerator = gen.Struct(reflect.TypeOf(MongoClusterProperties{}), generators)

	return mongoClusterPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForMongoClusterProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoClusterProperties(gens map[string]gopter.Gen) {
	gens["CreateMode"] = gen.PtrOf(gen.AlphaString())
	gens["PreviewFeatures"] = gen.SliceOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["ServerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMongoClusterProperties is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMongoClusterProperties(gens map[string]gopter.Gen) {
	gens["Administrator"] = gen.PtrOf(AdministratorPropertiesGenerator())
	gens["Compute"] = gen.PtrOf(ComputePropertiesGenerator())
	gens["HighAvailability"] = gen.PtrOf(HighAvailabilityPropertiesGenerator())
	gens["ReplicaParameters"] = gen.PtrOf(MongoClusterReplicaParametersGenerator())
	gens["RestoreParameters"] = gen.PtrOf(MongoClusterRestoreParametersGenerator())
	gens["Sharding"] = gen.PtrOf(ShardingPropertiesGenerator())
	gens["Storage"] = gen.PtrOf(StoragePropertiesGenerator())
}

func Test_MongoClusterProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoClusterProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoClusterProperties_STATUS, MongoClusterProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoClusterProperties_STATUS runs a test to see if a specific instance of MongoClusterProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoClusterProperties_STATUS(subject MongoClusterProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoClusterProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoClusterProperties_STATUS instances for property testing - lazily instantiated by
// MongoClusterProperties_STATUSGenerator()
var mongoClusterProperties_STATUSGenerator gopter.Gen

// MongoClusterProperties_STATUSGenerator returns a generator of MongoClusterProperties_STATUS instances for property testing.
// We first initialize mongoClusterProperties_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MongoClusterProperties_STATUSGenerator() gopter.Gen {
	if mongoClusterProperties_STATUSGenerator != nil {
		return mongoClusterProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoClusterProperties_STATUS(generators)
	mongoClusterProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(MongoClusterProperties_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoClusterProperties_STATUS(generators)
	AddRelatedPropertyGeneratorsForMongoClusterProperties_STATUS(generators)
	mongoClusterProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(MongoClusterProperties_STATUS{}), generators)

	return mongoClusterProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMongoClusterProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoClusterProperties_STATUS(gens map[string]gopter.Gen) {
	gens["ClusterStatus"] = gen.PtrOf(gen.AlphaString())
	gens["ConnectionString"] = gen.PtrOf(gen.AlphaString())
	gens["CreateMode"] = gen.PtrOf(gen.AlphaString())
	gens["InfrastructureVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PreviewFeatures"] = gen.SliceOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
	gens["ServerVersion"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMongoClusterProperties_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMongoClusterProperties_STATUS(gens map[string]gopter.Gen) {
	gens["Administrator"] = gen.PtrOf(AdministratorProperties_STATUSGenerator())
	gens["Backup"] = gen.PtrOf(BackupProperties_STATUSGenerator())
	gens["Compute"] = gen.PtrOf(ComputeProperties_STATUSGenerator())
	gens["HighAvailability"] = gen.PtrOf(HighAvailabilityProperties_STATUSGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_STATUSGenerator())
	gens["Replica"] = gen.PtrOf(ReplicationProperties_STATUSGenerator())
	gens["ReplicaParameters"] = gen.PtrOf(MongoClusterReplicaParameters_STATUSGenerator())
	gens["RestoreParameters"] = gen.PtrOf(MongoClusterRestoreParameters_STATUSGenerator())
	gens["Sharding"] = gen.PtrOf(ShardingProperties_STATUSGenerator())
	gens["Storage"] = gen.PtrOf(StorageProperties_STATUSGenerator())
}

func Test_MongoClusterReplicaParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoClusterReplicaParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoClusterReplicaParameters, MongoClusterReplicaParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoClusterReplicaParameters runs a test to see if a specific instance of MongoClusterReplicaParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoClusterReplicaParameters(subject MongoClusterReplicaParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoClusterReplicaParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoClusterReplicaParameters instances for property testing - lazily instantiated by
// MongoClusterReplicaParametersGenerator()
var mongoClusterReplicaParametersGenerator gopter.Gen

// MongoClusterReplicaParametersGenerator returns a generator of MongoClusterReplicaParameters instances for property testing.
func MongoClusterReplicaParametersGenerator() gopter.Gen {
	if mongoClusterReplicaParametersGenerator != nil {
		return mongoClusterReplicaParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoClusterReplicaParameters(generators)
	mongoClusterReplicaParametersGenerator = gen.Struct(reflect.TypeOf(MongoClusterReplicaParameters{}), generators)

	return mongoClusterReplicaParametersGenerator
}

// AddIndependentPropertyGeneratorsForMongoClusterReplicaParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoClusterReplicaParameters(gens map[string]gopter.Gen) {
	gens["SourceLocation"] = gen.PtrOf(gen.AlphaString())
}

func Test_MongoClusterReplicaParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoClusterReplicaParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoClusterReplicaParameters_STATUS, MongoClusterReplicaParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoClusterReplicaParameters_STATUS runs a test to see if a specific instance of MongoClusterReplicaParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoClusterReplicaParameters_STATUS(subject MongoClusterReplicaParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoClusterReplicaParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoClusterReplicaParameters_STATUS instances for property testing - lazily instantiated by
// MongoClusterReplicaParameters_STATUSGenerator()
var mongoClusterReplicaParameters_STATUSGenerator gopter.Gen

// MongoClusterReplicaParameters_STATUSGenerator returns a generator of MongoClusterReplicaParameters_STATUS instances for property testing.
func MongoClusterReplicaParameters_STATUSGenerator() gopter.Gen {
	if mongoClusterReplicaParameters_STATUSGenerator != nil {
		return mongoClusterReplicaParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoClusterReplicaParameters_STATUS(generators)
	mongoClusterReplicaParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(MongoClusterReplicaParameters_STATUS{}), generators)

	return mongoClusterReplicaParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMongoClusterReplicaParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoClusterReplicaParameters_STATUS(gens map[string]gopter.Gen) {
	gens["SourceLocation"] = gen.PtrOf(gen.AlphaString())
	gens["SourceResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_MongoClusterRestoreParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoClusterRestoreParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoClusterRestoreParameters, MongoClusterRestoreParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoClusterRestoreParameters runs a test to see if a specific instance of MongoClusterRestoreParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoClusterRestoreParameters(subject MongoClusterRestoreParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoClusterRestoreParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoClusterRestoreParameters instances for property testing - lazily instantiated by
// MongoClusterRestoreParametersGenerator()
var mongoClusterRestoreParametersGenerator gopter.Gen

// MongoClusterRestoreParametersGenerator returns a generator of MongoClusterRestoreParameters instances for property testing.
func MongoClusterRestoreParametersGenerator() gopter.Gen {
	if mongoClusterRestoreParametersGenerator != nil {
		return mongoClusterRestoreParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoClusterRestoreParameters(generators)
	mongoClusterRestoreParametersGenerator = gen.Struct(reflect.TypeOf(MongoClusterRestoreParameters{}), generators)

	return mongoClusterRestoreParametersGenerator
}

// AddIndependentPropertyGeneratorsForMongoClusterRestoreParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoClusterRestoreParameters(gens map[string]gopter.Gen) {
	gens["PointInTimeUTC"] = gen.PtrOf(gen.AlphaString())
}

func Test_MongoClusterRestoreParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoClusterRestoreParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoClusterRestoreParameters_STATUS, MongoClusterRestoreParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoClusterRestoreParameters_STATUS runs a test to see if a specific instance of MongoClusterRestoreParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoClusterRestoreParameters_STATUS(subject MongoClusterRestoreParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoClusterRestoreParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoClusterRestoreParameters_STATUS instances for property testing - lazily instantiated by
// MongoClusterRestoreParameters_STATUSGenerator()
var mongoClusterRestoreParameters_STATUSGenerator gopter.Gen

// MongoClusterRestoreParameters_STATUSGenerator returns a generator of MongoClusterRestoreParameters_STATUS instances for property testing.
func MongoClusterRestoreParameters_STATUSGenerator() gopter.Gen {
	if mongoClusterRestoreParameters_STATUSGenerator != nil {
		return mongoClusterRestoreParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoClusterRestoreParameters_STATUS(generators)
	mongoClusterRestoreParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(MongoClusterRestoreParameters_STATUS{}), generators)

	return mongoClusterRestoreParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMongoClusterRestoreParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoClusterRestoreParameters_STATUS(gens map[string]gopter.Gen) {
	gens["PointInTimeUTC"] = gen.PtrOf(gen.AlphaString())
	gens["SourceResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_MongoCluster_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoCluster_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoCluster_STATUS, MongoCluster_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoCluster_STATUS runs a test to see if a specific instance of MongoCluster_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoCluster_STATUS(subject MongoCluster_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoCluster_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoCluster_STATUS instances for property testing - lazily instantiated by
// MongoCluster_STATUSGenerator()
var mongoCluster_STATUSGenerator gopter.Gen

// MongoCluster_STATUSGenerator returns a generator of MongoCluster_STATUS instances for property testing.
// We first initialize mongoCluster_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MongoCluster_STATUSGenerator() gopter.Gen {
	if mongoCluster_STATUSGenerator != nil {
		return mongoCluster_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoCluster_STATUS(generators)
	mongoCluster_STATUSGenerator = gen.Struct(reflect.TypeOf(MongoCluster_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoCluster_STATUS(generators)
	AddRelatedPropertyGeneratorsForMongoCluster_STATUS(generators)
	mongoCluster_STATUSGenerator = gen.Struct(reflect.TypeOf(MongoCluster_STATUS{}), generators)

	return mongoCluster_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMongoCluster_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoCluster_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMongoCluster_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMongoCluster_STATUS(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(MongoClusterProperties_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_MongoCluster_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MongoCluster_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMongoCluster_Spec, MongoCluster_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMongoCluster_Spec runs a test to see if a specific instance of MongoCluster_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForMongoCluster_Spec(subject MongoCluster_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MongoCluster_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MongoCluster_Spec instances for property testing - lazily instantiated by MongoCluster_SpecGenerator()
var mongoCluster_SpecGenerator gopter.Gen

// MongoCluster_SpecGenerator returns a generator of MongoCluster_Spec instances for property testing.
// We first initialize mongoCluster_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MongoCluster_SpecGenerator() gopter.Gen {
	if mongoCluster_SpecGenerator != nil {
		return mongoCluster_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoCluster_Spec(generators)
	mongoCluster_SpecGenerator = gen.Struct(reflect.TypeOf(MongoCluster_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMongoCluster_Spec(generators)
	AddRelatedPropertyGeneratorsForMongoCluster_Spec(generators)
	mongoCluster_SpecGenerator = gen.Struct(reflect.TypeOf(MongoCluster_Spec{}), generators)

	return mongoCluster_SpecGenerator
}

// AddIndependentPropertyGeneratorsForMongoCluster_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMongoCluster_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMongoCluster_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMongoCluster_Spec(gens map[string]gopter.Gen) {
	gens["OperatorSpec"] = gen.PtrOf(MongoClusterOperatorSpecGenerator())
	gens["Properties"] = gen.PtrOf(MongoClusterPropertiesGenerator())
}

func Test_PrivateEndpointConnection_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PrivateEndpointConnection_STATUS to PrivateEndpointConnection_STATUS via AssignProperties_To_PrivateEndpointConnection_STATUS & AssignProperties_From_PrivateEndpointConnection_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS, PrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS tests if a specific instance of PrivateEndpointConnection_STATUS can be assigned to storage and back losslessly
func RunPropertyAssignmentTestForPrivateEndpointConnection_STATUS(subject PrivateEndpointConnection_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other storage.PrivateEndpointConnection_STATUS
	err := copied.AssignProperties_To_PrivateEndpointConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PrivateEndpointConnection_STATUS
	err = actual.AssignProperties_From_PrivateEndpointConnection_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PrivateEndpointConnection_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_STATUS, PrivateEndpointConnection_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_STATUS runs a test to see if a specific instance of PrivateEndpointConnection_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_STATUS(subject PrivateEndpointConnection_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS instances for property testing - lazily instantiated by
// PrivateEndpointConnection_STATUSGenerator()
var privateEndpointConnection_STATUSGenerator gopter.Gen

// PrivateEndpointConnection_STATUSGenerator returns a generator of PrivateEndpointConnection_STATUS instances for property testing.
func PrivateEndpointConnection_STATUSGenerator() gopter.Gen {
	if privateEndpointConnection_STATUSGenerator != nil {
		return privateEndpointConnection_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(generators)
	privateEndpointConnection_STATUSGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS{}), generators)

	return privateEndpointConnection_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ReplicationProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ReplicationProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForReplicationProperties_STATUS, ReplicationProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForReplicationProperties_STATUS runs a test to see if a specific instance of ReplicationProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForReplicationProperties_STATUS(subject ReplicationProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ReplicationProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ReplicationProperties_STATUS instances for property testing - lazily instantiated by
// ReplicationProperties_STATUSGenerator()
var replicationProperties_STATUSGenerator gopter.Gen

// ReplicationProperties_STATUSGenerator returns a generator of ReplicationProperties_STATUS instances for property testing.
func ReplicationProperties_STATUSGenerator() gopter.Gen {
	if replicationProperties_STATUSGenerator != nil {
		return replicationProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForReplicationProperties_STATUS(generators)
	replicationProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ReplicationProperties_STATUS{}), generators)

	return replicationProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForReplicationProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForReplicationProperties_STATUS(gens map[string]gopter.Gen) {
	gens["ReplicationState"] = gen.PtrOf(gen.AlphaString())
	gens["Role"] = gen.PtrOf(gen.AlphaString())
	gens["SourceResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ShardingProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ShardingProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForShardingProperties, ShardingPropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForShardingProperties runs a test to see if a specific instance of ShardingProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForShardingProperties(subject ShardingProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ShardingProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ShardingProperties instances for property testing - lazily instantiated by ShardingPropertiesGenerator()
var shardingPropertiesGenerator gopter.Gen

// ShardingPropertiesGenerator returns a generator of ShardingProperties instances for property testing.
func ShardingPropertiesGenerator() gopter.Gen {
	if shardingPropertiesGenerator != nil {
		return shardingPropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForShardingProperties(generators)
	shardingPropertiesGenerator = gen.Struct(reflect.TypeOf(ShardingProperties{}), generators)

	return shardingPropertiesGenerator
}

// AddIndependentPropertyGeneratorsForShardingProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForShardingProperties(gens map[string]gopter.Gen) {
	gens["ShardCount"] = gen.PtrOf(gen.Int())
}

func Test_ShardingProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ShardingProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForShardingProperties_STATUS, ShardingProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForShardingProperties_STATUS runs a test to see if a specific instance of ShardingProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForShardingProperties_STATUS(subject ShardingProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ShardingProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ShardingProperties_STATUS instances for property testing - lazily instantiated by
// ShardingProperties_STATUSGenerator()
var shardingProperties_STATUSGenerator gopter.Gen

// ShardingProperties_STATUSGenerator returns a generator of ShardingProperties_STATUS instances for property testing.
func ShardingProperties_STATUSGenerator() gopter.Gen {
	if shardingProperties_STATUSGenerator != nil {
		return shardingProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForShardingProperties_STATUS(generators)
	shardingProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(ShardingProperties_STATUS{}), generators)

	return shardingProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForShardingProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForShardingProperties_STATUS(gens map[string]gopter.Gen) {
	gens["ShardCount"] = gen.PtrOf(gen.Int())
}

func Test_StorageProperties_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProperties via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProperties, StoragePropertiesGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProperties runs a test to see if a specific instance of StorageProperties round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProperties(subject StorageProperties) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProperties
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProperties instances for property testing - lazily instantiated by StoragePropertiesGenerator()
var storagePropertiesGenerator gopter.Gen

// StoragePropertiesGenerator returns a generator of StorageProperties instances for property testing.
func StoragePropertiesGenerator() gopter.Gen {
	if storagePropertiesGenerator != nil {
		return storagePropertiesGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageProperties(generators)
	storagePropertiesGenerator = gen.Struct(reflect.TypeOf(StorageProperties{}), generators)

	return storagePropertiesGenerator
}

// AddIndependentPropertyGeneratorsForStorageProperties is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageProperties(gens map[string]gopter.Gen) {
	gens["SizeGb"] = gen.PtrOf(gen.Int())
}

func Test_StorageProperties_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of StorageProperties_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageProperties_STATUS, StorageProperties_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageProperties_STATUS runs a test to see if a specific instance of StorageProperties_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageProperties_STATUS(subject StorageProperties_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual StorageProperties_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of StorageProperties_STATUS instances for property testing - lazily instantiated by
// StorageProperties_STATUSGenerator()
var storageProperties_STATUSGenerator gopter.Gen

// StorageProperties_STATUSGenerator returns a generator of StorageProperties_STATUS instances for property testing.
func StorageProperties_STATUSGenerator() gopter.Gen {
	if storageProperties_STATUSGenerator != nil {
		return storageProperties_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageProperties_STATUS(generators)
	storageProperties_STATUSGenerator = gen.Struct(reflect.TypeOf(StorageProperties_STATUS{}), generators)

	return storageProperties_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForStorageProperties_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageProperties_STATUS(gens map[string]gopter.Gen) {
	gens["SizeGb"] = gen.PtrOf(gen.Int())
}
