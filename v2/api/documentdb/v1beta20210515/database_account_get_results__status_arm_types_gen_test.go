// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210515

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DatabaseAccountGetResults_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountGetResults_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountGetResultsStatusARM, DatabaseAccountGetResultsStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountGetResultsStatusARM runs a test to see if a specific instance of DatabaseAccountGetResults_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountGetResultsStatusARM(subject DatabaseAccountGetResults_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountGetResults_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountGetResults_StatusARM instances for property testing - lazily instantiated by
// DatabaseAccountGetResultsStatusARMGenerator()
var databaseAccountGetResultsStatusARMGenerator gopter.Gen

// DatabaseAccountGetResultsStatusARMGenerator returns a generator of DatabaseAccountGetResults_StatusARM instances for property testing.
// We first initialize databaseAccountGetResultsStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountGetResultsStatusARMGenerator() gopter.Gen {
	if databaseAccountGetResultsStatusARMGenerator != nil {
		return databaseAccountGetResultsStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountGetResultsStatusARM(generators)
	databaseAccountGetResultsStatusARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountGetResults_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountGetResultsStatusARM(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountGetResultsStatusARM(generators)
	databaseAccountGetResultsStatusARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountGetResults_StatusARM{}), generators)

	return databaseAccountGetResultsStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountGetResultsStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountGetResultsStatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountGetResultsStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountGetResultsStatusARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentityStatusARMGenerator())
	gens["Properties"] = gen.PtrOf(DatabaseAccountGetPropertiesStatusARMGenerator())
}

func Test_DatabaseAccountGetProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountGetProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountGetPropertiesStatusARM, DatabaseAccountGetPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountGetPropertiesStatusARM runs a test to see if a specific instance of DatabaseAccountGetProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountGetPropertiesStatusARM(subject DatabaseAccountGetProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountGetProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountGetProperties_StatusARM instances for property testing - lazily instantiated by
// DatabaseAccountGetPropertiesStatusARMGenerator()
var databaseAccountGetPropertiesStatusARMGenerator gopter.Gen

// DatabaseAccountGetPropertiesStatusARMGenerator returns a generator of DatabaseAccountGetProperties_StatusARM instances for property testing.
// We first initialize databaseAccountGetPropertiesStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountGetPropertiesStatusARMGenerator() gopter.Gen {
	if databaseAccountGetPropertiesStatusARMGenerator != nil {
		return databaseAccountGetPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountGetPropertiesStatusARM(generators)
	databaseAccountGetPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountGetProperties_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountGetPropertiesStatusARM(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountGetPropertiesStatusARM(generators)
	databaseAccountGetPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountGetProperties_StatusARM{}), generators)

	return databaseAccountGetPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountGetPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountGetPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["ConnectorOffer"] = gen.PtrOf(gen.AlphaString())
	gens["DatabaseAccountOfferType"] = gen.PtrOf(gen.AlphaString())
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["DocumentEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountGetPropertiesStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountGetPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfigurationStatusARMGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiPropertiesStatusARMGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicyStatusARMGenerator())
	gens["Capabilities"] = gen.SliceOf(CapabilityStatusARMGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicyStatusARMGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicyStatusARMGenerator())
	gens["FailoverPolicies"] = gen.SliceOf(FailoverPolicyStatusARMGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRangeStatusARMGenerator())
	gens["Locations"] = gen.SliceOf(LocationStatusARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator())
	gens["ReadLocations"] = gen.SliceOf(LocationStatusARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRuleStatusARMGenerator())
	gens["WriteLocations"] = gen.SliceOf(LocationStatusARMGenerator())
}

func Test_ManagedServiceIdentity_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentityStatusARM, ManagedServiceIdentityStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentityStatusARM runs a test to see if a specific instance of ManagedServiceIdentity_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentityStatusARM(subject ManagedServiceIdentity_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_StatusARM instances for property testing - lazily instantiated by
// ManagedServiceIdentityStatusARMGenerator()
var managedServiceIdentityStatusARMGenerator gopter.Gen

// ManagedServiceIdentityStatusARMGenerator returns a generator of ManagedServiceIdentity_StatusARM instances for property testing.
// We first initialize managedServiceIdentityStatusARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentityStatusARMGenerator() gopter.Gen {
	if managedServiceIdentityStatusARMGenerator != nil {
		return managedServiceIdentityStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentityStatusARM(generators)
	managedServiceIdentityStatusARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_StatusARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentityStatusARM(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentityStatusARM(generators)
	managedServiceIdentityStatusARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_StatusARM{}), generators)

	return managedServiceIdentityStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentityStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentityStatusARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentityStatusARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentityStatusARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), ManagedServiceIdentityStatusUserAssignedIdentitiesARMGenerator())
}

func Test_AnalyticalStorageConfiguration_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfigurationStatusARM, AnalyticalStorageConfigurationStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfigurationStatusARM runs a test to see if a specific instance of AnalyticalStorageConfiguration_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfigurationStatusARM(subject AnalyticalStorageConfiguration_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration_StatusARM instances for property testing - lazily instantiated by
// AnalyticalStorageConfigurationStatusARMGenerator()
var analyticalStorageConfigurationStatusARMGenerator gopter.Gen

// AnalyticalStorageConfigurationStatusARMGenerator returns a generator of AnalyticalStorageConfiguration_StatusARM instances for property testing.
func AnalyticalStorageConfigurationStatusARMGenerator() gopter.Gen {
	if analyticalStorageConfigurationStatusARMGenerator != nil {
		return analyticalStorageConfigurationStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationStatusARM(generators)
	analyticalStorageConfigurationStatusARMGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration_StatusARM{}), generators)

	return analyticalStorageConfigurationStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfigurationStatusARM(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.AlphaString())
}

func Test_ApiProperties_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiPropertiesStatusARM, ApiPropertiesStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiPropertiesStatusARM runs a test to see if a specific instance of ApiProperties_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiPropertiesStatusARM(subject ApiProperties_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_StatusARM instances for property testing - lazily instantiated by
// ApiPropertiesStatusARMGenerator()
var apiPropertiesStatusARMGenerator gopter.Gen

// ApiPropertiesStatusARMGenerator returns a generator of ApiProperties_StatusARM instances for property testing.
func ApiPropertiesStatusARMGenerator() gopter.Gen {
	if apiPropertiesStatusARMGenerator != nil {
		return apiPropertiesStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiPropertiesStatusARM(generators)
	apiPropertiesStatusARMGenerator = gen.Struct(reflect.TypeOf(ApiProperties_StatusARM{}), generators)

	return apiPropertiesStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForApiPropertiesStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiPropertiesStatusARM(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.AlphaString())
}

func Test_BackupPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicyStatusARM, BackupPolicyStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicyStatusARM runs a test to see if a specific instance of BackupPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicyStatusARM(subject BackupPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_StatusARM instances for property testing - lazily instantiated by
// BackupPolicyStatusARMGenerator()
var backupPolicyStatusARMGenerator gopter.Gen

// BackupPolicyStatusARMGenerator returns a generator of BackupPolicy_StatusARM instances for property testing.
func BackupPolicyStatusARMGenerator() gopter.Gen {
	if backupPolicyStatusARMGenerator != nil {
		return backupPolicyStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicyStatusARM(generators)
	backupPolicyStatusARMGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_StatusARM{}), generators)

	return backupPolicyStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicyStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicyStatusARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_Capability_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapabilityStatusARM, CapabilityStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapabilityStatusARM runs a test to see if a specific instance of Capability_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCapabilityStatusARM(subject Capability_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability_StatusARM instances for property testing - lazily instantiated by
// CapabilityStatusARMGenerator()
var capabilityStatusARMGenerator gopter.Gen

// CapabilityStatusARMGenerator returns a generator of Capability_StatusARM instances for property testing.
func CapabilityStatusARMGenerator() gopter.Gen {
	if capabilityStatusARMGenerator != nil {
		return capabilityStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapabilityStatusARM(generators)
	capabilityStatusARMGenerator = gen.Struct(reflect.TypeOf(Capability_StatusARM{}), generators)

	return capabilityStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForCapabilityStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapabilityStatusARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ConsistencyPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicyStatusARM, ConsistencyPolicyStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicyStatusARM runs a test to see if a specific instance of ConsistencyPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicyStatusARM(subject ConsistencyPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy_StatusARM instances for property testing - lazily instantiated by
// ConsistencyPolicyStatusARMGenerator()
var consistencyPolicyStatusARMGenerator gopter.Gen

// ConsistencyPolicyStatusARMGenerator returns a generator of ConsistencyPolicy_StatusARM instances for property testing.
func ConsistencyPolicyStatusARMGenerator() gopter.Gen {
	if consistencyPolicyStatusARMGenerator != nil {
		return consistencyPolicyStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicyStatusARM(generators)
	consistencyPolicyStatusARMGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy_StatusARM{}), generators)

	return consistencyPolicyStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicyStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicyStatusARM(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.PtrOf(gen.AlphaString())
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicyStatusARM, CorsPolicyStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicyStatusARM runs a test to see if a specific instance of CorsPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicyStatusARM(subject CorsPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_StatusARM instances for property testing - lazily instantiated by
// CorsPolicyStatusARMGenerator()
var corsPolicyStatusARMGenerator gopter.Gen

// CorsPolicyStatusARMGenerator returns a generator of CorsPolicy_StatusARM instances for property testing.
func CorsPolicyStatusARMGenerator() gopter.Gen {
	if corsPolicyStatusARMGenerator != nil {
		return corsPolicyStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicyStatusARM(generators)
	corsPolicyStatusARMGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_StatusARM{}), generators)

	return corsPolicyStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicyStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicyStatusARM(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.PtrOf(gen.AlphaString())
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_FailoverPolicy_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FailoverPolicy_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFailoverPolicyStatusARM, FailoverPolicyStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFailoverPolicyStatusARM runs a test to see if a specific instance of FailoverPolicy_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFailoverPolicyStatusARM(subject FailoverPolicy_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FailoverPolicy_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FailoverPolicy_StatusARM instances for property testing - lazily instantiated by
// FailoverPolicyStatusARMGenerator()
var failoverPolicyStatusARMGenerator gopter.Gen

// FailoverPolicyStatusARMGenerator returns a generator of FailoverPolicy_StatusARM instances for property testing.
func FailoverPolicyStatusARMGenerator() gopter.Gen {
	if failoverPolicyStatusARMGenerator != nil {
		return failoverPolicyStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFailoverPolicyStatusARM(generators)
	failoverPolicyStatusARMGenerator = gen.Struct(reflect.TypeOf(FailoverPolicy_StatusARM{}), generators)

	return failoverPolicyStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForFailoverPolicyStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFailoverPolicyStatusARM(gens map[string]gopter.Gen) {
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpAddressOrRange_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRangeStatusARM, IpAddressOrRangeStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRangeStatusARM runs a test to see if a specific instance of IpAddressOrRange_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRangeStatusARM(subject IpAddressOrRange_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange_StatusARM instances for property testing - lazily instantiated by
// IpAddressOrRangeStatusARMGenerator()
var ipAddressOrRangeStatusARMGenerator gopter.Gen

// IpAddressOrRangeStatusARMGenerator returns a generator of IpAddressOrRange_StatusARM instances for property testing.
func IpAddressOrRangeStatusARMGenerator() gopter.Gen {
	if ipAddressOrRangeStatusARMGenerator != nil {
		return ipAddressOrRangeStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRangeStatusARM(generators)
	ipAddressOrRangeStatusARMGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange_StatusARM{}), generators)

	return ipAddressOrRangeStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRangeStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRangeStatusARM(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocationStatusARM, LocationStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocationStatusARM runs a test to see if a specific instance of Location_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLocationStatusARM(subject Location_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location_StatusARM instances for property testing - lazily instantiated by LocationStatusARMGenerator()
var locationStatusARMGenerator gopter.Gen

// LocationStatusARMGenerator returns a generator of Location_StatusARM instances for property testing.
func LocationStatusARMGenerator() gopter.Gen {
	if locationStatusARMGenerator != nil {
		return locationStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocationStatusARM(generators)
	locationStatusARMGenerator = gen.Struct(reflect.TypeOf(Location_StatusARM{}), generators)

	return locationStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForLocationStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocationStatusARM(gens map[string]gopter.Gen) {
	gens["DocumentEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_Status_UserAssignedIdentitiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_Status_UserAssignedIdentitiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentityStatusUserAssignedIdentitiesARM, ManagedServiceIdentityStatusUserAssignedIdentitiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentityStatusUserAssignedIdentitiesARM runs a test to see if a specific instance of ManagedServiceIdentity_Status_UserAssignedIdentitiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentityStatusUserAssignedIdentitiesARM(subject ManagedServiceIdentity_Status_UserAssignedIdentitiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_Status_UserAssignedIdentitiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_Status_UserAssignedIdentitiesARM instances for property testing - lazily
// instantiated by ManagedServiceIdentityStatusUserAssignedIdentitiesARMGenerator()
var managedServiceIdentityStatusUserAssignedIdentitiesARMGenerator gopter.Gen

// ManagedServiceIdentityStatusUserAssignedIdentitiesARMGenerator returns a generator of ManagedServiceIdentity_Status_UserAssignedIdentitiesARM instances for property testing.
func ManagedServiceIdentityStatusUserAssignedIdentitiesARMGenerator() gopter.Gen {
	if managedServiceIdentityStatusUserAssignedIdentitiesARMGenerator != nil {
		return managedServiceIdentityStatusUserAssignedIdentitiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentityStatusUserAssignedIdentitiesARM(generators)
	managedServiceIdentityStatusUserAssignedIdentitiesARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_Status_UserAssignedIdentitiesARM{}), generators)

	return managedServiceIdentityStatusUserAssignedIdentitiesARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentityStatusUserAssignedIdentitiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentityStatusUserAssignedIdentitiesARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointConnection_Status_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_Status_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnectionStatusSubResourceEmbeddedARM, PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnectionStatusSubResourceEmbeddedARM runs a test to see if a specific instance of PrivateEndpointConnection_Status_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnectionStatusSubResourceEmbeddedARM(subject PrivateEndpointConnection_Status_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_Status_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_Status_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator()
var privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator gopter.Gen

// PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator returns a generator of PrivateEndpointConnection_Status_SubResourceEmbeddedARM instances for property testing.
func PrivateEndpointConnectionStatusSubResourceEmbeddedARMGenerator() gopter.Gen {
	if privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator != nil {
		return privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusSubResourceEmbeddedARM(generators)
	privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_Status_SubResourceEmbeddedARM{}), generators)

	return privateEndpointConnectionStatusSubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusSubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnectionStatusSubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_StatusARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_StatusARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRuleStatusARM, VirtualNetworkRuleStatusARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRuleStatusARM runs a test to see if a specific instance of VirtualNetworkRule_StatusARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRuleStatusARM(subject VirtualNetworkRule_StatusARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_StatusARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_StatusARM instances for property testing - lazily instantiated by
// VirtualNetworkRuleStatusARMGenerator()
var virtualNetworkRuleStatusARMGenerator gopter.Gen

// VirtualNetworkRuleStatusARMGenerator returns a generator of VirtualNetworkRule_StatusARM instances for property testing.
func VirtualNetworkRuleStatusARMGenerator() gopter.Gen {
	if virtualNetworkRuleStatusARMGenerator != nil {
		return virtualNetworkRuleStatusARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatusARM(generators)
	virtualNetworkRuleStatusARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_StatusARM{}), generators)

	return virtualNetworkRuleStatusARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatusARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRuleStatusARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}
