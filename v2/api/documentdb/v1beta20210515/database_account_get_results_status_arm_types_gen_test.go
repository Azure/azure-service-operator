// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210515

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_DatabaseAccountGetResults_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountGetResults_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountGetResults_STATUSARM, DatabaseAccountGetResults_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountGetResults_STATUSARM runs a test to see if a specific instance of DatabaseAccountGetResults_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountGetResults_STATUSARM(subject DatabaseAccountGetResults_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountGetResults_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountGetResults_STATUSARM instances for property testing - lazily instantiated by
// DatabaseAccountGetResults_STATUSARMGenerator()
var databaseAccountGetResults_STATUSARMGenerator gopter.Gen

// DatabaseAccountGetResults_STATUSARMGenerator returns a generator of DatabaseAccountGetResults_STATUSARM instances for property testing.
// We first initialize databaseAccountGetResults_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountGetResults_STATUSARMGenerator() gopter.Gen {
	if databaseAccountGetResults_STATUSARMGenerator != nil {
		return databaseAccountGetResults_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountGetResults_STATUSARM(generators)
	databaseAccountGetResults_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountGetResults_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountGetResults_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountGetResults_STATUSARM(generators)
	databaseAccountGetResults_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountGetResults_STATUSARM{}), generators)

	return databaseAccountGetResults_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountGetResults_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountGetResults_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(DatabaseAccountGetResults_STATUS_Kind_GlobalDocumentDB, DatabaseAccountGetResults_STATUS_Kind_MongoDB, DatabaseAccountGetResults_STATUS_Kind_Parse))
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDatabaseAccountGetResults_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountGetResults_STATUSARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(ManagedServiceIdentity_STATUSARMGenerator())
	gens["Properties"] = gen.PtrOf(DatabaseAccountGetProperties_STATUSARMGenerator())
}

func Test_DatabaseAccountGetProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DatabaseAccountGetProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDatabaseAccountGetProperties_STATUSARM, DatabaseAccountGetProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDatabaseAccountGetProperties_STATUSARM runs a test to see if a specific instance of DatabaseAccountGetProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDatabaseAccountGetProperties_STATUSARM(subject DatabaseAccountGetProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DatabaseAccountGetProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DatabaseAccountGetProperties_STATUSARM instances for property testing - lazily instantiated by
// DatabaseAccountGetProperties_STATUSARMGenerator()
var databaseAccountGetProperties_STATUSARMGenerator gopter.Gen

// DatabaseAccountGetProperties_STATUSARMGenerator returns a generator of DatabaseAccountGetProperties_STATUSARM instances for property testing.
// We first initialize databaseAccountGetProperties_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DatabaseAccountGetProperties_STATUSARMGenerator() gopter.Gen {
	if databaseAccountGetProperties_STATUSARMGenerator != nil {
		return databaseAccountGetProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountGetProperties_STATUSARM(generators)
	databaseAccountGetProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountGetProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDatabaseAccountGetProperties_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForDatabaseAccountGetProperties_STATUSARM(generators)
	databaseAccountGetProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(DatabaseAccountGetProperties_STATUSARM{}), generators)

	return databaseAccountGetProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForDatabaseAccountGetProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDatabaseAccountGetProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["ConnectorOffer"] = gen.PtrOf(gen.OneConstOf(ConnectorOffer_STATUS_Small))
	gens["DatabaseAccountOfferType"] = gen.PtrOf(gen.OneConstOf(DatabaseAccountOfferType_STATUS_Standard))
	gens["DefaultIdentity"] = gen.PtrOf(gen.AlphaString())
	gens["DisableKeyBasedMetadataWriteAccess"] = gen.PtrOf(gen.Bool())
	gens["DocumentEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["EnableAnalyticalStorage"] = gen.PtrOf(gen.Bool())
	gens["EnableAutomaticFailover"] = gen.PtrOf(gen.Bool())
	gens["EnableCassandraConnector"] = gen.PtrOf(gen.Bool())
	gens["EnableFreeTier"] = gen.PtrOf(gen.Bool())
	gens["EnableMultipleWriteLocations"] = gen.PtrOf(gen.Bool())
	gens["IsVirtualNetworkFilterEnabled"] = gen.PtrOf(gen.Bool())
	gens["KeyVaultKeyUri"] = gen.PtrOf(gen.AlphaString())
	gens["NetworkAclBypass"] = gen.PtrOf(gen.OneConstOf(NetworkAclBypass_STATUS_AzureServices, NetworkAclBypass_STATUS_None))
	gens["NetworkAclBypassResourceIds"] = gen.SliceOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(PublicNetworkAccess_STATUS_Disabled, PublicNetworkAccess_STATUS_Enabled))
}

// AddRelatedPropertyGeneratorsForDatabaseAccountGetProperties_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDatabaseAccountGetProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageConfiguration"] = gen.PtrOf(AnalyticalStorageConfiguration_STATUSARMGenerator())
	gens["ApiProperties"] = gen.PtrOf(ApiProperties_STATUSARMGenerator())
	gens["BackupPolicy"] = gen.PtrOf(BackupPolicy_STATUSARMGenerator())
	gens["Capabilities"] = gen.SliceOf(Capability_STATUSARMGenerator())
	gens["ConsistencyPolicy"] = gen.PtrOf(ConsistencyPolicy_STATUSARMGenerator())
	gens["Cors"] = gen.SliceOf(CorsPolicy_STATUSARMGenerator())
	gens["FailoverPolicies"] = gen.SliceOf(FailoverPolicy_STATUSARMGenerator())
	gens["IpRules"] = gen.SliceOf(IpAddressOrRange_STATUSARMGenerator())
	gens["Locations"] = gen.SliceOf(Location_STATUSARMGenerator())
	gens["PrivateEndpointConnections"] = gen.SliceOf(PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator())
	gens["ReadLocations"] = gen.SliceOf(Location_STATUSARMGenerator())
	gens["VirtualNetworkRules"] = gen.SliceOf(VirtualNetworkRule_STATUSARMGenerator())
	gens["WriteLocations"] = gen.SliceOf(Location_STATUSARMGenerator())
}

func Test_ManagedServiceIdentity_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_STATUSARM, ManagedServiceIdentity_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_STATUSARM runs a test to see if a specific instance of ManagedServiceIdentity_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_STATUSARM(subject ManagedServiceIdentity_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_STATUSARM instances for property testing - lazily instantiated by
// ManagedServiceIdentity_STATUSARMGenerator()
var managedServiceIdentity_STATUSARMGenerator gopter.Gen

// ManagedServiceIdentity_STATUSARMGenerator returns a generator of ManagedServiceIdentity_STATUSARM instances for property testing.
// We first initialize managedServiceIdentity_STATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedServiceIdentity_STATUSARMGenerator() gopter.Gen {
	if managedServiceIdentity_STATUSARMGenerator != nil {
		return managedServiceIdentity_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUSARM(generators)
	managedServiceIdentity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUSARM(generators)
	AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUSARM(generators)
	managedServiceIdentity_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUSARM{}), generators)

	return managedServiceIdentity_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
	gens["TenantId"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(
		ManagedServiceIdentity_STATUS_Type_None,
		ManagedServiceIdentity_STATUS_Type_SystemAssigned,
		ManagedServiceIdentity_STATUS_Type_SystemAssignedUserAssigned,
		ManagedServiceIdentity_STATUS_Type_UserAssigned))
}

// AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedServiceIdentity_STATUSARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.MapOf(gen.AlphaString(), ManagedServiceIdentity_STATUS_UserAssignedIdentitiesARMGenerator())
}

func Test_AnalyticalStorageConfiguration_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AnalyticalStorageConfiguration_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAnalyticalStorageConfiguration_STATUSARM, AnalyticalStorageConfiguration_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAnalyticalStorageConfiguration_STATUSARM runs a test to see if a specific instance of AnalyticalStorageConfiguration_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForAnalyticalStorageConfiguration_STATUSARM(subject AnalyticalStorageConfiguration_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AnalyticalStorageConfiguration_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AnalyticalStorageConfiguration_STATUSARM instances for property testing - lazily instantiated by
// AnalyticalStorageConfiguration_STATUSARMGenerator()
var analyticalStorageConfiguration_STATUSARMGenerator gopter.Gen

// AnalyticalStorageConfiguration_STATUSARMGenerator returns a generator of AnalyticalStorageConfiguration_STATUSARM instances for property testing.
func AnalyticalStorageConfiguration_STATUSARMGenerator() gopter.Gen {
	if analyticalStorageConfiguration_STATUSARMGenerator != nil {
		return analyticalStorageConfiguration_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_STATUSARM(generators)
	analyticalStorageConfiguration_STATUSARMGenerator = gen.Struct(reflect.TypeOf(AnalyticalStorageConfiguration_STATUSARM{}), generators)

	return analyticalStorageConfiguration_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAnalyticalStorageConfiguration_STATUSARM(gens map[string]gopter.Gen) {
	gens["SchemaType"] = gen.PtrOf(gen.OneConstOf(AnalyticalStorageSchemaType_STATUS_FullFidelity, AnalyticalStorageSchemaType_STATUS_WellDefined))
}

func Test_ApiProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ApiProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForApiProperties_STATUSARM, ApiProperties_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForApiProperties_STATUSARM runs a test to see if a specific instance of ApiProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForApiProperties_STATUSARM(subject ApiProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ApiProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ApiProperties_STATUSARM instances for property testing - lazily instantiated by
// ApiProperties_STATUSARMGenerator()
var apiProperties_STATUSARMGenerator gopter.Gen

// ApiProperties_STATUSARMGenerator returns a generator of ApiProperties_STATUSARM instances for property testing.
func ApiProperties_STATUSARMGenerator() gopter.Gen {
	if apiProperties_STATUSARMGenerator != nil {
		return apiProperties_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForApiProperties_STATUSARM(generators)
	apiProperties_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ApiProperties_STATUSARM{}), generators)

	return apiProperties_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForApiProperties_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForApiProperties_STATUSARM(gens map[string]gopter.Gen) {
	gens["ServerVersion"] = gen.PtrOf(gen.OneConstOf(ApiProperties_STATUS_ServerVersion_32, ApiProperties_STATUS_ServerVersion_36, ApiProperties_STATUS_ServerVersion_40))
}

func Test_BackupPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of BackupPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupPolicy_STATUSARM, BackupPolicy_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupPolicy_STATUSARM runs a test to see if a specific instance of BackupPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupPolicy_STATUSARM(subject BackupPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual BackupPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of BackupPolicy_STATUSARM instances for property testing - lazily instantiated by
// BackupPolicy_STATUSARMGenerator()
var backupPolicy_STATUSARMGenerator gopter.Gen

// BackupPolicy_STATUSARMGenerator returns a generator of BackupPolicy_STATUSARM instances for property testing.
func BackupPolicy_STATUSARMGenerator() gopter.Gen {
	if backupPolicy_STATUSARMGenerator != nil {
		return backupPolicy_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupPolicy_STATUSARM(generators)
	backupPolicy_STATUSARMGenerator = gen.Struct(reflect.TypeOf(BackupPolicy_STATUSARM{}), generators)

	return backupPolicy_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBackupPolicy_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupPolicy_STATUSARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(BackupPolicyType_STATUS_Continuous, BackupPolicyType_STATUS_Periodic))
}

func Test_Capability_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Capability_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCapability_STATUSARM, Capability_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCapability_STATUSARM runs a test to see if a specific instance of Capability_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCapability_STATUSARM(subject Capability_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Capability_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Capability_STATUSARM instances for property testing - lazily instantiated by
// Capability_STATUSARMGenerator()
var capability_STATUSARMGenerator gopter.Gen

// Capability_STATUSARMGenerator returns a generator of Capability_STATUSARM instances for property testing.
func Capability_STATUSARMGenerator() gopter.Gen {
	if capability_STATUSARMGenerator != nil {
		return capability_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCapability_STATUSARM(generators)
	capability_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Capability_STATUSARM{}), generators)

	return capability_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForCapability_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCapability_STATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_ConsistencyPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConsistencyPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConsistencyPolicy_STATUSARM, ConsistencyPolicy_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConsistencyPolicy_STATUSARM runs a test to see if a specific instance of ConsistencyPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForConsistencyPolicy_STATUSARM(subject ConsistencyPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConsistencyPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConsistencyPolicy_STATUSARM instances for property testing - lazily instantiated by
// ConsistencyPolicy_STATUSARMGenerator()
var consistencyPolicy_STATUSARMGenerator gopter.Gen

// ConsistencyPolicy_STATUSARMGenerator returns a generator of ConsistencyPolicy_STATUSARM instances for property testing.
func ConsistencyPolicy_STATUSARMGenerator() gopter.Gen {
	if consistencyPolicy_STATUSARMGenerator != nil {
		return consistencyPolicy_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConsistencyPolicy_STATUSARM(generators)
	consistencyPolicy_STATUSARMGenerator = gen.Struct(reflect.TypeOf(ConsistencyPolicy_STATUSARM{}), generators)

	return consistencyPolicy_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForConsistencyPolicy_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConsistencyPolicy_STATUSARM(gens map[string]gopter.Gen) {
	gens["DefaultConsistencyLevel"] = gen.PtrOf(gen.OneConstOf(
		ConsistencyPolicy_STATUS_DefaultConsistencyLevel_BoundedStaleness,
		ConsistencyPolicy_STATUS_DefaultConsistencyLevel_ConsistentPrefix,
		ConsistencyPolicy_STATUS_DefaultConsistencyLevel_Eventual,
		ConsistencyPolicy_STATUS_DefaultConsistencyLevel_Session,
		ConsistencyPolicy_STATUS_DefaultConsistencyLevel_Strong))
	gens["MaxIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["MaxStalenessPrefix"] = gen.PtrOf(gen.Int())
}

func Test_CorsPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CorsPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCorsPolicy_STATUSARM, CorsPolicy_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCorsPolicy_STATUSARM runs a test to see if a specific instance of CorsPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCorsPolicy_STATUSARM(subject CorsPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CorsPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CorsPolicy_STATUSARM instances for property testing - lazily instantiated by
// CorsPolicy_STATUSARMGenerator()
var corsPolicy_STATUSARMGenerator gopter.Gen

// CorsPolicy_STATUSARMGenerator returns a generator of CorsPolicy_STATUSARM instances for property testing.
func CorsPolicy_STATUSARMGenerator() gopter.Gen {
	if corsPolicy_STATUSARMGenerator != nil {
		return corsPolicy_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCorsPolicy_STATUSARM(generators)
	corsPolicy_STATUSARMGenerator = gen.Struct(reflect.TypeOf(CorsPolicy_STATUSARM{}), generators)

	return corsPolicy_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForCorsPolicy_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCorsPolicy_STATUSARM(gens map[string]gopter.Gen) {
	gens["AllowedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedMethods"] = gen.PtrOf(gen.AlphaString())
	gens["AllowedOrigins"] = gen.PtrOf(gen.AlphaString())
	gens["ExposedHeaders"] = gen.PtrOf(gen.AlphaString())
	gens["MaxAgeInSeconds"] = gen.PtrOf(gen.Int())
}

func Test_FailoverPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FailoverPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFailoverPolicy_STATUSARM, FailoverPolicy_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFailoverPolicy_STATUSARM runs a test to see if a specific instance of FailoverPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForFailoverPolicy_STATUSARM(subject FailoverPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FailoverPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FailoverPolicy_STATUSARM instances for property testing - lazily instantiated by
// FailoverPolicy_STATUSARMGenerator()
var failoverPolicy_STATUSARMGenerator gopter.Gen

// FailoverPolicy_STATUSARMGenerator returns a generator of FailoverPolicy_STATUSARM instances for property testing.
func FailoverPolicy_STATUSARMGenerator() gopter.Gen {
	if failoverPolicy_STATUSARMGenerator != nil {
		return failoverPolicy_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFailoverPolicy_STATUSARM(generators)
	failoverPolicy_STATUSARMGenerator = gen.Struct(reflect.TypeOf(FailoverPolicy_STATUSARM{}), generators)

	return failoverPolicy_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForFailoverPolicy_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFailoverPolicy_STATUSARM(gens map[string]gopter.Gen) {
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
}

func Test_IpAddressOrRange_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IpAddressOrRange_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIpAddressOrRange_STATUSARM, IpAddressOrRange_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIpAddressOrRange_STATUSARM runs a test to see if a specific instance of IpAddressOrRange_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIpAddressOrRange_STATUSARM(subject IpAddressOrRange_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IpAddressOrRange_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IpAddressOrRange_STATUSARM instances for property testing - lazily instantiated by
// IpAddressOrRange_STATUSARMGenerator()
var ipAddressOrRange_STATUSARMGenerator gopter.Gen

// IpAddressOrRange_STATUSARMGenerator returns a generator of IpAddressOrRange_STATUSARM instances for property testing.
func IpAddressOrRange_STATUSARMGenerator() gopter.Gen {
	if ipAddressOrRange_STATUSARMGenerator != nil {
		return ipAddressOrRange_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIpAddressOrRange_STATUSARM(generators)
	ipAddressOrRange_STATUSARMGenerator = gen.Struct(reflect.TypeOf(IpAddressOrRange_STATUSARM{}), generators)

	return ipAddressOrRange_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIpAddressOrRange_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIpAddressOrRange_STATUSARM(gens map[string]gopter.Gen) {
	gens["IpAddressOrRange"] = gen.PtrOf(gen.AlphaString())
}

func Test_Location_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Location_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLocation_STATUSARM, Location_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLocation_STATUSARM runs a test to see if a specific instance of Location_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForLocation_STATUSARM(subject Location_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Location_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Location_STATUSARM instances for property testing - lazily instantiated by Location_STATUSARMGenerator()
var location_STATUSARMGenerator gopter.Gen

// Location_STATUSARMGenerator returns a generator of Location_STATUSARM instances for property testing.
func Location_STATUSARMGenerator() gopter.Gen {
	if location_STATUSARMGenerator != nil {
		return location_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLocation_STATUSARM(generators)
	location_STATUSARMGenerator = gen.Struct(reflect.TypeOf(Location_STATUSARM{}), generators)

	return location_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForLocation_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLocation_STATUSARM(gens map[string]gopter.Gen) {
	gens["DocumentEndpoint"] = gen.PtrOf(gen.AlphaString())
	gens["FailoverPriority"] = gen.PtrOf(gen.Int())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsZoneRedundant"] = gen.PtrOf(gen.Bool())
	gens["LocationName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedServiceIdentity_STATUS_UserAssignedIdentitiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedServiceIdentity_STATUS_UserAssignedIdentitiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedServiceIdentity_STATUS_UserAssignedIdentitiesARM, ManagedServiceIdentity_STATUS_UserAssignedIdentitiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedServiceIdentity_STATUS_UserAssignedIdentitiesARM runs a test to see if a specific instance of ManagedServiceIdentity_STATUS_UserAssignedIdentitiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedServiceIdentity_STATUS_UserAssignedIdentitiesARM(subject ManagedServiceIdentity_STATUS_UserAssignedIdentitiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedServiceIdentity_STATUS_UserAssignedIdentitiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedServiceIdentity_STATUS_UserAssignedIdentitiesARM instances for property testing - lazily
// instantiated by ManagedServiceIdentity_STATUS_UserAssignedIdentitiesARMGenerator()
var managedServiceIdentity_STATUS_UserAssignedIdentitiesARMGenerator gopter.Gen

// ManagedServiceIdentity_STATUS_UserAssignedIdentitiesARMGenerator returns a generator of ManagedServiceIdentity_STATUS_UserAssignedIdentitiesARM instances for property testing.
func ManagedServiceIdentity_STATUS_UserAssignedIdentitiesARMGenerator() gopter.Gen {
	if managedServiceIdentity_STATUS_UserAssignedIdentitiesARMGenerator != nil {
		return managedServiceIdentity_STATUS_UserAssignedIdentitiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS_UserAssignedIdentitiesARM(generators)
	managedServiceIdentity_STATUS_UserAssignedIdentitiesARMGenerator = gen.Struct(reflect.TypeOf(ManagedServiceIdentity_STATUS_UserAssignedIdentitiesARM{}), generators)

	return managedServiceIdentity_STATUS_UserAssignedIdentitiesARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS_UserAssignedIdentitiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedServiceIdentity_STATUS_UserAssignedIdentitiesARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["PrincipalId"] = gen.PtrOf(gen.AlphaString())
}

func Test_PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM, PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM runs a test to see if a specific instance of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM(subject PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM instances for property testing - lazily
// instantiated by PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator()
var privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator gopter.Gen

// PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator returns a generator of PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM instances for property testing.
func PrivateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator() gopter.Gen {
	if privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator != nil {
		return privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM(generators)
	privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator = gen.Struct(reflect.TypeOf(PrivateEndpointConnection_STATUS_SubResourceEmbeddedARM{}), generators)

	return privateEndpointConnection_STATUS_SubResourceEmbeddedARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateEndpointConnection_STATUS_SubResourceEmbeddedARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_VirtualNetworkRule_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of VirtualNetworkRule_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForVirtualNetworkRule_STATUSARM, VirtualNetworkRule_STATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForVirtualNetworkRule_STATUSARM runs a test to see if a specific instance of VirtualNetworkRule_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForVirtualNetworkRule_STATUSARM(subject VirtualNetworkRule_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual VirtualNetworkRule_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of VirtualNetworkRule_STATUSARM instances for property testing - lazily instantiated by
// VirtualNetworkRule_STATUSARMGenerator()
var virtualNetworkRule_STATUSARMGenerator gopter.Gen

// VirtualNetworkRule_STATUSARMGenerator returns a generator of VirtualNetworkRule_STATUSARM instances for property testing.
func VirtualNetworkRule_STATUSARMGenerator() gopter.Gen {
	if virtualNetworkRule_STATUSARMGenerator != nil {
		return virtualNetworkRule_STATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForVirtualNetworkRule_STATUSARM(generators)
	virtualNetworkRule_STATUSARMGenerator = gen.Struct(reflect.TypeOf(VirtualNetworkRule_STATUSARM{}), generators)

	return virtualNetworkRule_STATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForVirtualNetworkRule_STATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForVirtualNetworkRule_STATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IgnoreMissingVNetServiceEndpoint"] = gen.PtrOf(gen.Bool())
}
