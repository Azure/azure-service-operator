// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210515

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_SqlContainerGetResults_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlContainerGetResults_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlContainerGetResultsSTATUSARM, SqlContainerGetResultsSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlContainerGetResultsSTATUSARM runs a test to see if a specific instance of SqlContainerGetResults_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlContainerGetResultsSTATUSARM(subject SqlContainerGetResults_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlContainerGetResults_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlContainerGetResults_STATUSARM instances for property testing - lazily instantiated by
// SqlContainerGetResultsSTATUSARMGenerator()
var sqlContainerGetResultsSTATUSARMGenerator gopter.Gen

// SqlContainerGetResultsSTATUSARMGenerator returns a generator of SqlContainerGetResults_STATUSARM instances for property testing.
// We first initialize sqlContainerGetResultsSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SqlContainerGetResultsSTATUSARMGenerator() gopter.Gen {
	if sqlContainerGetResultsSTATUSARMGenerator != nil {
		return sqlContainerGetResultsSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerGetResultsSTATUSARM(generators)
	sqlContainerGetResultsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SqlContainerGetResults_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerGetResultsSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForSqlContainerGetResultsSTATUSARM(generators)
	sqlContainerGetResultsSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SqlContainerGetResults_STATUSARM{}), generators)

	return sqlContainerGetResultsSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSqlContainerGetResultsSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSqlContainerGetResultsSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSqlContainerGetResultsSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlContainerGetResultsSTATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(SqlContainerGetPropertiesSTATUSARMGenerator())
}

func Test_SqlContainerGetProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlContainerGetProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlContainerGetPropertiesSTATUSARM, SqlContainerGetPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlContainerGetPropertiesSTATUSARM runs a test to see if a specific instance of SqlContainerGetProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlContainerGetPropertiesSTATUSARM(subject SqlContainerGetProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlContainerGetProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlContainerGetProperties_STATUSARM instances for property testing - lazily instantiated by
// SqlContainerGetPropertiesSTATUSARMGenerator()
var sqlContainerGetPropertiesSTATUSARMGenerator gopter.Gen

// SqlContainerGetPropertiesSTATUSARMGenerator returns a generator of SqlContainerGetProperties_STATUSARM instances for property testing.
func SqlContainerGetPropertiesSTATUSARMGenerator() gopter.Gen {
	if sqlContainerGetPropertiesSTATUSARMGenerator != nil {
		return sqlContainerGetPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSqlContainerGetPropertiesSTATUSARM(generators)
	sqlContainerGetPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SqlContainerGetProperties_STATUSARM{}), generators)

	return sqlContainerGetPropertiesSTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForSqlContainerGetPropertiesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlContainerGetPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["Options"] = gen.PtrOf(OptionsResourceSTATUSARMGenerator())
	gens["Resource"] = gen.PtrOf(SqlContainerGetPropertiesSTATUSResourceARMGenerator())
}

func Test_SqlContainerGetProperties_STATUS_ResourceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SqlContainerGetProperties_STATUS_ResourceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSqlContainerGetPropertiesSTATUSResourceARM, SqlContainerGetPropertiesSTATUSResourceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSqlContainerGetPropertiesSTATUSResourceARM runs a test to see if a specific instance of SqlContainerGetProperties_STATUS_ResourceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSqlContainerGetPropertiesSTATUSResourceARM(subject SqlContainerGetProperties_STATUS_ResourceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SqlContainerGetProperties_STATUS_ResourceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SqlContainerGetProperties_STATUS_ResourceARM instances for property testing - lazily instantiated by
// SqlContainerGetPropertiesSTATUSResourceARMGenerator()
var sqlContainerGetPropertiesSTATUSResourceARMGenerator gopter.Gen

// SqlContainerGetPropertiesSTATUSResourceARMGenerator returns a generator of SqlContainerGetProperties_STATUS_ResourceARM instances for property testing.
// We first initialize sqlContainerGetPropertiesSTATUSResourceARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func SqlContainerGetPropertiesSTATUSResourceARMGenerator() gopter.Gen {
	if sqlContainerGetPropertiesSTATUSResourceARMGenerator != nil {
		return sqlContainerGetPropertiesSTATUSResourceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerGetPropertiesSTATUSResourceARM(generators)
	sqlContainerGetPropertiesSTATUSResourceARMGenerator = gen.Struct(reflect.TypeOf(SqlContainerGetProperties_STATUS_ResourceARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSqlContainerGetPropertiesSTATUSResourceARM(generators)
	AddRelatedPropertyGeneratorsForSqlContainerGetPropertiesSTATUSResourceARM(generators)
	sqlContainerGetPropertiesSTATUSResourceARMGenerator = gen.Struct(reflect.TypeOf(SqlContainerGetProperties_STATUS_ResourceARM{}), generators)

	return sqlContainerGetPropertiesSTATUSResourceARMGenerator
}

// AddIndependentPropertyGeneratorsForSqlContainerGetPropertiesSTATUSResourceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSqlContainerGetPropertiesSTATUSResourceARM(gens map[string]gopter.Gen) {
	gens["AnalyticalStorageTtl"] = gen.PtrOf(gen.Int())
	gens["DefaultTtl"] = gen.PtrOf(gen.Int())
	gens["Etag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Rid"] = gen.PtrOf(gen.AlphaString())
	gens["Ts"] = gen.PtrOf(gen.Float64())
}

// AddRelatedPropertyGeneratorsForSqlContainerGetPropertiesSTATUSResourceARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSqlContainerGetPropertiesSTATUSResourceARM(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPolicy"] = gen.PtrOf(ConflictResolutionPolicySTATUSARMGenerator())
	gens["IndexingPolicy"] = gen.PtrOf(IndexingPolicySTATUSARMGenerator())
	gens["PartitionKey"] = gen.PtrOf(ContainerPartitionKeySTATUSARMGenerator())
	gens["UniqueKeyPolicy"] = gen.PtrOf(UniqueKeyPolicySTATUSARMGenerator())
}

func Test_ConflictResolutionPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ConflictResolutionPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForConflictResolutionPolicySTATUSARM, ConflictResolutionPolicySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForConflictResolutionPolicySTATUSARM runs a test to see if a specific instance of ConflictResolutionPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForConflictResolutionPolicySTATUSARM(subject ConflictResolutionPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ConflictResolutionPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ConflictResolutionPolicy_STATUSARM instances for property testing - lazily instantiated by
// ConflictResolutionPolicySTATUSARMGenerator()
var conflictResolutionPolicySTATUSARMGenerator gopter.Gen

// ConflictResolutionPolicySTATUSARMGenerator returns a generator of ConflictResolutionPolicy_STATUSARM instances for property testing.
func ConflictResolutionPolicySTATUSARMGenerator() gopter.Gen {
	if conflictResolutionPolicySTATUSARMGenerator != nil {
		return conflictResolutionPolicySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForConflictResolutionPolicySTATUSARM(generators)
	conflictResolutionPolicySTATUSARMGenerator = gen.Struct(reflect.TypeOf(ConflictResolutionPolicy_STATUSARM{}), generators)

	return conflictResolutionPolicySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForConflictResolutionPolicySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForConflictResolutionPolicySTATUSARM(gens map[string]gopter.Gen) {
	gens["ConflictResolutionPath"] = gen.PtrOf(gen.AlphaString())
	gens["ConflictResolutionProcedure"] = gen.PtrOf(gen.AlphaString())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(ConflictResolutionPolicySTATUSMode_Custom, ConflictResolutionPolicySTATUSMode_LastWriterWins))
}

func Test_ContainerPartitionKey_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerPartitionKey_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerPartitionKeySTATUSARM, ContainerPartitionKeySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerPartitionKeySTATUSARM runs a test to see if a specific instance of ContainerPartitionKey_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerPartitionKeySTATUSARM(subject ContainerPartitionKey_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerPartitionKey_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerPartitionKey_STATUSARM instances for property testing - lazily instantiated by
// ContainerPartitionKeySTATUSARMGenerator()
var containerPartitionKeySTATUSARMGenerator gopter.Gen

// ContainerPartitionKeySTATUSARMGenerator returns a generator of ContainerPartitionKey_STATUSARM instances for property testing.
func ContainerPartitionKeySTATUSARMGenerator() gopter.Gen {
	if containerPartitionKeySTATUSARMGenerator != nil {
		return containerPartitionKeySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerPartitionKeySTATUSARM(generators)
	containerPartitionKeySTATUSARMGenerator = gen.Struct(reflect.TypeOf(ContainerPartitionKey_STATUSARM{}), generators)

	return containerPartitionKeySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerPartitionKeySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerPartitionKeySTATUSARM(gens map[string]gopter.Gen) {
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(ContainerPartitionKeySTATUSKind_Hash, ContainerPartitionKeySTATUSKind_MultiHash, ContainerPartitionKeySTATUSKind_Range))
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
	gens["SystemKey"] = gen.PtrOf(gen.Bool())
	gens["Version"] = gen.PtrOf(gen.Int())
}

func Test_IndexingPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IndexingPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexingPolicySTATUSARM, IndexingPolicySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexingPolicySTATUSARM runs a test to see if a specific instance of IndexingPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexingPolicySTATUSARM(subject IndexingPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IndexingPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IndexingPolicy_STATUSARM instances for property testing - lazily instantiated by
// IndexingPolicySTATUSARMGenerator()
var indexingPolicySTATUSARMGenerator gopter.Gen

// IndexingPolicySTATUSARMGenerator returns a generator of IndexingPolicy_STATUSARM instances for property testing.
// We first initialize indexingPolicySTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IndexingPolicySTATUSARMGenerator() gopter.Gen {
	if indexingPolicySTATUSARMGenerator != nil {
		return indexingPolicySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicySTATUSARM(generators)
	indexingPolicySTATUSARMGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexingPolicySTATUSARM(generators)
	AddRelatedPropertyGeneratorsForIndexingPolicySTATUSARM(generators)
	indexingPolicySTATUSARMGenerator = gen.Struct(reflect.TypeOf(IndexingPolicy_STATUSARM{}), generators)

	return indexingPolicySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIndexingPolicySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexingPolicySTATUSARM(gens map[string]gopter.Gen) {
	gens["Automatic"] = gen.PtrOf(gen.Bool())
	gens["IndexingMode"] = gen.PtrOf(gen.OneConstOf(IndexingPolicySTATUSIndexingMode_Consistent, IndexingPolicySTATUSIndexingMode_Lazy, IndexingPolicySTATUSIndexingMode_None))
}

// AddRelatedPropertyGeneratorsForIndexingPolicySTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIndexingPolicySTATUSARM(gens map[string]gopter.Gen) {
	gens["CompositeIndexes"] = gen.SliceOf(gen.SliceOf(CompositePathSTATUSARMGenerator()))
	gens["ExcludedPaths"] = gen.SliceOf(ExcludedPathSTATUSARMGenerator())
	gens["IncludedPaths"] = gen.SliceOf(IncludedPathSTATUSARMGenerator())
	gens["SpatialIndexes"] = gen.SliceOf(SpatialSpecSTATUSARMGenerator())
}

func Test_UniqueKeyPolicy_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKeyPolicy_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKeyPolicySTATUSARM, UniqueKeyPolicySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKeyPolicySTATUSARM runs a test to see if a specific instance of UniqueKeyPolicy_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKeyPolicySTATUSARM(subject UniqueKeyPolicy_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKeyPolicy_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKeyPolicy_STATUSARM instances for property testing - lazily instantiated by
// UniqueKeyPolicySTATUSARMGenerator()
var uniqueKeyPolicySTATUSARMGenerator gopter.Gen

// UniqueKeyPolicySTATUSARMGenerator returns a generator of UniqueKeyPolicy_STATUSARM instances for property testing.
func UniqueKeyPolicySTATUSARMGenerator() gopter.Gen {
	if uniqueKeyPolicySTATUSARMGenerator != nil {
		return uniqueKeyPolicySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForUniqueKeyPolicySTATUSARM(generators)
	uniqueKeyPolicySTATUSARMGenerator = gen.Struct(reflect.TypeOf(UniqueKeyPolicy_STATUSARM{}), generators)

	return uniqueKeyPolicySTATUSARMGenerator
}

// AddRelatedPropertyGeneratorsForUniqueKeyPolicySTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUniqueKeyPolicySTATUSARM(gens map[string]gopter.Gen) {
	gens["UniqueKeys"] = gen.SliceOf(UniqueKeySTATUSARMGenerator())
}

func Test_CompositePath_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CompositePath_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCompositePathSTATUSARM, CompositePathSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCompositePathSTATUSARM runs a test to see if a specific instance of CompositePath_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCompositePathSTATUSARM(subject CompositePath_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CompositePath_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CompositePath_STATUSARM instances for property testing - lazily instantiated by
// CompositePathSTATUSARMGenerator()
var compositePathSTATUSARMGenerator gopter.Gen

// CompositePathSTATUSARMGenerator returns a generator of CompositePath_STATUSARM instances for property testing.
func CompositePathSTATUSARMGenerator() gopter.Gen {
	if compositePathSTATUSARMGenerator != nil {
		return compositePathSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCompositePathSTATUSARM(generators)
	compositePathSTATUSARMGenerator = gen.Struct(reflect.TypeOf(CompositePath_STATUSARM{}), generators)

	return compositePathSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForCompositePathSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCompositePathSTATUSARM(gens map[string]gopter.Gen) {
	gens["Order"] = gen.PtrOf(gen.OneConstOf(CompositePathSTATUSOrder_Ascending, CompositePathSTATUSOrder_Descending))
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_ExcludedPath_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExcludedPath_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExcludedPathSTATUSARM, ExcludedPathSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExcludedPathSTATUSARM runs a test to see if a specific instance of ExcludedPath_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExcludedPathSTATUSARM(subject ExcludedPath_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExcludedPath_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExcludedPath_STATUSARM instances for property testing - lazily instantiated by
// ExcludedPathSTATUSARMGenerator()
var excludedPathSTATUSARMGenerator gopter.Gen

// ExcludedPathSTATUSARMGenerator returns a generator of ExcludedPath_STATUSARM instances for property testing.
func ExcludedPathSTATUSARMGenerator() gopter.Gen {
	if excludedPathSTATUSARMGenerator != nil {
		return excludedPathSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExcludedPathSTATUSARM(generators)
	excludedPathSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ExcludedPath_STATUSARM{}), generators)

	return excludedPathSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForExcludedPathSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExcludedPathSTATUSARM(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

func Test_IncludedPath_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IncludedPath_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIncludedPathSTATUSARM, IncludedPathSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIncludedPathSTATUSARM runs a test to see if a specific instance of IncludedPath_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIncludedPathSTATUSARM(subject IncludedPath_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IncludedPath_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IncludedPath_STATUSARM instances for property testing - lazily instantiated by
// IncludedPathSTATUSARMGenerator()
var includedPathSTATUSARMGenerator gopter.Gen

// IncludedPathSTATUSARMGenerator returns a generator of IncludedPath_STATUSARM instances for property testing.
// We first initialize includedPathSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func IncludedPathSTATUSARMGenerator() gopter.Gen {
	if includedPathSTATUSARMGenerator != nil {
		return includedPathSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPathSTATUSARM(generators)
	includedPathSTATUSARMGenerator = gen.Struct(reflect.TypeOf(IncludedPath_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIncludedPathSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForIncludedPathSTATUSARM(generators)
	includedPathSTATUSARMGenerator = gen.Struct(reflect.TypeOf(IncludedPath_STATUSARM{}), generators)

	return includedPathSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIncludedPathSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIncludedPathSTATUSARM(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForIncludedPathSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForIncludedPathSTATUSARM(gens map[string]gopter.Gen) {
	gens["Indexes"] = gen.SliceOf(IndexesSTATUSARMGenerator())
}

func Test_SpatialSpec_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SpatialSpec_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSpatialSpecSTATUSARM, SpatialSpecSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSpatialSpecSTATUSARM runs a test to see if a specific instance of SpatialSpec_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSpatialSpecSTATUSARM(subject SpatialSpec_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SpatialSpec_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SpatialSpec_STATUSARM instances for property testing - lazily instantiated by
// SpatialSpecSTATUSARMGenerator()
var spatialSpecSTATUSARMGenerator gopter.Gen

// SpatialSpecSTATUSARMGenerator returns a generator of SpatialSpec_STATUSARM instances for property testing.
func SpatialSpecSTATUSARMGenerator() gopter.Gen {
	if spatialSpecSTATUSARMGenerator != nil {
		return spatialSpecSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSpatialSpecSTATUSARM(generators)
	spatialSpecSTATUSARMGenerator = gen.Struct(reflect.TypeOf(SpatialSpec_STATUSARM{}), generators)

	return spatialSpecSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSpatialSpecSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSpatialSpecSTATUSARM(gens map[string]gopter.Gen) {
	gens["Path"] = gen.PtrOf(gen.AlphaString())
	gens["Types"] = gen.SliceOf(gen.OneConstOf(
		SpatialType_STATUS_LineString,
		SpatialType_STATUS_MultiPolygon,
		SpatialType_STATUS_Point,
		SpatialType_STATUS_Polygon))
}

func Test_UniqueKey_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UniqueKey_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUniqueKeySTATUSARM, UniqueKeySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUniqueKeySTATUSARM runs a test to see if a specific instance of UniqueKey_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUniqueKeySTATUSARM(subject UniqueKey_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UniqueKey_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UniqueKey_STATUSARM instances for property testing - lazily instantiated by UniqueKeySTATUSARMGenerator()
var uniqueKeySTATUSARMGenerator gopter.Gen

// UniqueKeySTATUSARMGenerator returns a generator of UniqueKey_STATUSARM instances for property testing.
func UniqueKeySTATUSARMGenerator() gopter.Gen {
	if uniqueKeySTATUSARMGenerator != nil {
		return uniqueKeySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUniqueKeySTATUSARM(generators)
	uniqueKeySTATUSARMGenerator = gen.Struct(reflect.TypeOf(UniqueKey_STATUSARM{}), generators)

	return uniqueKeySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForUniqueKeySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUniqueKeySTATUSARM(gens map[string]gopter.Gen) {
	gens["Paths"] = gen.SliceOf(gen.AlphaString())
}

func Test_Indexes_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Indexes_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIndexesSTATUSARM, IndexesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIndexesSTATUSARM runs a test to see if a specific instance of Indexes_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIndexesSTATUSARM(subject Indexes_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Indexes_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Indexes_STATUSARM instances for property testing - lazily instantiated by IndexesSTATUSARMGenerator()
var indexesSTATUSARMGenerator gopter.Gen

// IndexesSTATUSARMGenerator returns a generator of Indexes_STATUSARM instances for property testing.
func IndexesSTATUSARMGenerator() gopter.Gen {
	if indexesSTATUSARMGenerator != nil {
		return indexesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIndexesSTATUSARM(generators)
	indexesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Indexes_STATUSARM{}), generators)

	return indexesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForIndexesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIndexesSTATUSARM(gens map[string]gopter.Gen) {
	gens["DataType"] = gen.PtrOf(gen.OneConstOf(
		IndexesSTATUSDataType_LineString,
		IndexesSTATUSDataType_MultiPolygon,
		IndexesSTATUSDataType_Number,
		IndexesSTATUSDataType_Point,
		IndexesSTATUSDataType_Polygon,
		IndexesSTATUSDataType_String))
	gens["Kind"] = gen.PtrOf(gen.OneConstOf(IndexesSTATUSKind_Hash, IndexesSTATUSKind_Range, IndexesSTATUSKind_Spatial))
	gens["Precision"] = gen.PtrOf(gen.Int())
}
