// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210601

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Server_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Server_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerSTATUSARM, ServerSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerSTATUSARM runs a test to see if a specific instance of Server_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServerSTATUSARM(subject Server_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Server_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Server_STATUSARM instances for property testing - lazily instantiated by ServerSTATUSARMGenerator()
var serverSTATUSARMGenerator gopter.Gen

// ServerSTATUSARMGenerator returns a generator of Server_STATUSARM instances for property testing.
// We first initialize serverSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServerSTATUSARMGenerator() gopter.Gen {
	if serverSTATUSARMGenerator != nil {
		return serverSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerSTATUSARM(generators)
	serverSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Server_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForServerSTATUSARM(generators)
	serverSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Server_STATUSARM{}), generators)

	return serverSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForServerSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerSTATUSARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForServerSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerSTATUSARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ServerPropertiesSTATUSARMGenerator())
	gens["Sku"] = gen.PtrOf(SkuSTATUSARMGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSARMGenerator())
}

func Test_ServerProperties_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerProperties_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerPropertiesSTATUSARM, ServerPropertiesSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerPropertiesSTATUSARM runs a test to see if a specific instance of ServerProperties_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServerPropertiesSTATUSARM(subject ServerProperties_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerProperties_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerProperties_STATUSARM instances for property testing - lazily instantiated by
// ServerPropertiesSTATUSARMGenerator()
var serverPropertiesSTATUSARMGenerator gopter.Gen

// ServerPropertiesSTATUSARMGenerator returns a generator of ServerProperties_STATUSARM instances for property testing.
// We first initialize serverPropertiesSTATUSARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ServerPropertiesSTATUSARMGenerator() gopter.Gen {
	if serverPropertiesSTATUSARMGenerator != nil {
		return serverPropertiesSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerPropertiesSTATUSARM(generators)
	serverPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ServerProperties_STATUSARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerPropertiesSTATUSARM(generators)
	AddRelatedPropertyGeneratorsForServerPropertiesSTATUSARM(generators)
	serverPropertiesSTATUSARMGenerator = gen.Struct(reflect.TypeOf(ServerProperties_STATUSARM{}), generators)

	return serverPropertiesSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForServerPropertiesSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["AdministratorLogin"] = gen.PtrOf(gen.AlphaString())
	gens["AvailabilityZone"] = gen.PtrOf(gen.AlphaString())
	gens["CreateMode"] = gen.PtrOf(gen.OneConstOf(
		ServerPropertiesSTATUSCreateMode_Create,
		ServerPropertiesSTATUSCreateMode_Default,
		ServerPropertiesSTATUSCreateMode_PointInTimeRestore,
		ServerPropertiesSTATUSCreateMode_Update))
	gens["FullyQualifiedDomainName"] = gen.PtrOf(gen.AlphaString())
	gens["MinorVersion"] = gen.PtrOf(gen.AlphaString())
	gens["PointInTimeUTC"] = gen.PtrOf(gen.AlphaString())
	gens["SourceServerResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		ServerPropertiesSTATUSState_Disabled,
		ServerPropertiesSTATUSState_Dropping,
		ServerPropertiesSTATUSState_Ready,
		ServerPropertiesSTATUSState_Starting,
		ServerPropertiesSTATUSState_Stopped,
		ServerPropertiesSTATUSState_Stopping,
		ServerPropertiesSTATUSState_Updating))
	gens["Version"] = gen.PtrOf(gen.OneConstOf(ServerVersion_STATUS_11, ServerVersion_STATUS_12, ServerVersion_STATUS_13))
}

// AddRelatedPropertyGeneratorsForServerPropertiesSTATUSARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForServerPropertiesSTATUSARM(gens map[string]gopter.Gen) {
	gens["Backup"] = gen.PtrOf(BackupSTATUSARMGenerator())
	gens["HighAvailability"] = gen.PtrOf(HighAvailabilitySTATUSARMGenerator())
	gens["MaintenanceWindow"] = gen.PtrOf(MaintenanceWindowSTATUSARMGenerator())
	gens["Network"] = gen.PtrOf(NetworkSTATUSARMGenerator())
	gens["Storage"] = gen.PtrOf(StorageSTATUSARMGenerator())
}

func Test_Sku_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Sku_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSkuSTATUSARM, SkuSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSkuSTATUSARM runs a test to see if a specific instance of Sku_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSkuSTATUSARM(subject Sku_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Sku_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Sku_STATUSARM instances for property testing - lazily instantiated by SkuSTATUSARMGenerator()
var skuSTATUSARMGenerator gopter.Gen

// SkuSTATUSARMGenerator returns a generator of Sku_STATUSARM instances for property testing.
func SkuSTATUSARMGenerator() gopter.Gen {
	if skuSTATUSARMGenerator != nil {
		return skuSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSkuSTATUSARM(generators)
	skuSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Sku_STATUSARM{}), generators)

	return skuSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForSkuSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSkuSTATUSARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(SkuSTATUSTier_Burstable, SkuSTATUSTier_GeneralPurpose, SkuSTATUSTier_MemoryOptimized))
}

func Test_Backup_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Backup_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForBackupSTATUSARM, BackupSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForBackupSTATUSARM runs a test to see if a specific instance of Backup_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForBackupSTATUSARM(subject Backup_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Backup_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Backup_STATUSARM instances for property testing - lazily instantiated by BackupSTATUSARMGenerator()
var backupSTATUSARMGenerator gopter.Gen

// BackupSTATUSARMGenerator returns a generator of Backup_STATUSARM instances for property testing.
func BackupSTATUSARMGenerator() gopter.Gen {
	if backupSTATUSARMGenerator != nil {
		return backupSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForBackupSTATUSARM(generators)
	backupSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Backup_STATUSARM{}), generators)

	return backupSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForBackupSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForBackupSTATUSARM(gens map[string]gopter.Gen) {
	gens["BackupRetentionDays"] = gen.PtrOf(gen.Int())
	gens["EarliestRestoreDate"] = gen.PtrOf(gen.AlphaString())
	gens["GeoRedundantBackup"] = gen.PtrOf(gen.OneConstOf(BackupSTATUSGeoRedundantBackup_Disabled, BackupSTATUSGeoRedundantBackup_Enabled))
}

func Test_HighAvailability_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HighAvailability_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHighAvailabilitySTATUSARM, HighAvailabilitySTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHighAvailabilitySTATUSARM runs a test to see if a specific instance of HighAvailability_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHighAvailabilitySTATUSARM(subject HighAvailability_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HighAvailability_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HighAvailability_STATUSARM instances for property testing - lazily instantiated by
// HighAvailabilitySTATUSARMGenerator()
var highAvailabilitySTATUSARMGenerator gopter.Gen

// HighAvailabilitySTATUSARMGenerator returns a generator of HighAvailability_STATUSARM instances for property testing.
func HighAvailabilitySTATUSARMGenerator() gopter.Gen {
	if highAvailabilitySTATUSARMGenerator != nil {
		return highAvailabilitySTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHighAvailabilitySTATUSARM(generators)
	highAvailabilitySTATUSARMGenerator = gen.Struct(reflect.TypeOf(HighAvailability_STATUSARM{}), generators)

	return highAvailabilitySTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForHighAvailabilitySTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHighAvailabilitySTATUSARM(gens map[string]gopter.Gen) {
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(HighAvailabilitySTATUSMode_Disabled, HighAvailabilitySTATUSMode_ZoneRedundant))
	gens["StandbyAvailabilityZone"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.OneConstOf(
		HighAvailabilitySTATUSState_CreatingStandby,
		HighAvailabilitySTATUSState_FailingOver,
		HighAvailabilitySTATUSState_Healthy,
		HighAvailabilitySTATUSState_NotEnabled,
		HighAvailabilitySTATUSState_RemovingStandby,
		HighAvailabilitySTATUSState_ReplicatingData))
}

func Test_MaintenanceWindow_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MaintenanceWindow_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMaintenanceWindowSTATUSARM, MaintenanceWindowSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMaintenanceWindowSTATUSARM runs a test to see if a specific instance of MaintenanceWindow_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForMaintenanceWindowSTATUSARM(subject MaintenanceWindow_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MaintenanceWindow_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MaintenanceWindow_STATUSARM instances for property testing - lazily instantiated by
// MaintenanceWindowSTATUSARMGenerator()
var maintenanceWindowSTATUSARMGenerator gopter.Gen

// MaintenanceWindowSTATUSARMGenerator returns a generator of MaintenanceWindow_STATUSARM instances for property testing.
func MaintenanceWindowSTATUSARMGenerator() gopter.Gen {
	if maintenanceWindowSTATUSARMGenerator != nil {
		return maintenanceWindowSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMaintenanceWindowSTATUSARM(generators)
	maintenanceWindowSTATUSARMGenerator = gen.Struct(reflect.TypeOf(MaintenanceWindow_STATUSARM{}), generators)

	return maintenanceWindowSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForMaintenanceWindowSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMaintenanceWindowSTATUSARM(gens map[string]gopter.Gen) {
	gens["CustomWindow"] = gen.PtrOf(gen.AlphaString())
	gens["DayOfWeek"] = gen.PtrOf(gen.Int())
	gens["StartHour"] = gen.PtrOf(gen.Int())
	gens["StartMinute"] = gen.PtrOf(gen.Int())
}

func Test_Network_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Network_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForNetworkSTATUSARM, NetworkSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForNetworkSTATUSARM runs a test to see if a specific instance of Network_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForNetworkSTATUSARM(subject Network_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Network_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Network_STATUSARM instances for property testing - lazily instantiated by NetworkSTATUSARMGenerator()
var networkSTATUSARMGenerator gopter.Gen

// NetworkSTATUSARMGenerator returns a generator of Network_STATUSARM instances for property testing.
func NetworkSTATUSARMGenerator() gopter.Gen {
	if networkSTATUSARMGenerator != nil {
		return networkSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForNetworkSTATUSARM(generators)
	networkSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Network_STATUSARM{}), generators)

	return networkSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForNetworkSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForNetworkSTATUSARM(gens map[string]gopter.Gen) {
	gens["DelegatedSubnetResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateDnsZoneArmResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["PublicNetworkAccess"] = gen.PtrOf(gen.OneConstOf(NetworkSTATUSPublicNetworkAccess_Disabled, NetworkSTATUSPublicNetworkAccess_Enabled))
}

func Test_Storage_STATUSARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Storage_STATUSARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForStorageSTATUSARM, StorageSTATUSARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForStorageSTATUSARM runs a test to see if a specific instance of Storage_STATUSARM round trips to JSON and back losslessly
func RunJSONSerializationTestForStorageSTATUSARM(subject Storage_STATUSARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Storage_STATUSARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Storage_STATUSARM instances for property testing - lazily instantiated by StorageSTATUSARMGenerator()
var storageSTATUSARMGenerator gopter.Gen

// StorageSTATUSARMGenerator returns a generator of Storage_STATUSARM instances for property testing.
func StorageSTATUSARMGenerator() gopter.Gen {
	if storageSTATUSARMGenerator != nil {
		return storageSTATUSARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForStorageSTATUSARM(generators)
	storageSTATUSARMGenerator = gen.Struct(reflect.TypeOf(Storage_STATUSARM{}), generators)

	return storageSTATUSARMGenerator
}

// AddIndependentPropertyGeneratorsForStorageSTATUSARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForStorageSTATUSARM(gens map[string]gopter.Gen) {
	gens["StorageSizeGB"] = gen.PtrOf(gen.Int())
}
