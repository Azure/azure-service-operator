// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20220901

import (
	"fmt"
	v1api20220901s "github.com/Azure/azure-service-operator/v2/api/search/v1api20220901storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /search/resource-manager/Microsoft.Search/stable/2022-09-01/search.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}
type SearchService struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              SearchService_Spec   `json:"spec,omitempty"`
	Status            SearchService_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &SearchService{}

// GetConditions returns the conditions of the resource
func (service *SearchService) GetConditions() conditions.Conditions {
	return service.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (service *SearchService) SetConditions(conditions conditions.Conditions) {
	service.Status.Conditions = conditions
}

var _ conversion.Convertible = &SearchService{}

// ConvertFrom populates our SearchService from the provided hub SearchService
func (service *SearchService) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v1api20220901s.SearchService)
	if !ok {
		return fmt.Errorf("expected search/v1api20220901storage/SearchService but received %T instead", hub)
	}

	return service.AssignProperties_From_SearchService(source)
}

// ConvertTo populates the provided hub SearchService from our SearchService
func (service *SearchService) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v1api20220901s.SearchService)
	if !ok {
		return fmt.Errorf("expected search/v1api20220901storage/SearchService but received %T instead", hub)
	}

	return service.AssignProperties_To_SearchService(destination)
}

// +kubebuilder:webhook:path=/mutate-search-azure-com-v1api20220901-searchservice,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=search.azure.com,resources=searchservices,verbs=create;update,versions=v1api20220901,name=default.v1api20220901.searchservices.search.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &SearchService{}

// Default applies defaults to the SearchService resource
func (service *SearchService) Default() {
	service.defaultImpl()
	var temp any = service
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (service *SearchService) defaultAzureName() {
	if service.Spec.AzureName == "" {
		service.Spec.AzureName = service.Name
	}
}

// defaultImpl applies the code generated defaults to the SearchService resource
func (service *SearchService) defaultImpl() { service.defaultAzureName() }

var _ genruntime.ImportableResource = &SearchService{}

// InitializeSpec initializes the spec for this resource from the given status
func (service *SearchService) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*SearchService_STATUS); ok {
		return service.Spec.Initialize_From_SearchService_STATUS(s)
	}

	return fmt.Errorf("expected Status of type SearchService_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &SearchService{}

// AzureName returns the Azure name of the resource
func (service *SearchService) AzureName() string {
	return service.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2022-09-01"
func (service SearchService) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (service *SearchService) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (service *SearchService) GetSpec() genruntime.ConvertibleSpec {
	return &service.Spec
}

// GetStatus returns the status of this resource
func (service *SearchService) GetStatus() genruntime.ConvertibleStatus {
	return &service.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Search/searchServices"
func (service *SearchService) GetType() string {
	return "Microsoft.Search/searchServices"
}

// NewEmptyStatus returns a new empty (blank) status
func (service *SearchService) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &SearchService_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (service *SearchService) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(service.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  service.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (service *SearchService) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*SearchService_STATUS); ok {
		service.Status = *st
		return nil
	}

	// Convert status to required version
	var st SearchService_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	service.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-search-azure-com-v1api20220901-searchservice,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=search.azure.com,resources=searchservices,verbs=create;update,versions=v1api20220901,name=validate.v1api20220901.searchservices.search.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &SearchService{}

// ValidateCreate validates the creation of the resource
func (service *SearchService) ValidateCreate() error {
	validations := service.createValidations()
	var temp any = service
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (service *SearchService) ValidateDelete() error {
	validations := service.deleteValidations()
	var temp any = service
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (service *SearchService) ValidateUpdate(old runtime.Object) error {
	validations := service.updateValidations()
	var temp any = service
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (service *SearchService) createValidations() []func() error {
	return []func() error{service.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (service *SearchService) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (service *SearchService) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return service.validateResourceReferences()
		},
		service.validateWriteOnceProperties}
}

// validateResourceReferences validates all resource references
func (service *SearchService) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&service.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (service *SearchService) validateWriteOnceProperties(old runtime.Object) error {
	oldObj, ok := old.(*SearchService)
	if !ok {
		return nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, service)
}

// AssignProperties_From_SearchService populates our SearchService from the provided source SearchService
func (service *SearchService) AssignProperties_From_SearchService(source *v1api20220901s.SearchService) error {

	// ObjectMeta
	service.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec SearchService_Spec
	err := spec.AssignProperties_From_SearchService_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_SearchService_Spec() to populate field Spec")
	}
	service.Spec = spec

	// Status
	var status SearchService_STATUS
	err = status.AssignProperties_From_SearchService_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_SearchService_STATUS() to populate field Status")
	}
	service.Status = status

	// No error
	return nil
}

// AssignProperties_To_SearchService populates the provided destination SearchService from our SearchService
func (service *SearchService) AssignProperties_To_SearchService(destination *v1api20220901s.SearchService) error {

	// ObjectMeta
	destination.ObjectMeta = *service.ObjectMeta.DeepCopy()

	// Spec
	var spec v1api20220901s.SearchService_Spec
	err := service.Spec.AssignProperties_To_SearchService_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_SearchService_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v1api20220901s.SearchService_STATUS
	err = service.Status.AssignProperties_To_SearchService_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_SearchService_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (service *SearchService) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: service.Spec.OriginalVersion(),
		Kind:    "SearchService",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /search/resource-manager/Microsoft.Search/stable/2022-09-01/search.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Search/searchServices/{searchServiceName}
type SearchServiceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []SearchService `json:"items"`
}

// +kubebuilder:validation:Enum={"2022-09-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2022-09-01")

type SearchService_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// DisableLocalAuth: When set to true, calls to the search service will not be permitted to utilize API keys for
	// authentication. This cannot be set to true if 'dataPlaneAuthOptions' are defined.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// EncryptionWithCmk: Specifies any policy regarding encryption of resources (such as indexes) using customer manager keys
	// within a search service.
	EncryptionWithCmk *EncryptionWithCmk `json:"encryptionWithCmk,omitempty"`

	// HostingMode: Applicable only for the standard3 SKU. You can set this property to enable up to 3 high density partitions
	// that allow up to 1000 indexes, which is much higher than the maximum indexes allowed for any other SKU. For the
	// standard3 SKU, the value is either 'default' or 'highDensity'. For all other SKUs, this value must be 'default'.
	HostingMode *SearchServiceProperties_HostingMode `json:"hostingMode,omitempty"`

	// Identity: The identity of the resource.
	Identity *Identity `json:"identity,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// NetworkRuleSet: Network specific rules that determine how the Azure Cognitive Search service may be reached.
	NetworkRuleSet *NetworkRuleSet `json:"networkRuleSet,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// +kubebuilder:validation:Maximum=12
	// +kubebuilder:validation:Minimum=1
	// PartitionCount: The number of partitions in the search service; if specified, it can be 1, 2, 3, 4, 6, or 12. Values
	// greater than 1 are only valid for standard SKUs. For 'standard3' services with hostingMode set to 'highDensity', the
	// allowed values are between 1 and 3.
	PartitionCount *int `json:"partitionCount,omitempty"`

	// PublicNetworkAccess: This value can be set to 'enabled' to avoid breaking changes on existing customer resources and
	// templates. If set to 'disabled', traffic over public interface is not allowed, and private endpoint connections would be
	// the exclusive access method.
	PublicNetworkAccess *SearchServiceProperties_PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// +kubebuilder:validation:Maximum=12
	// +kubebuilder:validation:Minimum=1
	// ReplicaCount: The number of replicas in the search service. If specified, it must be a value between 1 and 12 inclusive
	// for standard SKUs or between 1 and 3 inclusive for basic SKU.
	ReplicaCount *int `json:"replicaCount,omitempty"`

	// Sku: The SKU of the Search Service, which determines price tier and capacity limits. This property is required when
	// creating a new Search Service.
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &SearchService_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (service *SearchService_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if service == nil {
		return nil, nil
	}
	result := &SearchService_Spec_ARM{}

	// Set property ‘Identity’:
	if service.Identity != nil {
		identity_ARM, err := (*service.Identity).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		identity := *identity_ARM.(*Identity_ARM)
		result.Identity = &identity
	}

	// Set property ‘Location’:
	if service.Location != nil {
		location := *service.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if service.DisableLocalAuth != nil ||
		service.EncryptionWithCmk != nil ||
		service.HostingMode != nil ||
		service.NetworkRuleSet != nil ||
		service.PartitionCount != nil ||
		service.PublicNetworkAccess != nil ||
		service.ReplicaCount != nil {
		result.Properties = &SearchServiceProperties_ARM{}
	}
	if service.DisableLocalAuth != nil {
		disableLocalAuth := *service.DisableLocalAuth
		result.Properties.DisableLocalAuth = &disableLocalAuth
	}
	if service.EncryptionWithCmk != nil {
		encryptionWithCmk_ARM, err := (*service.EncryptionWithCmk).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		encryptionWithCmk := *encryptionWithCmk_ARM.(*EncryptionWithCmk_ARM)
		result.Properties.EncryptionWithCmk = &encryptionWithCmk
	}
	if service.HostingMode != nil {
		hostingMode := *service.HostingMode
		result.Properties.HostingMode = &hostingMode
	}
	if service.NetworkRuleSet != nil {
		networkRuleSet_ARM, err := (*service.NetworkRuleSet).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		networkRuleSet := *networkRuleSet_ARM.(*NetworkRuleSet_ARM)
		result.Properties.NetworkRuleSet = &networkRuleSet
	}
	if service.PartitionCount != nil {
		partitionCount := *service.PartitionCount
		result.Properties.PartitionCount = &partitionCount
	}
	if service.PublicNetworkAccess != nil {
		publicNetworkAccess := *service.PublicNetworkAccess
		result.Properties.PublicNetworkAccess = &publicNetworkAccess
	}
	if service.ReplicaCount != nil {
		replicaCount := *service.ReplicaCount
		result.Properties.ReplicaCount = &replicaCount
	}

	// Set property ‘Sku’:
	if service.Sku != nil {
		sku_ARM, err := (*service.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *sku_ARM.(*Sku_ARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if service.Tags != nil {
		result.Tags = make(map[string]string, len(service.Tags))
		for key, value := range service.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (service *SearchService_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SearchService_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (service *SearchService_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SearchService_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SearchService_Spec_ARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	service.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘DisableLocalAuth’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableLocalAuth != nil {
			disableLocalAuth := *typedInput.Properties.DisableLocalAuth
			service.DisableLocalAuth = &disableLocalAuth
		}
	}

	// Set property ‘EncryptionWithCmk’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionWithCmk != nil {
			var encryptionWithCmk1 EncryptionWithCmk
			err := encryptionWithCmk1.PopulateFromARM(owner, *typedInput.Properties.EncryptionWithCmk)
			if err != nil {
				return err
			}
			encryptionWithCmk := encryptionWithCmk1
			service.EncryptionWithCmk = &encryptionWithCmk
		}
	}

	// Set property ‘HostingMode’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostingMode != nil {
			hostingMode := *typedInput.Properties.HostingMode
			service.HostingMode = &hostingMode
		}
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 Identity
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		service.Identity = &identity
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		service.Location = &location
	}

	// Set property ‘NetworkRuleSet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkRuleSet != nil {
			var networkRuleSet1 NetworkRuleSet
			err := networkRuleSet1.PopulateFromARM(owner, *typedInput.Properties.NetworkRuleSet)
			if err != nil {
				return err
			}
			networkRuleSet := networkRuleSet1
			service.NetworkRuleSet = &networkRuleSet
		}
	}

	// Set property ‘Owner’:
	service.Owner = &genruntime.KnownResourceReference{Name: owner.Name}

	// Set property ‘PartitionCount’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PartitionCount != nil {
			partitionCount := *typedInput.Properties.PartitionCount
			service.PartitionCount = &partitionCount
		}
	}

	// Set property ‘PublicNetworkAccess’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			publicNetworkAccess := *typedInput.Properties.PublicNetworkAccess
			service.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property ‘ReplicaCount’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReplicaCount != nil {
			replicaCount := *typedInput.Properties.ReplicaCount
			service.ReplicaCount = &replicaCount
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		service.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		service.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			service.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &SearchService_Spec{}

// ConvertSpecFrom populates our SearchService_Spec from the provided source
func (service *SearchService_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v1api20220901s.SearchService_Spec)
	if ok {
		// Populate our instance from source
		return service.AssignProperties_From_SearchService_Spec(src)
	}

	// Convert to an intermediate form
	src = &v1api20220901s.SearchService_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = service.AssignProperties_From_SearchService_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our SearchService_Spec
func (service *SearchService_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v1api20220901s.SearchService_Spec)
	if ok {
		// Populate destination from our instance
		return service.AssignProperties_To_SearchService_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v1api20220901s.SearchService_Spec{}
	err := service.AssignProperties_To_SearchService_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_SearchService_Spec populates our SearchService_Spec from the provided source SearchService_Spec
func (service *SearchService_Spec) AssignProperties_From_SearchService_Spec(source *v1api20220901s.SearchService_Spec) error {

	// AzureName
	service.AzureName = source.AzureName

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		service.DisableLocalAuth = &disableLocalAuth
	} else {
		service.DisableLocalAuth = nil
	}

	// EncryptionWithCmk
	if source.EncryptionWithCmk != nil {
		var encryptionWithCmk EncryptionWithCmk
		err := encryptionWithCmk.AssignProperties_From_EncryptionWithCmk(source.EncryptionWithCmk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EncryptionWithCmk() to populate field EncryptionWithCmk")
		}
		service.EncryptionWithCmk = &encryptionWithCmk
	} else {
		service.EncryptionWithCmk = nil
	}

	// HostingMode
	if source.HostingMode != nil {
		hostingMode := SearchServiceProperties_HostingMode(*source.HostingMode)
		service.HostingMode = &hostingMode
	} else {
		service.HostingMode = nil
	}

	// Identity
	if source.Identity != nil {
		var identity Identity
		err := identity.AssignProperties_From_Identity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Identity() to populate field Identity")
		}
		service.Identity = &identity
	} else {
		service.Identity = nil
	}

	// Location
	service.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkRuleSet
	if source.NetworkRuleSet != nil {
		var networkRuleSet NetworkRuleSet
		err := networkRuleSet.AssignProperties_From_NetworkRuleSet(source.NetworkRuleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkRuleSet() to populate field NetworkRuleSet")
		}
		service.NetworkRuleSet = &networkRuleSet
	} else {
		service.NetworkRuleSet = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		service.Owner = &owner
	} else {
		service.Owner = nil
	}

	// PartitionCount
	if source.PartitionCount != nil {
		partitionCount := *source.PartitionCount
		service.PartitionCount = &partitionCount
	} else {
		service.PartitionCount = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := SearchServiceProperties_PublicNetworkAccess(*source.PublicNetworkAccess)
		service.PublicNetworkAccess = &publicNetworkAccess
	} else {
		service.PublicNetworkAccess = nil
	}

	// ReplicaCount
	if source.ReplicaCount != nil {
		replicaCount := *source.ReplicaCount
		service.ReplicaCount = &replicaCount
	} else {
		service.ReplicaCount = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignProperties_From_Sku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku() to populate field Sku")
		}
		service.Sku = &sku
	} else {
		service.Sku = nil
	}

	// Tags
	service.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignProperties_To_SearchService_Spec populates the provided destination SearchService_Spec from our SearchService_Spec
func (service *SearchService_Spec) AssignProperties_To_SearchService_Spec(destination *v1api20220901s.SearchService_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = service.AzureName

	// DisableLocalAuth
	if service.DisableLocalAuth != nil {
		disableLocalAuth := *service.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// EncryptionWithCmk
	if service.EncryptionWithCmk != nil {
		var encryptionWithCmk v1api20220901s.EncryptionWithCmk
		err := service.EncryptionWithCmk.AssignProperties_To_EncryptionWithCmk(&encryptionWithCmk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EncryptionWithCmk() to populate field EncryptionWithCmk")
		}
		destination.EncryptionWithCmk = &encryptionWithCmk
	} else {
		destination.EncryptionWithCmk = nil
	}

	// HostingMode
	if service.HostingMode != nil {
		hostingMode := string(*service.HostingMode)
		destination.HostingMode = &hostingMode
	} else {
		destination.HostingMode = nil
	}

	// Identity
	if service.Identity != nil {
		var identity v1api20220901s.Identity
		err := service.Identity.AssignProperties_To_Identity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Identity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(service.Location)

	// NetworkRuleSet
	if service.NetworkRuleSet != nil {
		var networkRuleSet v1api20220901s.NetworkRuleSet
		err := service.NetworkRuleSet.AssignProperties_To_NetworkRuleSet(&networkRuleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkRuleSet() to populate field NetworkRuleSet")
		}
		destination.NetworkRuleSet = &networkRuleSet
	} else {
		destination.NetworkRuleSet = nil
	}

	// OriginalVersion
	destination.OriginalVersion = service.OriginalVersion()

	// Owner
	if service.Owner != nil {
		owner := service.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PartitionCount
	if service.PartitionCount != nil {
		partitionCount := *service.PartitionCount
		destination.PartitionCount = &partitionCount
	} else {
		destination.PartitionCount = nil
	}

	// PublicNetworkAccess
	if service.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*service.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// ReplicaCount
	if service.ReplicaCount != nil {
		replicaCount := *service.ReplicaCount
		destination.ReplicaCount = &replicaCount
	} else {
		destination.ReplicaCount = nil
	}

	// Sku
	if service.Sku != nil {
		var sku v1api20220901s.Sku
		err := service.Sku.AssignProperties_To_Sku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(service.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SearchService_STATUS populates our SearchService_Spec from the provided source SearchService_STATUS
func (service *SearchService_Spec) Initialize_From_SearchService_STATUS(source *SearchService_STATUS) error {

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		service.DisableLocalAuth = &disableLocalAuth
	} else {
		service.DisableLocalAuth = nil
	}

	// EncryptionWithCmk
	if source.EncryptionWithCmk != nil {
		var encryptionWithCmk EncryptionWithCmk
		err := encryptionWithCmk.Initialize_From_EncryptionWithCmk_STATUS(source.EncryptionWithCmk)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_EncryptionWithCmk_STATUS() to populate field EncryptionWithCmk")
		}
		service.EncryptionWithCmk = &encryptionWithCmk
	} else {
		service.EncryptionWithCmk = nil
	}

	// HostingMode
	if source.HostingMode != nil {
		hostingMode := SearchServiceProperties_HostingMode(*source.HostingMode)
		service.HostingMode = &hostingMode
	} else {
		service.HostingMode = nil
	}

	// Identity
	if source.Identity != nil {
		var identity Identity
		err := identity.Initialize_From_Identity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Identity_STATUS() to populate field Identity")
		}
		service.Identity = &identity
	} else {
		service.Identity = nil
	}

	// Location
	service.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkRuleSet
	if source.NetworkRuleSet != nil {
		var networkRuleSet NetworkRuleSet
		err := networkRuleSet.Initialize_From_NetworkRuleSet_STATUS(source.NetworkRuleSet)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_NetworkRuleSet_STATUS() to populate field NetworkRuleSet")
		}
		service.NetworkRuleSet = &networkRuleSet
	} else {
		service.NetworkRuleSet = nil
	}

	// PartitionCount
	if source.PartitionCount != nil {
		partitionCount := *source.PartitionCount
		service.PartitionCount = &partitionCount
	} else {
		service.PartitionCount = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := SearchServiceProperties_PublicNetworkAccess(*source.PublicNetworkAccess)
		service.PublicNetworkAccess = &publicNetworkAccess
	} else {
		service.PublicNetworkAccess = nil
	}

	// ReplicaCount
	if source.ReplicaCount != nil {
		replicaCount := *source.ReplicaCount
		service.ReplicaCount = &replicaCount
	} else {
		service.ReplicaCount = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.Initialize_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_Sku_STATUS() to populate field Sku")
		}
		service.Sku = &sku
	} else {
		service.Sku = nil
	}

	// Tags
	service.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (service *SearchService_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (service *SearchService_Spec) SetAzureName(azureName string) { service.AzureName = azureName }

// Describes an Azure Cognitive Search service and its current state.
type SearchService_STATUS struct {
	// AuthOptions: Defines the options for how the data plane API of a search service authenticates requests. This cannot be
	// set if 'disableLocalAuth' is set to true.
	AuthOptions *DataPlaneAuthOptions_STATUS `json:"authOptions,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// DisableLocalAuth: When set to true, calls to the search service will not be permitted to utilize API keys for
	// authentication. This cannot be set to true if 'dataPlaneAuthOptions' are defined.
	DisableLocalAuth *bool `json:"disableLocalAuth,omitempty"`

	// EncryptionWithCmk: Specifies any policy regarding encryption of resources (such as indexes) using customer manager keys
	// within a search service.
	EncryptionWithCmk *EncryptionWithCmk_STATUS `json:"encryptionWithCmk,omitempty"`

	// HostingMode: Applicable only for the standard3 SKU. You can set this property to enable up to 3 high density partitions
	// that allow up to 1000 indexes, which is much higher than the maximum indexes allowed for any other SKU. For the
	// standard3 SKU, the value is either 'default' or 'highDensity'. For all other SKUs, this value must be 'default'.
	HostingMode *SearchServiceProperties_HostingMode_STATUS `json:"hostingMode,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Identity: The identity of the resource.
	Identity *Identity_STATUS `json:"identity,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// NetworkRuleSet: Network specific rules that determine how the Azure Cognitive Search service may be reached.
	NetworkRuleSet *NetworkRuleSet_STATUS `json:"networkRuleSet,omitempty"`

	// PartitionCount: The number of partitions in the search service; if specified, it can be 1, 2, 3, 4, 6, or 12. Values
	// greater than 1 are only valid for standard SKUs. For 'standard3' services with hostingMode set to 'highDensity', the
	// allowed values are between 1 and 3.
	PartitionCount *int `json:"partitionCount,omitempty"`

	// PrivateEndpointConnections: The list of private endpoint connections to the Azure Cognitive Search service.
	PrivateEndpointConnections []PrivateEndpointConnection_STATUS `json:"privateEndpointConnections,omitempty"`

	// ProvisioningState: The state of the last provisioning operation performed on the search service. Provisioning is an
	// intermediate state that occurs while service capacity is being established. After capacity is set up, provisioningState
	// changes to either 'succeeded' or 'failed'. Client applications can poll provisioning status (the recommended polling
	// interval is from 30 seconds to one minute) by using the Get Search Service operation to see when an operation is
	// completed. If you are using the free service, this value tends to come back as 'succeeded' directly in the call to
	// Create search service. This is because the free service uses capacity that is already set up.
	ProvisioningState *SearchServiceProperties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// PublicNetworkAccess: This value can be set to 'enabled' to avoid breaking changes on existing customer resources and
	// templates. If set to 'disabled', traffic over public interface is not allowed, and private endpoint connections would be
	// the exclusive access method.
	PublicNetworkAccess *SearchServiceProperties_PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`

	// ReplicaCount: The number of replicas in the search service. If specified, it must be a value between 1 and 12 inclusive
	// for standard SKUs or between 1 and 3 inclusive for basic SKU.
	ReplicaCount *int `json:"replicaCount,omitempty"`

	// SharedPrivateLinkResources: The list of shared private link resources managed by the Azure Cognitive Search service.
	SharedPrivateLinkResources []SharedPrivateLinkResource_STATUS `json:"sharedPrivateLinkResources,omitempty"`

	// Sku: The SKU of the Search Service, which determines price tier and capacity limits. This property is required when
	// creating a new Search Service.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// Status: The status of the search service. Possible values include: 'running': The search service is running and no
	// provisioning operations are underway. 'provisioning': The search service is being provisioned or scaled up or down.
	// 'deleting': The search service is being deleted. 'degraded': The search service is degraded. This can occur when the
	// underlying search units are not healthy. The search service is most likely operational, but performance might be slow
	// and some requests might be dropped. 'disabled': The search service is disabled. In this state, the service will reject
	// all API requests. 'error': The search service is in an error state. If your service is in the degraded, disabled, or
	// error states, it means the Azure Cognitive Search team is actively investigating the underlying issue. Dedicated
	// services in these states are still chargeable based on the number of search units provisioned.
	Status *SearchServiceProperties_Status_STATUS `json:"status,omitempty"`

	// StatusDetails: The details of the search service status.
	StatusDetails *string `json:"statusDetails,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &SearchService_STATUS{}

// ConvertStatusFrom populates our SearchService_STATUS from the provided source
func (service *SearchService_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v1api20220901s.SearchService_STATUS)
	if ok {
		// Populate our instance from source
		return service.AssignProperties_From_SearchService_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v1api20220901s.SearchService_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = service.AssignProperties_From_SearchService_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our SearchService_STATUS
func (service *SearchService_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v1api20220901s.SearchService_STATUS)
	if ok {
		// Populate destination from our instance
		return service.AssignProperties_To_SearchService_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v1api20220901s.SearchService_STATUS{}
	err := service.AssignProperties_To_SearchService_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &SearchService_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (service *SearchService_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SearchService_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (service *SearchService_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SearchService_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SearchService_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘AuthOptions’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AuthOptions != nil {
			var authOptions1 DataPlaneAuthOptions_STATUS
			err := authOptions1.PopulateFromARM(owner, *typedInput.Properties.AuthOptions)
			if err != nil {
				return err
			}
			authOptions := authOptions1
			service.AuthOptions = &authOptions
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘DisableLocalAuth’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DisableLocalAuth != nil {
			disableLocalAuth := *typedInput.Properties.DisableLocalAuth
			service.DisableLocalAuth = &disableLocalAuth
		}
	}

	// Set property ‘EncryptionWithCmk’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EncryptionWithCmk != nil {
			var encryptionWithCmk1 EncryptionWithCmk_STATUS
			err := encryptionWithCmk1.PopulateFromARM(owner, *typedInput.Properties.EncryptionWithCmk)
			if err != nil {
				return err
			}
			encryptionWithCmk := encryptionWithCmk1
			service.EncryptionWithCmk = &encryptionWithCmk
		}
	}

	// Set property ‘HostingMode’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostingMode != nil {
			hostingMode := *typedInput.Properties.HostingMode
			service.HostingMode = &hostingMode
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		service.Id = &id
	}

	// Set property ‘Identity’:
	if typedInput.Identity != nil {
		var identity1 Identity_STATUS
		err := identity1.PopulateFromARM(owner, *typedInput.Identity)
		if err != nil {
			return err
		}
		identity := identity1
		service.Identity = &identity
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		service.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		service.Name = &name
	}

	// Set property ‘NetworkRuleSet’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.NetworkRuleSet != nil {
			var networkRuleSet1 NetworkRuleSet_STATUS
			err := networkRuleSet1.PopulateFromARM(owner, *typedInput.Properties.NetworkRuleSet)
			if err != nil {
				return err
			}
			networkRuleSet := networkRuleSet1
			service.NetworkRuleSet = &networkRuleSet
		}
	}

	// Set property ‘PartitionCount’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PartitionCount != nil {
			partitionCount := *typedInput.Properties.PartitionCount
			service.PartitionCount = &partitionCount
		}
	}

	// Set property ‘PrivateEndpointConnections’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateEndpointConnections {
			var item1 PrivateEndpointConnection_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			service.PrivateEndpointConnections = append(service.PrivateEndpointConnections, item1)
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			service.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘PublicNetworkAccess’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			publicNetworkAccess := *typedInput.Properties.PublicNetworkAccess
			service.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property ‘ReplicaCount’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReplicaCount != nil {
			replicaCount := *typedInput.Properties.ReplicaCount
			service.ReplicaCount = &replicaCount
		}
	}

	// Set property ‘SharedPrivateLinkResources’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.SharedPrivateLinkResources {
			var item1 SharedPrivateLinkResource_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			service.SharedPrivateLinkResources = append(service.SharedPrivateLinkResources, item1)
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		service.Sku = &sku
	}

	// Set property ‘Status’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Status != nil {
			status := *typedInput.Properties.Status
			service.Status = &status
		}
	}

	// Set property ‘StatusDetails’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StatusDetails != nil {
			statusDetails := *typedInput.Properties.StatusDetails
			service.StatusDetails = &statusDetails
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		service.Tags = make(map[string]string, len(typedInput.Tags))
		for key, value := range typedInput.Tags {
			service.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		service.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_SearchService_STATUS populates our SearchService_STATUS from the provided source SearchService_STATUS
func (service *SearchService_STATUS) AssignProperties_From_SearchService_STATUS(source *v1api20220901s.SearchService_STATUS) error {

	// AuthOptions
	if source.AuthOptions != nil {
		var authOption DataPlaneAuthOptions_STATUS
		err := authOption.AssignProperties_From_DataPlaneAuthOptions_STATUS(source.AuthOptions)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataPlaneAuthOptions_STATUS() to populate field AuthOptions")
		}
		service.AuthOptions = &authOption
	} else {
		service.AuthOptions = nil
	}

	// Conditions
	service.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DisableLocalAuth
	if source.DisableLocalAuth != nil {
		disableLocalAuth := *source.DisableLocalAuth
		service.DisableLocalAuth = &disableLocalAuth
	} else {
		service.DisableLocalAuth = nil
	}

	// EncryptionWithCmk
	if source.EncryptionWithCmk != nil {
		var encryptionWithCmk EncryptionWithCmk_STATUS
		err := encryptionWithCmk.AssignProperties_From_EncryptionWithCmk_STATUS(source.EncryptionWithCmk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EncryptionWithCmk_STATUS() to populate field EncryptionWithCmk")
		}
		service.EncryptionWithCmk = &encryptionWithCmk
	} else {
		service.EncryptionWithCmk = nil
	}

	// HostingMode
	if source.HostingMode != nil {
		hostingMode := SearchServiceProperties_HostingMode_STATUS(*source.HostingMode)
		service.HostingMode = &hostingMode
	} else {
		service.HostingMode = nil
	}

	// Id
	service.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity Identity_STATUS
		err := identity.AssignProperties_From_Identity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Identity_STATUS() to populate field Identity")
		}
		service.Identity = &identity
	} else {
		service.Identity = nil
	}

	// Location
	service.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	service.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkRuleSet
	if source.NetworkRuleSet != nil {
		var networkRuleSet NetworkRuleSet_STATUS
		err := networkRuleSet.AssignProperties_From_NetworkRuleSet_STATUS(source.NetworkRuleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_NetworkRuleSet_STATUS() to populate field NetworkRuleSet")
		}
		service.NetworkRuleSet = &networkRuleSet
	} else {
		service.NetworkRuleSet = nil
	}

	// PartitionCount
	service.PartitionCount = genruntime.ClonePointerToInt(source.PartitionCount)

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]PrivateEndpointConnection_STATUS, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection PrivateEndpointConnection_STATUS
			err := privateEndpointConnection.AssignProperties_From_PrivateEndpointConnection_STATUS(&privateEndpointConnectionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		service.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		service.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := SearchServiceProperties_ProvisioningState_STATUS(*source.ProvisioningState)
		service.ProvisioningState = &provisioningState
	} else {
		service.ProvisioningState = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := SearchServiceProperties_PublicNetworkAccess_STATUS(*source.PublicNetworkAccess)
		service.PublicNetworkAccess = &publicNetworkAccess
	} else {
		service.PublicNetworkAccess = nil
	}

	// ReplicaCount
	service.ReplicaCount = genruntime.ClonePointerToInt(source.ReplicaCount)

	// SharedPrivateLinkResources
	if source.SharedPrivateLinkResources != nil {
		sharedPrivateLinkResourceList := make([]SharedPrivateLinkResource_STATUS, len(source.SharedPrivateLinkResources))
		for sharedPrivateLinkResourceIndex, sharedPrivateLinkResourceItem := range source.SharedPrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			sharedPrivateLinkResourceItem := sharedPrivateLinkResourceItem
			var sharedPrivateLinkResource SharedPrivateLinkResource_STATUS
			err := sharedPrivateLinkResource.AssignProperties_From_SharedPrivateLinkResource_STATUS(&sharedPrivateLinkResourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_SharedPrivateLinkResource_STATUS() to populate field SharedPrivateLinkResources")
			}
			sharedPrivateLinkResourceList[sharedPrivateLinkResourceIndex] = sharedPrivateLinkResource
		}
		service.SharedPrivateLinkResources = sharedPrivateLinkResourceList
	} else {
		service.SharedPrivateLinkResources = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignProperties_From_Sku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_Sku_STATUS() to populate field Sku")
		}
		service.Sku = &sku
	} else {
		service.Sku = nil
	}

	// Status
	if source.Status != nil {
		status := SearchServiceProperties_Status_STATUS(*source.Status)
		service.Status = &status
	} else {
		service.Status = nil
	}

	// StatusDetails
	service.StatusDetails = genruntime.ClonePointerToString(source.StatusDetails)

	// Tags
	service.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	service.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_SearchService_STATUS populates the provided destination SearchService_STATUS from our SearchService_STATUS
func (service *SearchService_STATUS) AssignProperties_To_SearchService_STATUS(destination *v1api20220901s.SearchService_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AuthOptions
	if service.AuthOptions != nil {
		var authOption v1api20220901s.DataPlaneAuthOptions_STATUS
		err := service.AuthOptions.AssignProperties_To_DataPlaneAuthOptions_STATUS(&authOption)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataPlaneAuthOptions_STATUS() to populate field AuthOptions")
		}
		destination.AuthOptions = &authOption
	} else {
		destination.AuthOptions = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(service.Conditions)

	// DisableLocalAuth
	if service.DisableLocalAuth != nil {
		disableLocalAuth := *service.DisableLocalAuth
		destination.DisableLocalAuth = &disableLocalAuth
	} else {
		destination.DisableLocalAuth = nil
	}

	// EncryptionWithCmk
	if service.EncryptionWithCmk != nil {
		var encryptionWithCmk v1api20220901s.EncryptionWithCmk_STATUS
		err := service.EncryptionWithCmk.AssignProperties_To_EncryptionWithCmk_STATUS(&encryptionWithCmk)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EncryptionWithCmk_STATUS() to populate field EncryptionWithCmk")
		}
		destination.EncryptionWithCmk = &encryptionWithCmk
	} else {
		destination.EncryptionWithCmk = nil
	}

	// HostingMode
	if service.HostingMode != nil {
		hostingMode := string(*service.HostingMode)
		destination.HostingMode = &hostingMode
	} else {
		destination.HostingMode = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(service.Id)

	// Identity
	if service.Identity != nil {
		var identity v1api20220901s.Identity_STATUS
		err := service.Identity.AssignProperties_To_Identity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Identity_STATUS() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(service.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(service.Name)

	// NetworkRuleSet
	if service.NetworkRuleSet != nil {
		var networkRuleSet v1api20220901s.NetworkRuleSet_STATUS
		err := service.NetworkRuleSet.AssignProperties_To_NetworkRuleSet_STATUS(&networkRuleSet)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_NetworkRuleSet_STATUS() to populate field NetworkRuleSet")
		}
		destination.NetworkRuleSet = &networkRuleSet
	} else {
		destination.NetworkRuleSet = nil
	}

	// PartitionCount
	destination.PartitionCount = genruntime.ClonePointerToInt(service.PartitionCount)

	// PrivateEndpointConnections
	if service.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]v1api20220901s.PrivateEndpointConnection_STATUS, len(service.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range service.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection v1api20220901s.PrivateEndpointConnection_STATUS
			err := privateEndpointConnectionItem.AssignProperties_To_PrivateEndpointConnection_STATUS(&privateEndpointConnection)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_PrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// ProvisioningState
	if service.ProvisioningState != nil {
		provisioningState := string(*service.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// PublicNetworkAccess
	if service.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*service.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// ReplicaCount
	destination.ReplicaCount = genruntime.ClonePointerToInt(service.ReplicaCount)

	// SharedPrivateLinkResources
	if service.SharedPrivateLinkResources != nil {
		sharedPrivateLinkResourceList := make([]v1api20220901s.SharedPrivateLinkResource_STATUS, len(service.SharedPrivateLinkResources))
		for sharedPrivateLinkResourceIndex, sharedPrivateLinkResourceItem := range service.SharedPrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			sharedPrivateLinkResourceItem := sharedPrivateLinkResourceItem
			var sharedPrivateLinkResource v1api20220901s.SharedPrivateLinkResource_STATUS
			err := sharedPrivateLinkResourceItem.AssignProperties_To_SharedPrivateLinkResource_STATUS(&sharedPrivateLinkResource)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_SharedPrivateLinkResource_STATUS() to populate field SharedPrivateLinkResources")
			}
			sharedPrivateLinkResourceList[sharedPrivateLinkResourceIndex] = sharedPrivateLinkResource
		}
		destination.SharedPrivateLinkResources = sharedPrivateLinkResourceList
	} else {
		destination.SharedPrivateLinkResources = nil
	}

	// Sku
	if service.Sku != nil {
		var sku v1api20220901s.Sku_STATUS
		err := service.Sku.AssignProperties_To_Sku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_Sku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Status
	if service.Status != nil {
		status := string(*service.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// StatusDetails
	destination.StatusDetails = genruntime.ClonePointerToString(service.StatusDetails)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(service.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(service.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the options for how the data plane API of a Search service authenticates requests. This cannot be set if
// 'disableLocalAuth' is set to true.
type DataPlaneAuthOptions_STATUS struct {
	// AadOrApiKey: Indicates that either the API key or an access token from Azure Active Directory can be used for
	// authentication.
	AadOrApiKey *DataPlaneAadOrApiKeyAuthOption_STATUS `json:"aadOrApiKey,omitempty"`

	// ApiKeyOnly: Indicates that only the API key needs to be used for authentication.
	ApiKeyOnly map[string]v1.JSON `json:"apiKeyOnly,omitempty"`
}

var _ genruntime.FromARMConverter = &DataPlaneAuthOptions_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (options *DataPlaneAuthOptions_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DataPlaneAuthOptions_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (options *DataPlaneAuthOptions_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DataPlaneAuthOptions_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DataPlaneAuthOptions_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘AadOrApiKey’:
	if typedInput.AadOrApiKey != nil {
		var aadOrApiKey1 DataPlaneAadOrApiKeyAuthOption_STATUS
		err := aadOrApiKey1.PopulateFromARM(owner, *typedInput.AadOrApiKey)
		if err != nil {
			return err
		}
		aadOrApiKey := aadOrApiKey1
		options.AadOrApiKey = &aadOrApiKey
	}

	// Set property ‘ApiKeyOnly’:
	if typedInput.ApiKeyOnly != nil {
		options.ApiKeyOnly = make(map[string]v1.JSON, len(typedInput.ApiKeyOnly))
		for key, value := range typedInput.ApiKeyOnly {
			options.ApiKeyOnly[key] = *value.DeepCopy()
		}
	}

	// No error
	return nil
}

// AssignProperties_From_DataPlaneAuthOptions_STATUS populates our DataPlaneAuthOptions_STATUS from the provided source DataPlaneAuthOptions_STATUS
func (options *DataPlaneAuthOptions_STATUS) AssignProperties_From_DataPlaneAuthOptions_STATUS(source *v1api20220901s.DataPlaneAuthOptions_STATUS) error {

	// AadOrApiKey
	if source.AadOrApiKey != nil {
		var aadOrApiKey DataPlaneAadOrApiKeyAuthOption_STATUS
		err := aadOrApiKey.AssignProperties_From_DataPlaneAadOrApiKeyAuthOption_STATUS(source.AadOrApiKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DataPlaneAadOrApiKeyAuthOption_STATUS() to populate field AadOrApiKey")
		}
		options.AadOrApiKey = &aadOrApiKey
	} else {
		options.AadOrApiKey = nil
	}

	// ApiKeyOnly
	if source.ApiKeyOnly != nil {
		apiKeyOnlyMap := make(map[string]v1.JSON, len(source.ApiKeyOnly))
		for apiKeyOnlyKey, apiKeyOnlyValue := range source.ApiKeyOnly {
			// Shadow the loop variable to avoid aliasing
			apiKeyOnlyValue := apiKeyOnlyValue
			apiKeyOnlyMap[apiKeyOnlyKey] = *apiKeyOnlyValue.DeepCopy()
		}
		options.ApiKeyOnly = apiKeyOnlyMap
	} else {
		options.ApiKeyOnly = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataPlaneAuthOptions_STATUS populates the provided destination DataPlaneAuthOptions_STATUS from our DataPlaneAuthOptions_STATUS
func (options *DataPlaneAuthOptions_STATUS) AssignProperties_To_DataPlaneAuthOptions_STATUS(destination *v1api20220901s.DataPlaneAuthOptions_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadOrApiKey
	if options.AadOrApiKey != nil {
		var aadOrApiKey v1api20220901s.DataPlaneAadOrApiKeyAuthOption_STATUS
		err := options.AadOrApiKey.AssignProperties_To_DataPlaneAadOrApiKeyAuthOption_STATUS(&aadOrApiKey)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DataPlaneAadOrApiKeyAuthOption_STATUS() to populate field AadOrApiKey")
		}
		destination.AadOrApiKey = &aadOrApiKey
	} else {
		destination.AadOrApiKey = nil
	}

	// ApiKeyOnly
	if options.ApiKeyOnly != nil {
		apiKeyOnlyMap := make(map[string]v1.JSON, len(options.ApiKeyOnly))
		for apiKeyOnlyKey, apiKeyOnlyValue := range options.ApiKeyOnly {
			// Shadow the loop variable to avoid aliasing
			apiKeyOnlyValue := apiKeyOnlyValue
			apiKeyOnlyMap[apiKeyOnlyKey] = *apiKeyOnlyValue.DeepCopy()
		}
		destination.ApiKeyOnly = apiKeyOnlyMap
	} else {
		destination.ApiKeyOnly = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes a policy that determines how resources within the search service are to be encrypted with Customer Managed
// Keys.
type EncryptionWithCmk struct {
	// Enforcement: Describes how a search service should enforce having one or more non customer encrypted resources.
	Enforcement *EncryptionWithCmk_Enforcement `json:"enforcement,omitempty"`
}

var _ genruntime.ARMTransformer = &EncryptionWithCmk{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (withCmk *EncryptionWithCmk) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if withCmk == nil {
		return nil, nil
	}
	result := &EncryptionWithCmk_ARM{}

	// Set property ‘Enforcement’:
	if withCmk.Enforcement != nil {
		enforcement := *withCmk.Enforcement
		result.Enforcement = &enforcement
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (withCmk *EncryptionWithCmk) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EncryptionWithCmk_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (withCmk *EncryptionWithCmk) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EncryptionWithCmk_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EncryptionWithCmk_ARM, got %T", armInput)
	}

	// Set property ‘Enforcement’:
	if typedInput.Enforcement != nil {
		enforcement := *typedInput.Enforcement
		withCmk.Enforcement = &enforcement
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionWithCmk populates our EncryptionWithCmk from the provided source EncryptionWithCmk
func (withCmk *EncryptionWithCmk) AssignProperties_From_EncryptionWithCmk(source *v1api20220901s.EncryptionWithCmk) error {

	// Enforcement
	if source.Enforcement != nil {
		enforcement := EncryptionWithCmk_Enforcement(*source.Enforcement)
		withCmk.Enforcement = &enforcement
	} else {
		withCmk.Enforcement = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionWithCmk populates the provided destination EncryptionWithCmk from our EncryptionWithCmk
func (withCmk *EncryptionWithCmk) AssignProperties_To_EncryptionWithCmk(destination *v1api20220901s.EncryptionWithCmk) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enforcement
	if withCmk.Enforcement != nil {
		enforcement := string(*withCmk.Enforcement)
		destination.Enforcement = &enforcement
	} else {
		destination.Enforcement = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_EncryptionWithCmk_STATUS populates our EncryptionWithCmk from the provided source EncryptionWithCmk_STATUS
func (withCmk *EncryptionWithCmk) Initialize_From_EncryptionWithCmk_STATUS(source *EncryptionWithCmk_STATUS) error {

	// Enforcement
	if source.Enforcement != nil {
		enforcement := EncryptionWithCmk_Enforcement(*source.Enforcement)
		withCmk.Enforcement = &enforcement
	} else {
		withCmk.Enforcement = nil
	}

	// No error
	return nil
}

// Describes a policy that determines how resources within the search service are to be encrypted with Customer Managed
// Keys.
type EncryptionWithCmk_STATUS struct {
	// EncryptionComplianceStatus: Describes whether the search service is compliant or not with respect to having non customer
	// encrypted resources. If a service has more than one non customer encrypted resource and 'Enforcement' is 'enabled' then
	// the service will be marked as 'nonCompliant'.
	EncryptionComplianceStatus *EncryptionWithCmk_EncryptionComplianceStatus_STATUS `json:"encryptionComplianceStatus,omitempty"`

	// Enforcement: Describes how a search service should enforce having one or more non customer encrypted resources.
	Enforcement *EncryptionWithCmk_Enforcement_STATUS `json:"enforcement,omitempty"`
}

var _ genruntime.FromARMConverter = &EncryptionWithCmk_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (withCmk *EncryptionWithCmk_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EncryptionWithCmk_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (withCmk *EncryptionWithCmk_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EncryptionWithCmk_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EncryptionWithCmk_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘EncryptionComplianceStatus’:
	if typedInput.EncryptionComplianceStatus != nil {
		encryptionComplianceStatus := *typedInput.EncryptionComplianceStatus
		withCmk.EncryptionComplianceStatus = &encryptionComplianceStatus
	}

	// Set property ‘Enforcement’:
	if typedInput.Enforcement != nil {
		enforcement := *typedInput.Enforcement
		withCmk.Enforcement = &enforcement
	}

	// No error
	return nil
}

// AssignProperties_From_EncryptionWithCmk_STATUS populates our EncryptionWithCmk_STATUS from the provided source EncryptionWithCmk_STATUS
func (withCmk *EncryptionWithCmk_STATUS) AssignProperties_From_EncryptionWithCmk_STATUS(source *v1api20220901s.EncryptionWithCmk_STATUS) error {

	// EncryptionComplianceStatus
	if source.EncryptionComplianceStatus != nil {
		encryptionComplianceStatus := EncryptionWithCmk_EncryptionComplianceStatus_STATUS(*source.EncryptionComplianceStatus)
		withCmk.EncryptionComplianceStatus = &encryptionComplianceStatus
	} else {
		withCmk.EncryptionComplianceStatus = nil
	}

	// Enforcement
	if source.Enforcement != nil {
		enforcement := EncryptionWithCmk_Enforcement_STATUS(*source.Enforcement)
		withCmk.Enforcement = &enforcement
	} else {
		withCmk.Enforcement = nil
	}

	// No error
	return nil
}

// AssignProperties_To_EncryptionWithCmk_STATUS populates the provided destination EncryptionWithCmk_STATUS from our EncryptionWithCmk_STATUS
func (withCmk *EncryptionWithCmk_STATUS) AssignProperties_To_EncryptionWithCmk_STATUS(destination *v1api20220901s.EncryptionWithCmk_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// EncryptionComplianceStatus
	if withCmk.EncryptionComplianceStatus != nil {
		encryptionComplianceStatus := string(*withCmk.EncryptionComplianceStatus)
		destination.EncryptionComplianceStatus = &encryptionComplianceStatus
	} else {
		destination.EncryptionComplianceStatus = nil
	}

	// Enforcement
	if withCmk.Enforcement != nil {
		enforcement := string(*withCmk.Enforcement)
		destination.Enforcement = &enforcement
	} else {
		destination.Enforcement = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type Identity struct {
	// +kubebuilder:validation:Required
	// Type: The identity type.
	Type *Identity_Type `json:"type,omitempty"`
}

var _ genruntime.ARMTransformer = &Identity{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identity *Identity) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identity == nil {
		return nil, nil
	}
	result := &Identity_ARM{}

	// Set property ‘Type’:
	if identity.Type != nil {
		typeVar := *identity.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *Identity) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Identity_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *Identity) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Identity_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Identity_ARM, got %T", armInput)
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Identity populates our Identity from the provided source Identity
func (identity *Identity) AssignProperties_From_Identity(source *v1api20220901s.Identity) error {

	// Type
	if source.Type != nil {
		typeVar := Identity_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Identity populates the provided destination Identity from our Identity
func (identity *Identity) AssignProperties_To_Identity(destination *v1api20220901s.Identity) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Identity_STATUS populates our Identity from the provided source Identity_STATUS
func (identity *Identity) Initialize_From_Identity_STATUS(source *Identity_STATUS) error {

	// Type
	if source.Type != nil {
		typeVar := Identity_Type(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// Identity for the resource.
type Identity_STATUS struct {
	// PrincipalId: The principal ID of the system-assigned identity of the search service.
	PrincipalId *string `json:"principalId,omitempty"`

	// TenantId: The tenant ID of the system-assigned identity of the search service.
	TenantId *string `json:"tenantId,omitempty"`

	// Type: The identity type.
	Type *Identity_Type_STATUS `json:"type,omitempty"`
}

var _ genruntime.FromARMConverter = &Identity_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identity *Identity_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Identity_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identity *Identity_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Identity_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Identity_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘PrincipalId’:
	if typedInput.PrincipalId != nil {
		principalId := *typedInput.PrincipalId
		identity.PrincipalId = &principalId
	}

	// Set property ‘TenantId’:
	if typedInput.TenantId != nil {
		tenantId := *typedInput.TenantId
		identity.TenantId = &tenantId
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		identity.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Identity_STATUS populates our Identity_STATUS from the provided source Identity_STATUS
func (identity *Identity_STATUS) AssignProperties_From_Identity_STATUS(source *v1api20220901s.Identity_STATUS) error {

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	if source.Type != nil {
		typeVar := Identity_Type_STATUS(*source.Type)
		identity.Type = &typeVar
	} else {
		identity.Type = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Identity_STATUS populates the provided destination Identity_STATUS from our Identity_STATUS
func (identity *Identity_STATUS) AssignProperties_To_Identity_STATUS(destination *v1api20220901s.Identity_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	if identity.Type != nil {
		typeVar := string(*identity.Type)
		destination.Type = &typeVar
	} else {
		destination.Type = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Network specific rules that determine how the Azure Cognitive Search service may be reached.
type NetworkRuleSet struct {
	// IpRules: A list of IP restriction rules that defines the inbound network(s) with allowing access to the search service
	// endpoint. At the meantime, all other public IP networks are blocked by the firewall. These restriction rules are applied
	// only when the 'publicNetworkAccess' of the search service is 'enabled'; otherwise, traffic over public interface is not
	// allowed even with any public IP rules, and private endpoint connections would be the exclusive access method.
	IpRules []IpRule `json:"ipRules,omitempty"`
}

var _ genruntime.ARMTransformer = &NetworkRuleSet{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (ruleSet *NetworkRuleSet) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if ruleSet == nil {
		return nil, nil
	}
	result := &NetworkRuleSet_ARM{}

	// Set property ‘IpRules’:
	for _, item := range ruleSet.IpRules {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.IpRules = append(result.IpRules, *item_ARM.(*IpRule_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *NetworkRuleSet) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkRuleSet_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *NetworkRuleSet) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkRuleSet_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkRuleSet_ARM, got %T", armInput)
	}

	// Set property ‘IpRules’:
	for _, item := range typedInput.IpRules {
		var item1 IpRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.IpRules = append(ruleSet.IpRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkRuleSet populates our NetworkRuleSet from the provided source NetworkRuleSet
func (ruleSet *NetworkRuleSet) AssignProperties_From_NetworkRuleSet(source *v1api20220901s.NetworkRuleSet) error {

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IpRule, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule IpRule
			err := ipRule.AssignProperties_From_IpRule(&ipRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IpRule() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		ruleSet.IpRules = ipRuleList
	} else {
		ruleSet.IpRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkRuleSet populates the provided destination NetworkRuleSet from our NetworkRuleSet
func (ruleSet *NetworkRuleSet) AssignProperties_To_NetworkRuleSet(destination *v1api20220901s.NetworkRuleSet) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpRules
	if ruleSet.IpRules != nil {
		ipRuleList := make([]v1api20220901s.IpRule, len(ruleSet.IpRules))
		for ipRuleIndex, ipRuleItem := range ruleSet.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule v1api20220901s.IpRule
			err := ipRuleItem.AssignProperties_To_IpRule(&ipRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IpRule() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		destination.IpRules = ipRuleList
	} else {
		destination.IpRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_NetworkRuleSet_STATUS populates our NetworkRuleSet from the provided source NetworkRuleSet_STATUS
func (ruleSet *NetworkRuleSet) Initialize_From_NetworkRuleSet_STATUS(source *NetworkRuleSet_STATUS) error {

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IpRule, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule IpRule
			err := ipRule.Initialize_From_IpRule_STATUS(&ipRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_IpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		ruleSet.IpRules = ipRuleList
	} else {
		ruleSet.IpRules = nil
	}

	// No error
	return nil
}

// Network specific rules that determine how the Azure Cognitive Search service may be reached.
type NetworkRuleSet_STATUS struct {
	// IpRules: A list of IP restriction rules that defines the inbound network(s) with allowing access to the search service
	// endpoint. At the meantime, all other public IP networks are blocked by the firewall. These restriction rules are applied
	// only when the 'publicNetworkAccess' of the search service is 'enabled'; otherwise, traffic over public interface is not
	// allowed even with any public IP rules, and private endpoint connections would be the exclusive access method.
	IpRules []IpRule_STATUS `json:"ipRules,omitempty"`
}

var _ genruntime.FromARMConverter = &NetworkRuleSet_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (ruleSet *NetworkRuleSet_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &NetworkRuleSet_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (ruleSet *NetworkRuleSet_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(NetworkRuleSet_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected NetworkRuleSet_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘IpRules’:
	for _, item := range typedInput.IpRules {
		var item1 IpRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		ruleSet.IpRules = append(ruleSet.IpRules, item1)
	}

	// No error
	return nil
}

// AssignProperties_From_NetworkRuleSet_STATUS populates our NetworkRuleSet_STATUS from the provided source NetworkRuleSet_STATUS
func (ruleSet *NetworkRuleSet_STATUS) AssignProperties_From_NetworkRuleSet_STATUS(source *v1api20220901s.NetworkRuleSet_STATUS) error {

	// IpRules
	if source.IpRules != nil {
		ipRuleList := make([]IpRule_STATUS, len(source.IpRules))
		for ipRuleIndex, ipRuleItem := range source.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule IpRule_STATUS
			err := ipRule.AssignProperties_From_IpRule_STATUS(&ipRuleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_IpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		ruleSet.IpRules = ipRuleList
	} else {
		ruleSet.IpRules = nil
	}

	// No error
	return nil
}

// AssignProperties_To_NetworkRuleSet_STATUS populates the provided destination NetworkRuleSet_STATUS from our NetworkRuleSet_STATUS
func (ruleSet *NetworkRuleSet_STATUS) AssignProperties_To_NetworkRuleSet_STATUS(destination *v1api20220901s.NetworkRuleSet_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// IpRules
	if ruleSet.IpRules != nil {
		ipRuleList := make([]v1api20220901s.IpRule_STATUS, len(ruleSet.IpRules))
		for ipRuleIndex, ipRuleItem := range ruleSet.IpRules {
			// Shadow the loop variable to avoid aliasing
			ipRuleItem := ipRuleItem
			var ipRule v1api20220901s.IpRule_STATUS
			err := ipRuleItem.AssignProperties_To_IpRule_STATUS(&ipRule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_IpRule_STATUS() to populate field IpRules")
			}
			ipRuleList[ipRuleIndex] = ipRule
		}
		destination.IpRules = ipRuleList
	} else {
		destination.IpRules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Describes an existing Private Endpoint connection to the Azure Cognitive Search service.
type PrivateEndpointConnection_STATUS struct {
	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *PrivateEndpointConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateEndpointConnection_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *PrivateEndpointConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PrivateEndpointConnection_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateEndpointConnection_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_PrivateEndpointConnection_STATUS populates our PrivateEndpointConnection_STATUS from the provided source PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_From_PrivateEndpointConnection_STATUS(source *v1api20220901s.PrivateEndpointConnection_STATUS) error {

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_PrivateEndpointConnection_STATUS populates the provided destination PrivateEndpointConnection_STATUS from our PrivateEndpointConnection_STATUS
func (connection *PrivateEndpointConnection_STATUS) AssignProperties_To_PrivateEndpointConnection_STATUS(destination *v1api20220901s.PrivateEndpointConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"default","highDensity"}
type SearchServiceProperties_HostingMode string

const (
	SearchServiceProperties_HostingMode_Default     = SearchServiceProperties_HostingMode("default")
	SearchServiceProperties_HostingMode_HighDensity = SearchServiceProperties_HostingMode("highDensity")
)

type SearchServiceProperties_HostingMode_STATUS string

const (
	SearchServiceProperties_HostingMode_STATUS_Default     = SearchServiceProperties_HostingMode_STATUS("default")
	SearchServiceProperties_HostingMode_STATUS_HighDensity = SearchServiceProperties_HostingMode_STATUS("highDensity")
)

type SearchServiceProperties_ProvisioningState_STATUS string

const (
	SearchServiceProperties_ProvisioningState_STATUS_Failed       = SearchServiceProperties_ProvisioningState_STATUS("failed")
	SearchServiceProperties_ProvisioningState_STATUS_Provisioning = SearchServiceProperties_ProvisioningState_STATUS("provisioning")
	SearchServiceProperties_ProvisioningState_STATUS_Succeeded    = SearchServiceProperties_ProvisioningState_STATUS("succeeded")
)

// +kubebuilder:validation:Enum={"disabled","enabled"}
type SearchServiceProperties_PublicNetworkAccess string

const (
	SearchServiceProperties_PublicNetworkAccess_Disabled = SearchServiceProperties_PublicNetworkAccess("disabled")
	SearchServiceProperties_PublicNetworkAccess_Enabled  = SearchServiceProperties_PublicNetworkAccess("enabled")
)

type SearchServiceProperties_PublicNetworkAccess_STATUS string

const (
	SearchServiceProperties_PublicNetworkAccess_STATUS_Disabled = SearchServiceProperties_PublicNetworkAccess_STATUS("disabled")
	SearchServiceProperties_PublicNetworkAccess_STATUS_Enabled  = SearchServiceProperties_PublicNetworkAccess_STATUS("enabled")
)

type SearchServiceProperties_Status_STATUS string

const (
	SearchServiceProperties_Status_STATUS_Degraded     = SearchServiceProperties_Status_STATUS("degraded")
	SearchServiceProperties_Status_STATUS_Deleting     = SearchServiceProperties_Status_STATUS("deleting")
	SearchServiceProperties_Status_STATUS_Disabled     = SearchServiceProperties_Status_STATUS("disabled")
	SearchServiceProperties_Status_STATUS_Error        = SearchServiceProperties_Status_STATUS("error")
	SearchServiceProperties_Status_STATUS_Provisioning = SearchServiceProperties_Status_STATUS("provisioning")
	SearchServiceProperties_Status_STATUS_Running      = SearchServiceProperties_Status_STATUS("running")
	SearchServiceProperties_Status_STATUS_Stopped      = SearchServiceProperties_Status_STATUS("stopped")
)

// Describes a Shared Private Link Resource managed by the Azure Cognitive Search service.
type SharedPrivateLinkResource_STATUS struct {
	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &SharedPrivateLinkResource_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (resource *SharedPrivateLinkResource_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SharedPrivateLinkResource_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (resource *SharedPrivateLinkResource_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SharedPrivateLinkResource_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SharedPrivateLinkResource_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		resource.Id = &id
	}

	// No error
	return nil
}

// AssignProperties_From_SharedPrivateLinkResource_STATUS populates our SharedPrivateLinkResource_STATUS from the provided source SharedPrivateLinkResource_STATUS
func (resource *SharedPrivateLinkResource_STATUS) AssignProperties_From_SharedPrivateLinkResource_STATUS(source *v1api20220901s.SharedPrivateLinkResource_STATUS) error {

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignProperties_To_SharedPrivateLinkResource_STATUS populates the provided destination SharedPrivateLinkResource_STATUS from our SharedPrivateLinkResource_STATUS
func (resource *SharedPrivateLinkResource_STATUS) AssignProperties_To_SharedPrivateLinkResource_STATUS(destination *v1api20220901s.SharedPrivateLinkResource_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the SKU of an Azure Cognitive Search Service, which determines price tier and capacity limits.
type Sku struct {
	// Name: The SKU of the search service. Valid values include: 'free': Shared service. 'basic': Dedicated service with up to
	// 3 replicas. 'standard': Dedicated service with up to 12 partitions and 12 replicas. 'standard2': Similar to standard,
	// but with more capacity per search unit. 'standard3': The largest Standard offering with up to 12 partitions and 12
	// replicas (or up to 3 partitions with more indexes if you also set the hostingMode property to 'highDensity').
	// 'storage_optimized_l1': Supports 1TB per partition, up to 12 partitions. 'storage_optimized_l2': Supports 2TB per
	// partition, up to 12 partitions.'
	Name *Sku_Name `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &Sku_ARM{}

	// Set property ‘Name’:
	if sku.Name != nil {
		name := *sku.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_ARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_Sku populates our Sku from the provided source Sku
func (sku *Sku) AssignProperties_From_Sku(source *v1api20220901s.Sku) error {

	// Name
	if source.Name != nil {
		name := Sku_Name(*source.Name)
		sku.Name = &name
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku populates the provided destination Sku from our Sku
func (sku *Sku) AssignProperties_To_Sku(destination *v1api20220901s.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if sku.Name != nil {
		name := string(*sku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Sku_STATUS populates our Sku from the provided source Sku_STATUS
func (sku *Sku) Initialize_From_Sku_STATUS(source *Sku_STATUS) error {

	// Name
	if source.Name != nil {
		name := Sku_Name(*source.Name)
		sku.Name = &name
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// Defines the SKU of an Azure Cognitive Search Service, which determines price tier and capacity limits.
type Sku_STATUS struct {
	// Name: The SKU of the search service. Valid values include: 'free': Shared service. 'basic': Dedicated service with up to
	// 3 replicas. 'standard': Dedicated service with up to 12 partitions and 12 replicas. 'standard2': Similar to standard,
	// but with more capacity per search unit. 'standard3': The largest Standard offering with up to 12 partitions and 12
	// replicas (or up to 3 partitions with more indexes if you also set the hostingMode property to 'highDensity').
	// 'storage_optimized_l1': Supports 1TB per partition, up to 12 partitions. 'storage_optimized_l2': Supports 2TB per
	// partition, up to 12 partitions.'
	Name *Sku_Name_STATUS `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// No error
	return nil
}

// AssignProperties_From_Sku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_From_Sku_STATUS(source *v1api20220901s.Sku_STATUS) error {

	// Name
	if source.Name != nil {
		name := Sku_Name_STATUS(*source.Name)
		sku.Name = &name
	} else {
		sku.Name = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Sku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignProperties_To_Sku_STATUS(destination *v1api20220901s.Sku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if sku.Name != nil {
		name := string(*sku.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Indicates that either the API key or an access token from Azure Active Directory can be used for authentication.
type DataPlaneAadOrApiKeyAuthOption_STATUS struct {
	// AadAuthFailureMode: Describes what response the data plane API of a Search service would send for requests that failed
	// authentication.
	AadAuthFailureMode *DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS `json:"aadAuthFailureMode,omitempty"`
}

var _ genruntime.FromARMConverter = &DataPlaneAadOrApiKeyAuthOption_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (option *DataPlaneAadOrApiKeyAuthOption_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DataPlaneAadOrApiKeyAuthOption_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (option *DataPlaneAadOrApiKeyAuthOption_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DataPlaneAadOrApiKeyAuthOption_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DataPlaneAadOrApiKeyAuthOption_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘AadAuthFailureMode’:
	if typedInput.AadAuthFailureMode != nil {
		aadAuthFailureMode := *typedInput.AadAuthFailureMode
		option.AadAuthFailureMode = &aadAuthFailureMode
	}

	// No error
	return nil
}

// AssignProperties_From_DataPlaneAadOrApiKeyAuthOption_STATUS populates our DataPlaneAadOrApiKeyAuthOption_STATUS from the provided source DataPlaneAadOrApiKeyAuthOption_STATUS
func (option *DataPlaneAadOrApiKeyAuthOption_STATUS) AssignProperties_From_DataPlaneAadOrApiKeyAuthOption_STATUS(source *v1api20220901s.DataPlaneAadOrApiKeyAuthOption_STATUS) error {

	// AadAuthFailureMode
	if source.AadAuthFailureMode != nil {
		aadAuthFailureMode := DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS(*source.AadAuthFailureMode)
		option.AadAuthFailureMode = &aadAuthFailureMode
	} else {
		option.AadAuthFailureMode = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DataPlaneAadOrApiKeyAuthOption_STATUS populates the provided destination DataPlaneAadOrApiKeyAuthOption_STATUS from our DataPlaneAadOrApiKeyAuthOption_STATUS
func (option *DataPlaneAadOrApiKeyAuthOption_STATUS) AssignProperties_To_DataPlaneAadOrApiKeyAuthOption_STATUS(destination *v1api20220901s.DataPlaneAadOrApiKeyAuthOption_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AadAuthFailureMode
	if option.AadAuthFailureMode != nil {
		aadAuthFailureMode := string(*option.AadAuthFailureMode)
		destination.AadAuthFailureMode = &aadAuthFailureMode
	} else {
		destination.AadAuthFailureMode = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EncryptionWithCmk_EncryptionComplianceStatus_STATUS string

const (
	EncryptionWithCmk_EncryptionComplianceStatus_STATUS_Compliant    = EncryptionWithCmk_EncryptionComplianceStatus_STATUS("Compliant")
	EncryptionWithCmk_EncryptionComplianceStatus_STATUS_NonCompliant = EncryptionWithCmk_EncryptionComplianceStatus_STATUS("NonCompliant")
)

// +kubebuilder:validation:Enum={"Disabled","Enabled","Unspecified"}
type EncryptionWithCmk_Enforcement string

const (
	EncryptionWithCmk_Enforcement_Disabled    = EncryptionWithCmk_Enforcement("Disabled")
	EncryptionWithCmk_Enforcement_Enabled     = EncryptionWithCmk_Enforcement("Enabled")
	EncryptionWithCmk_Enforcement_Unspecified = EncryptionWithCmk_Enforcement("Unspecified")
)

type EncryptionWithCmk_Enforcement_STATUS string

const (
	EncryptionWithCmk_Enforcement_STATUS_Disabled    = EncryptionWithCmk_Enforcement_STATUS("Disabled")
	EncryptionWithCmk_Enforcement_STATUS_Enabled     = EncryptionWithCmk_Enforcement_STATUS("Enabled")
	EncryptionWithCmk_Enforcement_STATUS_Unspecified = EncryptionWithCmk_Enforcement_STATUS("Unspecified")
)

// The IP restriction rule of the Azure Cognitive Search service.
type IpRule struct {
	// Value: Value corresponding to a single IPv4 address (eg., 123.1.2.3) or an IP range in CIDR format (eg., 123.1.2.3/24)
	// to be allowed.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &IpRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *IpRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &IpRule_ARM{}

	// Set property ‘Value’:
	if rule.Value != nil {
		value := *rule.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *IpRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IpRule_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *IpRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IpRule_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IpRule_ARM, got %T", armInput)
	}

	// Set property ‘Value’:
	if typedInput.Value != nil {
		value := *typedInput.Value
		rule.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_IpRule populates our IpRule from the provided source IpRule
func (rule *IpRule) AssignProperties_From_IpRule(source *v1api20220901s.IpRule) error {

	// Value
	rule.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_IpRule populates the provided destination IpRule from our IpRule
func (rule *IpRule) AssignProperties_To_IpRule(destination *v1api20220901s.IpRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	destination.Value = genruntime.ClonePointerToString(rule.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IpRule_STATUS populates our IpRule from the provided source IpRule_STATUS
func (rule *IpRule) Initialize_From_IpRule_STATUS(source *IpRule_STATUS) error {

	// Value
	rule.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// The IP restriction rule of the Azure Cognitive Search service.
type IpRule_STATUS struct {
	// Value: Value corresponding to a single IPv4 address (eg., 123.1.2.3) or an IP range in CIDR format (eg., 123.1.2.3/24)
	// to be allowed.
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &IpRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *IpRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IpRule_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *IpRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IpRule_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IpRule_STATUS_ARM, got %T", armInput)
	}

	// Set property ‘Value’:
	if typedInput.Value != nil {
		value := *typedInput.Value
		rule.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_IpRule_STATUS populates our IpRule_STATUS from the provided source IpRule_STATUS
func (rule *IpRule_STATUS) AssignProperties_From_IpRule_STATUS(source *v1api20220901s.IpRule_STATUS) error {

	// Value
	rule.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_IpRule_STATUS populates the provided destination IpRule_STATUS from our IpRule_STATUS
func (rule *IpRule_STATUS) AssignProperties_To_IpRule_STATUS(destination *v1api20220901s.IpRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Value
	destination.Value = genruntime.ClonePointerToString(rule.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS string

const (
	DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS_Http401WithBearerChallenge = DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS("http401WithBearerChallenge")
	DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS_Http403                    = DataPlaneAadOrApiKeyAuthOption_AadAuthFailureMode_STATUS("http403")
)

func init() {
	SchemeBuilder.Register(&SearchService{}, &SearchServiceList{})
}
