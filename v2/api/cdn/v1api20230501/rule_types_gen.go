// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20230501

import (
	"fmt"
	v20230501s "github.com/Azure/azure-service-operator/v2/api/cdn/v1api20230501/storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /cdn/resource-manager/Microsoft.Cdn/stable/2023-05-01/afdx.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/ruleSets/{ruleSetName}/rules/{ruleName}
type Rule struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Profiles_RuleSets_Rule_Spec   `json:"spec,omitempty"`
	Status            Profiles_RuleSets_Rule_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Rule{}

// GetConditions returns the conditions of the resource
func (rule *Rule) GetConditions() conditions.Conditions {
	return rule.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (rule *Rule) SetConditions(conditions conditions.Conditions) {
	rule.Status.Conditions = conditions
}

var _ conversion.Convertible = &Rule{}

// ConvertFrom populates our Rule from the provided hub Rule
func (rule *Rule) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20230501s.Rule)
	if !ok {
		return fmt.Errorf("expected cdn/v1api20230501/storage/Rule but received %T instead", hub)
	}

	return rule.AssignProperties_From_Rule(source)
}

// ConvertTo populates the provided hub Rule from our Rule
func (rule *Rule) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20230501s.Rule)
	if !ok {
		return fmt.Errorf("expected cdn/v1api20230501/storage/Rule but received %T instead", hub)
	}

	return rule.AssignProperties_To_Rule(destination)
}

// +kubebuilder:webhook:path=/mutate-cdn-azure-com-v1api20230501-rule,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=cdn.azure.com,resources=rules,verbs=create;update,versions=v1api20230501,name=default.v1api20230501.rules.cdn.azure.com,admissionReviewVersions=v1

var _ admission.Defaulter = &Rule{}

// Default applies defaults to the Rule resource
func (rule *Rule) Default() {
	rule.defaultImpl()
	var temp any = rule
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (rule *Rule) defaultAzureName() {
	if rule.Spec.AzureName == "" {
		rule.Spec.AzureName = rule.Name
	}
}

// defaultImpl applies the code generated defaults to the Rule resource
func (rule *Rule) defaultImpl() { rule.defaultAzureName() }

var _ genruntime.ImportableResource = &Rule{}

// InitializeSpec initializes the spec for this resource from the given status
func (rule *Rule) InitializeSpec(status genruntime.ConvertibleStatus) error {
	if s, ok := status.(*Profiles_RuleSets_Rule_STATUS); ok {
		return rule.Spec.Initialize_From_Profiles_RuleSets_Rule_STATUS(s)
	}

	return fmt.Errorf("expected Status of type Profiles_RuleSets_Rule_STATUS but received %T instead", status)
}

var _ genruntime.KubernetesResource = &Rule{}

// AzureName returns the Azure name of the resource
func (rule *Rule) AzureName() string {
	return rule.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-05-01"
func (rule Rule) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (rule *Rule) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (rule *Rule) GetSpec() genruntime.ConvertibleSpec {
	return &rule.Spec
}

// GetStatus returns the status of this resource
func (rule *Rule) GetStatus() genruntime.ConvertibleStatus {
	return &rule.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (rule *Rule) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Cdn/profiles/ruleSets/rules"
func (rule *Rule) GetType() string {
	return "Microsoft.Cdn/profiles/ruleSets/rules"
}

// NewEmptyStatus returns a new empty (blank) status
func (rule *Rule) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Profiles_RuleSets_Rule_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (rule *Rule) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(rule.Spec)
	return rule.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (rule *Rule) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Profiles_RuleSets_Rule_STATUS); ok {
		rule.Status = *st
		return nil
	}

	// Convert status to required version
	var st Profiles_RuleSets_Rule_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	rule.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-cdn-azure-com-v1api20230501-rule,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=cdn.azure.com,resources=rules,verbs=create;update,versions=v1api20230501,name=validate.v1api20230501.rules.cdn.azure.com,admissionReviewVersions=v1

var _ admission.Validator = &Rule{}

// ValidateCreate validates the creation of the resource
func (rule *Rule) ValidateCreate() (admission.Warnings, error) {
	validations := rule.createValidations()
	var temp any = rule
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	return genruntime.ValidateCreate(validations)
}

// ValidateDelete validates the deletion of the resource
func (rule *Rule) ValidateDelete() (admission.Warnings, error) {
	validations := rule.deleteValidations()
	var temp any = rule
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	return genruntime.ValidateDelete(validations)
}

// ValidateUpdate validates an update of the resource
func (rule *Rule) ValidateUpdate(old runtime.Object) (admission.Warnings, error) {
	validations := rule.updateValidations()
	var temp any = rule
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	return genruntime.ValidateUpdate(old, validations)
}

// createValidations validates the creation of the resource
func (rule *Rule) createValidations() []func() (admission.Warnings, error) {
	return []func() (admission.Warnings, error){rule.validateResourceReferences, rule.validateOwnerReference}
}

// deleteValidations validates the deletion of the resource
func (rule *Rule) deleteValidations() []func() (admission.Warnings, error) {
	return nil
}

// updateValidations validates the update of the resource
func (rule *Rule) updateValidations() []func(old runtime.Object) (admission.Warnings, error) {
	return []func(old runtime.Object) (admission.Warnings, error){
		func(old runtime.Object) (admission.Warnings, error) {
			return rule.validateResourceReferences()
		},
		rule.validateWriteOnceProperties,
		func(old runtime.Object) (admission.Warnings, error) {
			return rule.validateOwnerReference()
		},
	}
}

// validateOwnerReference validates the owner field
func (rule *Rule) validateOwnerReference() (admission.Warnings, error) {
	return genruntime.ValidateOwner(rule)
}

// validateResourceReferences validates all resource references
func (rule *Rule) validateResourceReferences() (admission.Warnings, error) {
	refs, err := reflecthelpers.FindResourceReferences(&rule.Spec)
	if err != nil {
		return nil, err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (rule *Rule) validateWriteOnceProperties(old runtime.Object) (admission.Warnings, error) {
	oldObj, ok := old.(*Rule)
	if !ok {
		return nil, nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, rule)
}

// AssignProperties_From_Rule populates our Rule from the provided source Rule
func (rule *Rule) AssignProperties_From_Rule(source *v20230501s.Rule) error {

	// ObjectMeta
	rule.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Profiles_RuleSets_Rule_Spec
	err := spec.AssignProperties_From_Profiles_RuleSets_Rule_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Profiles_RuleSets_Rule_Spec() to populate field Spec")
	}
	rule.Spec = spec

	// Status
	var status Profiles_RuleSets_Rule_STATUS
	err = status.AssignProperties_From_Profiles_RuleSets_Rule_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Profiles_RuleSets_Rule_STATUS() to populate field Status")
	}
	rule.Status = status

	// No error
	return nil
}

// AssignProperties_To_Rule populates the provided destination Rule from our Rule
func (rule *Rule) AssignProperties_To_Rule(destination *v20230501s.Rule) error {

	// ObjectMeta
	destination.ObjectMeta = *rule.ObjectMeta.DeepCopy()

	// Spec
	var spec v20230501s.Profiles_RuleSets_Rule_Spec
	err := rule.Spec.AssignProperties_To_Profiles_RuleSets_Rule_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Profiles_RuleSets_Rule_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20230501s.Profiles_RuleSets_Rule_STATUS
	err = rule.Status.AssignProperties_To_Profiles_RuleSets_Rule_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Profiles_RuleSets_Rule_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (rule *Rule) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: rule.Spec.OriginalVersion(),
		Kind:    "Rule",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /cdn/resource-manager/Microsoft.Cdn/stable/2023-05-01/afdx.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cdn/profiles/{profileName}/ruleSets/{ruleSetName}/rules/{ruleName}
type RuleList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Rule `json:"items"`
}

type Profiles_RuleSets_Rule_Spec struct {
	// Actions: A list of actions that are executed when all the conditions of a rule are satisfied.
	Actions []DeliveryRuleAction `json:"actions,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// MatchProcessingBehavior: If this rule is a match should the rules engine continue running the remaining rules or stop.
	// If not present, defaults to Continue.
	MatchProcessingBehavior *RuleProperties_MatchProcessingBehavior `json:"matchProcessingBehavior,omitempty"`

	// Order: The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A rule with a
	// lesser order will be applied before a rule with a greater order. Rule with order 0 is a special rule. It does not
	// require any condition and actions listed in it will always be applied.
	Order *int `json:"order,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a cdn.azure.com/RuleSet resource
	Owner *genruntime.KnownResourceReference `group:"cdn.azure.com" json:"owner,omitempty" kind:"RuleSet"`

	// RuleConditions: A list of conditions that must be matched for the actions to be executed
	RuleConditions []DeliveryRuleCondition `json:"ruleconditions,omitempty"`
}

var _ genruntime.ARMTransformer = &Profiles_RuleSets_Rule_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *Profiles_RuleSets_Rule_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &Profiles_RuleSets_Rule_Spec_ARM{}

	// Set property "Name":
	result.Name = resolved.Name

	// Set property "Properties":
	if rule.Actions != nil ||
		rule.MatchProcessingBehavior != nil ||
		rule.Order != nil ||
		rule.RuleConditions != nil {
		result.Properties = &RuleProperties_ARM{}
	}
	for _, item := range rule.Actions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Actions = append(result.Properties.Actions, *item_ARM.(*DeliveryRuleAction_ARM))
	}
	if rule.MatchProcessingBehavior != nil {
		matchProcessingBehavior := *rule.MatchProcessingBehavior
		result.Properties.MatchProcessingBehavior = &matchProcessingBehavior
	}
	if rule.Order != nil {
		order := *rule.Order
		result.Properties.Order = &order
	}
	for _, item := range rule.RuleConditions {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Conditions = append(result.Properties.Conditions, *item_ARM.(*DeliveryRuleCondition_ARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *Profiles_RuleSets_Rule_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Profiles_RuleSets_Rule_Spec_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *Profiles_RuleSets_Rule_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Profiles_RuleSets_Rule_Spec_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Profiles_RuleSets_Rule_Spec_ARM, got %T", armInput)
	}

	// Set property "Actions":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Actions {
			var item1 DeliveryRuleAction
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			rule.Actions = append(rule.Actions, item1)
		}
	}

	// Set property "AzureName":
	rule.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property "MatchProcessingBehavior":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MatchProcessingBehavior != nil {
			matchProcessingBehavior := *typedInput.Properties.MatchProcessingBehavior
			rule.MatchProcessingBehavior = &matchProcessingBehavior
		}
	}

	// Set property "Order":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Order != nil {
			order := *typedInput.Properties.Order
			rule.Order = &order
		}
	}

	// Set property "Owner":
	rule.Owner = &genruntime.KnownResourceReference{
		Name:  owner.Name,
		ARMID: owner.ARMID,
	}

	// Set property "RuleConditions":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Conditions {
			var item1 DeliveryRuleCondition
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			rule.RuleConditions = append(rule.RuleConditions, item1)
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Profiles_RuleSets_Rule_Spec{}

// ConvertSpecFrom populates our Profiles_RuleSets_Rule_Spec from the provided source
func (rule *Profiles_RuleSets_Rule_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20230501s.Profiles_RuleSets_Rule_Spec)
	if ok {
		// Populate our instance from source
		return rule.AssignProperties_From_Profiles_RuleSets_Rule_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20230501s.Profiles_RuleSets_Rule_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = rule.AssignProperties_From_Profiles_RuleSets_Rule_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Profiles_RuleSets_Rule_Spec
func (rule *Profiles_RuleSets_Rule_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20230501s.Profiles_RuleSets_Rule_Spec)
	if ok {
		// Populate destination from our instance
		return rule.AssignProperties_To_Profiles_RuleSets_Rule_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20230501s.Profiles_RuleSets_Rule_Spec{}
	err := rule.AssignProperties_To_Profiles_RuleSets_Rule_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Profiles_RuleSets_Rule_Spec populates our Profiles_RuleSets_Rule_Spec from the provided source Profiles_RuleSets_Rule_Spec
func (rule *Profiles_RuleSets_Rule_Spec) AssignProperties_From_Profiles_RuleSets_Rule_Spec(source *v20230501s.Profiles_RuleSets_Rule_Spec) error {

	// Actions
	if source.Actions != nil {
		actionList := make([]DeliveryRuleAction, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action DeliveryRuleAction
			err := action.AssignProperties_From_DeliveryRuleAction(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleAction() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		rule.Actions = actionList
	} else {
		rule.Actions = nil
	}

	// AzureName
	rule.AzureName = source.AzureName

	// MatchProcessingBehavior
	if source.MatchProcessingBehavior != nil {
		matchProcessingBehavior := RuleProperties_MatchProcessingBehavior(*source.MatchProcessingBehavior)
		rule.MatchProcessingBehavior = &matchProcessingBehavior
	} else {
		rule.MatchProcessingBehavior = nil
	}

	// Order
	rule.Order = genruntime.ClonePointerToInt(source.Order)

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		rule.Owner = &owner
	} else {
		rule.Owner = nil
	}

	// RuleConditions
	if source.RuleConditions != nil {
		ruleConditionList := make([]DeliveryRuleCondition, len(source.RuleConditions))
		for ruleConditionIndex, ruleConditionItem := range source.RuleConditions {
			// Shadow the loop variable to avoid aliasing
			ruleConditionItem := ruleConditionItem
			var ruleCondition DeliveryRuleCondition
			err := ruleCondition.AssignProperties_From_DeliveryRuleCondition(&ruleConditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCondition() to populate field RuleConditions")
			}
			ruleConditionList[ruleConditionIndex] = ruleCondition
		}
		rule.RuleConditions = ruleConditionList
	} else {
		rule.RuleConditions = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Profiles_RuleSets_Rule_Spec populates the provided destination Profiles_RuleSets_Rule_Spec from our Profiles_RuleSets_Rule_Spec
func (rule *Profiles_RuleSets_Rule_Spec) AssignProperties_To_Profiles_RuleSets_Rule_Spec(destination *v20230501s.Profiles_RuleSets_Rule_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if rule.Actions != nil {
		actionList := make([]v20230501s.DeliveryRuleAction, len(rule.Actions))
		for actionIndex, actionItem := range rule.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action v20230501s.DeliveryRuleAction
			err := actionItem.AssignProperties_To_DeliveryRuleAction(&action)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleAction() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		destination.Actions = actionList
	} else {
		destination.Actions = nil
	}

	// AzureName
	destination.AzureName = rule.AzureName

	// MatchProcessingBehavior
	if rule.MatchProcessingBehavior != nil {
		matchProcessingBehavior := string(*rule.MatchProcessingBehavior)
		destination.MatchProcessingBehavior = &matchProcessingBehavior
	} else {
		destination.MatchProcessingBehavior = nil
	}

	// Order
	destination.Order = genruntime.ClonePointerToInt(rule.Order)

	// OriginalVersion
	destination.OriginalVersion = rule.OriginalVersion()

	// Owner
	if rule.Owner != nil {
		owner := rule.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// RuleConditions
	if rule.RuleConditions != nil {
		ruleConditionList := make([]v20230501s.DeliveryRuleCondition, len(rule.RuleConditions))
		for ruleConditionIndex, ruleConditionItem := range rule.RuleConditions {
			// Shadow the loop variable to avoid aliasing
			ruleConditionItem := ruleConditionItem
			var ruleCondition v20230501s.DeliveryRuleCondition
			err := ruleConditionItem.AssignProperties_To_DeliveryRuleCondition(&ruleCondition)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCondition() to populate field RuleConditions")
			}
			ruleConditionList[ruleConditionIndex] = ruleCondition
		}
		destination.RuleConditions = ruleConditionList
	} else {
		destination.RuleConditions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_Profiles_RuleSets_Rule_STATUS populates our Profiles_RuleSets_Rule_Spec from the provided source Profiles_RuleSets_Rule_STATUS
func (rule *Profiles_RuleSets_Rule_Spec) Initialize_From_Profiles_RuleSets_Rule_STATUS(source *Profiles_RuleSets_Rule_STATUS) error {

	// Actions
	if source.Actions != nil {
		actionList := make([]DeliveryRuleAction, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action DeliveryRuleAction
			err := action.Initialize_From_DeliveryRuleAction_STATUS(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_DeliveryRuleAction_STATUS() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		rule.Actions = actionList
	} else {
		rule.Actions = nil
	}

	// MatchProcessingBehavior
	if source.MatchProcessingBehavior != nil {
		matchProcessingBehavior := RuleProperties_MatchProcessingBehavior(*source.MatchProcessingBehavior)
		rule.MatchProcessingBehavior = &matchProcessingBehavior
	} else {
		rule.MatchProcessingBehavior = nil
	}

	// Order
	rule.Order = genruntime.ClonePointerToInt(source.Order)

	// RuleConditions
	if source.RuleConditions != nil {
		ruleConditionList := make([]DeliveryRuleCondition, len(source.RuleConditions))
		for ruleConditionIndex, ruleConditionItem := range source.RuleConditions {
			// Shadow the loop variable to avoid aliasing
			ruleConditionItem := ruleConditionItem
			var ruleCondition DeliveryRuleCondition
			err := ruleCondition.Initialize_From_DeliveryRuleCondition_STATUS(&ruleConditionItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_DeliveryRuleCondition_STATUS() to populate field RuleConditions")
			}
			ruleConditionList[ruleConditionIndex] = ruleCondition
		}
		rule.RuleConditions = ruleConditionList
	} else {
		rule.RuleConditions = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (rule *Profiles_RuleSets_Rule_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (rule *Profiles_RuleSets_Rule_Spec) SetAzureName(azureName string) { rule.AzureName = azureName }

type Profiles_RuleSets_Rule_STATUS struct {
	// Actions: A list of actions that are executed when all the conditions of a rule are satisfied.
	Actions []DeliveryRuleAction_STATUS `json:"actions,omitempty"`

	// Conditions: The observed state of the resource
	Conditions       []conditions.Condition                  `json:"conditions,omitempty"`
	DeploymentStatus *RuleProperties_DeploymentStatus_STATUS `json:"deploymentStatus,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// MatchProcessingBehavior: If this rule is a match should the rules engine continue running the remaining rules or stop.
	// If not present, defaults to Continue.
	MatchProcessingBehavior *RuleProperties_MatchProcessingBehavior_STATUS `json:"matchProcessingBehavior,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// Order: The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A rule with a
	// lesser order will be applied before a rule with a greater order. Rule with order 0 is a special rule. It does not
	// require any condition and actions listed in it will always be applied.
	Order *int `json:"order,omitempty"`

	// ProvisioningState: Provisioning status
	ProvisioningState *RuleProperties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// RuleConditions: A list of conditions that must be matched for the actions to be executed
	RuleConditions []DeliveryRuleCondition_STATUS `json:"ruleconditions,omitempty"`

	// RuleSetName: The name of the rule set containing the rule.
	RuleSetName *string `json:"ruleSetName,omitempty"`

	// SystemData: Read only system data
	SystemData *SystemData_STATUS `json:"systemData,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Profiles_RuleSets_Rule_STATUS{}

// ConvertStatusFrom populates our Profiles_RuleSets_Rule_STATUS from the provided source
func (rule *Profiles_RuleSets_Rule_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20230501s.Profiles_RuleSets_Rule_STATUS)
	if ok {
		// Populate our instance from source
		return rule.AssignProperties_From_Profiles_RuleSets_Rule_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20230501s.Profiles_RuleSets_Rule_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = rule.AssignProperties_From_Profiles_RuleSets_Rule_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Profiles_RuleSets_Rule_STATUS
func (rule *Profiles_RuleSets_Rule_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20230501s.Profiles_RuleSets_Rule_STATUS)
	if ok {
		// Populate destination from our instance
		return rule.AssignProperties_To_Profiles_RuleSets_Rule_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20230501s.Profiles_RuleSets_Rule_STATUS{}
	err := rule.AssignProperties_To_Profiles_RuleSets_Rule_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Profiles_RuleSets_Rule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *Profiles_RuleSets_Rule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Profiles_RuleSets_Rule_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *Profiles_RuleSets_Rule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Profiles_RuleSets_Rule_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Profiles_RuleSets_Rule_STATUS_ARM, got %T", armInput)
	}

	// Set property "Actions":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Actions {
			var item1 DeliveryRuleAction_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			rule.Actions = append(rule.Actions, item1)
		}
	}

	// no assignment for property "Conditions"

	// Set property "DeploymentStatus":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeploymentStatus != nil {
			deploymentStatus := *typedInput.Properties.DeploymentStatus
			rule.DeploymentStatus = &deploymentStatus
		}
	}

	// Set property "Id":
	if typedInput.Id != nil {
		id := *typedInput.Id
		rule.Id = &id
	}

	// Set property "MatchProcessingBehavior":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MatchProcessingBehavior != nil {
			matchProcessingBehavior := *typedInput.Properties.MatchProcessingBehavior
			rule.MatchProcessingBehavior = &matchProcessingBehavior
		}
	}

	// Set property "Name":
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property "Order":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Order != nil {
			order := *typedInput.Properties.Order
			rule.Order = &order
		}
	}

	// Set property "ProvisioningState":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			rule.ProvisioningState = &provisioningState
		}
	}

	// Set property "RuleConditions":
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Conditions {
			var item1 DeliveryRuleCondition_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			rule.RuleConditions = append(rule.RuleConditions, item1)
		}
	}

	// Set property "RuleSetName":
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.RuleSetName != nil {
			ruleSetName := *typedInput.Properties.RuleSetName
			rule.RuleSetName = &ruleSetName
		}
	}

	// Set property "SystemData":
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		rule.SystemData = &systemData
	}

	// Set property "Type":
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		rule.Type = &typeVar
	}

	// No error
	return nil
}

// AssignProperties_From_Profiles_RuleSets_Rule_STATUS populates our Profiles_RuleSets_Rule_STATUS from the provided source Profiles_RuleSets_Rule_STATUS
func (rule *Profiles_RuleSets_Rule_STATUS) AssignProperties_From_Profiles_RuleSets_Rule_STATUS(source *v20230501s.Profiles_RuleSets_Rule_STATUS) error {

	// Actions
	if source.Actions != nil {
		actionList := make([]DeliveryRuleAction_STATUS, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action DeliveryRuleAction_STATUS
			err := action.AssignProperties_From_DeliveryRuleAction_STATUS(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleAction_STATUS() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		rule.Actions = actionList
	} else {
		rule.Actions = nil
	}

	// Conditions
	rule.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DeploymentStatus
	if source.DeploymentStatus != nil {
		deploymentStatus := RuleProperties_DeploymentStatus_STATUS(*source.DeploymentStatus)
		rule.DeploymentStatus = &deploymentStatus
	} else {
		rule.DeploymentStatus = nil
	}

	// Id
	rule.Id = genruntime.ClonePointerToString(source.Id)

	// MatchProcessingBehavior
	if source.MatchProcessingBehavior != nil {
		matchProcessingBehavior := RuleProperties_MatchProcessingBehavior_STATUS(*source.MatchProcessingBehavior)
		rule.MatchProcessingBehavior = &matchProcessingBehavior
	} else {
		rule.MatchProcessingBehavior = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Order
	rule.Order = genruntime.ClonePointerToInt(source.Order)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := RuleProperties_ProvisioningState_STATUS(*source.ProvisioningState)
		rule.ProvisioningState = &provisioningState
	} else {
		rule.ProvisioningState = nil
	}

	// RuleConditions
	if source.RuleConditions != nil {
		ruleConditionList := make([]DeliveryRuleCondition_STATUS, len(source.RuleConditions))
		for ruleConditionIndex, ruleConditionItem := range source.RuleConditions {
			// Shadow the loop variable to avoid aliasing
			ruleConditionItem := ruleConditionItem
			var ruleCondition DeliveryRuleCondition_STATUS
			err := ruleCondition.AssignProperties_From_DeliveryRuleCondition_STATUS(&ruleConditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCondition_STATUS() to populate field RuleConditions")
			}
			ruleConditionList[ruleConditionIndex] = ruleCondition
		}
		rule.RuleConditions = ruleConditionList
	} else {
		rule.RuleConditions = nil
	}

	// RuleSetName
	rule.RuleSetName = genruntime.ClonePointerToString(source.RuleSetName)

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		rule.SystemData = &systemDatum
	} else {
		rule.SystemData = nil
	}

	// Type
	rule.Type = genruntime.ClonePointerToString(source.Type)

	// No error
	return nil
}

// AssignProperties_To_Profiles_RuleSets_Rule_STATUS populates the provided destination Profiles_RuleSets_Rule_STATUS from our Profiles_RuleSets_Rule_STATUS
func (rule *Profiles_RuleSets_Rule_STATUS) AssignProperties_To_Profiles_RuleSets_Rule_STATUS(destination *v20230501s.Profiles_RuleSets_Rule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if rule.Actions != nil {
		actionList := make([]v20230501s.DeliveryRuleAction_STATUS, len(rule.Actions))
		for actionIndex, actionItem := range rule.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action v20230501s.DeliveryRuleAction_STATUS
			err := actionItem.AssignProperties_To_DeliveryRuleAction_STATUS(&action)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleAction_STATUS() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		destination.Actions = actionList
	} else {
		destination.Actions = nil
	}

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(rule.Conditions)

	// DeploymentStatus
	if rule.DeploymentStatus != nil {
		deploymentStatus := string(*rule.DeploymentStatus)
		destination.DeploymentStatus = &deploymentStatus
	} else {
		destination.DeploymentStatus = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(rule.Id)

	// MatchProcessingBehavior
	if rule.MatchProcessingBehavior != nil {
		matchProcessingBehavior := string(*rule.MatchProcessingBehavior)
		destination.MatchProcessingBehavior = &matchProcessingBehavior
	} else {
		destination.MatchProcessingBehavior = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Order
	destination.Order = genruntime.ClonePointerToInt(rule.Order)

	// ProvisioningState
	if rule.ProvisioningState != nil {
		provisioningState := string(*rule.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// RuleConditions
	if rule.RuleConditions != nil {
		ruleConditionList := make([]v20230501s.DeliveryRuleCondition_STATUS, len(rule.RuleConditions))
		for ruleConditionIndex, ruleConditionItem := range rule.RuleConditions {
			// Shadow the loop variable to avoid aliasing
			ruleConditionItem := ruleConditionItem
			var ruleCondition v20230501s.DeliveryRuleCondition_STATUS
			err := ruleConditionItem.AssignProperties_To_DeliveryRuleCondition_STATUS(&ruleCondition)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCondition_STATUS() to populate field RuleConditions")
			}
			ruleConditionList[ruleConditionIndex] = ruleCondition
		}
		destination.RuleConditions = ruleConditionList
	} else {
		destination.RuleConditions = nil
	}

	// RuleSetName
	destination.RuleSetName = genruntime.ClonePointerToString(rule.RuleSetName)

	// SystemData
	if rule.SystemData != nil {
		var systemDatum v20230501s.SystemData_STATUS
		err := rule.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(rule.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// An action for the delivery rule.
type DeliveryRuleAction struct {
	// CacheExpiration: Mutually exclusive with all other properties
	CacheExpiration *DeliveryRuleCacheExpirationAction `json:"cacheExpiration,omitempty"`

	// CacheKeyQueryString: Mutually exclusive with all other properties
	CacheKeyQueryString *DeliveryRuleCacheKeyQueryStringAction `json:"cacheKeyQueryString,omitempty"`

	// ModifyRequestHeader: Mutually exclusive with all other properties
	ModifyRequestHeader *DeliveryRuleRequestHeaderAction `json:"modifyRequestHeader,omitempty"`

	// ModifyResponseHeader: Mutually exclusive with all other properties
	ModifyResponseHeader *DeliveryRuleResponseHeaderAction `json:"modifyResponseHeader,omitempty"`

	// OriginGroupOverride: Mutually exclusive with all other properties
	OriginGroupOverride *OriginGroupOverrideAction `json:"originGroupOverride,omitempty"`

	// RouteConfigurationOverride: Mutually exclusive with all other properties
	RouteConfigurationOverride *DeliveryRuleRouteConfigurationOverrideAction `json:"routeConfigurationOverride,omitempty"`

	// UrlRedirect: Mutually exclusive with all other properties
	UrlRedirect *UrlRedirectAction `json:"urlRedirect,omitempty"`

	// UrlRewrite: Mutually exclusive with all other properties
	UrlRewrite *UrlRewriteAction `json:"urlRewrite,omitempty"`

	// UrlSigning: Mutually exclusive with all other properties
	UrlSigning *UrlSigningAction `json:"urlSigning,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *DeliveryRuleAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &DeliveryRuleAction_ARM{}

	// Set property "CacheExpiration":
	if action.CacheExpiration != nil {
		cacheExpiration_ARM, err := (*action.CacheExpiration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cacheExpiration := *cacheExpiration_ARM.(*DeliveryRuleCacheExpirationAction_ARM)
		result.CacheExpiration = &cacheExpiration
	}

	// Set property "CacheKeyQueryString":
	if action.CacheKeyQueryString != nil {
		cacheKeyQueryString_ARM, err := (*action.CacheKeyQueryString).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cacheKeyQueryString := *cacheKeyQueryString_ARM.(*DeliveryRuleCacheKeyQueryStringAction_ARM)
		result.CacheKeyQueryString = &cacheKeyQueryString
	}

	// Set property "ModifyRequestHeader":
	if action.ModifyRequestHeader != nil {
		modifyRequestHeader_ARM, err := (*action.ModifyRequestHeader).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		modifyRequestHeader := *modifyRequestHeader_ARM.(*DeliveryRuleRequestHeaderAction_ARM)
		result.ModifyRequestHeader = &modifyRequestHeader
	}

	// Set property "ModifyResponseHeader":
	if action.ModifyResponseHeader != nil {
		modifyResponseHeader_ARM, err := (*action.ModifyResponseHeader).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		modifyResponseHeader := *modifyResponseHeader_ARM.(*DeliveryRuleResponseHeaderAction_ARM)
		result.ModifyResponseHeader = &modifyResponseHeader
	}

	// Set property "OriginGroupOverride":
	if action.OriginGroupOverride != nil {
		originGroupOverride_ARM, err := (*action.OriginGroupOverride).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		originGroupOverride := *originGroupOverride_ARM.(*OriginGroupOverrideAction_ARM)
		result.OriginGroupOverride = &originGroupOverride
	}

	// Set property "RouteConfigurationOverride":
	if action.RouteConfigurationOverride != nil {
		routeConfigurationOverride_ARM, err := (*action.RouteConfigurationOverride).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		routeConfigurationOverride := *routeConfigurationOverride_ARM.(*DeliveryRuleRouteConfigurationOverrideAction_ARM)
		result.RouteConfigurationOverride = &routeConfigurationOverride
	}

	// Set property "UrlRedirect":
	if action.UrlRedirect != nil {
		urlRedirect_ARM, err := (*action.UrlRedirect).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		urlRedirect := *urlRedirect_ARM.(*UrlRedirectAction_ARM)
		result.UrlRedirect = &urlRedirect
	}

	// Set property "UrlRewrite":
	if action.UrlRewrite != nil {
		urlRewrite_ARM, err := (*action.UrlRewrite).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		urlRewrite := *urlRewrite_ARM.(*UrlRewriteAction_ARM)
		result.UrlRewrite = &urlRewrite
	}

	// Set property "UrlSigning":
	if action.UrlSigning != nil {
		urlSigning_ARM, err := (*action.UrlSigning).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		urlSigning := *urlSigning_ARM.(*UrlSigningAction_ARM)
		result.UrlSigning = &urlSigning
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleAction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleAction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleAction_ARM, got %T", armInput)
	}

	// Set property "CacheExpiration":
	if typedInput.CacheExpiration != nil {
		var cacheExpiration1 DeliveryRuleCacheExpirationAction
		err := cacheExpiration1.PopulateFromARM(owner, *typedInput.CacheExpiration)
		if err != nil {
			return err
		}
		cacheExpiration := cacheExpiration1
		action.CacheExpiration = &cacheExpiration
	}

	// Set property "CacheKeyQueryString":
	if typedInput.CacheKeyQueryString != nil {
		var cacheKeyQueryString1 DeliveryRuleCacheKeyQueryStringAction
		err := cacheKeyQueryString1.PopulateFromARM(owner, *typedInput.CacheKeyQueryString)
		if err != nil {
			return err
		}
		cacheKeyQueryString := cacheKeyQueryString1
		action.CacheKeyQueryString = &cacheKeyQueryString
	}

	// Set property "ModifyRequestHeader":
	if typedInput.ModifyRequestHeader != nil {
		var modifyRequestHeader1 DeliveryRuleRequestHeaderAction
		err := modifyRequestHeader1.PopulateFromARM(owner, *typedInput.ModifyRequestHeader)
		if err != nil {
			return err
		}
		modifyRequestHeader := modifyRequestHeader1
		action.ModifyRequestHeader = &modifyRequestHeader
	}

	// Set property "ModifyResponseHeader":
	if typedInput.ModifyResponseHeader != nil {
		var modifyResponseHeader1 DeliveryRuleResponseHeaderAction
		err := modifyResponseHeader1.PopulateFromARM(owner, *typedInput.ModifyResponseHeader)
		if err != nil {
			return err
		}
		modifyResponseHeader := modifyResponseHeader1
		action.ModifyResponseHeader = &modifyResponseHeader
	}

	// Set property "OriginGroupOverride":
	if typedInput.OriginGroupOverride != nil {
		var originGroupOverride1 OriginGroupOverrideAction
		err := originGroupOverride1.PopulateFromARM(owner, *typedInput.OriginGroupOverride)
		if err != nil {
			return err
		}
		originGroupOverride := originGroupOverride1
		action.OriginGroupOverride = &originGroupOverride
	}

	// Set property "RouteConfigurationOverride":
	if typedInput.RouteConfigurationOverride != nil {
		var routeConfigurationOverride1 DeliveryRuleRouteConfigurationOverrideAction
		err := routeConfigurationOverride1.PopulateFromARM(owner, *typedInput.RouteConfigurationOverride)
		if err != nil {
			return err
		}
		routeConfigurationOverride := routeConfigurationOverride1
		action.RouteConfigurationOverride = &routeConfigurationOverride
	}

	// Set property "UrlRedirect":
	if typedInput.UrlRedirect != nil {
		var urlRedirect1 UrlRedirectAction
		err := urlRedirect1.PopulateFromARM(owner, *typedInput.UrlRedirect)
		if err != nil {
			return err
		}
		urlRedirect := urlRedirect1
		action.UrlRedirect = &urlRedirect
	}

	// Set property "UrlRewrite":
	if typedInput.UrlRewrite != nil {
		var urlRewrite1 UrlRewriteAction
		err := urlRewrite1.PopulateFromARM(owner, *typedInput.UrlRewrite)
		if err != nil {
			return err
		}
		urlRewrite := urlRewrite1
		action.UrlRewrite = &urlRewrite
	}

	// Set property "UrlSigning":
	if typedInput.UrlSigning != nil {
		var urlSigning1 UrlSigningAction
		err := urlSigning1.PopulateFromARM(owner, *typedInput.UrlSigning)
		if err != nil {
			return err
		}
		urlSigning := urlSigning1
		action.UrlSigning = &urlSigning
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleAction populates our DeliveryRuleAction from the provided source DeliveryRuleAction
func (action *DeliveryRuleAction) AssignProperties_From_DeliveryRuleAction(source *v20230501s.DeliveryRuleAction) error {

	// CacheExpiration
	if source.CacheExpiration != nil {
		var cacheExpiration DeliveryRuleCacheExpirationAction
		err := cacheExpiration.AssignProperties_From_DeliveryRuleCacheExpirationAction(source.CacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheExpirationAction() to populate field CacheExpiration")
		}
		action.CacheExpiration = &cacheExpiration
	} else {
		action.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if source.CacheKeyQueryString != nil {
		var cacheKeyQueryString DeliveryRuleCacheKeyQueryStringAction
		err := cacheKeyQueryString.AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction(source.CacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction() to populate field CacheKeyQueryString")
		}
		action.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		action.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if source.ModifyRequestHeader != nil {
		var modifyRequestHeader DeliveryRuleRequestHeaderAction
		err := modifyRequestHeader.AssignProperties_From_DeliveryRuleRequestHeaderAction(source.ModifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderAction() to populate field ModifyRequestHeader")
		}
		action.ModifyRequestHeader = &modifyRequestHeader
	} else {
		action.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if source.ModifyResponseHeader != nil {
		var modifyResponseHeader DeliveryRuleResponseHeaderAction
		err := modifyResponseHeader.AssignProperties_From_DeliveryRuleResponseHeaderAction(source.ModifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleResponseHeaderAction() to populate field ModifyResponseHeader")
		}
		action.ModifyResponseHeader = &modifyResponseHeader
	} else {
		action.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverrideAction
		err := originGroupOverride.AssignProperties_From_OriginGroupOverrideAction(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideAction() to populate field OriginGroupOverride")
		}
		action.OriginGroupOverride = &originGroupOverride
	} else {
		action.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if source.RouteConfigurationOverride != nil {
		var routeConfigurationOverride DeliveryRuleRouteConfigurationOverrideAction
		err := routeConfigurationOverride.AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction(source.RouteConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction() to populate field RouteConfigurationOverride")
		}
		action.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		action.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if source.UrlRedirect != nil {
		var urlRedirect UrlRedirectAction
		err := urlRedirect.AssignProperties_From_UrlRedirectAction(source.UrlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectAction() to populate field UrlRedirect")
		}
		action.UrlRedirect = &urlRedirect
	} else {
		action.UrlRedirect = nil
	}

	// UrlRewrite
	if source.UrlRewrite != nil {
		var urlRewrite UrlRewriteAction
		err := urlRewrite.AssignProperties_From_UrlRewriteAction(source.UrlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteAction() to populate field UrlRewrite")
		}
		action.UrlRewrite = &urlRewrite
	} else {
		action.UrlRewrite = nil
	}

	// UrlSigning
	if source.UrlSigning != nil {
		var urlSigning UrlSigningAction
		err := urlSigning.AssignProperties_From_UrlSigningAction(source.UrlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningAction() to populate field UrlSigning")
		}
		action.UrlSigning = &urlSigning
	} else {
		action.UrlSigning = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleAction populates the provided destination DeliveryRuleAction from our DeliveryRuleAction
func (action *DeliveryRuleAction) AssignProperties_To_DeliveryRuleAction(destination *v20230501s.DeliveryRuleAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheExpiration
	if action.CacheExpiration != nil {
		var cacheExpiration v20230501s.DeliveryRuleCacheExpirationAction
		err := action.CacheExpiration.AssignProperties_To_DeliveryRuleCacheExpirationAction(&cacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheExpirationAction() to populate field CacheExpiration")
		}
		destination.CacheExpiration = &cacheExpiration
	} else {
		destination.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if action.CacheKeyQueryString != nil {
		var cacheKeyQueryString v20230501s.DeliveryRuleCacheKeyQueryStringAction
		err := action.CacheKeyQueryString.AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction(&cacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction() to populate field CacheKeyQueryString")
		}
		destination.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		destination.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if action.ModifyRequestHeader != nil {
		var modifyRequestHeader v20230501s.DeliveryRuleRequestHeaderAction
		err := action.ModifyRequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderAction(&modifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderAction() to populate field ModifyRequestHeader")
		}
		destination.ModifyRequestHeader = &modifyRequestHeader
	} else {
		destination.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if action.ModifyResponseHeader != nil {
		var modifyResponseHeader v20230501s.DeliveryRuleResponseHeaderAction
		err := action.ModifyResponseHeader.AssignProperties_To_DeliveryRuleResponseHeaderAction(&modifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleResponseHeaderAction() to populate field ModifyResponseHeader")
		}
		destination.ModifyResponseHeader = &modifyResponseHeader
	} else {
		destination.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if action.OriginGroupOverride != nil {
		var originGroupOverride v20230501s.OriginGroupOverrideAction
		err := action.OriginGroupOverride.AssignProperties_To_OriginGroupOverrideAction(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideAction() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if action.RouteConfigurationOverride != nil {
		var routeConfigurationOverride v20230501s.DeliveryRuleRouteConfigurationOverrideAction
		err := action.RouteConfigurationOverride.AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction(&routeConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction() to populate field RouteConfigurationOverride")
		}
		destination.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		destination.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if action.UrlRedirect != nil {
		var urlRedirect v20230501s.UrlRedirectAction
		err := action.UrlRedirect.AssignProperties_To_UrlRedirectAction(&urlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectAction() to populate field UrlRedirect")
		}
		destination.UrlRedirect = &urlRedirect
	} else {
		destination.UrlRedirect = nil
	}

	// UrlRewrite
	if action.UrlRewrite != nil {
		var urlRewrite v20230501s.UrlRewriteAction
		err := action.UrlRewrite.AssignProperties_To_UrlRewriteAction(&urlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteAction() to populate field UrlRewrite")
		}
		destination.UrlRewrite = &urlRewrite
	} else {
		destination.UrlRewrite = nil
	}

	// UrlSigning
	if action.UrlSigning != nil {
		var urlSigning v20230501s.UrlSigningAction
		err := action.UrlSigning.AssignProperties_To_UrlSigningAction(&urlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningAction() to populate field UrlSigning")
		}
		destination.UrlSigning = &urlSigning
	} else {
		destination.UrlSigning = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleAction_STATUS populates our DeliveryRuleAction from the provided source DeliveryRuleAction_STATUS
func (action *DeliveryRuleAction) Initialize_From_DeliveryRuleAction_STATUS(source *DeliveryRuleAction_STATUS) error {

	// CacheExpiration
	if source.CacheExpiration != nil {
		var cacheExpiration DeliveryRuleCacheExpirationAction
		err := cacheExpiration.Initialize_From_DeliveryRuleCacheExpirationAction_STATUS(source.CacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleCacheExpirationAction_STATUS() to populate field CacheExpiration")
		}
		action.CacheExpiration = &cacheExpiration
	} else {
		action.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if source.CacheKeyQueryString != nil {
		var cacheKeyQueryString DeliveryRuleCacheKeyQueryStringAction
		err := cacheKeyQueryString.Initialize_From_DeliveryRuleCacheKeyQueryStringAction_STATUS(source.CacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleCacheKeyQueryStringAction_STATUS() to populate field CacheKeyQueryString")
		}
		action.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		action.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if source.ModifyRequestHeader != nil {
		var modifyRequestHeader DeliveryRuleRequestHeaderAction
		err := modifyRequestHeader.Initialize_From_DeliveryRuleRequestHeaderAction_STATUS(source.ModifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRequestHeaderAction_STATUS() to populate field ModifyRequestHeader")
		}
		action.ModifyRequestHeader = &modifyRequestHeader
	} else {
		action.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if source.ModifyResponseHeader != nil {
		var modifyResponseHeader DeliveryRuleResponseHeaderAction
		err := modifyResponseHeader.Initialize_From_DeliveryRuleResponseHeaderAction_STATUS(source.ModifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleResponseHeaderAction_STATUS() to populate field ModifyResponseHeader")
		}
		action.ModifyResponseHeader = &modifyResponseHeader
	} else {
		action.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverrideAction
		err := originGroupOverride.Initialize_From_OriginGroupOverrideAction_STATUS(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_OriginGroupOverrideAction_STATUS() to populate field OriginGroupOverride")
		}
		action.OriginGroupOverride = &originGroupOverride
	} else {
		action.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if source.RouteConfigurationOverride != nil {
		var routeConfigurationOverride DeliveryRuleRouteConfigurationOverrideAction
		err := routeConfigurationOverride.Initialize_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS(source.RouteConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS() to populate field RouteConfigurationOverride")
		}
		action.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		action.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if source.UrlRedirect != nil {
		var urlRedirect UrlRedirectAction
		err := urlRedirect.Initialize_From_UrlRedirectAction_STATUS(source.UrlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlRedirectAction_STATUS() to populate field UrlRedirect")
		}
		action.UrlRedirect = &urlRedirect
	} else {
		action.UrlRedirect = nil
	}

	// UrlRewrite
	if source.UrlRewrite != nil {
		var urlRewrite UrlRewriteAction
		err := urlRewrite.Initialize_From_UrlRewriteAction_STATUS(source.UrlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlRewriteAction_STATUS() to populate field UrlRewrite")
		}
		action.UrlRewrite = &urlRewrite
	} else {
		action.UrlRewrite = nil
	}

	// UrlSigning
	if source.UrlSigning != nil {
		var urlSigning UrlSigningAction
		err := urlSigning.Initialize_From_UrlSigningAction_STATUS(source.UrlSigning)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlSigningAction_STATUS() to populate field UrlSigning")
		}
		action.UrlSigning = &urlSigning
	} else {
		action.UrlSigning = nil
	}

	// No error
	return nil
}

// An action for the delivery rule.
type DeliveryRuleAction_STATUS struct {
	// CacheExpiration: Mutually exclusive with all other properties
	CacheExpiration *DeliveryRuleCacheExpirationAction_STATUS `json:"cacheExpiration,omitempty"`

	// CacheKeyQueryString: Mutually exclusive with all other properties
	CacheKeyQueryString *DeliveryRuleCacheKeyQueryStringAction_STATUS `json:"cacheKeyQueryString,omitempty"`

	// ModifyRequestHeader: Mutually exclusive with all other properties
	ModifyRequestHeader *DeliveryRuleRequestHeaderAction_STATUS `json:"modifyRequestHeader,omitempty"`

	// ModifyResponseHeader: Mutually exclusive with all other properties
	ModifyResponseHeader *DeliveryRuleResponseHeaderAction_STATUS `json:"modifyResponseHeader,omitempty"`

	// OriginGroupOverride: Mutually exclusive with all other properties
	OriginGroupOverride *OriginGroupOverrideAction_STATUS `json:"originGroupOverride,omitempty"`

	// RouteConfigurationOverride: Mutually exclusive with all other properties
	RouteConfigurationOverride *DeliveryRuleRouteConfigurationOverrideAction_STATUS `json:"routeConfigurationOverride,omitempty"`

	// UrlRedirect: Mutually exclusive with all other properties
	UrlRedirect *UrlRedirectAction_STATUS `json:"urlRedirect,omitempty"`

	// UrlRewrite: Mutually exclusive with all other properties
	UrlRewrite *UrlRewriteAction_STATUS `json:"urlRewrite,omitempty"`

	// UrlSigning: Mutually exclusive with all other properties
	UrlSigning *UrlSigningAction_STATUS `json:"urlSigning,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleAction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleAction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleAction_STATUS_ARM, got %T", armInput)
	}

	// Set property "CacheExpiration":
	if typedInput.CacheExpiration != nil {
		var cacheExpiration1 DeliveryRuleCacheExpirationAction_STATUS
		err := cacheExpiration1.PopulateFromARM(owner, *typedInput.CacheExpiration)
		if err != nil {
			return err
		}
		cacheExpiration := cacheExpiration1
		action.CacheExpiration = &cacheExpiration
	}

	// Set property "CacheKeyQueryString":
	if typedInput.CacheKeyQueryString != nil {
		var cacheKeyQueryString1 DeliveryRuleCacheKeyQueryStringAction_STATUS
		err := cacheKeyQueryString1.PopulateFromARM(owner, *typedInput.CacheKeyQueryString)
		if err != nil {
			return err
		}
		cacheKeyQueryString := cacheKeyQueryString1
		action.CacheKeyQueryString = &cacheKeyQueryString
	}

	// Set property "ModifyRequestHeader":
	if typedInput.ModifyRequestHeader != nil {
		var modifyRequestHeader1 DeliveryRuleRequestHeaderAction_STATUS
		err := modifyRequestHeader1.PopulateFromARM(owner, *typedInput.ModifyRequestHeader)
		if err != nil {
			return err
		}
		modifyRequestHeader := modifyRequestHeader1
		action.ModifyRequestHeader = &modifyRequestHeader
	}

	// Set property "ModifyResponseHeader":
	if typedInput.ModifyResponseHeader != nil {
		var modifyResponseHeader1 DeliveryRuleResponseHeaderAction_STATUS
		err := modifyResponseHeader1.PopulateFromARM(owner, *typedInput.ModifyResponseHeader)
		if err != nil {
			return err
		}
		modifyResponseHeader := modifyResponseHeader1
		action.ModifyResponseHeader = &modifyResponseHeader
	}

	// Set property "OriginGroupOverride":
	if typedInput.OriginGroupOverride != nil {
		var originGroupOverride1 OriginGroupOverrideAction_STATUS
		err := originGroupOverride1.PopulateFromARM(owner, *typedInput.OriginGroupOverride)
		if err != nil {
			return err
		}
		originGroupOverride := originGroupOverride1
		action.OriginGroupOverride = &originGroupOverride
	}

	// Set property "RouteConfigurationOverride":
	if typedInput.RouteConfigurationOverride != nil {
		var routeConfigurationOverride1 DeliveryRuleRouteConfigurationOverrideAction_STATUS
		err := routeConfigurationOverride1.PopulateFromARM(owner, *typedInput.RouteConfigurationOverride)
		if err != nil {
			return err
		}
		routeConfigurationOverride := routeConfigurationOverride1
		action.RouteConfigurationOverride = &routeConfigurationOverride
	}

	// Set property "UrlRedirect":
	if typedInput.UrlRedirect != nil {
		var urlRedirect1 UrlRedirectAction_STATUS
		err := urlRedirect1.PopulateFromARM(owner, *typedInput.UrlRedirect)
		if err != nil {
			return err
		}
		urlRedirect := urlRedirect1
		action.UrlRedirect = &urlRedirect
	}

	// Set property "UrlRewrite":
	if typedInput.UrlRewrite != nil {
		var urlRewrite1 UrlRewriteAction_STATUS
		err := urlRewrite1.PopulateFromARM(owner, *typedInput.UrlRewrite)
		if err != nil {
			return err
		}
		urlRewrite := urlRewrite1
		action.UrlRewrite = &urlRewrite
	}

	// Set property "UrlSigning":
	if typedInput.UrlSigning != nil {
		var urlSigning1 UrlSigningAction_STATUS
		err := urlSigning1.PopulateFromARM(owner, *typedInput.UrlSigning)
		if err != nil {
			return err
		}
		urlSigning := urlSigning1
		action.UrlSigning = &urlSigning
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleAction_STATUS populates our DeliveryRuleAction_STATUS from the provided source DeliveryRuleAction_STATUS
func (action *DeliveryRuleAction_STATUS) AssignProperties_From_DeliveryRuleAction_STATUS(source *v20230501s.DeliveryRuleAction_STATUS) error {

	// CacheExpiration
	if source.CacheExpiration != nil {
		var cacheExpiration DeliveryRuleCacheExpirationAction_STATUS
		err := cacheExpiration.AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS(source.CacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS() to populate field CacheExpiration")
		}
		action.CacheExpiration = &cacheExpiration
	} else {
		action.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if source.CacheKeyQueryString != nil {
		var cacheKeyQueryString DeliveryRuleCacheKeyQueryStringAction_STATUS
		err := cacheKeyQueryString.AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS(source.CacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS() to populate field CacheKeyQueryString")
		}
		action.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		action.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if source.ModifyRequestHeader != nil {
		var modifyRequestHeader DeliveryRuleRequestHeaderAction_STATUS
		err := modifyRequestHeader.AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS(source.ModifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS() to populate field ModifyRequestHeader")
		}
		action.ModifyRequestHeader = &modifyRequestHeader
	} else {
		action.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if source.ModifyResponseHeader != nil {
		var modifyResponseHeader DeliveryRuleResponseHeaderAction_STATUS
		err := modifyResponseHeader.AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS(source.ModifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS() to populate field ModifyResponseHeader")
		}
		action.ModifyResponseHeader = &modifyResponseHeader
	} else {
		action.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverrideAction_STATUS
		err := originGroupOverride.AssignProperties_From_OriginGroupOverrideAction_STATUS(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideAction_STATUS() to populate field OriginGroupOverride")
		}
		action.OriginGroupOverride = &originGroupOverride
	} else {
		action.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if source.RouteConfigurationOverride != nil {
		var routeConfigurationOverride DeliveryRuleRouteConfigurationOverrideAction_STATUS
		err := routeConfigurationOverride.AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS(source.RouteConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS() to populate field RouteConfigurationOverride")
		}
		action.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		action.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if source.UrlRedirect != nil {
		var urlRedirect UrlRedirectAction_STATUS
		err := urlRedirect.AssignProperties_From_UrlRedirectAction_STATUS(source.UrlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectAction_STATUS() to populate field UrlRedirect")
		}
		action.UrlRedirect = &urlRedirect
	} else {
		action.UrlRedirect = nil
	}

	// UrlRewrite
	if source.UrlRewrite != nil {
		var urlRewrite UrlRewriteAction_STATUS
		err := urlRewrite.AssignProperties_From_UrlRewriteAction_STATUS(source.UrlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteAction_STATUS() to populate field UrlRewrite")
		}
		action.UrlRewrite = &urlRewrite
	} else {
		action.UrlRewrite = nil
	}

	// UrlSigning
	if source.UrlSigning != nil {
		var urlSigning UrlSigningAction_STATUS
		err := urlSigning.AssignProperties_From_UrlSigningAction_STATUS(source.UrlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningAction_STATUS() to populate field UrlSigning")
		}
		action.UrlSigning = &urlSigning
	} else {
		action.UrlSigning = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleAction_STATUS populates the provided destination DeliveryRuleAction_STATUS from our DeliveryRuleAction_STATUS
func (action *DeliveryRuleAction_STATUS) AssignProperties_To_DeliveryRuleAction_STATUS(destination *v20230501s.DeliveryRuleAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheExpiration
	if action.CacheExpiration != nil {
		var cacheExpiration v20230501s.DeliveryRuleCacheExpirationAction_STATUS
		err := action.CacheExpiration.AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS(&cacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS() to populate field CacheExpiration")
		}
		destination.CacheExpiration = &cacheExpiration
	} else {
		destination.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if action.CacheKeyQueryString != nil {
		var cacheKeyQueryString v20230501s.DeliveryRuleCacheKeyQueryStringAction_STATUS
		err := action.CacheKeyQueryString.AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS(&cacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS() to populate field CacheKeyQueryString")
		}
		destination.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		destination.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if action.ModifyRequestHeader != nil {
		var modifyRequestHeader v20230501s.DeliveryRuleRequestHeaderAction_STATUS
		err := action.ModifyRequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS(&modifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS() to populate field ModifyRequestHeader")
		}
		destination.ModifyRequestHeader = &modifyRequestHeader
	} else {
		destination.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if action.ModifyResponseHeader != nil {
		var modifyResponseHeader v20230501s.DeliveryRuleResponseHeaderAction_STATUS
		err := action.ModifyResponseHeader.AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS(&modifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS() to populate field ModifyResponseHeader")
		}
		destination.ModifyResponseHeader = &modifyResponseHeader
	} else {
		destination.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if action.OriginGroupOverride != nil {
		var originGroupOverride v20230501s.OriginGroupOverrideAction_STATUS
		err := action.OriginGroupOverride.AssignProperties_To_OriginGroupOverrideAction_STATUS(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideAction_STATUS() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if action.RouteConfigurationOverride != nil {
		var routeConfigurationOverride v20230501s.DeliveryRuleRouteConfigurationOverrideAction_STATUS
		err := action.RouteConfigurationOverride.AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS(&routeConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS() to populate field RouteConfigurationOverride")
		}
		destination.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		destination.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if action.UrlRedirect != nil {
		var urlRedirect v20230501s.UrlRedirectAction_STATUS
		err := action.UrlRedirect.AssignProperties_To_UrlRedirectAction_STATUS(&urlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectAction_STATUS() to populate field UrlRedirect")
		}
		destination.UrlRedirect = &urlRedirect
	} else {
		destination.UrlRedirect = nil
	}

	// UrlRewrite
	if action.UrlRewrite != nil {
		var urlRewrite v20230501s.UrlRewriteAction_STATUS
		err := action.UrlRewrite.AssignProperties_To_UrlRewriteAction_STATUS(&urlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteAction_STATUS() to populate field UrlRewrite")
		}
		destination.UrlRewrite = &urlRewrite
	} else {
		destination.UrlRewrite = nil
	}

	// UrlSigning
	if action.UrlSigning != nil {
		var urlSigning v20230501s.UrlSigningAction_STATUS
		err := action.UrlSigning.AssignProperties_To_UrlSigningAction_STATUS(&urlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningAction_STATUS() to populate field UrlSigning")
		}
		destination.UrlSigning = &urlSigning
	} else {
		destination.UrlSigning = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// A condition for the delivery rule.
type DeliveryRuleCondition struct {
	// ClientPort: Mutually exclusive with all other properties
	ClientPort *DeliveryRuleClientPortCondition `json:"clientPort,omitempty"`

	// Cookies: Mutually exclusive with all other properties
	Cookies *DeliveryRuleCookiesCondition `json:"cookies,omitempty"`

	// HostName: Mutually exclusive with all other properties
	HostName *DeliveryRuleHostNameCondition `json:"hostName,omitempty"`

	// HttpVersion: Mutually exclusive with all other properties
	HttpVersion *DeliveryRuleHttpVersionCondition `json:"httpVersion,omitempty"`

	// IsDevice: Mutually exclusive with all other properties
	IsDevice *DeliveryRuleIsDeviceCondition `json:"isDevice,omitempty"`

	// PostArgs: Mutually exclusive with all other properties
	PostArgs *DeliveryRulePostArgsCondition `json:"postArgs,omitempty"`

	// QueryString: Mutually exclusive with all other properties
	QueryString *DeliveryRuleQueryStringCondition `json:"queryString,omitempty"`

	// RemoteAddress: Mutually exclusive with all other properties
	RemoteAddress *DeliveryRuleRemoteAddressCondition `json:"remoteAddress,omitempty"`

	// RequestBody: Mutually exclusive with all other properties
	RequestBody *DeliveryRuleRequestBodyCondition `json:"requestBody,omitempty"`

	// RequestHeader: Mutually exclusive with all other properties
	RequestHeader *DeliveryRuleRequestHeaderCondition `json:"requestHeader,omitempty"`

	// RequestMethod: Mutually exclusive with all other properties
	RequestMethod *DeliveryRuleRequestMethodCondition `json:"requestMethod,omitempty"`

	// RequestScheme: Mutually exclusive with all other properties
	RequestScheme *DeliveryRuleRequestSchemeCondition `json:"requestScheme,omitempty"`

	// RequestUri: Mutually exclusive with all other properties
	RequestUri *DeliveryRuleRequestUriCondition `json:"requestUri,omitempty"`

	// ServerPort: Mutually exclusive with all other properties
	ServerPort *DeliveryRuleServerPortCondition `json:"serverPort,omitempty"`

	// SocketAddr: Mutually exclusive with all other properties
	SocketAddr *DeliveryRuleSocketAddrCondition `json:"socketAddr,omitempty"`

	// SslProtocol: Mutually exclusive with all other properties
	SslProtocol *DeliveryRuleSslProtocolCondition `json:"sslProtocol,omitempty"`

	// UrlFileExtension: Mutually exclusive with all other properties
	UrlFileExtension *DeliveryRuleUrlFileExtensionCondition `json:"urlFileExtension,omitempty"`

	// UrlFileName: Mutually exclusive with all other properties
	UrlFileName *DeliveryRuleUrlFileNameCondition `json:"urlFileName,omitempty"`

	// UrlPath: Mutually exclusive with all other properties
	UrlPath *DeliveryRuleUrlPathCondition `json:"urlPath,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleCondition_ARM{}

	// Set property "ClientPort":
	if condition.ClientPort != nil {
		clientPort_ARM, err := (*condition.ClientPort).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		clientPort := *clientPort_ARM.(*DeliveryRuleClientPortCondition_ARM)
		result.ClientPort = &clientPort
	}

	// Set property "Cookies":
	if condition.Cookies != nil {
		cookies_ARM, err := (*condition.Cookies).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cookies := *cookies_ARM.(*DeliveryRuleCookiesCondition_ARM)
		result.Cookies = &cookies
	}

	// Set property "HostName":
	if condition.HostName != nil {
		hostName_ARM, err := (*condition.HostName).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		hostName := *hostName_ARM.(*DeliveryRuleHostNameCondition_ARM)
		result.HostName = &hostName
	}

	// Set property "HttpVersion":
	if condition.HttpVersion != nil {
		httpVersion_ARM, err := (*condition.HttpVersion).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		httpVersion := *httpVersion_ARM.(*DeliveryRuleHttpVersionCondition_ARM)
		result.HttpVersion = &httpVersion
	}

	// Set property "IsDevice":
	if condition.IsDevice != nil {
		isDevice_ARM, err := (*condition.IsDevice).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		isDevice := *isDevice_ARM.(*DeliveryRuleIsDeviceCondition_ARM)
		result.IsDevice = &isDevice
	}

	// Set property "PostArgs":
	if condition.PostArgs != nil {
		postArgs_ARM, err := (*condition.PostArgs).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		postArgs := *postArgs_ARM.(*DeliveryRulePostArgsCondition_ARM)
		result.PostArgs = &postArgs
	}

	// Set property "QueryString":
	if condition.QueryString != nil {
		queryString_ARM, err := (*condition.QueryString).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		queryString := *queryString_ARM.(*DeliveryRuleQueryStringCondition_ARM)
		result.QueryString = &queryString
	}

	// Set property "RemoteAddress":
	if condition.RemoteAddress != nil {
		remoteAddress_ARM, err := (*condition.RemoteAddress).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		remoteAddress := *remoteAddress_ARM.(*DeliveryRuleRemoteAddressCondition_ARM)
		result.RemoteAddress = &remoteAddress
	}

	// Set property "RequestBody":
	if condition.RequestBody != nil {
		requestBody_ARM, err := (*condition.RequestBody).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requestBody := *requestBody_ARM.(*DeliveryRuleRequestBodyCondition_ARM)
		result.RequestBody = &requestBody
	}

	// Set property "RequestHeader":
	if condition.RequestHeader != nil {
		requestHeader_ARM, err := (*condition.RequestHeader).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requestHeader := *requestHeader_ARM.(*DeliveryRuleRequestHeaderCondition_ARM)
		result.RequestHeader = &requestHeader
	}

	// Set property "RequestMethod":
	if condition.RequestMethod != nil {
		requestMethod_ARM, err := (*condition.RequestMethod).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requestMethod := *requestMethod_ARM.(*DeliveryRuleRequestMethodCondition_ARM)
		result.RequestMethod = &requestMethod
	}

	// Set property "RequestScheme":
	if condition.RequestScheme != nil {
		requestScheme_ARM, err := (*condition.RequestScheme).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requestScheme := *requestScheme_ARM.(*DeliveryRuleRequestSchemeCondition_ARM)
		result.RequestScheme = &requestScheme
	}

	// Set property "RequestUri":
	if condition.RequestUri != nil {
		requestUri_ARM, err := (*condition.RequestUri).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		requestUri := *requestUri_ARM.(*DeliveryRuleRequestUriCondition_ARM)
		result.RequestUri = &requestUri
	}

	// Set property "ServerPort":
	if condition.ServerPort != nil {
		serverPort_ARM, err := (*condition.ServerPort).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		serverPort := *serverPort_ARM.(*DeliveryRuleServerPortCondition_ARM)
		result.ServerPort = &serverPort
	}

	// Set property "SocketAddr":
	if condition.SocketAddr != nil {
		socketAddr_ARM, err := (*condition.SocketAddr).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		socketAddr := *socketAddr_ARM.(*DeliveryRuleSocketAddrCondition_ARM)
		result.SocketAddr = &socketAddr
	}

	// Set property "SslProtocol":
	if condition.SslProtocol != nil {
		sslProtocol_ARM, err := (*condition.SslProtocol).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sslProtocol := *sslProtocol_ARM.(*DeliveryRuleSslProtocolCondition_ARM)
		result.SslProtocol = &sslProtocol
	}

	// Set property "UrlFileExtension":
	if condition.UrlFileExtension != nil {
		urlFileExtension_ARM, err := (*condition.UrlFileExtension).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		urlFileExtension := *urlFileExtension_ARM.(*DeliveryRuleUrlFileExtensionCondition_ARM)
		result.UrlFileExtension = &urlFileExtension
	}

	// Set property "UrlFileName":
	if condition.UrlFileName != nil {
		urlFileName_ARM, err := (*condition.UrlFileName).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		urlFileName := *urlFileName_ARM.(*DeliveryRuleUrlFileNameCondition_ARM)
		result.UrlFileName = &urlFileName
	}

	// Set property "UrlPath":
	if condition.UrlPath != nil {
		urlPath_ARM, err := (*condition.UrlPath).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		urlPath := *urlPath_ARM.(*DeliveryRuleUrlPathCondition_ARM)
		result.UrlPath = &urlPath
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleCondition_ARM, got %T", armInput)
	}

	// Set property "ClientPort":
	if typedInput.ClientPort != nil {
		var clientPort1 DeliveryRuleClientPortCondition
		err := clientPort1.PopulateFromARM(owner, *typedInput.ClientPort)
		if err != nil {
			return err
		}
		clientPort := clientPort1
		condition.ClientPort = &clientPort
	}

	// Set property "Cookies":
	if typedInput.Cookies != nil {
		var cookies1 DeliveryRuleCookiesCondition
		err := cookies1.PopulateFromARM(owner, *typedInput.Cookies)
		if err != nil {
			return err
		}
		cookies := cookies1
		condition.Cookies = &cookies
	}

	// Set property "HostName":
	if typedInput.HostName != nil {
		var hostName1 DeliveryRuleHostNameCondition
		err := hostName1.PopulateFromARM(owner, *typedInput.HostName)
		if err != nil {
			return err
		}
		hostName := hostName1
		condition.HostName = &hostName
	}

	// Set property "HttpVersion":
	if typedInput.HttpVersion != nil {
		var httpVersion1 DeliveryRuleHttpVersionCondition
		err := httpVersion1.PopulateFromARM(owner, *typedInput.HttpVersion)
		if err != nil {
			return err
		}
		httpVersion := httpVersion1
		condition.HttpVersion = &httpVersion
	}

	// Set property "IsDevice":
	if typedInput.IsDevice != nil {
		var isDevice1 DeliveryRuleIsDeviceCondition
		err := isDevice1.PopulateFromARM(owner, *typedInput.IsDevice)
		if err != nil {
			return err
		}
		isDevice := isDevice1
		condition.IsDevice = &isDevice
	}

	// Set property "PostArgs":
	if typedInput.PostArgs != nil {
		var postArgs1 DeliveryRulePostArgsCondition
		err := postArgs1.PopulateFromARM(owner, *typedInput.PostArgs)
		if err != nil {
			return err
		}
		postArgs := postArgs1
		condition.PostArgs = &postArgs
	}

	// Set property "QueryString":
	if typedInput.QueryString != nil {
		var queryString1 DeliveryRuleQueryStringCondition
		err := queryString1.PopulateFromARM(owner, *typedInput.QueryString)
		if err != nil {
			return err
		}
		queryString := queryString1
		condition.QueryString = &queryString
	}

	// Set property "RemoteAddress":
	if typedInput.RemoteAddress != nil {
		var remoteAddress1 DeliveryRuleRemoteAddressCondition
		err := remoteAddress1.PopulateFromARM(owner, *typedInput.RemoteAddress)
		if err != nil {
			return err
		}
		remoteAddress := remoteAddress1
		condition.RemoteAddress = &remoteAddress
	}

	// Set property "RequestBody":
	if typedInput.RequestBody != nil {
		var requestBody1 DeliveryRuleRequestBodyCondition
		err := requestBody1.PopulateFromARM(owner, *typedInput.RequestBody)
		if err != nil {
			return err
		}
		requestBody := requestBody1
		condition.RequestBody = &requestBody
	}

	// Set property "RequestHeader":
	if typedInput.RequestHeader != nil {
		var requestHeader1 DeliveryRuleRequestHeaderCondition
		err := requestHeader1.PopulateFromARM(owner, *typedInput.RequestHeader)
		if err != nil {
			return err
		}
		requestHeader := requestHeader1
		condition.RequestHeader = &requestHeader
	}

	// Set property "RequestMethod":
	if typedInput.RequestMethod != nil {
		var requestMethod1 DeliveryRuleRequestMethodCondition
		err := requestMethod1.PopulateFromARM(owner, *typedInput.RequestMethod)
		if err != nil {
			return err
		}
		requestMethod := requestMethod1
		condition.RequestMethod = &requestMethod
	}

	// Set property "RequestScheme":
	if typedInput.RequestScheme != nil {
		var requestScheme1 DeliveryRuleRequestSchemeCondition
		err := requestScheme1.PopulateFromARM(owner, *typedInput.RequestScheme)
		if err != nil {
			return err
		}
		requestScheme := requestScheme1
		condition.RequestScheme = &requestScheme
	}

	// Set property "RequestUri":
	if typedInput.RequestUri != nil {
		var requestUri1 DeliveryRuleRequestUriCondition
		err := requestUri1.PopulateFromARM(owner, *typedInput.RequestUri)
		if err != nil {
			return err
		}
		requestUri := requestUri1
		condition.RequestUri = &requestUri
	}

	// Set property "ServerPort":
	if typedInput.ServerPort != nil {
		var serverPort1 DeliveryRuleServerPortCondition
		err := serverPort1.PopulateFromARM(owner, *typedInput.ServerPort)
		if err != nil {
			return err
		}
		serverPort := serverPort1
		condition.ServerPort = &serverPort
	}

	// Set property "SocketAddr":
	if typedInput.SocketAddr != nil {
		var socketAddr1 DeliveryRuleSocketAddrCondition
		err := socketAddr1.PopulateFromARM(owner, *typedInput.SocketAddr)
		if err != nil {
			return err
		}
		socketAddr := socketAddr1
		condition.SocketAddr = &socketAddr
	}

	// Set property "SslProtocol":
	if typedInput.SslProtocol != nil {
		var sslProtocol1 DeliveryRuleSslProtocolCondition
		err := sslProtocol1.PopulateFromARM(owner, *typedInput.SslProtocol)
		if err != nil {
			return err
		}
		sslProtocol := sslProtocol1
		condition.SslProtocol = &sslProtocol
	}

	// Set property "UrlFileExtension":
	if typedInput.UrlFileExtension != nil {
		var urlFileExtension1 DeliveryRuleUrlFileExtensionCondition
		err := urlFileExtension1.PopulateFromARM(owner, *typedInput.UrlFileExtension)
		if err != nil {
			return err
		}
		urlFileExtension := urlFileExtension1
		condition.UrlFileExtension = &urlFileExtension
	}

	// Set property "UrlFileName":
	if typedInput.UrlFileName != nil {
		var urlFileName1 DeliveryRuleUrlFileNameCondition
		err := urlFileName1.PopulateFromARM(owner, *typedInput.UrlFileName)
		if err != nil {
			return err
		}
		urlFileName := urlFileName1
		condition.UrlFileName = &urlFileName
	}

	// Set property "UrlPath":
	if typedInput.UrlPath != nil {
		var urlPath1 DeliveryRuleUrlPathCondition
		err := urlPath1.PopulateFromARM(owner, *typedInput.UrlPath)
		if err != nil {
			return err
		}
		urlPath := urlPath1
		condition.UrlPath = &urlPath
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCondition populates our DeliveryRuleCondition from the provided source DeliveryRuleCondition
func (condition *DeliveryRuleCondition) AssignProperties_From_DeliveryRuleCondition(source *v20230501s.DeliveryRuleCondition) error {

	// ClientPort
	if source.ClientPort != nil {
		var clientPort DeliveryRuleClientPortCondition
		err := clientPort.AssignProperties_From_DeliveryRuleClientPortCondition(source.ClientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleClientPortCondition() to populate field ClientPort")
		}
		condition.ClientPort = &clientPort
	} else {
		condition.ClientPort = nil
	}

	// Cookies
	if source.Cookies != nil {
		var cookie DeliveryRuleCookiesCondition
		err := cookie.AssignProperties_From_DeliveryRuleCookiesCondition(source.Cookies)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCookiesCondition() to populate field Cookies")
		}
		condition.Cookies = &cookie
	} else {
		condition.Cookies = nil
	}

	// HostName
	if source.HostName != nil {
		var hostName DeliveryRuleHostNameCondition
		err := hostName.AssignProperties_From_DeliveryRuleHostNameCondition(source.HostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHostNameCondition() to populate field HostName")
		}
		condition.HostName = &hostName
	} else {
		condition.HostName = nil
	}

	// HttpVersion
	if source.HttpVersion != nil {
		var httpVersion DeliveryRuleHttpVersionCondition
		err := httpVersion.AssignProperties_From_DeliveryRuleHttpVersionCondition(source.HttpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHttpVersionCondition() to populate field HttpVersion")
		}
		condition.HttpVersion = &httpVersion
	} else {
		condition.HttpVersion = nil
	}

	// IsDevice
	if source.IsDevice != nil {
		var isDevice DeliveryRuleIsDeviceCondition
		err := isDevice.AssignProperties_From_DeliveryRuleIsDeviceCondition(source.IsDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleIsDeviceCondition() to populate field IsDevice")
		}
		condition.IsDevice = &isDevice
	} else {
		condition.IsDevice = nil
	}

	// PostArgs
	if source.PostArgs != nil {
		var postArg DeliveryRulePostArgsCondition
		err := postArg.AssignProperties_From_DeliveryRulePostArgsCondition(source.PostArgs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRulePostArgsCondition() to populate field PostArgs")
		}
		condition.PostArgs = &postArg
	} else {
		condition.PostArgs = nil
	}

	// QueryString
	if source.QueryString != nil {
		var queryString DeliveryRuleQueryStringCondition
		err := queryString.AssignProperties_From_DeliveryRuleQueryStringCondition(source.QueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleQueryStringCondition() to populate field QueryString")
		}
		condition.QueryString = &queryString
	} else {
		condition.QueryString = nil
	}

	// RemoteAddress
	if source.RemoteAddress != nil {
		var remoteAddress DeliveryRuleRemoteAddressCondition
		err := remoteAddress.AssignProperties_From_DeliveryRuleRemoteAddressCondition(source.RemoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRemoteAddressCondition() to populate field RemoteAddress")
		}
		condition.RemoteAddress = &remoteAddress
	} else {
		condition.RemoteAddress = nil
	}

	// RequestBody
	if source.RequestBody != nil {
		var requestBody DeliveryRuleRequestBodyCondition
		err := requestBody.AssignProperties_From_DeliveryRuleRequestBodyCondition(source.RequestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestBodyCondition() to populate field RequestBody")
		}
		condition.RequestBody = &requestBody
	} else {
		condition.RequestBody = nil
	}

	// RequestHeader
	if source.RequestHeader != nil {
		var requestHeader DeliveryRuleRequestHeaderCondition
		err := requestHeader.AssignProperties_From_DeliveryRuleRequestHeaderCondition(source.RequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderCondition() to populate field RequestHeader")
		}
		condition.RequestHeader = &requestHeader
	} else {
		condition.RequestHeader = nil
	}

	// RequestMethod
	if source.RequestMethod != nil {
		var requestMethod DeliveryRuleRequestMethodCondition
		err := requestMethod.AssignProperties_From_DeliveryRuleRequestMethodCondition(source.RequestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestMethodCondition() to populate field RequestMethod")
		}
		condition.RequestMethod = &requestMethod
	} else {
		condition.RequestMethod = nil
	}

	// RequestScheme
	if source.RequestScheme != nil {
		var requestScheme DeliveryRuleRequestSchemeCondition
		err := requestScheme.AssignProperties_From_DeliveryRuleRequestSchemeCondition(source.RequestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestSchemeCondition() to populate field RequestScheme")
		}
		condition.RequestScheme = &requestScheme
	} else {
		condition.RequestScheme = nil
	}

	// RequestUri
	if source.RequestUri != nil {
		var requestUri DeliveryRuleRequestUriCondition
		err := requestUri.AssignProperties_From_DeliveryRuleRequestUriCondition(source.RequestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestUriCondition() to populate field RequestUri")
		}
		condition.RequestUri = &requestUri
	} else {
		condition.RequestUri = nil
	}

	// ServerPort
	if source.ServerPort != nil {
		var serverPort DeliveryRuleServerPortCondition
		err := serverPort.AssignProperties_From_DeliveryRuleServerPortCondition(source.ServerPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleServerPortCondition() to populate field ServerPort")
		}
		condition.ServerPort = &serverPort
	} else {
		condition.ServerPort = nil
	}

	// SocketAddr
	if source.SocketAddr != nil {
		var socketAddr DeliveryRuleSocketAddrCondition
		err := socketAddr.AssignProperties_From_DeliveryRuleSocketAddrCondition(source.SocketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSocketAddrCondition() to populate field SocketAddr")
		}
		condition.SocketAddr = &socketAddr
	} else {
		condition.SocketAddr = nil
	}

	// SslProtocol
	if source.SslProtocol != nil {
		var sslProtocol DeliveryRuleSslProtocolCondition
		err := sslProtocol.AssignProperties_From_DeliveryRuleSslProtocolCondition(source.SslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSslProtocolCondition() to populate field SslProtocol")
		}
		condition.SslProtocol = &sslProtocol
	} else {
		condition.SslProtocol = nil
	}

	// UrlFileExtension
	if source.UrlFileExtension != nil {
		var urlFileExtension DeliveryRuleUrlFileExtensionCondition
		err := urlFileExtension.AssignProperties_From_DeliveryRuleUrlFileExtensionCondition(source.UrlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileExtensionCondition() to populate field UrlFileExtension")
		}
		condition.UrlFileExtension = &urlFileExtension
	} else {
		condition.UrlFileExtension = nil
	}

	// UrlFileName
	if source.UrlFileName != nil {
		var urlFileName DeliveryRuleUrlFileNameCondition
		err := urlFileName.AssignProperties_From_DeliveryRuleUrlFileNameCondition(source.UrlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileNameCondition() to populate field UrlFileName")
		}
		condition.UrlFileName = &urlFileName
	} else {
		condition.UrlFileName = nil
	}

	// UrlPath
	if source.UrlPath != nil {
		var urlPath DeliveryRuleUrlPathCondition
		err := urlPath.AssignProperties_From_DeliveryRuleUrlPathCondition(source.UrlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlPathCondition() to populate field UrlPath")
		}
		condition.UrlPath = &urlPath
	} else {
		condition.UrlPath = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCondition populates the provided destination DeliveryRuleCondition from our DeliveryRuleCondition
func (condition *DeliveryRuleCondition) AssignProperties_To_DeliveryRuleCondition(destination *v20230501s.DeliveryRuleCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientPort
	if condition.ClientPort != nil {
		var clientPort v20230501s.DeliveryRuleClientPortCondition
		err := condition.ClientPort.AssignProperties_To_DeliveryRuleClientPortCondition(&clientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleClientPortCondition() to populate field ClientPort")
		}
		destination.ClientPort = &clientPort
	} else {
		destination.ClientPort = nil
	}

	// Cookies
	if condition.Cookies != nil {
		var cookie v20230501s.DeliveryRuleCookiesCondition
		err := condition.Cookies.AssignProperties_To_DeliveryRuleCookiesCondition(&cookie)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCookiesCondition() to populate field Cookies")
		}
		destination.Cookies = &cookie
	} else {
		destination.Cookies = nil
	}

	// HostName
	if condition.HostName != nil {
		var hostName v20230501s.DeliveryRuleHostNameCondition
		err := condition.HostName.AssignProperties_To_DeliveryRuleHostNameCondition(&hostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHostNameCondition() to populate field HostName")
		}
		destination.HostName = &hostName
	} else {
		destination.HostName = nil
	}

	// HttpVersion
	if condition.HttpVersion != nil {
		var httpVersion v20230501s.DeliveryRuleHttpVersionCondition
		err := condition.HttpVersion.AssignProperties_To_DeliveryRuleHttpVersionCondition(&httpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHttpVersionCondition() to populate field HttpVersion")
		}
		destination.HttpVersion = &httpVersion
	} else {
		destination.HttpVersion = nil
	}

	// IsDevice
	if condition.IsDevice != nil {
		var isDevice v20230501s.DeliveryRuleIsDeviceCondition
		err := condition.IsDevice.AssignProperties_To_DeliveryRuleIsDeviceCondition(&isDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleIsDeviceCondition() to populate field IsDevice")
		}
		destination.IsDevice = &isDevice
	} else {
		destination.IsDevice = nil
	}

	// PostArgs
	if condition.PostArgs != nil {
		var postArg v20230501s.DeliveryRulePostArgsCondition
		err := condition.PostArgs.AssignProperties_To_DeliveryRulePostArgsCondition(&postArg)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRulePostArgsCondition() to populate field PostArgs")
		}
		destination.PostArgs = &postArg
	} else {
		destination.PostArgs = nil
	}

	// QueryString
	if condition.QueryString != nil {
		var queryString v20230501s.DeliveryRuleQueryStringCondition
		err := condition.QueryString.AssignProperties_To_DeliveryRuleQueryStringCondition(&queryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleQueryStringCondition() to populate field QueryString")
		}
		destination.QueryString = &queryString
	} else {
		destination.QueryString = nil
	}

	// RemoteAddress
	if condition.RemoteAddress != nil {
		var remoteAddress v20230501s.DeliveryRuleRemoteAddressCondition
		err := condition.RemoteAddress.AssignProperties_To_DeliveryRuleRemoteAddressCondition(&remoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRemoteAddressCondition() to populate field RemoteAddress")
		}
		destination.RemoteAddress = &remoteAddress
	} else {
		destination.RemoteAddress = nil
	}

	// RequestBody
	if condition.RequestBody != nil {
		var requestBody v20230501s.DeliveryRuleRequestBodyCondition
		err := condition.RequestBody.AssignProperties_To_DeliveryRuleRequestBodyCondition(&requestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestBodyCondition() to populate field RequestBody")
		}
		destination.RequestBody = &requestBody
	} else {
		destination.RequestBody = nil
	}

	// RequestHeader
	if condition.RequestHeader != nil {
		var requestHeader v20230501s.DeliveryRuleRequestHeaderCondition
		err := condition.RequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderCondition(&requestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderCondition() to populate field RequestHeader")
		}
		destination.RequestHeader = &requestHeader
	} else {
		destination.RequestHeader = nil
	}

	// RequestMethod
	if condition.RequestMethod != nil {
		var requestMethod v20230501s.DeliveryRuleRequestMethodCondition
		err := condition.RequestMethod.AssignProperties_To_DeliveryRuleRequestMethodCondition(&requestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestMethodCondition() to populate field RequestMethod")
		}
		destination.RequestMethod = &requestMethod
	} else {
		destination.RequestMethod = nil
	}

	// RequestScheme
	if condition.RequestScheme != nil {
		var requestScheme v20230501s.DeliveryRuleRequestSchemeCondition
		err := condition.RequestScheme.AssignProperties_To_DeliveryRuleRequestSchemeCondition(&requestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestSchemeCondition() to populate field RequestScheme")
		}
		destination.RequestScheme = &requestScheme
	} else {
		destination.RequestScheme = nil
	}

	// RequestUri
	if condition.RequestUri != nil {
		var requestUri v20230501s.DeliveryRuleRequestUriCondition
		err := condition.RequestUri.AssignProperties_To_DeliveryRuleRequestUriCondition(&requestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestUriCondition() to populate field RequestUri")
		}
		destination.RequestUri = &requestUri
	} else {
		destination.RequestUri = nil
	}

	// ServerPort
	if condition.ServerPort != nil {
		var serverPort v20230501s.DeliveryRuleServerPortCondition
		err := condition.ServerPort.AssignProperties_To_DeliveryRuleServerPortCondition(&serverPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleServerPortCondition() to populate field ServerPort")
		}
		destination.ServerPort = &serverPort
	} else {
		destination.ServerPort = nil
	}

	// SocketAddr
	if condition.SocketAddr != nil {
		var socketAddr v20230501s.DeliveryRuleSocketAddrCondition
		err := condition.SocketAddr.AssignProperties_To_DeliveryRuleSocketAddrCondition(&socketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSocketAddrCondition() to populate field SocketAddr")
		}
		destination.SocketAddr = &socketAddr
	} else {
		destination.SocketAddr = nil
	}

	// SslProtocol
	if condition.SslProtocol != nil {
		var sslProtocol v20230501s.DeliveryRuleSslProtocolCondition
		err := condition.SslProtocol.AssignProperties_To_DeliveryRuleSslProtocolCondition(&sslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSslProtocolCondition() to populate field SslProtocol")
		}
		destination.SslProtocol = &sslProtocol
	} else {
		destination.SslProtocol = nil
	}

	// UrlFileExtension
	if condition.UrlFileExtension != nil {
		var urlFileExtension v20230501s.DeliveryRuleUrlFileExtensionCondition
		err := condition.UrlFileExtension.AssignProperties_To_DeliveryRuleUrlFileExtensionCondition(&urlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileExtensionCondition() to populate field UrlFileExtension")
		}
		destination.UrlFileExtension = &urlFileExtension
	} else {
		destination.UrlFileExtension = nil
	}

	// UrlFileName
	if condition.UrlFileName != nil {
		var urlFileName v20230501s.DeliveryRuleUrlFileNameCondition
		err := condition.UrlFileName.AssignProperties_To_DeliveryRuleUrlFileNameCondition(&urlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileNameCondition() to populate field UrlFileName")
		}
		destination.UrlFileName = &urlFileName
	} else {
		destination.UrlFileName = nil
	}

	// UrlPath
	if condition.UrlPath != nil {
		var urlPath v20230501s.DeliveryRuleUrlPathCondition
		err := condition.UrlPath.AssignProperties_To_DeliveryRuleUrlPathCondition(&urlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlPathCondition() to populate field UrlPath")
		}
		destination.UrlPath = &urlPath
	} else {
		destination.UrlPath = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleCondition_STATUS populates our DeliveryRuleCondition from the provided source DeliveryRuleCondition_STATUS
func (condition *DeliveryRuleCondition) Initialize_From_DeliveryRuleCondition_STATUS(source *DeliveryRuleCondition_STATUS) error {

	// ClientPort
	if source.ClientPort != nil {
		var clientPort DeliveryRuleClientPortCondition
		err := clientPort.Initialize_From_DeliveryRuleClientPortCondition_STATUS(source.ClientPort)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleClientPortCondition_STATUS() to populate field ClientPort")
		}
		condition.ClientPort = &clientPort
	} else {
		condition.ClientPort = nil
	}

	// Cookies
	if source.Cookies != nil {
		var cookie DeliveryRuleCookiesCondition
		err := cookie.Initialize_From_DeliveryRuleCookiesCondition_STATUS(source.Cookies)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleCookiesCondition_STATUS() to populate field Cookies")
		}
		condition.Cookies = &cookie
	} else {
		condition.Cookies = nil
	}

	// HostName
	if source.HostName != nil {
		var hostName DeliveryRuleHostNameCondition
		err := hostName.Initialize_From_DeliveryRuleHostNameCondition_STATUS(source.HostName)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleHostNameCondition_STATUS() to populate field HostName")
		}
		condition.HostName = &hostName
	} else {
		condition.HostName = nil
	}

	// HttpVersion
	if source.HttpVersion != nil {
		var httpVersion DeliveryRuleHttpVersionCondition
		err := httpVersion.Initialize_From_DeliveryRuleHttpVersionCondition_STATUS(source.HttpVersion)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleHttpVersionCondition_STATUS() to populate field HttpVersion")
		}
		condition.HttpVersion = &httpVersion
	} else {
		condition.HttpVersion = nil
	}

	// IsDevice
	if source.IsDevice != nil {
		var isDevice DeliveryRuleIsDeviceCondition
		err := isDevice.Initialize_From_DeliveryRuleIsDeviceCondition_STATUS(source.IsDevice)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleIsDeviceCondition_STATUS() to populate field IsDevice")
		}
		condition.IsDevice = &isDevice
	} else {
		condition.IsDevice = nil
	}

	// PostArgs
	if source.PostArgs != nil {
		var postArg DeliveryRulePostArgsCondition
		err := postArg.Initialize_From_DeliveryRulePostArgsCondition_STATUS(source.PostArgs)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRulePostArgsCondition_STATUS() to populate field PostArgs")
		}
		condition.PostArgs = &postArg
	} else {
		condition.PostArgs = nil
	}

	// QueryString
	if source.QueryString != nil {
		var queryString DeliveryRuleQueryStringCondition
		err := queryString.Initialize_From_DeliveryRuleQueryStringCondition_STATUS(source.QueryString)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleQueryStringCondition_STATUS() to populate field QueryString")
		}
		condition.QueryString = &queryString
	} else {
		condition.QueryString = nil
	}

	// RemoteAddress
	if source.RemoteAddress != nil {
		var remoteAddress DeliveryRuleRemoteAddressCondition
		err := remoteAddress.Initialize_From_DeliveryRuleRemoteAddressCondition_STATUS(source.RemoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRemoteAddressCondition_STATUS() to populate field RemoteAddress")
		}
		condition.RemoteAddress = &remoteAddress
	} else {
		condition.RemoteAddress = nil
	}

	// RequestBody
	if source.RequestBody != nil {
		var requestBody DeliveryRuleRequestBodyCondition
		err := requestBody.Initialize_From_DeliveryRuleRequestBodyCondition_STATUS(source.RequestBody)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRequestBodyCondition_STATUS() to populate field RequestBody")
		}
		condition.RequestBody = &requestBody
	} else {
		condition.RequestBody = nil
	}

	// RequestHeader
	if source.RequestHeader != nil {
		var requestHeader DeliveryRuleRequestHeaderCondition
		err := requestHeader.Initialize_From_DeliveryRuleRequestHeaderCondition_STATUS(source.RequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRequestHeaderCondition_STATUS() to populate field RequestHeader")
		}
		condition.RequestHeader = &requestHeader
	} else {
		condition.RequestHeader = nil
	}

	// RequestMethod
	if source.RequestMethod != nil {
		var requestMethod DeliveryRuleRequestMethodCondition
		err := requestMethod.Initialize_From_DeliveryRuleRequestMethodCondition_STATUS(source.RequestMethod)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRequestMethodCondition_STATUS() to populate field RequestMethod")
		}
		condition.RequestMethod = &requestMethod
	} else {
		condition.RequestMethod = nil
	}

	// RequestScheme
	if source.RequestScheme != nil {
		var requestScheme DeliveryRuleRequestSchemeCondition
		err := requestScheme.Initialize_From_DeliveryRuleRequestSchemeCondition_STATUS(source.RequestScheme)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRequestSchemeCondition_STATUS() to populate field RequestScheme")
		}
		condition.RequestScheme = &requestScheme
	} else {
		condition.RequestScheme = nil
	}

	// RequestUri
	if source.RequestUri != nil {
		var requestUri DeliveryRuleRequestUriCondition
		err := requestUri.Initialize_From_DeliveryRuleRequestUriCondition_STATUS(source.RequestUri)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleRequestUriCondition_STATUS() to populate field RequestUri")
		}
		condition.RequestUri = &requestUri
	} else {
		condition.RequestUri = nil
	}

	// ServerPort
	if source.ServerPort != nil {
		var serverPort DeliveryRuleServerPortCondition
		err := serverPort.Initialize_From_DeliveryRuleServerPortCondition_STATUS(source.ServerPort)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleServerPortCondition_STATUS() to populate field ServerPort")
		}
		condition.ServerPort = &serverPort
	} else {
		condition.ServerPort = nil
	}

	// SocketAddr
	if source.SocketAddr != nil {
		var socketAddr DeliveryRuleSocketAddrCondition
		err := socketAddr.Initialize_From_DeliveryRuleSocketAddrCondition_STATUS(source.SocketAddr)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleSocketAddrCondition_STATUS() to populate field SocketAddr")
		}
		condition.SocketAddr = &socketAddr
	} else {
		condition.SocketAddr = nil
	}

	// SslProtocol
	if source.SslProtocol != nil {
		var sslProtocol DeliveryRuleSslProtocolCondition
		err := sslProtocol.Initialize_From_DeliveryRuleSslProtocolCondition_STATUS(source.SslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleSslProtocolCondition_STATUS() to populate field SslProtocol")
		}
		condition.SslProtocol = &sslProtocol
	} else {
		condition.SslProtocol = nil
	}

	// UrlFileExtension
	if source.UrlFileExtension != nil {
		var urlFileExtension DeliveryRuleUrlFileExtensionCondition
		err := urlFileExtension.Initialize_From_DeliveryRuleUrlFileExtensionCondition_STATUS(source.UrlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleUrlFileExtensionCondition_STATUS() to populate field UrlFileExtension")
		}
		condition.UrlFileExtension = &urlFileExtension
	} else {
		condition.UrlFileExtension = nil
	}

	// UrlFileName
	if source.UrlFileName != nil {
		var urlFileName DeliveryRuleUrlFileNameCondition
		err := urlFileName.Initialize_From_DeliveryRuleUrlFileNameCondition_STATUS(source.UrlFileName)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleUrlFileNameCondition_STATUS() to populate field UrlFileName")
		}
		condition.UrlFileName = &urlFileName
	} else {
		condition.UrlFileName = nil
	}

	// UrlPath
	if source.UrlPath != nil {
		var urlPath DeliveryRuleUrlPathCondition
		err := urlPath.Initialize_From_DeliveryRuleUrlPathCondition_STATUS(source.UrlPath)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_DeliveryRuleUrlPathCondition_STATUS() to populate field UrlPath")
		}
		condition.UrlPath = &urlPath
	} else {
		condition.UrlPath = nil
	}

	// No error
	return nil
}

// A condition for the delivery rule.
type DeliveryRuleCondition_STATUS struct {
	// ClientPort: Mutually exclusive with all other properties
	ClientPort *DeliveryRuleClientPortCondition_STATUS `json:"clientPort,omitempty"`

	// Cookies: Mutually exclusive with all other properties
	Cookies *DeliveryRuleCookiesCondition_STATUS `json:"cookies,omitempty"`

	// HostName: Mutually exclusive with all other properties
	HostName *DeliveryRuleHostNameCondition_STATUS `json:"hostName,omitempty"`

	// HttpVersion: Mutually exclusive with all other properties
	HttpVersion *DeliveryRuleHttpVersionCondition_STATUS `json:"httpVersion,omitempty"`

	// IsDevice: Mutually exclusive with all other properties
	IsDevice *DeliveryRuleIsDeviceCondition_STATUS `json:"isDevice,omitempty"`

	// PostArgs: Mutually exclusive with all other properties
	PostArgs *DeliveryRulePostArgsCondition_STATUS `json:"postArgs,omitempty"`

	// QueryString: Mutually exclusive with all other properties
	QueryString *DeliveryRuleQueryStringCondition_STATUS `json:"queryString,omitempty"`

	// RemoteAddress: Mutually exclusive with all other properties
	RemoteAddress *DeliveryRuleRemoteAddressCondition_STATUS `json:"remoteAddress,omitempty"`

	// RequestBody: Mutually exclusive with all other properties
	RequestBody *DeliveryRuleRequestBodyCondition_STATUS `json:"requestBody,omitempty"`

	// RequestHeader: Mutually exclusive with all other properties
	RequestHeader *DeliveryRuleRequestHeaderCondition_STATUS `json:"requestHeader,omitempty"`

	// RequestMethod: Mutually exclusive with all other properties
	RequestMethod *DeliveryRuleRequestMethodCondition_STATUS `json:"requestMethod,omitempty"`

	// RequestScheme: Mutually exclusive with all other properties
	RequestScheme *DeliveryRuleRequestSchemeCondition_STATUS `json:"requestScheme,omitempty"`

	// RequestUri: Mutually exclusive with all other properties
	RequestUri *DeliveryRuleRequestUriCondition_STATUS `json:"requestUri,omitempty"`

	// ServerPort: Mutually exclusive with all other properties
	ServerPort *DeliveryRuleServerPortCondition_STATUS `json:"serverPort,omitempty"`

	// SocketAddr: Mutually exclusive with all other properties
	SocketAddr *DeliveryRuleSocketAddrCondition_STATUS `json:"socketAddr,omitempty"`

	// SslProtocol: Mutually exclusive with all other properties
	SslProtocol *DeliveryRuleSslProtocolCondition_STATUS `json:"sslProtocol,omitempty"`

	// UrlFileExtension: Mutually exclusive with all other properties
	UrlFileExtension *DeliveryRuleUrlFileExtensionCondition_STATUS `json:"urlFileExtension,omitempty"`

	// UrlFileName: Mutually exclusive with all other properties
	UrlFileName *DeliveryRuleUrlFileNameCondition_STATUS `json:"urlFileName,omitempty"`

	// UrlPath: Mutually exclusive with all other properties
	UrlPath *DeliveryRuleUrlPathCondition_STATUS `json:"urlPath,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "ClientPort":
	if typedInput.ClientPort != nil {
		var clientPort1 DeliveryRuleClientPortCondition_STATUS
		err := clientPort1.PopulateFromARM(owner, *typedInput.ClientPort)
		if err != nil {
			return err
		}
		clientPort := clientPort1
		condition.ClientPort = &clientPort
	}

	// Set property "Cookies":
	if typedInput.Cookies != nil {
		var cookies1 DeliveryRuleCookiesCondition_STATUS
		err := cookies1.PopulateFromARM(owner, *typedInput.Cookies)
		if err != nil {
			return err
		}
		cookies := cookies1
		condition.Cookies = &cookies
	}

	// Set property "HostName":
	if typedInput.HostName != nil {
		var hostName1 DeliveryRuleHostNameCondition_STATUS
		err := hostName1.PopulateFromARM(owner, *typedInput.HostName)
		if err != nil {
			return err
		}
		hostName := hostName1
		condition.HostName = &hostName
	}

	// Set property "HttpVersion":
	if typedInput.HttpVersion != nil {
		var httpVersion1 DeliveryRuleHttpVersionCondition_STATUS
		err := httpVersion1.PopulateFromARM(owner, *typedInput.HttpVersion)
		if err != nil {
			return err
		}
		httpVersion := httpVersion1
		condition.HttpVersion = &httpVersion
	}

	// Set property "IsDevice":
	if typedInput.IsDevice != nil {
		var isDevice1 DeliveryRuleIsDeviceCondition_STATUS
		err := isDevice1.PopulateFromARM(owner, *typedInput.IsDevice)
		if err != nil {
			return err
		}
		isDevice := isDevice1
		condition.IsDevice = &isDevice
	}

	// Set property "PostArgs":
	if typedInput.PostArgs != nil {
		var postArgs1 DeliveryRulePostArgsCondition_STATUS
		err := postArgs1.PopulateFromARM(owner, *typedInput.PostArgs)
		if err != nil {
			return err
		}
		postArgs := postArgs1
		condition.PostArgs = &postArgs
	}

	// Set property "QueryString":
	if typedInput.QueryString != nil {
		var queryString1 DeliveryRuleQueryStringCondition_STATUS
		err := queryString1.PopulateFromARM(owner, *typedInput.QueryString)
		if err != nil {
			return err
		}
		queryString := queryString1
		condition.QueryString = &queryString
	}

	// Set property "RemoteAddress":
	if typedInput.RemoteAddress != nil {
		var remoteAddress1 DeliveryRuleRemoteAddressCondition_STATUS
		err := remoteAddress1.PopulateFromARM(owner, *typedInput.RemoteAddress)
		if err != nil {
			return err
		}
		remoteAddress := remoteAddress1
		condition.RemoteAddress = &remoteAddress
	}

	// Set property "RequestBody":
	if typedInput.RequestBody != nil {
		var requestBody1 DeliveryRuleRequestBodyCondition_STATUS
		err := requestBody1.PopulateFromARM(owner, *typedInput.RequestBody)
		if err != nil {
			return err
		}
		requestBody := requestBody1
		condition.RequestBody = &requestBody
	}

	// Set property "RequestHeader":
	if typedInput.RequestHeader != nil {
		var requestHeader1 DeliveryRuleRequestHeaderCondition_STATUS
		err := requestHeader1.PopulateFromARM(owner, *typedInput.RequestHeader)
		if err != nil {
			return err
		}
		requestHeader := requestHeader1
		condition.RequestHeader = &requestHeader
	}

	// Set property "RequestMethod":
	if typedInput.RequestMethod != nil {
		var requestMethod1 DeliveryRuleRequestMethodCondition_STATUS
		err := requestMethod1.PopulateFromARM(owner, *typedInput.RequestMethod)
		if err != nil {
			return err
		}
		requestMethod := requestMethod1
		condition.RequestMethod = &requestMethod
	}

	// Set property "RequestScheme":
	if typedInput.RequestScheme != nil {
		var requestScheme1 DeliveryRuleRequestSchemeCondition_STATUS
		err := requestScheme1.PopulateFromARM(owner, *typedInput.RequestScheme)
		if err != nil {
			return err
		}
		requestScheme := requestScheme1
		condition.RequestScheme = &requestScheme
	}

	// Set property "RequestUri":
	if typedInput.RequestUri != nil {
		var requestUri1 DeliveryRuleRequestUriCondition_STATUS
		err := requestUri1.PopulateFromARM(owner, *typedInput.RequestUri)
		if err != nil {
			return err
		}
		requestUri := requestUri1
		condition.RequestUri = &requestUri
	}

	// Set property "ServerPort":
	if typedInput.ServerPort != nil {
		var serverPort1 DeliveryRuleServerPortCondition_STATUS
		err := serverPort1.PopulateFromARM(owner, *typedInput.ServerPort)
		if err != nil {
			return err
		}
		serverPort := serverPort1
		condition.ServerPort = &serverPort
	}

	// Set property "SocketAddr":
	if typedInput.SocketAddr != nil {
		var socketAddr1 DeliveryRuleSocketAddrCondition_STATUS
		err := socketAddr1.PopulateFromARM(owner, *typedInput.SocketAddr)
		if err != nil {
			return err
		}
		socketAddr := socketAddr1
		condition.SocketAddr = &socketAddr
	}

	// Set property "SslProtocol":
	if typedInput.SslProtocol != nil {
		var sslProtocol1 DeliveryRuleSslProtocolCondition_STATUS
		err := sslProtocol1.PopulateFromARM(owner, *typedInput.SslProtocol)
		if err != nil {
			return err
		}
		sslProtocol := sslProtocol1
		condition.SslProtocol = &sslProtocol
	}

	// Set property "UrlFileExtension":
	if typedInput.UrlFileExtension != nil {
		var urlFileExtension1 DeliveryRuleUrlFileExtensionCondition_STATUS
		err := urlFileExtension1.PopulateFromARM(owner, *typedInput.UrlFileExtension)
		if err != nil {
			return err
		}
		urlFileExtension := urlFileExtension1
		condition.UrlFileExtension = &urlFileExtension
	}

	// Set property "UrlFileName":
	if typedInput.UrlFileName != nil {
		var urlFileName1 DeliveryRuleUrlFileNameCondition_STATUS
		err := urlFileName1.PopulateFromARM(owner, *typedInput.UrlFileName)
		if err != nil {
			return err
		}
		urlFileName := urlFileName1
		condition.UrlFileName = &urlFileName
	}

	// Set property "UrlPath":
	if typedInput.UrlPath != nil {
		var urlPath1 DeliveryRuleUrlPathCondition_STATUS
		err := urlPath1.PopulateFromARM(owner, *typedInput.UrlPath)
		if err != nil {
			return err
		}
		urlPath := urlPath1
		condition.UrlPath = &urlPath
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCondition_STATUS populates our DeliveryRuleCondition_STATUS from the provided source DeliveryRuleCondition_STATUS
func (condition *DeliveryRuleCondition_STATUS) AssignProperties_From_DeliveryRuleCondition_STATUS(source *v20230501s.DeliveryRuleCondition_STATUS) error {

	// ClientPort
	if source.ClientPort != nil {
		var clientPort DeliveryRuleClientPortCondition_STATUS
		err := clientPort.AssignProperties_From_DeliveryRuleClientPortCondition_STATUS(source.ClientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleClientPortCondition_STATUS() to populate field ClientPort")
		}
		condition.ClientPort = &clientPort
	} else {
		condition.ClientPort = nil
	}

	// Cookies
	if source.Cookies != nil {
		var cookie DeliveryRuleCookiesCondition_STATUS
		err := cookie.AssignProperties_From_DeliveryRuleCookiesCondition_STATUS(source.Cookies)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCookiesCondition_STATUS() to populate field Cookies")
		}
		condition.Cookies = &cookie
	} else {
		condition.Cookies = nil
	}

	// HostName
	if source.HostName != nil {
		var hostName DeliveryRuleHostNameCondition_STATUS
		err := hostName.AssignProperties_From_DeliveryRuleHostNameCondition_STATUS(source.HostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHostNameCondition_STATUS() to populate field HostName")
		}
		condition.HostName = &hostName
	} else {
		condition.HostName = nil
	}

	// HttpVersion
	if source.HttpVersion != nil {
		var httpVersion DeliveryRuleHttpVersionCondition_STATUS
		err := httpVersion.AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS(source.HttpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS() to populate field HttpVersion")
		}
		condition.HttpVersion = &httpVersion
	} else {
		condition.HttpVersion = nil
	}

	// IsDevice
	if source.IsDevice != nil {
		var isDevice DeliveryRuleIsDeviceCondition_STATUS
		err := isDevice.AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS(source.IsDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS() to populate field IsDevice")
		}
		condition.IsDevice = &isDevice
	} else {
		condition.IsDevice = nil
	}

	// PostArgs
	if source.PostArgs != nil {
		var postArg DeliveryRulePostArgsCondition_STATUS
		err := postArg.AssignProperties_From_DeliveryRulePostArgsCondition_STATUS(source.PostArgs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRulePostArgsCondition_STATUS() to populate field PostArgs")
		}
		condition.PostArgs = &postArg
	} else {
		condition.PostArgs = nil
	}

	// QueryString
	if source.QueryString != nil {
		var queryString DeliveryRuleQueryStringCondition_STATUS
		err := queryString.AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS(source.QueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS() to populate field QueryString")
		}
		condition.QueryString = &queryString
	} else {
		condition.QueryString = nil
	}

	// RemoteAddress
	if source.RemoteAddress != nil {
		var remoteAddress DeliveryRuleRemoteAddressCondition_STATUS
		err := remoteAddress.AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS(source.RemoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS() to populate field RemoteAddress")
		}
		condition.RemoteAddress = &remoteAddress
	} else {
		condition.RemoteAddress = nil
	}

	// RequestBody
	if source.RequestBody != nil {
		var requestBody DeliveryRuleRequestBodyCondition_STATUS
		err := requestBody.AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS(source.RequestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS() to populate field RequestBody")
		}
		condition.RequestBody = &requestBody
	} else {
		condition.RequestBody = nil
	}

	// RequestHeader
	if source.RequestHeader != nil {
		var requestHeader DeliveryRuleRequestHeaderCondition_STATUS
		err := requestHeader.AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS(source.RequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS() to populate field RequestHeader")
		}
		condition.RequestHeader = &requestHeader
	} else {
		condition.RequestHeader = nil
	}

	// RequestMethod
	if source.RequestMethod != nil {
		var requestMethod DeliveryRuleRequestMethodCondition_STATUS
		err := requestMethod.AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS(source.RequestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS() to populate field RequestMethod")
		}
		condition.RequestMethod = &requestMethod
	} else {
		condition.RequestMethod = nil
	}

	// RequestScheme
	if source.RequestScheme != nil {
		var requestScheme DeliveryRuleRequestSchemeCondition_STATUS
		err := requestScheme.AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS(source.RequestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS() to populate field RequestScheme")
		}
		condition.RequestScheme = &requestScheme
	} else {
		condition.RequestScheme = nil
	}

	// RequestUri
	if source.RequestUri != nil {
		var requestUri DeliveryRuleRequestUriCondition_STATUS
		err := requestUri.AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS(source.RequestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS() to populate field RequestUri")
		}
		condition.RequestUri = &requestUri
	} else {
		condition.RequestUri = nil
	}

	// ServerPort
	if source.ServerPort != nil {
		var serverPort DeliveryRuleServerPortCondition_STATUS
		err := serverPort.AssignProperties_From_DeliveryRuleServerPortCondition_STATUS(source.ServerPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleServerPortCondition_STATUS() to populate field ServerPort")
		}
		condition.ServerPort = &serverPort
	} else {
		condition.ServerPort = nil
	}

	// SocketAddr
	if source.SocketAddr != nil {
		var socketAddr DeliveryRuleSocketAddrCondition_STATUS
		err := socketAddr.AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS(source.SocketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS() to populate field SocketAddr")
		}
		condition.SocketAddr = &socketAddr
	} else {
		condition.SocketAddr = nil
	}

	// SslProtocol
	if source.SslProtocol != nil {
		var sslProtocol DeliveryRuleSslProtocolCondition_STATUS
		err := sslProtocol.AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS(source.SslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS() to populate field SslProtocol")
		}
		condition.SslProtocol = &sslProtocol
	} else {
		condition.SslProtocol = nil
	}

	// UrlFileExtension
	if source.UrlFileExtension != nil {
		var urlFileExtension DeliveryRuleUrlFileExtensionCondition_STATUS
		err := urlFileExtension.AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS(source.UrlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS() to populate field UrlFileExtension")
		}
		condition.UrlFileExtension = &urlFileExtension
	} else {
		condition.UrlFileExtension = nil
	}

	// UrlFileName
	if source.UrlFileName != nil {
		var urlFileName DeliveryRuleUrlFileNameCondition_STATUS
		err := urlFileName.AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS(source.UrlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS() to populate field UrlFileName")
		}
		condition.UrlFileName = &urlFileName
	} else {
		condition.UrlFileName = nil
	}

	// UrlPath
	if source.UrlPath != nil {
		var urlPath DeliveryRuleUrlPathCondition_STATUS
		err := urlPath.AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS(source.UrlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS() to populate field UrlPath")
		}
		condition.UrlPath = &urlPath
	} else {
		condition.UrlPath = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCondition_STATUS populates the provided destination DeliveryRuleCondition_STATUS from our DeliveryRuleCondition_STATUS
func (condition *DeliveryRuleCondition_STATUS) AssignProperties_To_DeliveryRuleCondition_STATUS(destination *v20230501s.DeliveryRuleCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ClientPort
	if condition.ClientPort != nil {
		var clientPort v20230501s.DeliveryRuleClientPortCondition_STATUS
		err := condition.ClientPort.AssignProperties_To_DeliveryRuleClientPortCondition_STATUS(&clientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleClientPortCondition_STATUS() to populate field ClientPort")
		}
		destination.ClientPort = &clientPort
	} else {
		destination.ClientPort = nil
	}

	// Cookies
	if condition.Cookies != nil {
		var cookie v20230501s.DeliveryRuleCookiesCondition_STATUS
		err := condition.Cookies.AssignProperties_To_DeliveryRuleCookiesCondition_STATUS(&cookie)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCookiesCondition_STATUS() to populate field Cookies")
		}
		destination.Cookies = &cookie
	} else {
		destination.Cookies = nil
	}

	// HostName
	if condition.HostName != nil {
		var hostName v20230501s.DeliveryRuleHostNameCondition_STATUS
		err := condition.HostName.AssignProperties_To_DeliveryRuleHostNameCondition_STATUS(&hostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHostNameCondition_STATUS() to populate field HostName")
		}
		destination.HostName = &hostName
	} else {
		destination.HostName = nil
	}

	// HttpVersion
	if condition.HttpVersion != nil {
		var httpVersion v20230501s.DeliveryRuleHttpVersionCondition_STATUS
		err := condition.HttpVersion.AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS(&httpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS() to populate field HttpVersion")
		}
		destination.HttpVersion = &httpVersion
	} else {
		destination.HttpVersion = nil
	}

	// IsDevice
	if condition.IsDevice != nil {
		var isDevice v20230501s.DeliveryRuleIsDeviceCondition_STATUS
		err := condition.IsDevice.AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS(&isDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS() to populate field IsDevice")
		}
		destination.IsDevice = &isDevice
	} else {
		destination.IsDevice = nil
	}

	// PostArgs
	if condition.PostArgs != nil {
		var postArg v20230501s.DeliveryRulePostArgsCondition_STATUS
		err := condition.PostArgs.AssignProperties_To_DeliveryRulePostArgsCondition_STATUS(&postArg)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRulePostArgsCondition_STATUS() to populate field PostArgs")
		}
		destination.PostArgs = &postArg
	} else {
		destination.PostArgs = nil
	}

	// QueryString
	if condition.QueryString != nil {
		var queryString v20230501s.DeliveryRuleQueryStringCondition_STATUS
		err := condition.QueryString.AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS(&queryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS() to populate field QueryString")
		}
		destination.QueryString = &queryString
	} else {
		destination.QueryString = nil
	}

	// RemoteAddress
	if condition.RemoteAddress != nil {
		var remoteAddress v20230501s.DeliveryRuleRemoteAddressCondition_STATUS
		err := condition.RemoteAddress.AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS(&remoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS() to populate field RemoteAddress")
		}
		destination.RemoteAddress = &remoteAddress
	} else {
		destination.RemoteAddress = nil
	}

	// RequestBody
	if condition.RequestBody != nil {
		var requestBody v20230501s.DeliveryRuleRequestBodyCondition_STATUS
		err := condition.RequestBody.AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS(&requestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS() to populate field RequestBody")
		}
		destination.RequestBody = &requestBody
	} else {
		destination.RequestBody = nil
	}

	// RequestHeader
	if condition.RequestHeader != nil {
		var requestHeader v20230501s.DeliveryRuleRequestHeaderCondition_STATUS
		err := condition.RequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS(&requestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS() to populate field RequestHeader")
		}
		destination.RequestHeader = &requestHeader
	} else {
		destination.RequestHeader = nil
	}

	// RequestMethod
	if condition.RequestMethod != nil {
		var requestMethod v20230501s.DeliveryRuleRequestMethodCondition_STATUS
		err := condition.RequestMethod.AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS(&requestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS() to populate field RequestMethod")
		}
		destination.RequestMethod = &requestMethod
	} else {
		destination.RequestMethod = nil
	}

	// RequestScheme
	if condition.RequestScheme != nil {
		var requestScheme v20230501s.DeliveryRuleRequestSchemeCondition_STATUS
		err := condition.RequestScheme.AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS(&requestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS() to populate field RequestScheme")
		}
		destination.RequestScheme = &requestScheme
	} else {
		destination.RequestScheme = nil
	}

	// RequestUri
	if condition.RequestUri != nil {
		var requestUri v20230501s.DeliveryRuleRequestUriCondition_STATUS
		err := condition.RequestUri.AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS(&requestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS() to populate field RequestUri")
		}
		destination.RequestUri = &requestUri
	} else {
		destination.RequestUri = nil
	}

	// ServerPort
	if condition.ServerPort != nil {
		var serverPort v20230501s.DeliveryRuleServerPortCondition_STATUS
		err := condition.ServerPort.AssignProperties_To_DeliveryRuleServerPortCondition_STATUS(&serverPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleServerPortCondition_STATUS() to populate field ServerPort")
		}
		destination.ServerPort = &serverPort
	} else {
		destination.ServerPort = nil
	}

	// SocketAddr
	if condition.SocketAddr != nil {
		var socketAddr v20230501s.DeliveryRuleSocketAddrCondition_STATUS
		err := condition.SocketAddr.AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS(&socketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS() to populate field SocketAddr")
		}
		destination.SocketAddr = &socketAddr
	} else {
		destination.SocketAddr = nil
	}

	// SslProtocol
	if condition.SslProtocol != nil {
		var sslProtocol v20230501s.DeliveryRuleSslProtocolCondition_STATUS
		err := condition.SslProtocol.AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS(&sslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS() to populate field SslProtocol")
		}
		destination.SslProtocol = &sslProtocol
	} else {
		destination.SslProtocol = nil
	}

	// UrlFileExtension
	if condition.UrlFileExtension != nil {
		var urlFileExtension v20230501s.DeliveryRuleUrlFileExtensionCondition_STATUS
		err := condition.UrlFileExtension.AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS(&urlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS() to populate field UrlFileExtension")
		}
		destination.UrlFileExtension = &urlFileExtension
	} else {
		destination.UrlFileExtension = nil
	}

	// UrlFileName
	if condition.UrlFileName != nil {
		var urlFileName v20230501s.DeliveryRuleUrlFileNameCondition_STATUS
		err := condition.UrlFileName.AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS(&urlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS() to populate field UrlFileName")
		}
		destination.UrlFileName = &urlFileName
	} else {
		destination.UrlFileName = nil
	}

	// UrlPath
	if condition.UrlPath != nil {
		var urlPath v20230501s.DeliveryRuleUrlPathCondition_STATUS
		err := condition.UrlPath.AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS(&urlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS() to populate field UrlPath")
		}
		destination.UrlPath = &urlPath
	} else {
		destination.UrlPath = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleCacheExpirationAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleCacheExpirationAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *CacheExpirationActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleCacheExpirationAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *DeliveryRuleCacheExpirationAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &DeliveryRuleCacheExpirationAction_ARM{}

	// Set property "Name":
	if action.Name != nil {
		result.Name = *action.Name
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*CacheExpirationActionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleCacheExpirationAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleCacheExpirationAction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleCacheExpirationAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleCacheExpirationAction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleCacheExpirationAction_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 CacheExpirationActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCacheExpirationAction populates our DeliveryRuleCacheExpirationAction from the provided source DeliveryRuleCacheExpirationAction
func (action *DeliveryRuleCacheExpirationAction) AssignProperties_From_DeliveryRuleCacheExpirationAction(source *v20230501s.DeliveryRuleCacheExpirationAction) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleCacheExpirationAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CacheExpirationActionParameters
		err := parameter.AssignProperties_From_CacheExpirationActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheExpirationActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheExpirationAction populates the provided destination DeliveryRuleCacheExpirationAction from our DeliveryRuleCacheExpirationAction
func (action *DeliveryRuleCacheExpirationAction) AssignProperties_To_DeliveryRuleCacheExpirationAction(destination *v20230501s.DeliveryRuleCacheExpirationAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.CacheExpirationActionParameters
		err := action.Parameters.AssignProperties_To_CacheExpirationActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheExpirationActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleCacheExpirationAction_STATUS populates our DeliveryRuleCacheExpirationAction from the provided source DeliveryRuleCacheExpirationAction_STATUS
func (action *DeliveryRuleCacheExpirationAction) Initialize_From_DeliveryRuleCacheExpirationAction_STATUS(source *DeliveryRuleCacheExpirationAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleCacheExpirationAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CacheExpirationActionParameters
		err := parameter.Initialize_From_CacheExpirationActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CacheExpirationActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleCacheExpirationAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleCacheExpirationAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *CacheExpirationActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleCacheExpirationAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleCacheExpirationAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleCacheExpirationAction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleCacheExpirationAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleCacheExpirationAction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleCacheExpirationAction_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 CacheExpirationActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS populates our DeliveryRuleCacheExpirationAction_STATUS from the provided source DeliveryRuleCacheExpirationAction_STATUS
func (action *DeliveryRuleCacheExpirationAction_STATUS) AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS(source *v20230501s.DeliveryRuleCacheExpirationAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleCacheExpirationAction_Name_STATUS(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CacheExpirationActionParameters_STATUS
		err := parameter.AssignProperties_From_CacheExpirationActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheExpirationActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS populates the provided destination DeliveryRuleCacheExpirationAction_STATUS from our DeliveryRuleCacheExpirationAction_STATUS
func (action *DeliveryRuleCacheExpirationAction_STATUS) AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS(destination *v20230501s.DeliveryRuleCacheExpirationAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.CacheExpirationActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_CacheExpirationActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheExpirationActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleCacheKeyQueryStringAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleCacheKeyQueryStringAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *CacheKeyQueryStringActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleCacheKeyQueryStringAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *DeliveryRuleCacheKeyQueryStringAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &DeliveryRuleCacheKeyQueryStringAction_ARM{}

	// Set property "Name":
	if action.Name != nil {
		result.Name = *action.Name
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*CacheKeyQueryStringActionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleCacheKeyQueryStringAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleCacheKeyQueryStringAction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleCacheKeyQueryStringAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleCacheKeyQueryStringAction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleCacheKeyQueryStringAction_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 CacheKeyQueryStringActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction populates our DeliveryRuleCacheKeyQueryStringAction from the provided source DeliveryRuleCacheKeyQueryStringAction
func (action *DeliveryRuleCacheKeyQueryStringAction) AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction(source *v20230501s.DeliveryRuleCacheKeyQueryStringAction) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleCacheKeyQueryStringAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CacheKeyQueryStringActionParameters
		err := parameter.AssignProperties_From_CacheKeyQueryStringActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheKeyQueryStringActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction populates the provided destination DeliveryRuleCacheKeyQueryStringAction from our DeliveryRuleCacheKeyQueryStringAction
func (action *DeliveryRuleCacheKeyQueryStringAction) AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction(destination *v20230501s.DeliveryRuleCacheKeyQueryStringAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.CacheKeyQueryStringActionParameters
		err := action.Parameters.AssignProperties_To_CacheKeyQueryStringActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheKeyQueryStringActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleCacheKeyQueryStringAction_STATUS populates our DeliveryRuleCacheKeyQueryStringAction from the provided source DeliveryRuleCacheKeyQueryStringAction_STATUS
func (action *DeliveryRuleCacheKeyQueryStringAction) Initialize_From_DeliveryRuleCacheKeyQueryStringAction_STATUS(source *DeliveryRuleCacheKeyQueryStringAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleCacheKeyQueryStringAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CacheKeyQueryStringActionParameters
		err := parameter.Initialize_From_CacheKeyQueryStringActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CacheKeyQueryStringActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleCacheKeyQueryStringAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleCacheKeyQueryStringAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *CacheKeyQueryStringActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleCacheKeyQueryStringAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleCacheKeyQueryStringAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleCacheKeyQueryStringAction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleCacheKeyQueryStringAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleCacheKeyQueryStringAction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleCacheKeyQueryStringAction_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 CacheKeyQueryStringActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS populates our DeliveryRuleCacheKeyQueryStringAction_STATUS from the provided source DeliveryRuleCacheKeyQueryStringAction_STATUS
func (action *DeliveryRuleCacheKeyQueryStringAction_STATUS) AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS(source *v20230501s.DeliveryRuleCacheKeyQueryStringAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleCacheKeyQueryStringAction_Name_STATUS(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CacheKeyQueryStringActionParameters_STATUS
		err := parameter.AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS populates the provided destination DeliveryRuleCacheKeyQueryStringAction_STATUS from our DeliveryRuleCacheKeyQueryStringAction_STATUS
func (action *DeliveryRuleCacheKeyQueryStringAction_STATUS) AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS(destination *v20230501s.DeliveryRuleCacheKeyQueryStringAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.CacheKeyQueryStringActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleClientPortCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleClientPortCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *ClientPortMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleClientPortCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleClientPortCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleClientPortCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*ClientPortMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleClientPortCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleClientPortCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleClientPortCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleClientPortCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleClientPortCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 ClientPortMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleClientPortCondition populates our DeliveryRuleClientPortCondition from the provided source DeliveryRuleClientPortCondition
func (condition *DeliveryRuleClientPortCondition) AssignProperties_From_DeliveryRuleClientPortCondition(source *v20230501s.DeliveryRuleClientPortCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleClientPortCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter ClientPortMatchConditionParameters
		err := parameter.AssignProperties_From_ClientPortMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ClientPortMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleClientPortCondition populates the provided destination DeliveryRuleClientPortCondition from our DeliveryRuleClientPortCondition
func (condition *DeliveryRuleClientPortCondition) AssignProperties_To_DeliveryRuleClientPortCondition(destination *v20230501s.DeliveryRuleClientPortCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.ClientPortMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_ClientPortMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ClientPortMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleClientPortCondition_STATUS populates our DeliveryRuleClientPortCondition from the provided source DeliveryRuleClientPortCondition_STATUS
func (condition *DeliveryRuleClientPortCondition) Initialize_From_DeliveryRuleClientPortCondition_STATUS(source *DeliveryRuleClientPortCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleClientPortCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter ClientPortMatchConditionParameters
		err := parameter.Initialize_From_ClientPortMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ClientPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleClientPortCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleClientPortCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *ClientPortMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleClientPortCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleClientPortCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleClientPortCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleClientPortCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleClientPortCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleClientPortCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 ClientPortMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleClientPortCondition_STATUS populates our DeliveryRuleClientPortCondition_STATUS from the provided source DeliveryRuleClientPortCondition_STATUS
func (condition *DeliveryRuleClientPortCondition_STATUS) AssignProperties_From_DeliveryRuleClientPortCondition_STATUS(source *v20230501s.DeliveryRuleClientPortCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleClientPortCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter ClientPortMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_ClientPortMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ClientPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleClientPortCondition_STATUS populates the provided destination DeliveryRuleClientPortCondition_STATUS from our DeliveryRuleClientPortCondition_STATUS
func (condition *DeliveryRuleClientPortCondition_STATUS) AssignProperties_To_DeliveryRuleClientPortCondition_STATUS(destination *v20230501s.DeliveryRuleClientPortCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.ClientPortMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_ClientPortMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ClientPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleCookiesCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleCookiesCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *CookiesMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleCookiesCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleCookiesCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleCookiesCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*CookiesMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleCookiesCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleCookiesCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleCookiesCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleCookiesCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleCookiesCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 CookiesMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCookiesCondition populates our DeliveryRuleCookiesCondition from the provided source DeliveryRuleCookiesCondition
func (condition *DeliveryRuleCookiesCondition) AssignProperties_From_DeliveryRuleCookiesCondition(source *v20230501s.DeliveryRuleCookiesCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleCookiesCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CookiesMatchConditionParameters
		err := parameter.AssignProperties_From_CookiesMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CookiesMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCookiesCondition populates the provided destination DeliveryRuleCookiesCondition from our DeliveryRuleCookiesCondition
func (condition *DeliveryRuleCookiesCondition) AssignProperties_To_DeliveryRuleCookiesCondition(destination *v20230501s.DeliveryRuleCookiesCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.CookiesMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_CookiesMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CookiesMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleCookiesCondition_STATUS populates our DeliveryRuleCookiesCondition from the provided source DeliveryRuleCookiesCondition_STATUS
func (condition *DeliveryRuleCookiesCondition) Initialize_From_DeliveryRuleCookiesCondition_STATUS(source *DeliveryRuleCookiesCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleCookiesCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CookiesMatchConditionParameters
		err := parameter.Initialize_From_CookiesMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CookiesMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleCookiesCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleCookiesCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *CookiesMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleCookiesCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleCookiesCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleCookiesCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleCookiesCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleCookiesCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleCookiesCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 CookiesMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleCookiesCondition_STATUS populates our DeliveryRuleCookiesCondition_STATUS from the provided source DeliveryRuleCookiesCondition_STATUS
func (condition *DeliveryRuleCookiesCondition_STATUS) AssignProperties_From_DeliveryRuleCookiesCondition_STATUS(source *v20230501s.DeliveryRuleCookiesCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleCookiesCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter CookiesMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_CookiesMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CookiesMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCookiesCondition_STATUS populates the provided destination DeliveryRuleCookiesCondition_STATUS from our DeliveryRuleCookiesCondition_STATUS
func (condition *DeliveryRuleCookiesCondition_STATUS) AssignProperties_To_DeliveryRuleCookiesCondition_STATUS(destination *v20230501s.DeliveryRuleCookiesCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.CookiesMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_CookiesMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CookiesMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleHostNameCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleHostNameCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *HostNameMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleHostNameCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleHostNameCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleHostNameCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*HostNameMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleHostNameCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleHostNameCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleHostNameCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleHostNameCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleHostNameCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HostNameMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleHostNameCondition populates our DeliveryRuleHostNameCondition from the provided source DeliveryRuleHostNameCondition
func (condition *DeliveryRuleHostNameCondition) AssignProperties_From_DeliveryRuleHostNameCondition(source *v20230501s.DeliveryRuleHostNameCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleHostNameCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HostNameMatchConditionParameters
		err := parameter.AssignProperties_From_HostNameMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HostNameMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHostNameCondition populates the provided destination DeliveryRuleHostNameCondition from our DeliveryRuleHostNameCondition
func (condition *DeliveryRuleHostNameCondition) AssignProperties_To_DeliveryRuleHostNameCondition(destination *v20230501s.DeliveryRuleHostNameCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.HostNameMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_HostNameMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HostNameMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleHostNameCondition_STATUS populates our DeliveryRuleHostNameCondition from the provided source DeliveryRuleHostNameCondition_STATUS
func (condition *DeliveryRuleHostNameCondition) Initialize_From_DeliveryRuleHostNameCondition_STATUS(source *DeliveryRuleHostNameCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleHostNameCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HostNameMatchConditionParameters
		err := parameter.Initialize_From_HostNameMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_HostNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleHostNameCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleHostNameCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *HostNameMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleHostNameCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleHostNameCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleHostNameCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleHostNameCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleHostNameCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleHostNameCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HostNameMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleHostNameCondition_STATUS populates our DeliveryRuleHostNameCondition_STATUS from the provided source DeliveryRuleHostNameCondition_STATUS
func (condition *DeliveryRuleHostNameCondition_STATUS) AssignProperties_From_DeliveryRuleHostNameCondition_STATUS(source *v20230501s.DeliveryRuleHostNameCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleHostNameCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HostNameMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_HostNameMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HostNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHostNameCondition_STATUS populates the provided destination DeliveryRuleHostNameCondition_STATUS from our DeliveryRuleHostNameCondition_STATUS
func (condition *DeliveryRuleHostNameCondition_STATUS) AssignProperties_To_DeliveryRuleHostNameCondition_STATUS(destination *v20230501s.DeliveryRuleHostNameCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.HostNameMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_HostNameMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HostNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleHttpVersionCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleHttpVersionCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *HttpVersionMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleHttpVersionCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleHttpVersionCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleHttpVersionCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*HttpVersionMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleHttpVersionCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleHttpVersionCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleHttpVersionCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleHttpVersionCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleHttpVersionCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HttpVersionMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleHttpVersionCondition populates our DeliveryRuleHttpVersionCondition from the provided source DeliveryRuleHttpVersionCondition
func (condition *DeliveryRuleHttpVersionCondition) AssignProperties_From_DeliveryRuleHttpVersionCondition(source *v20230501s.DeliveryRuleHttpVersionCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleHttpVersionCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HttpVersionMatchConditionParameters
		err := parameter.AssignProperties_From_HttpVersionMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HttpVersionMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHttpVersionCondition populates the provided destination DeliveryRuleHttpVersionCondition from our DeliveryRuleHttpVersionCondition
func (condition *DeliveryRuleHttpVersionCondition) AssignProperties_To_DeliveryRuleHttpVersionCondition(destination *v20230501s.DeliveryRuleHttpVersionCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.HttpVersionMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_HttpVersionMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HttpVersionMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleHttpVersionCondition_STATUS populates our DeliveryRuleHttpVersionCondition from the provided source DeliveryRuleHttpVersionCondition_STATUS
func (condition *DeliveryRuleHttpVersionCondition) Initialize_From_DeliveryRuleHttpVersionCondition_STATUS(source *DeliveryRuleHttpVersionCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleHttpVersionCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HttpVersionMatchConditionParameters
		err := parameter.Initialize_From_HttpVersionMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_HttpVersionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleHttpVersionCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleHttpVersionCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *HttpVersionMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleHttpVersionCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleHttpVersionCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleHttpVersionCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleHttpVersionCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleHttpVersionCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleHttpVersionCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HttpVersionMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS populates our DeliveryRuleHttpVersionCondition_STATUS from the provided source DeliveryRuleHttpVersionCondition_STATUS
func (condition *DeliveryRuleHttpVersionCondition_STATUS) AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS(source *v20230501s.DeliveryRuleHttpVersionCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleHttpVersionCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HttpVersionMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_HttpVersionMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HttpVersionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS populates the provided destination DeliveryRuleHttpVersionCondition_STATUS from our DeliveryRuleHttpVersionCondition_STATUS
func (condition *DeliveryRuleHttpVersionCondition_STATUS) AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS(destination *v20230501s.DeliveryRuleHttpVersionCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.HttpVersionMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_HttpVersionMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HttpVersionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleIsDeviceCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleIsDeviceCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *IsDeviceMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleIsDeviceCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleIsDeviceCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleIsDeviceCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*IsDeviceMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleIsDeviceCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleIsDeviceCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleIsDeviceCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleIsDeviceCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleIsDeviceCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 IsDeviceMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleIsDeviceCondition populates our DeliveryRuleIsDeviceCondition from the provided source DeliveryRuleIsDeviceCondition
func (condition *DeliveryRuleIsDeviceCondition) AssignProperties_From_DeliveryRuleIsDeviceCondition(source *v20230501s.DeliveryRuleIsDeviceCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleIsDeviceCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter IsDeviceMatchConditionParameters
		err := parameter.AssignProperties_From_IsDeviceMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IsDeviceMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleIsDeviceCondition populates the provided destination DeliveryRuleIsDeviceCondition from our DeliveryRuleIsDeviceCondition
func (condition *DeliveryRuleIsDeviceCondition) AssignProperties_To_DeliveryRuleIsDeviceCondition(destination *v20230501s.DeliveryRuleIsDeviceCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.IsDeviceMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_IsDeviceMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IsDeviceMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleIsDeviceCondition_STATUS populates our DeliveryRuleIsDeviceCondition from the provided source DeliveryRuleIsDeviceCondition_STATUS
func (condition *DeliveryRuleIsDeviceCondition) Initialize_From_DeliveryRuleIsDeviceCondition_STATUS(source *DeliveryRuleIsDeviceCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleIsDeviceCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter IsDeviceMatchConditionParameters
		err := parameter.Initialize_From_IsDeviceMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_IsDeviceMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleIsDeviceCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleIsDeviceCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *IsDeviceMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleIsDeviceCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleIsDeviceCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleIsDeviceCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleIsDeviceCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleIsDeviceCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleIsDeviceCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 IsDeviceMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS populates our DeliveryRuleIsDeviceCondition_STATUS from the provided source DeliveryRuleIsDeviceCondition_STATUS
func (condition *DeliveryRuleIsDeviceCondition_STATUS) AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS(source *v20230501s.DeliveryRuleIsDeviceCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleIsDeviceCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter IsDeviceMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_IsDeviceMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IsDeviceMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS populates the provided destination DeliveryRuleIsDeviceCondition_STATUS from our DeliveryRuleIsDeviceCondition_STATUS
func (condition *DeliveryRuleIsDeviceCondition_STATUS) AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS(destination *v20230501s.DeliveryRuleIsDeviceCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.IsDeviceMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_IsDeviceMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IsDeviceMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRulePostArgsCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRulePostArgsCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *PostArgsMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRulePostArgsCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRulePostArgsCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRulePostArgsCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*PostArgsMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRulePostArgsCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRulePostArgsCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRulePostArgsCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRulePostArgsCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRulePostArgsCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 PostArgsMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRulePostArgsCondition populates our DeliveryRulePostArgsCondition from the provided source DeliveryRulePostArgsCondition
func (condition *DeliveryRulePostArgsCondition) AssignProperties_From_DeliveryRulePostArgsCondition(source *v20230501s.DeliveryRulePostArgsCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRulePostArgsCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter PostArgsMatchConditionParameters
		err := parameter.AssignProperties_From_PostArgsMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PostArgsMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRulePostArgsCondition populates the provided destination DeliveryRulePostArgsCondition from our DeliveryRulePostArgsCondition
func (condition *DeliveryRulePostArgsCondition) AssignProperties_To_DeliveryRulePostArgsCondition(destination *v20230501s.DeliveryRulePostArgsCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.PostArgsMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_PostArgsMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PostArgsMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRulePostArgsCondition_STATUS populates our DeliveryRulePostArgsCondition from the provided source DeliveryRulePostArgsCondition_STATUS
func (condition *DeliveryRulePostArgsCondition) Initialize_From_DeliveryRulePostArgsCondition_STATUS(source *DeliveryRulePostArgsCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRulePostArgsCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter PostArgsMatchConditionParameters
		err := parameter.Initialize_From_PostArgsMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_PostArgsMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRulePostArgsCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRulePostArgsCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *PostArgsMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRulePostArgsCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRulePostArgsCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRulePostArgsCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRulePostArgsCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRulePostArgsCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRulePostArgsCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 PostArgsMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRulePostArgsCondition_STATUS populates our DeliveryRulePostArgsCondition_STATUS from the provided source DeliveryRulePostArgsCondition_STATUS
func (condition *DeliveryRulePostArgsCondition_STATUS) AssignProperties_From_DeliveryRulePostArgsCondition_STATUS(source *v20230501s.DeliveryRulePostArgsCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRulePostArgsCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter PostArgsMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_PostArgsMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PostArgsMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRulePostArgsCondition_STATUS populates the provided destination DeliveryRulePostArgsCondition_STATUS from our DeliveryRulePostArgsCondition_STATUS
func (condition *DeliveryRulePostArgsCondition_STATUS) AssignProperties_To_DeliveryRulePostArgsCondition_STATUS(destination *v20230501s.DeliveryRulePostArgsCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.PostArgsMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_PostArgsMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PostArgsMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleQueryStringCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleQueryStringCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *QueryStringMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleQueryStringCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleQueryStringCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleQueryStringCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*QueryStringMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleQueryStringCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleQueryStringCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleQueryStringCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleQueryStringCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleQueryStringCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 QueryStringMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleQueryStringCondition populates our DeliveryRuleQueryStringCondition from the provided source DeliveryRuleQueryStringCondition
func (condition *DeliveryRuleQueryStringCondition) AssignProperties_From_DeliveryRuleQueryStringCondition(source *v20230501s.DeliveryRuleQueryStringCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleQueryStringCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter QueryStringMatchConditionParameters
		err := parameter.AssignProperties_From_QueryStringMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_QueryStringMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleQueryStringCondition populates the provided destination DeliveryRuleQueryStringCondition from our DeliveryRuleQueryStringCondition
func (condition *DeliveryRuleQueryStringCondition) AssignProperties_To_DeliveryRuleQueryStringCondition(destination *v20230501s.DeliveryRuleQueryStringCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.QueryStringMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_QueryStringMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_QueryStringMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleQueryStringCondition_STATUS populates our DeliveryRuleQueryStringCondition from the provided source DeliveryRuleQueryStringCondition_STATUS
func (condition *DeliveryRuleQueryStringCondition) Initialize_From_DeliveryRuleQueryStringCondition_STATUS(source *DeliveryRuleQueryStringCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleQueryStringCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter QueryStringMatchConditionParameters
		err := parameter.Initialize_From_QueryStringMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_QueryStringMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleQueryStringCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleQueryStringCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *QueryStringMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleQueryStringCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleQueryStringCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleQueryStringCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleQueryStringCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleQueryStringCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleQueryStringCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 QueryStringMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS populates our DeliveryRuleQueryStringCondition_STATUS from the provided source DeliveryRuleQueryStringCondition_STATUS
func (condition *DeliveryRuleQueryStringCondition_STATUS) AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS(source *v20230501s.DeliveryRuleQueryStringCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleQueryStringCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter QueryStringMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_QueryStringMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_QueryStringMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS populates the provided destination DeliveryRuleQueryStringCondition_STATUS from our DeliveryRuleQueryStringCondition_STATUS
func (condition *DeliveryRuleQueryStringCondition_STATUS) AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS(destination *v20230501s.DeliveryRuleQueryStringCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.QueryStringMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_QueryStringMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_QueryStringMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRemoteAddressCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRemoteAddressCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *RemoteAddressMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRemoteAddressCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleRemoteAddressCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleRemoteAddressCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*RemoteAddressMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRemoteAddressCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRemoteAddressCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRemoteAddressCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRemoteAddressCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRemoteAddressCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RemoteAddressMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRemoteAddressCondition populates our DeliveryRuleRemoteAddressCondition from the provided source DeliveryRuleRemoteAddressCondition
func (condition *DeliveryRuleRemoteAddressCondition) AssignProperties_From_DeliveryRuleRemoteAddressCondition(source *v20230501s.DeliveryRuleRemoteAddressCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRemoteAddressCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RemoteAddressMatchConditionParameters
		err := parameter.AssignProperties_From_RemoteAddressMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RemoteAddressMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRemoteAddressCondition populates the provided destination DeliveryRuleRemoteAddressCondition from our DeliveryRuleRemoteAddressCondition
func (condition *DeliveryRuleRemoteAddressCondition) AssignProperties_To_DeliveryRuleRemoteAddressCondition(destination *v20230501s.DeliveryRuleRemoteAddressCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.RemoteAddressMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RemoteAddressMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RemoteAddressMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRemoteAddressCondition_STATUS populates our DeliveryRuleRemoteAddressCondition from the provided source DeliveryRuleRemoteAddressCondition_STATUS
func (condition *DeliveryRuleRemoteAddressCondition) Initialize_From_DeliveryRuleRemoteAddressCondition_STATUS(source *DeliveryRuleRemoteAddressCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRemoteAddressCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RemoteAddressMatchConditionParameters
		err := parameter.Initialize_From_RemoteAddressMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RemoteAddressMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRemoteAddressCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRemoteAddressCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *RemoteAddressMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRemoteAddressCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRemoteAddressCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRemoteAddressCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRemoteAddressCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRemoteAddressCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRemoteAddressCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RemoteAddressMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS populates our DeliveryRuleRemoteAddressCondition_STATUS from the provided source DeliveryRuleRemoteAddressCondition_STATUS
func (condition *DeliveryRuleRemoteAddressCondition_STATUS) AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS(source *v20230501s.DeliveryRuleRemoteAddressCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRemoteAddressCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RemoteAddressMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS populates the provided destination DeliveryRuleRemoteAddressCondition_STATUS from our DeliveryRuleRemoteAddressCondition_STATUS
func (condition *DeliveryRuleRemoteAddressCondition_STATUS) AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS(destination *v20230501s.DeliveryRuleRemoteAddressCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.RemoteAddressMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestBodyCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestBodyCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *RequestBodyMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRequestBodyCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleRequestBodyCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleRequestBodyCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*RequestBodyMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestBodyCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRequestBodyCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestBodyCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRequestBodyCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRequestBodyCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestBodyMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestBodyCondition populates our DeliveryRuleRequestBodyCondition from the provided source DeliveryRuleRequestBodyCondition
func (condition *DeliveryRuleRequestBodyCondition) AssignProperties_From_DeliveryRuleRequestBodyCondition(source *v20230501s.DeliveryRuleRequestBodyCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestBodyCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestBodyMatchConditionParameters
		err := parameter.AssignProperties_From_RequestBodyMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestBodyMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestBodyCondition populates the provided destination DeliveryRuleRequestBodyCondition from our DeliveryRuleRequestBodyCondition
func (condition *DeliveryRuleRequestBodyCondition) AssignProperties_To_DeliveryRuleRequestBodyCondition(destination *v20230501s.DeliveryRuleRequestBodyCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.RequestBodyMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestBodyMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestBodyMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRequestBodyCondition_STATUS populates our DeliveryRuleRequestBodyCondition from the provided source DeliveryRuleRequestBodyCondition_STATUS
func (condition *DeliveryRuleRequestBodyCondition) Initialize_From_DeliveryRuleRequestBodyCondition_STATUS(source *DeliveryRuleRequestBodyCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestBodyCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestBodyMatchConditionParameters
		err := parameter.Initialize_From_RequestBodyMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RequestBodyMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestBodyCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestBodyCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *RequestBodyMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRequestBodyCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestBodyCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRequestBodyCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestBodyCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRequestBodyCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRequestBodyCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestBodyMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS populates our DeliveryRuleRequestBodyCondition_STATUS from the provided source DeliveryRuleRequestBodyCondition_STATUS
func (condition *DeliveryRuleRequestBodyCondition_STATUS) AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS(source *v20230501s.DeliveryRuleRequestBodyCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestBodyCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestBodyMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestBodyMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestBodyMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS populates the provided destination DeliveryRuleRequestBodyCondition_STATUS from our DeliveryRuleRequestBodyCondition_STATUS
func (condition *DeliveryRuleRequestBodyCondition_STATUS) AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS(destination *v20230501s.DeliveryRuleRequestBodyCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.RequestBodyMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestBodyMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestBodyMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestHeaderAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleRequestHeaderAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *HeaderActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRequestHeaderAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *DeliveryRuleRequestHeaderAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &DeliveryRuleRequestHeaderAction_ARM{}

	// Set property "Name":
	if action.Name != nil {
		result.Name = *action.Name
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*HeaderActionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleRequestHeaderAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRequestHeaderAction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleRequestHeaderAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRequestHeaderAction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRequestHeaderAction_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HeaderActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestHeaderAction populates our DeliveryRuleRequestHeaderAction from the provided source DeliveryRuleRequestHeaderAction
func (action *DeliveryRuleRequestHeaderAction) AssignProperties_From_DeliveryRuleRequestHeaderAction(source *v20230501s.DeliveryRuleRequestHeaderAction) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestHeaderAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters
		err := parameter.AssignProperties_From_HeaderActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderAction populates the provided destination DeliveryRuleRequestHeaderAction from our DeliveryRuleRequestHeaderAction
func (action *DeliveryRuleRequestHeaderAction) AssignProperties_To_DeliveryRuleRequestHeaderAction(destination *v20230501s.DeliveryRuleRequestHeaderAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.HeaderActionParameters
		err := action.Parameters.AssignProperties_To_HeaderActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRequestHeaderAction_STATUS populates our DeliveryRuleRequestHeaderAction from the provided source DeliveryRuleRequestHeaderAction_STATUS
func (action *DeliveryRuleRequestHeaderAction) Initialize_From_DeliveryRuleRequestHeaderAction_STATUS(source *DeliveryRuleRequestHeaderAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestHeaderAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters
		err := parameter.Initialize_From_HeaderActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestHeaderAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleRequestHeaderAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *HeaderActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRequestHeaderAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleRequestHeaderAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRequestHeaderAction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleRequestHeaderAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRequestHeaderAction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRequestHeaderAction_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HeaderActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS populates our DeliveryRuleRequestHeaderAction_STATUS from the provided source DeliveryRuleRequestHeaderAction_STATUS
func (action *DeliveryRuleRequestHeaderAction_STATUS) AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS(source *v20230501s.DeliveryRuleRequestHeaderAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestHeaderAction_Name_STATUS(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters_STATUS
		err := parameter.AssignProperties_From_HeaderActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS populates the provided destination DeliveryRuleRequestHeaderAction_STATUS from our DeliveryRuleRequestHeaderAction_STATUS
func (action *DeliveryRuleRequestHeaderAction_STATUS) AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS(destination *v20230501s.DeliveryRuleRequestHeaderAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.HeaderActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_HeaderActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestHeaderCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestHeaderCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *RequestHeaderMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRequestHeaderCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleRequestHeaderCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleRequestHeaderCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*RequestHeaderMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestHeaderCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRequestHeaderCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestHeaderCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRequestHeaderCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRequestHeaderCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestHeaderMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestHeaderCondition populates our DeliveryRuleRequestHeaderCondition from the provided source DeliveryRuleRequestHeaderCondition
func (condition *DeliveryRuleRequestHeaderCondition) AssignProperties_From_DeliveryRuleRequestHeaderCondition(source *v20230501s.DeliveryRuleRequestHeaderCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestHeaderCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestHeaderMatchConditionParameters
		err := parameter.AssignProperties_From_RequestHeaderMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestHeaderMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderCondition populates the provided destination DeliveryRuleRequestHeaderCondition from our DeliveryRuleRequestHeaderCondition
func (condition *DeliveryRuleRequestHeaderCondition) AssignProperties_To_DeliveryRuleRequestHeaderCondition(destination *v20230501s.DeliveryRuleRequestHeaderCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.RequestHeaderMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestHeaderMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestHeaderMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRequestHeaderCondition_STATUS populates our DeliveryRuleRequestHeaderCondition from the provided source DeliveryRuleRequestHeaderCondition_STATUS
func (condition *DeliveryRuleRequestHeaderCondition) Initialize_From_DeliveryRuleRequestHeaderCondition_STATUS(source *DeliveryRuleRequestHeaderCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestHeaderCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestHeaderMatchConditionParameters
		err := parameter.Initialize_From_RequestHeaderMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RequestHeaderMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestHeaderCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestHeaderCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *RequestHeaderMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRequestHeaderCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestHeaderCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRequestHeaderCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestHeaderCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRequestHeaderCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRequestHeaderCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestHeaderMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS populates our DeliveryRuleRequestHeaderCondition_STATUS from the provided source DeliveryRuleRequestHeaderCondition_STATUS
func (condition *DeliveryRuleRequestHeaderCondition_STATUS) AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS(source *v20230501s.DeliveryRuleRequestHeaderCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestHeaderCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestHeaderMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS populates the provided destination DeliveryRuleRequestHeaderCondition_STATUS from our DeliveryRuleRequestHeaderCondition_STATUS
func (condition *DeliveryRuleRequestHeaderCondition_STATUS) AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS(destination *v20230501s.DeliveryRuleRequestHeaderCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.RequestHeaderMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestMethodCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestMethodCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *RequestMethodMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRequestMethodCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleRequestMethodCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleRequestMethodCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*RequestMethodMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestMethodCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRequestMethodCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestMethodCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRequestMethodCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRequestMethodCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestMethodMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestMethodCondition populates our DeliveryRuleRequestMethodCondition from the provided source DeliveryRuleRequestMethodCondition
func (condition *DeliveryRuleRequestMethodCondition) AssignProperties_From_DeliveryRuleRequestMethodCondition(source *v20230501s.DeliveryRuleRequestMethodCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestMethodCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestMethodMatchConditionParameters
		err := parameter.AssignProperties_From_RequestMethodMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestMethodMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestMethodCondition populates the provided destination DeliveryRuleRequestMethodCondition from our DeliveryRuleRequestMethodCondition
func (condition *DeliveryRuleRequestMethodCondition) AssignProperties_To_DeliveryRuleRequestMethodCondition(destination *v20230501s.DeliveryRuleRequestMethodCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.RequestMethodMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestMethodMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestMethodMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRequestMethodCondition_STATUS populates our DeliveryRuleRequestMethodCondition from the provided source DeliveryRuleRequestMethodCondition_STATUS
func (condition *DeliveryRuleRequestMethodCondition) Initialize_From_DeliveryRuleRequestMethodCondition_STATUS(source *DeliveryRuleRequestMethodCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestMethodCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestMethodMatchConditionParameters
		err := parameter.Initialize_From_RequestMethodMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RequestMethodMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestMethodCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestMethodCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *RequestMethodMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRequestMethodCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestMethodCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRequestMethodCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestMethodCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRequestMethodCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRequestMethodCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestMethodMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS populates our DeliveryRuleRequestMethodCondition_STATUS from the provided source DeliveryRuleRequestMethodCondition_STATUS
func (condition *DeliveryRuleRequestMethodCondition_STATUS) AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS(source *v20230501s.DeliveryRuleRequestMethodCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestMethodCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestMethodMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestMethodMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestMethodMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS populates the provided destination DeliveryRuleRequestMethodCondition_STATUS from our DeliveryRuleRequestMethodCondition_STATUS
func (condition *DeliveryRuleRequestMethodCondition_STATUS) AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS(destination *v20230501s.DeliveryRuleRequestMethodCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.RequestMethodMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestMethodMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestMethodMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestSchemeCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestSchemeCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *RequestSchemeMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRequestSchemeCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleRequestSchemeCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleRequestSchemeCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*RequestSchemeMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestSchemeCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRequestSchemeCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestSchemeCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRequestSchemeCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRequestSchemeCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestSchemeMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestSchemeCondition populates our DeliveryRuleRequestSchemeCondition from the provided source DeliveryRuleRequestSchemeCondition
func (condition *DeliveryRuleRequestSchemeCondition) AssignProperties_From_DeliveryRuleRequestSchemeCondition(source *v20230501s.DeliveryRuleRequestSchemeCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestSchemeCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestSchemeMatchConditionParameters
		err := parameter.AssignProperties_From_RequestSchemeMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestSchemeMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestSchemeCondition populates the provided destination DeliveryRuleRequestSchemeCondition from our DeliveryRuleRequestSchemeCondition
func (condition *DeliveryRuleRequestSchemeCondition) AssignProperties_To_DeliveryRuleRequestSchemeCondition(destination *v20230501s.DeliveryRuleRequestSchemeCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.RequestSchemeMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestSchemeMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestSchemeMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRequestSchemeCondition_STATUS populates our DeliveryRuleRequestSchemeCondition from the provided source DeliveryRuleRequestSchemeCondition_STATUS
func (condition *DeliveryRuleRequestSchemeCondition) Initialize_From_DeliveryRuleRequestSchemeCondition_STATUS(source *DeliveryRuleRequestSchemeCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestSchemeCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestSchemeMatchConditionParameters
		err := parameter.Initialize_From_RequestSchemeMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RequestSchemeMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestSchemeCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestSchemeCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *RequestSchemeMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRequestSchemeCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestSchemeCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRequestSchemeCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestSchemeCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRequestSchemeCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRequestSchemeCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestSchemeMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS populates our DeliveryRuleRequestSchemeCondition_STATUS from the provided source DeliveryRuleRequestSchemeCondition_STATUS
func (condition *DeliveryRuleRequestSchemeCondition_STATUS) AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS(source *v20230501s.DeliveryRuleRequestSchemeCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestSchemeCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestSchemeMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS populates the provided destination DeliveryRuleRequestSchemeCondition_STATUS from our DeliveryRuleRequestSchemeCondition_STATUS
func (condition *DeliveryRuleRequestSchemeCondition_STATUS) AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS(destination *v20230501s.DeliveryRuleRequestSchemeCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.RequestSchemeMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestUriCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestUriCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *RequestUriMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRequestUriCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleRequestUriCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleRequestUriCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*RequestUriMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestUriCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRequestUriCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestUriCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRequestUriCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRequestUriCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestUriMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestUriCondition populates our DeliveryRuleRequestUriCondition from the provided source DeliveryRuleRequestUriCondition
func (condition *DeliveryRuleRequestUriCondition) AssignProperties_From_DeliveryRuleRequestUriCondition(source *v20230501s.DeliveryRuleRequestUriCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestUriCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestUriMatchConditionParameters
		err := parameter.AssignProperties_From_RequestUriMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestUriMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestUriCondition populates the provided destination DeliveryRuleRequestUriCondition from our DeliveryRuleRequestUriCondition
func (condition *DeliveryRuleRequestUriCondition) AssignProperties_To_DeliveryRuleRequestUriCondition(destination *v20230501s.DeliveryRuleRequestUriCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.RequestUriMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestUriMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestUriMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRequestUriCondition_STATUS populates our DeliveryRuleRequestUriCondition from the provided source DeliveryRuleRequestUriCondition_STATUS
func (condition *DeliveryRuleRequestUriCondition) Initialize_From_DeliveryRuleRequestUriCondition_STATUS(source *DeliveryRuleRequestUriCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestUriCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestUriMatchConditionParameters
		err := parameter.Initialize_From_RequestUriMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RequestUriMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRequestUriCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleRequestUriCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *RequestUriMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRequestUriCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleRequestUriCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRequestUriCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleRequestUriCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRequestUriCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRequestUriCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RequestUriMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS populates our DeliveryRuleRequestUriCondition_STATUS from the provided source DeliveryRuleRequestUriCondition_STATUS
func (condition *DeliveryRuleRequestUriCondition_STATUS) AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS(source *v20230501s.DeliveryRuleRequestUriCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRequestUriCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RequestUriMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestUriMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestUriMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS populates the provided destination DeliveryRuleRequestUriCondition_STATUS from our DeliveryRuleRequestUriCondition_STATUS
func (condition *DeliveryRuleRequestUriCondition_STATUS) AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS(destination *v20230501s.DeliveryRuleRequestUriCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.RequestUriMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestUriMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestUriMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleResponseHeaderAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleResponseHeaderAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *HeaderActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleResponseHeaderAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *DeliveryRuleResponseHeaderAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &DeliveryRuleResponseHeaderAction_ARM{}

	// Set property "Name":
	if action.Name != nil {
		result.Name = *action.Name
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*HeaderActionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleResponseHeaderAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleResponseHeaderAction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleResponseHeaderAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleResponseHeaderAction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleResponseHeaderAction_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HeaderActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleResponseHeaderAction populates our DeliveryRuleResponseHeaderAction from the provided source DeliveryRuleResponseHeaderAction
func (action *DeliveryRuleResponseHeaderAction) AssignProperties_From_DeliveryRuleResponseHeaderAction(source *v20230501s.DeliveryRuleResponseHeaderAction) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleResponseHeaderAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters
		err := parameter.AssignProperties_From_HeaderActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleResponseHeaderAction populates the provided destination DeliveryRuleResponseHeaderAction from our DeliveryRuleResponseHeaderAction
func (action *DeliveryRuleResponseHeaderAction) AssignProperties_To_DeliveryRuleResponseHeaderAction(destination *v20230501s.DeliveryRuleResponseHeaderAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.HeaderActionParameters
		err := action.Parameters.AssignProperties_To_HeaderActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleResponseHeaderAction_STATUS populates our DeliveryRuleResponseHeaderAction from the provided source DeliveryRuleResponseHeaderAction_STATUS
func (action *DeliveryRuleResponseHeaderAction) Initialize_From_DeliveryRuleResponseHeaderAction_STATUS(source *DeliveryRuleResponseHeaderAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleResponseHeaderAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters
		err := parameter.Initialize_From_HeaderActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleResponseHeaderAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleResponseHeaderAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *HeaderActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleResponseHeaderAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleResponseHeaderAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleResponseHeaderAction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleResponseHeaderAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleResponseHeaderAction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleResponseHeaderAction_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 HeaderActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS populates our DeliveryRuleResponseHeaderAction_STATUS from the provided source DeliveryRuleResponseHeaderAction_STATUS
func (action *DeliveryRuleResponseHeaderAction_STATUS) AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS(source *v20230501s.DeliveryRuleResponseHeaderAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleResponseHeaderAction_Name_STATUS(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters_STATUS
		err := parameter.AssignProperties_From_HeaderActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS populates the provided destination DeliveryRuleResponseHeaderAction_STATUS from our DeliveryRuleResponseHeaderAction_STATUS
func (action *DeliveryRuleResponseHeaderAction_STATUS) AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS(destination *v20230501s.DeliveryRuleResponseHeaderAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.HeaderActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_HeaderActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleRouteConfigurationOverrideAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleRouteConfigurationOverrideAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *RouteConfigurationOverrideActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleRouteConfigurationOverrideAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *DeliveryRuleRouteConfigurationOverrideAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &DeliveryRuleRouteConfigurationOverrideAction_ARM{}

	// Set property "Name":
	if action.Name != nil {
		result.Name = *action.Name
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*RouteConfigurationOverrideActionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleRouteConfigurationOverrideAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRouteConfigurationOverrideAction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleRouteConfigurationOverrideAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRouteConfigurationOverrideAction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRouteConfigurationOverrideAction_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RouteConfigurationOverrideActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction populates our DeliveryRuleRouteConfigurationOverrideAction from the provided source DeliveryRuleRouteConfigurationOverrideAction
func (action *DeliveryRuleRouteConfigurationOverrideAction) AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction(source *v20230501s.DeliveryRuleRouteConfigurationOverrideAction) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRouteConfigurationOverrideAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RouteConfigurationOverrideActionParameters
		err := parameter.AssignProperties_From_RouteConfigurationOverrideActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RouteConfigurationOverrideActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction populates the provided destination DeliveryRuleRouteConfigurationOverrideAction from our DeliveryRuleRouteConfigurationOverrideAction
func (action *DeliveryRuleRouteConfigurationOverrideAction) AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction(destination *v20230501s.DeliveryRuleRouteConfigurationOverrideAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.RouteConfigurationOverrideActionParameters
		err := action.Parameters.AssignProperties_To_RouteConfigurationOverrideActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RouteConfigurationOverrideActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS populates our DeliveryRuleRouteConfigurationOverrideAction from the provided source DeliveryRuleRouteConfigurationOverrideAction_STATUS
func (action *DeliveryRuleRouteConfigurationOverrideAction) Initialize_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS(source *DeliveryRuleRouteConfigurationOverrideAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRouteConfigurationOverrideAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RouteConfigurationOverrideActionParameters
		err := parameter.Initialize_From_RouteConfigurationOverrideActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_RouteConfigurationOverrideActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleRouteConfigurationOverrideAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleRouteConfigurationOverrideAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *RouteConfigurationOverrideActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleRouteConfigurationOverrideAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleRouteConfigurationOverrideAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleRouteConfigurationOverrideAction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleRouteConfigurationOverrideAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleRouteConfigurationOverrideAction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleRouteConfigurationOverrideAction_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 RouteConfigurationOverrideActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS populates our DeliveryRuleRouteConfigurationOverrideAction_STATUS from the provided source DeliveryRuleRouteConfigurationOverrideAction_STATUS
func (action *DeliveryRuleRouteConfigurationOverrideAction_STATUS) AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS(source *v20230501s.DeliveryRuleRouteConfigurationOverrideAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleRouteConfigurationOverrideAction_Name_STATUS(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter RouteConfigurationOverrideActionParameters_STATUS
		err := parameter.AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS populates the provided destination DeliveryRuleRouteConfigurationOverrideAction_STATUS from our DeliveryRuleRouteConfigurationOverrideAction_STATUS
func (action *DeliveryRuleRouteConfigurationOverrideAction_STATUS) AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS(destination *v20230501s.DeliveryRuleRouteConfigurationOverrideAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.RouteConfigurationOverrideActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleServerPortCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleServerPortCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *ServerPortMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleServerPortCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleServerPortCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleServerPortCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*ServerPortMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleServerPortCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleServerPortCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleServerPortCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleServerPortCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleServerPortCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 ServerPortMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleServerPortCondition populates our DeliveryRuleServerPortCondition from the provided source DeliveryRuleServerPortCondition
func (condition *DeliveryRuleServerPortCondition) AssignProperties_From_DeliveryRuleServerPortCondition(source *v20230501s.DeliveryRuleServerPortCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleServerPortCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter ServerPortMatchConditionParameters
		err := parameter.AssignProperties_From_ServerPortMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPortMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleServerPortCondition populates the provided destination DeliveryRuleServerPortCondition from our DeliveryRuleServerPortCondition
func (condition *DeliveryRuleServerPortCondition) AssignProperties_To_DeliveryRuleServerPortCondition(destination *v20230501s.DeliveryRuleServerPortCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.ServerPortMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_ServerPortMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPortMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleServerPortCondition_STATUS populates our DeliveryRuleServerPortCondition from the provided source DeliveryRuleServerPortCondition_STATUS
func (condition *DeliveryRuleServerPortCondition) Initialize_From_DeliveryRuleServerPortCondition_STATUS(source *DeliveryRuleServerPortCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleServerPortCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter ServerPortMatchConditionParameters
		err := parameter.Initialize_From_ServerPortMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ServerPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleServerPortCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleServerPortCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *ServerPortMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleServerPortCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleServerPortCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleServerPortCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleServerPortCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleServerPortCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleServerPortCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 ServerPortMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleServerPortCondition_STATUS populates our DeliveryRuleServerPortCondition_STATUS from the provided source DeliveryRuleServerPortCondition_STATUS
func (condition *DeliveryRuleServerPortCondition_STATUS) AssignProperties_From_DeliveryRuleServerPortCondition_STATUS(source *v20230501s.DeliveryRuleServerPortCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleServerPortCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter ServerPortMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_ServerPortMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleServerPortCondition_STATUS populates the provided destination DeliveryRuleServerPortCondition_STATUS from our DeliveryRuleServerPortCondition_STATUS
func (condition *DeliveryRuleServerPortCondition_STATUS) AssignProperties_To_DeliveryRuleServerPortCondition_STATUS(destination *v20230501s.DeliveryRuleServerPortCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.ServerPortMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_ServerPortMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleSocketAddrCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleSocketAddrCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *SocketAddrMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleSocketAddrCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleSocketAddrCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleSocketAddrCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*SocketAddrMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleSocketAddrCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleSocketAddrCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleSocketAddrCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleSocketAddrCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleSocketAddrCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 SocketAddrMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleSocketAddrCondition populates our DeliveryRuleSocketAddrCondition from the provided source DeliveryRuleSocketAddrCondition
func (condition *DeliveryRuleSocketAddrCondition) AssignProperties_From_DeliveryRuleSocketAddrCondition(source *v20230501s.DeliveryRuleSocketAddrCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleSocketAddrCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter SocketAddrMatchConditionParameters
		err := parameter.AssignProperties_From_SocketAddrMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SocketAddrMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSocketAddrCondition populates the provided destination DeliveryRuleSocketAddrCondition from our DeliveryRuleSocketAddrCondition
func (condition *DeliveryRuleSocketAddrCondition) AssignProperties_To_DeliveryRuleSocketAddrCondition(destination *v20230501s.DeliveryRuleSocketAddrCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.SocketAddrMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_SocketAddrMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SocketAddrMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleSocketAddrCondition_STATUS populates our DeliveryRuleSocketAddrCondition from the provided source DeliveryRuleSocketAddrCondition_STATUS
func (condition *DeliveryRuleSocketAddrCondition) Initialize_From_DeliveryRuleSocketAddrCondition_STATUS(source *DeliveryRuleSocketAddrCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleSocketAddrCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter SocketAddrMatchConditionParameters
		err := parameter.Initialize_From_SocketAddrMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SocketAddrMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleSocketAddrCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleSocketAddrCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *SocketAddrMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleSocketAddrCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleSocketAddrCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleSocketAddrCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleSocketAddrCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleSocketAddrCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleSocketAddrCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 SocketAddrMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS populates our DeliveryRuleSocketAddrCondition_STATUS from the provided source DeliveryRuleSocketAddrCondition_STATUS
func (condition *DeliveryRuleSocketAddrCondition_STATUS) AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS(source *v20230501s.DeliveryRuleSocketAddrCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleSocketAddrCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter SocketAddrMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_SocketAddrMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SocketAddrMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS populates the provided destination DeliveryRuleSocketAddrCondition_STATUS from our DeliveryRuleSocketAddrCondition_STATUS
func (condition *DeliveryRuleSocketAddrCondition_STATUS) AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS(destination *v20230501s.DeliveryRuleSocketAddrCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.SocketAddrMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_SocketAddrMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SocketAddrMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleSslProtocolCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleSslProtocolCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *SslProtocolMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleSslProtocolCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleSslProtocolCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleSslProtocolCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*SslProtocolMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleSslProtocolCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleSslProtocolCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleSslProtocolCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleSslProtocolCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleSslProtocolCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 SslProtocolMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleSslProtocolCondition populates our DeliveryRuleSslProtocolCondition from the provided source DeliveryRuleSslProtocolCondition
func (condition *DeliveryRuleSslProtocolCondition) AssignProperties_From_DeliveryRuleSslProtocolCondition(source *v20230501s.DeliveryRuleSslProtocolCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleSslProtocolCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter SslProtocolMatchConditionParameters
		err := parameter.AssignProperties_From_SslProtocolMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SslProtocolMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSslProtocolCondition populates the provided destination DeliveryRuleSslProtocolCondition from our DeliveryRuleSslProtocolCondition
func (condition *DeliveryRuleSslProtocolCondition) AssignProperties_To_DeliveryRuleSslProtocolCondition(destination *v20230501s.DeliveryRuleSslProtocolCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.SslProtocolMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_SslProtocolMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SslProtocolMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleSslProtocolCondition_STATUS populates our DeliveryRuleSslProtocolCondition from the provided source DeliveryRuleSslProtocolCondition_STATUS
func (condition *DeliveryRuleSslProtocolCondition) Initialize_From_DeliveryRuleSslProtocolCondition_STATUS(source *DeliveryRuleSslProtocolCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleSslProtocolCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter SslProtocolMatchConditionParameters
		err := parameter.Initialize_From_SslProtocolMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_SslProtocolMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleSslProtocolCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleSslProtocolCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *SslProtocolMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleSslProtocolCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleSslProtocolCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleSslProtocolCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleSslProtocolCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleSslProtocolCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleSslProtocolCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 SslProtocolMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS populates our DeliveryRuleSslProtocolCondition_STATUS from the provided source DeliveryRuleSslProtocolCondition_STATUS
func (condition *DeliveryRuleSslProtocolCondition_STATUS) AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS(source *v20230501s.DeliveryRuleSslProtocolCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleSslProtocolCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter SslProtocolMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_SslProtocolMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SslProtocolMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS populates the provided destination DeliveryRuleSslProtocolCondition_STATUS from our DeliveryRuleSslProtocolCondition_STATUS
func (condition *DeliveryRuleSslProtocolCondition_STATUS) AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS(destination *v20230501s.DeliveryRuleSslProtocolCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.SslProtocolMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_SslProtocolMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SslProtocolMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleUrlFileExtensionCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleUrlFileExtensionCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *UrlFileExtensionMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleUrlFileExtensionCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleUrlFileExtensionCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleUrlFileExtensionCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*UrlFileExtensionMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleUrlFileExtensionCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleUrlFileExtensionCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleUrlFileExtensionCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleUrlFileExtensionCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleUrlFileExtensionCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlFileExtensionMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleUrlFileExtensionCondition populates our DeliveryRuleUrlFileExtensionCondition from the provided source DeliveryRuleUrlFileExtensionCondition
func (condition *DeliveryRuleUrlFileExtensionCondition) AssignProperties_From_DeliveryRuleUrlFileExtensionCondition(source *v20230501s.DeliveryRuleUrlFileExtensionCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleUrlFileExtensionCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileExtensionMatchConditionParameters
		err := parameter.AssignProperties_From_UrlFileExtensionMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileExtensionMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileExtensionCondition populates the provided destination DeliveryRuleUrlFileExtensionCondition from our DeliveryRuleUrlFileExtensionCondition
func (condition *DeliveryRuleUrlFileExtensionCondition) AssignProperties_To_DeliveryRuleUrlFileExtensionCondition(destination *v20230501s.DeliveryRuleUrlFileExtensionCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.UrlFileExtensionMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_UrlFileExtensionMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileExtensionMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleUrlFileExtensionCondition_STATUS populates our DeliveryRuleUrlFileExtensionCondition from the provided source DeliveryRuleUrlFileExtensionCondition_STATUS
func (condition *DeliveryRuleUrlFileExtensionCondition) Initialize_From_DeliveryRuleUrlFileExtensionCondition_STATUS(source *DeliveryRuleUrlFileExtensionCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleUrlFileExtensionCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileExtensionMatchConditionParameters
		err := parameter.Initialize_From_UrlFileExtensionMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlFileExtensionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleUrlFileExtensionCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleUrlFileExtensionCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *UrlFileExtensionMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleUrlFileExtensionCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleUrlFileExtensionCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleUrlFileExtensionCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleUrlFileExtensionCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleUrlFileExtensionCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleUrlFileExtensionCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlFileExtensionMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS populates our DeliveryRuleUrlFileExtensionCondition_STATUS from the provided source DeliveryRuleUrlFileExtensionCondition_STATUS
func (condition *DeliveryRuleUrlFileExtensionCondition_STATUS) AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS(source *v20230501s.DeliveryRuleUrlFileExtensionCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleUrlFileExtensionCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileExtensionMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS populates the provided destination DeliveryRuleUrlFileExtensionCondition_STATUS from our DeliveryRuleUrlFileExtensionCondition_STATUS
func (condition *DeliveryRuleUrlFileExtensionCondition_STATUS) AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS(destination *v20230501s.DeliveryRuleUrlFileExtensionCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.UrlFileExtensionMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleUrlFileNameCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleUrlFileNameCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *UrlFileNameMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleUrlFileNameCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleUrlFileNameCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleUrlFileNameCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*UrlFileNameMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleUrlFileNameCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleUrlFileNameCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleUrlFileNameCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleUrlFileNameCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleUrlFileNameCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlFileNameMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleUrlFileNameCondition populates our DeliveryRuleUrlFileNameCondition from the provided source DeliveryRuleUrlFileNameCondition
func (condition *DeliveryRuleUrlFileNameCondition) AssignProperties_From_DeliveryRuleUrlFileNameCondition(source *v20230501s.DeliveryRuleUrlFileNameCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleUrlFileNameCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileNameMatchConditionParameters
		err := parameter.AssignProperties_From_UrlFileNameMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileNameMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileNameCondition populates the provided destination DeliveryRuleUrlFileNameCondition from our DeliveryRuleUrlFileNameCondition
func (condition *DeliveryRuleUrlFileNameCondition) AssignProperties_To_DeliveryRuleUrlFileNameCondition(destination *v20230501s.DeliveryRuleUrlFileNameCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.UrlFileNameMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_UrlFileNameMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileNameMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleUrlFileNameCondition_STATUS populates our DeliveryRuleUrlFileNameCondition from the provided source DeliveryRuleUrlFileNameCondition_STATUS
func (condition *DeliveryRuleUrlFileNameCondition) Initialize_From_DeliveryRuleUrlFileNameCondition_STATUS(source *DeliveryRuleUrlFileNameCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleUrlFileNameCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileNameMatchConditionParameters
		err := parameter.Initialize_From_UrlFileNameMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlFileNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleUrlFileNameCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleUrlFileNameCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *UrlFileNameMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleUrlFileNameCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleUrlFileNameCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleUrlFileNameCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleUrlFileNameCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleUrlFileNameCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleUrlFileNameCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlFileNameMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS populates our DeliveryRuleUrlFileNameCondition_STATUS from the provided source DeliveryRuleUrlFileNameCondition_STATUS
func (condition *DeliveryRuleUrlFileNameCondition_STATUS) AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS(source *v20230501s.DeliveryRuleUrlFileNameCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleUrlFileNameCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileNameMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS populates the provided destination DeliveryRuleUrlFileNameCondition_STATUS from our DeliveryRuleUrlFileNameCondition_STATUS
func (condition *DeliveryRuleUrlFileNameCondition_STATUS) AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS(destination *v20230501s.DeliveryRuleUrlFileNameCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.UrlFileNameMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleUrlPathCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleUrlPathCondition_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the condition.
	Parameters *UrlPathMatchConditionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleUrlPathCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleUrlPathCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleUrlPathCondition_ARM{}

	// Set property "Name":
	if condition.Name != nil {
		result.Name = *condition.Name
	}

	// Set property "Parameters":
	if condition.Parameters != nil {
		parameters_ARM, err := (*condition.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*UrlPathMatchConditionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleUrlPathCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleUrlPathCondition_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleUrlPathCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleUrlPathCondition_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleUrlPathCondition_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlPathMatchConditionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleUrlPathCondition populates our DeliveryRuleUrlPathCondition from the provided source DeliveryRuleUrlPathCondition
func (condition *DeliveryRuleUrlPathCondition) AssignProperties_From_DeliveryRuleUrlPathCondition(source *v20230501s.DeliveryRuleUrlPathCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleUrlPathCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlPathMatchConditionParameters
		err := parameter.AssignProperties_From_UrlPathMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlPathMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlPathCondition populates the provided destination DeliveryRuleUrlPathCondition from our DeliveryRuleUrlPathCondition
func (condition *DeliveryRuleUrlPathCondition) AssignProperties_To_DeliveryRuleUrlPathCondition(destination *v20230501s.DeliveryRuleUrlPathCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.UrlPathMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_UrlPathMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlPathMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_DeliveryRuleUrlPathCondition_STATUS populates our DeliveryRuleUrlPathCondition from the provided source DeliveryRuleUrlPathCondition_STATUS
func (condition *DeliveryRuleUrlPathCondition) Initialize_From_DeliveryRuleUrlPathCondition_STATUS(source *DeliveryRuleUrlPathCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleUrlPathCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlPathMatchConditionParameters
		err := parameter.Initialize_From_UrlPathMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlPathMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

type DeliveryRuleUrlPathCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleUrlPathCondition_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the condition.
	Parameters *UrlPathMatchConditionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleUrlPathCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleUrlPathCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleUrlPathCondition_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleUrlPathCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleUrlPathCondition_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleUrlPathCondition_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	condition.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlPathMatchConditionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		condition.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS populates our DeliveryRuleUrlPathCondition_STATUS from the provided source DeliveryRuleUrlPathCondition_STATUS
func (condition *DeliveryRuleUrlPathCondition_STATUS) AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS(source *v20230501s.DeliveryRuleUrlPathCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleUrlPathCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlPathMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_UrlPathMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlPathMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS populates the provided destination DeliveryRuleUrlPathCondition_STATUS from our DeliveryRuleUrlPathCondition_STATUS
func (condition *DeliveryRuleUrlPathCondition_STATUS) AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS(destination *v20230501s.DeliveryRuleUrlPathCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if condition.Parameters != nil {
		var parameter v20230501s.UrlPathMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_UrlPathMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlPathMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type OriginGroupOverrideAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *OriginGroupOverrideAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *OriginGroupOverrideActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &OriginGroupOverrideAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *OriginGroupOverrideAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &OriginGroupOverrideAction_ARM{}

	// Set property "Name":
	if action.Name != nil {
		result.Name = *action.Name
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*OriginGroupOverrideActionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *OriginGroupOverrideAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OriginGroupOverrideAction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *OriginGroupOverrideAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OriginGroupOverrideAction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OriginGroupOverrideAction_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 OriginGroupOverrideActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_OriginGroupOverrideAction populates our OriginGroupOverrideAction from the provided source OriginGroupOverrideAction
func (action *OriginGroupOverrideAction) AssignProperties_From_OriginGroupOverrideAction(source *v20230501s.OriginGroupOverrideAction) error {

	// Name
	if source.Name != nil {
		name := OriginGroupOverrideAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter OriginGroupOverrideActionParameters
		err := parameter.AssignProperties_From_OriginGroupOverrideActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideAction populates the provided destination OriginGroupOverrideAction from our OriginGroupOverrideAction
func (action *OriginGroupOverrideAction) AssignProperties_To_OriginGroupOverrideAction(destination *v20230501s.OriginGroupOverrideAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.OriginGroupOverrideActionParameters
		err := action.Parameters.AssignProperties_To_OriginGroupOverrideActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OriginGroupOverrideAction_STATUS populates our OriginGroupOverrideAction from the provided source OriginGroupOverrideAction_STATUS
func (action *OriginGroupOverrideAction) Initialize_From_OriginGroupOverrideAction_STATUS(source *OriginGroupOverrideAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := OriginGroupOverrideAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter OriginGroupOverrideActionParameters
		err := parameter.Initialize_From_OriginGroupOverrideActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_OriginGroupOverrideActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type OriginGroupOverrideAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *OriginGroupOverrideAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *OriginGroupOverrideActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &OriginGroupOverrideAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *OriginGroupOverrideAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OriginGroupOverrideAction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *OriginGroupOverrideAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OriginGroupOverrideAction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OriginGroupOverrideAction_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 OriginGroupOverrideActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_OriginGroupOverrideAction_STATUS populates our OriginGroupOverrideAction_STATUS from the provided source OriginGroupOverrideAction_STATUS
func (action *OriginGroupOverrideAction_STATUS) AssignProperties_From_OriginGroupOverrideAction_STATUS(source *v20230501s.OriginGroupOverrideAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := OriginGroupOverrideAction_Name_STATUS(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter OriginGroupOverrideActionParameters_STATUS
		err := parameter.AssignProperties_From_OriginGroupOverrideActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideAction_STATUS populates the provided destination OriginGroupOverrideAction_STATUS from our OriginGroupOverrideAction_STATUS
func (action *OriginGroupOverrideAction_STATUS) AssignProperties_To_OriginGroupOverrideAction_STATUS(destination *v20230501s.OriginGroupOverrideAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.OriginGroupOverrideActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_OriginGroupOverrideActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UrlRedirectAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *UrlRedirectAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *UrlRedirectActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlRedirectAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *UrlRedirectAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &UrlRedirectAction_ARM{}

	// Set property "Name":
	if action.Name != nil {
		result.Name = *action.Name
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*UrlRedirectActionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *UrlRedirectAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlRedirectAction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *UrlRedirectAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlRedirectAction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlRedirectAction_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlRedirectActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRedirectAction populates our UrlRedirectAction from the provided source UrlRedirectAction
func (action *UrlRedirectAction) AssignProperties_From_UrlRedirectAction(source *v20230501s.UrlRedirectAction) error {

	// Name
	if source.Name != nil {
		name := UrlRedirectAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRedirectActionParameters
		err := parameter.AssignProperties_From_UrlRedirectActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectAction populates the provided destination UrlRedirectAction from our UrlRedirectAction
func (action *UrlRedirectAction) AssignProperties_To_UrlRedirectAction(destination *v20230501s.UrlRedirectAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.UrlRedirectActionParameters
		err := action.Parameters.AssignProperties_To_UrlRedirectActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlRedirectAction_STATUS populates our UrlRedirectAction from the provided source UrlRedirectAction_STATUS
func (action *UrlRedirectAction) Initialize_From_UrlRedirectAction_STATUS(source *UrlRedirectAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := UrlRedirectAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRedirectActionParameters
		err := parameter.Initialize_From_UrlRedirectActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlRedirectActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type UrlRedirectAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *UrlRedirectAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *UrlRedirectActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlRedirectAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *UrlRedirectAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlRedirectAction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *UrlRedirectAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlRedirectAction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlRedirectAction_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlRedirectActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRedirectAction_STATUS populates our UrlRedirectAction_STATUS from the provided source UrlRedirectAction_STATUS
func (action *UrlRedirectAction_STATUS) AssignProperties_From_UrlRedirectAction_STATUS(source *v20230501s.UrlRedirectAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := UrlRedirectAction_Name_STATUS(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRedirectActionParameters_STATUS
		err := parameter.AssignProperties_From_UrlRedirectActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectAction_STATUS populates the provided destination UrlRedirectAction_STATUS from our UrlRedirectAction_STATUS
func (action *UrlRedirectAction_STATUS) AssignProperties_To_UrlRedirectAction_STATUS(destination *v20230501s.UrlRedirectAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.UrlRedirectActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_UrlRedirectActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UrlRewriteAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *UrlRewriteAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *UrlRewriteActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlRewriteAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *UrlRewriteAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &UrlRewriteAction_ARM{}

	// Set property "Name":
	if action.Name != nil {
		result.Name = *action.Name
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*UrlRewriteActionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *UrlRewriteAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlRewriteAction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *UrlRewriteAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlRewriteAction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlRewriteAction_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlRewriteActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRewriteAction populates our UrlRewriteAction from the provided source UrlRewriteAction
func (action *UrlRewriteAction) AssignProperties_From_UrlRewriteAction(source *v20230501s.UrlRewriteAction) error {

	// Name
	if source.Name != nil {
		name := UrlRewriteAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRewriteActionParameters
		err := parameter.AssignProperties_From_UrlRewriteActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteAction populates the provided destination UrlRewriteAction from our UrlRewriteAction
func (action *UrlRewriteAction) AssignProperties_To_UrlRewriteAction(destination *v20230501s.UrlRewriteAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.UrlRewriteActionParameters
		err := action.Parameters.AssignProperties_To_UrlRewriteActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlRewriteAction_STATUS populates our UrlRewriteAction from the provided source UrlRewriteAction_STATUS
func (action *UrlRewriteAction) Initialize_From_UrlRewriteAction_STATUS(source *UrlRewriteAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := UrlRewriteAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRewriteActionParameters
		err := parameter.Initialize_From_UrlRewriteActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlRewriteActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type UrlRewriteAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *UrlRewriteAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *UrlRewriteActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlRewriteAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *UrlRewriteAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlRewriteAction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *UrlRewriteAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlRewriteAction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlRewriteAction_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlRewriteActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRewriteAction_STATUS populates our UrlRewriteAction_STATUS from the provided source UrlRewriteAction_STATUS
func (action *UrlRewriteAction_STATUS) AssignProperties_From_UrlRewriteAction_STATUS(source *v20230501s.UrlRewriteAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := UrlRewriteAction_Name_STATUS(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRewriteActionParameters_STATUS
		err := parameter.AssignProperties_From_UrlRewriteActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteAction_STATUS populates the provided destination UrlRewriteAction_STATUS from our UrlRewriteAction_STATUS
func (action *UrlRewriteAction_STATUS) AssignProperties_To_UrlRewriteAction_STATUS(destination *v20230501s.UrlRewriteAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.UrlRewriteActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_UrlRewriteActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UrlSigningAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *UrlSigningAction_Name `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Parameters: Defines the parameters for the action.
	Parameters *UrlSigningActionParameters `json:"parameters,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlSigningAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *UrlSigningAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &UrlSigningAction_ARM{}

	// Set property "Name":
	if action.Name != nil {
		result.Name = *action.Name
	}

	// Set property "Parameters":
	if action.Parameters != nil {
		parameters_ARM, err := (*action.Parameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		parameters := *parameters_ARM.(*UrlSigningActionParameters_ARM)
		result.Parameters = &parameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *UrlSigningAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlSigningAction_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *UrlSigningAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlSigningAction_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlSigningAction_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlSigningActionParameters
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_UrlSigningAction populates our UrlSigningAction from the provided source UrlSigningAction
func (action *UrlSigningAction) AssignProperties_From_UrlSigningAction(source *v20230501s.UrlSigningAction) error {

	// Name
	if source.Name != nil {
		name := UrlSigningAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlSigningActionParameters
		err := parameter.AssignProperties_From_UrlSigningActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningAction populates the provided destination UrlSigningAction from our UrlSigningAction
func (action *UrlSigningAction) AssignProperties_To_UrlSigningAction(destination *v20230501s.UrlSigningAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.UrlSigningActionParameters
		err := action.Parameters.AssignProperties_To_UrlSigningActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlSigningAction_STATUS populates our UrlSigningAction from the provided source UrlSigningAction_STATUS
func (action *UrlSigningAction) Initialize_From_UrlSigningAction_STATUS(source *UrlSigningAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := UrlSigningAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlSigningActionParameters
		err := parameter.Initialize_From_UrlSigningActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_UrlSigningActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

type UrlSigningAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *UrlSigningAction_Name_STATUS `json:"name,omitempty"`

	// Parameters: Defines the parameters for the action.
	Parameters *UrlSigningActionParameters_STATUS `json:"parameters,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlSigningAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *UrlSigningAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlSigningAction_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *UrlSigningAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlSigningAction_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlSigningAction_STATUS_ARM, got %T", armInput)
	}

	// Set property "Name":
	action.Name = &typedInput.Name

	// Set property "Parameters":
	if typedInput.Parameters != nil {
		var parameters1 UrlSigningActionParameters_STATUS
		err := parameters1.PopulateFromARM(owner, *typedInput.Parameters)
		if err != nil {
			return err
		}
		parameters := parameters1
		action.Parameters = &parameters
	}

	// No error
	return nil
}

// AssignProperties_From_UrlSigningAction_STATUS populates our UrlSigningAction_STATUS from the provided source UrlSigningAction_STATUS
func (action *UrlSigningAction_STATUS) AssignProperties_From_UrlSigningAction_STATUS(source *v20230501s.UrlSigningAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := UrlSigningAction_Name_STATUS(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// Parameters
	if source.Parameters != nil {
		var parameter UrlSigningActionParameters_STATUS
		err := parameter.AssignProperties_From_UrlSigningActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningAction_STATUS populates the provided destination UrlSigningAction_STATUS from our UrlSigningAction_STATUS
func (action *UrlSigningAction_STATUS) AssignProperties_To_UrlSigningAction_STATUS(destination *v20230501s.UrlSigningAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Parameters
	if action.Parameters != nil {
		var parameter v20230501s.UrlSigningActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_UrlSigningActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for the cache expiration action.
type CacheExpirationActionParameters struct {
	// +kubebuilder:validation:Required
	// CacheBehavior: Caching behavior for the requests
	CacheBehavior *CacheExpirationActionParameters_CacheBehavior `json:"cacheBehavior,omitempty"`

	// CacheDuration: The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
	CacheDuration *string `json:"cacheDuration,omitempty"`

	// +kubebuilder:validation:Required
	// CacheType: The level at which the content needs to be cached.
	CacheType *CacheExpirationActionParameters_CacheType `json:"cacheType,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *CacheExpirationActionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &CacheExpirationActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *CacheExpirationActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &CacheExpirationActionParameters_ARM{}

	// Set property "CacheBehavior":
	if parameters.CacheBehavior != nil {
		cacheBehavior := *parameters.CacheBehavior
		result.CacheBehavior = &cacheBehavior
	}

	// Set property "CacheDuration":
	if parameters.CacheDuration != nil {
		cacheDuration := *parameters.CacheDuration
		result.CacheDuration = &cacheDuration
	}

	// Set property "CacheType":
	if parameters.CacheType != nil {
		cacheType := *parameters.CacheType
		result.CacheType = &cacheType
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *CacheExpirationActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CacheExpirationActionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *CacheExpirationActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CacheExpirationActionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CacheExpirationActionParameters_ARM, got %T", armInput)
	}

	// Set property "CacheBehavior":
	if typedInput.CacheBehavior != nil {
		cacheBehavior := *typedInput.CacheBehavior
		parameters.CacheBehavior = &cacheBehavior
	}

	// Set property "CacheDuration":
	if typedInput.CacheDuration != nil {
		cacheDuration := *typedInput.CacheDuration
		parameters.CacheDuration = &cacheDuration
	}

	// Set property "CacheType":
	if typedInput.CacheType != nil {
		cacheType := *typedInput.CacheType
		parameters.CacheType = &cacheType
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_CacheExpirationActionParameters populates our CacheExpirationActionParameters from the provided source CacheExpirationActionParameters
func (parameters *CacheExpirationActionParameters) AssignProperties_From_CacheExpirationActionParameters(source *v20230501s.CacheExpirationActionParameters) error {

	// CacheBehavior
	if source.CacheBehavior != nil {
		cacheBehavior := CacheExpirationActionParameters_CacheBehavior(*source.CacheBehavior)
		parameters.CacheBehavior = &cacheBehavior
	} else {
		parameters.CacheBehavior = nil
	}

	// CacheDuration
	parameters.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// CacheType
	if source.CacheType != nil {
		cacheType := CacheExpirationActionParameters_CacheType(*source.CacheType)
		parameters.CacheType = &cacheType
	} else {
		parameters.CacheType = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := CacheExpirationActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CacheExpirationActionParameters populates the provided destination CacheExpirationActionParameters from our CacheExpirationActionParameters
func (parameters *CacheExpirationActionParameters) AssignProperties_To_CacheExpirationActionParameters(destination *v20230501s.CacheExpirationActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheBehavior
	if parameters.CacheBehavior != nil {
		cacheBehavior := string(*parameters.CacheBehavior)
		destination.CacheBehavior = &cacheBehavior
	} else {
		destination.CacheBehavior = nil
	}

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(parameters.CacheDuration)

	// CacheType
	if parameters.CacheType != nil {
		cacheType := string(*parameters.CacheType)
		destination.CacheType = &cacheType
	} else {
		destination.CacheType = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CacheExpirationActionParameters_STATUS populates our CacheExpirationActionParameters from the provided source CacheExpirationActionParameters_STATUS
func (parameters *CacheExpirationActionParameters) Initialize_From_CacheExpirationActionParameters_STATUS(source *CacheExpirationActionParameters_STATUS) error {

	// CacheBehavior
	if source.CacheBehavior != nil {
		cacheBehavior := CacheExpirationActionParameters_CacheBehavior(*source.CacheBehavior)
		parameters.CacheBehavior = &cacheBehavior
	} else {
		parameters.CacheBehavior = nil
	}

	// CacheDuration
	parameters.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// CacheType
	if source.CacheType != nil {
		cacheType := CacheExpirationActionParameters_CacheType(*source.CacheType)
		parameters.CacheType = &cacheType
	} else {
		parameters.CacheType = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := CacheExpirationActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for the cache expiration action.
type CacheExpirationActionParameters_STATUS struct {
	// CacheBehavior: Caching behavior for the requests
	CacheBehavior *CacheExpirationActionParameters_CacheBehavior_STATUS `json:"cacheBehavior,omitempty"`

	// CacheDuration: The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
	CacheDuration *string `json:"cacheDuration,omitempty"`

	// CacheType: The level at which the content needs to be cached.
	CacheType *CacheExpirationActionParameters_CacheType_STATUS `json:"cacheType,omitempty"`
	TypeName  *CacheExpirationActionParameters_TypeName_STATUS  `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &CacheExpirationActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *CacheExpirationActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CacheExpirationActionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *CacheExpirationActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CacheExpirationActionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CacheExpirationActionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "CacheBehavior":
	if typedInput.CacheBehavior != nil {
		cacheBehavior := *typedInput.CacheBehavior
		parameters.CacheBehavior = &cacheBehavior
	}

	// Set property "CacheDuration":
	if typedInput.CacheDuration != nil {
		cacheDuration := *typedInput.CacheDuration
		parameters.CacheDuration = &cacheDuration
	}

	// Set property "CacheType":
	if typedInput.CacheType != nil {
		cacheType := *typedInput.CacheType
		parameters.CacheType = &cacheType
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_CacheExpirationActionParameters_STATUS populates our CacheExpirationActionParameters_STATUS from the provided source CacheExpirationActionParameters_STATUS
func (parameters *CacheExpirationActionParameters_STATUS) AssignProperties_From_CacheExpirationActionParameters_STATUS(source *v20230501s.CacheExpirationActionParameters_STATUS) error {

	// CacheBehavior
	if source.CacheBehavior != nil {
		cacheBehavior := CacheExpirationActionParameters_CacheBehavior_STATUS(*source.CacheBehavior)
		parameters.CacheBehavior = &cacheBehavior
	} else {
		parameters.CacheBehavior = nil
	}

	// CacheDuration
	parameters.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// CacheType
	if source.CacheType != nil {
		cacheType := CacheExpirationActionParameters_CacheType_STATUS(*source.CacheType)
		parameters.CacheType = &cacheType
	} else {
		parameters.CacheType = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := CacheExpirationActionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CacheExpirationActionParameters_STATUS populates the provided destination CacheExpirationActionParameters_STATUS from our CacheExpirationActionParameters_STATUS
func (parameters *CacheExpirationActionParameters_STATUS) AssignProperties_To_CacheExpirationActionParameters_STATUS(destination *v20230501s.CacheExpirationActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheBehavior
	if parameters.CacheBehavior != nil {
		cacheBehavior := string(*parameters.CacheBehavior)
		destination.CacheBehavior = &cacheBehavior
	} else {
		destination.CacheBehavior = nil
	}

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(parameters.CacheDuration)

	// CacheType
	if parameters.CacheType != nil {
		cacheType := string(*parameters.CacheType)
		destination.CacheType = &cacheType
	} else {
		destination.CacheType = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for the cache-key query string action.
type CacheKeyQueryStringActionParameters struct {
	// QueryParameters: query parameters to include or exclude (comma separated).
	QueryParameters *string `json:"queryParameters,omitempty"`

	// +kubebuilder:validation:Required
	// QueryStringBehavior: Caching behavior for the requests
	QueryStringBehavior *CacheKeyQueryStringActionParameters_QueryStringBehavior `json:"queryStringBehavior,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *CacheKeyQueryStringActionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &CacheKeyQueryStringActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *CacheKeyQueryStringActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &CacheKeyQueryStringActionParameters_ARM{}

	// Set property "QueryParameters":
	if parameters.QueryParameters != nil {
		queryParameters := *parameters.QueryParameters
		result.QueryParameters = &queryParameters
	}

	// Set property "QueryStringBehavior":
	if parameters.QueryStringBehavior != nil {
		queryStringBehavior := *parameters.QueryStringBehavior
		result.QueryStringBehavior = &queryStringBehavior
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *CacheKeyQueryStringActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CacheKeyQueryStringActionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *CacheKeyQueryStringActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CacheKeyQueryStringActionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CacheKeyQueryStringActionParameters_ARM, got %T", armInput)
	}

	// Set property "QueryParameters":
	if typedInput.QueryParameters != nil {
		queryParameters := *typedInput.QueryParameters
		parameters.QueryParameters = &queryParameters
	}

	// Set property "QueryStringBehavior":
	if typedInput.QueryStringBehavior != nil {
		queryStringBehavior := *typedInput.QueryStringBehavior
		parameters.QueryStringBehavior = &queryStringBehavior
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_CacheKeyQueryStringActionParameters populates our CacheKeyQueryStringActionParameters from the provided source CacheKeyQueryStringActionParameters
func (parameters *CacheKeyQueryStringActionParameters) AssignProperties_From_CacheKeyQueryStringActionParameters(source *v20230501s.CacheKeyQueryStringActionParameters) error {

	// QueryParameters
	parameters.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringBehavior
	if source.QueryStringBehavior != nil {
		queryStringBehavior := CacheKeyQueryStringActionParameters_QueryStringBehavior(*source.QueryStringBehavior)
		parameters.QueryStringBehavior = &queryStringBehavior
	} else {
		parameters.QueryStringBehavior = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := CacheKeyQueryStringActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CacheKeyQueryStringActionParameters populates the provided destination CacheKeyQueryStringActionParameters from our CacheKeyQueryStringActionParameters
func (parameters *CacheKeyQueryStringActionParameters) AssignProperties_To_CacheKeyQueryStringActionParameters(destination *v20230501s.CacheKeyQueryStringActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(parameters.QueryParameters)

	// QueryStringBehavior
	if parameters.QueryStringBehavior != nil {
		queryStringBehavior := string(*parameters.QueryStringBehavior)
		destination.QueryStringBehavior = &queryStringBehavior
	} else {
		destination.QueryStringBehavior = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CacheKeyQueryStringActionParameters_STATUS populates our CacheKeyQueryStringActionParameters from the provided source CacheKeyQueryStringActionParameters_STATUS
func (parameters *CacheKeyQueryStringActionParameters) Initialize_From_CacheKeyQueryStringActionParameters_STATUS(source *CacheKeyQueryStringActionParameters_STATUS) error {

	// QueryParameters
	parameters.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringBehavior
	if source.QueryStringBehavior != nil {
		queryStringBehavior := CacheKeyQueryStringActionParameters_QueryStringBehavior(*source.QueryStringBehavior)
		parameters.QueryStringBehavior = &queryStringBehavior
	} else {
		parameters.QueryStringBehavior = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := CacheKeyQueryStringActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for the cache-key query string action.
type CacheKeyQueryStringActionParameters_STATUS struct {
	// QueryParameters: query parameters to include or exclude (comma separated).
	QueryParameters *string `json:"queryParameters,omitempty"`

	// QueryStringBehavior: Caching behavior for the requests
	QueryStringBehavior *CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS `json:"queryStringBehavior,omitempty"`
	TypeName            *CacheKeyQueryStringActionParameters_TypeName_STATUS            `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &CacheKeyQueryStringActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *CacheKeyQueryStringActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CacheKeyQueryStringActionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *CacheKeyQueryStringActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CacheKeyQueryStringActionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CacheKeyQueryStringActionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "QueryParameters":
	if typedInput.QueryParameters != nil {
		queryParameters := *typedInput.QueryParameters
		parameters.QueryParameters = &queryParameters
	}

	// Set property "QueryStringBehavior":
	if typedInput.QueryStringBehavior != nil {
		queryStringBehavior := *typedInput.QueryStringBehavior
		parameters.QueryStringBehavior = &queryStringBehavior
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS populates our CacheKeyQueryStringActionParameters_STATUS from the provided source CacheKeyQueryStringActionParameters_STATUS
func (parameters *CacheKeyQueryStringActionParameters_STATUS) AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS(source *v20230501s.CacheKeyQueryStringActionParameters_STATUS) error {

	// QueryParameters
	parameters.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringBehavior
	if source.QueryStringBehavior != nil {
		queryStringBehavior := CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS(*source.QueryStringBehavior)
		parameters.QueryStringBehavior = &queryStringBehavior
	} else {
		parameters.QueryStringBehavior = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := CacheKeyQueryStringActionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS populates the provided destination CacheKeyQueryStringActionParameters_STATUS from our CacheKeyQueryStringActionParameters_STATUS
func (parameters *CacheKeyQueryStringActionParameters_STATUS) AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS(destination *v20230501s.CacheKeyQueryStringActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(parameters.QueryParameters)

	// QueryStringBehavior
	if parameters.QueryStringBehavior != nil {
		queryStringBehavior := string(*parameters.QueryStringBehavior)
		destination.QueryStringBehavior = &queryStringBehavior
	} else {
		destination.QueryStringBehavior = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for ClientPort match conditions
type ClientPortMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *ClientPortMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *ClientPortMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &ClientPortMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *ClientPortMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &ClientPortMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ClientPortMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ClientPortMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ClientPortMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ClientPortMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ClientPortMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_ClientPortMatchConditionParameters populates our ClientPortMatchConditionParameters from the provided source ClientPortMatchConditionParameters
func (parameters *ClientPortMatchConditionParameters) AssignProperties_From_ClientPortMatchConditionParameters(source *v20230501s.ClientPortMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := ClientPortMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := ClientPortMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ClientPortMatchConditionParameters populates the provided destination ClientPortMatchConditionParameters from our ClientPortMatchConditionParameters
func (parameters *ClientPortMatchConditionParameters) AssignProperties_To_ClientPortMatchConditionParameters(destination *v20230501s.ClientPortMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ClientPortMatchConditionParameters_STATUS populates our ClientPortMatchConditionParameters from the provided source ClientPortMatchConditionParameters_STATUS
func (parameters *ClientPortMatchConditionParameters) Initialize_From_ClientPortMatchConditionParameters_STATUS(source *ClientPortMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := ClientPortMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := ClientPortMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for ClientPort match conditions
type ClientPortMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *ClientPortMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                  `json:"transforms,omitempty"`
	TypeName   *ClientPortMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &ClientPortMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ClientPortMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ClientPortMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ClientPortMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ClientPortMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ClientPortMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_ClientPortMatchConditionParameters_STATUS populates our ClientPortMatchConditionParameters_STATUS from the provided source ClientPortMatchConditionParameters_STATUS
func (parameters *ClientPortMatchConditionParameters_STATUS) AssignProperties_From_ClientPortMatchConditionParameters_STATUS(source *v20230501s.ClientPortMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := ClientPortMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := ClientPortMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ClientPortMatchConditionParameters_STATUS populates the provided destination ClientPortMatchConditionParameters_STATUS from our ClientPortMatchConditionParameters_STATUS
func (parameters *ClientPortMatchConditionParameters_STATUS) AssignProperties_To_ClientPortMatchConditionParameters_STATUS(destination *v20230501s.ClientPortMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for Cookies match conditions
type CookiesMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *CookiesMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Selector: Name of Cookies to be matched
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *CookiesMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &CookiesMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *CookiesMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &CookiesMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Selector":
	if parameters.Selector != nil {
		selector := *parameters.Selector
		result.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *CookiesMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CookiesMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *CookiesMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CookiesMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CookiesMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		parameters.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_CookiesMatchConditionParameters populates our CookiesMatchConditionParameters from the provided source CookiesMatchConditionParameters
func (parameters *CookiesMatchConditionParameters) AssignProperties_From_CookiesMatchConditionParameters(source *v20230501s.CookiesMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := CookiesMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := CookiesMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CookiesMatchConditionParameters populates the provided destination CookiesMatchConditionParameters from our CookiesMatchConditionParameters
func (parameters *CookiesMatchConditionParameters) AssignProperties_To_CookiesMatchConditionParameters(destination *v20230501s.CookiesMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CookiesMatchConditionParameters_STATUS populates our CookiesMatchConditionParameters from the provided source CookiesMatchConditionParameters_STATUS
func (parameters *CookiesMatchConditionParameters) Initialize_From_CookiesMatchConditionParameters_STATUS(source *CookiesMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := CookiesMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := CookiesMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for Cookies match conditions
type CookiesMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *CookiesMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Selector: Name of Cookies to be matched
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                               `json:"transforms,omitempty"`
	TypeName   *CookiesMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &CookiesMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *CookiesMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CookiesMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *CookiesMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CookiesMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CookiesMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		parameters.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_CookiesMatchConditionParameters_STATUS populates our CookiesMatchConditionParameters_STATUS from the provided source CookiesMatchConditionParameters_STATUS
func (parameters *CookiesMatchConditionParameters_STATUS) AssignProperties_From_CookiesMatchConditionParameters_STATUS(source *v20230501s.CookiesMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := CookiesMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := CookiesMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CookiesMatchConditionParameters_STATUS populates the provided destination CookiesMatchConditionParameters_STATUS from our CookiesMatchConditionParameters_STATUS
func (parameters *CookiesMatchConditionParameters_STATUS) AssignProperties_To_CookiesMatchConditionParameters_STATUS(destination *v20230501s.CookiesMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for the request header action.
type HeaderActionParameters struct {
	// +kubebuilder:validation:Required
	// HeaderAction: Action to perform
	HeaderAction *HeaderActionParameters_HeaderAction `json:"headerAction,omitempty"`

	// +kubebuilder:validation:Required
	// HeaderName: Name of the header to modify
	HeaderName *string `json:"headerName,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *HeaderActionParameters_TypeName `json:"typeName,omitempty"`

	// Value: Value for the specified action
	Value *string `json:"value,omitempty"`
}

var _ genruntime.ARMTransformer = &HeaderActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *HeaderActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &HeaderActionParameters_ARM{}

	// Set property "HeaderAction":
	if parameters.HeaderAction != nil {
		headerAction := *parameters.HeaderAction
		result.HeaderAction = &headerAction
	}

	// Set property "HeaderName":
	if parameters.HeaderName != nil {
		headerName := *parameters.HeaderName
		result.HeaderName = &headerName
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}

	// Set property "Value":
	if parameters.Value != nil {
		value := *parameters.Value
		result.Value = &value
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HeaderActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HeaderActionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HeaderActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HeaderActionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HeaderActionParameters_ARM, got %T", armInput)
	}

	// Set property "HeaderAction":
	if typedInput.HeaderAction != nil {
		headerAction := *typedInput.HeaderAction
		parameters.HeaderAction = &headerAction
	}

	// Set property "HeaderName":
	if typedInput.HeaderName != nil {
		headerName := *typedInput.HeaderName
		parameters.HeaderName = &headerName
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		parameters.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_HeaderActionParameters populates our HeaderActionParameters from the provided source HeaderActionParameters
func (parameters *HeaderActionParameters) AssignProperties_From_HeaderActionParameters(source *v20230501s.HeaderActionParameters) error {

	// HeaderAction
	if source.HeaderAction != nil {
		headerAction := HeaderActionParameters_HeaderAction(*source.HeaderAction)
		parameters.HeaderAction = &headerAction
	} else {
		parameters.HeaderAction = nil
	}

	// HeaderName
	parameters.HeaderName = genruntime.ClonePointerToString(source.HeaderName)

	// TypeName
	if source.TypeName != nil {
		typeName := HeaderActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// Value
	parameters.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_HeaderActionParameters populates the provided destination HeaderActionParameters from our HeaderActionParameters
func (parameters *HeaderActionParameters) AssignProperties_To_HeaderActionParameters(destination *v20230501s.HeaderActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HeaderAction
	if parameters.HeaderAction != nil {
		headerAction := string(*parameters.HeaderAction)
		destination.HeaderAction = &headerAction
	} else {
		destination.HeaderAction = nil
	}

	// HeaderName
	destination.HeaderName = genruntime.ClonePointerToString(parameters.HeaderName)

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(parameters.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HeaderActionParameters_STATUS populates our HeaderActionParameters from the provided source HeaderActionParameters_STATUS
func (parameters *HeaderActionParameters) Initialize_From_HeaderActionParameters_STATUS(source *HeaderActionParameters_STATUS) error {

	// HeaderAction
	if source.HeaderAction != nil {
		headerAction := HeaderActionParameters_HeaderAction(*source.HeaderAction)
		parameters.HeaderAction = &headerAction
	} else {
		parameters.HeaderAction = nil
	}

	// HeaderName
	parameters.HeaderName = genruntime.ClonePointerToString(source.HeaderName)

	// TypeName
	if source.TypeName != nil {
		typeName := HeaderActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// Value
	parameters.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// Defines the parameters for the request header action.
type HeaderActionParameters_STATUS struct {
	// HeaderAction: Action to perform
	HeaderAction *HeaderActionParameters_HeaderAction_STATUS `json:"headerAction,omitempty"`

	// HeaderName: Name of the header to modify
	HeaderName *string                                 `json:"headerName,omitempty"`
	TypeName   *HeaderActionParameters_TypeName_STATUS `json:"typeName,omitempty"`

	// Value: Value for the specified action
	Value *string `json:"value,omitempty"`
}

var _ genruntime.FromARMConverter = &HeaderActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HeaderActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HeaderActionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HeaderActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HeaderActionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HeaderActionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "HeaderAction":
	if typedInput.HeaderAction != nil {
		headerAction := *typedInput.HeaderAction
		parameters.HeaderAction = &headerAction
	}

	// Set property "HeaderName":
	if typedInput.HeaderName != nil {
		headerName := *typedInput.HeaderName
		parameters.HeaderName = &headerName
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// Set property "Value":
	if typedInput.Value != nil {
		value := *typedInput.Value
		parameters.Value = &value
	}

	// No error
	return nil
}

// AssignProperties_From_HeaderActionParameters_STATUS populates our HeaderActionParameters_STATUS from the provided source HeaderActionParameters_STATUS
func (parameters *HeaderActionParameters_STATUS) AssignProperties_From_HeaderActionParameters_STATUS(source *v20230501s.HeaderActionParameters_STATUS) error {

	// HeaderAction
	if source.HeaderAction != nil {
		headerAction := HeaderActionParameters_HeaderAction_STATUS(*source.HeaderAction)
		parameters.HeaderAction = &headerAction
	} else {
		parameters.HeaderAction = nil
	}

	// HeaderName
	parameters.HeaderName = genruntime.ClonePointerToString(source.HeaderName)

	// TypeName
	if source.TypeName != nil {
		typeName := HeaderActionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// Value
	parameters.Value = genruntime.ClonePointerToString(source.Value)

	// No error
	return nil
}

// AssignProperties_To_HeaderActionParameters_STATUS populates the provided destination HeaderActionParameters_STATUS from our HeaderActionParameters_STATUS
func (parameters *HeaderActionParameters_STATUS) AssignProperties_To_HeaderActionParameters_STATUS(destination *v20230501s.HeaderActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HeaderAction
	if parameters.HeaderAction != nil {
		headerAction := string(*parameters.HeaderAction)
		destination.HeaderAction = &headerAction
	} else {
		destination.HeaderAction = nil
	}

	// HeaderName
	destination.HeaderName = genruntime.ClonePointerToString(parameters.HeaderName)

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Value
	destination.Value = genruntime.ClonePointerToString(parameters.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for HostName match conditions
type HostNameMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *HostNameMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *HostNameMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &HostNameMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *HostNameMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &HostNameMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HostNameMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HostNameMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HostNameMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HostNameMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HostNameMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_HostNameMatchConditionParameters populates our HostNameMatchConditionParameters from the provided source HostNameMatchConditionParameters
func (parameters *HostNameMatchConditionParameters) AssignProperties_From_HostNameMatchConditionParameters(source *v20230501s.HostNameMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := HostNameMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := HostNameMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HostNameMatchConditionParameters populates the provided destination HostNameMatchConditionParameters from our HostNameMatchConditionParameters
func (parameters *HostNameMatchConditionParameters) AssignProperties_To_HostNameMatchConditionParameters(destination *v20230501s.HostNameMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HostNameMatchConditionParameters_STATUS populates our HostNameMatchConditionParameters from the provided source HostNameMatchConditionParameters_STATUS
func (parameters *HostNameMatchConditionParameters) Initialize_From_HostNameMatchConditionParameters_STATUS(source *HostNameMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := HostNameMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := HostNameMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for HostName match conditions
type HostNameMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *HostNameMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                `json:"transforms,omitempty"`
	TypeName   *HostNameMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &HostNameMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HostNameMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HostNameMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HostNameMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HostNameMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HostNameMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_HostNameMatchConditionParameters_STATUS populates our HostNameMatchConditionParameters_STATUS from the provided source HostNameMatchConditionParameters_STATUS
func (parameters *HostNameMatchConditionParameters_STATUS) AssignProperties_From_HostNameMatchConditionParameters_STATUS(source *v20230501s.HostNameMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := HostNameMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := HostNameMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HostNameMatchConditionParameters_STATUS populates the provided destination HostNameMatchConditionParameters_STATUS from our HostNameMatchConditionParameters_STATUS
func (parameters *HostNameMatchConditionParameters_STATUS) AssignProperties_To_HostNameMatchConditionParameters_STATUS(destination *v20230501s.HostNameMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for HttpVersion match conditions
type HttpVersionMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *HttpVersionMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *HttpVersionMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &HttpVersionMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *HttpVersionMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &HttpVersionMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HttpVersionMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HttpVersionMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HttpVersionMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HttpVersionMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HttpVersionMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_HttpVersionMatchConditionParameters populates our HttpVersionMatchConditionParameters from the provided source HttpVersionMatchConditionParameters
func (parameters *HttpVersionMatchConditionParameters) AssignProperties_From_HttpVersionMatchConditionParameters(source *v20230501s.HttpVersionMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := HttpVersionMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := HttpVersionMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HttpVersionMatchConditionParameters populates the provided destination HttpVersionMatchConditionParameters from our HttpVersionMatchConditionParameters
func (parameters *HttpVersionMatchConditionParameters) AssignProperties_To_HttpVersionMatchConditionParameters(destination *v20230501s.HttpVersionMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_HttpVersionMatchConditionParameters_STATUS populates our HttpVersionMatchConditionParameters from the provided source HttpVersionMatchConditionParameters_STATUS
func (parameters *HttpVersionMatchConditionParameters) Initialize_From_HttpVersionMatchConditionParameters_STATUS(source *HttpVersionMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := HttpVersionMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := HttpVersionMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for HttpVersion match conditions
type HttpVersionMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *HttpVersionMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                   `json:"transforms,omitempty"`
	TypeName   *HttpVersionMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &HttpVersionMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HttpVersionMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HttpVersionMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HttpVersionMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HttpVersionMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HttpVersionMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_HttpVersionMatchConditionParameters_STATUS populates our HttpVersionMatchConditionParameters_STATUS from the provided source HttpVersionMatchConditionParameters_STATUS
func (parameters *HttpVersionMatchConditionParameters_STATUS) AssignProperties_From_HttpVersionMatchConditionParameters_STATUS(source *v20230501s.HttpVersionMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := HttpVersionMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := HttpVersionMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_HttpVersionMatchConditionParameters_STATUS populates the provided destination HttpVersionMatchConditionParameters_STATUS from our HttpVersionMatchConditionParameters_STATUS
func (parameters *HttpVersionMatchConditionParameters_STATUS) AssignProperties_To_HttpVersionMatchConditionParameters_STATUS(destination *v20230501s.HttpVersionMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for IsDevice match conditions
type IsDeviceMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []IsDeviceMatchConditionParameters_MatchValues `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *IsDeviceMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *IsDeviceMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &IsDeviceMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *IsDeviceMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &IsDeviceMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *IsDeviceMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IsDeviceMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *IsDeviceMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IsDeviceMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IsDeviceMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_IsDeviceMatchConditionParameters populates our IsDeviceMatchConditionParameters from the provided source IsDeviceMatchConditionParameters
func (parameters *IsDeviceMatchConditionParameters) AssignProperties_From_IsDeviceMatchConditionParameters(source *v20230501s.IsDeviceMatchConditionParameters) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]IsDeviceMatchConditionParameters_MatchValues, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = IsDeviceMatchConditionParameters_MatchValues(matchValueItem)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := IsDeviceMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := IsDeviceMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IsDeviceMatchConditionParameters populates the provided destination IsDeviceMatchConditionParameters from our IsDeviceMatchConditionParameters
func (parameters *IsDeviceMatchConditionParameters) AssignProperties_To_IsDeviceMatchConditionParameters(destination *v20230501s.IsDeviceMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_IsDeviceMatchConditionParameters_STATUS populates our IsDeviceMatchConditionParameters from the provided source IsDeviceMatchConditionParameters_STATUS
func (parameters *IsDeviceMatchConditionParameters) Initialize_From_IsDeviceMatchConditionParameters_STATUS(source *IsDeviceMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]IsDeviceMatchConditionParameters_MatchValues, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValue := IsDeviceMatchConditionParameters_MatchValues(matchValueItem)
			matchValueList[matchValueIndex] = matchValue
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := IsDeviceMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := IsDeviceMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for IsDevice match conditions
type IsDeviceMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []IsDeviceMatchConditionParameters_MatchValues_STATUS `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *IsDeviceMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                `json:"transforms,omitempty"`
	TypeName   *IsDeviceMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &IsDeviceMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *IsDeviceMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &IsDeviceMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *IsDeviceMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(IsDeviceMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected IsDeviceMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_IsDeviceMatchConditionParameters_STATUS populates our IsDeviceMatchConditionParameters_STATUS from the provided source IsDeviceMatchConditionParameters_STATUS
func (parameters *IsDeviceMatchConditionParameters_STATUS) AssignProperties_From_IsDeviceMatchConditionParameters_STATUS(source *v20230501s.IsDeviceMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]IsDeviceMatchConditionParameters_MatchValues_STATUS, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = IsDeviceMatchConditionParameters_MatchValues_STATUS(matchValueItem)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := IsDeviceMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := IsDeviceMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_IsDeviceMatchConditionParameters_STATUS populates the provided destination IsDeviceMatchConditionParameters_STATUS from our IsDeviceMatchConditionParameters_STATUS
func (parameters *IsDeviceMatchConditionParameters_STATUS) AssignProperties_To_IsDeviceMatchConditionParameters_STATUS(destination *v20230501s.IsDeviceMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for the origin group override action.
type OriginGroupOverrideActionParameters struct {
	// +kubebuilder:validation:Required
	// OriginGroup: defines the OriginGroup that would override the DefaultOriginGroup.
	OriginGroup *ResourceReference `json:"originGroup,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *OriginGroupOverrideActionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &OriginGroupOverrideActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *OriginGroupOverrideActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &OriginGroupOverrideActionParameters_ARM{}

	// Set property "OriginGroup":
	if parameters.OriginGroup != nil {
		originGroup_ARM, err := (*parameters.OriginGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		originGroup := *originGroup_ARM.(*ResourceReference_ARM)
		result.OriginGroup = &originGroup
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *OriginGroupOverrideActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OriginGroupOverrideActionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *OriginGroupOverrideActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OriginGroupOverrideActionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OriginGroupOverrideActionParameters_ARM, got %T", armInput)
	}

	// Set property "OriginGroup":
	if typedInput.OriginGroup != nil {
		var originGroup1 ResourceReference
		err := originGroup1.PopulateFromARM(owner, *typedInput.OriginGroup)
		if err != nil {
			return err
		}
		originGroup := originGroup1
		parameters.OriginGroup = &originGroup
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_OriginGroupOverrideActionParameters populates our OriginGroupOverrideActionParameters from the provided source OriginGroupOverrideActionParameters
func (parameters *OriginGroupOverrideActionParameters) AssignProperties_From_OriginGroupOverrideActionParameters(source *v20230501s.OriginGroupOverrideActionParameters) error {

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference
		err := originGroup.AssignProperties_From_ResourceReference(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field OriginGroup")
		}
		parameters.OriginGroup = &originGroup
	} else {
		parameters.OriginGroup = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := OriginGroupOverrideActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideActionParameters populates the provided destination OriginGroupOverrideActionParameters from our OriginGroupOverrideActionParameters
func (parameters *OriginGroupOverrideActionParameters) AssignProperties_To_OriginGroupOverrideActionParameters(destination *v20230501s.OriginGroupOverrideActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// OriginGroup
	if parameters.OriginGroup != nil {
		var originGroup v20230501s.ResourceReference
		err := parameters.OriginGroup.AssignProperties_To_ResourceReference(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OriginGroupOverrideActionParameters_STATUS populates our OriginGroupOverrideActionParameters from the provided source OriginGroupOverrideActionParameters_STATUS
func (parameters *OriginGroupOverrideActionParameters) Initialize_From_OriginGroupOverrideActionParameters_STATUS(source *OriginGroupOverrideActionParameters_STATUS) error {

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference
		err := originGroup.Initialize_From_ResourceReference_STATUS(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ResourceReference_STATUS() to populate field OriginGroup")
		}
		parameters.OriginGroup = &originGroup
	} else {
		parameters.OriginGroup = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := OriginGroupOverrideActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for the origin group override action.
type OriginGroupOverrideActionParameters_STATUS struct {
	// OriginGroup: defines the OriginGroup that would override the DefaultOriginGroup.
	OriginGroup *ResourceReference_STATUS                            `json:"originGroup,omitempty"`
	TypeName    *OriginGroupOverrideActionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &OriginGroupOverrideActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *OriginGroupOverrideActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OriginGroupOverrideActionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *OriginGroupOverrideActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OriginGroupOverrideActionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OriginGroupOverrideActionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "OriginGroup":
	if typedInput.OriginGroup != nil {
		var originGroup1 ResourceReference_STATUS
		err := originGroup1.PopulateFromARM(owner, *typedInput.OriginGroup)
		if err != nil {
			return err
		}
		originGroup := originGroup1
		parameters.OriginGroup = &originGroup
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_OriginGroupOverrideActionParameters_STATUS populates our OriginGroupOverrideActionParameters_STATUS from the provided source OriginGroupOverrideActionParameters_STATUS
func (parameters *OriginGroupOverrideActionParameters_STATUS) AssignProperties_From_OriginGroupOverrideActionParameters_STATUS(source *v20230501s.OriginGroupOverrideActionParameters_STATUS) error {

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference_STATUS
		err := originGroup.AssignProperties_From_ResourceReference_STATUS(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field OriginGroup")
		}
		parameters.OriginGroup = &originGroup
	} else {
		parameters.OriginGroup = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := OriginGroupOverrideActionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideActionParameters_STATUS populates the provided destination OriginGroupOverrideActionParameters_STATUS from our OriginGroupOverrideActionParameters_STATUS
func (parameters *OriginGroupOverrideActionParameters_STATUS) AssignProperties_To_OriginGroupOverrideActionParameters_STATUS(destination *v20230501s.OriginGroupOverrideActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// OriginGroup
	if parameters.OriginGroup != nil {
		var originGroup v20230501s.ResourceReference_STATUS
		err := parameters.OriginGroup.AssignProperties_To_ResourceReference_STATUS(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for PostArgs match conditions
type PostArgsMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *PostArgsMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Selector: Name of PostArg to be matched
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *PostArgsMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &PostArgsMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *PostArgsMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &PostArgsMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Selector":
	if parameters.Selector != nil {
		selector := *parameters.Selector
		result.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *PostArgsMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PostArgsMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *PostArgsMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PostArgsMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PostArgsMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		parameters.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_PostArgsMatchConditionParameters populates our PostArgsMatchConditionParameters from the provided source PostArgsMatchConditionParameters
func (parameters *PostArgsMatchConditionParameters) AssignProperties_From_PostArgsMatchConditionParameters(source *v20230501s.PostArgsMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := PostArgsMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := PostArgsMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PostArgsMatchConditionParameters populates the provided destination PostArgsMatchConditionParameters from our PostArgsMatchConditionParameters
func (parameters *PostArgsMatchConditionParameters) AssignProperties_To_PostArgsMatchConditionParameters(destination *v20230501s.PostArgsMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_PostArgsMatchConditionParameters_STATUS populates our PostArgsMatchConditionParameters from the provided source PostArgsMatchConditionParameters_STATUS
func (parameters *PostArgsMatchConditionParameters) Initialize_From_PostArgsMatchConditionParameters_STATUS(source *PostArgsMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := PostArgsMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := PostArgsMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for PostArgs match conditions
type PostArgsMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *PostArgsMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Selector: Name of PostArg to be matched
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                `json:"transforms,omitempty"`
	TypeName   *PostArgsMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &PostArgsMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *PostArgsMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PostArgsMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *PostArgsMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PostArgsMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PostArgsMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		parameters.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_PostArgsMatchConditionParameters_STATUS populates our PostArgsMatchConditionParameters_STATUS from the provided source PostArgsMatchConditionParameters_STATUS
func (parameters *PostArgsMatchConditionParameters_STATUS) AssignProperties_From_PostArgsMatchConditionParameters_STATUS(source *v20230501s.PostArgsMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := PostArgsMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := PostArgsMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PostArgsMatchConditionParameters_STATUS populates the provided destination PostArgsMatchConditionParameters_STATUS from our PostArgsMatchConditionParameters_STATUS
func (parameters *PostArgsMatchConditionParameters_STATUS) AssignProperties_To_PostArgsMatchConditionParameters_STATUS(destination *v20230501s.PostArgsMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for QueryString match conditions
type QueryStringMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *QueryStringMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *QueryStringMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &QueryStringMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *QueryStringMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &QueryStringMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *QueryStringMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &QueryStringMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *QueryStringMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(QueryStringMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected QueryStringMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_QueryStringMatchConditionParameters populates our QueryStringMatchConditionParameters from the provided source QueryStringMatchConditionParameters
func (parameters *QueryStringMatchConditionParameters) AssignProperties_From_QueryStringMatchConditionParameters(source *v20230501s.QueryStringMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := QueryStringMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := QueryStringMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_QueryStringMatchConditionParameters populates the provided destination QueryStringMatchConditionParameters from our QueryStringMatchConditionParameters
func (parameters *QueryStringMatchConditionParameters) AssignProperties_To_QueryStringMatchConditionParameters(destination *v20230501s.QueryStringMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_QueryStringMatchConditionParameters_STATUS populates our QueryStringMatchConditionParameters from the provided source QueryStringMatchConditionParameters_STATUS
func (parameters *QueryStringMatchConditionParameters) Initialize_From_QueryStringMatchConditionParameters_STATUS(source *QueryStringMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := QueryStringMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := QueryStringMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for QueryString match conditions
type QueryStringMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *QueryStringMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                   `json:"transforms,omitempty"`
	TypeName   *QueryStringMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &QueryStringMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *QueryStringMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &QueryStringMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *QueryStringMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(QueryStringMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected QueryStringMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_QueryStringMatchConditionParameters_STATUS populates our QueryStringMatchConditionParameters_STATUS from the provided source QueryStringMatchConditionParameters_STATUS
func (parameters *QueryStringMatchConditionParameters_STATUS) AssignProperties_From_QueryStringMatchConditionParameters_STATUS(source *v20230501s.QueryStringMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := QueryStringMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := QueryStringMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_QueryStringMatchConditionParameters_STATUS populates the provided destination QueryStringMatchConditionParameters_STATUS from our QueryStringMatchConditionParameters_STATUS
func (parameters *QueryStringMatchConditionParameters_STATUS) AssignProperties_To_QueryStringMatchConditionParameters_STATUS(destination *v20230501s.QueryStringMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for RemoteAddress match conditions
type RemoteAddressMatchConditionParameters struct {
	// MatchValues: Match values to match against. The operator will apply to each value in here with OR semantics. If any of
	// them match the variable with the given operator this match condition is considered a match.
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *RemoteAddressMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *RemoteAddressMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &RemoteAddressMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RemoteAddressMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &RemoteAddressMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RemoteAddressMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RemoteAddressMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RemoteAddressMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RemoteAddressMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RemoteAddressMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RemoteAddressMatchConditionParameters populates our RemoteAddressMatchConditionParameters from the provided source RemoteAddressMatchConditionParameters
func (parameters *RemoteAddressMatchConditionParameters) AssignProperties_From_RemoteAddressMatchConditionParameters(source *v20230501s.RemoteAddressMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RemoteAddressMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RemoteAddressMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RemoteAddressMatchConditionParameters populates the provided destination RemoteAddressMatchConditionParameters from our RemoteAddressMatchConditionParameters
func (parameters *RemoteAddressMatchConditionParameters) AssignProperties_To_RemoteAddressMatchConditionParameters(destination *v20230501s.RemoteAddressMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RemoteAddressMatchConditionParameters_STATUS populates our RemoteAddressMatchConditionParameters from the provided source RemoteAddressMatchConditionParameters_STATUS
func (parameters *RemoteAddressMatchConditionParameters) Initialize_From_RemoteAddressMatchConditionParameters_STATUS(source *RemoteAddressMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RemoteAddressMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RemoteAddressMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for RemoteAddress match conditions
type RemoteAddressMatchConditionParameters_STATUS struct {
	// MatchValues: Match values to match against. The operator will apply to each value in here with OR semantics. If any of
	// them match the variable with the given operator this match condition is considered a match.
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *RemoteAddressMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                     `json:"transforms,omitempty"`
	TypeName   *RemoteAddressMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &RemoteAddressMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RemoteAddressMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RemoteAddressMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RemoteAddressMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RemoteAddressMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RemoteAddressMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS populates our RemoteAddressMatchConditionParameters_STATUS from the provided source RemoteAddressMatchConditionParameters_STATUS
func (parameters *RemoteAddressMatchConditionParameters_STATUS) AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS(source *v20230501s.RemoteAddressMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RemoteAddressMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RemoteAddressMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS populates the provided destination RemoteAddressMatchConditionParameters_STATUS from our RemoteAddressMatchConditionParameters_STATUS
func (parameters *RemoteAddressMatchConditionParameters_STATUS) AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS(destination *v20230501s.RemoteAddressMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestBody match conditions
type RequestBodyMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *RequestBodyMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *RequestBodyMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &RequestBodyMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RequestBodyMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &RequestBodyMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestBodyMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestBodyMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestBodyMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestBodyMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestBodyMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestBodyMatchConditionParameters populates our RequestBodyMatchConditionParameters from the provided source RequestBodyMatchConditionParameters
func (parameters *RequestBodyMatchConditionParameters) AssignProperties_From_RequestBodyMatchConditionParameters(source *v20230501s.RequestBodyMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestBodyMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestBodyMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestBodyMatchConditionParameters populates the provided destination RequestBodyMatchConditionParameters from our RequestBodyMatchConditionParameters
func (parameters *RequestBodyMatchConditionParameters) AssignProperties_To_RequestBodyMatchConditionParameters(destination *v20230501s.RequestBodyMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RequestBodyMatchConditionParameters_STATUS populates our RequestBodyMatchConditionParameters from the provided source RequestBodyMatchConditionParameters_STATUS
func (parameters *RequestBodyMatchConditionParameters) Initialize_From_RequestBodyMatchConditionParameters_STATUS(source *RequestBodyMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestBodyMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestBodyMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestBody match conditions
type RequestBodyMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *RequestBodyMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                   `json:"transforms,omitempty"`
	TypeName   *RequestBodyMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &RequestBodyMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestBodyMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestBodyMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestBodyMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestBodyMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestBodyMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestBodyMatchConditionParameters_STATUS populates our RequestBodyMatchConditionParameters_STATUS from the provided source RequestBodyMatchConditionParameters_STATUS
func (parameters *RequestBodyMatchConditionParameters_STATUS) AssignProperties_From_RequestBodyMatchConditionParameters_STATUS(source *v20230501s.RequestBodyMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestBodyMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestBodyMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestBodyMatchConditionParameters_STATUS populates the provided destination RequestBodyMatchConditionParameters_STATUS from our RequestBodyMatchConditionParameters_STATUS
func (parameters *RequestBodyMatchConditionParameters_STATUS) AssignProperties_To_RequestBodyMatchConditionParameters_STATUS(destination *v20230501s.RequestBodyMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestHeader match conditions
type RequestHeaderMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *RequestHeaderMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Selector: Name of Header to be matched
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *RequestHeaderMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &RequestHeaderMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RequestHeaderMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &RequestHeaderMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Selector":
	if parameters.Selector != nil {
		selector := *parameters.Selector
		result.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestHeaderMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestHeaderMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestHeaderMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestHeaderMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestHeaderMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		parameters.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestHeaderMatchConditionParameters populates our RequestHeaderMatchConditionParameters from the provided source RequestHeaderMatchConditionParameters
func (parameters *RequestHeaderMatchConditionParameters) AssignProperties_From_RequestHeaderMatchConditionParameters(source *v20230501s.RequestHeaderMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestHeaderMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestHeaderMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestHeaderMatchConditionParameters populates the provided destination RequestHeaderMatchConditionParameters from our RequestHeaderMatchConditionParameters
func (parameters *RequestHeaderMatchConditionParameters) AssignProperties_To_RequestHeaderMatchConditionParameters(destination *v20230501s.RequestHeaderMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RequestHeaderMatchConditionParameters_STATUS populates our RequestHeaderMatchConditionParameters from the provided source RequestHeaderMatchConditionParameters_STATUS
func (parameters *RequestHeaderMatchConditionParameters) Initialize_From_RequestHeaderMatchConditionParameters_STATUS(source *RequestHeaderMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestHeaderMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestHeaderMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestHeader match conditions
type RequestHeaderMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *RequestHeaderMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Selector: Name of Header to be matched
	Selector *string `json:"selector,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                     `json:"transforms,omitempty"`
	TypeName   *RequestHeaderMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &RequestHeaderMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestHeaderMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestHeaderMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestHeaderMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestHeaderMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestHeaderMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Selector":
	if typedInput.Selector != nil {
		selector := *typedInput.Selector
		parameters.Selector = &selector
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS populates our RequestHeaderMatchConditionParameters_STATUS from the provided source RequestHeaderMatchConditionParameters_STATUS
func (parameters *RequestHeaderMatchConditionParameters_STATUS) AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS(source *v20230501s.RequestHeaderMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestHeaderMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestHeaderMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS populates the provided destination RequestHeaderMatchConditionParameters_STATUS from our RequestHeaderMatchConditionParameters_STATUS
func (parameters *RequestHeaderMatchConditionParameters_STATUS) AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS(destination *v20230501s.RequestHeaderMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestMethod match conditions
type RequestMethodMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []RequestMethodMatchConditionParameters_MatchValues `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *RequestMethodMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *RequestMethodMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &RequestMethodMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RequestMethodMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &RequestMethodMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestMethodMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestMethodMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestMethodMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestMethodMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestMethodMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestMethodMatchConditionParameters populates our RequestMethodMatchConditionParameters from the provided source RequestMethodMatchConditionParameters
func (parameters *RequestMethodMatchConditionParameters) AssignProperties_From_RequestMethodMatchConditionParameters(source *v20230501s.RequestMethodMatchConditionParameters) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]RequestMethodMatchConditionParameters_MatchValues, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = RequestMethodMatchConditionParameters_MatchValues(matchValueItem)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestMethodMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestMethodMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestMethodMatchConditionParameters populates the provided destination RequestMethodMatchConditionParameters from our RequestMethodMatchConditionParameters
func (parameters *RequestMethodMatchConditionParameters) AssignProperties_To_RequestMethodMatchConditionParameters(destination *v20230501s.RequestMethodMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RequestMethodMatchConditionParameters_STATUS populates our RequestMethodMatchConditionParameters from the provided source RequestMethodMatchConditionParameters_STATUS
func (parameters *RequestMethodMatchConditionParameters) Initialize_From_RequestMethodMatchConditionParameters_STATUS(source *RequestMethodMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]RequestMethodMatchConditionParameters_MatchValues, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValue := RequestMethodMatchConditionParameters_MatchValues(matchValueItem)
			matchValueList[matchValueIndex] = matchValue
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestMethodMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestMethodMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestMethod match conditions
type RequestMethodMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []RequestMethodMatchConditionParameters_MatchValues_STATUS `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *RequestMethodMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                     `json:"transforms,omitempty"`
	TypeName   *RequestMethodMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &RequestMethodMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestMethodMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestMethodMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestMethodMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestMethodMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestMethodMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestMethodMatchConditionParameters_STATUS populates our RequestMethodMatchConditionParameters_STATUS from the provided source RequestMethodMatchConditionParameters_STATUS
func (parameters *RequestMethodMatchConditionParameters_STATUS) AssignProperties_From_RequestMethodMatchConditionParameters_STATUS(source *v20230501s.RequestMethodMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]RequestMethodMatchConditionParameters_MatchValues_STATUS, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = RequestMethodMatchConditionParameters_MatchValues_STATUS(matchValueItem)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestMethodMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestMethodMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestMethodMatchConditionParameters_STATUS populates the provided destination RequestMethodMatchConditionParameters_STATUS from our RequestMethodMatchConditionParameters_STATUS
func (parameters *RequestMethodMatchConditionParameters_STATUS) AssignProperties_To_RequestMethodMatchConditionParameters_STATUS(destination *v20230501s.RequestMethodMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestScheme match conditions
type RequestSchemeMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []RequestSchemeMatchConditionParameters_MatchValues `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *RequestSchemeMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *RequestSchemeMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &RequestSchemeMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RequestSchemeMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &RequestSchemeMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestSchemeMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestSchemeMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestSchemeMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestSchemeMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestSchemeMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestSchemeMatchConditionParameters populates our RequestSchemeMatchConditionParameters from the provided source RequestSchemeMatchConditionParameters
func (parameters *RequestSchemeMatchConditionParameters) AssignProperties_From_RequestSchemeMatchConditionParameters(source *v20230501s.RequestSchemeMatchConditionParameters) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]RequestSchemeMatchConditionParameters_MatchValues, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = RequestSchemeMatchConditionParameters_MatchValues(matchValueItem)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestSchemeMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestSchemeMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestSchemeMatchConditionParameters populates the provided destination RequestSchemeMatchConditionParameters from our RequestSchemeMatchConditionParameters
func (parameters *RequestSchemeMatchConditionParameters) AssignProperties_To_RequestSchemeMatchConditionParameters(destination *v20230501s.RequestSchemeMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RequestSchemeMatchConditionParameters_STATUS populates our RequestSchemeMatchConditionParameters from the provided source RequestSchemeMatchConditionParameters_STATUS
func (parameters *RequestSchemeMatchConditionParameters) Initialize_From_RequestSchemeMatchConditionParameters_STATUS(source *RequestSchemeMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]RequestSchemeMatchConditionParameters_MatchValues, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValue := RequestSchemeMatchConditionParameters_MatchValues(matchValueItem)
			matchValueList[matchValueIndex] = matchValue
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestSchemeMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestSchemeMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestScheme match conditions
type RequestSchemeMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []RequestSchemeMatchConditionParameters_MatchValues_STATUS `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *RequestSchemeMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                     `json:"transforms,omitempty"`
	TypeName   *RequestSchemeMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &RequestSchemeMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestSchemeMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestSchemeMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestSchemeMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestSchemeMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestSchemeMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS populates our RequestSchemeMatchConditionParameters_STATUS from the provided source RequestSchemeMatchConditionParameters_STATUS
func (parameters *RequestSchemeMatchConditionParameters_STATUS) AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS(source *v20230501s.RequestSchemeMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]RequestSchemeMatchConditionParameters_MatchValues_STATUS, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = RequestSchemeMatchConditionParameters_MatchValues_STATUS(matchValueItem)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestSchemeMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestSchemeMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS populates the provided destination RequestSchemeMatchConditionParameters_STATUS from our RequestSchemeMatchConditionParameters_STATUS
func (parameters *RequestSchemeMatchConditionParameters_STATUS) AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS(destination *v20230501s.RequestSchemeMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestUri match conditions
type RequestUriMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *RequestUriMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *RequestUriMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &RequestUriMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RequestUriMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &RequestUriMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestUriMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestUriMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestUriMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestUriMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestUriMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestUriMatchConditionParameters populates our RequestUriMatchConditionParameters from the provided source RequestUriMatchConditionParameters
func (parameters *RequestUriMatchConditionParameters) AssignProperties_From_RequestUriMatchConditionParameters(source *v20230501s.RequestUriMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestUriMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestUriMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestUriMatchConditionParameters populates the provided destination RequestUriMatchConditionParameters from our RequestUriMatchConditionParameters
func (parameters *RequestUriMatchConditionParameters) AssignProperties_To_RequestUriMatchConditionParameters(destination *v20230501s.RequestUriMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RequestUriMatchConditionParameters_STATUS populates our RequestUriMatchConditionParameters from the provided source RequestUriMatchConditionParameters_STATUS
func (parameters *RequestUriMatchConditionParameters) Initialize_From_RequestUriMatchConditionParameters_STATUS(source *RequestUriMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestUriMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestUriMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for RequestUri match conditions
type RequestUriMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *RequestUriMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                  `json:"transforms,omitempty"`
	TypeName   *RequestUriMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &RequestUriMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RequestUriMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RequestUriMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RequestUriMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RequestUriMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RequestUriMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RequestUriMatchConditionParameters_STATUS populates our RequestUriMatchConditionParameters_STATUS from the provided source RequestUriMatchConditionParameters_STATUS
func (parameters *RequestUriMatchConditionParameters_STATUS) AssignProperties_From_RequestUriMatchConditionParameters_STATUS(source *v20230501s.RequestUriMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := RequestUriMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RequestUriMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RequestUriMatchConditionParameters_STATUS populates the provided destination RequestUriMatchConditionParameters_STATUS from our RequestUriMatchConditionParameters_STATUS
func (parameters *RequestUriMatchConditionParameters_STATUS) AssignProperties_To_RequestUriMatchConditionParameters_STATUS(destination *v20230501s.RequestUriMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for the route configuration override action.
type RouteConfigurationOverrideActionParameters struct {
	// CacheConfiguration: The caching configuration associated with this rule. To disable caching, do not provide a
	// cacheConfiguration object.
	CacheConfiguration *CacheConfiguration `json:"cacheConfiguration,omitempty"`

	// OriginGroupOverride: A reference to the origin group override configuration. Leave empty to use the default origin group
	// on route.
	OriginGroupOverride *OriginGroupOverride `json:"originGroupOverride,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *RouteConfigurationOverrideActionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &RouteConfigurationOverrideActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *RouteConfigurationOverrideActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &RouteConfigurationOverrideActionParameters_ARM{}

	// Set property "CacheConfiguration":
	if parameters.CacheConfiguration != nil {
		cacheConfiguration_ARM, err := (*parameters.CacheConfiguration).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		cacheConfiguration := *cacheConfiguration_ARM.(*CacheConfiguration_ARM)
		result.CacheConfiguration = &cacheConfiguration
	}

	// Set property "OriginGroupOverride":
	if parameters.OriginGroupOverride != nil {
		originGroupOverride_ARM, err := (*parameters.OriginGroupOverride).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		originGroupOverride := *originGroupOverride_ARM.(*OriginGroupOverride_ARM)
		result.OriginGroupOverride = &originGroupOverride
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RouteConfigurationOverrideActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RouteConfigurationOverrideActionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RouteConfigurationOverrideActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RouteConfigurationOverrideActionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RouteConfigurationOverrideActionParameters_ARM, got %T", armInput)
	}

	// Set property "CacheConfiguration":
	if typedInput.CacheConfiguration != nil {
		var cacheConfiguration1 CacheConfiguration
		err := cacheConfiguration1.PopulateFromARM(owner, *typedInput.CacheConfiguration)
		if err != nil {
			return err
		}
		cacheConfiguration := cacheConfiguration1
		parameters.CacheConfiguration = &cacheConfiguration
	}

	// Set property "OriginGroupOverride":
	if typedInput.OriginGroupOverride != nil {
		var originGroupOverride1 OriginGroupOverride
		err := originGroupOverride1.PopulateFromARM(owner, *typedInput.OriginGroupOverride)
		if err != nil {
			return err
		}
		originGroupOverride := originGroupOverride1
		parameters.OriginGroupOverride = &originGroupOverride
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RouteConfigurationOverrideActionParameters populates our RouteConfigurationOverrideActionParameters from the provided source RouteConfigurationOverrideActionParameters
func (parameters *RouteConfigurationOverrideActionParameters) AssignProperties_From_RouteConfigurationOverrideActionParameters(source *v20230501s.RouteConfigurationOverrideActionParameters) error {

	// CacheConfiguration
	if source.CacheConfiguration != nil {
		var cacheConfiguration CacheConfiguration
		err := cacheConfiguration.AssignProperties_From_CacheConfiguration(source.CacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheConfiguration() to populate field CacheConfiguration")
		}
		parameters.CacheConfiguration = &cacheConfiguration
	} else {
		parameters.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverride
		err := originGroupOverride.AssignProperties_From_OriginGroupOverride(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverride() to populate field OriginGroupOverride")
		}
		parameters.OriginGroupOverride = &originGroupOverride
	} else {
		parameters.OriginGroupOverride = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RouteConfigurationOverrideActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RouteConfigurationOverrideActionParameters populates the provided destination RouteConfigurationOverrideActionParameters from our RouteConfigurationOverrideActionParameters
func (parameters *RouteConfigurationOverrideActionParameters) AssignProperties_To_RouteConfigurationOverrideActionParameters(destination *v20230501s.RouteConfigurationOverrideActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheConfiguration
	if parameters.CacheConfiguration != nil {
		var cacheConfiguration v20230501s.CacheConfiguration
		err := parameters.CacheConfiguration.AssignProperties_To_CacheConfiguration(&cacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheConfiguration() to populate field CacheConfiguration")
		}
		destination.CacheConfiguration = &cacheConfiguration
	} else {
		destination.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if parameters.OriginGroupOverride != nil {
		var originGroupOverride v20230501s.OriginGroupOverride
		err := parameters.OriginGroupOverride.AssignProperties_To_OriginGroupOverride(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverride() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_RouteConfigurationOverrideActionParameters_STATUS populates our RouteConfigurationOverrideActionParameters from the provided source RouteConfigurationOverrideActionParameters_STATUS
func (parameters *RouteConfigurationOverrideActionParameters) Initialize_From_RouteConfigurationOverrideActionParameters_STATUS(source *RouteConfigurationOverrideActionParameters_STATUS) error {

	// CacheConfiguration
	if source.CacheConfiguration != nil {
		var cacheConfiguration CacheConfiguration
		err := cacheConfiguration.Initialize_From_CacheConfiguration_STATUS(source.CacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_CacheConfiguration_STATUS() to populate field CacheConfiguration")
		}
		parameters.CacheConfiguration = &cacheConfiguration
	} else {
		parameters.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverride
		err := originGroupOverride.Initialize_From_OriginGroupOverride_STATUS(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_OriginGroupOverride_STATUS() to populate field OriginGroupOverride")
		}
		parameters.OriginGroupOverride = &originGroupOverride
	} else {
		parameters.OriginGroupOverride = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RouteConfigurationOverrideActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for the route configuration override action.
type RouteConfigurationOverrideActionParameters_STATUS struct {
	// CacheConfiguration: The caching configuration associated with this rule. To disable caching, do not provide a
	// cacheConfiguration object.
	CacheConfiguration *CacheConfiguration_STATUS `json:"cacheConfiguration,omitempty"`

	// OriginGroupOverride: A reference to the origin group override configuration. Leave empty to use the default origin group
	// on route.
	OriginGroupOverride *OriginGroupOverride_STATUS                                 `json:"originGroupOverride,omitempty"`
	TypeName            *RouteConfigurationOverrideActionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &RouteConfigurationOverrideActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *RouteConfigurationOverrideActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &RouteConfigurationOverrideActionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *RouteConfigurationOverrideActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(RouteConfigurationOverrideActionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected RouteConfigurationOverrideActionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "CacheConfiguration":
	if typedInput.CacheConfiguration != nil {
		var cacheConfiguration1 CacheConfiguration_STATUS
		err := cacheConfiguration1.PopulateFromARM(owner, *typedInput.CacheConfiguration)
		if err != nil {
			return err
		}
		cacheConfiguration := cacheConfiguration1
		parameters.CacheConfiguration = &cacheConfiguration
	}

	// Set property "OriginGroupOverride":
	if typedInput.OriginGroupOverride != nil {
		var originGroupOverride1 OriginGroupOverride_STATUS
		err := originGroupOverride1.PopulateFromARM(owner, *typedInput.OriginGroupOverride)
		if err != nil {
			return err
		}
		originGroupOverride := originGroupOverride1
		parameters.OriginGroupOverride = &originGroupOverride
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS populates our RouteConfigurationOverrideActionParameters_STATUS from the provided source RouteConfigurationOverrideActionParameters_STATUS
func (parameters *RouteConfigurationOverrideActionParameters_STATUS) AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS(source *v20230501s.RouteConfigurationOverrideActionParameters_STATUS) error {

	// CacheConfiguration
	if source.CacheConfiguration != nil {
		var cacheConfiguration CacheConfiguration_STATUS
		err := cacheConfiguration.AssignProperties_From_CacheConfiguration_STATUS(source.CacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheConfiguration_STATUS() to populate field CacheConfiguration")
		}
		parameters.CacheConfiguration = &cacheConfiguration
	} else {
		parameters.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverride_STATUS
		err := originGroupOverride.AssignProperties_From_OriginGroupOverride_STATUS(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverride_STATUS() to populate field OriginGroupOverride")
		}
		parameters.OriginGroupOverride = &originGroupOverride
	} else {
		parameters.OriginGroupOverride = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := RouteConfigurationOverrideActionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS populates the provided destination RouteConfigurationOverrideActionParameters_STATUS from our RouteConfigurationOverrideActionParameters_STATUS
func (parameters *RouteConfigurationOverrideActionParameters_STATUS) AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS(destination *v20230501s.RouteConfigurationOverrideActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheConfiguration
	if parameters.CacheConfiguration != nil {
		var cacheConfiguration v20230501s.CacheConfiguration_STATUS
		err := parameters.CacheConfiguration.AssignProperties_To_CacheConfiguration_STATUS(&cacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheConfiguration_STATUS() to populate field CacheConfiguration")
		}
		destination.CacheConfiguration = &cacheConfiguration
	} else {
		destination.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if parameters.OriginGroupOverride != nil {
		var originGroupOverride v20230501s.OriginGroupOverride_STATUS
		err := parameters.OriginGroupOverride.AssignProperties_To_OriginGroupOverride_STATUS(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverride_STATUS() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for ServerPort match conditions
type ServerPortMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *ServerPortMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *ServerPortMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &ServerPortMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *ServerPortMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &ServerPortMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ServerPortMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServerPortMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ServerPortMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServerPortMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServerPortMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_ServerPortMatchConditionParameters populates our ServerPortMatchConditionParameters from the provided source ServerPortMatchConditionParameters
func (parameters *ServerPortMatchConditionParameters) AssignProperties_From_ServerPortMatchConditionParameters(source *v20230501s.ServerPortMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := ServerPortMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := ServerPortMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPortMatchConditionParameters populates the provided destination ServerPortMatchConditionParameters from our ServerPortMatchConditionParameters
func (parameters *ServerPortMatchConditionParameters) AssignProperties_To_ServerPortMatchConditionParameters(destination *v20230501s.ServerPortMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_ServerPortMatchConditionParameters_STATUS populates our ServerPortMatchConditionParameters from the provided source ServerPortMatchConditionParameters_STATUS
func (parameters *ServerPortMatchConditionParameters) Initialize_From_ServerPortMatchConditionParameters_STATUS(source *ServerPortMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := ServerPortMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := ServerPortMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for ServerPort match conditions
type ServerPortMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *ServerPortMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                  `json:"transforms,omitempty"`
	TypeName   *ServerPortMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &ServerPortMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ServerPortMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServerPortMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ServerPortMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServerPortMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServerPortMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_ServerPortMatchConditionParameters_STATUS populates our ServerPortMatchConditionParameters_STATUS from the provided source ServerPortMatchConditionParameters_STATUS
func (parameters *ServerPortMatchConditionParameters_STATUS) AssignProperties_From_ServerPortMatchConditionParameters_STATUS(source *v20230501s.ServerPortMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := ServerPortMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := ServerPortMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPortMatchConditionParameters_STATUS populates the provided destination ServerPortMatchConditionParameters_STATUS from our ServerPortMatchConditionParameters_STATUS
func (parameters *ServerPortMatchConditionParameters_STATUS) AssignProperties_To_ServerPortMatchConditionParameters_STATUS(destination *v20230501s.ServerPortMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for SocketAddress match conditions
type SocketAddrMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *SocketAddrMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *SocketAddrMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &SocketAddrMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *SocketAddrMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &SocketAddrMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *SocketAddrMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SocketAddrMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *SocketAddrMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SocketAddrMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SocketAddrMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_SocketAddrMatchConditionParameters populates our SocketAddrMatchConditionParameters from the provided source SocketAddrMatchConditionParameters
func (parameters *SocketAddrMatchConditionParameters) AssignProperties_From_SocketAddrMatchConditionParameters(source *v20230501s.SocketAddrMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := SocketAddrMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := SocketAddrMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SocketAddrMatchConditionParameters populates the provided destination SocketAddrMatchConditionParameters from our SocketAddrMatchConditionParameters
func (parameters *SocketAddrMatchConditionParameters) AssignProperties_To_SocketAddrMatchConditionParameters(destination *v20230501s.SocketAddrMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SocketAddrMatchConditionParameters_STATUS populates our SocketAddrMatchConditionParameters from the provided source SocketAddrMatchConditionParameters_STATUS
func (parameters *SocketAddrMatchConditionParameters) Initialize_From_SocketAddrMatchConditionParameters_STATUS(source *SocketAddrMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := SocketAddrMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := SocketAddrMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for SocketAddress match conditions
type SocketAddrMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *SocketAddrMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                  `json:"transforms,omitempty"`
	TypeName   *SocketAddrMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &SocketAddrMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *SocketAddrMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SocketAddrMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *SocketAddrMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SocketAddrMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SocketAddrMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_SocketAddrMatchConditionParameters_STATUS populates our SocketAddrMatchConditionParameters_STATUS from the provided source SocketAddrMatchConditionParameters_STATUS
func (parameters *SocketAddrMatchConditionParameters_STATUS) AssignProperties_From_SocketAddrMatchConditionParameters_STATUS(source *v20230501s.SocketAddrMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := SocketAddrMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := SocketAddrMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SocketAddrMatchConditionParameters_STATUS populates the provided destination SocketAddrMatchConditionParameters_STATUS from our SocketAddrMatchConditionParameters_STATUS
func (parameters *SocketAddrMatchConditionParameters_STATUS) AssignProperties_To_SocketAddrMatchConditionParameters_STATUS(destination *v20230501s.SocketAddrMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for SslProtocol match conditions
type SslProtocolMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []SslProtocol `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *SslProtocolMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *SslProtocolMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &SslProtocolMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *SslProtocolMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &SslProtocolMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *SslProtocolMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SslProtocolMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *SslProtocolMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SslProtocolMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SslProtocolMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_SslProtocolMatchConditionParameters populates our SslProtocolMatchConditionParameters from the provided source SslProtocolMatchConditionParameters
func (parameters *SslProtocolMatchConditionParameters) AssignProperties_From_SslProtocolMatchConditionParameters(source *v20230501s.SslProtocolMatchConditionParameters) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]SslProtocol, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = SslProtocol(matchValueItem)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := SslProtocolMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := SslProtocolMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SslProtocolMatchConditionParameters populates the provided destination SslProtocolMatchConditionParameters from our SslProtocolMatchConditionParameters
func (parameters *SslProtocolMatchConditionParameters) AssignProperties_To_SslProtocolMatchConditionParameters(destination *v20230501s.SslProtocolMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_SslProtocolMatchConditionParameters_STATUS populates our SslProtocolMatchConditionParameters from the provided source SslProtocolMatchConditionParameters_STATUS
func (parameters *SslProtocolMatchConditionParameters) Initialize_From_SslProtocolMatchConditionParameters_STATUS(source *SslProtocolMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]SslProtocol, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValue := SslProtocol(matchValueItem)
			matchValueList[matchValueIndex] = matchValue
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := SslProtocolMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := SslProtocolMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for SslProtocol match conditions
type SslProtocolMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []SslProtocol_STATUS `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *SslProtocolMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                   `json:"transforms,omitempty"`
	TypeName   *SslProtocolMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &SslProtocolMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *SslProtocolMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SslProtocolMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *SslProtocolMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SslProtocolMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SslProtocolMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_SslProtocolMatchConditionParameters_STATUS populates our SslProtocolMatchConditionParameters_STATUS from the provided source SslProtocolMatchConditionParameters_STATUS
func (parameters *SslProtocolMatchConditionParameters_STATUS) AssignProperties_From_SslProtocolMatchConditionParameters_STATUS(source *v20230501s.SslProtocolMatchConditionParameters_STATUS) error {

	// MatchValues
	if source.MatchValues != nil {
		matchValueList := make([]SslProtocol_STATUS, len(source.MatchValues))
		for matchValueIndex, matchValueItem := range source.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = SslProtocol_STATUS(matchValueItem)
		}
		parameters.MatchValues = matchValueList
	} else {
		parameters.MatchValues = nil
	}

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := SslProtocolMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := SslProtocolMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_SslProtocolMatchConditionParameters_STATUS populates the provided destination SslProtocolMatchConditionParameters_STATUS from our SslProtocolMatchConditionParameters_STATUS
func (parameters *SslProtocolMatchConditionParameters_STATUS) AssignProperties_To_SslProtocolMatchConditionParameters_STATUS(destination *v20230501s.SslProtocolMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	if parameters.MatchValues != nil {
		matchValueList := make([]string, len(parameters.MatchValues))
		for matchValueIndex, matchValueItem := range parameters.MatchValues {
			// Shadow the loop variable to avoid aliasing
			matchValueItem := matchValueItem
			matchValueList[matchValueIndex] = string(matchValueItem)
		}
		destination.MatchValues = matchValueList
	} else {
		destination.MatchValues = nil
	}

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for UrlFileExtension match conditions
type UrlFileExtensionMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *UrlFileExtensionMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *UrlFileExtensionMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlFileExtensionMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *UrlFileExtensionMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &UrlFileExtensionMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlFileExtensionMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlFileExtensionMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlFileExtensionMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlFileExtensionMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlFileExtensionMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlFileExtensionMatchConditionParameters populates our UrlFileExtensionMatchConditionParameters from the provided source UrlFileExtensionMatchConditionParameters
func (parameters *UrlFileExtensionMatchConditionParameters) AssignProperties_From_UrlFileExtensionMatchConditionParameters(source *v20230501s.UrlFileExtensionMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := UrlFileExtensionMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlFileExtensionMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileExtensionMatchConditionParameters populates the provided destination UrlFileExtensionMatchConditionParameters from our UrlFileExtensionMatchConditionParameters
func (parameters *UrlFileExtensionMatchConditionParameters) AssignProperties_To_UrlFileExtensionMatchConditionParameters(destination *v20230501s.UrlFileExtensionMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlFileExtensionMatchConditionParameters_STATUS populates our UrlFileExtensionMatchConditionParameters from the provided source UrlFileExtensionMatchConditionParameters_STATUS
func (parameters *UrlFileExtensionMatchConditionParameters) Initialize_From_UrlFileExtensionMatchConditionParameters_STATUS(source *UrlFileExtensionMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := UrlFileExtensionMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlFileExtensionMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for UrlFileExtension match conditions
type UrlFileExtensionMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *UrlFileExtensionMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                        `json:"transforms,omitempty"`
	TypeName   *UrlFileExtensionMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlFileExtensionMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlFileExtensionMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlFileExtensionMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlFileExtensionMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlFileExtensionMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlFileExtensionMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS populates our UrlFileExtensionMatchConditionParameters_STATUS from the provided source UrlFileExtensionMatchConditionParameters_STATUS
func (parameters *UrlFileExtensionMatchConditionParameters_STATUS) AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS(source *v20230501s.UrlFileExtensionMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := UrlFileExtensionMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlFileExtensionMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS populates the provided destination UrlFileExtensionMatchConditionParameters_STATUS from our UrlFileExtensionMatchConditionParameters_STATUS
func (parameters *UrlFileExtensionMatchConditionParameters_STATUS) AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS(destination *v20230501s.UrlFileExtensionMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for UrlFilename match conditions
type UrlFileNameMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *UrlFileNameMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *UrlFileNameMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlFileNameMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *UrlFileNameMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &UrlFileNameMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlFileNameMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlFileNameMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlFileNameMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlFileNameMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlFileNameMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlFileNameMatchConditionParameters populates our UrlFileNameMatchConditionParameters from the provided source UrlFileNameMatchConditionParameters
func (parameters *UrlFileNameMatchConditionParameters) AssignProperties_From_UrlFileNameMatchConditionParameters(source *v20230501s.UrlFileNameMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := UrlFileNameMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlFileNameMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileNameMatchConditionParameters populates the provided destination UrlFileNameMatchConditionParameters from our UrlFileNameMatchConditionParameters
func (parameters *UrlFileNameMatchConditionParameters) AssignProperties_To_UrlFileNameMatchConditionParameters(destination *v20230501s.UrlFileNameMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlFileNameMatchConditionParameters_STATUS populates our UrlFileNameMatchConditionParameters from the provided source UrlFileNameMatchConditionParameters_STATUS
func (parameters *UrlFileNameMatchConditionParameters) Initialize_From_UrlFileNameMatchConditionParameters_STATUS(source *UrlFileNameMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := UrlFileNameMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlFileNameMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for UrlFilename match conditions
type UrlFileNameMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *UrlFileNameMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                                   `json:"transforms,omitempty"`
	TypeName   *UrlFileNameMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlFileNameMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlFileNameMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlFileNameMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlFileNameMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlFileNameMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlFileNameMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS populates our UrlFileNameMatchConditionParameters_STATUS from the provided source UrlFileNameMatchConditionParameters_STATUS
func (parameters *UrlFileNameMatchConditionParameters_STATUS) AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS(source *v20230501s.UrlFileNameMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := UrlFileNameMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlFileNameMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS populates the provided destination UrlFileNameMatchConditionParameters_STATUS from our UrlFileNameMatchConditionParameters_STATUS
func (parameters *UrlFileNameMatchConditionParameters_STATUS) AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS(destination *v20230501s.UrlFileNameMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for UrlPath match conditions
type UrlPathMatchConditionParameters struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// +kubebuilder:validation:Required
	// Operator: Describes operator to be matched
	Operator *UrlPathMatchConditionParameters_Operator `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform `json:"transforms,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *UrlPathMatchConditionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlPathMatchConditionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *UrlPathMatchConditionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &UrlPathMatchConditionParameters_ARM{}

	// Set property "MatchValues":
	for _, item := range parameters.MatchValues {
		result.MatchValues = append(result.MatchValues, item)
	}

	// Set property "NegateCondition":
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		result.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if parameters.Operator != nil {
		operator := *parameters.Operator
		result.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range parameters.Transforms {
		result.Transforms = append(result.Transforms, item)
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlPathMatchConditionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlPathMatchConditionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlPathMatchConditionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlPathMatchConditionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlPathMatchConditionParameters_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlPathMatchConditionParameters populates our UrlPathMatchConditionParameters from the provided source UrlPathMatchConditionParameters
func (parameters *UrlPathMatchConditionParameters) AssignProperties_From_UrlPathMatchConditionParameters(source *v20230501s.UrlPathMatchConditionParameters) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := UrlPathMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlPathMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlPathMatchConditionParameters populates the provided destination UrlPathMatchConditionParameters from our UrlPathMatchConditionParameters
func (parameters *UrlPathMatchConditionParameters) AssignProperties_To_UrlPathMatchConditionParameters(destination *v20230501s.UrlPathMatchConditionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlPathMatchConditionParameters_STATUS populates our UrlPathMatchConditionParameters from the provided source UrlPathMatchConditionParameters_STATUS
func (parameters *UrlPathMatchConditionParameters) Initialize_From_UrlPathMatchConditionParameters_STATUS(source *UrlPathMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := UrlPathMatchConditionParameters_Operator(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transform := Transform(transformItem)
			transformList[transformIndex] = transform
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlPathMatchConditionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for UrlPath match conditions
type UrlPathMatchConditionParameters_STATUS struct {
	// MatchValues: The match value for the condition of the delivery rule
	MatchValues []string `json:"matchValues,omitempty"`

	// NegateCondition: Describes if this is negate condition or not
	NegateCondition *bool `json:"negateCondition,omitempty"`

	// Operator: Describes operator to be matched
	Operator *UrlPathMatchConditionParameters_Operator_STATUS `json:"operator,omitempty"`

	// Transforms: List of transforms
	Transforms []Transform_STATUS                               `json:"transforms,omitempty"`
	TypeName   *UrlPathMatchConditionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlPathMatchConditionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlPathMatchConditionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlPathMatchConditionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlPathMatchConditionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlPathMatchConditionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlPathMatchConditionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "MatchValues":
	for _, item := range typedInput.MatchValues {
		parameters.MatchValues = append(parameters.MatchValues, item)
	}

	// Set property "NegateCondition":
	if typedInput.NegateCondition != nil {
		negateCondition := *typedInput.NegateCondition
		parameters.NegateCondition = &negateCondition
	}

	// Set property "Operator":
	if typedInput.Operator != nil {
		operator := *typedInput.Operator
		parameters.Operator = &operator
	}

	// Set property "Transforms":
	for _, item := range typedInput.Transforms {
		parameters.Transforms = append(parameters.Transforms, item)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlPathMatchConditionParameters_STATUS populates our UrlPathMatchConditionParameters_STATUS from the provided source UrlPathMatchConditionParameters_STATUS
func (parameters *UrlPathMatchConditionParameters_STATUS) AssignProperties_From_UrlPathMatchConditionParameters_STATUS(source *v20230501s.UrlPathMatchConditionParameters_STATUS) error {

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	if source.Operator != nil {
		operator := UrlPathMatchConditionParameters_Operator_STATUS(*source.Operator)
		parameters.Operator = &operator
	} else {
		parameters.Operator = nil
	}

	// Transforms
	if source.Transforms != nil {
		transformList := make([]Transform_STATUS, len(source.Transforms))
		for transformIndex, transformItem := range source.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = Transform_STATUS(transformItem)
		}
		parameters.Transforms = transformList
	} else {
		parameters.Transforms = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlPathMatchConditionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlPathMatchConditionParameters_STATUS populates the provided destination UrlPathMatchConditionParameters_STATUS from our UrlPathMatchConditionParameters_STATUS
func (parameters *UrlPathMatchConditionParameters_STATUS) AssignProperties_To_UrlPathMatchConditionParameters_STATUS(destination *v20230501s.UrlPathMatchConditionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	if parameters.Operator != nil {
		operator := string(*parameters.Operator)
		destination.Operator = &operator
	} else {
		destination.Operator = nil
	}

	// Transforms
	if parameters.Transforms != nil {
		transformList := make([]string, len(parameters.Transforms))
		for transformIndex, transformItem := range parameters.Transforms {
			// Shadow the loop variable to avoid aliasing
			transformItem := transformItem
			transformList[transformIndex] = string(transformItem)
		}
		destination.Transforms = transformList
	} else {
		destination.Transforms = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for the url redirect action.
type UrlRedirectActionParameters struct {
	// CustomFragment: Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include
	// the #.
	CustomFragment *string `json:"customFragment,omitempty"`

	// CustomHostname: Host to redirect. Leave empty to use the incoming host as the destination host.
	CustomHostname *string `json:"customHostname,omitempty"`

	// CustomPath: The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path
	// as destination path.
	CustomPath *string `json:"customPath,omitempty"`

	// CustomQueryString: The set of query strings to be placed in the redirect URL. Setting this value would replace any
	// existing query string; leave empty to preserve the incoming query string. Query string must be in <key>=<value> format.
	// ? and & will be added automatically so do not include them.
	CustomQueryString *string `json:"customQueryString,omitempty"`

	// DestinationProtocol: Protocol to use for the redirect. The default value is MatchRequest
	DestinationProtocol *UrlRedirectActionParameters_DestinationProtocol `json:"destinationProtocol,omitempty"`

	// +kubebuilder:validation:Required
	// RedirectType: The redirect type the rule will use when redirecting traffic.
	RedirectType *UrlRedirectActionParameters_RedirectType `json:"redirectType,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *UrlRedirectActionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlRedirectActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *UrlRedirectActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &UrlRedirectActionParameters_ARM{}

	// Set property "CustomFragment":
	if parameters.CustomFragment != nil {
		customFragment := *parameters.CustomFragment
		result.CustomFragment = &customFragment
	}

	// Set property "CustomHostname":
	if parameters.CustomHostname != nil {
		customHostname := *parameters.CustomHostname
		result.CustomHostname = &customHostname
	}

	// Set property "CustomPath":
	if parameters.CustomPath != nil {
		customPath := *parameters.CustomPath
		result.CustomPath = &customPath
	}

	// Set property "CustomQueryString":
	if parameters.CustomQueryString != nil {
		customQueryString := *parameters.CustomQueryString
		result.CustomQueryString = &customQueryString
	}

	// Set property "DestinationProtocol":
	if parameters.DestinationProtocol != nil {
		destinationProtocol := *parameters.DestinationProtocol
		result.DestinationProtocol = &destinationProtocol
	}

	// Set property "RedirectType":
	if parameters.RedirectType != nil {
		redirectType := *parameters.RedirectType
		result.RedirectType = &redirectType
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlRedirectActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlRedirectActionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlRedirectActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlRedirectActionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlRedirectActionParameters_ARM, got %T", armInput)
	}

	// Set property "CustomFragment":
	if typedInput.CustomFragment != nil {
		customFragment := *typedInput.CustomFragment
		parameters.CustomFragment = &customFragment
	}

	// Set property "CustomHostname":
	if typedInput.CustomHostname != nil {
		customHostname := *typedInput.CustomHostname
		parameters.CustomHostname = &customHostname
	}

	// Set property "CustomPath":
	if typedInput.CustomPath != nil {
		customPath := *typedInput.CustomPath
		parameters.CustomPath = &customPath
	}

	// Set property "CustomQueryString":
	if typedInput.CustomQueryString != nil {
		customQueryString := *typedInput.CustomQueryString
		parameters.CustomQueryString = &customQueryString
	}

	// Set property "DestinationProtocol":
	if typedInput.DestinationProtocol != nil {
		destinationProtocol := *typedInput.DestinationProtocol
		parameters.DestinationProtocol = &destinationProtocol
	}

	// Set property "RedirectType":
	if typedInput.RedirectType != nil {
		redirectType := *typedInput.RedirectType
		parameters.RedirectType = &redirectType
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRedirectActionParameters populates our UrlRedirectActionParameters from the provided source UrlRedirectActionParameters
func (parameters *UrlRedirectActionParameters) AssignProperties_From_UrlRedirectActionParameters(source *v20230501s.UrlRedirectActionParameters) error {

	// CustomFragment
	parameters.CustomFragment = genruntime.ClonePointerToString(source.CustomFragment)

	// CustomHostname
	parameters.CustomHostname = genruntime.ClonePointerToString(source.CustomHostname)

	// CustomPath
	parameters.CustomPath = genruntime.ClonePointerToString(source.CustomPath)

	// CustomQueryString
	parameters.CustomQueryString = genruntime.ClonePointerToString(source.CustomQueryString)

	// DestinationProtocol
	if source.DestinationProtocol != nil {
		destinationProtocol := UrlRedirectActionParameters_DestinationProtocol(*source.DestinationProtocol)
		parameters.DestinationProtocol = &destinationProtocol
	} else {
		parameters.DestinationProtocol = nil
	}

	// RedirectType
	if source.RedirectType != nil {
		redirectType := UrlRedirectActionParameters_RedirectType(*source.RedirectType)
		parameters.RedirectType = &redirectType
	} else {
		parameters.RedirectType = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlRedirectActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectActionParameters populates the provided destination UrlRedirectActionParameters from our UrlRedirectActionParameters
func (parameters *UrlRedirectActionParameters) AssignProperties_To_UrlRedirectActionParameters(destination *v20230501s.UrlRedirectActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomFragment
	destination.CustomFragment = genruntime.ClonePointerToString(parameters.CustomFragment)

	// CustomHostname
	destination.CustomHostname = genruntime.ClonePointerToString(parameters.CustomHostname)

	// CustomPath
	destination.CustomPath = genruntime.ClonePointerToString(parameters.CustomPath)

	// CustomQueryString
	destination.CustomQueryString = genruntime.ClonePointerToString(parameters.CustomQueryString)

	// DestinationProtocol
	if parameters.DestinationProtocol != nil {
		destinationProtocol := string(*parameters.DestinationProtocol)
		destination.DestinationProtocol = &destinationProtocol
	} else {
		destination.DestinationProtocol = nil
	}

	// RedirectType
	if parameters.RedirectType != nil {
		redirectType := string(*parameters.RedirectType)
		destination.RedirectType = &redirectType
	} else {
		destination.RedirectType = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlRedirectActionParameters_STATUS populates our UrlRedirectActionParameters from the provided source UrlRedirectActionParameters_STATUS
func (parameters *UrlRedirectActionParameters) Initialize_From_UrlRedirectActionParameters_STATUS(source *UrlRedirectActionParameters_STATUS) error {

	// CustomFragment
	parameters.CustomFragment = genruntime.ClonePointerToString(source.CustomFragment)

	// CustomHostname
	parameters.CustomHostname = genruntime.ClonePointerToString(source.CustomHostname)

	// CustomPath
	parameters.CustomPath = genruntime.ClonePointerToString(source.CustomPath)

	// CustomQueryString
	parameters.CustomQueryString = genruntime.ClonePointerToString(source.CustomQueryString)

	// DestinationProtocol
	if source.DestinationProtocol != nil {
		destinationProtocol := UrlRedirectActionParameters_DestinationProtocol(*source.DestinationProtocol)
		parameters.DestinationProtocol = &destinationProtocol
	} else {
		parameters.DestinationProtocol = nil
	}

	// RedirectType
	if source.RedirectType != nil {
		redirectType := UrlRedirectActionParameters_RedirectType(*source.RedirectType)
		parameters.RedirectType = &redirectType
	} else {
		parameters.RedirectType = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlRedirectActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for the url redirect action.
type UrlRedirectActionParameters_STATUS struct {
	// CustomFragment: Fragment to add to the redirect URL. Fragment is the part of the URL that comes after #. Do not include
	// the #.
	CustomFragment *string `json:"customFragment,omitempty"`

	// CustomHostname: Host to redirect. Leave empty to use the incoming host as the destination host.
	CustomHostname *string `json:"customHostname,omitempty"`

	// CustomPath: The full path to redirect. Path cannot be empty and must start with /. Leave empty to use the incoming path
	// as destination path.
	CustomPath *string `json:"customPath,omitempty"`

	// CustomQueryString: The set of query strings to be placed in the redirect URL. Setting this value would replace any
	// existing query string; leave empty to preserve the incoming query string. Query string must be in <key>=<value> format.
	// ? and & will be added automatically so do not include them.
	CustomQueryString *string `json:"customQueryString,omitempty"`

	// DestinationProtocol: Protocol to use for the redirect. The default value is MatchRequest
	DestinationProtocol *UrlRedirectActionParameters_DestinationProtocol_STATUS `json:"destinationProtocol,omitempty"`

	// RedirectType: The redirect type the rule will use when redirecting traffic.
	RedirectType *UrlRedirectActionParameters_RedirectType_STATUS `json:"redirectType,omitempty"`
	TypeName     *UrlRedirectActionParameters_TypeName_STATUS     `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlRedirectActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlRedirectActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlRedirectActionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlRedirectActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlRedirectActionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlRedirectActionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "CustomFragment":
	if typedInput.CustomFragment != nil {
		customFragment := *typedInput.CustomFragment
		parameters.CustomFragment = &customFragment
	}

	// Set property "CustomHostname":
	if typedInput.CustomHostname != nil {
		customHostname := *typedInput.CustomHostname
		parameters.CustomHostname = &customHostname
	}

	// Set property "CustomPath":
	if typedInput.CustomPath != nil {
		customPath := *typedInput.CustomPath
		parameters.CustomPath = &customPath
	}

	// Set property "CustomQueryString":
	if typedInput.CustomQueryString != nil {
		customQueryString := *typedInput.CustomQueryString
		parameters.CustomQueryString = &customQueryString
	}

	// Set property "DestinationProtocol":
	if typedInput.DestinationProtocol != nil {
		destinationProtocol := *typedInput.DestinationProtocol
		parameters.DestinationProtocol = &destinationProtocol
	}

	// Set property "RedirectType":
	if typedInput.RedirectType != nil {
		redirectType := *typedInput.RedirectType
		parameters.RedirectType = &redirectType
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRedirectActionParameters_STATUS populates our UrlRedirectActionParameters_STATUS from the provided source UrlRedirectActionParameters_STATUS
func (parameters *UrlRedirectActionParameters_STATUS) AssignProperties_From_UrlRedirectActionParameters_STATUS(source *v20230501s.UrlRedirectActionParameters_STATUS) error {

	// CustomFragment
	parameters.CustomFragment = genruntime.ClonePointerToString(source.CustomFragment)

	// CustomHostname
	parameters.CustomHostname = genruntime.ClonePointerToString(source.CustomHostname)

	// CustomPath
	parameters.CustomPath = genruntime.ClonePointerToString(source.CustomPath)

	// CustomQueryString
	parameters.CustomQueryString = genruntime.ClonePointerToString(source.CustomQueryString)

	// DestinationProtocol
	if source.DestinationProtocol != nil {
		destinationProtocol := UrlRedirectActionParameters_DestinationProtocol_STATUS(*source.DestinationProtocol)
		parameters.DestinationProtocol = &destinationProtocol
	} else {
		parameters.DestinationProtocol = nil
	}

	// RedirectType
	if source.RedirectType != nil {
		redirectType := UrlRedirectActionParameters_RedirectType_STATUS(*source.RedirectType)
		parameters.RedirectType = &redirectType
	} else {
		parameters.RedirectType = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlRedirectActionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectActionParameters_STATUS populates the provided destination UrlRedirectActionParameters_STATUS from our UrlRedirectActionParameters_STATUS
func (parameters *UrlRedirectActionParameters_STATUS) AssignProperties_To_UrlRedirectActionParameters_STATUS(destination *v20230501s.UrlRedirectActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomFragment
	destination.CustomFragment = genruntime.ClonePointerToString(parameters.CustomFragment)

	// CustomHostname
	destination.CustomHostname = genruntime.ClonePointerToString(parameters.CustomHostname)

	// CustomPath
	destination.CustomPath = genruntime.ClonePointerToString(parameters.CustomPath)

	// CustomQueryString
	destination.CustomQueryString = genruntime.ClonePointerToString(parameters.CustomQueryString)

	// DestinationProtocol
	if parameters.DestinationProtocol != nil {
		destinationProtocol := string(*parameters.DestinationProtocol)
		destination.DestinationProtocol = &destinationProtocol
	} else {
		destination.DestinationProtocol = nil
	}

	// RedirectType
	if parameters.RedirectType != nil {
		redirectType := string(*parameters.RedirectType)
		destination.RedirectType = &redirectType
	} else {
		destination.RedirectType = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for the url rewrite action.
type UrlRewriteActionParameters struct {
	// +kubebuilder:validation:Required
	// Destination: Define the relative URL to which the above requests will be rewritten by.
	Destination *string `json:"destination,omitempty"`

	// PreserveUnmatchedPath: Whether to preserve unmatched path. Default value is true.
	PreserveUnmatchedPath *bool `json:"preserveUnmatchedPath,omitempty"`

	// +kubebuilder:validation:Required
	// SourcePattern: define a request URI pattern that identifies the type of requests that may be rewritten. If value is
	// blank, all strings are matched.
	SourcePattern *string `json:"sourcePattern,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *UrlRewriteActionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlRewriteActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *UrlRewriteActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &UrlRewriteActionParameters_ARM{}

	// Set property "Destination":
	if parameters.Destination != nil {
		destination := *parameters.Destination
		result.Destination = &destination
	}

	// Set property "PreserveUnmatchedPath":
	if parameters.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *parameters.PreserveUnmatchedPath
		result.PreserveUnmatchedPath = &preserveUnmatchedPath
	}

	// Set property "SourcePattern":
	if parameters.SourcePattern != nil {
		sourcePattern := *parameters.SourcePattern
		result.SourcePattern = &sourcePattern
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlRewriteActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlRewriteActionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlRewriteActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlRewriteActionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlRewriteActionParameters_ARM, got %T", armInput)
	}

	// Set property "Destination":
	if typedInput.Destination != nil {
		destination := *typedInput.Destination
		parameters.Destination = &destination
	}

	// Set property "PreserveUnmatchedPath":
	if typedInput.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *typedInput.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	}

	// Set property "SourcePattern":
	if typedInput.SourcePattern != nil {
		sourcePattern := *typedInput.SourcePattern
		parameters.SourcePattern = &sourcePattern
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRewriteActionParameters populates our UrlRewriteActionParameters from the provided source UrlRewriteActionParameters
func (parameters *UrlRewriteActionParameters) AssignProperties_From_UrlRewriteActionParameters(source *v20230501s.UrlRewriteActionParameters) error {

	// Destination
	parameters.Destination = genruntime.ClonePointerToString(source.Destination)

	// PreserveUnmatchedPath
	if source.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *source.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		parameters.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	parameters.SourcePattern = genruntime.ClonePointerToString(source.SourcePattern)

	// TypeName
	if source.TypeName != nil {
		typeName := UrlRewriteActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteActionParameters populates the provided destination UrlRewriteActionParameters from our UrlRewriteActionParameters
func (parameters *UrlRewriteActionParameters) AssignProperties_To_UrlRewriteActionParameters(destination *v20230501s.UrlRewriteActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Destination
	destination.Destination = genruntime.ClonePointerToString(parameters.Destination)

	// PreserveUnmatchedPath
	if parameters.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *parameters.PreserveUnmatchedPath
		destination.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		destination.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	destination.SourcePattern = genruntime.ClonePointerToString(parameters.SourcePattern)

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlRewriteActionParameters_STATUS populates our UrlRewriteActionParameters from the provided source UrlRewriteActionParameters_STATUS
func (parameters *UrlRewriteActionParameters) Initialize_From_UrlRewriteActionParameters_STATUS(source *UrlRewriteActionParameters_STATUS) error {

	// Destination
	parameters.Destination = genruntime.ClonePointerToString(source.Destination)

	// PreserveUnmatchedPath
	if source.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *source.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		parameters.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	parameters.SourcePattern = genruntime.ClonePointerToString(source.SourcePattern)

	// TypeName
	if source.TypeName != nil {
		typeName := UrlRewriteActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for the url rewrite action.
type UrlRewriteActionParameters_STATUS struct {
	// Destination: Define the relative URL to which the above requests will be rewritten by.
	Destination *string `json:"destination,omitempty"`

	// PreserveUnmatchedPath: Whether to preserve unmatched path. Default value is true.
	PreserveUnmatchedPath *bool `json:"preserveUnmatchedPath,omitempty"`

	// SourcePattern: define a request URI pattern that identifies the type of requests that may be rewritten. If value is
	// blank, all strings are matched.
	SourcePattern *string                                     `json:"sourcePattern,omitempty"`
	TypeName      *UrlRewriteActionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlRewriteActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlRewriteActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlRewriteActionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlRewriteActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlRewriteActionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlRewriteActionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "Destination":
	if typedInput.Destination != nil {
		destination := *typedInput.Destination
		parameters.Destination = &destination
	}

	// Set property "PreserveUnmatchedPath":
	if typedInput.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *typedInput.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	}

	// Set property "SourcePattern":
	if typedInput.SourcePattern != nil {
		sourcePattern := *typedInput.SourcePattern
		parameters.SourcePattern = &sourcePattern
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlRewriteActionParameters_STATUS populates our UrlRewriteActionParameters_STATUS from the provided source UrlRewriteActionParameters_STATUS
func (parameters *UrlRewriteActionParameters_STATUS) AssignProperties_From_UrlRewriteActionParameters_STATUS(source *v20230501s.UrlRewriteActionParameters_STATUS) error {

	// Destination
	parameters.Destination = genruntime.ClonePointerToString(source.Destination)

	// PreserveUnmatchedPath
	if source.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *source.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		parameters.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	parameters.SourcePattern = genruntime.ClonePointerToString(source.SourcePattern)

	// TypeName
	if source.TypeName != nil {
		typeName := UrlRewriteActionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteActionParameters_STATUS populates the provided destination UrlRewriteActionParameters_STATUS from our UrlRewriteActionParameters_STATUS
func (parameters *UrlRewriteActionParameters_STATUS) AssignProperties_To_UrlRewriteActionParameters_STATUS(destination *v20230501s.UrlRewriteActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Destination
	destination.Destination = genruntime.ClonePointerToString(parameters.Destination)

	// PreserveUnmatchedPath
	if parameters.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *parameters.PreserveUnmatchedPath
		destination.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		destination.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	destination.SourcePattern = genruntime.ClonePointerToString(parameters.SourcePattern)

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for the Url Signing action.
type UrlSigningActionParameters struct {
	// Algorithm: Algorithm to use for URL signing
	Algorithm *UrlSigningActionParameters_Algorithm `json:"algorithm,omitempty"`

	// ParameterNameOverride: Defines which query string parameters in the url to be considered for expires, key id etc.
	ParameterNameOverride []UrlSigningParamIdentifier `json:"parameterNameOverride,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *UrlSigningActionParameters_TypeName `json:"typeName,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlSigningActionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *UrlSigningActionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &UrlSigningActionParameters_ARM{}

	// Set property "Algorithm":
	if parameters.Algorithm != nil {
		algorithm := *parameters.Algorithm
		result.Algorithm = &algorithm
	}

	// Set property "ParameterNameOverride":
	for _, item := range parameters.ParameterNameOverride {
		item_ARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.ParameterNameOverride = append(result.ParameterNameOverride, *item_ARM.(*UrlSigningParamIdentifier_ARM))
	}

	// Set property "TypeName":
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlSigningActionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlSigningActionParameters_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlSigningActionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlSigningActionParameters_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlSigningActionParameters_ARM, got %T", armInput)
	}

	// Set property "Algorithm":
	if typedInput.Algorithm != nil {
		algorithm := *typedInput.Algorithm
		parameters.Algorithm = &algorithm
	}

	// Set property "ParameterNameOverride":
	for _, item := range typedInput.ParameterNameOverride {
		var item1 UrlSigningParamIdentifier
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		parameters.ParameterNameOverride = append(parameters.ParameterNameOverride, item1)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlSigningActionParameters populates our UrlSigningActionParameters from the provided source UrlSigningActionParameters
func (parameters *UrlSigningActionParameters) AssignProperties_From_UrlSigningActionParameters(source *v20230501s.UrlSigningActionParameters) error {

	// Algorithm
	if source.Algorithm != nil {
		algorithm := UrlSigningActionParameters_Algorithm(*source.Algorithm)
		parameters.Algorithm = &algorithm
	} else {
		parameters.Algorithm = nil
	}

	// ParameterNameOverride
	if source.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]UrlSigningParamIdentifier, len(source.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range source.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride UrlSigningParamIdentifier
			err := parameterNameOverride.AssignProperties_From_UrlSigningParamIdentifier(&parameterNameOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UrlSigningParamIdentifier() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		parameters.ParameterNameOverride = parameterNameOverrideList
	} else {
		parameters.ParameterNameOverride = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlSigningActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningActionParameters populates the provided destination UrlSigningActionParameters from our UrlSigningActionParameters
func (parameters *UrlSigningActionParameters) AssignProperties_To_UrlSigningActionParameters(destination *v20230501s.UrlSigningActionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Algorithm
	if parameters.Algorithm != nil {
		algorithm := string(*parameters.Algorithm)
		destination.Algorithm = &algorithm
	} else {
		destination.Algorithm = nil
	}

	// ParameterNameOverride
	if parameters.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]v20230501s.UrlSigningParamIdentifier, len(parameters.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range parameters.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride v20230501s.UrlSigningParamIdentifier
			err := parameterNameOverrideItem.AssignProperties_To_UrlSigningParamIdentifier(&parameterNameOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UrlSigningParamIdentifier() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		destination.ParameterNameOverride = parameterNameOverrideList
	} else {
		destination.ParameterNameOverride = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlSigningActionParameters_STATUS populates our UrlSigningActionParameters from the provided source UrlSigningActionParameters_STATUS
func (parameters *UrlSigningActionParameters) Initialize_From_UrlSigningActionParameters_STATUS(source *UrlSigningActionParameters_STATUS) error {

	// Algorithm
	if source.Algorithm != nil {
		algorithm := UrlSigningActionParameters_Algorithm(*source.Algorithm)
		parameters.Algorithm = &algorithm
	} else {
		parameters.Algorithm = nil
	}

	// ParameterNameOverride
	if source.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]UrlSigningParamIdentifier, len(source.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range source.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride UrlSigningParamIdentifier
			err := parameterNameOverride.Initialize_From_UrlSigningParamIdentifier_STATUS(&parameterNameOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling Initialize_From_UrlSigningParamIdentifier_STATUS() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		parameters.ParameterNameOverride = parameterNameOverrideList
	} else {
		parameters.ParameterNameOverride = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlSigningActionParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// Defines the parameters for the Url Signing action.
type UrlSigningActionParameters_STATUS struct {
	// Algorithm: Algorithm to use for URL signing
	Algorithm *UrlSigningActionParameters_Algorithm_STATUS `json:"algorithm,omitempty"`

	// ParameterNameOverride: Defines which query string parameters in the url to be considered for expires, key id etc.
	ParameterNameOverride []UrlSigningParamIdentifier_STATUS          `json:"parameterNameOverride,omitempty"`
	TypeName              *UrlSigningActionParameters_TypeName_STATUS `json:"typeName,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlSigningActionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *UrlSigningActionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlSigningActionParameters_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *UrlSigningActionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlSigningActionParameters_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlSigningActionParameters_STATUS_ARM, got %T", armInput)
	}

	// Set property "Algorithm":
	if typedInput.Algorithm != nil {
		algorithm := *typedInput.Algorithm
		parameters.Algorithm = &algorithm
	}

	// Set property "ParameterNameOverride":
	for _, item := range typedInput.ParameterNameOverride {
		var item1 UrlSigningParamIdentifier_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		parameters.ParameterNameOverride = append(parameters.ParameterNameOverride, item1)
	}

	// Set property "TypeName":
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlSigningActionParameters_STATUS populates our UrlSigningActionParameters_STATUS from the provided source UrlSigningActionParameters_STATUS
func (parameters *UrlSigningActionParameters_STATUS) AssignProperties_From_UrlSigningActionParameters_STATUS(source *v20230501s.UrlSigningActionParameters_STATUS) error {

	// Algorithm
	if source.Algorithm != nil {
		algorithm := UrlSigningActionParameters_Algorithm_STATUS(*source.Algorithm)
		parameters.Algorithm = &algorithm
	} else {
		parameters.Algorithm = nil
	}

	// ParameterNameOverride
	if source.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]UrlSigningParamIdentifier_STATUS, len(source.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range source.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride UrlSigningParamIdentifier_STATUS
			err := parameterNameOverride.AssignProperties_From_UrlSigningParamIdentifier_STATUS(&parameterNameOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UrlSigningParamIdentifier_STATUS() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		parameters.ParameterNameOverride = parameterNameOverrideList
	} else {
		parameters.ParameterNameOverride = nil
	}

	// TypeName
	if source.TypeName != nil {
		typeName := UrlSigningActionParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningActionParameters_STATUS populates the provided destination UrlSigningActionParameters_STATUS from our UrlSigningActionParameters_STATUS
func (parameters *UrlSigningActionParameters_STATUS) AssignProperties_To_UrlSigningActionParameters_STATUS(destination *v20230501s.UrlSigningActionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Algorithm
	if parameters.Algorithm != nil {
		algorithm := string(*parameters.Algorithm)
		destination.Algorithm = &algorithm
	} else {
		destination.Algorithm = nil
	}

	// ParameterNameOverride
	if parameters.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]v20230501s.UrlSigningParamIdentifier_STATUS, len(parameters.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range parameters.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride v20230501s.UrlSigningParamIdentifier_STATUS
			err := parameterNameOverrideItem.AssignProperties_To_UrlSigningParamIdentifier_STATUS(&parameterNameOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UrlSigningParamIdentifier_STATUS() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		destination.ParameterNameOverride = parameterNameOverrideList
	} else {
		destination.ParameterNameOverride = nil
	}

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
type CacheConfiguration struct {
	// CacheBehavior: Caching behavior for the requests
	CacheBehavior *CacheConfiguration_CacheBehavior `json:"cacheBehavior,omitempty"`

	// CacheDuration: The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
	CacheDuration *string `json:"cacheDuration,omitempty"`

	// IsCompressionEnabled: Indicates whether content compression is enabled. If compression is enabled, content will be
	// served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when
	// requested content is smaller than 1 byte or larger than 1 MB.
	IsCompressionEnabled *CacheConfiguration_IsCompressionEnabled `json:"isCompressionEnabled,omitempty"`

	// QueryParameters: query parameters to include or exclude (comma separated).
	QueryParameters *string `json:"queryParameters,omitempty"`

	// QueryStringCachingBehavior: Defines how Frontdoor caches requests that include query strings. You can ignore any query
	// strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query
	// strings.
	QueryStringCachingBehavior *CacheConfiguration_QueryStringCachingBehavior `json:"queryStringCachingBehavior,omitempty"`
}

var _ genruntime.ARMTransformer = &CacheConfiguration{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (configuration *CacheConfiguration) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if configuration == nil {
		return nil, nil
	}
	result := &CacheConfiguration_ARM{}

	// Set property "CacheBehavior":
	if configuration.CacheBehavior != nil {
		cacheBehavior := *configuration.CacheBehavior
		result.CacheBehavior = &cacheBehavior
	}

	// Set property "CacheDuration":
	if configuration.CacheDuration != nil {
		cacheDuration := *configuration.CacheDuration
		result.CacheDuration = &cacheDuration
	}

	// Set property "IsCompressionEnabled":
	if configuration.IsCompressionEnabled != nil {
		isCompressionEnabled := *configuration.IsCompressionEnabled
		result.IsCompressionEnabled = &isCompressionEnabled
	}

	// Set property "QueryParameters":
	if configuration.QueryParameters != nil {
		queryParameters := *configuration.QueryParameters
		result.QueryParameters = &queryParameters
	}

	// Set property "QueryStringCachingBehavior":
	if configuration.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := *configuration.QueryStringCachingBehavior
		result.QueryStringCachingBehavior = &queryStringCachingBehavior
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *CacheConfiguration) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CacheConfiguration_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *CacheConfiguration) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CacheConfiguration_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CacheConfiguration_ARM, got %T", armInput)
	}

	// Set property "CacheBehavior":
	if typedInput.CacheBehavior != nil {
		cacheBehavior := *typedInput.CacheBehavior
		configuration.CacheBehavior = &cacheBehavior
	}

	// Set property "CacheDuration":
	if typedInput.CacheDuration != nil {
		cacheDuration := *typedInput.CacheDuration
		configuration.CacheDuration = &cacheDuration
	}

	// Set property "IsCompressionEnabled":
	if typedInput.IsCompressionEnabled != nil {
		isCompressionEnabled := *typedInput.IsCompressionEnabled
		configuration.IsCompressionEnabled = &isCompressionEnabled
	}

	// Set property "QueryParameters":
	if typedInput.QueryParameters != nil {
		queryParameters := *typedInput.QueryParameters
		configuration.QueryParameters = &queryParameters
	}

	// Set property "QueryStringCachingBehavior":
	if typedInput.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := *typedInput.QueryStringCachingBehavior
		configuration.QueryStringCachingBehavior = &queryStringCachingBehavior
	}

	// No error
	return nil
}

// AssignProperties_From_CacheConfiguration populates our CacheConfiguration from the provided source CacheConfiguration
func (configuration *CacheConfiguration) AssignProperties_From_CacheConfiguration(source *v20230501s.CacheConfiguration) error {

	// CacheBehavior
	if source.CacheBehavior != nil {
		cacheBehavior := CacheConfiguration_CacheBehavior(*source.CacheBehavior)
		configuration.CacheBehavior = &cacheBehavior
	} else {
		configuration.CacheBehavior = nil
	}

	// CacheDuration
	configuration.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := CacheConfiguration_IsCompressionEnabled(*source.IsCompressionEnabled)
		configuration.IsCompressionEnabled = &isCompressionEnabled
	} else {
		configuration.IsCompressionEnabled = nil
	}

	// QueryParameters
	configuration.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringCachingBehavior
	if source.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := CacheConfiguration_QueryStringCachingBehavior(*source.QueryStringCachingBehavior)
		configuration.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		configuration.QueryStringCachingBehavior = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CacheConfiguration populates the provided destination CacheConfiguration from our CacheConfiguration
func (configuration *CacheConfiguration) AssignProperties_To_CacheConfiguration(destination *v20230501s.CacheConfiguration) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheBehavior
	if configuration.CacheBehavior != nil {
		cacheBehavior := string(*configuration.CacheBehavior)
		destination.CacheBehavior = &cacheBehavior
	} else {
		destination.CacheBehavior = nil
	}

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(configuration.CacheDuration)

	// IsCompressionEnabled
	if configuration.IsCompressionEnabled != nil {
		isCompressionEnabled := string(*configuration.IsCompressionEnabled)
		destination.IsCompressionEnabled = &isCompressionEnabled
	} else {
		destination.IsCompressionEnabled = nil
	}

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(configuration.QueryParameters)

	// QueryStringCachingBehavior
	if configuration.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := string(*configuration.QueryStringCachingBehavior)
		destination.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		destination.QueryStringCachingBehavior = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_CacheConfiguration_STATUS populates our CacheConfiguration from the provided source CacheConfiguration_STATUS
func (configuration *CacheConfiguration) Initialize_From_CacheConfiguration_STATUS(source *CacheConfiguration_STATUS) error {

	// CacheBehavior
	if source.CacheBehavior != nil {
		cacheBehavior := CacheConfiguration_CacheBehavior(*source.CacheBehavior)
		configuration.CacheBehavior = &cacheBehavior
	} else {
		configuration.CacheBehavior = nil
	}

	// CacheDuration
	configuration.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := CacheConfiguration_IsCompressionEnabled(*source.IsCompressionEnabled)
		configuration.IsCompressionEnabled = &isCompressionEnabled
	} else {
		configuration.IsCompressionEnabled = nil
	}

	// QueryParameters
	configuration.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringCachingBehavior
	if source.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := CacheConfiguration_QueryStringCachingBehavior(*source.QueryStringCachingBehavior)
		configuration.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		configuration.QueryStringCachingBehavior = nil
	}

	// No error
	return nil
}

// Caching settings for a caching-type route. To disable caching, do not provide a cacheConfiguration object.
type CacheConfiguration_STATUS struct {
	// CacheBehavior: Caching behavior for the requests
	CacheBehavior *CacheConfiguration_CacheBehavior_STATUS `json:"cacheBehavior,omitempty"`

	// CacheDuration: The duration for which the content needs to be cached. Allowed format is [d.]hh:mm:ss
	CacheDuration *string `json:"cacheDuration,omitempty"`

	// IsCompressionEnabled: Indicates whether content compression is enabled. If compression is enabled, content will be
	// served as compressed if user requests for a compressed version. Content won't be compressed on AzureFrontDoor when
	// requested content is smaller than 1 byte or larger than 1 MB.
	IsCompressionEnabled *CacheConfiguration_IsCompressionEnabled_STATUS `json:"isCompressionEnabled,omitempty"`

	// QueryParameters: query parameters to include or exclude (comma separated).
	QueryParameters *string `json:"queryParameters,omitempty"`

	// QueryStringCachingBehavior: Defines how Frontdoor caches requests that include query strings. You can ignore any query
	// strings when caching, ignore specific query strings, cache every request with a unique URL, or cache specific query
	// strings.
	QueryStringCachingBehavior *CacheConfiguration_QueryStringCachingBehavior_STATUS `json:"queryStringCachingBehavior,omitempty"`
}

var _ genruntime.FromARMConverter = &CacheConfiguration_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (configuration *CacheConfiguration_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CacheConfiguration_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (configuration *CacheConfiguration_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CacheConfiguration_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CacheConfiguration_STATUS_ARM, got %T", armInput)
	}

	// Set property "CacheBehavior":
	if typedInput.CacheBehavior != nil {
		cacheBehavior := *typedInput.CacheBehavior
		configuration.CacheBehavior = &cacheBehavior
	}

	// Set property "CacheDuration":
	if typedInput.CacheDuration != nil {
		cacheDuration := *typedInput.CacheDuration
		configuration.CacheDuration = &cacheDuration
	}

	// Set property "IsCompressionEnabled":
	if typedInput.IsCompressionEnabled != nil {
		isCompressionEnabled := *typedInput.IsCompressionEnabled
		configuration.IsCompressionEnabled = &isCompressionEnabled
	}

	// Set property "QueryParameters":
	if typedInput.QueryParameters != nil {
		queryParameters := *typedInput.QueryParameters
		configuration.QueryParameters = &queryParameters
	}

	// Set property "QueryStringCachingBehavior":
	if typedInput.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := *typedInput.QueryStringCachingBehavior
		configuration.QueryStringCachingBehavior = &queryStringCachingBehavior
	}

	// No error
	return nil
}

// AssignProperties_From_CacheConfiguration_STATUS populates our CacheConfiguration_STATUS from the provided source CacheConfiguration_STATUS
func (configuration *CacheConfiguration_STATUS) AssignProperties_From_CacheConfiguration_STATUS(source *v20230501s.CacheConfiguration_STATUS) error {

	// CacheBehavior
	if source.CacheBehavior != nil {
		cacheBehavior := CacheConfiguration_CacheBehavior_STATUS(*source.CacheBehavior)
		configuration.CacheBehavior = &cacheBehavior
	} else {
		configuration.CacheBehavior = nil
	}

	// CacheDuration
	configuration.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := CacheConfiguration_IsCompressionEnabled_STATUS(*source.IsCompressionEnabled)
		configuration.IsCompressionEnabled = &isCompressionEnabled
	} else {
		configuration.IsCompressionEnabled = nil
	}

	// QueryParameters
	configuration.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringCachingBehavior
	if source.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := CacheConfiguration_QueryStringCachingBehavior_STATUS(*source.QueryStringCachingBehavior)
		configuration.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		configuration.QueryStringCachingBehavior = nil
	}

	// No error
	return nil
}

// AssignProperties_To_CacheConfiguration_STATUS populates the provided destination CacheConfiguration_STATUS from our CacheConfiguration_STATUS
func (configuration *CacheConfiguration_STATUS) AssignProperties_To_CacheConfiguration_STATUS(destination *v20230501s.CacheConfiguration_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CacheBehavior
	if configuration.CacheBehavior != nil {
		cacheBehavior := string(*configuration.CacheBehavior)
		destination.CacheBehavior = &cacheBehavior
	} else {
		destination.CacheBehavior = nil
	}

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(configuration.CacheDuration)

	// IsCompressionEnabled
	if configuration.IsCompressionEnabled != nil {
		isCompressionEnabled := string(*configuration.IsCompressionEnabled)
		destination.IsCompressionEnabled = &isCompressionEnabled
	} else {
		destination.IsCompressionEnabled = nil
	}

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(configuration.QueryParameters)

	// QueryStringCachingBehavior
	if configuration.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := string(*configuration.QueryStringCachingBehavior)
		destination.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		destination.QueryStringCachingBehavior = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines the parameters for the origin group override configuration.
type OriginGroupOverride struct {
	// ForwardingProtocol: Protocol this rule will use when forwarding traffic to backends.
	ForwardingProtocol *OriginGroupOverride_ForwardingProtocol `json:"forwardingProtocol,omitempty"`

	// OriginGroup: defines the OriginGroup that would override the DefaultOriginGroup on route.
	OriginGroup *ResourceReference `json:"originGroup,omitempty"`
}

var _ genruntime.ARMTransformer = &OriginGroupOverride{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (override *OriginGroupOverride) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if override == nil {
		return nil, nil
	}
	result := &OriginGroupOverride_ARM{}

	// Set property "ForwardingProtocol":
	if override.ForwardingProtocol != nil {
		forwardingProtocol := *override.ForwardingProtocol
		result.ForwardingProtocol = &forwardingProtocol
	}

	// Set property "OriginGroup":
	if override.OriginGroup != nil {
		originGroup_ARM, err := (*override.OriginGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		originGroup := *originGroup_ARM.(*ResourceReference_ARM)
		result.OriginGroup = &originGroup
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *OriginGroupOverride) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OriginGroupOverride_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *OriginGroupOverride) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OriginGroupOverride_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OriginGroupOverride_ARM, got %T", armInput)
	}

	// Set property "ForwardingProtocol":
	if typedInput.ForwardingProtocol != nil {
		forwardingProtocol := *typedInput.ForwardingProtocol
		override.ForwardingProtocol = &forwardingProtocol
	}

	// Set property "OriginGroup":
	if typedInput.OriginGroup != nil {
		var originGroup1 ResourceReference
		err := originGroup1.PopulateFromARM(owner, *typedInput.OriginGroup)
		if err != nil {
			return err
		}
		originGroup := originGroup1
		override.OriginGroup = &originGroup
	}

	// No error
	return nil
}

// AssignProperties_From_OriginGroupOverride populates our OriginGroupOverride from the provided source OriginGroupOverride
func (override *OriginGroupOverride) AssignProperties_From_OriginGroupOverride(source *v20230501s.OriginGroupOverride) error {

	// ForwardingProtocol
	if source.ForwardingProtocol != nil {
		forwardingProtocol := OriginGroupOverride_ForwardingProtocol(*source.ForwardingProtocol)
		override.ForwardingProtocol = &forwardingProtocol
	} else {
		override.ForwardingProtocol = nil
	}

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference
		err := originGroup.AssignProperties_From_ResourceReference(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field OriginGroup")
		}
		override.OriginGroup = &originGroup
	} else {
		override.OriginGroup = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverride populates the provided destination OriginGroupOverride from our OriginGroupOverride
func (override *OriginGroupOverride) AssignProperties_To_OriginGroupOverride(destination *v20230501s.OriginGroupOverride) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ForwardingProtocol
	if override.ForwardingProtocol != nil {
		forwardingProtocol := string(*override.ForwardingProtocol)
		destination.ForwardingProtocol = &forwardingProtocol
	} else {
		destination.ForwardingProtocol = nil
	}

	// OriginGroup
	if override.OriginGroup != nil {
		var originGroup v20230501s.ResourceReference
		err := override.OriginGroup.AssignProperties_To_ResourceReference(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_OriginGroupOverride_STATUS populates our OriginGroupOverride from the provided source OriginGroupOverride_STATUS
func (override *OriginGroupOverride) Initialize_From_OriginGroupOverride_STATUS(source *OriginGroupOverride_STATUS) error {

	// ForwardingProtocol
	if source.ForwardingProtocol != nil {
		forwardingProtocol := OriginGroupOverride_ForwardingProtocol(*source.ForwardingProtocol)
		override.ForwardingProtocol = &forwardingProtocol
	} else {
		override.ForwardingProtocol = nil
	}

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference
		err := originGroup.Initialize_From_ResourceReference_STATUS(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling Initialize_From_ResourceReference_STATUS() to populate field OriginGroup")
		}
		override.OriginGroup = &originGroup
	} else {
		override.OriginGroup = nil
	}

	// No error
	return nil
}

// Defines the parameters for the origin group override configuration.
type OriginGroupOverride_STATUS struct {
	// ForwardingProtocol: Protocol this rule will use when forwarding traffic to backends.
	ForwardingProtocol *OriginGroupOverride_ForwardingProtocol_STATUS `json:"forwardingProtocol,omitempty"`

	// OriginGroup: defines the OriginGroup that would override the DefaultOriginGroup on route.
	OriginGroup *ResourceReference_STATUS `json:"originGroup,omitempty"`
}

var _ genruntime.FromARMConverter = &OriginGroupOverride_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (override *OriginGroupOverride_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &OriginGroupOverride_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (override *OriginGroupOverride_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(OriginGroupOverride_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected OriginGroupOverride_STATUS_ARM, got %T", armInput)
	}

	// Set property "ForwardingProtocol":
	if typedInput.ForwardingProtocol != nil {
		forwardingProtocol := *typedInput.ForwardingProtocol
		override.ForwardingProtocol = &forwardingProtocol
	}

	// Set property "OriginGroup":
	if typedInput.OriginGroup != nil {
		var originGroup1 ResourceReference_STATUS
		err := originGroup1.PopulateFromARM(owner, *typedInput.OriginGroup)
		if err != nil {
			return err
		}
		originGroup := originGroup1
		override.OriginGroup = &originGroup
	}

	// No error
	return nil
}

// AssignProperties_From_OriginGroupOverride_STATUS populates our OriginGroupOverride_STATUS from the provided source OriginGroupOverride_STATUS
func (override *OriginGroupOverride_STATUS) AssignProperties_From_OriginGroupOverride_STATUS(source *v20230501s.OriginGroupOverride_STATUS) error {

	// ForwardingProtocol
	if source.ForwardingProtocol != nil {
		forwardingProtocol := OriginGroupOverride_ForwardingProtocol_STATUS(*source.ForwardingProtocol)
		override.ForwardingProtocol = &forwardingProtocol
	} else {
		override.ForwardingProtocol = nil
	}

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference_STATUS
		err := originGroup.AssignProperties_From_ResourceReference_STATUS(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field OriginGroup")
		}
		override.OriginGroup = &originGroup
	} else {
		override.OriginGroup = nil
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverride_STATUS populates the provided destination OriginGroupOverride_STATUS from our OriginGroupOverride_STATUS
func (override *OriginGroupOverride_STATUS) AssignProperties_To_OriginGroupOverride_STATUS(destination *v20230501s.OriginGroupOverride_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ForwardingProtocol
	if override.ForwardingProtocol != nil {
		forwardingProtocol := string(*override.ForwardingProtocol)
		destination.ForwardingProtocol = &forwardingProtocol
	} else {
		destination.ForwardingProtocol = nil
	}

	// OriginGroup
	if override.OriginGroup != nil {
		var originGroup v20230501s.ResourceReference_STATUS
		err := override.OriginGroup.AssignProperties_To_ResourceReference_STATUS(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Defines how to identify a parameter for a specific purpose e.g. expires
type UrlSigningParamIdentifier struct {
	// +kubebuilder:validation:Required
	// ParamIndicator: Indicates the purpose of the parameter
	ParamIndicator *UrlSigningParamIdentifier_ParamIndicator `json:"paramIndicator,omitempty"`

	// +kubebuilder:validation:Required
	// ParamName: Parameter name
	ParamName *string `json:"paramName,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlSigningParamIdentifier{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (identifier *UrlSigningParamIdentifier) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if identifier == nil {
		return nil, nil
	}
	result := &UrlSigningParamIdentifier_ARM{}

	// Set property "ParamIndicator":
	if identifier.ParamIndicator != nil {
		paramIndicator := *identifier.ParamIndicator
		result.ParamIndicator = &paramIndicator
	}

	// Set property "ParamName":
	if identifier.ParamName != nil {
		paramName := *identifier.ParamName
		result.ParamName = &paramName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identifier *UrlSigningParamIdentifier) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlSigningParamIdentifier_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identifier *UrlSigningParamIdentifier) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlSigningParamIdentifier_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlSigningParamIdentifier_ARM, got %T", armInput)
	}

	// Set property "ParamIndicator":
	if typedInput.ParamIndicator != nil {
		paramIndicator := *typedInput.ParamIndicator
		identifier.ParamIndicator = &paramIndicator
	}

	// Set property "ParamName":
	if typedInput.ParamName != nil {
		paramName := *typedInput.ParamName
		identifier.ParamName = &paramName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlSigningParamIdentifier populates our UrlSigningParamIdentifier from the provided source UrlSigningParamIdentifier
func (identifier *UrlSigningParamIdentifier) AssignProperties_From_UrlSigningParamIdentifier(source *v20230501s.UrlSigningParamIdentifier) error {

	// ParamIndicator
	if source.ParamIndicator != nil {
		paramIndicator := UrlSigningParamIdentifier_ParamIndicator(*source.ParamIndicator)
		identifier.ParamIndicator = &paramIndicator
	} else {
		identifier.ParamIndicator = nil
	}

	// ParamName
	identifier.ParamName = genruntime.ClonePointerToString(source.ParamName)

	// No error
	return nil
}

// AssignProperties_To_UrlSigningParamIdentifier populates the provided destination UrlSigningParamIdentifier from our UrlSigningParamIdentifier
func (identifier *UrlSigningParamIdentifier) AssignProperties_To_UrlSigningParamIdentifier(destination *v20230501s.UrlSigningParamIdentifier) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ParamIndicator
	if identifier.ParamIndicator != nil {
		paramIndicator := string(*identifier.ParamIndicator)
		destination.ParamIndicator = &paramIndicator
	} else {
		destination.ParamIndicator = nil
	}

	// ParamName
	destination.ParamName = genruntime.ClonePointerToString(identifier.ParamName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Initialize_From_UrlSigningParamIdentifier_STATUS populates our UrlSigningParamIdentifier from the provided source UrlSigningParamIdentifier_STATUS
func (identifier *UrlSigningParamIdentifier) Initialize_From_UrlSigningParamIdentifier_STATUS(source *UrlSigningParamIdentifier_STATUS) error {

	// ParamIndicator
	if source.ParamIndicator != nil {
		paramIndicator := UrlSigningParamIdentifier_ParamIndicator(*source.ParamIndicator)
		identifier.ParamIndicator = &paramIndicator
	} else {
		identifier.ParamIndicator = nil
	}

	// ParamName
	identifier.ParamName = genruntime.ClonePointerToString(source.ParamName)

	// No error
	return nil
}

// Defines how to identify a parameter for a specific purpose e.g. expires
type UrlSigningParamIdentifier_STATUS struct {
	// ParamIndicator: Indicates the purpose of the parameter
	ParamIndicator *UrlSigningParamIdentifier_ParamIndicator_STATUS `json:"paramIndicator,omitempty"`

	// ParamName: Parameter name
	ParamName *string `json:"paramName,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlSigningParamIdentifier_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (identifier *UrlSigningParamIdentifier_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlSigningParamIdentifier_STATUS_ARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (identifier *UrlSigningParamIdentifier_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlSigningParamIdentifier_STATUS_ARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlSigningParamIdentifier_STATUS_ARM, got %T", armInput)
	}

	// Set property "ParamIndicator":
	if typedInput.ParamIndicator != nil {
		paramIndicator := *typedInput.ParamIndicator
		identifier.ParamIndicator = &paramIndicator
	}

	// Set property "ParamName":
	if typedInput.ParamName != nil {
		paramName := *typedInput.ParamName
		identifier.ParamName = &paramName
	}

	// No error
	return nil
}

// AssignProperties_From_UrlSigningParamIdentifier_STATUS populates our UrlSigningParamIdentifier_STATUS from the provided source UrlSigningParamIdentifier_STATUS
func (identifier *UrlSigningParamIdentifier_STATUS) AssignProperties_From_UrlSigningParamIdentifier_STATUS(source *v20230501s.UrlSigningParamIdentifier_STATUS) error {

	// ParamIndicator
	if source.ParamIndicator != nil {
		paramIndicator := UrlSigningParamIdentifier_ParamIndicator_STATUS(*source.ParamIndicator)
		identifier.ParamIndicator = &paramIndicator
	} else {
		identifier.ParamIndicator = nil
	}

	// ParamName
	identifier.ParamName = genruntime.ClonePointerToString(source.ParamName)

	// No error
	return nil
}

// AssignProperties_To_UrlSigningParamIdentifier_STATUS populates the provided destination UrlSigningParamIdentifier_STATUS from our UrlSigningParamIdentifier_STATUS
func (identifier *UrlSigningParamIdentifier_STATUS) AssignProperties_To_UrlSigningParamIdentifier_STATUS(destination *v20230501s.UrlSigningParamIdentifier_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ParamIndicator
	if identifier.ParamIndicator != nil {
		paramIndicator := string(*identifier.ParamIndicator)
		destination.ParamIndicator = &paramIndicator
	} else {
		destination.ParamIndicator = nil
	}

	// ParamName
	destination.ParamName = genruntime.ClonePointerToString(identifier.ParamName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&Rule{}, &RuleList{})
}
