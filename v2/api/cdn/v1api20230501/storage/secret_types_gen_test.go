// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_AzureFirstPartyManagedCertificateParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirstPartyManagedCertificateParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirstPartyManagedCertificateParameters, AzureFirstPartyManagedCertificateParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirstPartyManagedCertificateParameters runs a test to see if a specific instance of AzureFirstPartyManagedCertificateParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirstPartyManagedCertificateParameters(subject AzureFirstPartyManagedCertificateParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirstPartyManagedCertificateParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirstPartyManagedCertificateParameters instances for property testing - lazily instantiated by
// AzureFirstPartyManagedCertificateParametersGenerator()
var azureFirstPartyManagedCertificateParametersGenerator gopter.Gen

// AzureFirstPartyManagedCertificateParametersGenerator returns a generator of AzureFirstPartyManagedCertificateParameters instances for property testing.
func AzureFirstPartyManagedCertificateParametersGenerator() gopter.Gen {
	if azureFirstPartyManagedCertificateParametersGenerator != nil {
		return azureFirstPartyManagedCertificateParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirstPartyManagedCertificateParameters(generators)
	azureFirstPartyManagedCertificateParametersGenerator = gen.Struct(reflect.TypeOf(AzureFirstPartyManagedCertificateParameters{}), generators)

	return azureFirstPartyManagedCertificateParametersGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirstPartyManagedCertificateParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirstPartyManagedCertificateParameters(gens map[string]gopter.Gen) {
	gens["SubjectAlternativeNames"] = gen.SliceOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_AzureFirstPartyManagedCertificateParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AzureFirstPartyManagedCertificateParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAzureFirstPartyManagedCertificateParameters_STATUS, AzureFirstPartyManagedCertificateParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAzureFirstPartyManagedCertificateParameters_STATUS runs a test to see if a specific instance of AzureFirstPartyManagedCertificateParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForAzureFirstPartyManagedCertificateParameters_STATUS(subject AzureFirstPartyManagedCertificateParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AzureFirstPartyManagedCertificateParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AzureFirstPartyManagedCertificateParameters_STATUS instances for property testing - lazily instantiated
// by AzureFirstPartyManagedCertificateParameters_STATUSGenerator()
var azureFirstPartyManagedCertificateParameters_STATUSGenerator gopter.Gen

// AzureFirstPartyManagedCertificateParameters_STATUSGenerator returns a generator of AzureFirstPartyManagedCertificateParameters_STATUS instances for property testing.
// We first initialize azureFirstPartyManagedCertificateParameters_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AzureFirstPartyManagedCertificateParameters_STATUSGenerator() gopter.Gen {
	if azureFirstPartyManagedCertificateParameters_STATUSGenerator != nil {
		return azureFirstPartyManagedCertificateParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirstPartyManagedCertificateParameters_STATUS(generators)
	azureFirstPartyManagedCertificateParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFirstPartyManagedCertificateParameters_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAzureFirstPartyManagedCertificateParameters_STATUS(generators)
	AddRelatedPropertyGeneratorsForAzureFirstPartyManagedCertificateParameters_STATUS(generators)
	azureFirstPartyManagedCertificateParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(AzureFirstPartyManagedCertificateParameters_STATUS{}), generators)

	return azureFirstPartyManagedCertificateParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForAzureFirstPartyManagedCertificateParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAzureFirstPartyManagedCertificateParameters_STATUS(gens map[string]gopter.Gen) {
	gens["CertificateAuthority"] = gen.PtrOf(gen.AlphaString())
	gens["ExpirationDate"] = gen.PtrOf(gen.AlphaString())
	gens["Subject"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectAlternativeNames"] = gen.SliceOf(gen.AlphaString())
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAzureFirstPartyManagedCertificateParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAzureFirstPartyManagedCertificateParameters_STATUS(gens map[string]gopter.Gen) {
	gens["SecretSource"] = gen.PtrOf(ResourceReference_STATUSGenerator())
}

func Test_CustomerCertificateParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomerCertificateParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomerCertificateParameters, CustomerCertificateParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomerCertificateParameters runs a test to see if a specific instance of CustomerCertificateParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomerCertificateParameters(subject CustomerCertificateParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomerCertificateParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomerCertificateParameters instances for property testing - lazily instantiated by
// CustomerCertificateParametersGenerator()
var customerCertificateParametersGenerator gopter.Gen

// CustomerCertificateParametersGenerator returns a generator of CustomerCertificateParameters instances for property testing.
// We first initialize customerCertificateParametersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomerCertificateParametersGenerator() gopter.Gen {
	if customerCertificateParametersGenerator != nil {
		return customerCertificateParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomerCertificateParameters(generators)
	customerCertificateParametersGenerator = gen.Struct(reflect.TypeOf(CustomerCertificateParameters{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomerCertificateParameters(generators)
	AddRelatedPropertyGeneratorsForCustomerCertificateParameters(generators)
	customerCertificateParametersGenerator = gen.Struct(reflect.TypeOf(CustomerCertificateParameters{}), generators)

	return customerCertificateParametersGenerator
}

// AddIndependentPropertyGeneratorsForCustomerCertificateParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomerCertificateParameters(gens map[string]gopter.Gen) {
	gens["SecretVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectAlternativeNames"] = gen.SliceOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["UseLatestVersion"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForCustomerCertificateParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomerCertificateParameters(gens map[string]gopter.Gen) {
	gens["SecretSource"] = gen.PtrOf(ResourceReferenceGenerator())
}

func Test_CustomerCertificateParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomerCertificateParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomerCertificateParameters_STATUS, CustomerCertificateParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomerCertificateParameters_STATUS runs a test to see if a specific instance of CustomerCertificateParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomerCertificateParameters_STATUS(subject CustomerCertificateParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomerCertificateParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomerCertificateParameters_STATUS instances for property testing - lazily instantiated by
// CustomerCertificateParameters_STATUSGenerator()
var customerCertificateParameters_STATUSGenerator gopter.Gen

// CustomerCertificateParameters_STATUSGenerator returns a generator of CustomerCertificateParameters_STATUS instances for property testing.
// We first initialize customerCertificateParameters_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomerCertificateParameters_STATUSGenerator() gopter.Gen {
	if customerCertificateParameters_STATUSGenerator != nil {
		return customerCertificateParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomerCertificateParameters_STATUS(generators)
	customerCertificateParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomerCertificateParameters_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomerCertificateParameters_STATUS(generators)
	AddRelatedPropertyGeneratorsForCustomerCertificateParameters_STATUS(generators)
	customerCertificateParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomerCertificateParameters_STATUS{}), generators)

	return customerCertificateParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCustomerCertificateParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomerCertificateParameters_STATUS(gens map[string]gopter.Gen) {
	gens["CertificateAuthority"] = gen.PtrOf(gen.AlphaString())
	gens["ExpirationDate"] = gen.PtrOf(gen.AlphaString())
	gens["SecretVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Subject"] = gen.PtrOf(gen.AlphaString())
	gens["SubjectAlternativeNames"] = gen.SliceOf(gen.AlphaString())
	gens["Thumbprint"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["UseLatestVersion"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForCustomerCertificateParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomerCertificateParameters_STATUS(gens map[string]gopter.Gen) {
	gens["SecretSource"] = gen.PtrOf(ResourceReference_STATUSGenerator())
}

func Test_ManagedCertificateParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedCertificateParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedCertificateParameters, ManagedCertificateParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedCertificateParameters runs a test to see if a specific instance of ManagedCertificateParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedCertificateParameters(subject ManagedCertificateParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedCertificateParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedCertificateParameters instances for property testing - lazily instantiated by
// ManagedCertificateParametersGenerator()
var managedCertificateParametersGenerator gopter.Gen

// ManagedCertificateParametersGenerator returns a generator of ManagedCertificateParameters instances for property testing.
func ManagedCertificateParametersGenerator() gopter.Gen {
	if managedCertificateParametersGenerator != nil {
		return managedCertificateParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedCertificateParameters(generators)
	managedCertificateParametersGenerator = gen.Struct(reflect.TypeOf(ManagedCertificateParameters{}), generators)

	return managedCertificateParametersGenerator
}

// AddIndependentPropertyGeneratorsForManagedCertificateParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedCertificateParameters(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedCertificateParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedCertificateParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedCertificateParameters_STATUS, ManagedCertificateParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedCertificateParameters_STATUS runs a test to see if a specific instance of ManagedCertificateParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedCertificateParameters_STATUS(subject ManagedCertificateParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedCertificateParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedCertificateParameters_STATUS instances for property testing - lazily instantiated by
// ManagedCertificateParameters_STATUSGenerator()
var managedCertificateParameters_STATUSGenerator gopter.Gen

// ManagedCertificateParameters_STATUSGenerator returns a generator of ManagedCertificateParameters_STATUS instances for property testing.
func ManagedCertificateParameters_STATUSGenerator() gopter.Gen {
	if managedCertificateParameters_STATUSGenerator != nil {
		return managedCertificateParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedCertificateParameters_STATUS(generators)
	managedCertificateParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedCertificateParameters_STATUS{}), generators)

	return managedCertificateParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedCertificateParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedCertificateParameters_STATUS(gens map[string]gopter.Gen) {
	gens["ExpirationDate"] = gen.PtrOf(gen.AlphaString())
	gens["Subject"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_Secret_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Secret via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecret, SecretGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecret runs a test to see if a specific instance of Secret round trips to JSON and back losslessly
func RunJSONSerializationTestForSecret(subject Secret) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Secret
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Secret instances for property testing - lazily instantiated by SecretGenerator()
var secretGenerator gopter.Gen

// SecretGenerator returns a generator of Secret instances for property testing.
func SecretGenerator() gopter.Gen {
	if secretGenerator != nil {
		return secretGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSecret(generators)
	secretGenerator = gen.Struct(reflect.TypeOf(Secret{}), generators)

	return secretGenerator
}

// AddRelatedPropertyGeneratorsForSecret is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecret(gens map[string]gopter.Gen) {
	gens["Spec"] = Secret_SpecGenerator()
	gens["Status"] = Secret_STATUSGenerator()
}

func Test_SecretOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretOperatorSpec, SecretOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretOperatorSpec runs a test to see if a specific instance of SecretOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretOperatorSpec(subject SecretOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretOperatorSpec instances for property testing - lazily instantiated by SecretOperatorSpecGenerator()
var secretOperatorSpecGenerator gopter.Gen

// SecretOperatorSpecGenerator returns a generator of SecretOperatorSpec instances for property testing.
func SecretOperatorSpecGenerator() gopter.Gen {
	if secretOperatorSpecGenerator != nil {
		return secretOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	secretOperatorSpecGenerator = gen.Struct(reflect.TypeOf(SecretOperatorSpec{}), generators)

	return secretOperatorSpecGenerator
}

func Test_SecretParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretParameters, SecretParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretParameters runs a test to see if a specific instance of SecretParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretParameters(subject SecretParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretParameters instances for property testing - lazily instantiated by SecretParametersGenerator()
var secretParametersGenerator gopter.Gen

// SecretParametersGenerator returns a generator of SecretParameters instances for property testing.
func SecretParametersGenerator() gopter.Gen {
	if secretParametersGenerator != nil {
		return secretParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSecretParameters(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(SecretParameters{}), map[string]gopter.Gen{propName: propGen}))
	}
	secretParametersGenerator = gen.OneGenOf(gens...)

	return secretParametersGenerator
}

// AddRelatedPropertyGeneratorsForSecretParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecretParameters(gens map[string]gopter.Gen) {
	gens["AzureFirstPartyManagedCertificate"] = AzureFirstPartyManagedCertificateParametersGenerator().Map(func(it AzureFirstPartyManagedCertificateParameters) *AzureFirstPartyManagedCertificateParameters {
		return &it
	}) // generate one case for OneOf type
	gens["CustomerCertificate"] = CustomerCertificateParametersGenerator().Map(func(it CustomerCertificateParameters) *CustomerCertificateParameters {
		return &it
	}) // generate one case for OneOf type
	gens["ManagedCertificate"] = ManagedCertificateParametersGenerator().Map(func(it ManagedCertificateParameters) *ManagedCertificateParameters {
		return &it
	}) // generate one case for OneOf type
	gens["UrlSigningKey"] = UrlSigningKeyParametersGenerator().Map(func(it UrlSigningKeyParameters) *UrlSigningKeyParameters {
		return &it
	}) // generate one case for OneOf type
}

func Test_SecretParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SecretParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecretParameters_STATUS, SecretParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecretParameters_STATUS runs a test to see if a specific instance of SecretParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSecretParameters_STATUS(subject SecretParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SecretParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SecretParameters_STATUS instances for property testing - lazily instantiated by
// SecretParameters_STATUSGenerator()
var secretParameters_STATUSGenerator gopter.Gen

// SecretParameters_STATUSGenerator returns a generator of SecretParameters_STATUS instances for property testing.
func SecretParameters_STATUSGenerator() gopter.Gen {
	if secretParameters_STATUSGenerator != nil {
		return secretParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForSecretParameters_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(SecretParameters_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	secretParameters_STATUSGenerator = gen.OneGenOf(gens...)

	return secretParameters_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForSecretParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecretParameters_STATUS(gens map[string]gopter.Gen) {
	gens["AzureFirstPartyManagedCertificate"] = AzureFirstPartyManagedCertificateParameters_STATUSGenerator().Map(func(it AzureFirstPartyManagedCertificateParameters_STATUS) *AzureFirstPartyManagedCertificateParameters_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["CustomerCertificate"] = CustomerCertificateParameters_STATUSGenerator().Map(func(it CustomerCertificateParameters_STATUS) *CustomerCertificateParameters_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["ManagedCertificate"] = ManagedCertificateParameters_STATUSGenerator().Map(func(it ManagedCertificateParameters_STATUS) *ManagedCertificateParameters_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["UrlSigningKey"] = UrlSigningKeyParameters_STATUSGenerator().Map(func(it UrlSigningKeyParameters_STATUS) *UrlSigningKeyParameters_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_Secret_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Secret_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecret_STATUS, Secret_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecret_STATUS runs a test to see if a specific instance of Secret_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSecret_STATUS(subject Secret_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Secret_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Secret_STATUS instances for property testing - lazily instantiated by Secret_STATUSGenerator()
var secret_STATUSGenerator gopter.Gen

// Secret_STATUSGenerator returns a generator of Secret_STATUS instances for property testing.
// We first initialize secret_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Secret_STATUSGenerator() gopter.Gen {
	if secret_STATUSGenerator != nil {
		return secret_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecret_STATUS(generators)
	secret_STATUSGenerator = gen.Struct(reflect.TypeOf(Secret_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecret_STATUS(generators)
	AddRelatedPropertyGeneratorsForSecret_STATUS(generators)
	secret_STATUSGenerator = gen.Struct(reflect.TypeOf(Secret_STATUS{}), generators)

	return secret_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSecret_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecret_STATUS(gens map[string]gopter.Gen) {
	gens["DeploymentStatus"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProfileName"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForSecret_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecret_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(SecretParameters_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_Secret_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Secret_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSecret_Spec, Secret_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSecret_Spec runs a test to see if a specific instance of Secret_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSecret_Spec(subject Secret_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Secret_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Secret_Spec instances for property testing - lazily instantiated by Secret_SpecGenerator()
var secret_SpecGenerator gopter.Gen

// Secret_SpecGenerator returns a generator of Secret_Spec instances for property testing.
// We first initialize secret_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Secret_SpecGenerator() gopter.Gen {
	if secret_SpecGenerator != nil {
		return secret_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecret_Spec(generators)
	secret_SpecGenerator = gen.Struct(reflect.TypeOf(Secret_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSecret_Spec(generators)
	AddRelatedPropertyGeneratorsForSecret_Spec(generators)
	secret_SpecGenerator = gen.Struct(reflect.TypeOf(Secret_Spec{}), generators)

	return secret_SpecGenerator
}

// AddIndependentPropertyGeneratorsForSecret_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSecret_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["OriginalVersion"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForSecret_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForSecret_Spec(gens map[string]gopter.Gen) {
	gens["OperatorSpec"] = gen.PtrOf(SecretOperatorSpecGenerator())
	gens["Parameters"] = gen.PtrOf(SecretParametersGenerator())
}

func Test_UrlSigningKeyParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningKeyParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningKeyParameters, UrlSigningKeyParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningKeyParameters runs a test to see if a specific instance of UrlSigningKeyParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningKeyParameters(subject UrlSigningKeyParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningKeyParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningKeyParameters instances for property testing - lazily instantiated by
// UrlSigningKeyParametersGenerator()
var urlSigningKeyParametersGenerator gopter.Gen

// UrlSigningKeyParametersGenerator returns a generator of UrlSigningKeyParameters instances for property testing.
// We first initialize urlSigningKeyParametersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningKeyParametersGenerator() gopter.Gen {
	if urlSigningKeyParametersGenerator != nil {
		return urlSigningKeyParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKeyParameters(generators)
	urlSigningKeyParametersGenerator = gen.Struct(reflect.TypeOf(UrlSigningKeyParameters{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKeyParameters(generators)
	AddRelatedPropertyGeneratorsForUrlSigningKeyParameters(generators)
	urlSigningKeyParametersGenerator = gen.Struct(reflect.TypeOf(UrlSigningKeyParameters{}), generators)

	return urlSigningKeyParametersGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningKeyParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningKeyParameters(gens map[string]gopter.Gen) {
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
	gens["SecretVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUrlSigningKeyParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningKeyParameters(gens map[string]gopter.Gen) {
	gens["SecretSource"] = gen.PtrOf(ResourceReferenceGenerator())
}

func Test_UrlSigningKeyParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningKeyParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningKeyParameters_STATUS, UrlSigningKeyParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningKeyParameters_STATUS runs a test to see if a specific instance of UrlSigningKeyParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningKeyParameters_STATUS(subject UrlSigningKeyParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningKeyParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningKeyParameters_STATUS instances for property testing - lazily instantiated by
// UrlSigningKeyParameters_STATUSGenerator()
var urlSigningKeyParameters_STATUSGenerator gopter.Gen

// UrlSigningKeyParameters_STATUSGenerator returns a generator of UrlSigningKeyParameters_STATUS instances for property testing.
// We first initialize urlSigningKeyParameters_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningKeyParameters_STATUSGenerator() gopter.Gen {
	if urlSigningKeyParameters_STATUSGenerator != nil {
		return urlSigningKeyParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKeyParameters_STATUS(generators)
	urlSigningKeyParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlSigningKeyParameters_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKeyParameters_STATUS(generators)
	AddRelatedPropertyGeneratorsForUrlSigningKeyParameters_STATUS(generators)
	urlSigningKeyParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlSigningKeyParameters_STATUS{}), generators)

	return urlSigningKeyParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningKeyParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningKeyParameters_STATUS(gens map[string]gopter.Gen) {
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
	gens["SecretVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUrlSigningKeyParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningKeyParameters_STATUS(gens map[string]gopter.Gen) {
	gens["SecretSource"] = gen.PtrOf(ResourceReference_STATUSGenerator())
}
