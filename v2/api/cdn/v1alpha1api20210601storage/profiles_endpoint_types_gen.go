// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210601storage

import (
	"fmt"
	v20210601s "github.com/Azure/azure-service-operator/v2/api/cdn/v1beta20210601storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1alpha1api20210601.ProfilesEndpoint
// Deprecated version of ProfilesEndpoint. Use v1beta20210601.ProfilesEndpoint instead
type ProfilesEndpoint struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ProfilesEndpoints_Spec `json:"spec,omitempty"`
	Status            Endpoint_Status        `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ProfilesEndpoint{}

// GetConditions returns the conditions of the resource
func (endpoint *ProfilesEndpoint) GetConditions() conditions.Conditions {
	return endpoint.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (endpoint *ProfilesEndpoint) SetConditions(conditions conditions.Conditions) {
	endpoint.Status.Conditions = conditions
}

var _ conversion.Convertible = &ProfilesEndpoint{}

// ConvertFrom populates our ProfilesEndpoint from the provided hub ProfilesEndpoint
func (endpoint *ProfilesEndpoint) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20210601s.ProfilesEndpoint)
	if !ok {
		return fmt.Errorf("expected cdn/v1beta20210601storage/ProfilesEndpoint but received %T instead", hub)
	}

	return endpoint.AssignPropertiesFromProfilesEndpoint(source)
}

// ConvertTo populates the provided hub ProfilesEndpoint from our ProfilesEndpoint
func (endpoint *ProfilesEndpoint) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20210601s.ProfilesEndpoint)
	if !ok {
		return fmt.Errorf("expected cdn/v1beta20210601storage/ProfilesEndpoint but received %T instead", hub)
	}

	return endpoint.AssignPropertiesToProfilesEndpoint(destination)
}

var _ genruntime.KubernetesResource = &ProfilesEndpoint{}

// AzureName returns the Azure name of the resource
func (endpoint *ProfilesEndpoint) AzureName() string {
	return endpoint.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-06-01"
func (endpoint ProfilesEndpoint) GetAPIVersion() string {
	return "2021-06-01"
}

// GetResourceKind returns the kind of the resource
func (endpoint *ProfilesEndpoint) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (endpoint *ProfilesEndpoint) GetSpec() genruntime.ConvertibleSpec {
	return &endpoint.Spec
}

// GetStatus returns the status of this resource
func (endpoint *ProfilesEndpoint) GetStatus() genruntime.ConvertibleStatus {
	return &endpoint.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Cdn/profiles/endpoints"
func (endpoint *ProfilesEndpoint) GetType() string {
	return "Microsoft.Cdn/profiles/endpoints"
}

// NewEmptyStatus returns a new empty (blank) status
func (endpoint *ProfilesEndpoint) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Endpoint_Status{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (endpoint *ProfilesEndpoint) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(endpoint.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  endpoint.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (endpoint *ProfilesEndpoint) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Endpoint_Status); ok {
		endpoint.Status = *st
		return nil
	}

	// Convert status to required version
	var st Endpoint_Status
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	endpoint.Status = st
	return nil
}

// AssignPropertiesFromProfilesEndpoint populates our ProfilesEndpoint from the provided source ProfilesEndpoint
func (endpoint *ProfilesEndpoint) AssignPropertiesFromProfilesEndpoint(source *v20210601s.ProfilesEndpoint) error {

	// ObjectMeta
	endpoint.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ProfilesEndpoints_Spec
	err := spec.AssignPropertiesFromProfilesEndpointsSpec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromProfilesEndpointsSpec() to populate field Spec")
	}
	endpoint.Spec = spec

	// Status
	var status Endpoint_Status
	err = status.AssignPropertiesFromEndpointStatus(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromEndpointStatus() to populate field Status")
	}
	endpoint.Status = status

	// No error
	return nil
}

// AssignPropertiesToProfilesEndpoint populates the provided destination ProfilesEndpoint from our ProfilesEndpoint
func (endpoint *ProfilesEndpoint) AssignPropertiesToProfilesEndpoint(destination *v20210601s.ProfilesEndpoint) error {

	// ObjectMeta
	destination.ObjectMeta = *endpoint.ObjectMeta.DeepCopy()

	// Spec
	var spec v20210601s.ProfilesEndpoints_Spec
	err := endpoint.Spec.AssignPropertiesToProfilesEndpointsSpec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToProfilesEndpointsSpec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20210601s.Endpoint_Status
	err = endpoint.Status.AssignPropertiesToEndpointStatus(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToEndpointStatus() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (endpoint *ProfilesEndpoint) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: endpoint.Spec.OriginalVersion,
		Kind:    "ProfilesEndpoint",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1alpha1api20210601.ProfilesEndpoint
// Deprecated version of ProfilesEndpoint. Use v1beta20210601.ProfilesEndpoint instead
type ProfilesEndpointList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProfilesEndpoint `json:"items"`
}

// Storage version of v1alpha1api20210601.Endpoint_Status
// Deprecated version of Endpoint_Status. Use v1beta20210601.Endpoint_Status instead
type Endpoint_Status struct {
	Conditions                       []conditions.Condition                                      `json:"conditions,omitempty"`
	ContentTypesToCompress           []string                                                    `json:"contentTypesToCompress,omitempty"`
	CustomDomains                    []CustomDomain_Status_SubResourceEmbedded                   `json:"customDomains,omitempty"`
	DefaultOriginGroup               *ResourceReference_Status                                   `json:"defaultOriginGroup,omitempty"`
	DeliveryPolicy                   *EndpointProperties_Status_DeliveryPolicy                   `json:"deliveryPolicy,omitempty"`
	GeoFilters                       []GeoFilter_Status                                          `json:"geoFilters,omitempty"`
	HostName                         *string                                                     `json:"hostName,omitempty"`
	Id                               *string                                                     `json:"id,omitempty"`
	IsCompressionEnabled             *bool                                                       `json:"isCompressionEnabled,omitempty"`
	IsHttpAllowed                    *bool                                                       `json:"isHttpAllowed,omitempty"`
	IsHttpsAllowed                   *bool                                                       `json:"isHttpsAllowed,omitempty"`
	Location                         *string                                                     `json:"location,omitempty"`
	Name                             *string                                                     `json:"name,omitempty"`
	OptimizationType                 *string                                                     `json:"optimizationType,omitempty"`
	OriginGroups                     []DeepCreatedOriginGroup_Status                             `json:"originGroups,omitempty"`
	OriginHostHeader                 *string                                                     `json:"originHostHeader,omitempty"`
	OriginPath                       *string                                                     `json:"originPath,omitempty"`
	Origins                          []DeepCreatedOrigin_Status                                  `json:"origins,omitempty"`
	ProbePath                        *string                                                     `json:"probePath,omitempty"`
	PropertyBag                      genruntime.PropertyBag                                      `json:"$propertyBag,omitempty"`
	ProvisioningState                *string                                                     `json:"provisioningState,omitempty"`
	QueryStringCachingBehavior       *string                                                     `json:"queryStringCachingBehavior,omitempty"`
	ResourceState                    *string                                                     `json:"resourceState,omitempty"`
	SystemData                       *SystemData_Status                                          `json:"systemData,omitempty"`
	Tags                             map[string]string                                           `json:"tags,omitempty"`
	Type                             *string                                                     `json:"type,omitempty"`
	UrlSigningKeys                   []UrlSigningKey_Status                                      `json:"urlSigningKeys,omitempty"`
	WebApplicationFirewallPolicyLink *EndpointProperties_Status_WebApplicationFirewallPolicyLink `json:"webApplicationFirewallPolicyLink,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Endpoint_Status{}

// ConvertStatusFrom populates our Endpoint_Status from the provided source
func (endpoint *Endpoint_Status) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20210601s.Endpoint_Status)
	if ok {
		// Populate our instance from source
		return endpoint.AssignPropertiesFromEndpointStatus(src)
	}

	// Convert to an intermediate form
	src = &v20210601s.Endpoint_Status{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignPropertiesFromEndpointStatus(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Endpoint_Status
func (endpoint *Endpoint_Status) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20210601s.Endpoint_Status)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignPropertiesToEndpointStatus(dst)
	}

	// Convert to an intermediate form
	dst = &v20210601s.Endpoint_Status{}
	err := endpoint.AssignPropertiesToEndpointStatus(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

// AssignPropertiesFromEndpointStatus populates our Endpoint_Status from the provided source Endpoint_Status
func (endpoint *Endpoint_Status) AssignPropertiesFromEndpointStatus(source *v20210601s.Endpoint_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Conditions
	endpoint.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// ContentTypesToCompress
	endpoint.ContentTypesToCompress = genruntime.CloneSliceOfString(source.ContentTypesToCompress)

	// CustomDomains
	if source.CustomDomains != nil {
		customDomainList := make([]CustomDomain_Status_SubResourceEmbedded, len(source.CustomDomains))
		for customDomainIndex, customDomainItem := range source.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain CustomDomain_Status_SubResourceEmbedded
			err := customDomain.AssignPropertiesFromCustomDomainStatusSubResourceEmbedded(&customDomainItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromCustomDomainStatusSubResourceEmbedded() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		endpoint.CustomDomains = customDomainList
	} else {
		endpoint.CustomDomains = nil
	}

	// DefaultOriginGroup
	if source.DefaultOriginGroup != nil {
		var defaultOriginGroup ResourceReference_Status
		err := defaultOriginGroup.AssignPropertiesFromResourceReferenceStatus(source.DefaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceReferenceStatus() to populate field DefaultOriginGroup")
		}
		endpoint.DefaultOriginGroup = &defaultOriginGroup
	} else {
		endpoint.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if source.DeliveryPolicy != nil {
		var deliveryPolicy EndpointProperties_Status_DeliveryPolicy
		err := deliveryPolicy.AssignPropertiesFromEndpointPropertiesStatusDeliveryPolicy(source.DeliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromEndpointPropertiesStatusDeliveryPolicy() to populate field DeliveryPolicy")
		}
		endpoint.DeliveryPolicy = &deliveryPolicy
	} else {
		endpoint.DeliveryPolicy = nil
	}

	// GeoFilters
	if source.GeoFilters != nil {
		geoFilterList := make([]GeoFilter_Status, len(source.GeoFilters))
		for geoFilterIndex, geoFilterItem := range source.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter GeoFilter_Status
			err := geoFilter.AssignPropertiesFromGeoFilterStatus(&geoFilterItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromGeoFilterStatus() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		endpoint.GeoFilters = geoFilterList
	} else {
		endpoint.GeoFilters = nil
	}

	// HostName
	endpoint.HostName = genruntime.ClonePointerToString(source.HostName)

	// Id
	endpoint.Id = genruntime.ClonePointerToString(source.Id)

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := *source.IsCompressionEnabled
		endpoint.IsCompressionEnabled = &isCompressionEnabled
	} else {
		endpoint.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if source.IsHttpAllowed != nil {
		isHttpAllowed := *source.IsHttpAllowed
		endpoint.IsHttpAllowed = &isHttpAllowed
	} else {
		endpoint.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if source.IsHttpsAllowed != nil {
		isHttpsAllowed := *source.IsHttpsAllowed
		endpoint.IsHttpsAllowed = &isHttpsAllowed
	} else {
		endpoint.IsHttpsAllowed = nil
	}

	// Location
	endpoint.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	endpoint.Name = genruntime.ClonePointerToString(source.Name)

	// OptimizationType
	endpoint.OptimizationType = genruntime.ClonePointerToString(source.OptimizationType)

	// OriginGroups
	if source.OriginGroups != nil {
		originGroupList := make([]DeepCreatedOriginGroup_Status, len(source.OriginGroups))
		for originGroupIndex, originGroupItem := range source.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup DeepCreatedOriginGroup_Status
			err := originGroup.AssignPropertiesFromDeepCreatedOriginGroupStatus(&originGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeepCreatedOriginGroupStatus() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		endpoint.OriginGroups = originGroupList
	} else {
		endpoint.OriginGroups = nil
	}

	// OriginHostHeader
	endpoint.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// OriginPath
	endpoint.OriginPath = genruntime.ClonePointerToString(source.OriginPath)

	// Origins
	if source.Origins != nil {
		originList := make([]DeepCreatedOrigin_Status, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin DeepCreatedOrigin_Status
			err := origin.AssignPropertiesFromDeepCreatedOriginStatus(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeepCreatedOriginStatus() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		endpoint.Origins = originList
	} else {
		endpoint.Origins = nil
	}

	// ProbePath
	endpoint.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProvisioningState
	endpoint.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// QueryStringCachingBehavior
	endpoint.QueryStringCachingBehavior = genruntime.ClonePointerToString(source.QueryStringCachingBehavior)

	// ResourceState
	endpoint.ResourceState = genruntime.ClonePointerToString(source.ResourceState)

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_Status
		err := systemDatum.AssignPropertiesFromSystemDataStatus(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSystemDataStatus() to populate field SystemData")
		}
		endpoint.SystemData = &systemDatum
	} else {
		endpoint.SystemData = nil
	}

	// Tags
	endpoint.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// UrlSigningKeys
	if source.UrlSigningKeys != nil {
		urlSigningKeyList := make([]UrlSigningKey_Status, len(source.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range source.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey UrlSigningKey_Status
			err := urlSigningKey.AssignPropertiesFromUrlSigningKeyStatus(&urlSigningKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromUrlSigningKeyStatus() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		endpoint.UrlSigningKeys = urlSigningKeyList
	} else {
		endpoint.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if source.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink EndpointProperties_Status_WebApplicationFirewallPolicyLink
		err := webApplicationFirewallPolicyLink.AssignPropertiesFromEndpointPropertiesStatusWebApplicationFirewallPolicyLink(source.WebApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromEndpointPropertiesStatusWebApplicationFirewallPolicyLink() to populate field WebApplicationFirewallPolicyLink")
		}
		endpoint.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		endpoint.WebApplicationFirewallPolicyLink = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		endpoint.PropertyBag = propertyBag
	} else {
		endpoint.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEndpointStatus populates the provided destination Endpoint_Status from our Endpoint_Status
func (endpoint *Endpoint_Status) AssignPropertiesToEndpointStatus(destination *v20210601s.Endpoint_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(endpoint.PropertyBag)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(endpoint.Conditions)

	// ContentTypesToCompress
	destination.ContentTypesToCompress = genruntime.CloneSliceOfString(endpoint.ContentTypesToCompress)

	// CustomDomains
	if endpoint.CustomDomains != nil {
		customDomainList := make([]v20210601s.CustomDomain_Status_SubResourceEmbedded, len(endpoint.CustomDomains))
		for customDomainIndex, customDomainItem := range endpoint.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain v20210601s.CustomDomain_Status_SubResourceEmbedded
			err := customDomainItem.AssignPropertiesToCustomDomainStatusSubResourceEmbedded(&customDomain)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToCustomDomainStatusSubResourceEmbedded() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		destination.CustomDomains = customDomainList
	} else {
		destination.CustomDomains = nil
	}

	// DefaultOriginGroup
	if endpoint.DefaultOriginGroup != nil {
		var defaultOriginGroup v20210601s.ResourceReference_Status
		err := endpoint.DefaultOriginGroup.AssignPropertiesToResourceReferenceStatus(&defaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceReferenceStatus() to populate field DefaultOriginGroup")
		}
		destination.DefaultOriginGroup = &defaultOriginGroup
	} else {
		destination.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if endpoint.DeliveryPolicy != nil {
		var deliveryPolicy v20210601s.EndpointProperties_Status_DeliveryPolicy
		err := endpoint.DeliveryPolicy.AssignPropertiesToEndpointPropertiesStatusDeliveryPolicy(&deliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToEndpointPropertiesStatusDeliveryPolicy() to populate field DeliveryPolicy")
		}
		destination.DeliveryPolicy = &deliveryPolicy
	} else {
		destination.DeliveryPolicy = nil
	}

	// GeoFilters
	if endpoint.GeoFilters != nil {
		geoFilterList := make([]v20210601s.GeoFilter_Status, len(endpoint.GeoFilters))
		for geoFilterIndex, geoFilterItem := range endpoint.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter v20210601s.GeoFilter_Status
			err := geoFilterItem.AssignPropertiesToGeoFilterStatus(&geoFilter)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToGeoFilterStatus() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		destination.GeoFilters = geoFilterList
	} else {
		destination.GeoFilters = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(endpoint.HostName)

	// Id
	destination.Id = genruntime.ClonePointerToString(endpoint.Id)

	// IsCompressionEnabled
	if endpoint.IsCompressionEnabled != nil {
		isCompressionEnabled := *endpoint.IsCompressionEnabled
		destination.IsCompressionEnabled = &isCompressionEnabled
	} else {
		destination.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if endpoint.IsHttpAllowed != nil {
		isHttpAllowed := *endpoint.IsHttpAllowed
		destination.IsHttpAllowed = &isHttpAllowed
	} else {
		destination.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if endpoint.IsHttpsAllowed != nil {
		isHttpsAllowed := *endpoint.IsHttpsAllowed
		destination.IsHttpsAllowed = &isHttpsAllowed
	} else {
		destination.IsHttpsAllowed = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(endpoint.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(endpoint.Name)

	// OptimizationType
	destination.OptimizationType = genruntime.ClonePointerToString(endpoint.OptimizationType)

	// OriginGroups
	if endpoint.OriginGroups != nil {
		originGroupList := make([]v20210601s.DeepCreatedOriginGroup_Status, len(endpoint.OriginGroups))
		for originGroupIndex, originGroupItem := range endpoint.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup v20210601s.DeepCreatedOriginGroup_Status
			err := originGroupItem.AssignPropertiesToDeepCreatedOriginGroupStatus(&originGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeepCreatedOriginGroupStatus() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		destination.OriginGroups = originGroupList
	} else {
		destination.OriginGroups = nil
	}

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(endpoint.OriginHostHeader)

	// OriginPath
	destination.OriginPath = genruntime.ClonePointerToString(endpoint.OriginPath)

	// Origins
	if endpoint.Origins != nil {
		originList := make([]v20210601s.DeepCreatedOrigin_Status, len(endpoint.Origins))
		for originIndex, originItem := range endpoint.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin v20210601s.DeepCreatedOrigin_Status
			err := originItem.AssignPropertiesToDeepCreatedOriginStatus(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeepCreatedOriginStatus() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(endpoint.ProbePath)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(endpoint.ProvisioningState)

	// QueryStringCachingBehavior
	destination.QueryStringCachingBehavior = genruntime.ClonePointerToString(endpoint.QueryStringCachingBehavior)

	// ResourceState
	destination.ResourceState = genruntime.ClonePointerToString(endpoint.ResourceState)

	// SystemData
	if endpoint.SystemData != nil {
		var systemDatum v20210601s.SystemData_Status
		err := endpoint.SystemData.AssignPropertiesToSystemDataStatus(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSystemDataStatus() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(endpoint.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(endpoint.Type)

	// UrlSigningKeys
	if endpoint.UrlSigningKeys != nil {
		urlSigningKeyList := make([]v20210601s.UrlSigningKey_Status, len(endpoint.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range endpoint.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey v20210601s.UrlSigningKey_Status
			err := urlSigningKeyItem.AssignPropertiesToUrlSigningKeyStatus(&urlSigningKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToUrlSigningKeyStatus() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		destination.UrlSigningKeys = urlSigningKeyList
	} else {
		destination.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if endpoint.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink v20210601s.EndpointProperties_Status_WebApplicationFirewallPolicyLink
		err := endpoint.WebApplicationFirewallPolicyLink.AssignPropertiesToEndpointPropertiesStatusWebApplicationFirewallPolicyLink(&webApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToEndpointPropertiesStatusWebApplicationFirewallPolicyLink() to populate field WebApplicationFirewallPolicyLink")
		}
		destination.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		destination.WebApplicationFirewallPolicyLink = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.ProfilesEndpoints_Spec
type ProfilesEndpoints_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName              string                                            `json:"azureName,omitempty"`
	ContentTypesToCompress []string                                          `json:"contentTypesToCompress,omitempty"`
	DefaultOriginGroup     *ResourceReference                                `json:"defaultOriginGroup,omitempty"`
	DeliveryPolicy         *EndpointPropertiesUpdateParametersDeliveryPolicy `json:"deliveryPolicy,omitempty"`
	GeoFilters             []GeoFilter                                       `json:"geoFilters,omitempty"`
	IsCompressionEnabled   *bool                                             `json:"isCompressionEnabled,omitempty"`
	IsHttpAllowed          *bool                                             `json:"isHttpAllowed,omitempty"`
	IsHttpsAllowed         *bool                                             `json:"isHttpsAllowed,omitempty"`
	Location               *string                                           `json:"location,omitempty"`
	OptimizationType       *string                                           `json:"optimizationType,omitempty"`
	OriginGroups           []ProfilesEndpoints_Spec_Properties_OriginGroups  `json:"originGroups,omitempty"`
	OriginHostHeader       *string                                           `json:"originHostHeader,omitempty"`
	OriginPath             *string                                           `json:"originPath,omitempty"`
	OriginalVersion        string                                            `json:"originalVersion,omitempty"`
	Origins                []ProfilesEndpoints_Spec_Properties_Origins       `json:"origins,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a cdn.azure.com/Profile resource
	Owner                            *genruntime.KnownResourceReference                                  `group:"cdn.azure.com" json:"owner,omitempty" kind:"Profile"`
	ProbePath                        *string                                                             `json:"probePath,omitempty"`
	PropertyBag                      genruntime.PropertyBag                                              `json:"$propertyBag,omitempty"`
	QueryStringCachingBehavior       *string                                                             `json:"queryStringCachingBehavior,omitempty"`
	Tags                             map[string]string                                                   `json:"tags,omitempty"`
	UrlSigningKeys                   []UrlSigningKey                                                     `json:"urlSigningKeys,omitempty"`
	WebApplicationFirewallPolicyLink *EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink `json:"webApplicationFirewallPolicyLink,omitempty"`
}

var _ genruntime.ConvertibleSpec = &ProfilesEndpoints_Spec{}

// ConvertSpecFrom populates our ProfilesEndpoints_Spec from the provided source
func (endpoints *ProfilesEndpoints_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20210601s.ProfilesEndpoints_Spec)
	if ok {
		// Populate our instance from source
		return endpoints.AssignPropertiesFromProfilesEndpointsSpec(src)
	}

	// Convert to an intermediate form
	src = &v20210601s.ProfilesEndpoints_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = endpoints.AssignPropertiesFromProfilesEndpointsSpec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ProfilesEndpoints_Spec
func (endpoints *ProfilesEndpoints_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20210601s.ProfilesEndpoints_Spec)
	if ok {
		// Populate destination from our instance
		return endpoints.AssignPropertiesToProfilesEndpointsSpec(dst)
	}

	// Convert to an intermediate form
	dst = &v20210601s.ProfilesEndpoints_Spec{}
	err := endpoints.AssignPropertiesToProfilesEndpointsSpec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromProfilesEndpointsSpec populates our ProfilesEndpoints_Spec from the provided source ProfilesEndpoints_Spec
func (endpoints *ProfilesEndpoints_Spec) AssignPropertiesFromProfilesEndpointsSpec(source *v20210601s.ProfilesEndpoints_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureName
	endpoints.AzureName = source.AzureName

	// ContentTypesToCompress
	endpoints.ContentTypesToCompress = genruntime.CloneSliceOfString(source.ContentTypesToCompress)

	// DefaultOriginGroup
	if source.DefaultOriginGroup != nil {
		var defaultOriginGroup ResourceReference
		err := defaultOriginGroup.AssignPropertiesFromResourceReference(source.DefaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceReference() to populate field DefaultOriginGroup")
		}
		endpoints.DefaultOriginGroup = &defaultOriginGroup
	} else {
		endpoints.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if source.DeliveryPolicy != nil {
		var deliveryPolicy EndpointPropertiesUpdateParametersDeliveryPolicy
		err := deliveryPolicy.AssignPropertiesFromEndpointPropertiesUpdateParametersDeliveryPolicy(source.DeliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromEndpointPropertiesUpdateParametersDeliveryPolicy() to populate field DeliveryPolicy")
		}
		endpoints.DeliveryPolicy = &deliveryPolicy
	} else {
		endpoints.DeliveryPolicy = nil
	}

	// GeoFilters
	if source.GeoFilters != nil {
		geoFilterList := make([]GeoFilter, len(source.GeoFilters))
		for geoFilterIndex, geoFilterItem := range source.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter GeoFilter
			err := geoFilter.AssignPropertiesFromGeoFilter(&geoFilterItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromGeoFilter() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		endpoints.GeoFilters = geoFilterList
	} else {
		endpoints.GeoFilters = nil
	}

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := *source.IsCompressionEnabled
		endpoints.IsCompressionEnabled = &isCompressionEnabled
	} else {
		endpoints.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if source.IsHttpAllowed != nil {
		isHttpAllowed := *source.IsHttpAllowed
		endpoints.IsHttpAllowed = &isHttpAllowed
	} else {
		endpoints.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if source.IsHttpsAllowed != nil {
		isHttpsAllowed := *source.IsHttpsAllowed
		endpoints.IsHttpsAllowed = &isHttpsAllowed
	} else {
		endpoints.IsHttpsAllowed = nil
	}

	// Location
	endpoints.Location = genruntime.ClonePointerToString(source.Location)

	// OptimizationType
	endpoints.OptimizationType = genruntime.ClonePointerToString(source.OptimizationType)

	// OriginGroups
	if source.OriginGroups != nil {
		originGroupList := make([]ProfilesEndpoints_Spec_Properties_OriginGroups, len(source.OriginGroups))
		for originGroupIndex, originGroupItem := range source.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup ProfilesEndpoints_Spec_Properties_OriginGroups
			err := originGroup.AssignPropertiesFromProfilesEndpointsSpecPropertiesOriginGroups(&originGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromProfilesEndpointsSpecPropertiesOriginGroups() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		endpoints.OriginGroups = originGroupList
	} else {
		endpoints.OriginGroups = nil
	}

	// OriginHostHeader
	endpoints.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// OriginPath
	endpoints.OriginPath = genruntime.ClonePointerToString(source.OriginPath)

	// OriginalVersion
	endpoints.OriginalVersion = source.OriginalVersion

	// Origins
	if source.Origins != nil {
		originList := make([]ProfilesEndpoints_Spec_Properties_Origins, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin ProfilesEndpoints_Spec_Properties_Origins
			err := origin.AssignPropertiesFromProfilesEndpointsSpecPropertiesOrigins(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromProfilesEndpointsSpecPropertiesOrigins() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		endpoints.Origins = originList
	} else {
		endpoints.Origins = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		endpoints.Owner = &owner
	} else {
		endpoints.Owner = nil
	}

	// ProbePath
	endpoints.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// QueryStringCachingBehavior
	endpoints.QueryStringCachingBehavior = genruntime.ClonePointerToString(source.QueryStringCachingBehavior)

	// Tags
	endpoints.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UrlSigningKeys
	if source.UrlSigningKeys != nil {
		urlSigningKeyList := make([]UrlSigningKey, len(source.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range source.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey UrlSigningKey
			err := urlSigningKey.AssignPropertiesFromUrlSigningKey(&urlSigningKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromUrlSigningKey() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		endpoints.UrlSigningKeys = urlSigningKeyList
	} else {
		endpoints.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if source.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink
		err := webApplicationFirewallPolicyLink.AssignPropertiesFromEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink(source.WebApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink() to populate field WebApplicationFirewallPolicyLink")
		}
		endpoints.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		endpoints.WebApplicationFirewallPolicyLink = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		endpoints.PropertyBag = propertyBag
	} else {
		endpoints.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToProfilesEndpointsSpec populates the provided destination ProfilesEndpoints_Spec from our ProfilesEndpoints_Spec
func (endpoints *ProfilesEndpoints_Spec) AssignPropertiesToProfilesEndpointsSpec(destination *v20210601s.ProfilesEndpoints_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(endpoints.PropertyBag)

	// AzureName
	destination.AzureName = endpoints.AzureName

	// ContentTypesToCompress
	destination.ContentTypesToCompress = genruntime.CloneSliceOfString(endpoints.ContentTypesToCompress)

	// DefaultOriginGroup
	if endpoints.DefaultOriginGroup != nil {
		var defaultOriginGroup v20210601s.ResourceReference
		err := endpoints.DefaultOriginGroup.AssignPropertiesToResourceReference(&defaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceReference() to populate field DefaultOriginGroup")
		}
		destination.DefaultOriginGroup = &defaultOriginGroup
	} else {
		destination.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if endpoints.DeliveryPolicy != nil {
		var deliveryPolicy v20210601s.EndpointPropertiesUpdateParametersDeliveryPolicy
		err := endpoints.DeliveryPolicy.AssignPropertiesToEndpointPropertiesUpdateParametersDeliveryPolicy(&deliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToEndpointPropertiesUpdateParametersDeliveryPolicy() to populate field DeliveryPolicy")
		}
		destination.DeliveryPolicy = &deliveryPolicy
	} else {
		destination.DeliveryPolicy = nil
	}

	// GeoFilters
	if endpoints.GeoFilters != nil {
		geoFilterList := make([]v20210601s.GeoFilter, len(endpoints.GeoFilters))
		for geoFilterIndex, geoFilterItem := range endpoints.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter v20210601s.GeoFilter
			err := geoFilterItem.AssignPropertiesToGeoFilter(&geoFilter)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToGeoFilter() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		destination.GeoFilters = geoFilterList
	} else {
		destination.GeoFilters = nil
	}

	// IsCompressionEnabled
	if endpoints.IsCompressionEnabled != nil {
		isCompressionEnabled := *endpoints.IsCompressionEnabled
		destination.IsCompressionEnabled = &isCompressionEnabled
	} else {
		destination.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if endpoints.IsHttpAllowed != nil {
		isHttpAllowed := *endpoints.IsHttpAllowed
		destination.IsHttpAllowed = &isHttpAllowed
	} else {
		destination.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if endpoints.IsHttpsAllowed != nil {
		isHttpsAllowed := *endpoints.IsHttpsAllowed
		destination.IsHttpsAllowed = &isHttpsAllowed
	} else {
		destination.IsHttpsAllowed = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(endpoints.Location)

	// OptimizationType
	destination.OptimizationType = genruntime.ClonePointerToString(endpoints.OptimizationType)

	// OriginGroups
	if endpoints.OriginGroups != nil {
		originGroupList := make([]v20210601s.ProfilesEndpoints_Spec_Properties_OriginGroups, len(endpoints.OriginGroups))
		for originGroupIndex, originGroupItem := range endpoints.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup v20210601s.ProfilesEndpoints_Spec_Properties_OriginGroups
			err := originGroupItem.AssignPropertiesToProfilesEndpointsSpecPropertiesOriginGroups(&originGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToProfilesEndpointsSpecPropertiesOriginGroups() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		destination.OriginGroups = originGroupList
	} else {
		destination.OriginGroups = nil
	}

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(endpoints.OriginHostHeader)

	// OriginPath
	destination.OriginPath = genruntime.ClonePointerToString(endpoints.OriginPath)

	// OriginalVersion
	destination.OriginalVersion = endpoints.OriginalVersion

	// Origins
	if endpoints.Origins != nil {
		originList := make([]v20210601s.ProfilesEndpoints_Spec_Properties_Origins, len(endpoints.Origins))
		for originIndex, originItem := range endpoints.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin v20210601s.ProfilesEndpoints_Spec_Properties_Origins
			err := originItem.AssignPropertiesToProfilesEndpointsSpecPropertiesOrigins(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToProfilesEndpointsSpecPropertiesOrigins() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// Owner
	if endpoints.Owner != nil {
		owner := endpoints.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(endpoints.ProbePath)

	// QueryStringCachingBehavior
	destination.QueryStringCachingBehavior = genruntime.ClonePointerToString(endpoints.QueryStringCachingBehavior)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(endpoints.Tags)

	// UrlSigningKeys
	if endpoints.UrlSigningKeys != nil {
		urlSigningKeyList := make([]v20210601s.UrlSigningKey, len(endpoints.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range endpoints.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey v20210601s.UrlSigningKey
			err := urlSigningKeyItem.AssignPropertiesToUrlSigningKey(&urlSigningKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToUrlSigningKey() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		destination.UrlSigningKeys = urlSigningKeyList
	} else {
		destination.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if endpoints.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink v20210601s.EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink
		err := endpoints.WebApplicationFirewallPolicyLink.AssignPropertiesToEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink(&webApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink() to populate field WebApplicationFirewallPolicyLink")
		}
		destination.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		destination.WebApplicationFirewallPolicyLink = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.CustomDomain_Status_SubResourceEmbedded
// Deprecated version of CustomDomain_Status_SubResourceEmbedded. Use v1beta20210601.CustomDomain_Status_SubResourceEmbedded instead
type CustomDomain_Status_SubResourceEmbedded struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SystemData  *SystemData_Status     `json:"systemData,omitempty"`
}

// AssignPropertiesFromCustomDomainStatusSubResourceEmbedded populates our CustomDomain_Status_SubResourceEmbedded from the provided source CustomDomain_Status_SubResourceEmbedded
func (embedded *CustomDomain_Status_SubResourceEmbedded) AssignPropertiesFromCustomDomainStatusSubResourceEmbedded(source *v20210601s.CustomDomain_Status_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	embedded.Id = genruntime.ClonePointerToString(source.Id)

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_Status
		err := systemDatum.AssignPropertiesFromSystemDataStatus(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSystemDataStatus() to populate field SystemData")
		}
		embedded.SystemData = &systemDatum
	} else {
		embedded.SystemData = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		embedded.PropertyBag = propertyBag
	} else {
		embedded.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCustomDomainStatusSubResourceEmbedded populates the provided destination CustomDomain_Status_SubResourceEmbedded from our CustomDomain_Status_SubResourceEmbedded
func (embedded *CustomDomain_Status_SubResourceEmbedded) AssignPropertiesToCustomDomainStatusSubResourceEmbedded(destination *v20210601s.CustomDomain_Status_SubResourceEmbedded) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(embedded.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(embedded.Id)

	// SystemData
	if embedded.SystemData != nil {
		var systemDatum v20210601s.SystemData_Status
		err := embedded.SystemData.AssignPropertiesToSystemDataStatus(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSystemDataStatus() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeepCreatedOriginGroup_Status
// Deprecated version of DeepCreatedOriginGroup_Status. Use v1beta20210601.DeepCreatedOriginGroup_Status instead
type DeepCreatedOriginGroup_Status struct {
	HealthProbeSettings                                   *HealthProbeParameters_Status                       `json:"healthProbeSettings,omitempty"`
	Name                                                  *string                                             `json:"name,omitempty"`
	Origins                                               []ResourceReference_Status                          `json:"origins,omitempty"`
	PropertyBag                                           genruntime.PropertyBag                              `json:"$propertyBag,omitempty"`
	ResponseBasedOriginErrorDetectionSettings             *ResponseBasedOriginErrorDetectionParameters_Status `json:"responseBasedOriginErrorDetectionSettings,omitempty"`
	TrafficRestorationTimeToHealedOrNewEndpointsInMinutes *int                                                `json:"trafficRestorationTimeToHealedOrNewEndpointsInMinutes,omitempty"`
}

// AssignPropertiesFromDeepCreatedOriginGroupStatus populates our DeepCreatedOriginGroup_Status from the provided source DeepCreatedOriginGroup_Status
func (group *DeepCreatedOriginGroup_Status) AssignPropertiesFromDeepCreatedOriginGroupStatus(source *v20210601s.DeepCreatedOriginGroup_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HealthProbeSettings
	if source.HealthProbeSettings != nil {
		var healthProbeSetting HealthProbeParameters_Status
		err := healthProbeSetting.AssignPropertiesFromHealthProbeParametersStatus(source.HealthProbeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromHealthProbeParametersStatus() to populate field HealthProbeSettings")
		}
		group.HealthProbeSettings = &healthProbeSetting
	} else {
		group.HealthProbeSettings = nil
	}

	// Name
	group.Name = genruntime.ClonePointerToString(source.Name)

	// Origins
	if source.Origins != nil {
		originList := make([]ResourceReference_Status, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin ResourceReference_Status
			err := origin.AssignPropertiesFromResourceReferenceStatus(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromResourceReferenceStatus() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		group.Origins = originList
	} else {
		group.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if source.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting ResponseBasedOriginErrorDetectionParameters_Status
		err := responseBasedOriginErrorDetectionSetting.AssignPropertiesFromResponseBasedOriginErrorDetectionParametersStatus(source.ResponseBasedOriginErrorDetectionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResponseBasedOriginErrorDetectionParametersStatus() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		group.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		group.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = genruntime.ClonePointerToInt(source.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)

	// Update the property bag
	if len(propertyBag) > 0 {
		group.PropertyBag = propertyBag
	} else {
		group.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeepCreatedOriginGroupStatus populates the provided destination DeepCreatedOriginGroup_Status from our DeepCreatedOriginGroup_Status
func (group *DeepCreatedOriginGroup_Status) AssignPropertiesToDeepCreatedOriginGroupStatus(destination *v20210601s.DeepCreatedOriginGroup_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(group.PropertyBag)

	// HealthProbeSettings
	if group.HealthProbeSettings != nil {
		var healthProbeSetting v20210601s.HealthProbeParameters_Status
		err := group.HealthProbeSettings.AssignPropertiesToHealthProbeParametersStatus(&healthProbeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToHealthProbeParametersStatus() to populate field HealthProbeSettings")
		}
		destination.HealthProbeSettings = &healthProbeSetting
	} else {
		destination.HealthProbeSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(group.Name)

	// Origins
	if group.Origins != nil {
		originList := make([]v20210601s.ResourceReference_Status, len(group.Origins))
		for originIndex, originItem := range group.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin v20210601s.ResourceReference_Status
			err := originItem.AssignPropertiesToResourceReferenceStatus(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToResourceReferenceStatus() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if group.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting v20210601s.ResponseBasedOriginErrorDetectionParameters_Status
		err := group.ResponseBasedOriginErrorDetectionSettings.AssignPropertiesToResponseBasedOriginErrorDetectionParametersStatus(&responseBasedOriginErrorDetectionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResponseBasedOriginErrorDetectionParametersStatus() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		destination.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		destination.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	destination.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = genruntime.ClonePointerToInt(group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeepCreatedOrigin_Status
// Deprecated version of DeepCreatedOrigin_Status. Use v1beta20210601.DeepCreatedOrigin_Status instead
type DeepCreatedOrigin_Status struct {
	Enabled                    *bool                  `json:"enabled,omitempty"`
	HostName                   *string                `json:"hostName,omitempty"`
	HttpPort                   *int                   `json:"httpPort,omitempty"`
	HttpsPort                  *int                   `json:"httpsPort,omitempty"`
	Name                       *string                `json:"name,omitempty"`
	OriginHostHeader           *string                `json:"originHostHeader,omitempty"`
	Priority                   *int                   `json:"priority,omitempty"`
	PrivateEndpointStatus      *string                `json:"privateEndpointStatus,omitempty"`
	PrivateLinkAlias           *string                `json:"privateLinkAlias,omitempty"`
	PrivateLinkApprovalMessage *string                `json:"privateLinkApprovalMessage,omitempty"`
	PrivateLinkLocation        *string                `json:"privateLinkLocation,omitempty"`
	PrivateLinkResourceId      *string                `json:"privateLinkResourceId,omitempty"`
	PropertyBag                genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Weight                     *int                   `json:"weight,omitempty"`
}

// AssignPropertiesFromDeepCreatedOriginStatus populates our DeepCreatedOrigin_Status from the provided source DeepCreatedOrigin_Status
func (origin *DeepCreatedOrigin_Status) AssignPropertiesFromDeepCreatedOriginStatus(source *v20210601s.DeepCreatedOrigin_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		origin.Enabled = &enabled
	} else {
		origin.Enabled = nil
	}

	// HostName
	origin.HostName = genruntime.ClonePointerToString(source.HostName)

	// HttpPort
	origin.HttpPort = genruntime.ClonePointerToInt(source.HttpPort)

	// HttpsPort
	origin.HttpsPort = genruntime.ClonePointerToInt(source.HttpsPort)

	// Name
	origin.Name = genruntime.ClonePointerToString(source.Name)

	// OriginHostHeader
	origin.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// Priority
	origin.Priority = genruntime.ClonePointerToInt(source.Priority)

	// PrivateEndpointStatus
	origin.PrivateEndpointStatus = genruntime.ClonePointerToString(source.PrivateEndpointStatus)

	// PrivateLinkAlias
	origin.PrivateLinkAlias = genruntime.ClonePointerToString(source.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	origin.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(source.PrivateLinkApprovalMessage)

	// PrivateLinkLocation
	origin.PrivateLinkLocation = genruntime.ClonePointerToString(source.PrivateLinkLocation)

	// PrivateLinkResourceId
	origin.PrivateLinkResourceId = genruntime.ClonePointerToString(source.PrivateLinkResourceId)

	// Weight
	origin.Weight = genruntime.ClonePointerToInt(source.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		origin.PropertyBag = propertyBag
	} else {
		origin.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeepCreatedOriginStatus populates the provided destination DeepCreatedOrigin_Status from our DeepCreatedOrigin_Status
func (origin *DeepCreatedOrigin_Status) AssignPropertiesToDeepCreatedOriginStatus(destination *v20210601s.DeepCreatedOrigin_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// Enabled
	if origin.Enabled != nil {
		enabled := *origin.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(origin.HostName)

	// HttpPort
	destination.HttpPort = genruntime.ClonePointerToInt(origin.HttpPort)

	// HttpsPort
	destination.HttpsPort = genruntime.ClonePointerToInt(origin.HttpsPort)

	// Name
	destination.Name = genruntime.ClonePointerToString(origin.Name)

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(origin.OriginHostHeader)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(origin.Priority)

	// PrivateEndpointStatus
	destination.PrivateEndpointStatus = genruntime.ClonePointerToString(origin.PrivateEndpointStatus)

	// PrivateLinkAlias
	destination.PrivateLinkAlias = genruntime.ClonePointerToString(origin.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	destination.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(origin.PrivateLinkApprovalMessage)

	// PrivateLinkLocation
	destination.PrivateLinkLocation = genruntime.ClonePointerToString(origin.PrivateLinkLocation)

	// PrivateLinkResourceId
	destination.PrivateLinkResourceId = genruntime.ClonePointerToString(origin.PrivateLinkResourceId)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(origin.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.EndpointPropertiesUpdateParametersDeliveryPolicy
// Deprecated version of EndpointPropertiesUpdateParametersDeliveryPolicy. Use v1beta20210601.EndpointPropertiesUpdateParametersDeliveryPolicy instead
type EndpointPropertiesUpdateParametersDeliveryPolicy struct {
	Description *string                `json:"description,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Rules       []DeliveryRule         `json:"rules,omitempty"`
}

// AssignPropertiesFromEndpointPropertiesUpdateParametersDeliveryPolicy populates our EndpointPropertiesUpdateParametersDeliveryPolicy from the provided source EndpointPropertiesUpdateParametersDeliveryPolicy
func (policy *EndpointPropertiesUpdateParametersDeliveryPolicy) AssignPropertiesFromEndpointPropertiesUpdateParametersDeliveryPolicy(source *v20210601s.EndpointPropertiesUpdateParametersDeliveryPolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Description
	policy.Description = genruntime.ClonePointerToString(source.Description)

	// Rules
	if source.Rules != nil {
		ruleList := make([]DeliveryRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule DeliveryRule
			err := rule.AssignPropertiesFromDeliveryRule(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEndpointPropertiesUpdateParametersDeliveryPolicy populates the provided destination EndpointPropertiesUpdateParametersDeliveryPolicy from our EndpointPropertiesUpdateParametersDeliveryPolicy
func (policy *EndpointPropertiesUpdateParametersDeliveryPolicy) AssignPropertiesToEndpointPropertiesUpdateParametersDeliveryPolicy(destination *v20210601s.EndpointPropertiesUpdateParametersDeliveryPolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// Description
	destination.Description = genruntime.ClonePointerToString(policy.Description)

	// Rules
	if policy.Rules != nil {
		ruleList := make([]v20210601s.DeliveryRule, len(policy.Rules))
		for ruleIndex, ruleItem := range policy.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule v20210601s.DeliveryRule
			err := ruleItem.AssignPropertiesToDeliveryRule(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeliveryRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink
// Deprecated version of EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink. Use v1beta20210601.EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink instead
type EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink struct {
	PropertyBag genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Reference   *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignPropertiesFromEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink populates our EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink from the provided source EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink
func (link *EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink) AssignPropertiesFromEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink(source *v20210601s.EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		link.Reference = &reference
	} else {
		link.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		link.PropertyBag = propertyBag
	} else {
		link.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink populates the provided destination EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink from our EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink
func (link *EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink) AssignPropertiesToEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink(destination *v20210601s.EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(link.PropertyBag)

	// Reference
	if link.Reference != nil {
		reference := link.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.EndpointProperties_Status_DeliveryPolicy
// Deprecated version of EndpointProperties_Status_DeliveryPolicy. Use v1beta20210601.EndpointProperties_Status_DeliveryPolicy instead
type EndpointProperties_Status_DeliveryPolicy struct {
	Description *string                `json:"description,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Rules       []DeliveryRule_Status  `json:"rules,omitempty"`
}

// AssignPropertiesFromEndpointPropertiesStatusDeliveryPolicy populates our EndpointProperties_Status_DeliveryPolicy from the provided source EndpointProperties_Status_DeliveryPolicy
func (policy *EndpointProperties_Status_DeliveryPolicy) AssignPropertiesFromEndpointPropertiesStatusDeliveryPolicy(source *v20210601s.EndpointProperties_Status_DeliveryPolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Description
	policy.Description = genruntime.ClonePointerToString(source.Description)

	// Rules
	if source.Rules != nil {
		ruleList := make([]DeliveryRule_Status, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule DeliveryRule_Status
			err := rule.AssignPropertiesFromDeliveryRuleStatus(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleStatus() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEndpointPropertiesStatusDeliveryPolicy populates the provided destination EndpointProperties_Status_DeliveryPolicy from our EndpointProperties_Status_DeliveryPolicy
func (policy *EndpointProperties_Status_DeliveryPolicy) AssignPropertiesToEndpointPropertiesStatusDeliveryPolicy(destination *v20210601s.EndpointProperties_Status_DeliveryPolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// Description
	destination.Description = genruntime.ClonePointerToString(policy.Description)

	// Rules
	if policy.Rules != nil {
		ruleList := make([]v20210601s.DeliveryRule_Status, len(policy.Rules))
		for ruleIndex, ruleItem := range policy.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule v20210601s.DeliveryRule_Status
			err := ruleItem.AssignPropertiesToDeliveryRuleStatus(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleStatus() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.EndpointProperties_Status_WebApplicationFirewallPolicyLink
// Deprecated version of EndpointProperties_Status_WebApplicationFirewallPolicyLink. Use v1beta20210601.EndpointProperties_Status_WebApplicationFirewallPolicyLink instead
type EndpointProperties_Status_WebApplicationFirewallPolicyLink struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromEndpointPropertiesStatusWebApplicationFirewallPolicyLink populates our EndpointProperties_Status_WebApplicationFirewallPolicyLink from the provided source EndpointProperties_Status_WebApplicationFirewallPolicyLink
func (link *EndpointProperties_Status_WebApplicationFirewallPolicyLink) AssignPropertiesFromEndpointPropertiesStatusWebApplicationFirewallPolicyLink(source *v20210601s.EndpointProperties_Status_WebApplicationFirewallPolicyLink) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	link.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		link.PropertyBag = propertyBag
	} else {
		link.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEndpointPropertiesStatusWebApplicationFirewallPolicyLink populates the provided destination EndpointProperties_Status_WebApplicationFirewallPolicyLink from our EndpointProperties_Status_WebApplicationFirewallPolicyLink
func (link *EndpointProperties_Status_WebApplicationFirewallPolicyLink) AssignPropertiesToEndpointPropertiesStatusWebApplicationFirewallPolicyLink(destination *v20210601s.EndpointProperties_Status_WebApplicationFirewallPolicyLink) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(link.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(link.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.GeoFilter
// Deprecated version of GeoFilter. Use v1beta20210601.GeoFilter instead
type GeoFilter struct {
	Action       *string                `json:"action,omitempty"`
	CountryCodes []string               `json:"countryCodes,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RelativePath *string                `json:"relativePath,omitempty"`
}

// AssignPropertiesFromGeoFilter populates our GeoFilter from the provided source GeoFilter
func (filter *GeoFilter) AssignPropertiesFromGeoFilter(source *v20210601s.GeoFilter) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Action
	filter.Action = genruntime.ClonePointerToString(source.Action)

	// CountryCodes
	filter.CountryCodes = genruntime.CloneSliceOfString(source.CountryCodes)

	// RelativePath
	filter.RelativePath = genruntime.ClonePointerToString(source.RelativePath)

	// Update the property bag
	if len(propertyBag) > 0 {
		filter.PropertyBag = propertyBag
	} else {
		filter.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToGeoFilter populates the provided destination GeoFilter from our GeoFilter
func (filter *GeoFilter) AssignPropertiesToGeoFilter(destination *v20210601s.GeoFilter) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(filter.PropertyBag)

	// Action
	destination.Action = genruntime.ClonePointerToString(filter.Action)

	// CountryCodes
	destination.CountryCodes = genruntime.CloneSliceOfString(filter.CountryCodes)

	// RelativePath
	destination.RelativePath = genruntime.ClonePointerToString(filter.RelativePath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.GeoFilter_Status
// Deprecated version of GeoFilter_Status. Use v1beta20210601.GeoFilter_Status instead
type GeoFilter_Status struct {
	Action       *string                `json:"action,omitempty"`
	CountryCodes []string               `json:"countryCodes,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RelativePath *string                `json:"relativePath,omitempty"`
}

// AssignPropertiesFromGeoFilterStatus populates our GeoFilter_Status from the provided source GeoFilter_Status
func (filter *GeoFilter_Status) AssignPropertiesFromGeoFilterStatus(source *v20210601s.GeoFilter_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Action
	filter.Action = genruntime.ClonePointerToString(source.Action)

	// CountryCodes
	filter.CountryCodes = genruntime.CloneSliceOfString(source.CountryCodes)

	// RelativePath
	filter.RelativePath = genruntime.ClonePointerToString(source.RelativePath)

	// Update the property bag
	if len(propertyBag) > 0 {
		filter.PropertyBag = propertyBag
	} else {
		filter.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToGeoFilterStatus populates the provided destination GeoFilter_Status from our GeoFilter_Status
func (filter *GeoFilter_Status) AssignPropertiesToGeoFilterStatus(destination *v20210601s.GeoFilter_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(filter.PropertyBag)

	// Action
	destination.Action = genruntime.ClonePointerToString(filter.Action)

	// CountryCodes
	destination.CountryCodes = genruntime.CloneSliceOfString(filter.CountryCodes)

	// RelativePath
	destination.RelativePath = genruntime.ClonePointerToString(filter.RelativePath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.ProfilesEndpoints_Spec_Properties_OriginGroups
// Deprecated version of ProfilesEndpoints_Spec_Properties_OriginGroups. Use v1beta20210601.ProfilesEndpoints_Spec_Properties_OriginGroups instead
type ProfilesEndpoints_Spec_Properties_OriginGroups struct {
	HealthProbeSettings                                   *HealthProbeParameters                       `json:"healthProbeSettings,omitempty"`
	Name                                                  *string                                      `json:"name,omitempty"`
	Origins                                               []ResourceReference                          `json:"origins,omitempty"`
	PropertyBag                                           genruntime.PropertyBag                       `json:"$propertyBag,omitempty"`
	ResponseBasedOriginErrorDetectionSettings             *ResponseBasedOriginErrorDetectionParameters `json:"responseBasedOriginErrorDetectionSettings,omitempty"`
	TrafficRestorationTimeToHealedOrNewEndpointsInMinutes *int                                         `json:"trafficRestorationTimeToHealedOrNewEndpointsInMinutes,omitempty"`
}

// AssignPropertiesFromProfilesEndpointsSpecPropertiesOriginGroups populates our ProfilesEndpoints_Spec_Properties_OriginGroups from the provided source ProfilesEndpoints_Spec_Properties_OriginGroups
func (groups *ProfilesEndpoints_Spec_Properties_OriginGroups) AssignPropertiesFromProfilesEndpointsSpecPropertiesOriginGroups(source *v20210601s.ProfilesEndpoints_Spec_Properties_OriginGroups) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HealthProbeSettings
	if source.HealthProbeSettings != nil {
		var healthProbeSetting HealthProbeParameters
		err := healthProbeSetting.AssignPropertiesFromHealthProbeParameters(source.HealthProbeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromHealthProbeParameters() to populate field HealthProbeSettings")
		}
		groups.HealthProbeSettings = &healthProbeSetting
	} else {
		groups.HealthProbeSettings = nil
	}

	// Name
	groups.Name = genruntime.ClonePointerToString(source.Name)

	// Origins
	if source.Origins != nil {
		originList := make([]ResourceReference, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin ResourceReference
			err := origin.AssignPropertiesFromResourceReference(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromResourceReference() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		groups.Origins = originList
	} else {
		groups.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if source.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting ResponseBasedOriginErrorDetectionParameters
		err := responseBasedOriginErrorDetectionSetting.AssignPropertiesFromResponseBasedOriginErrorDetectionParameters(source.ResponseBasedOriginErrorDetectionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResponseBasedOriginErrorDetectionParameters() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		groups.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		groups.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	groups.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = genruntime.ClonePointerToInt(source.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)

	// Update the property bag
	if len(propertyBag) > 0 {
		groups.PropertyBag = propertyBag
	} else {
		groups.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToProfilesEndpointsSpecPropertiesOriginGroups populates the provided destination ProfilesEndpoints_Spec_Properties_OriginGroups from our ProfilesEndpoints_Spec_Properties_OriginGroups
func (groups *ProfilesEndpoints_Spec_Properties_OriginGroups) AssignPropertiesToProfilesEndpointsSpecPropertiesOriginGroups(destination *v20210601s.ProfilesEndpoints_Spec_Properties_OriginGroups) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(groups.PropertyBag)

	// HealthProbeSettings
	if groups.HealthProbeSettings != nil {
		var healthProbeSetting v20210601s.HealthProbeParameters
		err := groups.HealthProbeSettings.AssignPropertiesToHealthProbeParameters(&healthProbeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToHealthProbeParameters() to populate field HealthProbeSettings")
		}
		destination.HealthProbeSettings = &healthProbeSetting
	} else {
		destination.HealthProbeSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(groups.Name)

	// Origins
	if groups.Origins != nil {
		originList := make([]v20210601s.ResourceReference, len(groups.Origins))
		for originIndex, originItem := range groups.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin v20210601s.ResourceReference
			err := originItem.AssignPropertiesToResourceReference(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToResourceReference() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if groups.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting v20210601s.ResponseBasedOriginErrorDetectionParameters
		err := groups.ResponseBasedOriginErrorDetectionSettings.AssignPropertiesToResponseBasedOriginErrorDetectionParameters(&responseBasedOriginErrorDetectionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResponseBasedOriginErrorDetectionParameters() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		destination.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		destination.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	destination.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = genruntime.ClonePointerToInt(groups.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.ProfilesEndpoints_Spec_Properties_Origins
// Deprecated version of ProfilesEndpoints_Spec_Properties_Origins. Use v1beta20210601.ProfilesEndpoints_Spec_Properties_Origins instead
type ProfilesEndpoints_Spec_Properties_Origins struct {
	Enabled                      *bool                         `json:"enabled,omitempty"`
	HostName                     *string                       `json:"hostName,omitempty"`
	HttpPort                     *int                          `json:"httpPort,omitempty"`
	HttpsPort                    *int                          `json:"httpsPort,omitempty"`
	Name                         *string                       `json:"name,omitempty"`
	OriginHostHeader             *string                       `json:"originHostHeader,omitempty"`
	Priority                     *int                          `json:"priority,omitempty"`
	PrivateLinkAlias             *string                       `json:"privateLinkAlias,omitempty"`
	PrivateLinkApprovalMessage   *string                       `json:"privateLinkApprovalMessage,omitempty"`
	PrivateLinkLocationReference *genruntime.ResourceReference `armReference:"PrivateLinkLocation" json:"privateLinkLocationReference,omitempty"`
	PrivateLinkResourceReference *genruntime.ResourceReference `armReference:"PrivateLinkResourceId" json:"privateLinkResourceReference,omitempty"`
	PropertyBag                  genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Weight                       *int                          `json:"weight,omitempty"`
}

// AssignPropertiesFromProfilesEndpointsSpecPropertiesOrigins populates our ProfilesEndpoints_Spec_Properties_Origins from the provided source ProfilesEndpoints_Spec_Properties_Origins
func (origins *ProfilesEndpoints_Spec_Properties_Origins) AssignPropertiesFromProfilesEndpointsSpecPropertiesOrigins(source *v20210601s.ProfilesEndpoints_Spec_Properties_Origins) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		origins.Enabled = &enabled
	} else {
		origins.Enabled = nil
	}

	// HostName
	origins.HostName = genruntime.ClonePointerToString(source.HostName)

	// HttpPort
	origins.HttpPort = genruntime.ClonePointerToInt(source.HttpPort)

	// HttpsPort
	origins.HttpsPort = genruntime.ClonePointerToInt(source.HttpsPort)

	// Name
	origins.Name = genruntime.ClonePointerToString(source.Name)

	// OriginHostHeader
	origins.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// Priority
	origins.Priority = genruntime.ClonePointerToInt(source.Priority)

	// PrivateLinkAlias
	origins.PrivateLinkAlias = genruntime.ClonePointerToString(source.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	origins.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(source.PrivateLinkApprovalMessage)

	// PrivateLinkLocationReference
	if source.PrivateLinkLocationReference != nil {
		privateLinkLocationReference := source.PrivateLinkLocationReference.Copy()
		origins.PrivateLinkLocationReference = &privateLinkLocationReference
	} else {
		origins.PrivateLinkLocationReference = nil
	}

	// PrivateLinkResourceReference
	if source.PrivateLinkResourceReference != nil {
		privateLinkResourceReference := source.PrivateLinkResourceReference.Copy()
		origins.PrivateLinkResourceReference = &privateLinkResourceReference
	} else {
		origins.PrivateLinkResourceReference = nil
	}

	// Weight
	origins.Weight = genruntime.ClonePointerToInt(source.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		origins.PropertyBag = propertyBag
	} else {
		origins.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToProfilesEndpointsSpecPropertiesOrigins populates the provided destination ProfilesEndpoints_Spec_Properties_Origins from our ProfilesEndpoints_Spec_Properties_Origins
func (origins *ProfilesEndpoints_Spec_Properties_Origins) AssignPropertiesToProfilesEndpointsSpecPropertiesOrigins(destination *v20210601s.ProfilesEndpoints_Spec_Properties_Origins) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origins.PropertyBag)

	// Enabled
	if origins.Enabled != nil {
		enabled := *origins.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(origins.HostName)

	// HttpPort
	destination.HttpPort = genruntime.ClonePointerToInt(origins.HttpPort)

	// HttpsPort
	destination.HttpsPort = genruntime.ClonePointerToInt(origins.HttpsPort)

	// Name
	destination.Name = genruntime.ClonePointerToString(origins.Name)

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(origins.OriginHostHeader)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(origins.Priority)

	// PrivateLinkAlias
	destination.PrivateLinkAlias = genruntime.ClonePointerToString(origins.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	destination.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(origins.PrivateLinkApprovalMessage)

	// PrivateLinkLocationReference
	if origins.PrivateLinkLocationReference != nil {
		privateLinkLocationReference := origins.PrivateLinkLocationReference.Copy()
		destination.PrivateLinkLocationReference = &privateLinkLocationReference
	} else {
		destination.PrivateLinkLocationReference = nil
	}

	// PrivateLinkResourceReference
	if origins.PrivateLinkResourceReference != nil {
		privateLinkResourceReference := origins.PrivateLinkResourceReference.Copy()
		destination.PrivateLinkResourceReference = &privateLinkResourceReference
	} else {
		destination.PrivateLinkResourceReference = nil
	}

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(origins.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.ResourceReference
// Deprecated version of ResourceReference. Use v1beta20210601.ResourceReference instead
type ResourceReference struct {
	PropertyBag genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Reference   *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignPropertiesFromResourceReference populates our ResourceReference from the provided source ResourceReference
func (reference *ResourceReference) AssignPropertiesFromResourceReference(source *v20210601s.ResourceReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResourceReference populates the provided destination ResourceReference from our ResourceReference
func (reference *ResourceReference) AssignPropertiesToResourceReference(destination *v20210601s.ResourceReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.ResourceReference_Status
// Deprecated version of ResourceReference_Status. Use v1beta20210601.ResourceReference_Status instead
type ResourceReference_Status struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromResourceReferenceStatus populates our ResourceReference_Status from the provided source ResourceReference_Status
func (reference *ResourceReference_Status) AssignPropertiesFromResourceReferenceStatus(source *v20210601s.ResourceReference_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResourceReferenceStatus populates the provided destination ResourceReference_Status from our ResourceReference_Status
func (reference *ResourceReference_Status) AssignPropertiesToResourceReferenceStatus(destination *v20210601s.ResourceReference_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.UrlSigningKey
// Deprecated version of UrlSigningKey. Use v1beta20210601.UrlSigningKey instead
type UrlSigningKey struct {
	KeyId               *string                       `json:"keyId,omitempty"`
	KeySourceParameters *KeyVaultSigningKeyParameters `json:"keySourceParameters,omitempty"`
	PropertyBag         genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromUrlSigningKey populates our UrlSigningKey from the provided source UrlSigningKey
func (signingKey *UrlSigningKey) AssignPropertiesFromUrlSigningKey(source *v20210601s.UrlSigningKey) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyId
	signingKey.KeyId = genruntime.ClonePointerToString(source.KeyId)

	// KeySourceParameters
	if source.KeySourceParameters != nil {
		var keySourceParameter KeyVaultSigningKeyParameters
		err := keySourceParameter.AssignPropertiesFromKeyVaultSigningKeyParameters(source.KeySourceParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKeyVaultSigningKeyParameters() to populate field KeySourceParameters")
		}
		signingKey.KeySourceParameters = &keySourceParameter
	} else {
		signingKey.KeySourceParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		signingKey.PropertyBag = propertyBag
	} else {
		signingKey.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUrlSigningKey populates the provided destination UrlSigningKey from our UrlSigningKey
func (signingKey *UrlSigningKey) AssignPropertiesToUrlSigningKey(destination *v20210601s.UrlSigningKey) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(signingKey.PropertyBag)

	// KeyId
	destination.KeyId = genruntime.ClonePointerToString(signingKey.KeyId)

	// KeySourceParameters
	if signingKey.KeySourceParameters != nil {
		var keySourceParameter v20210601s.KeyVaultSigningKeyParameters
		err := signingKey.KeySourceParameters.AssignPropertiesToKeyVaultSigningKeyParameters(&keySourceParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKeyVaultSigningKeyParameters() to populate field KeySourceParameters")
		}
		destination.KeySourceParameters = &keySourceParameter
	} else {
		destination.KeySourceParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.UrlSigningKey_Status
// Deprecated version of UrlSigningKey_Status. Use v1beta20210601.UrlSigningKey_Status instead
type UrlSigningKey_Status struct {
	KeyId               *string                              `json:"keyId,omitempty"`
	KeySourceParameters *KeyVaultSigningKeyParameters_Status `json:"keySourceParameters,omitempty"`
	PropertyBag         genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromUrlSigningKeyStatus populates our UrlSigningKey_Status from the provided source UrlSigningKey_Status
func (signingKey *UrlSigningKey_Status) AssignPropertiesFromUrlSigningKeyStatus(source *v20210601s.UrlSigningKey_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyId
	signingKey.KeyId = genruntime.ClonePointerToString(source.KeyId)

	// KeySourceParameters
	if source.KeySourceParameters != nil {
		var keySourceParameter KeyVaultSigningKeyParameters_Status
		err := keySourceParameter.AssignPropertiesFromKeyVaultSigningKeyParametersStatus(source.KeySourceParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKeyVaultSigningKeyParametersStatus() to populate field KeySourceParameters")
		}
		signingKey.KeySourceParameters = &keySourceParameter
	} else {
		signingKey.KeySourceParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		signingKey.PropertyBag = propertyBag
	} else {
		signingKey.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUrlSigningKeyStatus populates the provided destination UrlSigningKey_Status from our UrlSigningKey_Status
func (signingKey *UrlSigningKey_Status) AssignPropertiesToUrlSigningKeyStatus(destination *v20210601s.UrlSigningKey_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(signingKey.PropertyBag)

	// KeyId
	destination.KeyId = genruntime.ClonePointerToString(signingKey.KeyId)

	// KeySourceParameters
	if signingKey.KeySourceParameters != nil {
		var keySourceParameter v20210601s.KeyVaultSigningKeyParameters_Status
		err := signingKey.KeySourceParameters.AssignPropertiesToKeyVaultSigningKeyParametersStatus(&keySourceParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKeyVaultSigningKeyParametersStatus() to populate field KeySourceParameters")
		}
		destination.KeySourceParameters = &keySourceParameter
	} else {
		destination.KeySourceParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRule
// Deprecated version of DeliveryRule. Use v1beta20210601.DeliveryRule instead
type DeliveryRule struct {
	Actions     []DeliveryRuleAction1   `json:"actions,omitempty"`
	Conditions  []DeliveryRuleCondition `json:"conditions,omitempty"`
	Name        *string                 `json:"name,omitempty"`
	Order       *int                    `json:"order,omitempty"`
	PropertyBag genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRule populates our DeliveryRule from the provided source DeliveryRule
func (rule *DeliveryRule) AssignPropertiesFromDeliveryRule(source *v20210601s.DeliveryRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Actions
	if source.Actions != nil {
		actionList := make([]DeliveryRuleAction1, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action DeliveryRuleAction1
			err := action.AssignPropertiesFromDeliveryRuleAction1(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleAction1() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		rule.Actions = actionList
	} else {
		rule.Actions = nil
	}

	// Conditions
	if source.Conditions != nil {
		conditionList := make([]DeliveryRuleCondition, len(source.Conditions))
		for conditionIndex, conditionItem := range source.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition DeliveryRuleCondition
			err := condition.AssignPropertiesFromDeliveryRuleCondition(&conditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleCondition() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		rule.Conditions = conditionList
	} else {
		rule.Conditions = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Order
	rule.Order = genruntime.ClonePointerToInt(source.Order)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRule populates the provided destination DeliveryRule from our DeliveryRule
func (rule *DeliveryRule) AssignPropertiesToDeliveryRule(destination *v20210601s.DeliveryRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// Actions
	if rule.Actions != nil {
		actionList := make([]v20210601s.DeliveryRuleAction1, len(rule.Actions))
		for actionIndex, actionItem := range rule.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action v20210601s.DeliveryRuleAction1
			err := actionItem.AssignPropertiesToDeliveryRuleAction1(&action)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleAction1() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		destination.Actions = actionList
	} else {
		destination.Actions = nil
	}

	// Conditions
	if rule.Conditions != nil {
		conditionList := make([]v20210601s.DeliveryRuleCondition, len(rule.Conditions))
		for conditionIndex, conditionItem := range rule.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition v20210601s.DeliveryRuleCondition
			err := conditionItem.AssignPropertiesToDeliveryRuleCondition(&condition)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleCondition() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		destination.Conditions = conditionList
	} else {
		destination.Conditions = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Order
	destination.Order = genruntime.ClonePointerToInt(rule.Order)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRule_Status
// Deprecated version of DeliveryRule_Status. Use v1beta20210601.DeliveryRule_Status instead
type DeliveryRule_Status struct {
	Actions     []DeliveryRuleAction_Status    `json:"actions,omitempty"`
	Conditions  []DeliveryRuleCondition_Status `json:"conditions,omitempty"`
	Name        *string                        `json:"name,omitempty"`
	Order       *int                           `json:"order,omitempty"`
	PropertyBag genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleStatus populates our DeliveryRule_Status from the provided source DeliveryRule_Status
func (rule *DeliveryRule_Status) AssignPropertiesFromDeliveryRuleStatus(source *v20210601s.DeliveryRule_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Actions
	if source.Actions != nil {
		actionList := make([]DeliveryRuleAction_Status, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action DeliveryRuleAction_Status
			err := action.AssignPropertiesFromDeliveryRuleActionStatus(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleActionStatus() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		rule.Actions = actionList
	} else {
		rule.Actions = nil
	}

	// Conditions
	if source.Conditions != nil {
		conditionList := make([]DeliveryRuleCondition_Status, len(source.Conditions))
		for conditionIndex, conditionItem := range source.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition DeliveryRuleCondition_Status
			err := condition.AssignPropertiesFromDeliveryRuleConditionStatus(&conditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleConditionStatus() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		rule.Conditions = conditionList
	} else {
		rule.Conditions = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Order
	rule.Order = genruntime.ClonePointerToInt(source.Order)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleStatus populates the provided destination DeliveryRule_Status from our DeliveryRule_Status
func (rule *DeliveryRule_Status) AssignPropertiesToDeliveryRuleStatus(destination *v20210601s.DeliveryRule_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// Actions
	if rule.Actions != nil {
		actionList := make([]v20210601s.DeliveryRuleAction_Status, len(rule.Actions))
		for actionIndex, actionItem := range rule.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action v20210601s.DeliveryRuleAction_Status
			err := actionItem.AssignPropertiesToDeliveryRuleActionStatus(&action)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleActionStatus() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		destination.Actions = actionList
	} else {
		destination.Actions = nil
	}

	// Conditions
	if rule.Conditions != nil {
		conditionList := make([]v20210601s.DeliveryRuleCondition_Status, len(rule.Conditions))
		for conditionIndex, conditionItem := range rule.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition v20210601s.DeliveryRuleCondition_Status
			err := conditionItem.AssignPropertiesToDeliveryRuleConditionStatus(&condition)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleConditionStatus() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		destination.Conditions = conditionList
	} else {
		destination.Conditions = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Order
	destination.Order = genruntime.ClonePointerToInt(rule.Order)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.HealthProbeParameters
// Deprecated version of HealthProbeParameters. Use v1beta20210601.HealthProbeParameters instead
type HealthProbeParameters struct {
	ProbeIntervalInSeconds *int                   `json:"probeIntervalInSeconds,omitempty"`
	ProbePath              *string                `json:"probePath,omitempty"`
	ProbeProtocol          *string                `json:"probeProtocol,omitempty"`
	ProbeRequestType       *string                `json:"probeRequestType,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromHealthProbeParameters populates our HealthProbeParameters from the provided source HealthProbeParameters
func (parameters *HealthProbeParameters) AssignPropertiesFromHealthProbeParameters(source *v20210601s.HealthProbeParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ProbeIntervalInSeconds
	parameters.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(source.ProbeIntervalInSeconds)

	// ProbePath
	parameters.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProbeProtocol
	parameters.ProbeProtocol = genruntime.ClonePointerToString(source.ProbeProtocol)

	// ProbeRequestType
	parameters.ProbeRequestType = genruntime.ClonePointerToString(source.ProbeRequestType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHealthProbeParameters populates the provided destination HealthProbeParameters from our HealthProbeParameters
func (parameters *HealthProbeParameters) AssignPropertiesToHealthProbeParameters(destination *v20210601s.HealthProbeParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// ProbeIntervalInSeconds
	destination.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(parameters.ProbeIntervalInSeconds)

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(parameters.ProbePath)

	// ProbeProtocol
	destination.ProbeProtocol = genruntime.ClonePointerToString(parameters.ProbeProtocol)

	// ProbeRequestType
	destination.ProbeRequestType = genruntime.ClonePointerToString(parameters.ProbeRequestType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.HealthProbeParameters_Status
// Deprecated version of HealthProbeParameters_Status. Use v1beta20210601.HealthProbeParameters_Status instead
type HealthProbeParameters_Status struct {
	ProbeIntervalInSeconds *int                   `json:"probeIntervalInSeconds,omitempty"`
	ProbePath              *string                `json:"probePath,omitempty"`
	ProbeProtocol          *string                `json:"probeProtocol,omitempty"`
	ProbeRequestType       *string                `json:"probeRequestType,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromHealthProbeParametersStatus populates our HealthProbeParameters_Status from the provided source HealthProbeParameters_Status
func (parameters *HealthProbeParameters_Status) AssignPropertiesFromHealthProbeParametersStatus(source *v20210601s.HealthProbeParameters_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ProbeIntervalInSeconds
	parameters.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(source.ProbeIntervalInSeconds)

	// ProbePath
	parameters.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProbeProtocol
	parameters.ProbeProtocol = genruntime.ClonePointerToString(source.ProbeProtocol)

	// ProbeRequestType
	parameters.ProbeRequestType = genruntime.ClonePointerToString(source.ProbeRequestType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHealthProbeParametersStatus populates the provided destination HealthProbeParameters_Status from our HealthProbeParameters_Status
func (parameters *HealthProbeParameters_Status) AssignPropertiesToHealthProbeParametersStatus(destination *v20210601s.HealthProbeParameters_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// ProbeIntervalInSeconds
	destination.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(parameters.ProbeIntervalInSeconds)

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(parameters.ProbePath)

	// ProbeProtocol
	destination.ProbeProtocol = genruntime.ClonePointerToString(parameters.ProbeProtocol)

	// ProbeRequestType
	destination.ProbeRequestType = genruntime.ClonePointerToString(parameters.ProbeRequestType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.KeyVaultSigningKeyParameters
// Deprecated version of KeyVaultSigningKeyParameters. Use v1beta20210601.KeyVaultSigningKeyParameters instead
type KeyVaultSigningKeyParameters struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceGroupName *string                `json:"resourceGroupName,omitempty"`
	SecretName        *string                `json:"secretName,omitempty"`
	SecretVersion     *string                `json:"secretVersion,omitempty"`
	SubscriptionId    *string                `json:"subscriptionId,omitempty"`
	TypeName          *string                `json:"typeName,omitempty"`
	VaultName         *string                `json:"vaultName,omitempty"`
}

// AssignPropertiesFromKeyVaultSigningKeyParameters populates our KeyVaultSigningKeyParameters from the provided source KeyVaultSigningKeyParameters
func (parameters *KeyVaultSigningKeyParameters) AssignPropertiesFromKeyVaultSigningKeyParameters(source *v20210601s.KeyVaultSigningKeyParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ResourceGroupName
	parameters.ResourceGroupName = genruntime.ClonePointerToString(source.ResourceGroupName)

	// SecretName
	parameters.SecretName = genruntime.ClonePointerToString(source.SecretName)

	// SecretVersion
	parameters.SecretVersion = genruntime.ClonePointerToString(source.SecretVersion)

	// SubscriptionId
	parameters.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// VaultName
	parameters.VaultName = genruntime.ClonePointerToString(source.VaultName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultSigningKeyParameters populates the provided destination KeyVaultSigningKeyParameters from our KeyVaultSigningKeyParameters
func (parameters *KeyVaultSigningKeyParameters) AssignPropertiesToKeyVaultSigningKeyParameters(destination *v20210601s.KeyVaultSigningKeyParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// ResourceGroupName
	destination.ResourceGroupName = genruntime.ClonePointerToString(parameters.ResourceGroupName)

	// SecretName
	destination.SecretName = genruntime.ClonePointerToString(parameters.SecretName)

	// SecretVersion
	destination.SecretVersion = genruntime.ClonePointerToString(parameters.SecretVersion)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(parameters.SubscriptionId)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// VaultName
	destination.VaultName = genruntime.ClonePointerToString(parameters.VaultName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.KeyVaultSigningKeyParameters_Status
// Deprecated version of KeyVaultSigningKeyParameters_Status. Use v1beta20210601.KeyVaultSigningKeyParameters_Status instead
type KeyVaultSigningKeyParameters_Status struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceGroupName *string                `json:"resourceGroupName,omitempty"`
	SecretName        *string                `json:"secretName,omitempty"`
	SecretVersion     *string                `json:"secretVersion,omitempty"`
	SubscriptionId    *string                `json:"subscriptionId,omitempty"`
	TypeName          *string                `json:"typeName,omitempty"`
	VaultName         *string                `json:"vaultName,omitempty"`
}

// AssignPropertiesFromKeyVaultSigningKeyParametersStatus populates our KeyVaultSigningKeyParameters_Status from the provided source KeyVaultSigningKeyParameters_Status
func (parameters *KeyVaultSigningKeyParameters_Status) AssignPropertiesFromKeyVaultSigningKeyParametersStatus(source *v20210601s.KeyVaultSigningKeyParameters_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ResourceGroupName
	parameters.ResourceGroupName = genruntime.ClonePointerToString(source.ResourceGroupName)

	// SecretName
	parameters.SecretName = genruntime.ClonePointerToString(source.SecretName)

	// SecretVersion
	parameters.SecretVersion = genruntime.ClonePointerToString(source.SecretVersion)

	// SubscriptionId
	parameters.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// VaultName
	parameters.VaultName = genruntime.ClonePointerToString(source.VaultName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToKeyVaultSigningKeyParametersStatus populates the provided destination KeyVaultSigningKeyParameters_Status from our KeyVaultSigningKeyParameters_Status
func (parameters *KeyVaultSigningKeyParameters_Status) AssignPropertiesToKeyVaultSigningKeyParametersStatus(destination *v20210601s.KeyVaultSigningKeyParameters_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// ResourceGroupName
	destination.ResourceGroupName = genruntime.ClonePointerToString(parameters.ResourceGroupName)

	// SecretName
	destination.SecretName = genruntime.ClonePointerToString(parameters.SecretName)

	// SecretVersion
	destination.SecretVersion = genruntime.ClonePointerToString(parameters.SecretVersion)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(parameters.SubscriptionId)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// VaultName
	destination.VaultName = genruntime.ClonePointerToString(parameters.VaultName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.ResponseBasedOriginErrorDetectionParameters
// Deprecated version of ResponseBasedOriginErrorDetectionParameters. Use v1beta20210601.ResponseBasedOriginErrorDetectionParameters instead
type ResponseBasedOriginErrorDetectionParameters struct {
	HttpErrorRanges                          []HttpErrorRangeParameters `json:"httpErrorRanges,omitempty"`
	PropertyBag                              genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	ResponseBasedDetectedErrorTypes          *string                    `json:"responseBasedDetectedErrorTypes,omitempty"`
	ResponseBasedFailoverThresholdPercentage *int                       `json:"responseBasedFailoverThresholdPercentage,omitempty"`
}

// AssignPropertiesFromResponseBasedOriginErrorDetectionParameters populates our ResponseBasedOriginErrorDetectionParameters from the provided source ResponseBasedOriginErrorDetectionParameters
func (parameters *ResponseBasedOriginErrorDetectionParameters) AssignPropertiesFromResponseBasedOriginErrorDetectionParameters(source *v20210601s.ResponseBasedOriginErrorDetectionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HttpErrorRanges
	if source.HttpErrorRanges != nil {
		httpErrorRangeList := make([]HttpErrorRangeParameters, len(source.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range source.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange HttpErrorRangeParameters
			err := httpErrorRange.AssignPropertiesFromHttpErrorRangeParameters(&httpErrorRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromHttpErrorRangeParameters() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		parameters.HttpErrorRanges = httpErrorRangeList
	} else {
		parameters.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	parameters.ResponseBasedDetectedErrorTypes = genruntime.ClonePointerToString(source.ResponseBasedDetectedErrorTypes)

	// ResponseBasedFailoverThresholdPercentage
	parameters.ResponseBasedFailoverThresholdPercentage = genruntime.ClonePointerToInt(source.ResponseBasedFailoverThresholdPercentage)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResponseBasedOriginErrorDetectionParameters populates the provided destination ResponseBasedOriginErrorDetectionParameters from our ResponseBasedOriginErrorDetectionParameters
func (parameters *ResponseBasedOriginErrorDetectionParameters) AssignPropertiesToResponseBasedOriginErrorDetectionParameters(destination *v20210601s.ResponseBasedOriginErrorDetectionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// HttpErrorRanges
	if parameters.HttpErrorRanges != nil {
		httpErrorRangeList := make([]v20210601s.HttpErrorRangeParameters, len(parameters.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range parameters.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange v20210601s.HttpErrorRangeParameters
			err := httpErrorRangeItem.AssignPropertiesToHttpErrorRangeParameters(&httpErrorRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToHttpErrorRangeParameters() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		destination.HttpErrorRanges = httpErrorRangeList
	} else {
		destination.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	destination.ResponseBasedDetectedErrorTypes = genruntime.ClonePointerToString(parameters.ResponseBasedDetectedErrorTypes)

	// ResponseBasedFailoverThresholdPercentage
	destination.ResponseBasedFailoverThresholdPercentage = genruntime.ClonePointerToInt(parameters.ResponseBasedFailoverThresholdPercentage)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.ResponseBasedOriginErrorDetectionParameters_Status
// Deprecated version of ResponseBasedOriginErrorDetectionParameters_Status. Use v1beta20210601.ResponseBasedOriginErrorDetectionParameters_Status instead
type ResponseBasedOriginErrorDetectionParameters_Status struct {
	HttpErrorRanges                          []HttpErrorRangeParameters_Status `json:"httpErrorRanges,omitempty"`
	PropertyBag                              genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
	ResponseBasedDetectedErrorTypes          *string                           `json:"responseBasedDetectedErrorTypes,omitempty"`
	ResponseBasedFailoverThresholdPercentage *int                              `json:"responseBasedFailoverThresholdPercentage,omitempty"`
}

// AssignPropertiesFromResponseBasedOriginErrorDetectionParametersStatus populates our ResponseBasedOriginErrorDetectionParameters_Status from the provided source ResponseBasedOriginErrorDetectionParameters_Status
func (parameters *ResponseBasedOriginErrorDetectionParameters_Status) AssignPropertiesFromResponseBasedOriginErrorDetectionParametersStatus(source *v20210601s.ResponseBasedOriginErrorDetectionParameters_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HttpErrorRanges
	if source.HttpErrorRanges != nil {
		httpErrorRangeList := make([]HttpErrorRangeParameters_Status, len(source.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range source.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange HttpErrorRangeParameters_Status
			err := httpErrorRange.AssignPropertiesFromHttpErrorRangeParametersStatus(&httpErrorRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromHttpErrorRangeParametersStatus() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		parameters.HttpErrorRanges = httpErrorRangeList
	} else {
		parameters.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	parameters.ResponseBasedDetectedErrorTypes = genruntime.ClonePointerToString(source.ResponseBasedDetectedErrorTypes)

	// ResponseBasedFailoverThresholdPercentage
	parameters.ResponseBasedFailoverThresholdPercentage = genruntime.ClonePointerToInt(source.ResponseBasedFailoverThresholdPercentage)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResponseBasedOriginErrorDetectionParametersStatus populates the provided destination ResponseBasedOriginErrorDetectionParameters_Status from our ResponseBasedOriginErrorDetectionParameters_Status
func (parameters *ResponseBasedOriginErrorDetectionParameters_Status) AssignPropertiesToResponseBasedOriginErrorDetectionParametersStatus(destination *v20210601s.ResponseBasedOriginErrorDetectionParameters_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// HttpErrorRanges
	if parameters.HttpErrorRanges != nil {
		httpErrorRangeList := make([]v20210601s.HttpErrorRangeParameters_Status, len(parameters.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range parameters.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange v20210601s.HttpErrorRangeParameters_Status
			err := httpErrorRangeItem.AssignPropertiesToHttpErrorRangeParametersStatus(&httpErrorRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToHttpErrorRangeParametersStatus() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		destination.HttpErrorRanges = httpErrorRangeList
	} else {
		destination.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	destination.ResponseBasedDetectedErrorTypes = genruntime.ClonePointerToString(parameters.ResponseBasedDetectedErrorTypes)

	// ResponseBasedFailoverThresholdPercentage
	destination.ResponseBasedFailoverThresholdPercentage = genruntime.ClonePointerToInt(parameters.ResponseBasedFailoverThresholdPercentage)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleAction1
// Deprecated version of DeliveryRuleAction1. Use v1beta20210601.DeliveryRuleAction1 instead
type DeliveryRuleAction1 struct {
	DeliveryRuleCacheExpiration            *DeliveryRuleCacheExpirationAction            `json:"deliveryRuleCacheExpirationAction,omitempty"`
	DeliveryRuleCacheKeyQueryString        *DeliveryRuleCacheKeyQueryStringAction        `json:"deliveryRuleCacheKeyQueryStringAction,omitempty"`
	DeliveryRuleRequestHeader              *DeliveryRuleRequestHeaderAction              `json:"deliveryRuleRequestHeaderAction,omitempty"`
	DeliveryRuleResponseHeader             *DeliveryRuleResponseHeaderAction             `json:"deliveryRuleResponseHeaderAction,omitempty"`
	DeliveryRuleRouteConfigurationOverride *DeliveryRuleRouteConfigurationOverrideAction `json:"deliveryRuleRouteConfigurationOverrideAction,omitempty"`
	OriginGroupOverride                    *OriginGroupOverrideAction                    `json:"originGroupOverrideAction,omitempty"`
	PropertyBag                            genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
	UrlRedirect                            *UrlRedirectAction                            `json:"urlRedirectAction,omitempty"`
	UrlRewrite                             *UrlRewriteAction                             `json:"urlRewriteAction,omitempty"`
	UrlSigning                             *UrlSigningAction                             `json:"urlSigningAction,omitempty"`
}

// AssignPropertiesFromDeliveryRuleAction1 populates our DeliveryRuleAction1 from the provided source DeliveryRuleAction1
func (action1 *DeliveryRuleAction1) AssignPropertiesFromDeliveryRuleAction1(source *v20210601s.DeliveryRuleAction1) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeliveryRuleCacheExpiration
	if source.DeliveryRuleCacheExpiration != nil {
		var deliveryRuleCacheExpiration DeliveryRuleCacheExpirationAction
		err := deliveryRuleCacheExpiration.AssignPropertiesFromDeliveryRuleCacheExpirationAction(source.DeliveryRuleCacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleCacheExpirationAction() to populate field DeliveryRuleCacheExpiration")
		}
		action1.DeliveryRuleCacheExpiration = &deliveryRuleCacheExpiration
	} else {
		action1.DeliveryRuleCacheExpiration = nil
	}

	// DeliveryRuleCacheKeyQueryString
	if source.DeliveryRuleCacheKeyQueryString != nil {
		var deliveryRuleCacheKeyQueryString DeliveryRuleCacheKeyQueryStringAction
		err := deliveryRuleCacheKeyQueryString.AssignPropertiesFromDeliveryRuleCacheKeyQueryStringAction(source.DeliveryRuleCacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleCacheKeyQueryStringAction() to populate field DeliveryRuleCacheKeyQueryString")
		}
		action1.DeliveryRuleCacheKeyQueryString = &deliveryRuleCacheKeyQueryString
	} else {
		action1.DeliveryRuleCacheKeyQueryString = nil
	}

	// DeliveryRuleRequestHeader
	if source.DeliveryRuleRequestHeader != nil {
		var deliveryRuleRequestHeader DeliveryRuleRequestHeaderAction
		err := deliveryRuleRequestHeader.AssignPropertiesFromDeliveryRuleRequestHeaderAction(source.DeliveryRuleRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleRequestHeaderAction() to populate field DeliveryRuleRequestHeader")
		}
		action1.DeliveryRuleRequestHeader = &deliveryRuleRequestHeader
	} else {
		action1.DeliveryRuleRequestHeader = nil
	}

	// DeliveryRuleResponseHeader
	if source.DeliveryRuleResponseHeader != nil {
		var deliveryRuleResponseHeader DeliveryRuleResponseHeaderAction
		err := deliveryRuleResponseHeader.AssignPropertiesFromDeliveryRuleResponseHeaderAction(source.DeliveryRuleResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleResponseHeaderAction() to populate field DeliveryRuleResponseHeader")
		}
		action1.DeliveryRuleResponseHeader = &deliveryRuleResponseHeader
	} else {
		action1.DeliveryRuleResponseHeader = nil
	}

	// DeliveryRuleRouteConfigurationOverride
	if source.DeliveryRuleRouteConfigurationOverride != nil {
		var deliveryRuleRouteConfigurationOverride DeliveryRuleRouteConfigurationOverrideAction
		err := deliveryRuleRouteConfigurationOverride.AssignPropertiesFromDeliveryRuleRouteConfigurationOverrideAction(source.DeliveryRuleRouteConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleRouteConfigurationOverrideAction() to populate field DeliveryRuleRouteConfigurationOverride")
		}
		action1.DeliveryRuleRouteConfigurationOverride = &deliveryRuleRouteConfigurationOverride
	} else {
		action1.DeliveryRuleRouteConfigurationOverride = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverrideAction
		err := originGroupOverride.AssignPropertiesFromOriginGroupOverrideAction(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromOriginGroupOverrideAction() to populate field OriginGroupOverride")
		}
		action1.OriginGroupOverride = &originGroupOverride
	} else {
		action1.OriginGroupOverride = nil
	}

	// UrlRedirect
	if source.UrlRedirect != nil {
		var urlRedirect UrlRedirectAction
		err := urlRedirect.AssignPropertiesFromUrlRedirectAction(source.UrlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUrlRedirectAction() to populate field UrlRedirect")
		}
		action1.UrlRedirect = &urlRedirect
	} else {
		action1.UrlRedirect = nil
	}

	// UrlRewrite
	if source.UrlRewrite != nil {
		var urlRewrite UrlRewriteAction
		err := urlRewrite.AssignPropertiesFromUrlRewriteAction(source.UrlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUrlRewriteAction() to populate field UrlRewrite")
		}
		action1.UrlRewrite = &urlRewrite
	} else {
		action1.UrlRewrite = nil
	}

	// UrlSigning
	if source.UrlSigning != nil {
		var urlSigning UrlSigningAction
		err := urlSigning.AssignPropertiesFromUrlSigningAction(source.UrlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUrlSigningAction() to populate field UrlSigning")
		}
		action1.UrlSigning = &urlSigning
	} else {
		action1.UrlSigning = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action1.PropertyBag = propertyBag
	} else {
		action1.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleAction1 populates the provided destination DeliveryRuleAction1 from our DeliveryRuleAction1
func (action1 *DeliveryRuleAction1) AssignPropertiesToDeliveryRuleAction1(destination *v20210601s.DeliveryRuleAction1) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action1.PropertyBag)

	// DeliveryRuleCacheExpiration
	if action1.DeliveryRuleCacheExpiration != nil {
		var deliveryRuleCacheExpiration v20210601s.DeliveryRuleCacheExpirationAction
		err := action1.DeliveryRuleCacheExpiration.AssignPropertiesToDeliveryRuleCacheExpirationAction(&deliveryRuleCacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleCacheExpirationAction() to populate field DeliveryRuleCacheExpiration")
		}
		destination.DeliveryRuleCacheExpiration = &deliveryRuleCacheExpiration
	} else {
		destination.DeliveryRuleCacheExpiration = nil
	}

	// DeliveryRuleCacheKeyQueryString
	if action1.DeliveryRuleCacheKeyQueryString != nil {
		var deliveryRuleCacheKeyQueryString v20210601s.DeliveryRuleCacheKeyQueryStringAction
		err := action1.DeliveryRuleCacheKeyQueryString.AssignPropertiesToDeliveryRuleCacheKeyQueryStringAction(&deliveryRuleCacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleCacheKeyQueryStringAction() to populate field DeliveryRuleCacheKeyQueryString")
		}
		destination.DeliveryRuleCacheKeyQueryString = &deliveryRuleCacheKeyQueryString
	} else {
		destination.DeliveryRuleCacheKeyQueryString = nil
	}

	// DeliveryRuleRequestHeader
	if action1.DeliveryRuleRequestHeader != nil {
		var deliveryRuleRequestHeader v20210601s.DeliveryRuleRequestHeaderAction
		err := action1.DeliveryRuleRequestHeader.AssignPropertiesToDeliveryRuleRequestHeaderAction(&deliveryRuleRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleRequestHeaderAction() to populate field DeliveryRuleRequestHeader")
		}
		destination.DeliveryRuleRequestHeader = &deliveryRuleRequestHeader
	} else {
		destination.DeliveryRuleRequestHeader = nil
	}

	// DeliveryRuleResponseHeader
	if action1.DeliveryRuleResponseHeader != nil {
		var deliveryRuleResponseHeader v20210601s.DeliveryRuleResponseHeaderAction
		err := action1.DeliveryRuleResponseHeader.AssignPropertiesToDeliveryRuleResponseHeaderAction(&deliveryRuleResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleResponseHeaderAction() to populate field DeliveryRuleResponseHeader")
		}
		destination.DeliveryRuleResponseHeader = &deliveryRuleResponseHeader
	} else {
		destination.DeliveryRuleResponseHeader = nil
	}

	// DeliveryRuleRouteConfigurationOverride
	if action1.DeliveryRuleRouteConfigurationOverride != nil {
		var deliveryRuleRouteConfigurationOverride v20210601s.DeliveryRuleRouteConfigurationOverrideAction
		err := action1.DeliveryRuleRouteConfigurationOverride.AssignPropertiesToDeliveryRuleRouteConfigurationOverrideAction(&deliveryRuleRouteConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleRouteConfigurationOverrideAction() to populate field DeliveryRuleRouteConfigurationOverride")
		}
		destination.DeliveryRuleRouteConfigurationOverride = &deliveryRuleRouteConfigurationOverride
	} else {
		destination.DeliveryRuleRouteConfigurationOverride = nil
	}

	// OriginGroupOverride
	if action1.OriginGroupOverride != nil {
		var originGroupOverride v20210601s.OriginGroupOverrideAction
		err := action1.OriginGroupOverride.AssignPropertiesToOriginGroupOverrideAction(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToOriginGroupOverrideAction() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// UrlRedirect
	if action1.UrlRedirect != nil {
		var urlRedirect v20210601s.UrlRedirectAction
		err := action1.UrlRedirect.AssignPropertiesToUrlRedirectAction(&urlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUrlRedirectAction() to populate field UrlRedirect")
		}
		destination.UrlRedirect = &urlRedirect
	} else {
		destination.UrlRedirect = nil
	}

	// UrlRewrite
	if action1.UrlRewrite != nil {
		var urlRewrite v20210601s.UrlRewriteAction
		err := action1.UrlRewrite.AssignPropertiesToUrlRewriteAction(&urlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUrlRewriteAction() to populate field UrlRewrite")
		}
		destination.UrlRewrite = &urlRewrite
	} else {
		destination.UrlRewrite = nil
	}

	// UrlSigning
	if action1.UrlSigning != nil {
		var urlSigning v20210601s.UrlSigningAction
		err := action1.UrlSigning.AssignPropertiesToUrlSigningAction(&urlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUrlSigningAction() to populate field UrlSigning")
		}
		destination.UrlSigning = &urlSigning
	} else {
		destination.UrlSigning = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleAction_Status
// Deprecated version of DeliveryRuleAction_Status. Use v1beta20210601.DeliveryRuleAction_Status instead
type DeliveryRuleAction_Status struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleActionStatus populates our DeliveryRuleAction_Status from the provided source DeliveryRuleAction_Status
func (action *DeliveryRuleAction_Status) AssignPropertiesFromDeliveryRuleActionStatus(source *v20210601s.DeliveryRuleAction_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleActionStatus populates the provided destination DeliveryRuleAction_Status from our DeliveryRuleAction_Status
func (action *DeliveryRuleAction_Status) AssignPropertiesToDeliveryRuleActionStatus(destination *v20210601s.DeliveryRuleAction_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleCondition
// Deprecated version of DeliveryRuleCondition. Use v1beta20210601.DeliveryRuleCondition instead
type DeliveryRuleCondition struct {
	DeliveryRuleClientPort       *DeliveryRuleClientPortCondition       `json:"deliveryRuleClientPortCondition,omitempty"`
	DeliveryRuleCookies          *DeliveryRuleCookiesCondition          `json:"deliveryRuleCookiesCondition,omitempty"`
	DeliveryRuleHostName         *DeliveryRuleHostNameCondition         `json:"deliveryRuleHostNameCondition,omitempty"`
	DeliveryRuleHttpVersion      *DeliveryRuleHttpVersionCondition      `json:"deliveryRuleHttpVersionCondition,omitempty"`
	DeliveryRuleIsDevice         *DeliveryRuleIsDeviceCondition         `json:"deliveryRuleIsDeviceCondition,omitempty"`
	DeliveryRulePostArgs         *DeliveryRulePostArgsCondition         `json:"deliveryRulePostArgsCondition,omitempty"`
	DeliveryRuleQueryString      *DeliveryRuleQueryStringCondition      `json:"deliveryRuleQueryStringCondition,omitempty"`
	DeliveryRuleRemoteAddress    *DeliveryRuleRemoteAddressCondition    `json:"deliveryRuleRemoteAddressCondition,omitempty"`
	DeliveryRuleRequestBody      *DeliveryRuleRequestBodyCondition      `json:"deliveryRuleRequestBodyCondition,omitempty"`
	DeliveryRuleRequestHeader    *DeliveryRuleRequestHeaderCondition    `json:"deliveryRuleRequestHeaderCondition,omitempty"`
	DeliveryRuleRequestMethod    *DeliveryRuleRequestMethodCondition    `json:"deliveryRuleRequestMethodCondition,omitempty"`
	DeliveryRuleRequestScheme    *DeliveryRuleRequestSchemeCondition    `json:"deliveryRuleRequestSchemeCondition,omitempty"`
	DeliveryRuleRequestUri       *DeliveryRuleRequestUriCondition       `json:"deliveryRuleRequestUriCondition,omitempty"`
	DeliveryRuleServerPort       *DeliveryRuleServerPortCondition       `json:"deliveryRuleServerPortCondition,omitempty"`
	DeliveryRuleSocketAddr       *DeliveryRuleSocketAddrCondition       `json:"deliveryRuleSocketAddrCondition,omitempty"`
	DeliveryRuleSslProtocol      *DeliveryRuleSslProtocolCondition      `json:"deliveryRuleSslProtocolCondition,omitempty"`
	DeliveryRuleUrlFileExtension *DeliveryRuleUrlFileExtensionCondition `json:"deliveryRuleUrlFileExtensionCondition,omitempty"`
	DeliveryRuleUrlFileName      *DeliveryRuleUrlFileNameCondition      `json:"deliveryRuleUrlFileNameCondition,omitempty"`
	DeliveryRuleUrlPath          *DeliveryRuleUrlPathCondition          `json:"deliveryRuleUrlPathCondition,omitempty"`
	PropertyBag                  genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleCondition populates our DeliveryRuleCondition from the provided source DeliveryRuleCondition
func (condition *DeliveryRuleCondition) AssignPropertiesFromDeliveryRuleCondition(source *v20210601s.DeliveryRuleCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DeliveryRuleClientPort
	if source.DeliveryRuleClientPort != nil {
		var deliveryRuleClientPort DeliveryRuleClientPortCondition
		err := deliveryRuleClientPort.AssignPropertiesFromDeliveryRuleClientPortCondition(source.DeliveryRuleClientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleClientPortCondition() to populate field DeliveryRuleClientPort")
		}
		condition.DeliveryRuleClientPort = &deliveryRuleClientPort
	} else {
		condition.DeliveryRuleClientPort = nil
	}

	// DeliveryRuleCookies
	if source.DeliveryRuleCookies != nil {
		var deliveryRuleCooky DeliveryRuleCookiesCondition
		err := deliveryRuleCooky.AssignPropertiesFromDeliveryRuleCookiesCondition(source.DeliveryRuleCookies)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleCookiesCondition() to populate field DeliveryRuleCookies")
		}
		condition.DeliveryRuleCookies = &deliveryRuleCooky
	} else {
		condition.DeliveryRuleCookies = nil
	}

	// DeliveryRuleHostName
	if source.DeliveryRuleHostName != nil {
		var deliveryRuleHostName DeliveryRuleHostNameCondition
		err := deliveryRuleHostName.AssignPropertiesFromDeliveryRuleHostNameCondition(source.DeliveryRuleHostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleHostNameCondition() to populate field DeliveryRuleHostName")
		}
		condition.DeliveryRuleHostName = &deliveryRuleHostName
	} else {
		condition.DeliveryRuleHostName = nil
	}

	// DeliveryRuleHttpVersion
	if source.DeliveryRuleHttpVersion != nil {
		var deliveryRuleHttpVersion DeliveryRuleHttpVersionCondition
		err := deliveryRuleHttpVersion.AssignPropertiesFromDeliveryRuleHttpVersionCondition(source.DeliveryRuleHttpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleHttpVersionCondition() to populate field DeliveryRuleHttpVersion")
		}
		condition.DeliveryRuleHttpVersion = &deliveryRuleHttpVersion
	} else {
		condition.DeliveryRuleHttpVersion = nil
	}

	// DeliveryRuleIsDevice
	if source.DeliveryRuleIsDevice != nil {
		var deliveryRuleIsDevice DeliveryRuleIsDeviceCondition
		err := deliveryRuleIsDevice.AssignPropertiesFromDeliveryRuleIsDeviceCondition(source.DeliveryRuleIsDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleIsDeviceCondition() to populate field DeliveryRuleIsDevice")
		}
		condition.DeliveryRuleIsDevice = &deliveryRuleIsDevice
	} else {
		condition.DeliveryRuleIsDevice = nil
	}

	// DeliveryRulePostArgs
	if source.DeliveryRulePostArgs != nil {
		var deliveryRulePostArg DeliveryRulePostArgsCondition
		err := deliveryRulePostArg.AssignPropertiesFromDeliveryRulePostArgsCondition(source.DeliveryRulePostArgs)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRulePostArgsCondition() to populate field DeliveryRulePostArgs")
		}
		condition.DeliveryRulePostArgs = &deliveryRulePostArg
	} else {
		condition.DeliveryRulePostArgs = nil
	}

	// DeliveryRuleQueryString
	if source.DeliveryRuleQueryString != nil {
		var deliveryRuleQueryString DeliveryRuleQueryStringCondition
		err := deliveryRuleQueryString.AssignPropertiesFromDeliveryRuleQueryStringCondition(source.DeliveryRuleQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleQueryStringCondition() to populate field DeliveryRuleQueryString")
		}
		condition.DeliveryRuleQueryString = &deliveryRuleQueryString
	} else {
		condition.DeliveryRuleQueryString = nil
	}

	// DeliveryRuleRemoteAddress
	if source.DeliveryRuleRemoteAddress != nil {
		var deliveryRuleRemoteAddress DeliveryRuleRemoteAddressCondition
		err := deliveryRuleRemoteAddress.AssignPropertiesFromDeliveryRuleRemoteAddressCondition(source.DeliveryRuleRemoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleRemoteAddressCondition() to populate field DeliveryRuleRemoteAddress")
		}
		condition.DeliveryRuleRemoteAddress = &deliveryRuleRemoteAddress
	} else {
		condition.DeliveryRuleRemoteAddress = nil
	}

	// DeliveryRuleRequestBody
	if source.DeliveryRuleRequestBody != nil {
		var deliveryRuleRequestBody DeliveryRuleRequestBodyCondition
		err := deliveryRuleRequestBody.AssignPropertiesFromDeliveryRuleRequestBodyCondition(source.DeliveryRuleRequestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleRequestBodyCondition() to populate field DeliveryRuleRequestBody")
		}
		condition.DeliveryRuleRequestBody = &deliveryRuleRequestBody
	} else {
		condition.DeliveryRuleRequestBody = nil
	}

	// DeliveryRuleRequestHeader
	if source.DeliveryRuleRequestHeader != nil {
		var deliveryRuleRequestHeader DeliveryRuleRequestHeaderCondition
		err := deliveryRuleRequestHeader.AssignPropertiesFromDeliveryRuleRequestHeaderCondition(source.DeliveryRuleRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleRequestHeaderCondition() to populate field DeliveryRuleRequestHeader")
		}
		condition.DeliveryRuleRequestHeader = &deliveryRuleRequestHeader
	} else {
		condition.DeliveryRuleRequestHeader = nil
	}

	// DeliveryRuleRequestMethod
	if source.DeliveryRuleRequestMethod != nil {
		var deliveryRuleRequestMethod DeliveryRuleRequestMethodCondition
		err := deliveryRuleRequestMethod.AssignPropertiesFromDeliveryRuleRequestMethodCondition(source.DeliveryRuleRequestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleRequestMethodCondition() to populate field DeliveryRuleRequestMethod")
		}
		condition.DeliveryRuleRequestMethod = &deliveryRuleRequestMethod
	} else {
		condition.DeliveryRuleRequestMethod = nil
	}

	// DeliveryRuleRequestScheme
	if source.DeliveryRuleRequestScheme != nil {
		var deliveryRuleRequestScheme DeliveryRuleRequestSchemeCondition
		err := deliveryRuleRequestScheme.AssignPropertiesFromDeliveryRuleRequestSchemeCondition(source.DeliveryRuleRequestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleRequestSchemeCondition() to populate field DeliveryRuleRequestScheme")
		}
		condition.DeliveryRuleRequestScheme = &deliveryRuleRequestScheme
	} else {
		condition.DeliveryRuleRequestScheme = nil
	}

	// DeliveryRuleRequestUri
	if source.DeliveryRuleRequestUri != nil {
		var deliveryRuleRequestUri DeliveryRuleRequestUriCondition
		err := deliveryRuleRequestUri.AssignPropertiesFromDeliveryRuleRequestUriCondition(source.DeliveryRuleRequestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleRequestUriCondition() to populate field DeliveryRuleRequestUri")
		}
		condition.DeliveryRuleRequestUri = &deliveryRuleRequestUri
	} else {
		condition.DeliveryRuleRequestUri = nil
	}

	// DeliveryRuleServerPort
	if source.DeliveryRuleServerPort != nil {
		var deliveryRuleServerPort DeliveryRuleServerPortCondition
		err := deliveryRuleServerPort.AssignPropertiesFromDeliveryRuleServerPortCondition(source.DeliveryRuleServerPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleServerPortCondition() to populate field DeliveryRuleServerPort")
		}
		condition.DeliveryRuleServerPort = &deliveryRuleServerPort
	} else {
		condition.DeliveryRuleServerPort = nil
	}

	// DeliveryRuleSocketAddr
	if source.DeliveryRuleSocketAddr != nil {
		var deliveryRuleSocketAddr DeliveryRuleSocketAddrCondition
		err := deliveryRuleSocketAddr.AssignPropertiesFromDeliveryRuleSocketAddrCondition(source.DeliveryRuleSocketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleSocketAddrCondition() to populate field DeliveryRuleSocketAddr")
		}
		condition.DeliveryRuleSocketAddr = &deliveryRuleSocketAddr
	} else {
		condition.DeliveryRuleSocketAddr = nil
	}

	// DeliveryRuleSslProtocol
	if source.DeliveryRuleSslProtocol != nil {
		var deliveryRuleSslProtocol DeliveryRuleSslProtocolCondition
		err := deliveryRuleSslProtocol.AssignPropertiesFromDeliveryRuleSslProtocolCondition(source.DeliveryRuleSslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleSslProtocolCondition() to populate field DeliveryRuleSslProtocol")
		}
		condition.DeliveryRuleSslProtocol = &deliveryRuleSslProtocol
	} else {
		condition.DeliveryRuleSslProtocol = nil
	}

	// DeliveryRuleUrlFileExtension
	if source.DeliveryRuleUrlFileExtension != nil {
		var deliveryRuleUrlFileExtension DeliveryRuleUrlFileExtensionCondition
		err := deliveryRuleUrlFileExtension.AssignPropertiesFromDeliveryRuleUrlFileExtensionCondition(source.DeliveryRuleUrlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleUrlFileExtensionCondition() to populate field DeliveryRuleUrlFileExtension")
		}
		condition.DeliveryRuleUrlFileExtension = &deliveryRuleUrlFileExtension
	} else {
		condition.DeliveryRuleUrlFileExtension = nil
	}

	// DeliveryRuleUrlFileName
	if source.DeliveryRuleUrlFileName != nil {
		var deliveryRuleUrlFileName DeliveryRuleUrlFileNameCondition
		err := deliveryRuleUrlFileName.AssignPropertiesFromDeliveryRuleUrlFileNameCondition(source.DeliveryRuleUrlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleUrlFileNameCondition() to populate field DeliveryRuleUrlFileName")
		}
		condition.DeliveryRuleUrlFileName = &deliveryRuleUrlFileName
	} else {
		condition.DeliveryRuleUrlFileName = nil
	}

	// DeliveryRuleUrlPath
	if source.DeliveryRuleUrlPath != nil {
		var deliveryRuleUrlPath DeliveryRuleUrlPathCondition
		err := deliveryRuleUrlPath.AssignPropertiesFromDeliveryRuleUrlPathCondition(source.DeliveryRuleUrlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleUrlPathCondition() to populate field DeliveryRuleUrlPath")
		}
		condition.DeliveryRuleUrlPath = &deliveryRuleUrlPath
	} else {
		condition.DeliveryRuleUrlPath = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleCondition populates the provided destination DeliveryRuleCondition from our DeliveryRuleCondition
func (condition *DeliveryRuleCondition) AssignPropertiesToDeliveryRuleCondition(destination *v20210601s.DeliveryRuleCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// DeliveryRuleClientPort
	if condition.DeliveryRuleClientPort != nil {
		var deliveryRuleClientPort v20210601s.DeliveryRuleClientPortCondition
		err := condition.DeliveryRuleClientPort.AssignPropertiesToDeliveryRuleClientPortCondition(&deliveryRuleClientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleClientPortCondition() to populate field DeliveryRuleClientPort")
		}
		destination.DeliveryRuleClientPort = &deliveryRuleClientPort
	} else {
		destination.DeliveryRuleClientPort = nil
	}

	// DeliveryRuleCookies
	if condition.DeliveryRuleCookies != nil {
		var deliveryRuleCooky v20210601s.DeliveryRuleCookiesCondition
		err := condition.DeliveryRuleCookies.AssignPropertiesToDeliveryRuleCookiesCondition(&deliveryRuleCooky)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleCookiesCondition() to populate field DeliveryRuleCookies")
		}
		destination.DeliveryRuleCookies = &deliveryRuleCooky
	} else {
		destination.DeliveryRuleCookies = nil
	}

	// DeliveryRuleHostName
	if condition.DeliveryRuleHostName != nil {
		var deliveryRuleHostName v20210601s.DeliveryRuleHostNameCondition
		err := condition.DeliveryRuleHostName.AssignPropertiesToDeliveryRuleHostNameCondition(&deliveryRuleHostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleHostNameCondition() to populate field DeliveryRuleHostName")
		}
		destination.DeliveryRuleHostName = &deliveryRuleHostName
	} else {
		destination.DeliveryRuleHostName = nil
	}

	// DeliveryRuleHttpVersion
	if condition.DeliveryRuleHttpVersion != nil {
		var deliveryRuleHttpVersion v20210601s.DeliveryRuleHttpVersionCondition
		err := condition.DeliveryRuleHttpVersion.AssignPropertiesToDeliveryRuleHttpVersionCondition(&deliveryRuleHttpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleHttpVersionCondition() to populate field DeliveryRuleHttpVersion")
		}
		destination.DeliveryRuleHttpVersion = &deliveryRuleHttpVersion
	} else {
		destination.DeliveryRuleHttpVersion = nil
	}

	// DeliveryRuleIsDevice
	if condition.DeliveryRuleIsDevice != nil {
		var deliveryRuleIsDevice v20210601s.DeliveryRuleIsDeviceCondition
		err := condition.DeliveryRuleIsDevice.AssignPropertiesToDeliveryRuleIsDeviceCondition(&deliveryRuleIsDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleIsDeviceCondition() to populate field DeliveryRuleIsDevice")
		}
		destination.DeliveryRuleIsDevice = &deliveryRuleIsDevice
	} else {
		destination.DeliveryRuleIsDevice = nil
	}

	// DeliveryRulePostArgs
	if condition.DeliveryRulePostArgs != nil {
		var deliveryRulePostArg v20210601s.DeliveryRulePostArgsCondition
		err := condition.DeliveryRulePostArgs.AssignPropertiesToDeliveryRulePostArgsCondition(&deliveryRulePostArg)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRulePostArgsCondition() to populate field DeliveryRulePostArgs")
		}
		destination.DeliveryRulePostArgs = &deliveryRulePostArg
	} else {
		destination.DeliveryRulePostArgs = nil
	}

	// DeliveryRuleQueryString
	if condition.DeliveryRuleQueryString != nil {
		var deliveryRuleQueryString v20210601s.DeliveryRuleQueryStringCondition
		err := condition.DeliveryRuleQueryString.AssignPropertiesToDeliveryRuleQueryStringCondition(&deliveryRuleQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleQueryStringCondition() to populate field DeliveryRuleQueryString")
		}
		destination.DeliveryRuleQueryString = &deliveryRuleQueryString
	} else {
		destination.DeliveryRuleQueryString = nil
	}

	// DeliveryRuleRemoteAddress
	if condition.DeliveryRuleRemoteAddress != nil {
		var deliveryRuleRemoteAddress v20210601s.DeliveryRuleRemoteAddressCondition
		err := condition.DeliveryRuleRemoteAddress.AssignPropertiesToDeliveryRuleRemoteAddressCondition(&deliveryRuleRemoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleRemoteAddressCondition() to populate field DeliveryRuleRemoteAddress")
		}
		destination.DeliveryRuleRemoteAddress = &deliveryRuleRemoteAddress
	} else {
		destination.DeliveryRuleRemoteAddress = nil
	}

	// DeliveryRuleRequestBody
	if condition.DeliveryRuleRequestBody != nil {
		var deliveryRuleRequestBody v20210601s.DeliveryRuleRequestBodyCondition
		err := condition.DeliveryRuleRequestBody.AssignPropertiesToDeliveryRuleRequestBodyCondition(&deliveryRuleRequestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleRequestBodyCondition() to populate field DeliveryRuleRequestBody")
		}
		destination.DeliveryRuleRequestBody = &deliveryRuleRequestBody
	} else {
		destination.DeliveryRuleRequestBody = nil
	}

	// DeliveryRuleRequestHeader
	if condition.DeliveryRuleRequestHeader != nil {
		var deliveryRuleRequestHeader v20210601s.DeliveryRuleRequestHeaderCondition
		err := condition.DeliveryRuleRequestHeader.AssignPropertiesToDeliveryRuleRequestHeaderCondition(&deliveryRuleRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleRequestHeaderCondition() to populate field DeliveryRuleRequestHeader")
		}
		destination.DeliveryRuleRequestHeader = &deliveryRuleRequestHeader
	} else {
		destination.DeliveryRuleRequestHeader = nil
	}

	// DeliveryRuleRequestMethod
	if condition.DeliveryRuleRequestMethod != nil {
		var deliveryRuleRequestMethod v20210601s.DeliveryRuleRequestMethodCondition
		err := condition.DeliveryRuleRequestMethod.AssignPropertiesToDeliveryRuleRequestMethodCondition(&deliveryRuleRequestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleRequestMethodCondition() to populate field DeliveryRuleRequestMethod")
		}
		destination.DeliveryRuleRequestMethod = &deliveryRuleRequestMethod
	} else {
		destination.DeliveryRuleRequestMethod = nil
	}

	// DeliveryRuleRequestScheme
	if condition.DeliveryRuleRequestScheme != nil {
		var deliveryRuleRequestScheme v20210601s.DeliveryRuleRequestSchemeCondition
		err := condition.DeliveryRuleRequestScheme.AssignPropertiesToDeliveryRuleRequestSchemeCondition(&deliveryRuleRequestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleRequestSchemeCondition() to populate field DeliveryRuleRequestScheme")
		}
		destination.DeliveryRuleRequestScheme = &deliveryRuleRequestScheme
	} else {
		destination.DeliveryRuleRequestScheme = nil
	}

	// DeliveryRuleRequestUri
	if condition.DeliveryRuleRequestUri != nil {
		var deliveryRuleRequestUri v20210601s.DeliveryRuleRequestUriCondition
		err := condition.DeliveryRuleRequestUri.AssignPropertiesToDeliveryRuleRequestUriCondition(&deliveryRuleRequestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleRequestUriCondition() to populate field DeliveryRuleRequestUri")
		}
		destination.DeliveryRuleRequestUri = &deliveryRuleRequestUri
	} else {
		destination.DeliveryRuleRequestUri = nil
	}

	// DeliveryRuleServerPort
	if condition.DeliveryRuleServerPort != nil {
		var deliveryRuleServerPort v20210601s.DeliveryRuleServerPortCondition
		err := condition.DeliveryRuleServerPort.AssignPropertiesToDeliveryRuleServerPortCondition(&deliveryRuleServerPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleServerPortCondition() to populate field DeliveryRuleServerPort")
		}
		destination.DeliveryRuleServerPort = &deliveryRuleServerPort
	} else {
		destination.DeliveryRuleServerPort = nil
	}

	// DeliveryRuleSocketAddr
	if condition.DeliveryRuleSocketAddr != nil {
		var deliveryRuleSocketAddr v20210601s.DeliveryRuleSocketAddrCondition
		err := condition.DeliveryRuleSocketAddr.AssignPropertiesToDeliveryRuleSocketAddrCondition(&deliveryRuleSocketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleSocketAddrCondition() to populate field DeliveryRuleSocketAddr")
		}
		destination.DeliveryRuleSocketAddr = &deliveryRuleSocketAddr
	} else {
		destination.DeliveryRuleSocketAddr = nil
	}

	// DeliveryRuleSslProtocol
	if condition.DeliveryRuleSslProtocol != nil {
		var deliveryRuleSslProtocol v20210601s.DeliveryRuleSslProtocolCondition
		err := condition.DeliveryRuleSslProtocol.AssignPropertiesToDeliveryRuleSslProtocolCondition(&deliveryRuleSslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleSslProtocolCondition() to populate field DeliveryRuleSslProtocol")
		}
		destination.DeliveryRuleSslProtocol = &deliveryRuleSslProtocol
	} else {
		destination.DeliveryRuleSslProtocol = nil
	}

	// DeliveryRuleUrlFileExtension
	if condition.DeliveryRuleUrlFileExtension != nil {
		var deliveryRuleUrlFileExtension v20210601s.DeliveryRuleUrlFileExtensionCondition
		err := condition.DeliveryRuleUrlFileExtension.AssignPropertiesToDeliveryRuleUrlFileExtensionCondition(&deliveryRuleUrlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleUrlFileExtensionCondition() to populate field DeliveryRuleUrlFileExtension")
		}
		destination.DeliveryRuleUrlFileExtension = &deliveryRuleUrlFileExtension
	} else {
		destination.DeliveryRuleUrlFileExtension = nil
	}

	// DeliveryRuleUrlFileName
	if condition.DeliveryRuleUrlFileName != nil {
		var deliveryRuleUrlFileName v20210601s.DeliveryRuleUrlFileNameCondition
		err := condition.DeliveryRuleUrlFileName.AssignPropertiesToDeliveryRuleUrlFileNameCondition(&deliveryRuleUrlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleUrlFileNameCondition() to populate field DeliveryRuleUrlFileName")
		}
		destination.DeliveryRuleUrlFileName = &deliveryRuleUrlFileName
	} else {
		destination.DeliveryRuleUrlFileName = nil
	}

	// DeliveryRuleUrlPath
	if condition.DeliveryRuleUrlPath != nil {
		var deliveryRuleUrlPath v20210601s.DeliveryRuleUrlPathCondition
		err := condition.DeliveryRuleUrlPath.AssignPropertiesToDeliveryRuleUrlPathCondition(&deliveryRuleUrlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleUrlPathCondition() to populate field DeliveryRuleUrlPath")
		}
		destination.DeliveryRuleUrlPath = &deliveryRuleUrlPath
	} else {
		destination.DeliveryRuleUrlPath = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleCondition_Status
// Deprecated version of DeliveryRuleCondition_Status. Use v1beta20210601.DeliveryRuleCondition_Status instead
type DeliveryRuleCondition_Status struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleConditionStatus populates our DeliveryRuleCondition_Status from the provided source DeliveryRuleCondition_Status
func (condition *DeliveryRuleCondition_Status) AssignPropertiesFromDeliveryRuleConditionStatus(source *v20210601s.DeliveryRuleCondition_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleConditionStatus populates the provided destination DeliveryRuleCondition_Status from our DeliveryRuleCondition_Status
func (condition *DeliveryRuleCondition_Status) AssignPropertiesToDeliveryRuleConditionStatus(destination *v20210601s.DeliveryRuleCondition_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.HttpErrorRangeParameters
// Deprecated version of HttpErrorRangeParameters. Use v1beta20210601.HttpErrorRangeParameters instead
type HttpErrorRangeParameters struct {
	Begin       *int                   `json:"begin,omitempty"`
	End         *int                   `json:"end,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromHttpErrorRangeParameters populates our HttpErrorRangeParameters from the provided source HttpErrorRangeParameters
func (parameters *HttpErrorRangeParameters) AssignPropertiesFromHttpErrorRangeParameters(source *v20210601s.HttpErrorRangeParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Begin
	parameters.Begin = genruntime.ClonePointerToInt(source.Begin)

	// End
	parameters.End = genruntime.ClonePointerToInt(source.End)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHttpErrorRangeParameters populates the provided destination HttpErrorRangeParameters from our HttpErrorRangeParameters
func (parameters *HttpErrorRangeParameters) AssignPropertiesToHttpErrorRangeParameters(destination *v20210601s.HttpErrorRangeParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Begin
	destination.Begin = genruntime.ClonePointerToInt(parameters.Begin)

	// End
	destination.End = genruntime.ClonePointerToInt(parameters.End)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.HttpErrorRangeParameters_Status
// Deprecated version of HttpErrorRangeParameters_Status. Use v1beta20210601.HttpErrorRangeParameters_Status instead
type HttpErrorRangeParameters_Status struct {
	Begin       *int                   `json:"begin,omitempty"`
	End         *int                   `json:"end,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromHttpErrorRangeParametersStatus populates our HttpErrorRangeParameters_Status from the provided source HttpErrorRangeParameters_Status
func (parameters *HttpErrorRangeParameters_Status) AssignPropertiesFromHttpErrorRangeParametersStatus(source *v20210601s.HttpErrorRangeParameters_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Begin
	parameters.Begin = genruntime.ClonePointerToInt(source.Begin)

	// End
	parameters.End = genruntime.ClonePointerToInt(source.End)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHttpErrorRangeParametersStatus populates the provided destination HttpErrorRangeParameters_Status from our HttpErrorRangeParameters_Status
func (parameters *HttpErrorRangeParameters_Status) AssignPropertiesToHttpErrorRangeParametersStatus(destination *v20210601s.HttpErrorRangeParameters_Status) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Begin
	destination.Begin = genruntime.ClonePointerToInt(parameters.Begin)

	// End
	destination.End = genruntime.ClonePointerToInt(parameters.End)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleCacheExpirationAction
// Deprecated version of DeliveryRuleCacheExpirationAction. Use v1beta20210601.DeliveryRuleCacheExpirationAction instead
type DeliveryRuleCacheExpirationAction struct {
	Name        *string                          `json:"name,omitempty"`
	Parameters  *CacheExpirationActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleCacheExpirationAction populates our DeliveryRuleCacheExpirationAction from the provided source DeliveryRuleCacheExpirationAction
func (action *DeliveryRuleCacheExpirationAction) AssignPropertiesFromDeliveryRuleCacheExpirationAction(source *v20210601s.DeliveryRuleCacheExpirationAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CacheExpirationActionParameters
		err := parameter.AssignPropertiesFromCacheExpirationActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromCacheExpirationActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleCacheExpirationAction populates the provided destination DeliveryRuleCacheExpirationAction from our DeliveryRuleCacheExpirationAction
func (action *DeliveryRuleCacheExpirationAction) AssignPropertiesToDeliveryRuleCacheExpirationAction(destination *v20210601s.DeliveryRuleCacheExpirationAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.CacheExpirationActionParameters
		err := action.Parameters.AssignPropertiesToCacheExpirationActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToCacheExpirationActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleCacheKeyQueryStringAction
// Deprecated version of DeliveryRuleCacheKeyQueryStringAction. Use v1beta20210601.DeliveryRuleCacheKeyQueryStringAction instead
type DeliveryRuleCacheKeyQueryStringAction struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *CacheKeyQueryStringActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleCacheKeyQueryStringAction populates our DeliveryRuleCacheKeyQueryStringAction from the provided source DeliveryRuleCacheKeyQueryStringAction
func (action *DeliveryRuleCacheKeyQueryStringAction) AssignPropertiesFromDeliveryRuleCacheKeyQueryStringAction(source *v20210601s.DeliveryRuleCacheKeyQueryStringAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CacheKeyQueryStringActionParameters
		err := parameter.AssignPropertiesFromCacheKeyQueryStringActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromCacheKeyQueryStringActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleCacheKeyQueryStringAction populates the provided destination DeliveryRuleCacheKeyQueryStringAction from our DeliveryRuleCacheKeyQueryStringAction
func (action *DeliveryRuleCacheKeyQueryStringAction) AssignPropertiesToDeliveryRuleCacheKeyQueryStringAction(destination *v20210601s.DeliveryRuleCacheKeyQueryStringAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.CacheKeyQueryStringActionParameters
		err := action.Parameters.AssignPropertiesToCacheKeyQueryStringActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToCacheKeyQueryStringActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleClientPortCondition
// Deprecated version of DeliveryRuleClientPortCondition. Use v1beta20210601.DeliveryRuleClientPortCondition instead
type DeliveryRuleClientPortCondition struct {
	Name        *string                             `json:"name,omitempty"`
	Parameters  *ClientPortMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleClientPortCondition populates our DeliveryRuleClientPortCondition from the provided source DeliveryRuleClientPortCondition
func (condition *DeliveryRuleClientPortCondition) AssignPropertiesFromDeliveryRuleClientPortCondition(source *v20210601s.DeliveryRuleClientPortCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter ClientPortMatchConditionParameters
		err := parameter.AssignPropertiesFromClientPortMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromClientPortMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleClientPortCondition populates the provided destination DeliveryRuleClientPortCondition from our DeliveryRuleClientPortCondition
func (condition *DeliveryRuleClientPortCondition) AssignPropertiesToDeliveryRuleClientPortCondition(destination *v20210601s.DeliveryRuleClientPortCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.ClientPortMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToClientPortMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToClientPortMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleCookiesCondition
// Deprecated version of DeliveryRuleCookiesCondition. Use v1beta20210601.DeliveryRuleCookiesCondition instead
type DeliveryRuleCookiesCondition struct {
	Name        *string                          `json:"name,omitempty"`
	Parameters  *CookiesMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleCookiesCondition populates our DeliveryRuleCookiesCondition from the provided source DeliveryRuleCookiesCondition
func (condition *DeliveryRuleCookiesCondition) AssignPropertiesFromDeliveryRuleCookiesCondition(source *v20210601s.DeliveryRuleCookiesCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CookiesMatchConditionParameters
		err := parameter.AssignPropertiesFromCookiesMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromCookiesMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleCookiesCondition populates the provided destination DeliveryRuleCookiesCondition from our DeliveryRuleCookiesCondition
func (condition *DeliveryRuleCookiesCondition) AssignPropertiesToDeliveryRuleCookiesCondition(destination *v20210601s.DeliveryRuleCookiesCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.CookiesMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToCookiesMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToCookiesMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleHostNameCondition
// Deprecated version of DeliveryRuleHostNameCondition. Use v1beta20210601.DeliveryRuleHostNameCondition instead
type DeliveryRuleHostNameCondition struct {
	Name        *string                           `json:"name,omitempty"`
	Parameters  *HostNameMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleHostNameCondition populates our DeliveryRuleHostNameCondition from the provided source DeliveryRuleHostNameCondition
func (condition *DeliveryRuleHostNameCondition) AssignPropertiesFromDeliveryRuleHostNameCondition(source *v20210601s.DeliveryRuleHostNameCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HostNameMatchConditionParameters
		err := parameter.AssignPropertiesFromHostNameMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromHostNameMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleHostNameCondition populates the provided destination DeliveryRuleHostNameCondition from our DeliveryRuleHostNameCondition
func (condition *DeliveryRuleHostNameCondition) AssignPropertiesToDeliveryRuleHostNameCondition(destination *v20210601s.DeliveryRuleHostNameCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.HostNameMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToHostNameMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToHostNameMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleHttpVersionCondition
// Deprecated version of DeliveryRuleHttpVersionCondition. Use v1beta20210601.DeliveryRuleHttpVersionCondition instead
type DeliveryRuleHttpVersionCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *HttpVersionMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleHttpVersionCondition populates our DeliveryRuleHttpVersionCondition from the provided source DeliveryRuleHttpVersionCondition
func (condition *DeliveryRuleHttpVersionCondition) AssignPropertiesFromDeliveryRuleHttpVersionCondition(source *v20210601s.DeliveryRuleHttpVersionCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HttpVersionMatchConditionParameters
		err := parameter.AssignPropertiesFromHttpVersionMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromHttpVersionMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleHttpVersionCondition populates the provided destination DeliveryRuleHttpVersionCondition from our DeliveryRuleHttpVersionCondition
func (condition *DeliveryRuleHttpVersionCondition) AssignPropertiesToDeliveryRuleHttpVersionCondition(destination *v20210601s.DeliveryRuleHttpVersionCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.HttpVersionMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToHttpVersionMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToHttpVersionMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleIsDeviceCondition
// Deprecated version of DeliveryRuleIsDeviceCondition. Use v1beta20210601.DeliveryRuleIsDeviceCondition instead
type DeliveryRuleIsDeviceCondition struct {
	Name        *string                           `json:"name,omitempty"`
	Parameters  *IsDeviceMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleIsDeviceCondition populates our DeliveryRuleIsDeviceCondition from the provided source DeliveryRuleIsDeviceCondition
func (condition *DeliveryRuleIsDeviceCondition) AssignPropertiesFromDeliveryRuleIsDeviceCondition(source *v20210601s.DeliveryRuleIsDeviceCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter IsDeviceMatchConditionParameters
		err := parameter.AssignPropertiesFromIsDeviceMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromIsDeviceMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleIsDeviceCondition populates the provided destination DeliveryRuleIsDeviceCondition from our DeliveryRuleIsDeviceCondition
func (condition *DeliveryRuleIsDeviceCondition) AssignPropertiesToDeliveryRuleIsDeviceCondition(destination *v20210601s.DeliveryRuleIsDeviceCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.IsDeviceMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToIsDeviceMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToIsDeviceMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRulePostArgsCondition
// Deprecated version of DeliveryRulePostArgsCondition. Use v1beta20210601.DeliveryRulePostArgsCondition instead
type DeliveryRulePostArgsCondition struct {
	Name        *string                           `json:"name,omitempty"`
	Parameters  *PostArgsMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRulePostArgsCondition populates our DeliveryRulePostArgsCondition from the provided source DeliveryRulePostArgsCondition
func (condition *DeliveryRulePostArgsCondition) AssignPropertiesFromDeliveryRulePostArgsCondition(source *v20210601s.DeliveryRulePostArgsCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter PostArgsMatchConditionParameters
		err := parameter.AssignPropertiesFromPostArgsMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPostArgsMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRulePostArgsCondition populates the provided destination DeliveryRulePostArgsCondition from our DeliveryRulePostArgsCondition
func (condition *DeliveryRulePostArgsCondition) AssignPropertiesToDeliveryRulePostArgsCondition(destination *v20210601s.DeliveryRulePostArgsCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.PostArgsMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToPostArgsMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPostArgsMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleQueryStringCondition
// Deprecated version of DeliveryRuleQueryStringCondition. Use v1beta20210601.DeliveryRuleQueryStringCondition instead
type DeliveryRuleQueryStringCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *QueryStringMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleQueryStringCondition populates our DeliveryRuleQueryStringCondition from the provided source DeliveryRuleQueryStringCondition
func (condition *DeliveryRuleQueryStringCondition) AssignPropertiesFromDeliveryRuleQueryStringCondition(source *v20210601s.DeliveryRuleQueryStringCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter QueryStringMatchConditionParameters
		err := parameter.AssignPropertiesFromQueryStringMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromQueryStringMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleQueryStringCondition populates the provided destination DeliveryRuleQueryStringCondition from our DeliveryRuleQueryStringCondition
func (condition *DeliveryRuleQueryStringCondition) AssignPropertiesToDeliveryRuleQueryStringCondition(destination *v20210601s.DeliveryRuleQueryStringCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.QueryStringMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToQueryStringMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToQueryStringMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleRemoteAddressCondition
// Deprecated version of DeliveryRuleRemoteAddressCondition. Use v1beta20210601.DeliveryRuleRemoteAddressCondition instead
type DeliveryRuleRemoteAddressCondition struct {
	Name        *string                                `json:"name,omitempty"`
	Parameters  *RemoteAddressMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleRemoteAddressCondition populates our DeliveryRuleRemoteAddressCondition from the provided source DeliveryRuleRemoteAddressCondition
func (condition *DeliveryRuleRemoteAddressCondition) AssignPropertiesFromDeliveryRuleRemoteAddressCondition(source *v20210601s.DeliveryRuleRemoteAddressCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RemoteAddressMatchConditionParameters
		err := parameter.AssignPropertiesFromRemoteAddressMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromRemoteAddressMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleRemoteAddressCondition populates the provided destination DeliveryRuleRemoteAddressCondition from our DeliveryRuleRemoteAddressCondition
func (condition *DeliveryRuleRemoteAddressCondition) AssignPropertiesToDeliveryRuleRemoteAddressCondition(destination *v20210601s.DeliveryRuleRemoteAddressCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RemoteAddressMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToRemoteAddressMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToRemoteAddressMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleRequestBodyCondition
// Deprecated version of DeliveryRuleRequestBodyCondition. Use v1beta20210601.DeliveryRuleRequestBodyCondition instead
type DeliveryRuleRequestBodyCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *RequestBodyMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleRequestBodyCondition populates our DeliveryRuleRequestBodyCondition from the provided source DeliveryRuleRequestBodyCondition
func (condition *DeliveryRuleRequestBodyCondition) AssignPropertiesFromDeliveryRuleRequestBodyCondition(source *v20210601s.DeliveryRuleRequestBodyCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestBodyMatchConditionParameters
		err := parameter.AssignPropertiesFromRequestBodyMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromRequestBodyMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleRequestBodyCondition populates the provided destination DeliveryRuleRequestBodyCondition from our DeliveryRuleRequestBodyCondition
func (condition *DeliveryRuleRequestBodyCondition) AssignPropertiesToDeliveryRuleRequestBodyCondition(destination *v20210601s.DeliveryRuleRequestBodyCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestBodyMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToRequestBodyMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToRequestBodyMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleRequestHeaderAction
// Deprecated version of DeliveryRuleRequestHeaderAction. Use v1beta20210601.DeliveryRuleRequestHeaderAction instead
type DeliveryRuleRequestHeaderAction struct {
	Name        *string                 `json:"name,omitempty"`
	Parameters  *HeaderActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleRequestHeaderAction populates our DeliveryRuleRequestHeaderAction from the provided source DeliveryRuleRequestHeaderAction
func (action *DeliveryRuleRequestHeaderAction) AssignPropertiesFromDeliveryRuleRequestHeaderAction(source *v20210601s.DeliveryRuleRequestHeaderAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters
		err := parameter.AssignPropertiesFromHeaderActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromHeaderActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleRequestHeaderAction populates the provided destination DeliveryRuleRequestHeaderAction from our DeliveryRuleRequestHeaderAction
func (action *DeliveryRuleRequestHeaderAction) AssignPropertiesToDeliveryRuleRequestHeaderAction(destination *v20210601s.DeliveryRuleRequestHeaderAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.HeaderActionParameters
		err := action.Parameters.AssignPropertiesToHeaderActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToHeaderActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleRequestHeaderCondition
// Deprecated version of DeliveryRuleRequestHeaderCondition. Use v1beta20210601.DeliveryRuleRequestHeaderCondition instead
type DeliveryRuleRequestHeaderCondition struct {
	Name        *string                                `json:"name,omitempty"`
	Parameters  *RequestHeaderMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleRequestHeaderCondition populates our DeliveryRuleRequestHeaderCondition from the provided source DeliveryRuleRequestHeaderCondition
func (condition *DeliveryRuleRequestHeaderCondition) AssignPropertiesFromDeliveryRuleRequestHeaderCondition(source *v20210601s.DeliveryRuleRequestHeaderCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestHeaderMatchConditionParameters
		err := parameter.AssignPropertiesFromRequestHeaderMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromRequestHeaderMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleRequestHeaderCondition populates the provided destination DeliveryRuleRequestHeaderCondition from our DeliveryRuleRequestHeaderCondition
func (condition *DeliveryRuleRequestHeaderCondition) AssignPropertiesToDeliveryRuleRequestHeaderCondition(destination *v20210601s.DeliveryRuleRequestHeaderCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestHeaderMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToRequestHeaderMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToRequestHeaderMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleRequestMethodCondition
// Deprecated version of DeliveryRuleRequestMethodCondition. Use v1beta20210601.DeliveryRuleRequestMethodCondition instead
type DeliveryRuleRequestMethodCondition struct {
	Name        *string                                `json:"name,omitempty"`
	Parameters  *RequestMethodMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleRequestMethodCondition populates our DeliveryRuleRequestMethodCondition from the provided source DeliveryRuleRequestMethodCondition
func (condition *DeliveryRuleRequestMethodCondition) AssignPropertiesFromDeliveryRuleRequestMethodCondition(source *v20210601s.DeliveryRuleRequestMethodCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestMethodMatchConditionParameters
		err := parameter.AssignPropertiesFromRequestMethodMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromRequestMethodMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleRequestMethodCondition populates the provided destination DeliveryRuleRequestMethodCondition from our DeliveryRuleRequestMethodCondition
func (condition *DeliveryRuleRequestMethodCondition) AssignPropertiesToDeliveryRuleRequestMethodCondition(destination *v20210601s.DeliveryRuleRequestMethodCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestMethodMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToRequestMethodMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToRequestMethodMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleRequestSchemeCondition
// Deprecated version of DeliveryRuleRequestSchemeCondition. Use v1beta20210601.DeliveryRuleRequestSchemeCondition instead
type DeliveryRuleRequestSchemeCondition struct {
	Name        *string                                `json:"name,omitempty"`
	Parameters  *RequestSchemeMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleRequestSchemeCondition populates our DeliveryRuleRequestSchemeCondition from the provided source DeliveryRuleRequestSchemeCondition
func (condition *DeliveryRuleRequestSchemeCondition) AssignPropertiesFromDeliveryRuleRequestSchemeCondition(source *v20210601s.DeliveryRuleRequestSchemeCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestSchemeMatchConditionParameters
		err := parameter.AssignPropertiesFromRequestSchemeMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromRequestSchemeMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleRequestSchemeCondition populates the provided destination DeliveryRuleRequestSchemeCondition from our DeliveryRuleRequestSchemeCondition
func (condition *DeliveryRuleRequestSchemeCondition) AssignPropertiesToDeliveryRuleRequestSchemeCondition(destination *v20210601s.DeliveryRuleRequestSchemeCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestSchemeMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToRequestSchemeMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToRequestSchemeMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleRequestUriCondition
// Deprecated version of DeliveryRuleRequestUriCondition. Use v1beta20210601.DeliveryRuleRequestUriCondition instead
type DeliveryRuleRequestUriCondition struct {
	Name        *string                             `json:"name,omitempty"`
	Parameters  *RequestUriMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleRequestUriCondition populates our DeliveryRuleRequestUriCondition from the provided source DeliveryRuleRequestUriCondition
func (condition *DeliveryRuleRequestUriCondition) AssignPropertiesFromDeliveryRuleRequestUriCondition(source *v20210601s.DeliveryRuleRequestUriCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestUriMatchConditionParameters
		err := parameter.AssignPropertiesFromRequestUriMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromRequestUriMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleRequestUriCondition populates the provided destination DeliveryRuleRequestUriCondition from our DeliveryRuleRequestUriCondition
func (condition *DeliveryRuleRequestUriCondition) AssignPropertiesToDeliveryRuleRequestUriCondition(destination *v20210601s.DeliveryRuleRequestUriCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestUriMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToRequestUriMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToRequestUriMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleResponseHeaderAction
// Deprecated version of DeliveryRuleResponseHeaderAction. Use v1beta20210601.DeliveryRuleResponseHeaderAction instead
type DeliveryRuleResponseHeaderAction struct {
	Name        *string                 `json:"name,omitempty"`
	Parameters  *HeaderActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleResponseHeaderAction populates our DeliveryRuleResponseHeaderAction from the provided source DeliveryRuleResponseHeaderAction
func (action *DeliveryRuleResponseHeaderAction) AssignPropertiesFromDeliveryRuleResponseHeaderAction(source *v20210601s.DeliveryRuleResponseHeaderAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters
		err := parameter.AssignPropertiesFromHeaderActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromHeaderActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleResponseHeaderAction populates the provided destination DeliveryRuleResponseHeaderAction from our DeliveryRuleResponseHeaderAction
func (action *DeliveryRuleResponseHeaderAction) AssignPropertiesToDeliveryRuleResponseHeaderAction(destination *v20210601s.DeliveryRuleResponseHeaderAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.HeaderActionParameters
		err := action.Parameters.AssignPropertiesToHeaderActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToHeaderActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleRouteConfigurationOverrideAction
// Deprecated version of DeliveryRuleRouteConfigurationOverrideAction. Use v1beta20210601.DeliveryRuleRouteConfigurationOverrideAction instead
type DeliveryRuleRouteConfigurationOverrideAction struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *RouteConfigurationOverrideActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleRouteConfigurationOverrideAction populates our DeliveryRuleRouteConfigurationOverrideAction from the provided source DeliveryRuleRouteConfigurationOverrideAction
func (action *DeliveryRuleRouteConfigurationOverrideAction) AssignPropertiesFromDeliveryRuleRouteConfigurationOverrideAction(source *v20210601s.DeliveryRuleRouteConfigurationOverrideAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RouteConfigurationOverrideActionParameters
		err := parameter.AssignPropertiesFromRouteConfigurationOverrideActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromRouteConfigurationOverrideActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleRouteConfigurationOverrideAction populates the provided destination DeliveryRuleRouteConfigurationOverrideAction from our DeliveryRuleRouteConfigurationOverrideAction
func (action *DeliveryRuleRouteConfigurationOverrideAction) AssignPropertiesToDeliveryRuleRouteConfigurationOverrideAction(destination *v20210601s.DeliveryRuleRouteConfigurationOverrideAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.RouteConfigurationOverrideActionParameters
		err := action.Parameters.AssignPropertiesToRouteConfigurationOverrideActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToRouteConfigurationOverrideActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleServerPortCondition
// Deprecated version of DeliveryRuleServerPortCondition. Use v1beta20210601.DeliveryRuleServerPortCondition instead
type DeliveryRuleServerPortCondition struct {
	Name        *string                             `json:"name,omitempty"`
	Parameters  *ServerPortMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleServerPortCondition populates our DeliveryRuleServerPortCondition from the provided source DeliveryRuleServerPortCondition
func (condition *DeliveryRuleServerPortCondition) AssignPropertiesFromDeliveryRuleServerPortCondition(source *v20210601s.DeliveryRuleServerPortCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter ServerPortMatchConditionParameters
		err := parameter.AssignPropertiesFromServerPortMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromServerPortMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleServerPortCondition populates the provided destination DeliveryRuleServerPortCondition from our DeliveryRuleServerPortCondition
func (condition *DeliveryRuleServerPortCondition) AssignPropertiesToDeliveryRuleServerPortCondition(destination *v20210601s.DeliveryRuleServerPortCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.ServerPortMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToServerPortMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToServerPortMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleSocketAddrCondition
// Deprecated version of DeliveryRuleSocketAddrCondition. Use v1beta20210601.DeliveryRuleSocketAddrCondition instead
type DeliveryRuleSocketAddrCondition struct {
	Name        *string                             `json:"name,omitempty"`
	Parameters  *SocketAddrMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleSocketAddrCondition populates our DeliveryRuleSocketAddrCondition from the provided source DeliveryRuleSocketAddrCondition
func (condition *DeliveryRuleSocketAddrCondition) AssignPropertiesFromDeliveryRuleSocketAddrCondition(source *v20210601s.DeliveryRuleSocketAddrCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter SocketAddrMatchConditionParameters
		err := parameter.AssignPropertiesFromSocketAddrMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSocketAddrMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleSocketAddrCondition populates the provided destination DeliveryRuleSocketAddrCondition from our DeliveryRuleSocketAddrCondition
func (condition *DeliveryRuleSocketAddrCondition) AssignPropertiesToDeliveryRuleSocketAddrCondition(destination *v20210601s.DeliveryRuleSocketAddrCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.SocketAddrMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToSocketAddrMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSocketAddrMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleSslProtocolCondition
// Deprecated version of DeliveryRuleSslProtocolCondition. Use v1beta20210601.DeliveryRuleSslProtocolCondition instead
type DeliveryRuleSslProtocolCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *SslProtocolMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleSslProtocolCondition populates our DeliveryRuleSslProtocolCondition from the provided source DeliveryRuleSslProtocolCondition
func (condition *DeliveryRuleSslProtocolCondition) AssignPropertiesFromDeliveryRuleSslProtocolCondition(source *v20210601s.DeliveryRuleSslProtocolCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter SslProtocolMatchConditionParameters
		err := parameter.AssignPropertiesFromSslProtocolMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSslProtocolMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleSslProtocolCondition populates the provided destination DeliveryRuleSslProtocolCondition from our DeliveryRuleSslProtocolCondition
func (condition *DeliveryRuleSslProtocolCondition) AssignPropertiesToDeliveryRuleSslProtocolCondition(destination *v20210601s.DeliveryRuleSslProtocolCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.SslProtocolMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToSslProtocolMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSslProtocolMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleUrlFileExtensionCondition
// Deprecated version of DeliveryRuleUrlFileExtensionCondition. Use v1beta20210601.DeliveryRuleUrlFileExtensionCondition instead
type DeliveryRuleUrlFileExtensionCondition struct {
	Name        *string                                   `json:"name,omitempty"`
	Parameters  *UrlFileExtensionMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                    `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleUrlFileExtensionCondition populates our DeliveryRuleUrlFileExtensionCondition from the provided source DeliveryRuleUrlFileExtensionCondition
func (condition *DeliveryRuleUrlFileExtensionCondition) AssignPropertiesFromDeliveryRuleUrlFileExtensionCondition(source *v20210601s.DeliveryRuleUrlFileExtensionCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileExtensionMatchConditionParameters
		err := parameter.AssignPropertiesFromUrlFileExtensionMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUrlFileExtensionMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleUrlFileExtensionCondition populates the provided destination DeliveryRuleUrlFileExtensionCondition from our DeliveryRuleUrlFileExtensionCondition
func (condition *DeliveryRuleUrlFileExtensionCondition) AssignPropertiesToDeliveryRuleUrlFileExtensionCondition(destination *v20210601s.DeliveryRuleUrlFileExtensionCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.UrlFileExtensionMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToUrlFileExtensionMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUrlFileExtensionMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleUrlFileNameCondition
// Deprecated version of DeliveryRuleUrlFileNameCondition. Use v1beta20210601.DeliveryRuleUrlFileNameCondition instead
type DeliveryRuleUrlFileNameCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *UrlFileNameMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleUrlFileNameCondition populates our DeliveryRuleUrlFileNameCondition from the provided source DeliveryRuleUrlFileNameCondition
func (condition *DeliveryRuleUrlFileNameCondition) AssignPropertiesFromDeliveryRuleUrlFileNameCondition(source *v20210601s.DeliveryRuleUrlFileNameCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileNameMatchConditionParameters
		err := parameter.AssignPropertiesFromUrlFileNameMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUrlFileNameMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleUrlFileNameCondition populates the provided destination DeliveryRuleUrlFileNameCondition from our DeliveryRuleUrlFileNameCondition
func (condition *DeliveryRuleUrlFileNameCondition) AssignPropertiesToDeliveryRuleUrlFileNameCondition(destination *v20210601s.DeliveryRuleUrlFileNameCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.UrlFileNameMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToUrlFileNameMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUrlFileNameMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.DeliveryRuleUrlPathCondition
// Deprecated version of DeliveryRuleUrlPathCondition. Use v1beta20210601.DeliveryRuleUrlPathCondition instead
type DeliveryRuleUrlPathCondition struct {
	Name        *string                          `json:"name,omitempty"`
	Parameters  *UrlPathMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromDeliveryRuleUrlPathCondition populates our DeliveryRuleUrlPathCondition from the provided source DeliveryRuleUrlPathCondition
func (condition *DeliveryRuleUrlPathCondition) AssignPropertiesFromDeliveryRuleUrlPathCondition(source *v20210601s.DeliveryRuleUrlPathCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlPathMatchConditionParameters
		err := parameter.AssignPropertiesFromUrlPathMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUrlPathMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleUrlPathCondition populates the provided destination DeliveryRuleUrlPathCondition from our DeliveryRuleUrlPathCondition
func (condition *DeliveryRuleUrlPathCondition) AssignPropertiesToDeliveryRuleUrlPathCondition(destination *v20210601s.DeliveryRuleUrlPathCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.UrlPathMatchConditionParameters
		err := condition.Parameters.AssignPropertiesToUrlPathMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUrlPathMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.OriginGroupOverrideAction
// Deprecated version of OriginGroupOverrideAction. Use v1beta20210601.OriginGroupOverrideAction instead
type OriginGroupOverrideAction struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *OriginGroupOverrideActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromOriginGroupOverrideAction populates our OriginGroupOverrideAction from the provided source OriginGroupOverrideAction
func (action *OriginGroupOverrideAction) AssignPropertiesFromOriginGroupOverrideAction(source *v20210601s.OriginGroupOverrideAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter OriginGroupOverrideActionParameters
		err := parameter.AssignPropertiesFromOriginGroupOverrideActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromOriginGroupOverrideActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOriginGroupOverrideAction populates the provided destination OriginGroupOverrideAction from our OriginGroupOverrideAction
func (action *OriginGroupOverrideAction) AssignPropertiesToOriginGroupOverrideAction(destination *v20210601s.OriginGroupOverrideAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.OriginGroupOverrideActionParameters
		err := action.Parameters.AssignPropertiesToOriginGroupOverrideActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToOriginGroupOverrideActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.UrlRedirectAction
// Deprecated version of UrlRedirectAction. Use v1beta20210601.UrlRedirectAction instead
type UrlRedirectAction struct {
	Name        *string                      `json:"name,omitempty"`
	Parameters  *UrlRedirectActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromUrlRedirectAction populates our UrlRedirectAction from the provided source UrlRedirectAction
func (action *UrlRedirectAction) AssignPropertiesFromUrlRedirectAction(source *v20210601s.UrlRedirectAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRedirectActionParameters
		err := parameter.AssignPropertiesFromUrlRedirectActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUrlRedirectActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUrlRedirectAction populates the provided destination UrlRedirectAction from our UrlRedirectAction
func (action *UrlRedirectAction) AssignPropertiesToUrlRedirectAction(destination *v20210601s.UrlRedirectAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.UrlRedirectActionParameters
		err := action.Parameters.AssignPropertiesToUrlRedirectActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUrlRedirectActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.UrlRewriteAction
// Deprecated version of UrlRewriteAction. Use v1beta20210601.UrlRewriteAction instead
type UrlRewriteAction struct {
	Name        *string                     `json:"name,omitempty"`
	Parameters  *UrlRewriteActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromUrlRewriteAction populates our UrlRewriteAction from the provided source UrlRewriteAction
func (action *UrlRewriteAction) AssignPropertiesFromUrlRewriteAction(source *v20210601s.UrlRewriteAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRewriteActionParameters
		err := parameter.AssignPropertiesFromUrlRewriteActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUrlRewriteActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUrlRewriteAction populates the provided destination UrlRewriteAction from our UrlRewriteAction
func (action *UrlRewriteAction) AssignPropertiesToUrlRewriteAction(destination *v20210601s.UrlRewriteAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.UrlRewriteActionParameters
		err := action.Parameters.AssignPropertiesToUrlRewriteActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUrlRewriteActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.UrlSigningAction
// Deprecated version of UrlSigningAction. Use v1beta20210601.UrlSigningAction instead
type UrlSigningAction struct {
	Name        *string                     `json:"name,omitempty"`
	Parameters  *UrlSigningActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromUrlSigningAction populates our UrlSigningAction from the provided source UrlSigningAction
func (action *UrlSigningAction) AssignPropertiesFromUrlSigningAction(source *v20210601s.UrlSigningAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlSigningActionParameters
		err := parameter.AssignPropertiesFromUrlSigningActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUrlSigningActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUrlSigningAction populates the provided destination UrlSigningAction from our UrlSigningAction
func (action *UrlSigningAction) AssignPropertiesToUrlSigningAction(destination *v20210601s.UrlSigningAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.UrlSigningActionParameters
		err := action.Parameters.AssignPropertiesToUrlSigningActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUrlSigningActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.CacheExpirationActionParameters
// Deprecated version of CacheExpirationActionParameters. Use v1beta20210601.CacheExpirationActionParameters instead
type CacheExpirationActionParameters struct {
	CacheBehavior *string                `json:"cacheBehavior,omitempty"`
	CacheDuration *string                `json:"cacheDuration,omitempty"`
	CacheType     *string                `json:"cacheType,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName      *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromCacheExpirationActionParameters populates our CacheExpirationActionParameters from the provided source CacheExpirationActionParameters
func (parameters *CacheExpirationActionParameters) AssignPropertiesFromCacheExpirationActionParameters(source *v20210601s.CacheExpirationActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheBehavior
	parameters.CacheBehavior = genruntime.ClonePointerToString(source.CacheBehavior)

	// CacheDuration
	parameters.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// CacheType
	parameters.CacheType = genruntime.ClonePointerToString(source.CacheType)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCacheExpirationActionParameters populates the provided destination CacheExpirationActionParameters from our CacheExpirationActionParameters
func (parameters *CacheExpirationActionParameters) AssignPropertiesToCacheExpirationActionParameters(destination *v20210601s.CacheExpirationActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CacheBehavior
	destination.CacheBehavior = genruntime.ClonePointerToString(parameters.CacheBehavior)

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(parameters.CacheDuration)

	// CacheType
	destination.CacheType = genruntime.ClonePointerToString(parameters.CacheType)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.CacheKeyQueryStringActionParameters
// Deprecated version of CacheKeyQueryStringActionParameters. Use v1beta20210601.CacheKeyQueryStringActionParameters instead
type CacheKeyQueryStringActionParameters struct {
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	QueryParameters     *string                `json:"queryParameters,omitempty"`
	QueryStringBehavior *string                `json:"queryStringBehavior,omitempty"`
	TypeName            *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromCacheKeyQueryStringActionParameters populates our CacheKeyQueryStringActionParameters from the provided source CacheKeyQueryStringActionParameters
func (parameters *CacheKeyQueryStringActionParameters) AssignPropertiesFromCacheKeyQueryStringActionParameters(source *v20210601s.CacheKeyQueryStringActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// QueryParameters
	parameters.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringBehavior
	parameters.QueryStringBehavior = genruntime.ClonePointerToString(source.QueryStringBehavior)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCacheKeyQueryStringActionParameters populates the provided destination CacheKeyQueryStringActionParameters from our CacheKeyQueryStringActionParameters
func (parameters *CacheKeyQueryStringActionParameters) AssignPropertiesToCacheKeyQueryStringActionParameters(destination *v20210601s.CacheKeyQueryStringActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(parameters.QueryParameters)

	// QueryStringBehavior
	destination.QueryStringBehavior = genruntime.ClonePointerToString(parameters.QueryStringBehavior)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.ClientPortMatchConditionParameters
// Deprecated version of ClientPortMatchConditionParameters. Use v1beta20210601.ClientPortMatchConditionParameters instead
type ClientPortMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromClientPortMatchConditionParameters populates our ClientPortMatchConditionParameters from the provided source ClientPortMatchConditionParameters
func (parameters *ClientPortMatchConditionParameters) AssignPropertiesFromClientPortMatchConditionParameters(source *v20210601s.ClientPortMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToClientPortMatchConditionParameters populates the provided destination ClientPortMatchConditionParameters from our ClientPortMatchConditionParameters
func (parameters *ClientPortMatchConditionParameters) AssignPropertiesToClientPortMatchConditionParameters(destination *v20210601s.ClientPortMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.CookiesMatchConditionParameters
// Deprecated version of CookiesMatchConditionParameters. Use v1beta20210601.CookiesMatchConditionParameters instead
type CookiesMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromCookiesMatchConditionParameters populates our CookiesMatchConditionParameters from the provided source CookiesMatchConditionParameters
func (parameters *CookiesMatchConditionParameters) AssignPropertiesFromCookiesMatchConditionParameters(source *v20210601s.CookiesMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCookiesMatchConditionParameters populates the provided destination CookiesMatchConditionParameters from our CookiesMatchConditionParameters
func (parameters *CookiesMatchConditionParameters) AssignPropertiesToCookiesMatchConditionParameters(destination *v20210601s.CookiesMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.HeaderActionParameters
// Deprecated version of HeaderActionParameters. Use v1beta20210601.HeaderActionParameters instead
type HeaderActionParameters struct {
	HeaderAction *string                `json:"headerAction,omitempty"`
	HeaderName   *string                `json:"headerName,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName     *string                `json:"typeName,omitempty"`
	Value        *string                `json:"value,omitempty"`
}

// AssignPropertiesFromHeaderActionParameters populates our HeaderActionParameters from the provided source HeaderActionParameters
func (parameters *HeaderActionParameters) AssignPropertiesFromHeaderActionParameters(source *v20210601s.HeaderActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HeaderAction
	parameters.HeaderAction = genruntime.ClonePointerToString(source.HeaderAction)

	// HeaderName
	parameters.HeaderName = genruntime.ClonePointerToString(source.HeaderName)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Value
	parameters.Value = genruntime.ClonePointerToString(source.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHeaderActionParameters populates the provided destination HeaderActionParameters from our HeaderActionParameters
func (parameters *HeaderActionParameters) AssignPropertiesToHeaderActionParameters(destination *v20210601s.HeaderActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// HeaderAction
	destination.HeaderAction = genruntime.ClonePointerToString(parameters.HeaderAction)

	// HeaderName
	destination.HeaderName = genruntime.ClonePointerToString(parameters.HeaderName)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Value
	destination.Value = genruntime.ClonePointerToString(parameters.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.HostNameMatchConditionParameters
// Deprecated version of HostNameMatchConditionParameters. Use v1beta20210601.HostNameMatchConditionParameters instead
type HostNameMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromHostNameMatchConditionParameters populates our HostNameMatchConditionParameters from the provided source HostNameMatchConditionParameters
func (parameters *HostNameMatchConditionParameters) AssignPropertiesFromHostNameMatchConditionParameters(source *v20210601s.HostNameMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHostNameMatchConditionParameters populates the provided destination HostNameMatchConditionParameters from our HostNameMatchConditionParameters
func (parameters *HostNameMatchConditionParameters) AssignPropertiesToHostNameMatchConditionParameters(destination *v20210601s.HostNameMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.HttpVersionMatchConditionParameters
// Deprecated version of HttpVersionMatchConditionParameters. Use v1beta20210601.HttpVersionMatchConditionParameters instead
type HttpVersionMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromHttpVersionMatchConditionParameters populates our HttpVersionMatchConditionParameters from the provided source HttpVersionMatchConditionParameters
func (parameters *HttpVersionMatchConditionParameters) AssignPropertiesFromHttpVersionMatchConditionParameters(source *v20210601s.HttpVersionMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHttpVersionMatchConditionParameters populates the provided destination HttpVersionMatchConditionParameters from our HttpVersionMatchConditionParameters
func (parameters *HttpVersionMatchConditionParameters) AssignPropertiesToHttpVersionMatchConditionParameters(destination *v20210601s.HttpVersionMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.IsDeviceMatchConditionParameters
// Deprecated version of IsDeviceMatchConditionParameters. Use v1beta20210601.IsDeviceMatchConditionParameters instead
type IsDeviceMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromIsDeviceMatchConditionParameters populates our IsDeviceMatchConditionParameters from the provided source IsDeviceMatchConditionParameters
func (parameters *IsDeviceMatchConditionParameters) AssignPropertiesFromIsDeviceMatchConditionParameters(source *v20210601s.IsDeviceMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToIsDeviceMatchConditionParameters populates the provided destination IsDeviceMatchConditionParameters from our IsDeviceMatchConditionParameters
func (parameters *IsDeviceMatchConditionParameters) AssignPropertiesToIsDeviceMatchConditionParameters(destination *v20210601s.IsDeviceMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.OriginGroupOverrideActionParameters
// Deprecated version of OriginGroupOverrideActionParameters. Use v1beta20210601.OriginGroupOverrideActionParameters instead
type OriginGroupOverrideActionParameters struct {
	OriginGroup *ResourceReference     `json:"originGroup,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName    *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromOriginGroupOverrideActionParameters populates our OriginGroupOverrideActionParameters from the provided source OriginGroupOverrideActionParameters
func (parameters *OriginGroupOverrideActionParameters) AssignPropertiesFromOriginGroupOverrideActionParameters(source *v20210601s.OriginGroupOverrideActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference
		err := originGroup.AssignPropertiesFromResourceReference(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceReference() to populate field OriginGroup")
		}
		parameters.OriginGroup = &originGroup
	} else {
		parameters.OriginGroup = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOriginGroupOverrideActionParameters populates the provided destination OriginGroupOverrideActionParameters from our OriginGroupOverrideActionParameters
func (parameters *OriginGroupOverrideActionParameters) AssignPropertiesToOriginGroupOverrideActionParameters(destination *v20210601s.OriginGroupOverrideActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// OriginGroup
	if parameters.OriginGroup != nil {
		var originGroup v20210601s.ResourceReference
		err := parameters.OriginGroup.AssignPropertiesToResourceReference(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceReference() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.PostArgsMatchConditionParameters
// Deprecated version of PostArgsMatchConditionParameters. Use v1beta20210601.PostArgsMatchConditionParameters instead
type PostArgsMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromPostArgsMatchConditionParameters populates our PostArgsMatchConditionParameters from the provided source PostArgsMatchConditionParameters
func (parameters *PostArgsMatchConditionParameters) AssignPropertiesFromPostArgsMatchConditionParameters(source *v20210601s.PostArgsMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToPostArgsMatchConditionParameters populates the provided destination PostArgsMatchConditionParameters from our PostArgsMatchConditionParameters
func (parameters *PostArgsMatchConditionParameters) AssignPropertiesToPostArgsMatchConditionParameters(destination *v20210601s.PostArgsMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.QueryStringMatchConditionParameters
// Deprecated version of QueryStringMatchConditionParameters. Use v1beta20210601.QueryStringMatchConditionParameters instead
type QueryStringMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromQueryStringMatchConditionParameters populates our QueryStringMatchConditionParameters from the provided source QueryStringMatchConditionParameters
func (parameters *QueryStringMatchConditionParameters) AssignPropertiesFromQueryStringMatchConditionParameters(source *v20210601s.QueryStringMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToQueryStringMatchConditionParameters populates the provided destination QueryStringMatchConditionParameters from our QueryStringMatchConditionParameters
func (parameters *QueryStringMatchConditionParameters) AssignPropertiesToQueryStringMatchConditionParameters(destination *v20210601s.QueryStringMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.RemoteAddressMatchConditionParameters
// Deprecated version of RemoteAddressMatchConditionParameters. Use v1beta20210601.RemoteAddressMatchConditionParameters instead
type RemoteAddressMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromRemoteAddressMatchConditionParameters populates our RemoteAddressMatchConditionParameters from the provided source RemoteAddressMatchConditionParameters
func (parameters *RemoteAddressMatchConditionParameters) AssignPropertiesFromRemoteAddressMatchConditionParameters(source *v20210601s.RemoteAddressMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRemoteAddressMatchConditionParameters populates the provided destination RemoteAddressMatchConditionParameters from our RemoteAddressMatchConditionParameters
func (parameters *RemoteAddressMatchConditionParameters) AssignPropertiesToRemoteAddressMatchConditionParameters(destination *v20210601s.RemoteAddressMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.RequestBodyMatchConditionParameters
// Deprecated version of RequestBodyMatchConditionParameters. Use v1beta20210601.RequestBodyMatchConditionParameters instead
type RequestBodyMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromRequestBodyMatchConditionParameters populates our RequestBodyMatchConditionParameters from the provided source RequestBodyMatchConditionParameters
func (parameters *RequestBodyMatchConditionParameters) AssignPropertiesFromRequestBodyMatchConditionParameters(source *v20210601s.RequestBodyMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRequestBodyMatchConditionParameters populates the provided destination RequestBodyMatchConditionParameters from our RequestBodyMatchConditionParameters
func (parameters *RequestBodyMatchConditionParameters) AssignPropertiesToRequestBodyMatchConditionParameters(destination *v20210601s.RequestBodyMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.RequestHeaderMatchConditionParameters
// Deprecated version of RequestHeaderMatchConditionParameters. Use v1beta20210601.RequestHeaderMatchConditionParameters instead
type RequestHeaderMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromRequestHeaderMatchConditionParameters populates our RequestHeaderMatchConditionParameters from the provided source RequestHeaderMatchConditionParameters
func (parameters *RequestHeaderMatchConditionParameters) AssignPropertiesFromRequestHeaderMatchConditionParameters(source *v20210601s.RequestHeaderMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRequestHeaderMatchConditionParameters populates the provided destination RequestHeaderMatchConditionParameters from our RequestHeaderMatchConditionParameters
func (parameters *RequestHeaderMatchConditionParameters) AssignPropertiesToRequestHeaderMatchConditionParameters(destination *v20210601s.RequestHeaderMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.RequestMethodMatchConditionParameters
// Deprecated version of RequestMethodMatchConditionParameters. Use v1beta20210601.RequestMethodMatchConditionParameters instead
type RequestMethodMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromRequestMethodMatchConditionParameters populates our RequestMethodMatchConditionParameters from the provided source RequestMethodMatchConditionParameters
func (parameters *RequestMethodMatchConditionParameters) AssignPropertiesFromRequestMethodMatchConditionParameters(source *v20210601s.RequestMethodMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRequestMethodMatchConditionParameters populates the provided destination RequestMethodMatchConditionParameters from our RequestMethodMatchConditionParameters
func (parameters *RequestMethodMatchConditionParameters) AssignPropertiesToRequestMethodMatchConditionParameters(destination *v20210601s.RequestMethodMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.RequestSchemeMatchConditionParameters
// Deprecated version of RequestSchemeMatchConditionParameters. Use v1beta20210601.RequestSchemeMatchConditionParameters instead
type RequestSchemeMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromRequestSchemeMatchConditionParameters populates our RequestSchemeMatchConditionParameters from the provided source RequestSchemeMatchConditionParameters
func (parameters *RequestSchemeMatchConditionParameters) AssignPropertiesFromRequestSchemeMatchConditionParameters(source *v20210601s.RequestSchemeMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRequestSchemeMatchConditionParameters populates the provided destination RequestSchemeMatchConditionParameters from our RequestSchemeMatchConditionParameters
func (parameters *RequestSchemeMatchConditionParameters) AssignPropertiesToRequestSchemeMatchConditionParameters(destination *v20210601s.RequestSchemeMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.RequestUriMatchConditionParameters
// Deprecated version of RequestUriMatchConditionParameters. Use v1beta20210601.RequestUriMatchConditionParameters instead
type RequestUriMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromRequestUriMatchConditionParameters populates our RequestUriMatchConditionParameters from the provided source RequestUriMatchConditionParameters
func (parameters *RequestUriMatchConditionParameters) AssignPropertiesFromRequestUriMatchConditionParameters(source *v20210601s.RequestUriMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRequestUriMatchConditionParameters populates the provided destination RequestUriMatchConditionParameters from our RequestUriMatchConditionParameters
func (parameters *RequestUriMatchConditionParameters) AssignPropertiesToRequestUriMatchConditionParameters(destination *v20210601s.RequestUriMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.RouteConfigurationOverrideActionParameters
// Deprecated version of RouteConfigurationOverrideActionParameters. Use v1beta20210601.RouteConfigurationOverrideActionParameters instead
type RouteConfigurationOverrideActionParameters struct {
	CacheConfiguration  *CacheConfiguration    `json:"cacheConfiguration,omitempty"`
	OriginGroupOverride *OriginGroupOverride   `json:"originGroupOverride,omitempty"`
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName            *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromRouteConfigurationOverrideActionParameters populates our RouteConfigurationOverrideActionParameters from the provided source RouteConfigurationOverrideActionParameters
func (parameters *RouteConfigurationOverrideActionParameters) AssignPropertiesFromRouteConfigurationOverrideActionParameters(source *v20210601s.RouteConfigurationOverrideActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheConfiguration
	if source.CacheConfiguration != nil {
		var cacheConfiguration CacheConfiguration
		err := cacheConfiguration.AssignPropertiesFromCacheConfiguration(source.CacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromCacheConfiguration() to populate field CacheConfiguration")
		}
		parameters.CacheConfiguration = &cacheConfiguration
	} else {
		parameters.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverride
		err := originGroupOverride.AssignPropertiesFromOriginGroupOverride(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromOriginGroupOverride() to populate field OriginGroupOverride")
		}
		parameters.OriginGroupOverride = &originGroupOverride
	} else {
		parameters.OriginGroupOverride = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToRouteConfigurationOverrideActionParameters populates the provided destination RouteConfigurationOverrideActionParameters from our RouteConfigurationOverrideActionParameters
func (parameters *RouteConfigurationOverrideActionParameters) AssignPropertiesToRouteConfigurationOverrideActionParameters(destination *v20210601s.RouteConfigurationOverrideActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CacheConfiguration
	if parameters.CacheConfiguration != nil {
		var cacheConfiguration v20210601s.CacheConfiguration
		err := parameters.CacheConfiguration.AssignPropertiesToCacheConfiguration(&cacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToCacheConfiguration() to populate field CacheConfiguration")
		}
		destination.CacheConfiguration = &cacheConfiguration
	} else {
		destination.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if parameters.OriginGroupOverride != nil {
		var originGroupOverride v20210601s.OriginGroupOverride
		err := parameters.OriginGroupOverride.AssignPropertiesToOriginGroupOverride(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToOriginGroupOverride() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.ServerPortMatchConditionParameters
// Deprecated version of ServerPortMatchConditionParameters. Use v1beta20210601.ServerPortMatchConditionParameters instead
type ServerPortMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromServerPortMatchConditionParameters populates our ServerPortMatchConditionParameters from the provided source ServerPortMatchConditionParameters
func (parameters *ServerPortMatchConditionParameters) AssignPropertiesFromServerPortMatchConditionParameters(source *v20210601s.ServerPortMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToServerPortMatchConditionParameters populates the provided destination ServerPortMatchConditionParameters from our ServerPortMatchConditionParameters
func (parameters *ServerPortMatchConditionParameters) AssignPropertiesToServerPortMatchConditionParameters(destination *v20210601s.ServerPortMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.SocketAddrMatchConditionParameters
// Deprecated version of SocketAddrMatchConditionParameters. Use v1beta20210601.SocketAddrMatchConditionParameters instead
type SocketAddrMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromSocketAddrMatchConditionParameters populates our SocketAddrMatchConditionParameters from the provided source SocketAddrMatchConditionParameters
func (parameters *SocketAddrMatchConditionParameters) AssignPropertiesFromSocketAddrMatchConditionParameters(source *v20210601s.SocketAddrMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSocketAddrMatchConditionParameters populates the provided destination SocketAddrMatchConditionParameters from our SocketAddrMatchConditionParameters
func (parameters *SocketAddrMatchConditionParameters) AssignPropertiesToSocketAddrMatchConditionParameters(destination *v20210601s.SocketAddrMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.SslProtocolMatchConditionParameters
// Deprecated version of SslProtocolMatchConditionParameters. Use v1beta20210601.SslProtocolMatchConditionParameters instead
type SslProtocolMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromSslProtocolMatchConditionParameters populates our SslProtocolMatchConditionParameters from the provided source SslProtocolMatchConditionParameters
func (parameters *SslProtocolMatchConditionParameters) AssignPropertiesFromSslProtocolMatchConditionParameters(source *v20210601s.SslProtocolMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSslProtocolMatchConditionParameters populates the provided destination SslProtocolMatchConditionParameters from our SslProtocolMatchConditionParameters
func (parameters *SslProtocolMatchConditionParameters) AssignPropertiesToSslProtocolMatchConditionParameters(destination *v20210601s.SslProtocolMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.UrlFileExtensionMatchConditionParameters
// Deprecated version of UrlFileExtensionMatchConditionParameters. Use v1beta20210601.UrlFileExtensionMatchConditionParameters instead
type UrlFileExtensionMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromUrlFileExtensionMatchConditionParameters populates our UrlFileExtensionMatchConditionParameters from the provided source UrlFileExtensionMatchConditionParameters
func (parameters *UrlFileExtensionMatchConditionParameters) AssignPropertiesFromUrlFileExtensionMatchConditionParameters(source *v20210601s.UrlFileExtensionMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUrlFileExtensionMatchConditionParameters populates the provided destination UrlFileExtensionMatchConditionParameters from our UrlFileExtensionMatchConditionParameters
func (parameters *UrlFileExtensionMatchConditionParameters) AssignPropertiesToUrlFileExtensionMatchConditionParameters(destination *v20210601s.UrlFileExtensionMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.UrlFileNameMatchConditionParameters
// Deprecated version of UrlFileNameMatchConditionParameters. Use v1beta20210601.UrlFileNameMatchConditionParameters instead
type UrlFileNameMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromUrlFileNameMatchConditionParameters populates our UrlFileNameMatchConditionParameters from the provided source UrlFileNameMatchConditionParameters
func (parameters *UrlFileNameMatchConditionParameters) AssignPropertiesFromUrlFileNameMatchConditionParameters(source *v20210601s.UrlFileNameMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUrlFileNameMatchConditionParameters populates the provided destination UrlFileNameMatchConditionParameters from our UrlFileNameMatchConditionParameters
func (parameters *UrlFileNameMatchConditionParameters) AssignPropertiesToUrlFileNameMatchConditionParameters(destination *v20210601s.UrlFileNameMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.UrlPathMatchConditionParameters
// Deprecated version of UrlPathMatchConditionParameters. Use v1beta20210601.UrlPathMatchConditionParameters instead
type UrlPathMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromUrlPathMatchConditionParameters populates our UrlPathMatchConditionParameters from the provided source UrlPathMatchConditionParameters
func (parameters *UrlPathMatchConditionParameters) AssignPropertiesFromUrlPathMatchConditionParameters(source *v20210601s.UrlPathMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUrlPathMatchConditionParameters populates the provided destination UrlPathMatchConditionParameters from our UrlPathMatchConditionParameters
func (parameters *UrlPathMatchConditionParameters) AssignPropertiesToUrlPathMatchConditionParameters(destination *v20210601s.UrlPathMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.UrlRedirectActionParameters
// Deprecated version of UrlRedirectActionParameters. Use v1beta20210601.UrlRedirectActionParameters instead
type UrlRedirectActionParameters struct {
	CustomFragment      *string                `json:"customFragment,omitempty"`
	CustomHostname      *string                `json:"customHostname,omitempty"`
	CustomPath          *string                `json:"customPath,omitempty"`
	CustomQueryString   *string                `json:"customQueryString,omitempty"`
	DestinationProtocol *string                `json:"destinationProtocol,omitempty"`
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RedirectType        *string                `json:"redirectType,omitempty"`
	TypeName            *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromUrlRedirectActionParameters populates our UrlRedirectActionParameters from the provided source UrlRedirectActionParameters
func (parameters *UrlRedirectActionParameters) AssignPropertiesFromUrlRedirectActionParameters(source *v20210601s.UrlRedirectActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CustomFragment
	parameters.CustomFragment = genruntime.ClonePointerToString(source.CustomFragment)

	// CustomHostname
	parameters.CustomHostname = genruntime.ClonePointerToString(source.CustomHostname)

	// CustomPath
	parameters.CustomPath = genruntime.ClonePointerToString(source.CustomPath)

	// CustomQueryString
	parameters.CustomQueryString = genruntime.ClonePointerToString(source.CustomQueryString)

	// DestinationProtocol
	parameters.DestinationProtocol = genruntime.ClonePointerToString(source.DestinationProtocol)

	// RedirectType
	parameters.RedirectType = genruntime.ClonePointerToString(source.RedirectType)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUrlRedirectActionParameters populates the provided destination UrlRedirectActionParameters from our UrlRedirectActionParameters
func (parameters *UrlRedirectActionParameters) AssignPropertiesToUrlRedirectActionParameters(destination *v20210601s.UrlRedirectActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CustomFragment
	destination.CustomFragment = genruntime.ClonePointerToString(parameters.CustomFragment)

	// CustomHostname
	destination.CustomHostname = genruntime.ClonePointerToString(parameters.CustomHostname)

	// CustomPath
	destination.CustomPath = genruntime.ClonePointerToString(parameters.CustomPath)

	// CustomQueryString
	destination.CustomQueryString = genruntime.ClonePointerToString(parameters.CustomQueryString)

	// DestinationProtocol
	destination.DestinationProtocol = genruntime.ClonePointerToString(parameters.DestinationProtocol)

	// RedirectType
	destination.RedirectType = genruntime.ClonePointerToString(parameters.RedirectType)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.UrlRewriteActionParameters
// Deprecated version of UrlRewriteActionParameters. Use v1beta20210601.UrlRewriteActionParameters instead
type UrlRewriteActionParameters struct {
	Destination           *string                `json:"destination,omitempty"`
	PreserveUnmatchedPath *bool                  `json:"preserveUnmatchedPath,omitempty"`
	PropertyBag           genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SourcePattern         *string                `json:"sourcePattern,omitempty"`
	TypeName              *string                `json:"typeName,omitempty"`
}

// AssignPropertiesFromUrlRewriteActionParameters populates our UrlRewriteActionParameters from the provided source UrlRewriteActionParameters
func (parameters *UrlRewriteActionParameters) AssignPropertiesFromUrlRewriteActionParameters(source *v20210601s.UrlRewriteActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Destination
	parameters.Destination = genruntime.ClonePointerToString(source.Destination)

	// PreserveUnmatchedPath
	if source.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *source.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		parameters.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	parameters.SourcePattern = genruntime.ClonePointerToString(source.SourcePattern)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUrlRewriteActionParameters populates the provided destination UrlRewriteActionParameters from our UrlRewriteActionParameters
func (parameters *UrlRewriteActionParameters) AssignPropertiesToUrlRewriteActionParameters(destination *v20210601s.UrlRewriteActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Destination
	destination.Destination = genruntime.ClonePointerToString(parameters.Destination)

	// PreserveUnmatchedPath
	if parameters.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *parameters.PreserveUnmatchedPath
		destination.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		destination.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	destination.SourcePattern = genruntime.ClonePointerToString(parameters.SourcePattern)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.UrlSigningActionParameters
// Deprecated version of UrlSigningActionParameters. Use v1beta20210601.UrlSigningActionParameters instead
type UrlSigningActionParameters struct {
	Algorithm             *string                     `json:"algorithm,omitempty"`
	ParameterNameOverride []UrlSigningParamIdentifier `json:"parameterNameOverride,omitempty"`
	PropertyBag           genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	TypeName              *string                     `json:"typeName,omitempty"`
}

// AssignPropertiesFromUrlSigningActionParameters populates our UrlSigningActionParameters from the provided source UrlSigningActionParameters
func (parameters *UrlSigningActionParameters) AssignPropertiesFromUrlSigningActionParameters(source *v20210601s.UrlSigningActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Algorithm
	parameters.Algorithm = genruntime.ClonePointerToString(source.Algorithm)

	// ParameterNameOverride
	if source.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]UrlSigningParamIdentifier, len(source.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range source.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride UrlSigningParamIdentifier
			err := parameterNameOverride.AssignPropertiesFromUrlSigningParamIdentifier(&parameterNameOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromUrlSigningParamIdentifier() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		parameters.ParameterNameOverride = parameterNameOverrideList
	} else {
		parameters.ParameterNameOverride = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUrlSigningActionParameters populates the provided destination UrlSigningActionParameters from our UrlSigningActionParameters
func (parameters *UrlSigningActionParameters) AssignPropertiesToUrlSigningActionParameters(destination *v20210601s.UrlSigningActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Algorithm
	destination.Algorithm = genruntime.ClonePointerToString(parameters.Algorithm)

	// ParameterNameOverride
	if parameters.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]v20210601s.UrlSigningParamIdentifier, len(parameters.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range parameters.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride v20210601s.UrlSigningParamIdentifier
			err := parameterNameOverrideItem.AssignPropertiesToUrlSigningParamIdentifier(&parameterNameOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToUrlSigningParamIdentifier() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		destination.ParameterNameOverride = parameterNameOverrideList
	} else {
		destination.ParameterNameOverride = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.CacheConfiguration
// Deprecated version of CacheConfiguration. Use v1beta20210601.CacheConfiguration instead
type CacheConfiguration struct {
	CacheBehavior              *string                `json:"cacheBehavior,omitempty"`
	CacheDuration              *string                `json:"cacheDuration,omitempty"`
	IsCompressionEnabled       *string                `json:"isCompressionEnabled,omitempty"`
	PropertyBag                genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	QueryParameters            *string                `json:"queryParameters,omitempty"`
	QueryStringCachingBehavior *string                `json:"queryStringCachingBehavior,omitempty"`
}

// AssignPropertiesFromCacheConfiguration populates our CacheConfiguration from the provided source CacheConfiguration
func (configuration *CacheConfiguration) AssignPropertiesFromCacheConfiguration(source *v20210601s.CacheConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheBehavior
	configuration.CacheBehavior = genruntime.ClonePointerToString(source.CacheBehavior)

	// CacheDuration
	configuration.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// IsCompressionEnabled
	configuration.IsCompressionEnabled = genruntime.ClonePointerToString(source.IsCompressionEnabled)

	// QueryParameters
	configuration.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringCachingBehavior
	configuration.QueryStringCachingBehavior = genruntime.ClonePointerToString(source.QueryStringCachingBehavior)

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCacheConfiguration populates the provided destination CacheConfiguration from our CacheConfiguration
func (configuration *CacheConfiguration) AssignPropertiesToCacheConfiguration(destination *v20210601s.CacheConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// CacheBehavior
	destination.CacheBehavior = genruntime.ClonePointerToString(configuration.CacheBehavior)

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(configuration.CacheDuration)

	// IsCompressionEnabled
	destination.IsCompressionEnabled = genruntime.ClonePointerToString(configuration.IsCompressionEnabled)

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(configuration.QueryParameters)

	// QueryStringCachingBehavior
	destination.QueryStringCachingBehavior = genruntime.ClonePointerToString(configuration.QueryStringCachingBehavior)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.OriginGroupOverride
// Deprecated version of OriginGroupOverride. Use v1beta20210601.OriginGroupOverride instead
type OriginGroupOverride struct {
	ForwardingProtocol *string                `json:"forwardingProtocol,omitempty"`
	OriginGroup        *ResourceReference     `json:"originGroup,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromOriginGroupOverride populates our OriginGroupOverride from the provided source OriginGroupOverride
func (override *OriginGroupOverride) AssignPropertiesFromOriginGroupOverride(source *v20210601s.OriginGroupOverride) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ForwardingProtocol
	override.ForwardingProtocol = genruntime.ClonePointerToString(source.ForwardingProtocol)

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference
		err := originGroup.AssignPropertiesFromResourceReference(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceReference() to populate field OriginGroup")
		}
		override.OriginGroup = &originGroup
	} else {
		override.OriginGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		override.PropertyBag = propertyBag
	} else {
		override.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToOriginGroupOverride populates the provided destination OriginGroupOverride from our OriginGroupOverride
func (override *OriginGroupOverride) AssignPropertiesToOriginGroupOverride(destination *v20210601s.OriginGroupOverride) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(override.PropertyBag)

	// ForwardingProtocol
	destination.ForwardingProtocol = genruntime.ClonePointerToString(override.ForwardingProtocol)

	// OriginGroup
	if override.OriginGroup != nil {
		var originGroup v20210601s.ResourceReference
		err := override.OriginGroup.AssignPropertiesToResourceReference(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceReference() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210601.UrlSigningParamIdentifier
// Deprecated version of UrlSigningParamIdentifier. Use v1beta20210601.UrlSigningParamIdentifier instead
type UrlSigningParamIdentifier struct {
	ParamIndicator *string                `json:"paramIndicator,omitempty"`
	ParamName      *string                `json:"paramName,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignPropertiesFromUrlSigningParamIdentifier populates our UrlSigningParamIdentifier from the provided source UrlSigningParamIdentifier
func (identifier *UrlSigningParamIdentifier) AssignPropertiesFromUrlSigningParamIdentifier(source *v20210601s.UrlSigningParamIdentifier) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ParamIndicator
	identifier.ParamIndicator = genruntime.ClonePointerToString(source.ParamIndicator)

	// ParamName
	identifier.ParamName = genruntime.ClonePointerToString(source.ParamName)

	// Update the property bag
	if len(propertyBag) > 0 {
		identifier.PropertyBag = propertyBag
	} else {
		identifier.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUrlSigningParamIdentifier populates the provided destination UrlSigningParamIdentifier from our UrlSigningParamIdentifier
func (identifier *UrlSigningParamIdentifier) AssignPropertiesToUrlSigningParamIdentifier(destination *v20210601s.UrlSigningParamIdentifier) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identifier.PropertyBag)

	// ParamIndicator
	destination.ParamIndicator = genruntime.ClonePointerToString(identifier.ParamIndicator)

	// ParamName
	destination.ParamName = genruntime.ClonePointerToString(identifier.ParamName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&ProfilesEndpoint{}, &ProfilesEndpointList{})
}
