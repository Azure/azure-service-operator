// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"fmt"
	v20210601s "github.com/Azure/azure-service-operator/v2/api/cdn/v1api20210601/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1beta20210601.ProfilesEndpoint
// Deprecated version of ProfilesEndpoint. Use v1api20210601.ProfilesEndpoint instead
type ProfilesEndpoint struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Profiles_Endpoint_Spec   `json:"spec,omitempty"`
	Status            Profiles_Endpoint_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ProfilesEndpoint{}

// GetConditions returns the conditions of the resource
func (endpoint *ProfilesEndpoint) GetConditions() conditions.Conditions {
	return endpoint.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (endpoint *ProfilesEndpoint) SetConditions(conditions conditions.Conditions) {
	endpoint.Status.Conditions = conditions
}

var _ conversion.Convertible = &ProfilesEndpoint{}

// ConvertFrom populates our ProfilesEndpoint from the provided hub ProfilesEndpoint
func (endpoint *ProfilesEndpoint) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20210601s.ProfilesEndpoint)
	if !ok {
		return fmt.Errorf("expected cdn/v1api20210601/storage/ProfilesEndpoint but received %T instead", hub)
	}

	return endpoint.AssignProperties_From_ProfilesEndpoint(source)
}

// ConvertTo populates the provided hub ProfilesEndpoint from our ProfilesEndpoint
func (endpoint *ProfilesEndpoint) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20210601s.ProfilesEndpoint)
	if !ok {
		return fmt.Errorf("expected cdn/v1api20210601/storage/ProfilesEndpoint but received %T instead", hub)
	}

	return endpoint.AssignProperties_To_ProfilesEndpoint(destination)
}

var _ genruntime.KubernetesResource = &ProfilesEndpoint{}

// AzureName returns the Azure name of the resource
func (endpoint *ProfilesEndpoint) AzureName() string {
	return endpoint.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-06-01"
func (endpoint ProfilesEndpoint) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (endpoint *ProfilesEndpoint) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (endpoint *ProfilesEndpoint) GetSpec() genruntime.ConvertibleSpec {
	return &endpoint.Spec
}

// GetStatus returns the status of this resource
func (endpoint *ProfilesEndpoint) GetStatus() genruntime.ConvertibleStatus {
	return &endpoint.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (endpoint *ProfilesEndpoint) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.Cdn/profiles/endpoints"
func (endpoint *ProfilesEndpoint) GetType() string {
	return "Microsoft.Cdn/profiles/endpoints"
}

// NewEmptyStatus returns a new empty (blank) status
func (endpoint *ProfilesEndpoint) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Profiles_Endpoint_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (endpoint *ProfilesEndpoint) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(endpoint.Spec)
	return endpoint.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (endpoint *ProfilesEndpoint) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Profiles_Endpoint_STATUS); ok {
		endpoint.Status = *st
		return nil
	}

	// Convert status to required version
	var st Profiles_Endpoint_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	endpoint.Status = st
	return nil
}

// AssignProperties_From_ProfilesEndpoint populates our ProfilesEndpoint from the provided source ProfilesEndpoint
func (endpoint *ProfilesEndpoint) AssignProperties_From_ProfilesEndpoint(source *v20210601s.ProfilesEndpoint) error {

	// ObjectMeta
	endpoint.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Profiles_Endpoint_Spec
	err := spec.AssignProperties_From_Profiles_Endpoint_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Profiles_Endpoint_Spec() to populate field Spec")
	}
	endpoint.Spec = spec

	// Status
	var status Profiles_Endpoint_STATUS
	err = status.AssignProperties_From_Profiles_Endpoint_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_Profiles_Endpoint_STATUS() to populate field Status")
	}
	endpoint.Status = status

	// Invoke the augmentConversionForProfilesEndpoint interface (if implemented) to customize the conversion
	var endpointAsAny any = endpoint
	if augmentedEndpoint, ok := endpointAsAny.(augmentConversionForProfilesEndpoint); ok {
		err := augmentedEndpoint.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ProfilesEndpoint populates the provided destination ProfilesEndpoint from our ProfilesEndpoint
func (endpoint *ProfilesEndpoint) AssignProperties_To_ProfilesEndpoint(destination *v20210601s.ProfilesEndpoint) error {

	// ObjectMeta
	destination.ObjectMeta = *endpoint.ObjectMeta.DeepCopy()

	// Spec
	var spec v20210601s.Profiles_Endpoint_Spec
	err := endpoint.Spec.AssignProperties_To_Profiles_Endpoint_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Profiles_Endpoint_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20210601s.Profiles_Endpoint_STATUS
	err = endpoint.Status.AssignProperties_To_Profiles_Endpoint_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_Profiles_Endpoint_STATUS() to populate field Status")
	}
	destination.Status = status

	// Invoke the augmentConversionForProfilesEndpoint interface (if implemented) to customize the conversion
	var endpointAsAny any = endpoint
	if augmentedEndpoint, ok := endpointAsAny.(augmentConversionForProfilesEndpoint); ok {
		err := augmentedEndpoint.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (endpoint *ProfilesEndpoint) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: endpoint.Spec.OriginalVersion,
		Kind:    "ProfilesEndpoint",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1beta20210601.ProfilesEndpoint
// Deprecated version of ProfilesEndpoint. Use v1api20210601.ProfilesEndpoint instead
type ProfilesEndpointList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProfilesEndpoint `json:"items"`
}

type augmentConversionForProfilesEndpoint interface {
	AssignPropertiesFrom(src *v20210601s.ProfilesEndpoint) error
	AssignPropertiesTo(dst *v20210601s.ProfilesEndpoint) error
}

// Storage version of v1beta20210601.Profiles_Endpoint_Spec
type Profiles_Endpoint_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName              string                             `json:"azureName,omitempty"`
	ContentTypesToCompress []string                           `json:"contentTypesToCompress,omitempty"`
	DefaultOriginGroup     *ResourceReference                 `json:"defaultOriginGroup,omitempty"`
	DeliveryPolicy         *EndpointProperties_DeliveryPolicy `json:"deliveryPolicy,omitempty"`
	GeoFilters             []GeoFilter                        `json:"geoFilters,omitempty"`
	IsCompressionEnabled   *bool                              `json:"isCompressionEnabled,omitempty"`
	IsHttpAllowed          *bool                              `json:"isHttpAllowed,omitempty"`
	IsHttpsAllowed         *bool                              `json:"isHttpsAllowed,omitempty"`
	Location               *string                            `json:"location,omitempty"`
	OptimizationType       *string                            `json:"optimizationType,omitempty"`
	OriginGroups           []DeepCreatedOriginGroup           `json:"originGroups,omitempty"`
	OriginHostHeader       *string                            `json:"originHostHeader,omitempty"`
	OriginPath             *string                            `json:"originPath,omitempty"`
	OriginalVersion        string                             `json:"originalVersion,omitempty"`
	Origins                []DeepCreatedOrigin                `json:"origins,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a cdn.azure.com/Profile resource
	Owner                            *genruntime.KnownResourceReference                   `group:"cdn.azure.com" json:"owner,omitempty" kind:"Profile"`
	ProbePath                        *string                                              `json:"probePath,omitempty"`
	PropertyBag                      genruntime.PropertyBag                               `json:"$propertyBag,omitempty"`
	QueryStringCachingBehavior       *string                                              `json:"queryStringCachingBehavior,omitempty"`
	Tags                             map[string]string                                    `json:"tags,omitempty"`
	UrlSigningKeys                   []UrlSigningKey                                      `json:"urlSigningKeys,omitempty"`
	WebApplicationFirewallPolicyLink *EndpointProperties_WebApplicationFirewallPolicyLink `json:"webApplicationFirewallPolicyLink,omitempty"`
}

var _ genruntime.ConvertibleSpec = &Profiles_Endpoint_Spec{}

// ConvertSpecFrom populates our Profiles_Endpoint_Spec from the provided source
func (endpoint *Profiles_Endpoint_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20210601s.Profiles_Endpoint_Spec)
	if ok {
		// Populate our instance from source
		return endpoint.AssignProperties_From_Profiles_Endpoint_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20210601s.Profiles_Endpoint_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignProperties_From_Profiles_Endpoint_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Profiles_Endpoint_Spec
func (endpoint *Profiles_Endpoint_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20210601s.Profiles_Endpoint_Spec)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignProperties_To_Profiles_Endpoint_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20210601s.Profiles_Endpoint_Spec{}
	err := endpoint.AssignProperties_To_Profiles_Endpoint_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_Profiles_Endpoint_Spec populates our Profiles_Endpoint_Spec from the provided source Profiles_Endpoint_Spec
func (endpoint *Profiles_Endpoint_Spec) AssignProperties_From_Profiles_Endpoint_Spec(source *v20210601s.Profiles_Endpoint_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AzureName
	endpoint.AzureName = source.AzureName

	// ContentTypesToCompress
	endpoint.ContentTypesToCompress = genruntime.CloneSliceOfString(source.ContentTypesToCompress)

	// DefaultOriginGroup
	if source.DefaultOriginGroup != nil {
		var defaultOriginGroup ResourceReference
		err := defaultOriginGroup.AssignProperties_From_ResourceReference(source.DefaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field DefaultOriginGroup")
		}
		endpoint.DefaultOriginGroup = &defaultOriginGroup
	} else {
		endpoint.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if source.DeliveryPolicy != nil {
		var deliveryPolicy EndpointProperties_DeliveryPolicy
		err := deliveryPolicy.AssignProperties_From_EndpointProperties_DeliveryPolicy(source.DeliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_DeliveryPolicy() to populate field DeliveryPolicy")
		}
		endpoint.DeliveryPolicy = &deliveryPolicy
	} else {
		endpoint.DeliveryPolicy = nil
	}

	// GeoFilters
	if source.GeoFilters != nil {
		geoFilterList := make([]GeoFilter, len(source.GeoFilters))
		for geoFilterIndex, geoFilterItem := range source.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter GeoFilter
			err := geoFilter.AssignProperties_From_GeoFilter(&geoFilterItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_GeoFilter() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		endpoint.GeoFilters = geoFilterList
	} else {
		endpoint.GeoFilters = nil
	}

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := *source.IsCompressionEnabled
		endpoint.IsCompressionEnabled = &isCompressionEnabled
	} else {
		endpoint.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if source.IsHttpAllowed != nil {
		isHttpAllowed := *source.IsHttpAllowed
		endpoint.IsHttpAllowed = &isHttpAllowed
	} else {
		endpoint.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if source.IsHttpsAllowed != nil {
		isHttpsAllowed := *source.IsHttpsAllowed
		endpoint.IsHttpsAllowed = &isHttpsAllowed
	} else {
		endpoint.IsHttpsAllowed = nil
	}

	// Location
	endpoint.Location = genruntime.ClonePointerToString(source.Location)

	// OptimizationType
	endpoint.OptimizationType = genruntime.ClonePointerToString(source.OptimizationType)

	// OriginGroups
	if source.OriginGroups != nil {
		originGroupList := make([]DeepCreatedOriginGroup, len(source.OriginGroups))
		for originGroupIndex, originGroupItem := range source.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup DeepCreatedOriginGroup
			err := originGroup.AssignProperties_From_DeepCreatedOriginGroup(&originGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeepCreatedOriginGroup() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		endpoint.OriginGroups = originGroupList
	} else {
		endpoint.OriginGroups = nil
	}

	// OriginHostHeader
	endpoint.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// OriginPath
	endpoint.OriginPath = genruntime.ClonePointerToString(source.OriginPath)

	// OriginalVersion
	endpoint.OriginalVersion = source.OriginalVersion

	// Origins
	if source.Origins != nil {
		originList := make([]DeepCreatedOrigin, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin DeepCreatedOrigin
			err := origin.AssignProperties_From_DeepCreatedOrigin(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeepCreatedOrigin() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		endpoint.Origins = originList
	} else {
		endpoint.Origins = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		endpoint.Owner = &owner
	} else {
		endpoint.Owner = nil
	}

	// ProbePath
	endpoint.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// QueryStringCachingBehavior
	endpoint.QueryStringCachingBehavior = genruntime.ClonePointerToString(source.QueryStringCachingBehavior)

	// Tags
	endpoint.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// UrlSigningKeys
	if source.UrlSigningKeys != nil {
		urlSigningKeyList := make([]UrlSigningKey, len(source.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range source.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey UrlSigningKey
			err := urlSigningKey.AssignProperties_From_UrlSigningKey(&urlSigningKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UrlSigningKey() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		endpoint.UrlSigningKeys = urlSigningKeyList
	} else {
		endpoint.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if source.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink EndpointProperties_WebApplicationFirewallPolicyLink
		err := webApplicationFirewallPolicyLink.AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink(source.WebApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink() to populate field WebApplicationFirewallPolicyLink")
		}
		endpoint.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		endpoint.WebApplicationFirewallPolicyLink = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		endpoint.PropertyBag = propertyBag
	} else {
		endpoint.PropertyBag = nil
	}

	// Invoke the augmentConversionForProfiles_Endpoint_Spec interface (if implemented) to customize the conversion
	var endpointAsAny any = endpoint
	if augmentedEndpoint, ok := endpointAsAny.(augmentConversionForProfiles_Endpoint_Spec); ok {
		err := augmentedEndpoint.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Profiles_Endpoint_Spec populates the provided destination Profiles_Endpoint_Spec from our Profiles_Endpoint_Spec
func (endpoint *Profiles_Endpoint_Spec) AssignProperties_To_Profiles_Endpoint_Spec(destination *v20210601s.Profiles_Endpoint_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(endpoint.PropertyBag)

	// AzureName
	destination.AzureName = endpoint.AzureName

	// ContentTypesToCompress
	destination.ContentTypesToCompress = genruntime.CloneSliceOfString(endpoint.ContentTypesToCompress)

	// DefaultOriginGroup
	if endpoint.DefaultOriginGroup != nil {
		var defaultOriginGroup v20210601s.ResourceReference
		err := endpoint.DefaultOriginGroup.AssignProperties_To_ResourceReference(&defaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field DefaultOriginGroup")
		}
		destination.DefaultOriginGroup = &defaultOriginGroup
	} else {
		destination.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if endpoint.DeliveryPolicy != nil {
		var deliveryPolicy v20210601s.EndpointProperties_DeliveryPolicy
		err := endpoint.DeliveryPolicy.AssignProperties_To_EndpointProperties_DeliveryPolicy(&deliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_DeliveryPolicy() to populate field DeliveryPolicy")
		}
		destination.DeliveryPolicy = &deliveryPolicy
	} else {
		destination.DeliveryPolicy = nil
	}

	// GeoFilters
	if endpoint.GeoFilters != nil {
		geoFilterList := make([]v20210601s.GeoFilter, len(endpoint.GeoFilters))
		for geoFilterIndex, geoFilterItem := range endpoint.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter v20210601s.GeoFilter
			err := geoFilterItem.AssignProperties_To_GeoFilter(&geoFilter)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_GeoFilter() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		destination.GeoFilters = geoFilterList
	} else {
		destination.GeoFilters = nil
	}

	// IsCompressionEnabled
	if endpoint.IsCompressionEnabled != nil {
		isCompressionEnabled := *endpoint.IsCompressionEnabled
		destination.IsCompressionEnabled = &isCompressionEnabled
	} else {
		destination.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if endpoint.IsHttpAllowed != nil {
		isHttpAllowed := *endpoint.IsHttpAllowed
		destination.IsHttpAllowed = &isHttpAllowed
	} else {
		destination.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if endpoint.IsHttpsAllowed != nil {
		isHttpsAllowed := *endpoint.IsHttpsAllowed
		destination.IsHttpsAllowed = &isHttpsAllowed
	} else {
		destination.IsHttpsAllowed = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(endpoint.Location)

	// OptimizationType
	destination.OptimizationType = genruntime.ClonePointerToString(endpoint.OptimizationType)

	// OriginGroups
	if endpoint.OriginGroups != nil {
		originGroupList := make([]v20210601s.DeepCreatedOriginGroup, len(endpoint.OriginGroups))
		for originGroupIndex, originGroupItem := range endpoint.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup v20210601s.DeepCreatedOriginGroup
			err := originGroupItem.AssignProperties_To_DeepCreatedOriginGroup(&originGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeepCreatedOriginGroup() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		destination.OriginGroups = originGroupList
	} else {
		destination.OriginGroups = nil
	}

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(endpoint.OriginHostHeader)

	// OriginPath
	destination.OriginPath = genruntime.ClonePointerToString(endpoint.OriginPath)

	// OriginalVersion
	destination.OriginalVersion = endpoint.OriginalVersion

	// Origins
	if endpoint.Origins != nil {
		originList := make([]v20210601s.DeepCreatedOrigin, len(endpoint.Origins))
		for originIndex, originItem := range endpoint.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin v20210601s.DeepCreatedOrigin
			err := originItem.AssignProperties_To_DeepCreatedOrigin(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeepCreatedOrigin() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// Owner
	if endpoint.Owner != nil {
		owner := endpoint.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(endpoint.ProbePath)

	// QueryStringCachingBehavior
	destination.QueryStringCachingBehavior = genruntime.ClonePointerToString(endpoint.QueryStringCachingBehavior)

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(endpoint.Tags)

	// UrlSigningKeys
	if endpoint.UrlSigningKeys != nil {
		urlSigningKeyList := make([]v20210601s.UrlSigningKey, len(endpoint.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range endpoint.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey v20210601s.UrlSigningKey
			err := urlSigningKeyItem.AssignProperties_To_UrlSigningKey(&urlSigningKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UrlSigningKey() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		destination.UrlSigningKeys = urlSigningKeyList
	} else {
		destination.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if endpoint.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink
		err := endpoint.WebApplicationFirewallPolicyLink.AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink(&webApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink() to populate field WebApplicationFirewallPolicyLink")
		}
		destination.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		destination.WebApplicationFirewallPolicyLink = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForProfiles_Endpoint_Spec interface (if implemented) to customize the conversion
	var endpointAsAny any = endpoint
	if augmentedEndpoint, ok := endpointAsAny.(augmentConversionForProfiles_Endpoint_Spec); ok {
		err := augmentedEndpoint.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.Profiles_Endpoint_STATUS
// Deprecated version of Profiles_Endpoint_STATUS. Use v1api20210601.Profiles_Endpoint_STATUS instead
type Profiles_Endpoint_STATUS struct {
	Conditions                       []conditions.Condition                                      `json:"conditions,omitempty"`
	ContentTypesToCompress           []string                                                    `json:"contentTypesToCompress,omitempty"`
	CustomDomains                    []DeepCreatedCustomDomain_STATUS                            `json:"customDomains,omitempty"`
	DefaultOriginGroup               *ResourceReference_STATUS                                   `json:"defaultOriginGroup,omitempty"`
	DeliveryPolicy                   *EndpointProperties_DeliveryPolicy_STATUS                   `json:"deliveryPolicy,omitempty"`
	GeoFilters                       []GeoFilter_STATUS                                          `json:"geoFilters,omitempty"`
	HostName                         *string                                                     `json:"hostName,omitempty"`
	Id                               *string                                                     `json:"id,omitempty"`
	IsCompressionEnabled             *bool                                                       `json:"isCompressionEnabled,omitempty"`
	IsHttpAllowed                    *bool                                                       `json:"isHttpAllowed,omitempty"`
	IsHttpsAllowed                   *bool                                                       `json:"isHttpsAllowed,omitempty"`
	Location                         *string                                                     `json:"location,omitempty"`
	Name                             *string                                                     `json:"name,omitempty"`
	OptimizationType                 *string                                                     `json:"optimizationType,omitempty"`
	OriginGroups                     []DeepCreatedOriginGroup_STATUS                             `json:"originGroups,omitempty"`
	OriginHostHeader                 *string                                                     `json:"originHostHeader,omitempty"`
	OriginPath                       *string                                                     `json:"originPath,omitempty"`
	Origins                          []DeepCreatedOrigin_STATUS                                  `json:"origins,omitempty"`
	ProbePath                        *string                                                     `json:"probePath,omitempty"`
	PropertyBag                      genruntime.PropertyBag                                      `json:"$propertyBag,omitempty"`
	ProvisioningState                *string                                                     `json:"provisioningState,omitempty"`
	QueryStringCachingBehavior       *string                                                     `json:"queryStringCachingBehavior,omitempty"`
	ResourceState                    *string                                                     `json:"resourceState,omitempty"`
	SystemData                       *SystemData_STATUS                                          `json:"systemData,omitempty"`
	Tags                             map[string]string                                           `json:"tags,omitempty"`
	Type                             *string                                                     `json:"type,omitempty"`
	UrlSigningKeys                   []UrlSigningKey_STATUS                                      `json:"urlSigningKeys,omitempty"`
	WebApplicationFirewallPolicyLink *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS `json:"webApplicationFirewallPolicyLink,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Profiles_Endpoint_STATUS{}

// ConvertStatusFrom populates our Profiles_Endpoint_STATUS from the provided source
func (endpoint *Profiles_Endpoint_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20210601s.Profiles_Endpoint_STATUS)
	if ok {
		// Populate our instance from source
		return endpoint.AssignProperties_From_Profiles_Endpoint_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20210601s.Profiles_Endpoint_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignProperties_From_Profiles_Endpoint_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Profiles_Endpoint_STATUS
func (endpoint *Profiles_Endpoint_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20210601s.Profiles_Endpoint_STATUS)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignProperties_To_Profiles_Endpoint_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20210601s.Profiles_Endpoint_STATUS{}
	err := endpoint.AssignProperties_To_Profiles_Endpoint_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

// AssignProperties_From_Profiles_Endpoint_STATUS populates our Profiles_Endpoint_STATUS from the provided source Profiles_Endpoint_STATUS
func (endpoint *Profiles_Endpoint_STATUS) AssignProperties_From_Profiles_Endpoint_STATUS(source *v20210601s.Profiles_Endpoint_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Conditions
	endpoint.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// ContentTypesToCompress
	endpoint.ContentTypesToCompress = genruntime.CloneSliceOfString(source.ContentTypesToCompress)

	// CustomDomains
	if source.CustomDomains != nil {
		customDomainList := make([]DeepCreatedCustomDomain_STATUS, len(source.CustomDomains))
		for customDomainIndex, customDomainItem := range source.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain DeepCreatedCustomDomain_STATUS
			err := customDomain.AssignProperties_From_DeepCreatedCustomDomain_STATUS(&customDomainItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeepCreatedCustomDomain_STATUS() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		endpoint.CustomDomains = customDomainList
	} else {
		endpoint.CustomDomains = nil
	}

	// DefaultOriginGroup
	if source.DefaultOriginGroup != nil {
		var defaultOriginGroup ResourceReference_STATUS
		err := defaultOriginGroup.AssignProperties_From_ResourceReference_STATUS(source.DefaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field DefaultOriginGroup")
		}
		endpoint.DefaultOriginGroup = &defaultOriginGroup
	} else {
		endpoint.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if source.DeliveryPolicy != nil {
		var deliveryPolicy EndpointProperties_DeliveryPolicy_STATUS
		err := deliveryPolicy.AssignProperties_From_EndpointProperties_DeliveryPolicy_STATUS(source.DeliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_DeliveryPolicy_STATUS() to populate field DeliveryPolicy")
		}
		endpoint.DeliveryPolicy = &deliveryPolicy
	} else {
		endpoint.DeliveryPolicy = nil
	}

	// GeoFilters
	if source.GeoFilters != nil {
		geoFilterList := make([]GeoFilter_STATUS, len(source.GeoFilters))
		for geoFilterIndex, geoFilterItem := range source.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter GeoFilter_STATUS
			err := geoFilter.AssignProperties_From_GeoFilter_STATUS(&geoFilterItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_GeoFilter_STATUS() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		endpoint.GeoFilters = geoFilterList
	} else {
		endpoint.GeoFilters = nil
	}

	// HostName
	endpoint.HostName = genruntime.ClonePointerToString(source.HostName)

	// Id
	endpoint.Id = genruntime.ClonePointerToString(source.Id)

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := *source.IsCompressionEnabled
		endpoint.IsCompressionEnabled = &isCompressionEnabled
	} else {
		endpoint.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if source.IsHttpAllowed != nil {
		isHttpAllowed := *source.IsHttpAllowed
		endpoint.IsHttpAllowed = &isHttpAllowed
	} else {
		endpoint.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if source.IsHttpsAllowed != nil {
		isHttpsAllowed := *source.IsHttpsAllowed
		endpoint.IsHttpsAllowed = &isHttpsAllowed
	} else {
		endpoint.IsHttpsAllowed = nil
	}

	// Location
	endpoint.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	endpoint.Name = genruntime.ClonePointerToString(source.Name)

	// OptimizationType
	endpoint.OptimizationType = genruntime.ClonePointerToString(source.OptimizationType)

	// OriginGroups
	if source.OriginGroups != nil {
		originGroupList := make([]DeepCreatedOriginGroup_STATUS, len(source.OriginGroups))
		for originGroupIndex, originGroupItem := range source.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup DeepCreatedOriginGroup_STATUS
			err := originGroup.AssignProperties_From_DeepCreatedOriginGroup_STATUS(&originGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeepCreatedOriginGroup_STATUS() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		endpoint.OriginGroups = originGroupList
	} else {
		endpoint.OriginGroups = nil
	}

	// OriginHostHeader
	endpoint.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// OriginPath
	endpoint.OriginPath = genruntime.ClonePointerToString(source.OriginPath)

	// Origins
	if source.Origins != nil {
		originList := make([]DeepCreatedOrigin_STATUS, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin DeepCreatedOrigin_STATUS
			err := origin.AssignProperties_From_DeepCreatedOrigin_STATUS(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeepCreatedOrigin_STATUS() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		endpoint.Origins = originList
	} else {
		endpoint.Origins = nil
	}

	// ProbePath
	endpoint.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProvisioningState
	endpoint.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// QueryStringCachingBehavior
	endpoint.QueryStringCachingBehavior = genruntime.ClonePointerToString(source.QueryStringCachingBehavior)

	// ResourceState
	endpoint.ResourceState = genruntime.ClonePointerToString(source.ResourceState)

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignProperties_From_SystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SystemData_STATUS() to populate field SystemData")
		}
		endpoint.SystemData = &systemDatum
	} else {
		endpoint.SystemData = nil
	}

	// Tags
	endpoint.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// UrlSigningKeys
	if source.UrlSigningKeys != nil {
		urlSigningKeyList := make([]UrlSigningKey_STATUS, len(source.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range source.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey UrlSigningKey_STATUS
			err := urlSigningKey.AssignProperties_From_UrlSigningKey_STATUS(&urlSigningKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UrlSigningKey_STATUS() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		endpoint.UrlSigningKeys = urlSigningKeyList
	} else {
		endpoint.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if source.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
		err := webApplicationFirewallPolicyLink.AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS(source.WebApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS() to populate field WebApplicationFirewallPolicyLink")
		}
		endpoint.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		endpoint.WebApplicationFirewallPolicyLink = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		endpoint.PropertyBag = propertyBag
	} else {
		endpoint.PropertyBag = nil
	}

	// Invoke the augmentConversionForProfiles_Endpoint_STATUS interface (if implemented) to customize the conversion
	var endpointAsAny any = endpoint
	if augmentedEndpoint, ok := endpointAsAny.(augmentConversionForProfiles_Endpoint_STATUS); ok {
		err := augmentedEndpoint.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_Profiles_Endpoint_STATUS populates the provided destination Profiles_Endpoint_STATUS from our Profiles_Endpoint_STATUS
func (endpoint *Profiles_Endpoint_STATUS) AssignProperties_To_Profiles_Endpoint_STATUS(destination *v20210601s.Profiles_Endpoint_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(endpoint.PropertyBag)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(endpoint.Conditions)

	// ContentTypesToCompress
	destination.ContentTypesToCompress = genruntime.CloneSliceOfString(endpoint.ContentTypesToCompress)

	// CustomDomains
	if endpoint.CustomDomains != nil {
		customDomainList := make([]v20210601s.DeepCreatedCustomDomain_STATUS, len(endpoint.CustomDomains))
		for customDomainIndex, customDomainItem := range endpoint.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain v20210601s.DeepCreatedCustomDomain_STATUS
			err := customDomainItem.AssignProperties_To_DeepCreatedCustomDomain_STATUS(&customDomain)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeepCreatedCustomDomain_STATUS() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		destination.CustomDomains = customDomainList
	} else {
		destination.CustomDomains = nil
	}

	// DefaultOriginGroup
	if endpoint.DefaultOriginGroup != nil {
		var defaultOriginGroup v20210601s.ResourceReference_STATUS
		err := endpoint.DefaultOriginGroup.AssignProperties_To_ResourceReference_STATUS(&defaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field DefaultOriginGroup")
		}
		destination.DefaultOriginGroup = &defaultOriginGroup
	} else {
		destination.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if endpoint.DeliveryPolicy != nil {
		var deliveryPolicy v20210601s.EndpointProperties_DeliveryPolicy_STATUS
		err := endpoint.DeliveryPolicy.AssignProperties_To_EndpointProperties_DeliveryPolicy_STATUS(&deliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_DeliveryPolicy_STATUS() to populate field DeliveryPolicy")
		}
		destination.DeliveryPolicy = &deliveryPolicy
	} else {
		destination.DeliveryPolicy = nil
	}

	// GeoFilters
	if endpoint.GeoFilters != nil {
		geoFilterList := make([]v20210601s.GeoFilter_STATUS, len(endpoint.GeoFilters))
		for geoFilterIndex, geoFilterItem := range endpoint.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter v20210601s.GeoFilter_STATUS
			err := geoFilterItem.AssignProperties_To_GeoFilter_STATUS(&geoFilter)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_GeoFilter_STATUS() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		destination.GeoFilters = geoFilterList
	} else {
		destination.GeoFilters = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(endpoint.HostName)

	// Id
	destination.Id = genruntime.ClonePointerToString(endpoint.Id)

	// IsCompressionEnabled
	if endpoint.IsCompressionEnabled != nil {
		isCompressionEnabled := *endpoint.IsCompressionEnabled
		destination.IsCompressionEnabled = &isCompressionEnabled
	} else {
		destination.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if endpoint.IsHttpAllowed != nil {
		isHttpAllowed := *endpoint.IsHttpAllowed
		destination.IsHttpAllowed = &isHttpAllowed
	} else {
		destination.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if endpoint.IsHttpsAllowed != nil {
		isHttpsAllowed := *endpoint.IsHttpsAllowed
		destination.IsHttpsAllowed = &isHttpsAllowed
	} else {
		destination.IsHttpsAllowed = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(endpoint.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(endpoint.Name)

	// OptimizationType
	destination.OptimizationType = genruntime.ClonePointerToString(endpoint.OptimizationType)

	// OriginGroups
	if endpoint.OriginGroups != nil {
		originGroupList := make([]v20210601s.DeepCreatedOriginGroup_STATUS, len(endpoint.OriginGroups))
		for originGroupIndex, originGroupItem := range endpoint.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup v20210601s.DeepCreatedOriginGroup_STATUS
			err := originGroupItem.AssignProperties_To_DeepCreatedOriginGroup_STATUS(&originGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeepCreatedOriginGroup_STATUS() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		destination.OriginGroups = originGroupList
	} else {
		destination.OriginGroups = nil
	}

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(endpoint.OriginHostHeader)

	// OriginPath
	destination.OriginPath = genruntime.ClonePointerToString(endpoint.OriginPath)

	// Origins
	if endpoint.Origins != nil {
		originList := make([]v20210601s.DeepCreatedOrigin_STATUS, len(endpoint.Origins))
		for originIndex, originItem := range endpoint.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin v20210601s.DeepCreatedOrigin_STATUS
			err := originItem.AssignProperties_To_DeepCreatedOrigin_STATUS(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeepCreatedOrigin_STATUS() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(endpoint.ProbePath)

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(endpoint.ProvisioningState)

	// QueryStringCachingBehavior
	destination.QueryStringCachingBehavior = genruntime.ClonePointerToString(endpoint.QueryStringCachingBehavior)

	// ResourceState
	destination.ResourceState = genruntime.ClonePointerToString(endpoint.ResourceState)

	// SystemData
	if endpoint.SystemData != nil {
		var systemDatum v20210601s.SystemData_STATUS
		err := endpoint.SystemData.AssignProperties_To_SystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(endpoint.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(endpoint.Type)

	// UrlSigningKeys
	if endpoint.UrlSigningKeys != nil {
		urlSigningKeyList := make([]v20210601s.UrlSigningKey_STATUS, len(endpoint.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range endpoint.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey v20210601s.UrlSigningKey_STATUS
			err := urlSigningKeyItem.AssignProperties_To_UrlSigningKey_STATUS(&urlSigningKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UrlSigningKey_STATUS() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		destination.UrlSigningKeys = urlSigningKeyList
	} else {
		destination.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if endpoint.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
		err := endpoint.WebApplicationFirewallPolicyLink.AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS(&webApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS() to populate field WebApplicationFirewallPolicyLink")
		}
		destination.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		destination.WebApplicationFirewallPolicyLink = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForProfiles_Endpoint_STATUS interface (if implemented) to customize the conversion
	var endpointAsAny any = endpoint
	if augmentedEndpoint, ok := endpointAsAny.(augmentConversionForProfiles_Endpoint_STATUS); ok {
		err := augmentedEndpoint.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForProfiles_Endpoint_Spec interface {
	AssignPropertiesFrom(src *v20210601s.Profiles_Endpoint_Spec) error
	AssignPropertiesTo(dst *v20210601s.Profiles_Endpoint_Spec) error
}

type augmentConversionForProfiles_Endpoint_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.Profiles_Endpoint_STATUS) error
	AssignPropertiesTo(dst *v20210601s.Profiles_Endpoint_STATUS) error
}

// Storage version of v1beta20210601.DeepCreatedCustomDomain_STATUS
// Deprecated version of DeepCreatedCustomDomain_STATUS. Use v1api20210601.DeepCreatedCustomDomain_STATUS instead
type DeepCreatedCustomDomain_STATUS struct {
	HostName       *string                `json:"hostName,omitempty"`
	Name           *string                `json:"name,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ValidationData *string                `json:"validationData,omitempty"`
}

// AssignProperties_From_DeepCreatedCustomDomain_STATUS populates our DeepCreatedCustomDomain_STATUS from the provided source DeepCreatedCustomDomain_STATUS
func (domain *DeepCreatedCustomDomain_STATUS) AssignProperties_From_DeepCreatedCustomDomain_STATUS(source *v20210601s.DeepCreatedCustomDomain_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HostName
	domain.HostName = genruntime.ClonePointerToString(source.HostName)

	// Name
	domain.Name = genruntime.ClonePointerToString(source.Name)

	// ValidationData
	domain.ValidationData = genruntime.ClonePointerToString(source.ValidationData)

	// Update the property bag
	if len(propertyBag) > 0 {
		domain.PropertyBag = propertyBag
	} else {
		domain.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeepCreatedCustomDomain_STATUS interface (if implemented) to customize the conversion
	var domainAsAny any = domain
	if augmentedDomain, ok := domainAsAny.(augmentConversionForDeepCreatedCustomDomain_STATUS); ok {
		err := augmentedDomain.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeepCreatedCustomDomain_STATUS populates the provided destination DeepCreatedCustomDomain_STATUS from our DeepCreatedCustomDomain_STATUS
func (domain *DeepCreatedCustomDomain_STATUS) AssignProperties_To_DeepCreatedCustomDomain_STATUS(destination *v20210601s.DeepCreatedCustomDomain_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(domain.PropertyBag)

	// HostName
	destination.HostName = genruntime.ClonePointerToString(domain.HostName)

	// Name
	destination.Name = genruntime.ClonePointerToString(domain.Name)

	// ValidationData
	destination.ValidationData = genruntime.ClonePointerToString(domain.ValidationData)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeepCreatedCustomDomain_STATUS interface (if implemented) to customize the conversion
	var domainAsAny any = domain
	if augmentedDomain, ok := domainAsAny.(augmentConversionForDeepCreatedCustomDomain_STATUS); ok {
		err := augmentedDomain.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeepCreatedOrigin
// Deprecated version of DeepCreatedOrigin. Use v1api20210601.DeepCreatedOrigin instead
type DeepCreatedOrigin struct {
	Enabled                      *bool                         `json:"enabled,omitempty"`
	HostName                     *string                       `json:"hostName,omitempty"`
	HttpPort                     *int                          `json:"httpPort,omitempty"`
	HttpsPort                    *int                          `json:"httpsPort,omitempty"`
	Name                         *string                       `json:"name,omitempty"`
	OriginHostHeader             *string                       `json:"originHostHeader,omitempty"`
	Priority                     *int                          `json:"priority,omitempty"`
	PrivateLinkAlias             *string                       `json:"privateLinkAlias,omitempty"`
	PrivateLinkApprovalMessage   *string                       `json:"privateLinkApprovalMessage,omitempty"`
	PrivateLinkLocationReference *genruntime.ResourceReference `armReference:"PrivateLinkLocation" json:"privateLinkLocationReference,omitempty"`
	PrivateLinkResourceReference *genruntime.ResourceReference `armReference:"PrivateLinkResourceId" json:"privateLinkResourceReference,omitempty"`
	PropertyBag                  genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Weight                       *int                          `json:"weight,omitempty"`
}

// AssignProperties_From_DeepCreatedOrigin populates our DeepCreatedOrigin from the provided source DeepCreatedOrigin
func (origin *DeepCreatedOrigin) AssignProperties_From_DeepCreatedOrigin(source *v20210601s.DeepCreatedOrigin) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		origin.Enabled = &enabled
	} else {
		origin.Enabled = nil
	}

	// HostName
	origin.HostName = genruntime.ClonePointerToString(source.HostName)

	// HttpPort
	origin.HttpPort = genruntime.ClonePointerToInt(source.HttpPort)

	// HttpsPort
	origin.HttpsPort = genruntime.ClonePointerToInt(source.HttpsPort)

	// Name
	origin.Name = genruntime.ClonePointerToString(source.Name)

	// OriginHostHeader
	origin.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// Priority
	origin.Priority = genruntime.ClonePointerToInt(source.Priority)

	// PrivateLinkAlias
	origin.PrivateLinkAlias = genruntime.ClonePointerToString(source.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	origin.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(source.PrivateLinkApprovalMessage)

	// PrivateLinkLocationReference
	if source.PrivateLinkLocationReference != nil {
		privateLinkLocationReference := source.PrivateLinkLocationReference.Copy()
		origin.PrivateLinkLocationReference = &privateLinkLocationReference
	} else {
		origin.PrivateLinkLocationReference = nil
	}

	// PrivateLinkResourceReference
	if source.PrivateLinkResourceReference != nil {
		privateLinkResourceReference := source.PrivateLinkResourceReference.Copy()
		origin.PrivateLinkResourceReference = &privateLinkResourceReference
	} else {
		origin.PrivateLinkResourceReference = nil
	}

	// Weight
	origin.Weight = genruntime.ClonePointerToInt(source.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		origin.PropertyBag = propertyBag
	} else {
		origin.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeepCreatedOrigin interface (if implemented) to customize the conversion
	var originAsAny any = origin
	if augmentedOrigin, ok := originAsAny.(augmentConversionForDeepCreatedOrigin); ok {
		err := augmentedOrigin.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeepCreatedOrigin populates the provided destination DeepCreatedOrigin from our DeepCreatedOrigin
func (origin *DeepCreatedOrigin) AssignProperties_To_DeepCreatedOrigin(destination *v20210601s.DeepCreatedOrigin) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// Enabled
	if origin.Enabled != nil {
		enabled := *origin.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(origin.HostName)

	// HttpPort
	destination.HttpPort = genruntime.ClonePointerToInt(origin.HttpPort)

	// HttpsPort
	destination.HttpsPort = genruntime.ClonePointerToInt(origin.HttpsPort)

	// Name
	destination.Name = genruntime.ClonePointerToString(origin.Name)

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(origin.OriginHostHeader)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(origin.Priority)

	// PrivateLinkAlias
	destination.PrivateLinkAlias = genruntime.ClonePointerToString(origin.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	destination.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(origin.PrivateLinkApprovalMessage)

	// PrivateLinkLocationReference
	if origin.PrivateLinkLocationReference != nil {
		privateLinkLocationReference := origin.PrivateLinkLocationReference.Copy()
		destination.PrivateLinkLocationReference = &privateLinkLocationReference
	} else {
		destination.PrivateLinkLocationReference = nil
	}

	// PrivateLinkResourceReference
	if origin.PrivateLinkResourceReference != nil {
		privateLinkResourceReference := origin.PrivateLinkResourceReference.Copy()
		destination.PrivateLinkResourceReference = &privateLinkResourceReference
	} else {
		destination.PrivateLinkResourceReference = nil
	}

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(origin.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeepCreatedOrigin interface (if implemented) to customize the conversion
	var originAsAny any = origin
	if augmentedOrigin, ok := originAsAny.(augmentConversionForDeepCreatedOrigin); ok {
		err := augmentedOrigin.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeepCreatedOrigin_STATUS
// Deprecated version of DeepCreatedOrigin_STATUS. Use v1api20210601.DeepCreatedOrigin_STATUS instead
type DeepCreatedOrigin_STATUS struct {
	Enabled                    *bool                  `json:"enabled,omitempty"`
	HostName                   *string                `json:"hostName,omitempty"`
	HttpPort                   *int                   `json:"httpPort,omitempty"`
	HttpsPort                  *int                   `json:"httpsPort,omitempty"`
	Name                       *string                `json:"name,omitempty"`
	OriginHostHeader           *string                `json:"originHostHeader,omitempty"`
	Priority                   *int                   `json:"priority,omitempty"`
	PrivateEndpointStatus      *string                `json:"privateEndpointStatus,omitempty"`
	PrivateLinkAlias           *string                `json:"privateLinkAlias,omitempty"`
	PrivateLinkApprovalMessage *string                `json:"privateLinkApprovalMessage,omitempty"`
	PrivateLinkLocation        *string                `json:"privateLinkLocation,omitempty"`
	PrivateLinkResourceId      *string                `json:"privateLinkResourceId,omitempty"`
	PropertyBag                genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Weight                     *int                   `json:"weight,omitempty"`
}

// AssignProperties_From_DeepCreatedOrigin_STATUS populates our DeepCreatedOrigin_STATUS from the provided source DeepCreatedOrigin_STATUS
func (origin *DeepCreatedOrigin_STATUS) AssignProperties_From_DeepCreatedOrigin_STATUS(source *v20210601s.DeepCreatedOrigin_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		origin.Enabled = &enabled
	} else {
		origin.Enabled = nil
	}

	// HostName
	origin.HostName = genruntime.ClonePointerToString(source.HostName)

	// HttpPort
	origin.HttpPort = genruntime.ClonePointerToInt(source.HttpPort)

	// HttpsPort
	origin.HttpsPort = genruntime.ClonePointerToInt(source.HttpsPort)

	// Name
	origin.Name = genruntime.ClonePointerToString(source.Name)

	// OriginHostHeader
	origin.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// Priority
	origin.Priority = genruntime.ClonePointerToInt(source.Priority)

	// PrivateEndpointStatus
	origin.PrivateEndpointStatus = genruntime.ClonePointerToString(source.PrivateEndpointStatus)

	// PrivateLinkAlias
	origin.PrivateLinkAlias = genruntime.ClonePointerToString(source.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	origin.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(source.PrivateLinkApprovalMessage)

	// PrivateLinkLocation
	origin.PrivateLinkLocation = genruntime.ClonePointerToString(source.PrivateLinkLocation)

	// PrivateLinkResourceId
	origin.PrivateLinkResourceId = genruntime.ClonePointerToString(source.PrivateLinkResourceId)

	// Weight
	origin.Weight = genruntime.ClonePointerToInt(source.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		origin.PropertyBag = propertyBag
	} else {
		origin.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeepCreatedOrigin_STATUS interface (if implemented) to customize the conversion
	var originAsAny any = origin
	if augmentedOrigin, ok := originAsAny.(augmentConversionForDeepCreatedOrigin_STATUS); ok {
		err := augmentedOrigin.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeepCreatedOrigin_STATUS populates the provided destination DeepCreatedOrigin_STATUS from our DeepCreatedOrigin_STATUS
func (origin *DeepCreatedOrigin_STATUS) AssignProperties_To_DeepCreatedOrigin_STATUS(destination *v20210601s.DeepCreatedOrigin_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(origin.PropertyBag)

	// Enabled
	if origin.Enabled != nil {
		enabled := *origin.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(origin.HostName)

	// HttpPort
	destination.HttpPort = genruntime.ClonePointerToInt(origin.HttpPort)

	// HttpsPort
	destination.HttpsPort = genruntime.ClonePointerToInt(origin.HttpsPort)

	// Name
	destination.Name = genruntime.ClonePointerToString(origin.Name)

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(origin.OriginHostHeader)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(origin.Priority)

	// PrivateEndpointStatus
	destination.PrivateEndpointStatus = genruntime.ClonePointerToString(origin.PrivateEndpointStatus)

	// PrivateLinkAlias
	destination.PrivateLinkAlias = genruntime.ClonePointerToString(origin.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	destination.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(origin.PrivateLinkApprovalMessage)

	// PrivateLinkLocation
	destination.PrivateLinkLocation = genruntime.ClonePointerToString(origin.PrivateLinkLocation)

	// PrivateLinkResourceId
	destination.PrivateLinkResourceId = genruntime.ClonePointerToString(origin.PrivateLinkResourceId)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(origin.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeepCreatedOrigin_STATUS interface (if implemented) to customize the conversion
	var originAsAny any = origin
	if augmentedOrigin, ok := originAsAny.(augmentConversionForDeepCreatedOrigin_STATUS); ok {
		err := augmentedOrigin.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeepCreatedOriginGroup
// Deprecated version of DeepCreatedOriginGroup. Use v1api20210601.DeepCreatedOriginGroup instead
type DeepCreatedOriginGroup struct {
	HealthProbeSettings                                   *HealthProbeParameters                       `json:"healthProbeSettings,omitempty"`
	Name                                                  *string                                      `json:"name,omitempty"`
	Origins                                               []ResourceReference                          `json:"origins,omitempty"`
	PropertyBag                                           genruntime.PropertyBag                       `json:"$propertyBag,omitempty"`
	ResponseBasedOriginErrorDetectionSettings             *ResponseBasedOriginErrorDetectionParameters `json:"responseBasedOriginErrorDetectionSettings,omitempty"`
	TrafficRestorationTimeToHealedOrNewEndpointsInMinutes *int                                         `json:"trafficRestorationTimeToHealedOrNewEndpointsInMinutes,omitempty"`
}

// AssignProperties_From_DeepCreatedOriginGroup populates our DeepCreatedOriginGroup from the provided source DeepCreatedOriginGroup
func (group *DeepCreatedOriginGroup) AssignProperties_From_DeepCreatedOriginGroup(source *v20210601s.DeepCreatedOriginGroup) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HealthProbeSettings
	if source.HealthProbeSettings != nil {
		var healthProbeSetting HealthProbeParameters
		err := healthProbeSetting.AssignProperties_From_HealthProbeParameters(source.HealthProbeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HealthProbeParameters() to populate field HealthProbeSettings")
		}
		group.HealthProbeSettings = &healthProbeSetting
	} else {
		group.HealthProbeSettings = nil
	}

	// Name
	group.Name = genruntime.ClonePointerToString(source.Name)

	// Origins
	if source.Origins != nil {
		originList := make([]ResourceReference, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin ResourceReference
			err := origin.AssignProperties_From_ResourceReference(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		group.Origins = originList
	} else {
		group.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if source.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting ResponseBasedOriginErrorDetectionParameters
		err := responseBasedOriginErrorDetectionSetting.AssignProperties_From_ResponseBasedOriginErrorDetectionParameters(source.ResponseBasedOriginErrorDetectionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResponseBasedOriginErrorDetectionParameters() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		group.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		group.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = genruntime.ClonePointerToInt(source.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)

	// Update the property bag
	if len(propertyBag) > 0 {
		group.PropertyBag = propertyBag
	} else {
		group.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeepCreatedOriginGroup interface (if implemented) to customize the conversion
	var groupAsAny any = group
	if augmentedGroup, ok := groupAsAny.(augmentConversionForDeepCreatedOriginGroup); ok {
		err := augmentedGroup.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeepCreatedOriginGroup populates the provided destination DeepCreatedOriginGroup from our DeepCreatedOriginGroup
func (group *DeepCreatedOriginGroup) AssignProperties_To_DeepCreatedOriginGroup(destination *v20210601s.DeepCreatedOriginGroup) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(group.PropertyBag)

	// HealthProbeSettings
	if group.HealthProbeSettings != nil {
		var healthProbeSetting v20210601s.HealthProbeParameters
		err := group.HealthProbeSettings.AssignProperties_To_HealthProbeParameters(&healthProbeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HealthProbeParameters() to populate field HealthProbeSettings")
		}
		destination.HealthProbeSettings = &healthProbeSetting
	} else {
		destination.HealthProbeSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(group.Name)

	// Origins
	if group.Origins != nil {
		originList := make([]v20210601s.ResourceReference, len(group.Origins))
		for originIndex, originItem := range group.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin v20210601s.ResourceReference
			err := originItem.AssignProperties_To_ResourceReference(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if group.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting v20210601s.ResponseBasedOriginErrorDetectionParameters
		err := group.ResponseBasedOriginErrorDetectionSettings.AssignProperties_To_ResponseBasedOriginErrorDetectionParameters(&responseBasedOriginErrorDetectionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResponseBasedOriginErrorDetectionParameters() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		destination.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		destination.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	destination.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = genruntime.ClonePointerToInt(group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeepCreatedOriginGroup interface (if implemented) to customize the conversion
	var groupAsAny any = group
	if augmentedGroup, ok := groupAsAny.(augmentConversionForDeepCreatedOriginGroup); ok {
		err := augmentedGroup.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeepCreatedOriginGroup_STATUS
// Deprecated version of DeepCreatedOriginGroup_STATUS. Use v1api20210601.DeepCreatedOriginGroup_STATUS instead
type DeepCreatedOriginGroup_STATUS struct {
	HealthProbeSettings                                   *HealthProbeParameters_STATUS                       `json:"healthProbeSettings,omitempty"`
	Name                                                  *string                                             `json:"name,omitempty"`
	Origins                                               []ResourceReference_STATUS                          `json:"origins,omitempty"`
	PropertyBag                                           genruntime.PropertyBag                              `json:"$propertyBag,omitempty"`
	ResponseBasedOriginErrorDetectionSettings             *ResponseBasedOriginErrorDetectionParameters_STATUS `json:"responseBasedOriginErrorDetectionSettings,omitempty"`
	TrafficRestorationTimeToHealedOrNewEndpointsInMinutes *int                                                `json:"trafficRestorationTimeToHealedOrNewEndpointsInMinutes,omitempty"`
}

// AssignProperties_From_DeepCreatedOriginGroup_STATUS populates our DeepCreatedOriginGroup_STATUS from the provided source DeepCreatedOriginGroup_STATUS
func (group *DeepCreatedOriginGroup_STATUS) AssignProperties_From_DeepCreatedOriginGroup_STATUS(source *v20210601s.DeepCreatedOriginGroup_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HealthProbeSettings
	if source.HealthProbeSettings != nil {
		var healthProbeSetting HealthProbeParameters_STATUS
		err := healthProbeSetting.AssignProperties_From_HealthProbeParameters_STATUS(source.HealthProbeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HealthProbeParameters_STATUS() to populate field HealthProbeSettings")
		}
		group.HealthProbeSettings = &healthProbeSetting
	} else {
		group.HealthProbeSettings = nil
	}

	// Name
	group.Name = genruntime.ClonePointerToString(source.Name)

	// Origins
	if source.Origins != nil {
		originList := make([]ResourceReference_STATUS, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin ResourceReference_STATUS
			err := origin.AssignProperties_From_ResourceReference_STATUS(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		group.Origins = originList
	} else {
		group.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if source.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting ResponseBasedOriginErrorDetectionParameters_STATUS
		err := responseBasedOriginErrorDetectionSetting.AssignProperties_From_ResponseBasedOriginErrorDetectionParameters_STATUS(source.ResponseBasedOriginErrorDetectionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResponseBasedOriginErrorDetectionParameters_STATUS() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		group.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		group.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = genruntime.ClonePointerToInt(source.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)

	// Update the property bag
	if len(propertyBag) > 0 {
		group.PropertyBag = propertyBag
	} else {
		group.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeepCreatedOriginGroup_STATUS interface (if implemented) to customize the conversion
	var groupAsAny any = group
	if augmentedGroup, ok := groupAsAny.(augmentConversionForDeepCreatedOriginGroup_STATUS); ok {
		err := augmentedGroup.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeepCreatedOriginGroup_STATUS populates the provided destination DeepCreatedOriginGroup_STATUS from our DeepCreatedOriginGroup_STATUS
func (group *DeepCreatedOriginGroup_STATUS) AssignProperties_To_DeepCreatedOriginGroup_STATUS(destination *v20210601s.DeepCreatedOriginGroup_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(group.PropertyBag)

	// HealthProbeSettings
	if group.HealthProbeSettings != nil {
		var healthProbeSetting v20210601s.HealthProbeParameters_STATUS
		err := group.HealthProbeSettings.AssignProperties_To_HealthProbeParameters_STATUS(&healthProbeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HealthProbeParameters_STATUS() to populate field HealthProbeSettings")
		}
		destination.HealthProbeSettings = &healthProbeSetting
	} else {
		destination.HealthProbeSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(group.Name)

	// Origins
	if group.Origins != nil {
		originList := make([]v20210601s.ResourceReference_STATUS, len(group.Origins))
		for originIndex, originItem := range group.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin v20210601s.ResourceReference_STATUS
			err := originItem.AssignProperties_To_ResourceReference_STATUS(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if group.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting v20210601s.ResponseBasedOriginErrorDetectionParameters_STATUS
		err := group.ResponseBasedOriginErrorDetectionSettings.AssignProperties_To_ResponseBasedOriginErrorDetectionParameters_STATUS(&responseBasedOriginErrorDetectionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResponseBasedOriginErrorDetectionParameters_STATUS() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		destination.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		destination.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	destination.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = genruntime.ClonePointerToInt(group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeepCreatedOriginGroup_STATUS interface (if implemented) to customize the conversion
	var groupAsAny any = group
	if augmentedGroup, ok := groupAsAny.(augmentConversionForDeepCreatedOriginGroup_STATUS); ok {
		err := augmentedGroup.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.EndpointProperties_DeliveryPolicy
// Deprecated version of EndpointProperties_DeliveryPolicy. Use v1api20210601.EndpointProperties_DeliveryPolicy instead
type EndpointProperties_DeliveryPolicy struct {
	Description *string                `json:"description,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Rules       []DeliveryRule         `json:"rules,omitempty"`
}

// AssignProperties_From_EndpointProperties_DeliveryPolicy populates our EndpointProperties_DeliveryPolicy from the provided source EndpointProperties_DeliveryPolicy
func (policy *EndpointProperties_DeliveryPolicy) AssignProperties_From_EndpointProperties_DeliveryPolicy(source *v20210601s.EndpointProperties_DeliveryPolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Description
	policy.Description = genruntime.ClonePointerToString(source.Description)

	// Rules
	if source.Rules != nil {
		ruleList := make([]DeliveryRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule DeliveryRule
			err := rule.AssignProperties_From_DeliveryRule(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForEndpointProperties_DeliveryPolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForEndpointProperties_DeliveryPolicy); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EndpointProperties_DeliveryPolicy populates the provided destination EndpointProperties_DeliveryPolicy from our EndpointProperties_DeliveryPolicy
func (policy *EndpointProperties_DeliveryPolicy) AssignProperties_To_EndpointProperties_DeliveryPolicy(destination *v20210601s.EndpointProperties_DeliveryPolicy) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// Description
	destination.Description = genruntime.ClonePointerToString(policy.Description)

	// Rules
	if policy.Rules != nil {
		ruleList := make([]v20210601s.DeliveryRule, len(policy.Rules))
		for ruleIndex, ruleItem := range policy.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule v20210601s.DeliveryRule
			err := ruleItem.AssignProperties_To_DeliveryRule(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEndpointProperties_DeliveryPolicy interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForEndpointProperties_DeliveryPolicy); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.EndpointProperties_DeliveryPolicy_STATUS
// Deprecated version of EndpointProperties_DeliveryPolicy_STATUS. Use v1api20210601.EndpointProperties_DeliveryPolicy_STATUS instead
type EndpointProperties_DeliveryPolicy_STATUS struct {
	Description *string                `json:"description,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Rules       []DeliveryRule_STATUS  `json:"rules,omitempty"`
}

// AssignProperties_From_EndpointProperties_DeliveryPolicy_STATUS populates our EndpointProperties_DeliveryPolicy_STATUS from the provided source EndpointProperties_DeliveryPolicy_STATUS
func (policy *EndpointProperties_DeliveryPolicy_STATUS) AssignProperties_From_EndpointProperties_DeliveryPolicy_STATUS(source *v20210601s.EndpointProperties_DeliveryPolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Description
	policy.Description = genruntime.ClonePointerToString(source.Description)

	// Rules
	if source.Rules != nil {
		ruleList := make([]DeliveryRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule DeliveryRule_STATUS
			err := rule.AssignProperties_From_DeliveryRule_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		policy.PropertyBag = propertyBag
	} else {
		policy.PropertyBag = nil
	}

	// Invoke the augmentConversionForEndpointProperties_DeliveryPolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForEndpointProperties_DeliveryPolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EndpointProperties_DeliveryPolicy_STATUS populates the provided destination EndpointProperties_DeliveryPolicy_STATUS from our EndpointProperties_DeliveryPolicy_STATUS
func (policy *EndpointProperties_DeliveryPolicy_STATUS) AssignProperties_To_EndpointProperties_DeliveryPolicy_STATUS(destination *v20210601s.EndpointProperties_DeliveryPolicy_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(policy.PropertyBag)

	// Description
	destination.Description = genruntime.ClonePointerToString(policy.Description)

	// Rules
	if policy.Rules != nil {
		ruleList := make([]v20210601s.DeliveryRule_STATUS, len(policy.Rules))
		for ruleIndex, ruleItem := range policy.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule v20210601s.DeliveryRule_STATUS
			err := ruleItem.AssignProperties_To_DeliveryRule_STATUS(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEndpointProperties_DeliveryPolicy_STATUS interface (if implemented) to customize the conversion
	var policyAsAny any = policy
	if augmentedPolicy, ok := policyAsAny.(augmentConversionForEndpointProperties_DeliveryPolicy_STATUS); ok {
		err := augmentedPolicy.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.EndpointProperties_WebApplicationFirewallPolicyLink
// Deprecated version of EndpointProperties_WebApplicationFirewallPolicyLink. Use v1api20210601.EndpointProperties_WebApplicationFirewallPolicyLink instead
type EndpointProperties_WebApplicationFirewallPolicyLink struct {
	PropertyBag genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Reference   *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink populates our EndpointProperties_WebApplicationFirewallPolicyLink from the provided source EndpointProperties_WebApplicationFirewallPolicyLink
func (link *EndpointProperties_WebApplicationFirewallPolicyLink) AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink(source *v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		link.Reference = &reference
	} else {
		link.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		link.PropertyBag = propertyBag
	} else {
		link.PropertyBag = nil
	}

	// Invoke the augmentConversionForEndpointProperties_WebApplicationFirewallPolicyLink interface (if implemented) to customize the conversion
	var linkAsAny any = link
	if augmentedLink, ok := linkAsAny.(augmentConversionForEndpointProperties_WebApplicationFirewallPolicyLink); ok {
		err := augmentedLink.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink populates the provided destination EndpointProperties_WebApplicationFirewallPolicyLink from our EndpointProperties_WebApplicationFirewallPolicyLink
func (link *EndpointProperties_WebApplicationFirewallPolicyLink) AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink(destination *v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(link.PropertyBag)

	// Reference
	if link.Reference != nil {
		reference := link.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEndpointProperties_WebApplicationFirewallPolicyLink interface (if implemented) to customize the conversion
	var linkAsAny any = link
	if augmentedLink, ok := linkAsAny.(augmentConversionForEndpointProperties_WebApplicationFirewallPolicyLink); ok {
		err := augmentedLink.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
// Deprecated version of EndpointProperties_WebApplicationFirewallPolicyLink_STATUS. Use v1api20210601.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS instead
type EndpointProperties_WebApplicationFirewallPolicyLink_STATUS struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS populates our EndpointProperties_WebApplicationFirewallPolicyLink_STATUS from the provided source EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
func (link *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS(source *v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	link.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		link.PropertyBag = propertyBag
	} else {
		link.PropertyBag = nil
	}

	// Invoke the augmentConversionForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS interface (if implemented) to customize the conversion
	var linkAsAny any = link
	if augmentedLink, ok := linkAsAny.(augmentConversionForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS); ok {
		err := augmentedLink.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS populates the provided destination EndpointProperties_WebApplicationFirewallPolicyLink_STATUS from our EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
func (link *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS(destination *v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(link.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(link.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS interface (if implemented) to customize the conversion
	var linkAsAny any = link
	if augmentedLink, ok := linkAsAny.(augmentConversionForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS); ok {
		err := augmentedLink.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.GeoFilter
// Deprecated version of GeoFilter. Use v1api20210601.GeoFilter instead
type GeoFilter struct {
	Action       *string                `json:"action,omitempty"`
	CountryCodes []string               `json:"countryCodes,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RelativePath *string                `json:"relativePath,omitempty"`
}

// AssignProperties_From_GeoFilter populates our GeoFilter from the provided source GeoFilter
func (filter *GeoFilter) AssignProperties_From_GeoFilter(source *v20210601s.GeoFilter) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Action
	filter.Action = genruntime.ClonePointerToString(source.Action)

	// CountryCodes
	filter.CountryCodes = genruntime.CloneSliceOfString(source.CountryCodes)

	// RelativePath
	filter.RelativePath = genruntime.ClonePointerToString(source.RelativePath)

	// Update the property bag
	if len(propertyBag) > 0 {
		filter.PropertyBag = propertyBag
	} else {
		filter.PropertyBag = nil
	}

	// Invoke the augmentConversionForGeoFilter interface (if implemented) to customize the conversion
	var filterAsAny any = filter
	if augmentedFilter, ok := filterAsAny.(augmentConversionForGeoFilter); ok {
		err := augmentedFilter.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_GeoFilter populates the provided destination GeoFilter from our GeoFilter
func (filter *GeoFilter) AssignProperties_To_GeoFilter(destination *v20210601s.GeoFilter) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(filter.PropertyBag)

	// Action
	destination.Action = genruntime.ClonePointerToString(filter.Action)

	// CountryCodes
	destination.CountryCodes = genruntime.CloneSliceOfString(filter.CountryCodes)

	// RelativePath
	destination.RelativePath = genruntime.ClonePointerToString(filter.RelativePath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForGeoFilter interface (if implemented) to customize the conversion
	var filterAsAny any = filter
	if augmentedFilter, ok := filterAsAny.(augmentConversionForGeoFilter); ok {
		err := augmentedFilter.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.GeoFilter_STATUS
// Deprecated version of GeoFilter_STATUS. Use v1api20210601.GeoFilter_STATUS instead
type GeoFilter_STATUS struct {
	Action       *string                `json:"action,omitempty"`
	CountryCodes []string               `json:"countryCodes,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RelativePath *string                `json:"relativePath,omitempty"`
}

// AssignProperties_From_GeoFilter_STATUS populates our GeoFilter_STATUS from the provided source GeoFilter_STATUS
func (filter *GeoFilter_STATUS) AssignProperties_From_GeoFilter_STATUS(source *v20210601s.GeoFilter_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Action
	filter.Action = genruntime.ClonePointerToString(source.Action)

	// CountryCodes
	filter.CountryCodes = genruntime.CloneSliceOfString(source.CountryCodes)

	// RelativePath
	filter.RelativePath = genruntime.ClonePointerToString(source.RelativePath)

	// Update the property bag
	if len(propertyBag) > 0 {
		filter.PropertyBag = propertyBag
	} else {
		filter.PropertyBag = nil
	}

	// Invoke the augmentConversionForGeoFilter_STATUS interface (if implemented) to customize the conversion
	var filterAsAny any = filter
	if augmentedFilter, ok := filterAsAny.(augmentConversionForGeoFilter_STATUS); ok {
		err := augmentedFilter.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_GeoFilter_STATUS populates the provided destination GeoFilter_STATUS from our GeoFilter_STATUS
func (filter *GeoFilter_STATUS) AssignProperties_To_GeoFilter_STATUS(destination *v20210601s.GeoFilter_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(filter.PropertyBag)

	// Action
	destination.Action = genruntime.ClonePointerToString(filter.Action)

	// CountryCodes
	destination.CountryCodes = genruntime.CloneSliceOfString(filter.CountryCodes)

	// RelativePath
	destination.RelativePath = genruntime.ClonePointerToString(filter.RelativePath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForGeoFilter_STATUS interface (if implemented) to customize the conversion
	var filterAsAny any = filter
	if augmentedFilter, ok := filterAsAny.(augmentConversionForGeoFilter_STATUS); ok {
		err := augmentedFilter.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.ResourceReference
// Deprecated version of ResourceReference. Use v1api20210601.ResourceReference instead
type ResourceReference struct {
	PropertyBag genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Reference   *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignProperties_From_ResourceReference populates our ResourceReference from the provided source ResourceReference
func (reference *ResourceReference) AssignProperties_From_ResourceReference(source *v20210601s.ResourceReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForResourceReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForResourceReference); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceReference populates the provided destination ResourceReference from our ResourceReference
func (reference *ResourceReference) AssignProperties_To_ResourceReference(destination *v20210601s.ResourceReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForResourceReference interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForResourceReference); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.ResourceReference_STATUS
// Deprecated version of ResourceReference_STATUS. Use v1api20210601.ResourceReference_STATUS instead
type ResourceReference_STATUS struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ResourceReference_STATUS populates our ResourceReference_STATUS from the provided source ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignProperties_From_ResourceReference_STATUS(source *v20210601s.ResourceReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// Invoke the augmentConversionForResourceReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForResourceReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceReference_STATUS populates the provided destination ResourceReference_STATUS from our ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignProperties_To_ResourceReference_STATUS(destination *v20210601s.ResourceReference_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForResourceReference_STATUS interface (if implemented) to customize the conversion
	var referenceAsAny any = reference
	if augmentedReference, ok := referenceAsAny.(augmentConversionForResourceReference_STATUS); ok {
		err := augmentedReference.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlSigningKey
// Deprecated version of UrlSigningKey. Use v1api20210601.UrlSigningKey instead
type UrlSigningKey struct {
	KeyId               *string                       `json:"keyId,omitempty"`
	KeySourceParameters *KeyVaultSigningKeyParameters `json:"keySourceParameters,omitempty"`
	PropertyBag         genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlSigningKey populates our UrlSigningKey from the provided source UrlSigningKey
func (signingKey *UrlSigningKey) AssignProperties_From_UrlSigningKey(source *v20210601s.UrlSigningKey) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyId
	signingKey.KeyId = genruntime.ClonePointerToString(source.KeyId)

	// KeySourceParameters
	if source.KeySourceParameters != nil {
		var keySourceParameter KeyVaultSigningKeyParameters
		err := keySourceParameter.AssignProperties_From_KeyVaultSigningKeyParameters(source.KeySourceParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultSigningKeyParameters() to populate field KeySourceParameters")
		}
		signingKey.KeySourceParameters = &keySourceParameter
	} else {
		signingKey.KeySourceParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		signingKey.PropertyBag = propertyBag
	} else {
		signingKey.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningKey interface (if implemented) to customize the conversion
	var signingKeyAsAny any = signingKey
	if augmentedSigningKey, ok := signingKeyAsAny.(augmentConversionForUrlSigningKey); ok {
		err := augmentedSigningKey.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningKey populates the provided destination UrlSigningKey from our UrlSigningKey
func (signingKey *UrlSigningKey) AssignProperties_To_UrlSigningKey(destination *v20210601s.UrlSigningKey) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(signingKey.PropertyBag)

	// KeyId
	destination.KeyId = genruntime.ClonePointerToString(signingKey.KeyId)

	// KeySourceParameters
	if signingKey.KeySourceParameters != nil {
		var keySourceParameter v20210601s.KeyVaultSigningKeyParameters
		err := signingKey.KeySourceParameters.AssignProperties_To_KeyVaultSigningKeyParameters(&keySourceParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultSigningKeyParameters() to populate field KeySourceParameters")
		}
		destination.KeySourceParameters = &keySourceParameter
	} else {
		destination.KeySourceParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningKey interface (if implemented) to customize the conversion
	var signingKeyAsAny any = signingKey
	if augmentedSigningKey, ok := signingKeyAsAny.(augmentConversionForUrlSigningKey); ok {
		err := augmentedSigningKey.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlSigningKey_STATUS
// Deprecated version of UrlSigningKey_STATUS. Use v1api20210601.UrlSigningKey_STATUS instead
type UrlSigningKey_STATUS struct {
	KeyId               *string                              `json:"keyId,omitempty"`
	KeySourceParameters *KeyVaultSigningKeyParameters_STATUS `json:"keySourceParameters,omitempty"`
	PropertyBag         genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlSigningKey_STATUS populates our UrlSigningKey_STATUS from the provided source UrlSigningKey_STATUS
func (signingKey *UrlSigningKey_STATUS) AssignProperties_From_UrlSigningKey_STATUS(source *v20210601s.UrlSigningKey_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyId
	signingKey.KeyId = genruntime.ClonePointerToString(source.KeyId)

	// KeySourceParameters
	if source.KeySourceParameters != nil {
		var keySourceParameter KeyVaultSigningKeyParameters_STATUS
		err := keySourceParameter.AssignProperties_From_KeyVaultSigningKeyParameters_STATUS(source.KeySourceParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KeyVaultSigningKeyParameters_STATUS() to populate field KeySourceParameters")
		}
		signingKey.KeySourceParameters = &keySourceParameter
	} else {
		signingKey.KeySourceParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		signingKey.PropertyBag = propertyBag
	} else {
		signingKey.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningKey_STATUS interface (if implemented) to customize the conversion
	var signingKeyAsAny any = signingKey
	if augmentedSigningKey, ok := signingKeyAsAny.(augmentConversionForUrlSigningKey_STATUS); ok {
		err := augmentedSigningKey.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningKey_STATUS populates the provided destination UrlSigningKey_STATUS from our UrlSigningKey_STATUS
func (signingKey *UrlSigningKey_STATUS) AssignProperties_To_UrlSigningKey_STATUS(destination *v20210601s.UrlSigningKey_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(signingKey.PropertyBag)

	// KeyId
	destination.KeyId = genruntime.ClonePointerToString(signingKey.KeyId)

	// KeySourceParameters
	if signingKey.KeySourceParameters != nil {
		var keySourceParameter v20210601s.KeyVaultSigningKeyParameters_STATUS
		err := signingKey.KeySourceParameters.AssignProperties_To_KeyVaultSigningKeyParameters_STATUS(&keySourceParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KeyVaultSigningKeyParameters_STATUS() to populate field KeySourceParameters")
		}
		destination.KeySourceParameters = &keySourceParameter
	} else {
		destination.KeySourceParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningKey_STATUS interface (if implemented) to customize the conversion
	var signingKeyAsAny any = signingKey
	if augmentedSigningKey, ok := signingKeyAsAny.(augmentConversionForUrlSigningKey_STATUS); ok {
		err := augmentedSigningKey.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForDeepCreatedCustomDomain_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeepCreatedCustomDomain_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeepCreatedCustomDomain_STATUS) error
}

type augmentConversionForDeepCreatedOrigin interface {
	AssignPropertiesFrom(src *v20210601s.DeepCreatedOrigin) error
	AssignPropertiesTo(dst *v20210601s.DeepCreatedOrigin) error
}

type augmentConversionForDeepCreatedOrigin_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeepCreatedOrigin_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeepCreatedOrigin_STATUS) error
}

type augmentConversionForDeepCreatedOriginGroup interface {
	AssignPropertiesFrom(src *v20210601s.DeepCreatedOriginGroup) error
	AssignPropertiesTo(dst *v20210601s.DeepCreatedOriginGroup) error
}

type augmentConversionForDeepCreatedOriginGroup_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeepCreatedOriginGroup_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeepCreatedOriginGroup_STATUS) error
}

type augmentConversionForEndpointProperties_DeliveryPolicy interface {
	AssignPropertiesFrom(src *v20210601s.EndpointProperties_DeliveryPolicy) error
	AssignPropertiesTo(dst *v20210601s.EndpointProperties_DeliveryPolicy) error
}

type augmentConversionForEndpointProperties_DeliveryPolicy_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.EndpointProperties_DeliveryPolicy_STATUS) error
	AssignPropertiesTo(dst *v20210601s.EndpointProperties_DeliveryPolicy_STATUS) error
}

type augmentConversionForEndpointProperties_WebApplicationFirewallPolicyLink interface {
	AssignPropertiesFrom(src *v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink) error
	AssignPropertiesTo(dst *v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink) error
}

type augmentConversionForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) error
	AssignPropertiesTo(dst *v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) error
}

type augmentConversionForGeoFilter interface {
	AssignPropertiesFrom(src *v20210601s.GeoFilter) error
	AssignPropertiesTo(dst *v20210601s.GeoFilter) error
}

type augmentConversionForGeoFilter_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.GeoFilter_STATUS) error
	AssignPropertiesTo(dst *v20210601s.GeoFilter_STATUS) error
}

type augmentConversionForResourceReference interface {
	AssignPropertiesFrom(src *v20210601s.ResourceReference) error
	AssignPropertiesTo(dst *v20210601s.ResourceReference) error
}

type augmentConversionForResourceReference_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.ResourceReference_STATUS) error
	AssignPropertiesTo(dst *v20210601s.ResourceReference_STATUS) error
}

type augmentConversionForUrlSigningKey interface {
	AssignPropertiesFrom(src *v20210601s.UrlSigningKey) error
	AssignPropertiesTo(dst *v20210601s.UrlSigningKey) error
}

type augmentConversionForUrlSigningKey_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.UrlSigningKey_STATUS) error
	AssignPropertiesTo(dst *v20210601s.UrlSigningKey_STATUS) error
}

// Storage version of v1beta20210601.DeliveryRule
// Deprecated version of DeliveryRule. Use v1api20210601.DeliveryRule instead
type DeliveryRule struct {
	Actions     []DeliveryRuleAction    `json:"actions,omitempty"`
	Conditions  []DeliveryRuleCondition `json:"conditions,omitempty"`
	Name        *string                 `json:"name,omitempty"`
	Order       *int                    `json:"order,omitempty"`
	PropertyBag genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRule populates our DeliveryRule from the provided source DeliveryRule
func (rule *DeliveryRule) AssignProperties_From_DeliveryRule(source *v20210601s.DeliveryRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Actions
	if source.Actions != nil {
		actionList := make([]DeliveryRuleAction, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action DeliveryRuleAction
			err := action.AssignProperties_From_DeliveryRuleAction(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleAction() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		rule.Actions = actionList
	} else {
		rule.Actions = nil
	}

	// Conditions
	if source.Conditions != nil {
		conditionList := make([]DeliveryRuleCondition, len(source.Conditions))
		for conditionIndex, conditionItem := range source.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition DeliveryRuleCondition
			err := condition.AssignProperties_From_DeliveryRuleCondition(&conditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCondition() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		rule.Conditions = conditionList
	} else {
		rule.Conditions = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Order
	rule.Order = genruntime.ClonePointerToInt(source.Order)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForDeliveryRule); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRule populates the provided destination DeliveryRule from our DeliveryRule
func (rule *DeliveryRule) AssignProperties_To_DeliveryRule(destination *v20210601s.DeliveryRule) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// Actions
	if rule.Actions != nil {
		actionList := make([]v20210601s.DeliveryRuleAction, len(rule.Actions))
		for actionIndex, actionItem := range rule.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action v20210601s.DeliveryRuleAction
			err := actionItem.AssignProperties_To_DeliveryRuleAction(&action)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleAction() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		destination.Actions = actionList
	} else {
		destination.Actions = nil
	}

	// Conditions
	if rule.Conditions != nil {
		conditionList := make([]v20210601s.DeliveryRuleCondition, len(rule.Conditions))
		for conditionIndex, conditionItem := range rule.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition v20210601s.DeliveryRuleCondition
			err := conditionItem.AssignProperties_To_DeliveryRuleCondition(&condition)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCondition() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		destination.Conditions = conditionList
	} else {
		destination.Conditions = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Order
	destination.Order = genruntime.ClonePointerToInt(rule.Order)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRule interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForDeliveryRule); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRule_STATUS
// Deprecated version of DeliveryRule_STATUS. Use v1api20210601.DeliveryRule_STATUS instead
type DeliveryRule_STATUS struct {
	Actions     []DeliveryRuleAction_STATUS    `json:"actions,omitempty"`
	Conditions  []DeliveryRuleCondition_STATUS `json:"conditions,omitempty"`
	Name        *string                        `json:"name,omitempty"`
	Order       *int                           `json:"order,omitempty"`
	PropertyBag genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRule_STATUS populates our DeliveryRule_STATUS from the provided source DeliveryRule_STATUS
func (rule *DeliveryRule_STATUS) AssignProperties_From_DeliveryRule_STATUS(source *v20210601s.DeliveryRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Actions
	if source.Actions != nil {
		actionList := make([]DeliveryRuleAction_STATUS, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action DeliveryRuleAction_STATUS
			err := action.AssignProperties_From_DeliveryRuleAction_STATUS(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleAction_STATUS() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		rule.Actions = actionList
	} else {
		rule.Actions = nil
	}

	// Conditions
	if source.Conditions != nil {
		conditionList := make([]DeliveryRuleCondition_STATUS, len(source.Conditions))
		for conditionIndex, conditionItem := range source.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition DeliveryRuleCondition_STATUS
			err := condition.AssignProperties_From_DeliveryRuleCondition_STATUS(&conditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCondition_STATUS() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		rule.Conditions = conditionList
	} else {
		rule.Conditions = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Order
	rule.Order = genruntime.ClonePointerToInt(source.Order)

	// Update the property bag
	if len(propertyBag) > 0 {
		rule.PropertyBag = propertyBag
	} else {
		rule.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForDeliveryRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRule_STATUS populates the provided destination DeliveryRule_STATUS from our DeliveryRule_STATUS
func (rule *DeliveryRule_STATUS) AssignProperties_To_DeliveryRule_STATUS(destination *v20210601s.DeliveryRule_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(rule.PropertyBag)

	// Actions
	if rule.Actions != nil {
		actionList := make([]v20210601s.DeliveryRuleAction_STATUS, len(rule.Actions))
		for actionIndex, actionItem := range rule.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action v20210601s.DeliveryRuleAction_STATUS
			err := actionItem.AssignProperties_To_DeliveryRuleAction_STATUS(&action)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleAction_STATUS() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		destination.Actions = actionList
	} else {
		destination.Actions = nil
	}

	// Conditions
	if rule.Conditions != nil {
		conditionList := make([]v20210601s.DeliveryRuleCondition_STATUS, len(rule.Conditions))
		for conditionIndex, conditionItem := range rule.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition v20210601s.DeliveryRuleCondition_STATUS
			err := conditionItem.AssignProperties_To_DeliveryRuleCondition_STATUS(&condition)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCondition_STATUS() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		destination.Conditions = conditionList
	} else {
		destination.Conditions = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Order
	destination.Order = genruntime.ClonePointerToInt(rule.Order)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRule_STATUS interface (if implemented) to customize the conversion
	var ruleAsAny any = rule
	if augmentedRule, ok := ruleAsAny.(augmentConversionForDeliveryRule_STATUS); ok {
		err := augmentedRule.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.HealthProbeParameters
// Deprecated version of HealthProbeParameters. Use v1api20210601.HealthProbeParameters instead
type HealthProbeParameters struct {
	ProbeIntervalInSeconds *int                   `json:"probeIntervalInSeconds,omitempty"`
	ProbePath              *string                `json:"probePath,omitempty"`
	ProbeProtocol          *string                `json:"probeProtocol,omitempty"`
	ProbeRequestType       *string                `json:"probeRequestType,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_HealthProbeParameters populates our HealthProbeParameters from the provided source HealthProbeParameters
func (parameters *HealthProbeParameters) AssignProperties_From_HealthProbeParameters(source *v20210601s.HealthProbeParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ProbeIntervalInSeconds
	parameters.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(source.ProbeIntervalInSeconds)

	// ProbePath
	parameters.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProbeProtocol
	parameters.ProbeProtocol = genruntime.ClonePointerToString(source.ProbeProtocol)

	// ProbeRequestType
	parameters.ProbeRequestType = genruntime.ClonePointerToString(source.ProbeRequestType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHealthProbeParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHealthProbeParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HealthProbeParameters populates the provided destination HealthProbeParameters from our HealthProbeParameters
func (parameters *HealthProbeParameters) AssignProperties_To_HealthProbeParameters(destination *v20210601s.HealthProbeParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// ProbeIntervalInSeconds
	destination.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(parameters.ProbeIntervalInSeconds)

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(parameters.ProbePath)

	// ProbeProtocol
	destination.ProbeProtocol = genruntime.ClonePointerToString(parameters.ProbeProtocol)

	// ProbeRequestType
	destination.ProbeRequestType = genruntime.ClonePointerToString(parameters.ProbeRequestType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHealthProbeParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHealthProbeParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.HealthProbeParameters_STATUS
// Deprecated version of HealthProbeParameters_STATUS. Use v1api20210601.HealthProbeParameters_STATUS instead
type HealthProbeParameters_STATUS struct {
	ProbeIntervalInSeconds *int                   `json:"probeIntervalInSeconds,omitempty"`
	ProbePath              *string                `json:"probePath,omitempty"`
	ProbeProtocol          *string                `json:"probeProtocol,omitempty"`
	ProbeRequestType       *string                `json:"probeRequestType,omitempty"`
	PropertyBag            genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_HealthProbeParameters_STATUS populates our HealthProbeParameters_STATUS from the provided source HealthProbeParameters_STATUS
func (parameters *HealthProbeParameters_STATUS) AssignProperties_From_HealthProbeParameters_STATUS(source *v20210601s.HealthProbeParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ProbeIntervalInSeconds
	parameters.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(source.ProbeIntervalInSeconds)

	// ProbePath
	parameters.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProbeProtocol
	parameters.ProbeProtocol = genruntime.ClonePointerToString(source.ProbeProtocol)

	// ProbeRequestType
	parameters.ProbeRequestType = genruntime.ClonePointerToString(source.ProbeRequestType)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHealthProbeParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHealthProbeParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HealthProbeParameters_STATUS populates the provided destination HealthProbeParameters_STATUS from our HealthProbeParameters_STATUS
func (parameters *HealthProbeParameters_STATUS) AssignProperties_To_HealthProbeParameters_STATUS(destination *v20210601s.HealthProbeParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// ProbeIntervalInSeconds
	destination.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(parameters.ProbeIntervalInSeconds)

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(parameters.ProbePath)

	// ProbeProtocol
	destination.ProbeProtocol = genruntime.ClonePointerToString(parameters.ProbeProtocol)

	// ProbeRequestType
	destination.ProbeRequestType = genruntime.ClonePointerToString(parameters.ProbeRequestType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHealthProbeParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHealthProbeParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.KeyVaultSigningKeyParameters
// Deprecated version of KeyVaultSigningKeyParameters. Use v1api20210601.KeyVaultSigningKeyParameters instead
type KeyVaultSigningKeyParameters struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceGroupName *string                `json:"resourceGroupName,omitempty"`
	SecretName        *string                `json:"secretName,omitempty"`
	SecretVersion     *string                `json:"secretVersion,omitempty"`
	SubscriptionId    *string                `json:"subscriptionId,omitempty"`
	TypeName          *string                `json:"typeName,omitempty"`
	VaultName         *string                `json:"vaultName,omitempty"`
}

// AssignProperties_From_KeyVaultSigningKeyParameters populates our KeyVaultSigningKeyParameters from the provided source KeyVaultSigningKeyParameters
func (parameters *KeyVaultSigningKeyParameters) AssignProperties_From_KeyVaultSigningKeyParameters(source *v20210601s.KeyVaultSigningKeyParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ResourceGroupName
	parameters.ResourceGroupName = genruntime.ClonePointerToString(source.ResourceGroupName)

	// SecretName
	parameters.SecretName = genruntime.ClonePointerToString(source.SecretName)

	// SecretVersion
	parameters.SecretVersion = genruntime.ClonePointerToString(source.SecretVersion)

	// SubscriptionId
	parameters.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// VaultName
	parameters.VaultName = genruntime.ClonePointerToString(source.VaultName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultSigningKeyParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForKeyVaultSigningKeyParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_KeyVaultSigningKeyParameters populates the provided destination KeyVaultSigningKeyParameters from our KeyVaultSigningKeyParameters
func (parameters *KeyVaultSigningKeyParameters) AssignProperties_To_KeyVaultSigningKeyParameters(destination *v20210601s.KeyVaultSigningKeyParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// ResourceGroupName
	destination.ResourceGroupName = genruntime.ClonePointerToString(parameters.ResourceGroupName)

	// SecretName
	destination.SecretName = genruntime.ClonePointerToString(parameters.SecretName)

	// SecretVersion
	destination.SecretVersion = genruntime.ClonePointerToString(parameters.SecretVersion)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(parameters.SubscriptionId)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// VaultName
	destination.VaultName = genruntime.ClonePointerToString(parameters.VaultName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultSigningKeyParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForKeyVaultSigningKeyParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.KeyVaultSigningKeyParameters_STATUS
// Deprecated version of KeyVaultSigningKeyParameters_STATUS. Use v1api20210601.KeyVaultSigningKeyParameters_STATUS instead
type KeyVaultSigningKeyParameters_STATUS struct {
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceGroupName *string                `json:"resourceGroupName,omitempty"`
	SecretName        *string                `json:"secretName,omitempty"`
	SecretVersion     *string                `json:"secretVersion,omitempty"`
	SubscriptionId    *string                `json:"subscriptionId,omitempty"`
	TypeName          *string                `json:"typeName,omitempty"`
	VaultName         *string                `json:"vaultName,omitempty"`
}

// AssignProperties_From_KeyVaultSigningKeyParameters_STATUS populates our KeyVaultSigningKeyParameters_STATUS from the provided source KeyVaultSigningKeyParameters_STATUS
func (parameters *KeyVaultSigningKeyParameters_STATUS) AssignProperties_From_KeyVaultSigningKeyParameters_STATUS(source *v20210601s.KeyVaultSigningKeyParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ResourceGroupName
	parameters.ResourceGroupName = genruntime.ClonePointerToString(source.ResourceGroupName)

	// SecretName
	parameters.SecretName = genruntime.ClonePointerToString(source.SecretName)

	// SecretVersion
	parameters.SecretVersion = genruntime.ClonePointerToString(source.SecretVersion)

	// SubscriptionId
	parameters.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// VaultName
	parameters.VaultName = genruntime.ClonePointerToString(source.VaultName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultSigningKeyParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForKeyVaultSigningKeyParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_KeyVaultSigningKeyParameters_STATUS populates the provided destination KeyVaultSigningKeyParameters_STATUS from our KeyVaultSigningKeyParameters_STATUS
func (parameters *KeyVaultSigningKeyParameters_STATUS) AssignProperties_To_KeyVaultSigningKeyParameters_STATUS(destination *v20210601s.KeyVaultSigningKeyParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// ResourceGroupName
	destination.ResourceGroupName = genruntime.ClonePointerToString(parameters.ResourceGroupName)

	// SecretName
	destination.SecretName = genruntime.ClonePointerToString(parameters.SecretName)

	// SecretVersion
	destination.SecretVersion = genruntime.ClonePointerToString(parameters.SecretVersion)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(parameters.SubscriptionId)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// VaultName
	destination.VaultName = genruntime.ClonePointerToString(parameters.VaultName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForKeyVaultSigningKeyParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForKeyVaultSigningKeyParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.ResponseBasedOriginErrorDetectionParameters
// Deprecated version of ResponseBasedOriginErrorDetectionParameters. Use v1api20210601.ResponseBasedOriginErrorDetectionParameters instead
type ResponseBasedOriginErrorDetectionParameters struct {
	HttpErrorRanges                          []HttpErrorRangeParameters `json:"httpErrorRanges,omitempty"`
	PropertyBag                              genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	ResponseBasedDetectedErrorTypes          *string                    `json:"responseBasedDetectedErrorTypes,omitempty"`
	ResponseBasedFailoverThresholdPercentage *int                       `json:"responseBasedFailoverThresholdPercentage,omitempty"`
}

// AssignProperties_From_ResponseBasedOriginErrorDetectionParameters populates our ResponseBasedOriginErrorDetectionParameters from the provided source ResponseBasedOriginErrorDetectionParameters
func (parameters *ResponseBasedOriginErrorDetectionParameters) AssignProperties_From_ResponseBasedOriginErrorDetectionParameters(source *v20210601s.ResponseBasedOriginErrorDetectionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HttpErrorRanges
	if source.HttpErrorRanges != nil {
		httpErrorRangeList := make([]HttpErrorRangeParameters, len(source.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range source.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange HttpErrorRangeParameters
			err := httpErrorRange.AssignProperties_From_HttpErrorRangeParameters(&httpErrorRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HttpErrorRangeParameters() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		parameters.HttpErrorRanges = httpErrorRangeList
	} else {
		parameters.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	parameters.ResponseBasedDetectedErrorTypes = genruntime.ClonePointerToString(source.ResponseBasedDetectedErrorTypes)

	// ResponseBasedFailoverThresholdPercentage
	parameters.ResponseBasedFailoverThresholdPercentage = genruntime.ClonePointerToInt(source.ResponseBasedFailoverThresholdPercentage)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForResponseBasedOriginErrorDetectionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForResponseBasedOriginErrorDetectionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ResponseBasedOriginErrorDetectionParameters populates the provided destination ResponseBasedOriginErrorDetectionParameters from our ResponseBasedOriginErrorDetectionParameters
func (parameters *ResponseBasedOriginErrorDetectionParameters) AssignProperties_To_ResponseBasedOriginErrorDetectionParameters(destination *v20210601s.ResponseBasedOriginErrorDetectionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// HttpErrorRanges
	if parameters.HttpErrorRanges != nil {
		httpErrorRangeList := make([]v20210601s.HttpErrorRangeParameters, len(parameters.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range parameters.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange v20210601s.HttpErrorRangeParameters
			err := httpErrorRangeItem.AssignProperties_To_HttpErrorRangeParameters(&httpErrorRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HttpErrorRangeParameters() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		destination.HttpErrorRanges = httpErrorRangeList
	} else {
		destination.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	destination.ResponseBasedDetectedErrorTypes = genruntime.ClonePointerToString(parameters.ResponseBasedDetectedErrorTypes)

	// ResponseBasedFailoverThresholdPercentage
	destination.ResponseBasedFailoverThresholdPercentage = genruntime.ClonePointerToInt(parameters.ResponseBasedFailoverThresholdPercentage)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForResponseBasedOriginErrorDetectionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForResponseBasedOriginErrorDetectionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.ResponseBasedOriginErrorDetectionParameters_STATUS
// Deprecated version of ResponseBasedOriginErrorDetectionParameters_STATUS. Use v1api20210601.ResponseBasedOriginErrorDetectionParameters_STATUS instead
type ResponseBasedOriginErrorDetectionParameters_STATUS struct {
	HttpErrorRanges                          []HttpErrorRangeParameters_STATUS `json:"httpErrorRanges,omitempty"`
	PropertyBag                              genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
	ResponseBasedDetectedErrorTypes          *string                           `json:"responseBasedDetectedErrorTypes,omitempty"`
	ResponseBasedFailoverThresholdPercentage *int                              `json:"responseBasedFailoverThresholdPercentage,omitempty"`
}

// AssignProperties_From_ResponseBasedOriginErrorDetectionParameters_STATUS populates our ResponseBasedOriginErrorDetectionParameters_STATUS from the provided source ResponseBasedOriginErrorDetectionParameters_STATUS
func (parameters *ResponseBasedOriginErrorDetectionParameters_STATUS) AssignProperties_From_ResponseBasedOriginErrorDetectionParameters_STATUS(source *v20210601s.ResponseBasedOriginErrorDetectionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HttpErrorRanges
	if source.HttpErrorRanges != nil {
		httpErrorRangeList := make([]HttpErrorRangeParameters_STATUS, len(source.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range source.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange HttpErrorRangeParameters_STATUS
			err := httpErrorRange.AssignProperties_From_HttpErrorRangeParameters_STATUS(&httpErrorRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_HttpErrorRangeParameters_STATUS() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		parameters.HttpErrorRanges = httpErrorRangeList
	} else {
		parameters.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	parameters.ResponseBasedDetectedErrorTypes = genruntime.ClonePointerToString(source.ResponseBasedDetectedErrorTypes)

	// ResponseBasedFailoverThresholdPercentage
	parameters.ResponseBasedFailoverThresholdPercentage = genruntime.ClonePointerToInt(source.ResponseBasedFailoverThresholdPercentage)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForResponseBasedOriginErrorDetectionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForResponseBasedOriginErrorDetectionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ResponseBasedOriginErrorDetectionParameters_STATUS populates the provided destination ResponseBasedOriginErrorDetectionParameters_STATUS from our ResponseBasedOriginErrorDetectionParameters_STATUS
func (parameters *ResponseBasedOriginErrorDetectionParameters_STATUS) AssignProperties_To_ResponseBasedOriginErrorDetectionParameters_STATUS(destination *v20210601s.ResponseBasedOriginErrorDetectionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// HttpErrorRanges
	if parameters.HttpErrorRanges != nil {
		httpErrorRangeList := make([]v20210601s.HttpErrorRangeParameters_STATUS, len(parameters.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range parameters.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange v20210601s.HttpErrorRangeParameters_STATUS
			err := httpErrorRangeItem.AssignProperties_To_HttpErrorRangeParameters_STATUS(&httpErrorRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_HttpErrorRangeParameters_STATUS() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		destination.HttpErrorRanges = httpErrorRangeList
	} else {
		destination.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	destination.ResponseBasedDetectedErrorTypes = genruntime.ClonePointerToString(parameters.ResponseBasedDetectedErrorTypes)

	// ResponseBasedFailoverThresholdPercentage
	destination.ResponseBasedFailoverThresholdPercentage = genruntime.ClonePointerToInt(parameters.ResponseBasedFailoverThresholdPercentage)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForResponseBasedOriginErrorDetectionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForResponseBasedOriginErrorDetectionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForDeliveryRule interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRule) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRule) error
}

type augmentConversionForDeliveryRule_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRule_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRule_STATUS) error
}

type augmentConversionForHealthProbeParameters interface {
	AssignPropertiesFrom(src *v20210601s.HealthProbeParameters) error
	AssignPropertiesTo(dst *v20210601s.HealthProbeParameters) error
}

type augmentConversionForHealthProbeParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.HealthProbeParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.HealthProbeParameters_STATUS) error
}

type augmentConversionForKeyVaultSigningKeyParameters interface {
	AssignPropertiesFrom(src *v20210601s.KeyVaultSigningKeyParameters) error
	AssignPropertiesTo(dst *v20210601s.KeyVaultSigningKeyParameters) error
}

type augmentConversionForKeyVaultSigningKeyParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.KeyVaultSigningKeyParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.KeyVaultSigningKeyParameters_STATUS) error
}

type augmentConversionForResponseBasedOriginErrorDetectionParameters interface {
	AssignPropertiesFrom(src *v20210601s.ResponseBasedOriginErrorDetectionParameters) error
	AssignPropertiesTo(dst *v20210601s.ResponseBasedOriginErrorDetectionParameters) error
}

type augmentConversionForResponseBasedOriginErrorDetectionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.ResponseBasedOriginErrorDetectionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.ResponseBasedOriginErrorDetectionParameters_STATUS) error
}

// Storage version of v1beta20210601.DeliveryRuleAction
// Deprecated version of DeliveryRuleAction. Use v1api20210601.DeliveryRuleAction instead
type DeliveryRuleAction struct {
	CacheExpiration            *DeliveryRuleCacheExpirationAction            `json:"cacheExpiration,omitempty"`
	CacheKeyQueryString        *DeliveryRuleCacheKeyQueryStringAction        `json:"cacheKeyQueryString,omitempty"`
	ModifyRequestHeader        *DeliveryRuleRequestHeaderAction              `json:"modifyRequestHeader,omitempty"`
	ModifyResponseHeader       *DeliveryRuleResponseHeaderAction             `json:"modifyResponseHeader,omitempty"`
	OriginGroupOverride        *OriginGroupOverrideAction                    `json:"originGroupOverride,omitempty"`
	PropertyBag                genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
	RouteConfigurationOverride *DeliveryRuleRouteConfigurationOverrideAction `json:"routeConfigurationOverride,omitempty"`
	UrlRedirect                *UrlRedirectAction                            `json:"urlRedirect,omitempty"`
	UrlRewrite                 *UrlRewriteAction                             `json:"urlRewrite,omitempty"`
	UrlSigning                 *UrlSigningAction                             `json:"urlSigning,omitempty"`
}

// AssignProperties_From_DeliveryRuleAction populates our DeliveryRuleAction from the provided source DeliveryRuleAction
func (action *DeliveryRuleAction) AssignProperties_From_DeliveryRuleAction(source *v20210601s.DeliveryRuleAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheExpiration
	if source.CacheExpiration != nil {
		var cacheExpiration DeliveryRuleCacheExpirationAction
		err := cacheExpiration.AssignProperties_From_DeliveryRuleCacheExpirationAction(source.CacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheExpirationAction() to populate field CacheExpiration")
		}
		action.CacheExpiration = &cacheExpiration
	} else {
		action.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if source.CacheKeyQueryString != nil {
		var cacheKeyQueryString DeliveryRuleCacheKeyQueryStringAction
		err := cacheKeyQueryString.AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction(source.CacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction() to populate field CacheKeyQueryString")
		}
		action.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		action.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if source.ModifyRequestHeader != nil {
		var modifyRequestHeader DeliveryRuleRequestHeaderAction
		err := modifyRequestHeader.AssignProperties_From_DeliveryRuleRequestHeaderAction(source.ModifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderAction() to populate field ModifyRequestHeader")
		}
		action.ModifyRequestHeader = &modifyRequestHeader
	} else {
		action.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if source.ModifyResponseHeader != nil {
		var modifyResponseHeader DeliveryRuleResponseHeaderAction
		err := modifyResponseHeader.AssignProperties_From_DeliveryRuleResponseHeaderAction(source.ModifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleResponseHeaderAction() to populate field ModifyResponseHeader")
		}
		action.ModifyResponseHeader = &modifyResponseHeader
	} else {
		action.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverrideAction
		err := originGroupOverride.AssignProperties_From_OriginGroupOverrideAction(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideAction() to populate field OriginGroupOverride")
		}
		action.OriginGroupOverride = &originGroupOverride
	} else {
		action.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if source.RouteConfigurationOverride != nil {
		var routeConfigurationOverride DeliveryRuleRouteConfigurationOverrideAction
		err := routeConfigurationOverride.AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction(source.RouteConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction() to populate field RouteConfigurationOverride")
		}
		action.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		action.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if source.UrlRedirect != nil {
		var urlRedirect UrlRedirectAction
		err := urlRedirect.AssignProperties_From_UrlRedirectAction(source.UrlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectAction() to populate field UrlRedirect")
		}
		action.UrlRedirect = &urlRedirect
	} else {
		action.UrlRedirect = nil
	}

	// UrlRewrite
	if source.UrlRewrite != nil {
		var urlRewrite UrlRewriteAction
		err := urlRewrite.AssignProperties_From_UrlRewriteAction(source.UrlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteAction() to populate field UrlRewrite")
		}
		action.UrlRewrite = &urlRewrite
	} else {
		action.UrlRewrite = nil
	}

	// UrlSigning
	if source.UrlSigning != nil {
		var urlSigning UrlSigningAction
		err := urlSigning.AssignProperties_From_UrlSigningAction(source.UrlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningAction() to populate field UrlSigning")
		}
		action.UrlSigning = &urlSigning
	} else {
		action.UrlSigning = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleAction populates the provided destination DeliveryRuleAction from our DeliveryRuleAction
func (action *DeliveryRuleAction) AssignProperties_To_DeliveryRuleAction(destination *v20210601s.DeliveryRuleAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// CacheExpiration
	if action.CacheExpiration != nil {
		var cacheExpiration v20210601s.DeliveryRuleCacheExpirationAction
		err := action.CacheExpiration.AssignProperties_To_DeliveryRuleCacheExpirationAction(&cacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheExpirationAction() to populate field CacheExpiration")
		}
		destination.CacheExpiration = &cacheExpiration
	} else {
		destination.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if action.CacheKeyQueryString != nil {
		var cacheKeyQueryString v20210601s.DeliveryRuleCacheKeyQueryStringAction
		err := action.CacheKeyQueryString.AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction(&cacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction() to populate field CacheKeyQueryString")
		}
		destination.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		destination.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if action.ModifyRequestHeader != nil {
		var modifyRequestHeader v20210601s.DeliveryRuleRequestHeaderAction
		err := action.ModifyRequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderAction(&modifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderAction() to populate field ModifyRequestHeader")
		}
		destination.ModifyRequestHeader = &modifyRequestHeader
	} else {
		destination.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if action.ModifyResponseHeader != nil {
		var modifyResponseHeader v20210601s.DeliveryRuleResponseHeaderAction
		err := action.ModifyResponseHeader.AssignProperties_To_DeliveryRuleResponseHeaderAction(&modifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleResponseHeaderAction() to populate field ModifyResponseHeader")
		}
		destination.ModifyResponseHeader = &modifyResponseHeader
	} else {
		destination.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if action.OriginGroupOverride != nil {
		var originGroupOverride v20210601s.OriginGroupOverrideAction
		err := action.OriginGroupOverride.AssignProperties_To_OriginGroupOverrideAction(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideAction() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if action.RouteConfigurationOverride != nil {
		var routeConfigurationOverride v20210601s.DeliveryRuleRouteConfigurationOverrideAction
		err := action.RouteConfigurationOverride.AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction(&routeConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction() to populate field RouteConfigurationOverride")
		}
		destination.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		destination.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if action.UrlRedirect != nil {
		var urlRedirect v20210601s.UrlRedirectAction
		err := action.UrlRedirect.AssignProperties_To_UrlRedirectAction(&urlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectAction() to populate field UrlRedirect")
		}
		destination.UrlRedirect = &urlRedirect
	} else {
		destination.UrlRedirect = nil
	}

	// UrlRewrite
	if action.UrlRewrite != nil {
		var urlRewrite v20210601s.UrlRewriteAction
		err := action.UrlRewrite.AssignProperties_To_UrlRewriteAction(&urlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteAction() to populate field UrlRewrite")
		}
		destination.UrlRewrite = &urlRewrite
	} else {
		destination.UrlRewrite = nil
	}

	// UrlSigning
	if action.UrlSigning != nil {
		var urlSigning v20210601s.UrlSigningAction
		err := action.UrlSigning.AssignProperties_To_UrlSigningAction(&urlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningAction() to populate field UrlSigning")
		}
		destination.UrlSigning = &urlSigning
	} else {
		destination.UrlSigning = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleAction_STATUS
// Deprecated version of DeliveryRuleAction_STATUS. Use v1api20210601.DeliveryRuleAction_STATUS instead
type DeliveryRuleAction_STATUS struct {
	CacheExpiration            *DeliveryRuleCacheExpirationAction_STATUS            `json:"cacheExpiration,omitempty"`
	CacheKeyQueryString        *DeliveryRuleCacheKeyQueryStringAction_STATUS        `json:"cacheKeyQueryString,omitempty"`
	ModifyRequestHeader        *DeliveryRuleRequestHeaderAction_STATUS              `json:"modifyRequestHeader,omitempty"`
	ModifyResponseHeader       *DeliveryRuleResponseHeaderAction_STATUS             `json:"modifyResponseHeader,omitempty"`
	OriginGroupOverride        *OriginGroupOverrideAction_STATUS                    `json:"originGroupOverride,omitempty"`
	PropertyBag                genruntime.PropertyBag                               `json:"$propertyBag,omitempty"`
	RouteConfigurationOverride *DeliveryRuleRouteConfigurationOverrideAction_STATUS `json:"routeConfigurationOverride,omitempty"`
	UrlRedirect                *UrlRedirectAction_STATUS                            `json:"urlRedirect,omitempty"`
	UrlRewrite                 *UrlRewriteAction_STATUS                             `json:"urlRewrite,omitempty"`
	UrlSigning                 *UrlSigningAction_STATUS                             `json:"urlSigning,omitempty"`
}

// AssignProperties_From_DeliveryRuleAction_STATUS populates our DeliveryRuleAction_STATUS from the provided source DeliveryRuleAction_STATUS
func (action *DeliveryRuleAction_STATUS) AssignProperties_From_DeliveryRuleAction_STATUS(source *v20210601s.DeliveryRuleAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheExpiration
	if source.CacheExpiration != nil {
		var cacheExpiration DeliveryRuleCacheExpirationAction_STATUS
		err := cacheExpiration.AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS(source.CacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS() to populate field CacheExpiration")
		}
		action.CacheExpiration = &cacheExpiration
	} else {
		action.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if source.CacheKeyQueryString != nil {
		var cacheKeyQueryString DeliveryRuleCacheKeyQueryStringAction_STATUS
		err := cacheKeyQueryString.AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS(source.CacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS() to populate field CacheKeyQueryString")
		}
		action.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		action.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if source.ModifyRequestHeader != nil {
		var modifyRequestHeader DeliveryRuleRequestHeaderAction_STATUS
		err := modifyRequestHeader.AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS(source.ModifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS() to populate field ModifyRequestHeader")
		}
		action.ModifyRequestHeader = &modifyRequestHeader
	} else {
		action.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if source.ModifyResponseHeader != nil {
		var modifyResponseHeader DeliveryRuleResponseHeaderAction_STATUS
		err := modifyResponseHeader.AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS(source.ModifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS() to populate field ModifyResponseHeader")
		}
		action.ModifyResponseHeader = &modifyResponseHeader
	} else {
		action.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverrideAction_STATUS
		err := originGroupOverride.AssignProperties_From_OriginGroupOverrideAction_STATUS(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideAction_STATUS() to populate field OriginGroupOverride")
		}
		action.OriginGroupOverride = &originGroupOverride
	} else {
		action.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if source.RouteConfigurationOverride != nil {
		var routeConfigurationOverride DeliveryRuleRouteConfigurationOverrideAction_STATUS
		err := routeConfigurationOverride.AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS(source.RouteConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS() to populate field RouteConfigurationOverride")
		}
		action.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		action.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if source.UrlRedirect != nil {
		var urlRedirect UrlRedirectAction_STATUS
		err := urlRedirect.AssignProperties_From_UrlRedirectAction_STATUS(source.UrlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectAction_STATUS() to populate field UrlRedirect")
		}
		action.UrlRedirect = &urlRedirect
	} else {
		action.UrlRedirect = nil
	}

	// UrlRewrite
	if source.UrlRewrite != nil {
		var urlRewrite UrlRewriteAction_STATUS
		err := urlRewrite.AssignProperties_From_UrlRewriteAction_STATUS(source.UrlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteAction_STATUS() to populate field UrlRewrite")
		}
		action.UrlRewrite = &urlRewrite
	} else {
		action.UrlRewrite = nil
	}

	// UrlSigning
	if source.UrlSigning != nil {
		var urlSigning UrlSigningAction_STATUS
		err := urlSigning.AssignProperties_From_UrlSigningAction_STATUS(source.UrlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningAction_STATUS() to populate field UrlSigning")
		}
		action.UrlSigning = &urlSigning
	} else {
		action.UrlSigning = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleAction_STATUS populates the provided destination DeliveryRuleAction_STATUS from our DeliveryRuleAction_STATUS
func (action *DeliveryRuleAction_STATUS) AssignProperties_To_DeliveryRuleAction_STATUS(destination *v20210601s.DeliveryRuleAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// CacheExpiration
	if action.CacheExpiration != nil {
		var cacheExpiration v20210601s.DeliveryRuleCacheExpirationAction_STATUS
		err := action.CacheExpiration.AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS(&cacheExpiration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS() to populate field CacheExpiration")
		}
		destination.CacheExpiration = &cacheExpiration
	} else {
		destination.CacheExpiration = nil
	}

	// CacheKeyQueryString
	if action.CacheKeyQueryString != nil {
		var cacheKeyQueryString v20210601s.DeliveryRuleCacheKeyQueryStringAction_STATUS
		err := action.CacheKeyQueryString.AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS(&cacheKeyQueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS() to populate field CacheKeyQueryString")
		}
		destination.CacheKeyQueryString = &cacheKeyQueryString
	} else {
		destination.CacheKeyQueryString = nil
	}

	// ModifyRequestHeader
	if action.ModifyRequestHeader != nil {
		var modifyRequestHeader v20210601s.DeliveryRuleRequestHeaderAction_STATUS
		err := action.ModifyRequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS(&modifyRequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS() to populate field ModifyRequestHeader")
		}
		destination.ModifyRequestHeader = &modifyRequestHeader
	} else {
		destination.ModifyRequestHeader = nil
	}

	// ModifyResponseHeader
	if action.ModifyResponseHeader != nil {
		var modifyResponseHeader v20210601s.DeliveryRuleResponseHeaderAction_STATUS
		err := action.ModifyResponseHeader.AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS(&modifyResponseHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS() to populate field ModifyResponseHeader")
		}
		destination.ModifyResponseHeader = &modifyResponseHeader
	} else {
		destination.ModifyResponseHeader = nil
	}

	// OriginGroupOverride
	if action.OriginGroupOverride != nil {
		var originGroupOverride v20210601s.OriginGroupOverrideAction_STATUS
		err := action.OriginGroupOverride.AssignProperties_To_OriginGroupOverrideAction_STATUS(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideAction_STATUS() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// RouteConfigurationOverride
	if action.RouteConfigurationOverride != nil {
		var routeConfigurationOverride v20210601s.DeliveryRuleRouteConfigurationOverrideAction_STATUS
		err := action.RouteConfigurationOverride.AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS(&routeConfigurationOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS() to populate field RouteConfigurationOverride")
		}
		destination.RouteConfigurationOverride = &routeConfigurationOverride
	} else {
		destination.RouteConfigurationOverride = nil
	}

	// UrlRedirect
	if action.UrlRedirect != nil {
		var urlRedirect v20210601s.UrlRedirectAction_STATUS
		err := action.UrlRedirect.AssignProperties_To_UrlRedirectAction_STATUS(&urlRedirect)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectAction_STATUS() to populate field UrlRedirect")
		}
		destination.UrlRedirect = &urlRedirect
	} else {
		destination.UrlRedirect = nil
	}

	// UrlRewrite
	if action.UrlRewrite != nil {
		var urlRewrite v20210601s.UrlRewriteAction_STATUS
		err := action.UrlRewrite.AssignProperties_To_UrlRewriteAction_STATUS(&urlRewrite)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteAction_STATUS() to populate field UrlRewrite")
		}
		destination.UrlRewrite = &urlRewrite
	} else {
		destination.UrlRewrite = nil
	}

	// UrlSigning
	if action.UrlSigning != nil {
		var urlSigning v20210601s.UrlSigningAction_STATUS
		err := action.UrlSigning.AssignProperties_To_UrlSigningAction_STATUS(&urlSigning)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningAction_STATUS() to populate field UrlSigning")
		}
		destination.UrlSigning = &urlSigning
	} else {
		destination.UrlSigning = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleCondition
// Deprecated version of DeliveryRuleCondition. Use v1api20210601.DeliveryRuleCondition instead
type DeliveryRuleCondition struct {
	ClientPort       *DeliveryRuleClientPortCondition       `json:"clientPort,omitempty"`
	Cookies          *DeliveryRuleCookiesCondition          `json:"cookies,omitempty"`
	HostName         *DeliveryRuleHostNameCondition         `json:"hostName,omitempty"`
	HttpVersion      *DeliveryRuleHttpVersionCondition      `json:"httpVersion,omitempty"`
	IsDevice         *DeliveryRuleIsDeviceCondition         `json:"isDevice,omitempty"`
	PostArgs         *DeliveryRulePostArgsCondition         `json:"postArgs,omitempty"`
	PropertyBag      genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	QueryString      *DeliveryRuleQueryStringCondition      `json:"queryString,omitempty"`
	RemoteAddress    *DeliveryRuleRemoteAddressCondition    `json:"remoteAddress,omitempty"`
	RequestBody      *DeliveryRuleRequestBodyCondition      `json:"requestBody,omitempty"`
	RequestHeader    *DeliveryRuleRequestHeaderCondition    `json:"requestHeader,omitempty"`
	RequestMethod    *DeliveryRuleRequestMethodCondition    `json:"requestMethod,omitempty"`
	RequestScheme    *DeliveryRuleRequestSchemeCondition    `json:"requestScheme,omitempty"`
	RequestUri       *DeliveryRuleRequestUriCondition       `json:"requestUri,omitempty"`
	ServerPort       *DeliveryRuleServerPortCondition       `json:"serverPort,omitempty"`
	SocketAddr       *DeliveryRuleSocketAddrCondition       `json:"socketAddr,omitempty"`
	SslProtocol      *DeliveryRuleSslProtocolCondition      `json:"sslProtocol,omitempty"`
	UrlFileExtension *DeliveryRuleUrlFileExtensionCondition `json:"urlFileExtension,omitempty"`
	UrlFileName      *DeliveryRuleUrlFileNameCondition      `json:"urlFileName,omitempty"`
	UrlPath          *DeliveryRuleUrlPathCondition          `json:"urlPath,omitempty"`
}

// AssignProperties_From_DeliveryRuleCondition populates our DeliveryRuleCondition from the provided source DeliveryRuleCondition
func (condition *DeliveryRuleCondition) AssignProperties_From_DeliveryRuleCondition(source *v20210601s.DeliveryRuleCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientPort
	if source.ClientPort != nil {
		var clientPort DeliveryRuleClientPortCondition
		err := clientPort.AssignProperties_From_DeliveryRuleClientPortCondition(source.ClientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleClientPortCondition() to populate field ClientPort")
		}
		condition.ClientPort = &clientPort
	} else {
		condition.ClientPort = nil
	}

	// Cookies
	if source.Cookies != nil {
		var cookie DeliveryRuleCookiesCondition
		err := cookie.AssignProperties_From_DeliveryRuleCookiesCondition(source.Cookies)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCookiesCondition() to populate field Cookies")
		}
		condition.Cookies = &cookie
	} else {
		condition.Cookies = nil
	}

	// HostName
	if source.HostName != nil {
		var hostName DeliveryRuleHostNameCondition
		err := hostName.AssignProperties_From_DeliveryRuleHostNameCondition(source.HostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHostNameCondition() to populate field HostName")
		}
		condition.HostName = &hostName
	} else {
		condition.HostName = nil
	}

	// HttpVersion
	if source.HttpVersion != nil {
		var httpVersion DeliveryRuleHttpVersionCondition
		err := httpVersion.AssignProperties_From_DeliveryRuleHttpVersionCondition(source.HttpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHttpVersionCondition() to populate field HttpVersion")
		}
		condition.HttpVersion = &httpVersion
	} else {
		condition.HttpVersion = nil
	}

	// IsDevice
	if source.IsDevice != nil {
		var isDevice DeliveryRuleIsDeviceCondition
		err := isDevice.AssignProperties_From_DeliveryRuleIsDeviceCondition(source.IsDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleIsDeviceCondition() to populate field IsDevice")
		}
		condition.IsDevice = &isDevice
	} else {
		condition.IsDevice = nil
	}

	// PostArgs
	if source.PostArgs != nil {
		var postArg DeliveryRulePostArgsCondition
		err := postArg.AssignProperties_From_DeliveryRulePostArgsCondition(source.PostArgs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRulePostArgsCondition() to populate field PostArgs")
		}
		condition.PostArgs = &postArg
	} else {
		condition.PostArgs = nil
	}

	// QueryString
	if source.QueryString != nil {
		var queryString DeliveryRuleQueryStringCondition
		err := queryString.AssignProperties_From_DeliveryRuleQueryStringCondition(source.QueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleQueryStringCondition() to populate field QueryString")
		}
		condition.QueryString = &queryString
	} else {
		condition.QueryString = nil
	}

	// RemoteAddress
	if source.RemoteAddress != nil {
		var remoteAddress DeliveryRuleRemoteAddressCondition
		err := remoteAddress.AssignProperties_From_DeliveryRuleRemoteAddressCondition(source.RemoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRemoteAddressCondition() to populate field RemoteAddress")
		}
		condition.RemoteAddress = &remoteAddress
	} else {
		condition.RemoteAddress = nil
	}

	// RequestBody
	if source.RequestBody != nil {
		var requestBody DeliveryRuleRequestBodyCondition
		err := requestBody.AssignProperties_From_DeliveryRuleRequestBodyCondition(source.RequestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestBodyCondition() to populate field RequestBody")
		}
		condition.RequestBody = &requestBody
	} else {
		condition.RequestBody = nil
	}

	// RequestHeader
	if source.RequestHeader != nil {
		var requestHeader DeliveryRuleRequestHeaderCondition
		err := requestHeader.AssignProperties_From_DeliveryRuleRequestHeaderCondition(source.RequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderCondition() to populate field RequestHeader")
		}
		condition.RequestHeader = &requestHeader
	} else {
		condition.RequestHeader = nil
	}

	// RequestMethod
	if source.RequestMethod != nil {
		var requestMethod DeliveryRuleRequestMethodCondition
		err := requestMethod.AssignProperties_From_DeliveryRuleRequestMethodCondition(source.RequestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestMethodCondition() to populate field RequestMethod")
		}
		condition.RequestMethod = &requestMethod
	} else {
		condition.RequestMethod = nil
	}

	// RequestScheme
	if source.RequestScheme != nil {
		var requestScheme DeliveryRuleRequestSchemeCondition
		err := requestScheme.AssignProperties_From_DeliveryRuleRequestSchemeCondition(source.RequestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestSchemeCondition() to populate field RequestScheme")
		}
		condition.RequestScheme = &requestScheme
	} else {
		condition.RequestScheme = nil
	}

	// RequestUri
	if source.RequestUri != nil {
		var requestUri DeliveryRuleRequestUriCondition
		err := requestUri.AssignProperties_From_DeliveryRuleRequestUriCondition(source.RequestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestUriCondition() to populate field RequestUri")
		}
		condition.RequestUri = &requestUri
	} else {
		condition.RequestUri = nil
	}

	// ServerPort
	if source.ServerPort != nil {
		var serverPort DeliveryRuleServerPortCondition
		err := serverPort.AssignProperties_From_DeliveryRuleServerPortCondition(source.ServerPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleServerPortCondition() to populate field ServerPort")
		}
		condition.ServerPort = &serverPort
	} else {
		condition.ServerPort = nil
	}

	// SocketAddr
	if source.SocketAddr != nil {
		var socketAddr DeliveryRuleSocketAddrCondition
		err := socketAddr.AssignProperties_From_DeliveryRuleSocketAddrCondition(source.SocketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSocketAddrCondition() to populate field SocketAddr")
		}
		condition.SocketAddr = &socketAddr
	} else {
		condition.SocketAddr = nil
	}

	// SslProtocol
	if source.SslProtocol != nil {
		var sslProtocol DeliveryRuleSslProtocolCondition
		err := sslProtocol.AssignProperties_From_DeliveryRuleSslProtocolCondition(source.SslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSslProtocolCondition() to populate field SslProtocol")
		}
		condition.SslProtocol = &sslProtocol
	} else {
		condition.SslProtocol = nil
	}

	// UrlFileExtension
	if source.UrlFileExtension != nil {
		var urlFileExtension DeliveryRuleUrlFileExtensionCondition
		err := urlFileExtension.AssignProperties_From_DeliveryRuleUrlFileExtensionCondition(source.UrlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileExtensionCondition() to populate field UrlFileExtension")
		}
		condition.UrlFileExtension = &urlFileExtension
	} else {
		condition.UrlFileExtension = nil
	}

	// UrlFileName
	if source.UrlFileName != nil {
		var urlFileName DeliveryRuleUrlFileNameCondition
		err := urlFileName.AssignProperties_From_DeliveryRuleUrlFileNameCondition(source.UrlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileNameCondition() to populate field UrlFileName")
		}
		condition.UrlFileName = &urlFileName
	} else {
		condition.UrlFileName = nil
	}

	// UrlPath
	if source.UrlPath != nil {
		var urlPath DeliveryRuleUrlPathCondition
		err := urlPath.AssignProperties_From_DeliveryRuleUrlPathCondition(source.UrlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlPathCondition() to populate field UrlPath")
		}
		condition.UrlPath = &urlPath
	} else {
		condition.UrlPath = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCondition populates the provided destination DeliveryRuleCondition from our DeliveryRuleCondition
func (condition *DeliveryRuleCondition) AssignProperties_To_DeliveryRuleCondition(destination *v20210601s.DeliveryRuleCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// ClientPort
	if condition.ClientPort != nil {
		var clientPort v20210601s.DeliveryRuleClientPortCondition
		err := condition.ClientPort.AssignProperties_To_DeliveryRuleClientPortCondition(&clientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleClientPortCondition() to populate field ClientPort")
		}
		destination.ClientPort = &clientPort
	} else {
		destination.ClientPort = nil
	}

	// Cookies
	if condition.Cookies != nil {
		var cookie v20210601s.DeliveryRuleCookiesCondition
		err := condition.Cookies.AssignProperties_To_DeliveryRuleCookiesCondition(&cookie)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCookiesCondition() to populate field Cookies")
		}
		destination.Cookies = &cookie
	} else {
		destination.Cookies = nil
	}

	// HostName
	if condition.HostName != nil {
		var hostName v20210601s.DeliveryRuleHostNameCondition
		err := condition.HostName.AssignProperties_To_DeliveryRuleHostNameCondition(&hostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHostNameCondition() to populate field HostName")
		}
		destination.HostName = &hostName
	} else {
		destination.HostName = nil
	}

	// HttpVersion
	if condition.HttpVersion != nil {
		var httpVersion v20210601s.DeliveryRuleHttpVersionCondition
		err := condition.HttpVersion.AssignProperties_To_DeliveryRuleHttpVersionCondition(&httpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHttpVersionCondition() to populate field HttpVersion")
		}
		destination.HttpVersion = &httpVersion
	} else {
		destination.HttpVersion = nil
	}

	// IsDevice
	if condition.IsDevice != nil {
		var isDevice v20210601s.DeliveryRuleIsDeviceCondition
		err := condition.IsDevice.AssignProperties_To_DeliveryRuleIsDeviceCondition(&isDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleIsDeviceCondition() to populate field IsDevice")
		}
		destination.IsDevice = &isDevice
	} else {
		destination.IsDevice = nil
	}

	// PostArgs
	if condition.PostArgs != nil {
		var postArg v20210601s.DeliveryRulePostArgsCondition
		err := condition.PostArgs.AssignProperties_To_DeliveryRulePostArgsCondition(&postArg)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRulePostArgsCondition() to populate field PostArgs")
		}
		destination.PostArgs = &postArg
	} else {
		destination.PostArgs = nil
	}

	// QueryString
	if condition.QueryString != nil {
		var queryString v20210601s.DeliveryRuleQueryStringCondition
		err := condition.QueryString.AssignProperties_To_DeliveryRuleQueryStringCondition(&queryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleQueryStringCondition() to populate field QueryString")
		}
		destination.QueryString = &queryString
	} else {
		destination.QueryString = nil
	}

	// RemoteAddress
	if condition.RemoteAddress != nil {
		var remoteAddress v20210601s.DeliveryRuleRemoteAddressCondition
		err := condition.RemoteAddress.AssignProperties_To_DeliveryRuleRemoteAddressCondition(&remoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRemoteAddressCondition() to populate field RemoteAddress")
		}
		destination.RemoteAddress = &remoteAddress
	} else {
		destination.RemoteAddress = nil
	}

	// RequestBody
	if condition.RequestBody != nil {
		var requestBody v20210601s.DeliveryRuleRequestBodyCondition
		err := condition.RequestBody.AssignProperties_To_DeliveryRuleRequestBodyCondition(&requestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestBodyCondition() to populate field RequestBody")
		}
		destination.RequestBody = &requestBody
	} else {
		destination.RequestBody = nil
	}

	// RequestHeader
	if condition.RequestHeader != nil {
		var requestHeader v20210601s.DeliveryRuleRequestHeaderCondition
		err := condition.RequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderCondition(&requestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderCondition() to populate field RequestHeader")
		}
		destination.RequestHeader = &requestHeader
	} else {
		destination.RequestHeader = nil
	}

	// RequestMethod
	if condition.RequestMethod != nil {
		var requestMethod v20210601s.DeliveryRuleRequestMethodCondition
		err := condition.RequestMethod.AssignProperties_To_DeliveryRuleRequestMethodCondition(&requestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestMethodCondition() to populate field RequestMethod")
		}
		destination.RequestMethod = &requestMethod
	} else {
		destination.RequestMethod = nil
	}

	// RequestScheme
	if condition.RequestScheme != nil {
		var requestScheme v20210601s.DeliveryRuleRequestSchemeCondition
		err := condition.RequestScheme.AssignProperties_To_DeliveryRuleRequestSchemeCondition(&requestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestSchemeCondition() to populate field RequestScheme")
		}
		destination.RequestScheme = &requestScheme
	} else {
		destination.RequestScheme = nil
	}

	// RequestUri
	if condition.RequestUri != nil {
		var requestUri v20210601s.DeliveryRuleRequestUriCondition
		err := condition.RequestUri.AssignProperties_To_DeliveryRuleRequestUriCondition(&requestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestUriCondition() to populate field RequestUri")
		}
		destination.RequestUri = &requestUri
	} else {
		destination.RequestUri = nil
	}

	// ServerPort
	if condition.ServerPort != nil {
		var serverPort v20210601s.DeliveryRuleServerPortCondition
		err := condition.ServerPort.AssignProperties_To_DeliveryRuleServerPortCondition(&serverPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleServerPortCondition() to populate field ServerPort")
		}
		destination.ServerPort = &serverPort
	} else {
		destination.ServerPort = nil
	}

	// SocketAddr
	if condition.SocketAddr != nil {
		var socketAddr v20210601s.DeliveryRuleSocketAddrCondition
		err := condition.SocketAddr.AssignProperties_To_DeliveryRuleSocketAddrCondition(&socketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSocketAddrCondition() to populate field SocketAddr")
		}
		destination.SocketAddr = &socketAddr
	} else {
		destination.SocketAddr = nil
	}

	// SslProtocol
	if condition.SslProtocol != nil {
		var sslProtocol v20210601s.DeliveryRuleSslProtocolCondition
		err := condition.SslProtocol.AssignProperties_To_DeliveryRuleSslProtocolCondition(&sslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSslProtocolCondition() to populate field SslProtocol")
		}
		destination.SslProtocol = &sslProtocol
	} else {
		destination.SslProtocol = nil
	}

	// UrlFileExtension
	if condition.UrlFileExtension != nil {
		var urlFileExtension v20210601s.DeliveryRuleUrlFileExtensionCondition
		err := condition.UrlFileExtension.AssignProperties_To_DeliveryRuleUrlFileExtensionCondition(&urlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileExtensionCondition() to populate field UrlFileExtension")
		}
		destination.UrlFileExtension = &urlFileExtension
	} else {
		destination.UrlFileExtension = nil
	}

	// UrlFileName
	if condition.UrlFileName != nil {
		var urlFileName v20210601s.DeliveryRuleUrlFileNameCondition
		err := condition.UrlFileName.AssignProperties_To_DeliveryRuleUrlFileNameCondition(&urlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileNameCondition() to populate field UrlFileName")
		}
		destination.UrlFileName = &urlFileName
	} else {
		destination.UrlFileName = nil
	}

	// UrlPath
	if condition.UrlPath != nil {
		var urlPath v20210601s.DeliveryRuleUrlPathCondition
		err := condition.UrlPath.AssignProperties_To_DeliveryRuleUrlPathCondition(&urlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlPathCondition() to populate field UrlPath")
		}
		destination.UrlPath = &urlPath
	} else {
		destination.UrlPath = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleCondition_STATUS
// Deprecated version of DeliveryRuleCondition_STATUS. Use v1api20210601.DeliveryRuleCondition_STATUS instead
type DeliveryRuleCondition_STATUS struct {
	ClientPort       *DeliveryRuleClientPortCondition_STATUS       `json:"clientPort,omitempty"`
	Cookies          *DeliveryRuleCookiesCondition_STATUS          `json:"cookies,omitempty"`
	HostName         *DeliveryRuleHostNameCondition_STATUS         `json:"hostName,omitempty"`
	HttpVersion      *DeliveryRuleHttpVersionCondition_STATUS      `json:"httpVersion,omitempty"`
	IsDevice         *DeliveryRuleIsDeviceCondition_STATUS         `json:"isDevice,omitempty"`
	PostArgs         *DeliveryRulePostArgsCondition_STATUS         `json:"postArgs,omitempty"`
	PropertyBag      genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
	QueryString      *DeliveryRuleQueryStringCondition_STATUS      `json:"queryString,omitempty"`
	RemoteAddress    *DeliveryRuleRemoteAddressCondition_STATUS    `json:"remoteAddress,omitempty"`
	RequestBody      *DeliveryRuleRequestBodyCondition_STATUS      `json:"requestBody,omitempty"`
	RequestHeader    *DeliveryRuleRequestHeaderCondition_STATUS    `json:"requestHeader,omitempty"`
	RequestMethod    *DeliveryRuleRequestMethodCondition_STATUS    `json:"requestMethod,omitempty"`
	RequestScheme    *DeliveryRuleRequestSchemeCondition_STATUS    `json:"requestScheme,omitempty"`
	RequestUri       *DeliveryRuleRequestUriCondition_STATUS       `json:"requestUri,omitempty"`
	ServerPort       *DeliveryRuleServerPortCondition_STATUS       `json:"serverPort,omitempty"`
	SocketAddr       *DeliveryRuleSocketAddrCondition_STATUS       `json:"socketAddr,omitempty"`
	SslProtocol      *DeliveryRuleSslProtocolCondition_STATUS      `json:"sslProtocol,omitempty"`
	UrlFileExtension *DeliveryRuleUrlFileExtensionCondition_STATUS `json:"urlFileExtension,omitempty"`
	UrlFileName      *DeliveryRuleUrlFileNameCondition_STATUS      `json:"urlFileName,omitempty"`
	UrlPath          *DeliveryRuleUrlPathCondition_STATUS          `json:"urlPath,omitempty"`
}

// AssignProperties_From_DeliveryRuleCondition_STATUS populates our DeliveryRuleCondition_STATUS from the provided source DeliveryRuleCondition_STATUS
func (condition *DeliveryRuleCondition_STATUS) AssignProperties_From_DeliveryRuleCondition_STATUS(source *v20210601s.DeliveryRuleCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientPort
	if source.ClientPort != nil {
		var clientPort DeliveryRuleClientPortCondition_STATUS
		err := clientPort.AssignProperties_From_DeliveryRuleClientPortCondition_STATUS(source.ClientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleClientPortCondition_STATUS() to populate field ClientPort")
		}
		condition.ClientPort = &clientPort
	} else {
		condition.ClientPort = nil
	}

	// Cookies
	if source.Cookies != nil {
		var cookie DeliveryRuleCookiesCondition_STATUS
		err := cookie.AssignProperties_From_DeliveryRuleCookiesCondition_STATUS(source.Cookies)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleCookiesCondition_STATUS() to populate field Cookies")
		}
		condition.Cookies = &cookie
	} else {
		condition.Cookies = nil
	}

	// HostName
	if source.HostName != nil {
		var hostName DeliveryRuleHostNameCondition_STATUS
		err := hostName.AssignProperties_From_DeliveryRuleHostNameCondition_STATUS(source.HostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHostNameCondition_STATUS() to populate field HostName")
		}
		condition.HostName = &hostName
	} else {
		condition.HostName = nil
	}

	// HttpVersion
	if source.HttpVersion != nil {
		var httpVersion DeliveryRuleHttpVersionCondition_STATUS
		err := httpVersion.AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS(source.HttpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS() to populate field HttpVersion")
		}
		condition.HttpVersion = &httpVersion
	} else {
		condition.HttpVersion = nil
	}

	// IsDevice
	if source.IsDevice != nil {
		var isDevice DeliveryRuleIsDeviceCondition_STATUS
		err := isDevice.AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS(source.IsDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS() to populate field IsDevice")
		}
		condition.IsDevice = &isDevice
	} else {
		condition.IsDevice = nil
	}

	// PostArgs
	if source.PostArgs != nil {
		var postArg DeliveryRulePostArgsCondition_STATUS
		err := postArg.AssignProperties_From_DeliveryRulePostArgsCondition_STATUS(source.PostArgs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRulePostArgsCondition_STATUS() to populate field PostArgs")
		}
		condition.PostArgs = &postArg
	} else {
		condition.PostArgs = nil
	}

	// QueryString
	if source.QueryString != nil {
		var queryString DeliveryRuleQueryStringCondition_STATUS
		err := queryString.AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS(source.QueryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS() to populate field QueryString")
		}
		condition.QueryString = &queryString
	} else {
		condition.QueryString = nil
	}

	// RemoteAddress
	if source.RemoteAddress != nil {
		var remoteAddress DeliveryRuleRemoteAddressCondition_STATUS
		err := remoteAddress.AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS(source.RemoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS() to populate field RemoteAddress")
		}
		condition.RemoteAddress = &remoteAddress
	} else {
		condition.RemoteAddress = nil
	}

	// RequestBody
	if source.RequestBody != nil {
		var requestBody DeliveryRuleRequestBodyCondition_STATUS
		err := requestBody.AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS(source.RequestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS() to populate field RequestBody")
		}
		condition.RequestBody = &requestBody
	} else {
		condition.RequestBody = nil
	}

	// RequestHeader
	if source.RequestHeader != nil {
		var requestHeader DeliveryRuleRequestHeaderCondition_STATUS
		err := requestHeader.AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS(source.RequestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS() to populate field RequestHeader")
		}
		condition.RequestHeader = &requestHeader
	} else {
		condition.RequestHeader = nil
	}

	// RequestMethod
	if source.RequestMethod != nil {
		var requestMethod DeliveryRuleRequestMethodCondition_STATUS
		err := requestMethod.AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS(source.RequestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS() to populate field RequestMethod")
		}
		condition.RequestMethod = &requestMethod
	} else {
		condition.RequestMethod = nil
	}

	// RequestScheme
	if source.RequestScheme != nil {
		var requestScheme DeliveryRuleRequestSchemeCondition_STATUS
		err := requestScheme.AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS(source.RequestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS() to populate field RequestScheme")
		}
		condition.RequestScheme = &requestScheme
	} else {
		condition.RequestScheme = nil
	}

	// RequestUri
	if source.RequestUri != nil {
		var requestUri DeliveryRuleRequestUriCondition_STATUS
		err := requestUri.AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS(source.RequestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS() to populate field RequestUri")
		}
		condition.RequestUri = &requestUri
	} else {
		condition.RequestUri = nil
	}

	// ServerPort
	if source.ServerPort != nil {
		var serverPort DeliveryRuleServerPortCondition_STATUS
		err := serverPort.AssignProperties_From_DeliveryRuleServerPortCondition_STATUS(source.ServerPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleServerPortCondition_STATUS() to populate field ServerPort")
		}
		condition.ServerPort = &serverPort
	} else {
		condition.ServerPort = nil
	}

	// SocketAddr
	if source.SocketAddr != nil {
		var socketAddr DeliveryRuleSocketAddrCondition_STATUS
		err := socketAddr.AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS(source.SocketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS() to populate field SocketAddr")
		}
		condition.SocketAddr = &socketAddr
	} else {
		condition.SocketAddr = nil
	}

	// SslProtocol
	if source.SslProtocol != nil {
		var sslProtocol DeliveryRuleSslProtocolCondition_STATUS
		err := sslProtocol.AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS(source.SslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS() to populate field SslProtocol")
		}
		condition.SslProtocol = &sslProtocol
	} else {
		condition.SslProtocol = nil
	}

	// UrlFileExtension
	if source.UrlFileExtension != nil {
		var urlFileExtension DeliveryRuleUrlFileExtensionCondition_STATUS
		err := urlFileExtension.AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS(source.UrlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS() to populate field UrlFileExtension")
		}
		condition.UrlFileExtension = &urlFileExtension
	} else {
		condition.UrlFileExtension = nil
	}

	// UrlFileName
	if source.UrlFileName != nil {
		var urlFileName DeliveryRuleUrlFileNameCondition_STATUS
		err := urlFileName.AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS(source.UrlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS() to populate field UrlFileName")
		}
		condition.UrlFileName = &urlFileName
	} else {
		condition.UrlFileName = nil
	}

	// UrlPath
	if source.UrlPath != nil {
		var urlPath DeliveryRuleUrlPathCondition_STATUS
		err := urlPath.AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS(source.UrlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS() to populate field UrlPath")
		}
		condition.UrlPath = &urlPath
	} else {
		condition.UrlPath = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCondition_STATUS populates the provided destination DeliveryRuleCondition_STATUS from our DeliveryRuleCondition_STATUS
func (condition *DeliveryRuleCondition_STATUS) AssignProperties_To_DeliveryRuleCondition_STATUS(destination *v20210601s.DeliveryRuleCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// ClientPort
	if condition.ClientPort != nil {
		var clientPort v20210601s.DeliveryRuleClientPortCondition_STATUS
		err := condition.ClientPort.AssignProperties_To_DeliveryRuleClientPortCondition_STATUS(&clientPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleClientPortCondition_STATUS() to populate field ClientPort")
		}
		destination.ClientPort = &clientPort
	} else {
		destination.ClientPort = nil
	}

	// Cookies
	if condition.Cookies != nil {
		var cookie v20210601s.DeliveryRuleCookiesCondition_STATUS
		err := condition.Cookies.AssignProperties_To_DeliveryRuleCookiesCondition_STATUS(&cookie)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleCookiesCondition_STATUS() to populate field Cookies")
		}
		destination.Cookies = &cookie
	} else {
		destination.Cookies = nil
	}

	// HostName
	if condition.HostName != nil {
		var hostName v20210601s.DeliveryRuleHostNameCondition_STATUS
		err := condition.HostName.AssignProperties_To_DeliveryRuleHostNameCondition_STATUS(&hostName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHostNameCondition_STATUS() to populate field HostName")
		}
		destination.HostName = &hostName
	} else {
		destination.HostName = nil
	}

	// HttpVersion
	if condition.HttpVersion != nil {
		var httpVersion v20210601s.DeliveryRuleHttpVersionCondition_STATUS
		err := condition.HttpVersion.AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS(&httpVersion)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS() to populate field HttpVersion")
		}
		destination.HttpVersion = &httpVersion
	} else {
		destination.HttpVersion = nil
	}

	// IsDevice
	if condition.IsDevice != nil {
		var isDevice v20210601s.DeliveryRuleIsDeviceCondition_STATUS
		err := condition.IsDevice.AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS(&isDevice)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS() to populate field IsDevice")
		}
		destination.IsDevice = &isDevice
	} else {
		destination.IsDevice = nil
	}

	// PostArgs
	if condition.PostArgs != nil {
		var postArg v20210601s.DeliveryRulePostArgsCondition_STATUS
		err := condition.PostArgs.AssignProperties_To_DeliveryRulePostArgsCondition_STATUS(&postArg)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRulePostArgsCondition_STATUS() to populate field PostArgs")
		}
		destination.PostArgs = &postArg
	} else {
		destination.PostArgs = nil
	}

	// QueryString
	if condition.QueryString != nil {
		var queryString v20210601s.DeliveryRuleQueryStringCondition_STATUS
		err := condition.QueryString.AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS(&queryString)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS() to populate field QueryString")
		}
		destination.QueryString = &queryString
	} else {
		destination.QueryString = nil
	}

	// RemoteAddress
	if condition.RemoteAddress != nil {
		var remoteAddress v20210601s.DeliveryRuleRemoteAddressCondition_STATUS
		err := condition.RemoteAddress.AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS(&remoteAddress)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS() to populate field RemoteAddress")
		}
		destination.RemoteAddress = &remoteAddress
	} else {
		destination.RemoteAddress = nil
	}

	// RequestBody
	if condition.RequestBody != nil {
		var requestBody v20210601s.DeliveryRuleRequestBodyCondition_STATUS
		err := condition.RequestBody.AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS(&requestBody)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS() to populate field RequestBody")
		}
		destination.RequestBody = &requestBody
	} else {
		destination.RequestBody = nil
	}

	// RequestHeader
	if condition.RequestHeader != nil {
		var requestHeader v20210601s.DeliveryRuleRequestHeaderCondition_STATUS
		err := condition.RequestHeader.AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS(&requestHeader)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS() to populate field RequestHeader")
		}
		destination.RequestHeader = &requestHeader
	} else {
		destination.RequestHeader = nil
	}

	// RequestMethod
	if condition.RequestMethod != nil {
		var requestMethod v20210601s.DeliveryRuleRequestMethodCondition_STATUS
		err := condition.RequestMethod.AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS(&requestMethod)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS() to populate field RequestMethod")
		}
		destination.RequestMethod = &requestMethod
	} else {
		destination.RequestMethod = nil
	}

	// RequestScheme
	if condition.RequestScheme != nil {
		var requestScheme v20210601s.DeliveryRuleRequestSchemeCondition_STATUS
		err := condition.RequestScheme.AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS(&requestScheme)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS() to populate field RequestScheme")
		}
		destination.RequestScheme = &requestScheme
	} else {
		destination.RequestScheme = nil
	}

	// RequestUri
	if condition.RequestUri != nil {
		var requestUri v20210601s.DeliveryRuleRequestUriCondition_STATUS
		err := condition.RequestUri.AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS(&requestUri)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS() to populate field RequestUri")
		}
		destination.RequestUri = &requestUri
	} else {
		destination.RequestUri = nil
	}

	// ServerPort
	if condition.ServerPort != nil {
		var serverPort v20210601s.DeliveryRuleServerPortCondition_STATUS
		err := condition.ServerPort.AssignProperties_To_DeliveryRuleServerPortCondition_STATUS(&serverPort)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleServerPortCondition_STATUS() to populate field ServerPort")
		}
		destination.ServerPort = &serverPort
	} else {
		destination.ServerPort = nil
	}

	// SocketAddr
	if condition.SocketAddr != nil {
		var socketAddr v20210601s.DeliveryRuleSocketAddrCondition_STATUS
		err := condition.SocketAddr.AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS(&socketAddr)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS() to populate field SocketAddr")
		}
		destination.SocketAddr = &socketAddr
	} else {
		destination.SocketAddr = nil
	}

	// SslProtocol
	if condition.SslProtocol != nil {
		var sslProtocol v20210601s.DeliveryRuleSslProtocolCondition_STATUS
		err := condition.SslProtocol.AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS(&sslProtocol)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS() to populate field SslProtocol")
		}
		destination.SslProtocol = &sslProtocol
	} else {
		destination.SslProtocol = nil
	}

	// UrlFileExtension
	if condition.UrlFileExtension != nil {
		var urlFileExtension v20210601s.DeliveryRuleUrlFileExtensionCondition_STATUS
		err := condition.UrlFileExtension.AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS(&urlFileExtension)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS() to populate field UrlFileExtension")
		}
		destination.UrlFileExtension = &urlFileExtension
	} else {
		destination.UrlFileExtension = nil
	}

	// UrlFileName
	if condition.UrlFileName != nil {
		var urlFileName v20210601s.DeliveryRuleUrlFileNameCondition_STATUS
		err := condition.UrlFileName.AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS(&urlFileName)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS() to populate field UrlFileName")
		}
		destination.UrlFileName = &urlFileName
	} else {
		destination.UrlFileName = nil
	}

	// UrlPath
	if condition.UrlPath != nil {
		var urlPath v20210601s.DeliveryRuleUrlPathCondition_STATUS
		err := condition.UrlPath.AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS(&urlPath)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS() to populate field UrlPath")
		}
		destination.UrlPath = &urlPath
	} else {
		destination.UrlPath = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.HttpErrorRangeParameters
// Deprecated version of HttpErrorRangeParameters. Use v1api20210601.HttpErrorRangeParameters instead
type HttpErrorRangeParameters struct {
	Begin       *int                   `json:"begin,omitempty"`
	End         *int                   `json:"end,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_HttpErrorRangeParameters populates our HttpErrorRangeParameters from the provided source HttpErrorRangeParameters
func (parameters *HttpErrorRangeParameters) AssignProperties_From_HttpErrorRangeParameters(source *v20210601s.HttpErrorRangeParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Begin
	parameters.Begin = genruntime.ClonePointerToInt(source.Begin)

	// End
	parameters.End = genruntime.ClonePointerToInt(source.End)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpErrorRangeParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHttpErrorRangeParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HttpErrorRangeParameters populates the provided destination HttpErrorRangeParameters from our HttpErrorRangeParameters
func (parameters *HttpErrorRangeParameters) AssignProperties_To_HttpErrorRangeParameters(destination *v20210601s.HttpErrorRangeParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Begin
	destination.Begin = genruntime.ClonePointerToInt(parameters.Begin)

	// End
	destination.End = genruntime.ClonePointerToInt(parameters.End)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpErrorRangeParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHttpErrorRangeParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.HttpErrorRangeParameters_STATUS
// Deprecated version of HttpErrorRangeParameters_STATUS. Use v1api20210601.HttpErrorRangeParameters_STATUS instead
type HttpErrorRangeParameters_STATUS struct {
	Begin       *int                   `json:"begin,omitempty"`
	End         *int                   `json:"end,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_HttpErrorRangeParameters_STATUS populates our HttpErrorRangeParameters_STATUS from the provided source HttpErrorRangeParameters_STATUS
func (parameters *HttpErrorRangeParameters_STATUS) AssignProperties_From_HttpErrorRangeParameters_STATUS(source *v20210601s.HttpErrorRangeParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Begin
	parameters.Begin = genruntime.ClonePointerToInt(source.Begin)

	// End
	parameters.End = genruntime.ClonePointerToInt(source.End)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpErrorRangeParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHttpErrorRangeParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HttpErrorRangeParameters_STATUS populates the provided destination HttpErrorRangeParameters_STATUS from our HttpErrorRangeParameters_STATUS
func (parameters *HttpErrorRangeParameters_STATUS) AssignProperties_To_HttpErrorRangeParameters_STATUS(destination *v20210601s.HttpErrorRangeParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Begin
	destination.Begin = genruntime.ClonePointerToInt(parameters.Begin)

	// End
	destination.End = genruntime.ClonePointerToInt(parameters.End)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpErrorRangeParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHttpErrorRangeParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForDeliveryRuleAction interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleAction) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleAction) error
}

type augmentConversionForDeliveryRuleAction_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleAction_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleAction_STATUS) error
}

type augmentConversionForDeliveryRuleCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleCondition) error
}

type augmentConversionForDeliveryRuleCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleCondition_STATUS) error
}

type augmentConversionForHttpErrorRangeParameters interface {
	AssignPropertiesFrom(src *v20210601s.HttpErrorRangeParameters) error
	AssignPropertiesTo(dst *v20210601s.HttpErrorRangeParameters) error
}

type augmentConversionForHttpErrorRangeParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.HttpErrorRangeParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.HttpErrorRangeParameters_STATUS) error
}

// Storage version of v1beta20210601.DeliveryRuleCacheExpirationAction
// Deprecated version of DeliveryRuleCacheExpirationAction. Use v1api20210601.DeliveryRuleCacheExpirationAction instead
type DeliveryRuleCacheExpirationAction struct {
	Name        *string                          `json:"name,omitempty"`
	Parameters  *CacheExpirationActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleCacheExpirationAction populates our DeliveryRuleCacheExpirationAction from the provided source DeliveryRuleCacheExpirationAction
func (action *DeliveryRuleCacheExpirationAction) AssignProperties_From_DeliveryRuleCacheExpirationAction(source *v20210601s.DeliveryRuleCacheExpirationAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CacheExpirationActionParameters
		err := parameter.AssignProperties_From_CacheExpirationActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheExpirationActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheExpirationAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheExpirationAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheExpirationAction populates the provided destination DeliveryRuleCacheExpirationAction from our DeliveryRuleCacheExpirationAction
func (action *DeliveryRuleCacheExpirationAction) AssignProperties_To_DeliveryRuleCacheExpirationAction(destination *v20210601s.DeliveryRuleCacheExpirationAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.CacheExpirationActionParameters
		err := action.Parameters.AssignProperties_To_CacheExpirationActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheExpirationActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheExpirationAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheExpirationAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleCacheExpirationAction_STATUS
// Deprecated version of DeliveryRuleCacheExpirationAction_STATUS. Use v1api20210601.DeliveryRuleCacheExpirationAction_STATUS instead
type DeliveryRuleCacheExpirationAction_STATUS struct {
	Name        *string                                 `json:"name,omitempty"`
	Parameters  *CacheExpirationActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS populates our DeliveryRuleCacheExpirationAction_STATUS from the provided source DeliveryRuleCacheExpirationAction_STATUS
func (action *DeliveryRuleCacheExpirationAction_STATUS) AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS(source *v20210601s.DeliveryRuleCacheExpirationAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CacheExpirationActionParameters_STATUS
		err := parameter.AssignProperties_From_CacheExpirationActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheExpirationActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheExpirationAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheExpirationAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS populates the provided destination DeliveryRuleCacheExpirationAction_STATUS from our DeliveryRuleCacheExpirationAction_STATUS
func (action *DeliveryRuleCacheExpirationAction_STATUS) AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS(destination *v20210601s.DeliveryRuleCacheExpirationAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.CacheExpirationActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_CacheExpirationActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheExpirationActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheExpirationAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheExpirationAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleCacheKeyQueryStringAction
// Deprecated version of DeliveryRuleCacheKeyQueryStringAction. Use v1api20210601.DeliveryRuleCacheKeyQueryStringAction instead
type DeliveryRuleCacheKeyQueryStringAction struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *CacheKeyQueryStringActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction populates our DeliveryRuleCacheKeyQueryStringAction from the provided source DeliveryRuleCacheKeyQueryStringAction
func (action *DeliveryRuleCacheKeyQueryStringAction) AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction(source *v20210601s.DeliveryRuleCacheKeyQueryStringAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CacheKeyQueryStringActionParameters
		err := parameter.AssignProperties_From_CacheKeyQueryStringActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheKeyQueryStringActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheKeyQueryStringAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheKeyQueryStringAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction populates the provided destination DeliveryRuleCacheKeyQueryStringAction from our DeliveryRuleCacheKeyQueryStringAction
func (action *DeliveryRuleCacheKeyQueryStringAction) AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction(destination *v20210601s.DeliveryRuleCacheKeyQueryStringAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.CacheKeyQueryStringActionParameters
		err := action.Parameters.AssignProperties_To_CacheKeyQueryStringActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheKeyQueryStringActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheKeyQueryStringAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheKeyQueryStringAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleCacheKeyQueryStringAction_STATUS
// Deprecated version of DeliveryRuleCacheKeyQueryStringAction_STATUS. Use v1api20210601.DeliveryRuleCacheKeyQueryStringAction_STATUS instead
type DeliveryRuleCacheKeyQueryStringAction_STATUS struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *CacheKeyQueryStringActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS populates our DeliveryRuleCacheKeyQueryStringAction_STATUS from the provided source DeliveryRuleCacheKeyQueryStringAction_STATUS
func (action *DeliveryRuleCacheKeyQueryStringAction_STATUS) AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS(source *v20210601s.DeliveryRuleCacheKeyQueryStringAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CacheKeyQueryStringActionParameters_STATUS
		err := parameter.AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheKeyQueryStringAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheKeyQueryStringAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS populates the provided destination DeliveryRuleCacheKeyQueryStringAction_STATUS from our DeliveryRuleCacheKeyQueryStringAction_STATUS
func (action *DeliveryRuleCacheKeyQueryStringAction_STATUS) AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS(destination *v20210601s.DeliveryRuleCacheKeyQueryStringAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.CacheKeyQueryStringActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCacheKeyQueryStringAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleCacheKeyQueryStringAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleClientPortCondition
// Deprecated version of DeliveryRuleClientPortCondition. Use v1api20210601.DeliveryRuleClientPortCondition instead
type DeliveryRuleClientPortCondition struct {
	Name        *string                             `json:"name,omitempty"`
	Parameters  *ClientPortMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleClientPortCondition populates our DeliveryRuleClientPortCondition from the provided source DeliveryRuleClientPortCondition
func (condition *DeliveryRuleClientPortCondition) AssignProperties_From_DeliveryRuleClientPortCondition(source *v20210601s.DeliveryRuleClientPortCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter ClientPortMatchConditionParameters
		err := parameter.AssignProperties_From_ClientPortMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ClientPortMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleClientPortCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleClientPortCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleClientPortCondition populates the provided destination DeliveryRuleClientPortCondition from our DeliveryRuleClientPortCondition
func (condition *DeliveryRuleClientPortCondition) AssignProperties_To_DeliveryRuleClientPortCondition(destination *v20210601s.DeliveryRuleClientPortCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.ClientPortMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_ClientPortMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ClientPortMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleClientPortCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleClientPortCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleClientPortCondition_STATUS
// Deprecated version of DeliveryRuleClientPortCondition_STATUS. Use v1api20210601.DeliveryRuleClientPortCondition_STATUS instead
type DeliveryRuleClientPortCondition_STATUS struct {
	Name        *string                                    `json:"name,omitempty"`
	Parameters  *ClientPortMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                     `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleClientPortCondition_STATUS populates our DeliveryRuleClientPortCondition_STATUS from the provided source DeliveryRuleClientPortCondition_STATUS
func (condition *DeliveryRuleClientPortCondition_STATUS) AssignProperties_From_DeliveryRuleClientPortCondition_STATUS(source *v20210601s.DeliveryRuleClientPortCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter ClientPortMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_ClientPortMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ClientPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleClientPortCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleClientPortCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleClientPortCondition_STATUS populates the provided destination DeliveryRuleClientPortCondition_STATUS from our DeliveryRuleClientPortCondition_STATUS
func (condition *DeliveryRuleClientPortCondition_STATUS) AssignProperties_To_DeliveryRuleClientPortCondition_STATUS(destination *v20210601s.DeliveryRuleClientPortCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.ClientPortMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_ClientPortMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ClientPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleClientPortCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleClientPortCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleCookiesCondition
// Deprecated version of DeliveryRuleCookiesCondition. Use v1api20210601.DeliveryRuleCookiesCondition instead
type DeliveryRuleCookiesCondition struct {
	Name        *string                          `json:"name,omitempty"`
	Parameters  *CookiesMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleCookiesCondition populates our DeliveryRuleCookiesCondition from the provided source DeliveryRuleCookiesCondition
func (condition *DeliveryRuleCookiesCondition) AssignProperties_From_DeliveryRuleCookiesCondition(source *v20210601s.DeliveryRuleCookiesCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CookiesMatchConditionParameters
		err := parameter.AssignProperties_From_CookiesMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CookiesMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCookiesCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCookiesCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCookiesCondition populates the provided destination DeliveryRuleCookiesCondition from our DeliveryRuleCookiesCondition
func (condition *DeliveryRuleCookiesCondition) AssignProperties_To_DeliveryRuleCookiesCondition(destination *v20210601s.DeliveryRuleCookiesCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.CookiesMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_CookiesMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CookiesMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCookiesCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCookiesCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleCookiesCondition_STATUS
// Deprecated version of DeliveryRuleCookiesCondition_STATUS. Use v1api20210601.DeliveryRuleCookiesCondition_STATUS instead
type DeliveryRuleCookiesCondition_STATUS struct {
	Name        *string                                 `json:"name,omitempty"`
	Parameters  *CookiesMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleCookiesCondition_STATUS populates our DeliveryRuleCookiesCondition_STATUS from the provided source DeliveryRuleCookiesCondition_STATUS
func (condition *DeliveryRuleCookiesCondition_STATUS) AssignProperties_From_DeliveryRuleCookiesCondition_STATUS(source *v20210601s.DeliveryRuleCookiesCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter CookiesMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_CookiesMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CookiesMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCookiesCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCookiesCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleCookiesCondition_STATUS populates the provided destination DeliveryRuleCookiesCondition_STATUS from our DeliveryRuleCookiesCondition_STATUS
func (condition *DeliveryRuleCookiesCondition_STATUS) AssignProperties_To_DeliveryRuleCookiesCondition_STATUS(destination *v20210601s.DeliveryRuleCookiesCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.CookiesMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_CookiesMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CookiesMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleCookiesCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleCookiesCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleHostNameCondition
// Deprecated version of DeliveryRuleHostNameCondition. Use v1api20210601.DeliveryRuleHostNameCondition instead
type DeliveryRuleHostNameCondition struct {
	Name        *string                           `json:"name,omitempty"`
	Parameters  *HostNameMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleHostNameCondition populates our DeliveryRuleHostNameCondition from the provided source DeliveryRuleHostNameCondition
func (condition *DeliveryRuleHostNameCondition) AssignProperties_From_DeliveryRuleHostNameCondition(source *v20210601s.DeliveryRuleHostNameCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HostNameMatchConditionParameters
		err := parameter.AssignProperties_From_HostNameMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HostNameMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHostNameCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHostNameCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHostNameCondition populates the provided destination DeliveryRuleHostNameCondition from our DeliveryRuleHostNameCondition
func (condition *DeliveryRuleHostNameCondition) AssignProperties_To_DeliveryRuleHostNameCondition(destination *v20210601s.DeliveryRuleHostNameCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.HostNameMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_HostNameMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HostNameMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHostNameCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHostNameCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleHostNameCondition_STATUS
// Deprecated version of DeliveryRuleHostNameCondition_STATUS. Use v1api20210601.DeliveryRuleHostNameCondition_STATUS instead
type DeliveryRuleHostNameCondition_STATUS struct {
	Name        *string                                  `json:"name,omitempty"`
	Parameters  *HostNameMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                   `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleHostNameCondition_STATUS populates our DeliveryRuleHostNameCondition_STATUS from the provided source DeliveryRuleHostNameCondition_STATUS
func (condition *DeliveryRuleHostNameCondition_STATUS) AssignProperties_From_DeliveryRuleHostNameCondition_STATUS(source *v20210601s.DeliveryRuleHostNameCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HostNameMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_HostNameMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HostNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHostNameCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHostNameCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHostNameCondition_STATUS populates the provided destination DeliveryRuleHostNameCondition_STATUS from our DeliveryRuleHostNameCondition_STATUS
func (condition *DeliveryRuleHostNameCondition_STATUS) AssignProperties_To_DeliveryRuleHostNameCondition_STATUS(destination *v20210601s.DeliveryRuleHostNameCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.HostNameMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_HostNameMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HostNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHostNameCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHostNameCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleHttpVersionCondition
// Deprecated version of DeliveryRuleHttpVersionCondition. Use v1api20210601.DeliveryRuleHttpVersionCondition instead
type DeliveryRuleHttpVersionCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *HttpVersionMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleHttpVersionCondition populates our DeliveryRuleHttpVersionCondition from the provided source DeliveryRuleHttpVersionCondition
func (condition *DeliveryRuleHttpVersionCondition) AssignProperties_From_DeliveryRuleHttpVersionCondition(source *v20210601s.DeliveryRuleHttpVersionCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HttpVersionMatchConditionParameters
		err := parameter.AssignProperties_From_HttpVersionMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HttpVersionMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHttpVersionCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHttpVersionCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHttpVersionCondition populates the provided destination DeliveryRuleHttpVersionCondition from our DeliveryRuleHttpVersionCondition
func (condition *DeliveryRuleHttpVersionCondition) AssignProperties_To_DeliveryRuleHttpVersionCondition(destination *v20210601s.DeliveryRuleHttpVersionCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.HttpVersionMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_HttpVersionMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HttpVersionMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHttpVersionCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHttpVersionCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleHttpVersionCondition_STATUS
// Deprecated version of DeliveryRuleHttpVersionCondition_STATUS. Use v1api20210601.DeliveryRuleHttpVersionCondition_STATUS instead
type DeliveryRuleHttpVersionCondition_STATUS struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *HttpVersionMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS populates our DeliveryRuleHttpVersionCondition_STATUS from the provided source DeliveryRuleHttpVersionCondition_STATUS
func (condition *DeliveryRuleHttpVersionCondition_STATUS) AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS(source *v20210601s.DeliveryRuleHttpVersionCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HttpVersionMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_HttpVersionMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HttpVersionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHttpVersionCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHttpVersionCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS populates the provided destination DeliveryRuleHttpVersionCondition_STATUS from our DeliveryRuleHttpVersionCondition_STATUS
func (condition *DeliveryRuleHttpVersionCondition_STATUS) AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS(destination *v20210601s.DeliveryRuleHttpVersionCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.HttpVersionMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_HttpVersionMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HttpVersionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleHttpVersionCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleHttpVersionCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleIsDeviceCondition
// Deprecated version of DeliveryRuleIsDeviceCondition. Use v1api20210601.DeliveryRuleIsDeviceCondition instead
type DeliveryRuleIsDeviceCondition struct {
	Name        *string                           `json:"name,omitempty"`
	Parameters  *IsDeviceMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleIsDeviceCondition populates our DeliveryRuleIsDeviceCondition from the provided source DeliveryRuleIsDeviceCondition
func (condition *DeliveryRuleIsDeviceCondition) AssignProperties_From_DeliveryRuleIsDeviceCondition(source *v20210601s.DeliveryRuleIsDeviceCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter IsDeviceMatchConditionParameters
		err := parameter.AssignProperties_From_IsDeviceMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IsDeviceMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleIsDeviceCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleIsDeviceCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleIsDeviceCondition populates the provided destination DeliveryRuleIsDeviceCondition from our DeliveryRuleIsDeviceCondition
func (condition *DeliveryRuleIsDeviceCondition) AssignProperties_To_DeliveryRuleIsDeviceCondition(destination *v20210601s.DeliveryRuleIsDeviceCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.IsDeviceMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_IsDeviceMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IsDeviceMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleIsDeviceCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleIsDeviceCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleIsDeviceCondition_STATUS
// Deprecated version of DeliveryRuleIsDeviceCondition_STATUS. Use v1api20210601.DeliveryRuleIsDeviceCondition_STATUS instead
type DeliveryRuleIsDeviceCondition_STATUS struct {
	Name        *string                                  `json:"name,omitempty"`
	Parameters  *IsDeviceMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                   `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS populates our DeliveryRuleIsDeviceCondition_STATUS from the provided source DeliveryRuleIsDeviceCondition_STATUS
func (condition *DeliveryRuleIsDeviceCondition_STATUS) AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS(source *v20210601s.DeliveryRuleIsDeviceCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter IsDeviceMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_IsDeviceMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_IsDeviceMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleIsDeviceCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleIsDeviceCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS populates the provided destination DeliveryRuleIsDeviceCondition_STATUS from our DeliveryRuleIsDeviceCondition_STATUS
func (condition *DeliveryRuleIsDeviceCondition_STATUS) AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS(destination *v20210601s.DeliveryRuleIsDeviceCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.IsDeviceMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_IsDeviceMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_IsDeviceMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleIsDeviceCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleIsDeviceCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRulePostArgsCondition
// Deprecated version of DeliveryRulePostArgsCondition. Use v1api20210601.DeliveryRulePostArgsCondition instead
type DeliveryRulePostArgsCondition struct {
	Name        *string                           `json:"name,omitempty"`
	Parameters  *PostArgsMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRulePostArgsCondition populates our DeliveryRulePostArgsCondition from the provided source DeliveryRulePostArgsCondition
func (condition *DeliveryRulePostArgsCondition) AssignProperties_From_DeliveryRulePostArgsCondition(source *v20210601s.DeliveryRulePostArgsCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter PostArgsMatchConditionParameters
		err := parameter.AssignProperties_From_PostArgsMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PostArgsMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRulePostArgsCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRulePostArgsCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRulePostArgsCondition populates the provided destination DeliveryRulePostArgsCondition from our DeliveryRulePostArgsCondition
func (condition *DeliveryRulePostArgsCondition) AssignProperties_To_DeliveryRulePostArgsCondition(destination *v20210601s.DeliveryRulePostArgsCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.PostArgsMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_PostArgsMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PostArgsMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRulePostArgsCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRulePostArgsCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRulePostArgsCondition_STATUS
// Deprecated version of DeliveryRulePostArgsCondition_STATUS. Use v1api20210601.DeliveryRulePostArgsCondition_STATUS instead
type DeliveryRulePostArgsCondition_STATUS struct {
	Name        *string                                  `json:"name,omitempty"`
	Parameters  *PostArgsMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                   `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRulePostArgsCondition_STATUS populates our DeliveryRulePostArgsCondition_STATUS from the provided source DeliveryRulePostArgsCondition_STATUS
func (condition *DeliveryRulePostArgsCondition_STATUS) AssignProperties_From_DeliveryRulePostArgsCondition_STATUS(source *v20210601s.DeliveryRulePostArgsCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter PostArgsMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_PostArgsMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PostArgsMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRulePostArgsCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRulePostArgsCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRulePostArgsCondition_STATUS populates the provided destination DeliveryRulePostArgsCondition_STATUS from our DeliveryRulePostArgsCondition_STATUS
func (condition *DeliveryRulePostArgsCondition_STATUS) AssignProperties_To_DeliveryRulePostArgsCondition_STATUS(destination *v20210601s.DeliveryRulePostArgsCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.PostArgsMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_PostArgsMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PostArgsMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRulePostArgsCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRulePostArgsCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleQueryStringCondition
// Deprecated version of DeliveryRuleQueryStringCondition. Use v1api20210601.DeliveryRuleQueryStringCondition instead
type DeliveryRuleQueryStringCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *QueryStringMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleQueryStringCondition populates our DeliveryRuleQueryStringCondition from the provided source DeliveryRuleQueryStringCondition
func (condition *DeliveryRuleQueryStringCondition) AssignProperties_From_DeliveryRuleQueryStringCondition(source *v20210601s.DeliveryRuleQueryStringCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter QueryStringMatchConditionParameters
		err := parameter.AssignProperties_From_QueryStringMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_QueryStringMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleQueryStringCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleQueryStringCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleQueryStringCondition populates the provided destination DeliveryRuleQueryStringCondition from our DeliveryRuleQueryStringCondition
func (condition *DeliveryRuleQueryStringCondition) AssignProperties_To_DeliveryRuleQueryStringCondition(destination *v20210601s.DeliveryRuleQueryStringCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.QueryStringMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_QueryStringMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_QueryStringMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleQueryStringCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleQueryStringCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleQueryStringCondition_STATUS
// Deprecated version of DeliveryRuleQueryStringCondition_STATUS. Use v1api20210601.DeliveryRuleQueryStringCondition_STATUS instead
type DeliveryRuleQueryStringCondition_STATUS struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *QueryStringMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS populates our DeliveryRuleQueryStringCondition_STATUS from the provided source DeliveryRuleQueryStringCondition_STATUS
func (condition *DeliveryRuleQueryStringCondition_STATUS) AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS(source *v20210601s.DeliveryRuleQueryStringCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter QueryStringMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_QueryStringMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_QueryStringMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleQueryStringCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleQueryStringCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS populates the provided destination DeliveryRuleQueryStringCondition_STATUS from our DeliveryRuleQueryStringCondition_STATUS
func (condition *DeliveryRuleQueryStringCondition_STATUS) AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS(destination *v20210601s.DeliveryRuleQueryStringCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.QueryStringMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_QueryStringMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_QueryStringMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleQueryStringCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleQueryStringCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRemoteAddressCondition
// Deprecated version of DeliveryRuleRemoteAddressCondition. Use v1api20210601.DeliveryRuleRemoteAddressCondition instead
type DeliveryRuleRemoteAddressCondition struct {
	Name        *string                                `json:"name,omitempty"`
	Parameters  *RemoteAddressMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRemoteAddressCondition populates our DeliveryRuleRemoteAddressCondition from the provided source DeliveryRuleRemoteAddressCondition
func (condition *DeliveryRuleRemoteAddressCondition) AssignProperties_From_DeliveryRuleRemoteAddressCondition(source *v20210601s.DeliveryRuleRemoteAddressCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RemoteAddressMatchConditionParameters
		err := parameter.AssignProperties_From_RemoteAddressMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RemoteAddressMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRemoteAddressCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRemoteAddressCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRemoteAddressCondition populates the provided destination DeliveryRuleRemoteAddressCondition from our DeliveryRuleRemoteAddressCondition
func (condition *DeliveryRuleRemoteAddressCondition) AssignProperties_To_DeliveryRuleRemoteAddressCondition(destination *v20210601s.DeliveryRuleRemoteAddressCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RemoteAddressMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RemoteAddressMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RemoteAddressMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRemoteAddressCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRemoteAddressCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRemoteAddressCondition_STATUS
// Deprecated version of DeliveryRuleRemoteAddressCondition_STATUS. Use v1api20210601.DeliveryRuleRemoteAddressCondition_STATUS instead
type DeliveryRuleRemoteAddressCondition_STATUS struct {
	Name        *string                                       `json:"name,omitempty"`
	Parameters  *RemoteAddressMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS populates our DeliveryRuleRemoteAddressCondition_STATUS from the provided source DeliveryRuleRemoteAddressCondition_STATUS
func (condition *DeliveryRuleRemoteAddressCondition_STATUS) AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS(source *v20210601s.DeliveryRuleRemoteAddressCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RemoteAddressMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRemoteAddressCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRemoteAddressCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS populates the provided destination DeliveryRuleRemoteAddressCondition_STATUS from our DeliveryRuleRemoteAddressCondition_STATUS
func (condition *DeliveryRuleRemoteAddressCondition_STATUS) AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS(destination *v20210601s.DeliveryRuleRemoteAddressCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RemoteAddressMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRemoteAddressCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRemoteAddressCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRequestBodyCondition
// Deprecated version of DeliveryRuleRequestBodyCondition. Use v1api20210601.DeliveryRuleRequestBodyCondition instead
type DeliveryRuleRequestBodyCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *RequestBodyMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestBodyCondition populates our DeliveryRuleRequestBodyCondition from the provided source DeliveryRuleRequestBodyCondition
func (condition *DeliveryRuleRequestBodyCondition) AssignProperties_From_DeliveryRuleRequestBodyCondition(source *v20210601s.DeliveryRuleRequestBodyCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestBodyMatchConditionParameters
		err := parameter.AssignProperties_From_RequestBodyMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestBodyMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestBodyCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestBodyCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestBodyCondition populates the provided destination DeliveryRuleRequestBodyCondition from our DeliveryRuleRequestBodyCondition
func (condition *DeliveryRuleRequestBodyCondition) AssignProperties_To_DeliveryRuleRequestBodyCondition(destination *v20210601s.DeliveryRuleRequestBodyCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestBodyMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestBodyMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestBodyMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestBodyCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestBodyCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRequestBodyCondition_STATUS
// Deprecated version of DeliveryRuleRequestBodyCondition_STATUS. Use v1api20210601.DeliveryRuleRequestBodyCondition_STATUS instead
type DeliveryRuleRequestBodyCondition_STATUS struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *RequestBodyMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS populates our DeliveryRuleRequestBodyCondition_STATUS from the provided source DeliveryRuleRequestBodyCondition_STATUS
func (condition *DeliveryRuleRequestBodyCondition_STATUS) AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS(source *v20210601s.DeliveryRuleRequestBodyCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestBodyMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestBodyMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestBodyMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestBodyCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestBodyCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS populates the provided destination DeliveryRuleRequestBodyCondition_STATUS from our DeliveryRuleRequestBodyCondition_STATUS
func (condition *DeliveryRuleRequestBodyCondition_STATUS) AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS(destination *v20210601s.DeliveryRuleRequestBodyCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestBodyMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestBodyMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestBodyMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestBodyCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestBodyCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRequestHeaderAction
// Deprecated version of DeliveryRuleRequestHeaderAction. Use v1api20210601.DeliveryRuleRequestHeaderAction instead
type DeliveryRuleRequestHeaderAction struct {
	Name        *string                 `json:"name,omitempty"`
	Parameters  *HeaderActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestHeaderAction populates our DeliveryRuleRequestHeaderAction from the provided source DeliveryRuleRequestHeaderAction
func (action *DeliveryRuleRequestHeaderAction) AssignProperties_From_DeliveryRuleRequestHeaderAction(source *v20210601s.DeliveryRuleRequestHeaderAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters
		err := parameter.AssignProperties_From_HeaderActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRequestHeaderAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderAction populates the provided destination DeliveryRuleRequestHeaderAction from our DeliveryRuleRequestHeaderAction
func (action *DeliveryRuleRequestHeaderAction) AssignProperties_To_DeliveryRuleRequestHeaderAction(destination *v20210601s.DeliveryRuleRequestHeaderAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.HeaderActionParameters
		err := action.Parameters.AssignProperties_To_HeaderActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRequestHeaderAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRequestHeaderAction_STATUS
// Deprecated version of DeliveryRuleRequestHeaderAction_STATUS. Use v1api20210601.DeliveryRuleRequestHeaderAction_STATUS instead
type DeliveryRuleRequestHeaderAction_STATUS struct {
	Name        *string                        `json:"name,omitempty"`
	Parameters  *HeaderActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS populates our DeliveryRuleRequestHeaderAction_STATUS from the provided source DeliveryRuleRequestHeaderAction_STATUS
func (action *DeliveryRuleRequestHeaderAction_STATUS) AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS(source *v20210601s.DeliveryRuleRequestHeaderAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters_STATUS
		err := parameter.AssignProperties_From_HeaderActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRequestHeaderAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS populates the provided destination DeliveryRuleRequestHeaderAction_STATUS from our DeliveryRuleRequestHeaderAction_STATUS
func (action *DeliveryRuleRequestHeaderAction_STATUS) AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS(destination *v20210601s.DeliveryRuleRequestHeaderAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.HeaderActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_HeaderActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRequestHeaderAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRequestHeaderCondition
// Deprecated version of DeliveryRuleRequestHeaderCondition. Use v1api20210601.DeliveryRuleRequestHeaderCondition instead
type DeliveryRuleRequestHeaderCondition struct {
	Name        *string                                `json:"name,omitempty"`
	Parameters  *RequestHeaderMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestHeaderCondition populates our DeliveryRuleRequestHeaderCondition from the provided source DeliveryRuleRequestHeaderCondition
func (condition *DeliveryRuleRequestHeaderCondition) AssignProperties_From_DeliveryRuleRequestHeaderCondition(source *v20210601s.DeliveryRuleRequestHeaderCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestHeaderMatchConditionParameters
		err := parameter.AssignProperties_From_RequestHeaderMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestHeaderMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestHeaderCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderCondition populates the provided destination DeliveryRuleRequestHeaderCondition from our DeliveryRuleRequestHeaderCondition
func (condition *DeliveryRuleRequestHeaderCondition) AssignProperties_To_DeliveryRuleRequestHeaderCondition(destination *v20210601s.DeliveryRuleRequestHeaderCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestHeaderMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestHeaderMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestHeaderMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestHeaderCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRequestHeaderCondition_STATUS
// Deprecated version of DeliveryRuleRequestHeaderCondition_STATUS. Use v1api20210601.DeliveryRuleRequestHeaderCondition_STATUS instead
type DeliveryRuleRequestHeaderCondition_STATUS struct {
	Name        *string                                       `json:"name,omitempty"`
	Parameters  *RequestHeaderMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS populates our DeliveryRuleRequestHeaderCondition_STATUS from the provided source DeliveryRuleRequestHeaderCondition_STATUS
func (condition *DeliveryRuleRequestHeaderCondition_STATUS) AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS(source *v20210601s.DeliveryRuleRequestHeaderCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestHeaderMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestHeaderCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS populates the provided destination DeliveryRuleRequestHeaderCondition_STATUS from our DeliveryRuleRequestHeaderCondition_STATUS
func (condition *DeliveryRuleRequestHeaderCondition_STATUS) AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS(destination *v20210601s.DeliveryRuleRequestHeaderCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestHeaderMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestHeaderCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestHeaderCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRequestMethodCondition
// Deprecated version of DeliveryRuleRequestMethodCondition. Use v1api20210601.DeliveryRuleRequestMethodCondition instead
type DeliveryRuleRequestMethodCondition struct {
	Name        *string                                `json:"name,omitempty"`
	Parameters  *RequestMethodMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestMethodCondition populates our DeliveryRuleRequestMethodCondition from the provided source DeliveryRuleRequestMethodCondition
func (condition *DeliveryRuleRequestMethodCondition) AssignProperties_From_DeliveryRuleRequestMethodCondition(source *v20210601s.DeliveryRuleRequestMethodCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestMethodMatchConditionParameters
		err := parameter.AssignProperties_From_RequestMethodMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestMethodMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestMethodCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestMethodCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestMethodCondition populates the provided destination DeliveryRuleRequestMethodCondition from our DeliveryRuleRequestMethodCondition
func (condition *DeliveryRuleRequestMethodCondition) AssignProperties_To_DeliveryRuleRequestMethodCondition(destination *v20210601s.DeliveryRuleRequestMethodCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestMethodMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestMethodMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestMethodMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestMethodCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestMethodCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRequestMethodCondition_STATUS
// Deprecated version of DeliveryRuleRequestMethodCondition_STATUS. Use v1api20210601.DeliveryRuleRequestMethodCondition_STATUS instead
type DeliveryRuleRequestMethodCondition_STATUS struct {
	Name        *string                                       `json:"name,omitempty"`
	Parameters  *RequestMethodMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS populates our DeliveryRuleRequestMethodCondition_STATUS from the provided source DeliveryRuleRequestMethodCondition_STATUS
func (condition *DeliveryRuleRequestMethodCondition_STATUS) AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS(source *v20210601s.DeliveryRuleRequestMethodCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestMethodMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestMethodMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestMethodMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestMethodCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestMethodCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS populates the provided destination DeliveryRuleRequestMethodCondition_STATUS from our DeliveryRuleRequestMethodCondition_STATUS
func (condition *DeliveryRuleRequestMethodCondition_STATUS) AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS(destination *v20210601s.DeliveryRuleRequestMethodCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestMethodMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestMethodMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestMethodMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestMethodCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestMethodCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRequestSchemeCondition
// Deprecated version of DeliveryRuleRequestSchemeCondition. Use v1api20210601.DeliveryRuleRequestSchemeCondition instead
type DeliveryRuleRequestSchemeCondition struct {
	Name        *string                                `json:"name,omitempty"`
	Parameters  *RequestSchemeMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestSchemeCondition populates our DeliveryRuleRequestSchemeCondition from the provided source DeliveryRuleRequestSchemeCondition
func (condition *DeliveryRuleRequestSchemeCondition) AssignProperties_From_DeliveryRuleRequestSchemeCondition(source *v20210601s.DeliveryRuleRequestSchemeCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestSchemeMatchConditionParameters
		err := parameter.AssignProperties_From_RequestSchemeMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestSchemeMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestSchemeCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestSchemeCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestSchemeCondition populates the provided destination DeliveryRuleRequestSchemeCondition from our DeliveryRuleRequestSchemeCondition
func (condition *DeliveryRuleRequestSchemeCondition) AssignProperties_To_DeliveryRuleRequestSchemeCondition(destination *v20210601s.DeliveryRuleRequestSchemeCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestSchemeMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestSchemeMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestSchemeMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestSchemeCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestSchemeCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRequestSchemeCondition_STATUS
// Deprecated version of DeliveryRuleRequestSchemeCondition_STATUS. Use v1api20210601.DeliveryRuleRequestSchemeCondition_STATUS instead
type DeliveryRuleRequestSchemeCondition_STATUS struct {
	Name        *string                                       `json:"name,omitempty"`
	Parameters  *RequestSchemeMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                        `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS populates our DeliveryRuleRequestSchemeCondition_STATUS from the provided source DeliveryRuleRequestSchemeCondition_STATUS
func (condition *DeliveryRuleRequestSchemeCondition_STATUS) AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS(source *v20210601s.DeliveryRuleRequestSchemeCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestSchemeMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestSchemeCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestSchemeCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS populates the provided destination DeliveryRuleRequestSchemeCondition_STATUS from our DeliveryRuleRequestSchemeCondition_STATUS
func (condition *DeliveryRuleRequestSchemeCondition_STATUS) AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS(destination *v20210601s.DeliveryRuleRequestSchemeCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestSchemeMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestSchemeCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestSchemeCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRequestUriCondition
// Deprecated version of DeliveryRuleRequestUriCondition. Use v1api20210601.DeliveryRuleRequestUriCondition instead
type DeliveryRuleRequestUriCondition struct {
	Name        *string                             `json:"name,omitempty"`
	Parameters  *RequestUriMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestUriCondition populates our DeliveryRuleRequestUriCondition from the provided source DeliveryRuleRequestUriCondition
func (condition *DeliveryRuleRequestUriCondition) AssignProperties_From_DeliveryRuleRequestUriCondition(source *v20210601s.DeliveryRuleRequestUriCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestUriMatchConditionParameters
		err := parameter.AssignProperties_From_RequestUriMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestUriMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestUriCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestUriCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestUriCondition populates the provided destination DeliveryRuleRequestUriCondition from our DeliveryRuleRequestUriCondition
func (condition *DeliveryRuleRequestUriCondition) AssignProperties_To_DeliveryRuleRequestUriCondition(destination *v20210601s.DeliveryRuleRequestUriCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestUriMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_RequestUriMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestUriMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestUriCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestUriCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRequestUriCondition_STATUS
// Deprecated version of DeliveryRuleRequestUriCondition_STATUS. Use v1api20210601.DeliveryRuleRequestUriCondition_STATUS instead
type DeliveryRuleRequestUriCondition_STATUS struct {
	Name        *string                                    `json:"name,omitempty"`
	Parameters  *RequestUriMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                     `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS populates our DeliveryRuleRequestUriCondition_STATUS from the provided source DeliveryRuleRequestUriCondition_STATUS
func (condition *DeliveryRuleRequestUriCondition_STATUS) AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS(source *v20210601s.DeliveryRuleRequestUriCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RequestUriMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_RequestUriMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RequestUriMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestUriCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestUriCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS populates the provided destination DeliveryRuleRequestUriCondition_STATUS from our DeliveryRuleRequestUriCondition_STATUS
func (condition *DeliveryRuleRequestUriCondition_STATUS) AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS(destination *v20210601s.DeliveryRuleRequestUriCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.RequestUriMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_RequestUriMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RequestUriMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRequestUriCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleRequestUriCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleResponseHeaderAction
// Deprecated version of DeliveryRuleResponseHeaderAction. Use v1api20210601.DeliveryRuleResponseHeaderAction instead
type DeliveryRuleResponseHeaderAction struct {
	Name        *string                 `json:"name,omitempty"`
	Parameters  *HeaderActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleResponseHeaderAction populates our DeliveryRuleResponseHeaderAction from the provided source DeliveryRuleResponseHeaderAction
func (action *DeliveryRuleResponseHeaderAction) AssignProperties_From_DeliveryRuleResponseHeaderAction(source *v20210601s.DeliveryRuleResponseHeaderAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters
		err := parameter.AssignProperties_From_HeaderActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleResponseHeaderAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleResponseHeaderAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleResponseHeaderAction populates the provided destination DeliveryRuleResponseHeaderAction from our DeliveryRuleResponseHeaderAction
func (action *DeliveryRuleResponseHeaderAction) AssignProperties_To_DeliveryRuleResponseHeaderAction(destination *v20210601s.DeliveryRuleResponseHeaderAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.HeaderActionParameters
		err := action.Parameters.AssignProperties_To_HeaderActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleResponseHeaderAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleResponseHeaderAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleResponseHeaderAction_STATUS
// Deprecated version of DeliveryRuleResponseHeaderAction_STATUS. Use v1api20210601.DeliveryRuleResponseHeaderAction_STATUS instead
type DeliveryRuleResponseHeaderAction_STATUS struct {
	Name        *string                        `json:"name,omitempty"`
	Parameters  *HeaderActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS populates our DeliveryRuleResponseHeaderAction_STATUS from the provided source DeliveryRuleResponseHeaderAction_STATUS
func (action *DeliveryRuleResponseHeaderAction_STATUS) AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS(source *v20210601s.DeliveryRuleResponseHeaderAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter HeaderActionParameters_STATUS
		err := parameter.AssignProperties_From_HeaderActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleResponseHeaderAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleResponseHeaderAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS populates the provided destination DeliveryRuleResponseHeaderAction_STATUS from our DeliveryRuleResponseHeaderAction_STATUS
func (action *DeliveryRuleResponseHeaderAction_STATUS) AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS(destination *v20210601s.DeliveryRuleResponseHeaderAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.HeaderActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_HeaderActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_HeaderActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleResponseHeaderAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleResponseHeaderAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRouteConfigurationOverrideAction
// Deprecated version of DeliveryRuleRouteConfigurationOverrideAction. Use v1api20210601.DeliveryRuleRouteConfigurationOverrideAction instead
type DeliveryRuleRouteConfigurationOverrideAction struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *RouteConfigurationOverrideActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction populates our DeliveryRuleRouteConfigurationOverrideAction from the provided source DeliveryRuleRouteConfigurationOverrideAction
func (action *DeliveryRuleRouteConfigurationOverrideAction) AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction(source *v20210601s.DeliveryRuleRouteConfigurationOverrideAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RouteConfigurationOverrideActionParameters
		err := parameter.AssignProperties_From_RouteConfigurationOverrideActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RouteConfigurationOverrideActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRouteConfigurationOverrideAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRouteConfigurationOverrideAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction populates the provided destination DeliveryRuleRouteConfigurationOverrideAction from our DeliveryRuleRouteConfigurationOverrideAction
func (action *DeliveryRuleRouteConfigurationOverrideAction) AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction(destination *v20210601s.DeliveryRuleRouteConfigurationOverrideAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.RouteConfigurationOverrideActionParameters
		err := action.Parameters.AssignProperties_To_RouteConfigurationOverrideActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RouteConfigurationOverrideActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRouteConfigurationOverrideAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRouteConfigurationOverrideAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleRouteConfigurationOverrideAction_STATUS
// Deprecated version of DeliveryRuleRouteConfigurationOverrideAction_STATUS. Use v1api20210601.DeliveryRuleRouteConfigurationOverrideAction_STATUS instead
type DeliveryRuleRouteConfigurationOverrideAction_STATUS struct {
	Name        *string                                            `json:"name,omitempty"`
	Parameters  *RouteConfigurationOverrideActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                             `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS populates our DeliveryRuleRouteConfigurationOverrideAction_STATUS from the provided source DeliveryRuleRouteConfigurationOverrideAction_STATUS
func (action *DeliveryRuleRouteConfigurationOverrideAction_STATUS) AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS(source *v20210601s.DeliveryRuleRouteConfigurationOverrideAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter RouteConfigurationOverrideActionParameters_STATUS
		err := parameter.AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRouteConfigurationOverrideAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRouteConfigurationOverrideAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS populates the provided destination DeliveryRuleRouteConfigurationOverrideAction_STATUS from our DeliveryRuleRouteConfigurationOverrideAction_STATUS
func (action *DeliveryRuleRouteConfigurationOverrideAction_STATUS) AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS(destination *v20210601s.DeliveryRuleRouteConfigurationOverrideAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.RouteConfigurationOverrideActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleRouteConfigurationOverrideAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForDeliveryRuleRouteConfigurationOverrideAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleServerPortCondition
// Deprecated version of DeliveryRuleServerPortCondition. Use v1api20210601.DeliveryRuleServerPortCondition instead
type DeliveryRuleServerPortCondition struct {
	Name        *string                             `json:"name,omitempty"`
	Parameters  *ServerPortMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleServerPortCondition populates our DeliveryRuleServerPortCondition from the provided source DeliveryRuleServerPortCondition
func (condition *DeliveryRuleServerPortCondition) AssignProperties_From_DeliveryRuleServerPortCondition(source *v20210601s.DeliveryRuleServerPortCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter ServerPortMatchConditionParameters
		err := parameter.AssignProperties_From_ServerPortMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPortMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleServerPortCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleServerPortCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleServerPortCondition populates the provided destination DeliveryRuleServerPortCondition from our DeliveryRuleServerPortCondition
func (condition *DeliveryRuleServerPortCondition) AssignProperties_To_DeliveryRuleServerPortCondition(destination *v20210601s.DeliveryRuleServerPortCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.ServerPortMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_ServerPortMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPortMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleServerPortCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleServerPortCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleServerPortCondition_STATUS
// Deprecated version of DeliveryRuleServerPortCondition_STATUS. Use v1api20210601.DeliveryRuleServerPortCondition_STATUS instead
type DeliveryRuleServerPortCondition_STATUS struct {
	Name        *string                                    `json:"name,omitempty"`
	Parameters  *ServerPortMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                     `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleServerPortCondition_STATUS populates our DeliveryRuleServerPortCondition_STATUS from the provided source DeliveryRuleServerPortCondition_STATUS
func (condition *DeliveryRuleServerPortCondition_STATUS) AssignProperties_From_DeliveryRuleServerPortCondition_STATUS(source *v20210601s.DeliveryRuleServerPortCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter ServerPortMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_ServerPortMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ServerPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleServerPortCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleServerPortCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleServerPortCondition_STATUS populates the provided destination DeliveryRuleServerPortCondition_STATUS from our DeliveryRuleServerPortCondition_STATUS
func (condition *DeliveryRuleServerPortCondition_STATUS) AssignProperties_To_DeliveryRuleServerPortCondition_STATUS(destination *v20210601s.DeliveryRuleServerPortCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.ServerPortMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_ServerPortMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ServerPortMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleServerPortCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleServerPortCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleSocketAddrCondition
// Deprecated version of DeliveryRuleSocketAddrCondition. Use v1api20210601.DeliveryRuleSocketAddrCondition instead
type DeliveryRuleSocketAddrCondition struct {
	Name        *string                             `json:"name,omitempty"`
	Parameters  *SocketAddrMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleSocketAddrCondition populates our DeliveryRuleSocketAddrCondition from the provided source DeliveryRuleSocketAddrCondition
func (condition *DeliveryRuleSocketAddrCondition) AssignProperties_From_DeliveryRuleSocketAddrCondition(source *v20210601s.DeliveryRuleSocketAddrCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter SocketAddrMatchConditionParameters
		err := parameter.AssignProperties_From_SocketAddrMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SocketAddrMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSocketAddrCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSocketAddrCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSocketAddrCondition populates the provided destination DeliveryRuleSocketAddrCondition from our DeliveryRuleSocketAddrCondition
func (condition *DeliveryRuleSocketAddrCondition) AssignProperties_To_DeliveryRuleSocketAddrCondition(destination *v20210601s.DeliveryRuleSocketAddrCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.SocketAddrMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_SocketAddrMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SocketAddrMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSocketAddrCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSocketAddrCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleSocketAddrCondition_STATUS
// Deprecated version of DeliveryRuleSocketAddrCondition_STATUS. Use v1api20210601.DeliveryRuleSocketAddrCondition_STATUS instead
type DeliveryRuleSocketAddrCondition_STATUS struct {
	Name        *string                                    `json:"name,omitempty"`
	Parameters  *SocketAddrMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                     `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS populates our DeliveryRuleSocketAddrCondition_STATUS from the provided source DeliveryRuleSocketAddrCondition_STATUS
func (condition *DeliveryRuleSocketAddrCondition_STATUS) AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS(source *v20210601s.DeliveryRuleSocketAddrCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter SocketAddrMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_SocketAddrMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SocketAddrMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSocketAddrCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSocketAddrCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS populates the provided destination DeliveryRuleSocketAddrCondition_STATUS from our DeliveryRuleSocketAddrCondition_STATUS
func (condition *DeliveryRuleSocketAddrCondition_STATUS) AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS(destination *v20210601s.DeliveryRuleSocketAddrCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.SocketAddrMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_SocketAddrMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SocketAddrMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSocketAddrCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSocketAddrCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleSslProtocolCondition
// Deprecated version of DeliveryRuleSslProtocolCondition. Use v1api20210601.DeliveryRuleSslProtocolCondition instead
type DeliveryRuleSslProtocolCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *SslProtocolMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleSslProtocolCondition populates our DeliveryRuleSslProtocolCondition from the provided source DeliveryRuleSslProtocolCondition
func (condition *DeliveryRuleSslProtocolCondition) AssignProperties_From_DeliveryRuleSslProtocolCondition(source *v20210601s.DeliveryRuleSslProtocolCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter SslProtocolMatchConditionParameters
		err := parameter.AssignProperties_From_SslProtocolMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SslProtocolMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSslProtocolCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSslProtocolCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSslProtocolCondition populates the provided destination DeliveryRuleSslProtocolCondition from our DeliveryRuleSslProtocolCondition
func (condition *DeliveryRuleSslProtocolCondition) AssignProperties_To_DeliveryRuleSslProtocolCondition(destination *v20210601s.DeliveryRuleSslProtocolCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.SslProtocolMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_SslProtocolMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SslProtocolMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSslProtocolCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSslProtocolCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleSslProtocolCondition_STATUS
// Deprecated version of DeliveryRuleSslProtocolCondition_STATUS. Use v1api20210601.DeliveryRuleSslProtocolCondition_STATUS instead
type DeliveryRuleSslProtocolCondition_STATUS struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *SslProtocolMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS populates our DeliveryRuleSslProtocolCondition_STATUS from the provided source DeliveryRuleSslProtocolCondition_STATUS
func (condition *DeliveryRuleSslProtocolCondition_STATUS) AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS(source *v20210601s.DeliveryRuleSslProtocolCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter SslProtocolMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_SslProtocolMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_SslProtocolMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSslProtocolCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSslProtocolCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS populates the provided destination DeliveryRuleSslProtocolCondition_STATUS from our DeliveryRuleSslProtocolCondition_STATUS
func (condition *DeliveryRuleSslProtocolCondition_STATUS) AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS(destination *v20210601s.DeliveryRuleSslProtocolCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.SslProtocolMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_SslProtocolMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_SslProtocolMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleSslProtocolCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleSslProtocolCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleUrlFileExtensionCondition
// Deprecated version of DeliveryRuleUrlFileExtensionCondition. Use v1api20210601.DeliveryRuleUrlFileExtensionCondition instead
type DeliveryRuleUrlFileExtensionCondition struct {
	Name        *string                                   `json:"name,omitempty"`
	Parameters  *UrlFileExtensionMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                    `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleUrlFileExtensionCondition populates our DeliveryRuleUrlFileExtensionCondition from the provided source DeliveryRuleUrlFileExtensionCondition
func (condition *DeliveryRuleUrlFileExtensionCondition) AssignProperties_From_DeliveryRuleUrlFileExtensionCondition(source *v20210601s.DeliveryRuleUrlFileExtensionCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileExtensionMatchConditionParameters
		err := parameter.AssignProperties_From_UrlFileExtensionMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileExtensionMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileExtensionCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileExtensionCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileExtensionCondition populates the provided destination DeliveryRuleUrlFileExtensionCondition from our DeliveryRuleUrlFileExtensionCondition
func (condition *DeliveryRuleUrlFileExtensionCondition) AssignProperties_To_DeliveryRuleUrlFileExtensionCondition(destination *v20210601s.DeliveryRuleUrlFileExtensionCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.UrlFileExtensionMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_UrlFileExtensionMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileExtensionMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileExtensionCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileExtensionCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleUrlFileExtensionCondition_STATUS
// Deprecated version of DeliveryRuleUrlFileExtensionCondition_STATUS. Use v1api20210601.DeliveryRuleUrlFileExtensionCondition_STATUS instead
type DeliveryRuleUrlFileExtensionCondition_STATUS struct {
	Name        *string                                          `json:"name,omitempty"`
	Parameters  *UrlFileExtensionMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                           `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS populates our DeliveryRuleUrlFileExtensionCondition_STATUS from the provided source DeliveryRuleUrlFileExtensionCondition_STATUS
func (condition *DeliveryRuleUrlFileExtensionCondition_STATUS) AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS(source *v20210601s.DeliveryRuleUrlFileExtensionCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileExtensionMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileExtensionCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileExtensionCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS populates the provided destination DeliveryRuleUrlFileExtensionCondition_STATUS from our DeliveryRuleUrlFileExtensionCondition_STATUS
func (condition *DeliveryRuleUrlFileExtensionCondition_STATUS) AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS(destination *v20210601s.DeliveryRuleUrlFileExtensionCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.UrlFileExtensionMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileExtensionCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileExtensionCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleUrlFileNameCondition
// Deprecated version of DeliveryRuleUrlFileNameCondition. Use v1api20210601.DeliveryRuleUrlFileNameCondition instead
type DeliveryRuleUrlFileNameCondition struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *UrlFileNameMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleUrlFileNameCondition populates our DeliveryRuleUrlFileNameCondition from the provided source DeliveryRuleUrlFileNameCondition
func (condition *DeliveryRuleUrlFileNameCondition) AssignProperties_From_DeliveryRuleUrlFileNameCondition(source *v20210601s.DeliveryRuleUrlFileNameCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileNameMatchConditionParameters
		err := parameter.AssignProperties_From_UrlFileNameMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileNameMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileNameCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileNameCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileNameCondition populates the provided destination DeliveryRuleUrlFileNameCondition from our DeliveryRuleUrlFileNameCondition
func (condition *DeliveryRuleUrlFileNameCondition) AssignProperties_To_DeliveryRuleUrlFileNameCondition(destination *v20210601s.DeliveryRuleUrlFileNameCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.UrlFileNameMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_UrlFileNameMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileNameMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileNameCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileNameCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleUrlFileNameCondition_STATUS
// Deprecated version of DeliveryRuleUrlFileNameCondition_STATUS. Use v1api20210601.DeliveryRuleUrlFileNameCondition_STATUS instead
type DeliveryRuleUrlFileNameCondition_STATUS struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *UrlFileNameMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS populates our DeliveryRuleUrlFileNameCondition_STATUS from the provided source DeliveryRuleUrlFileNameCondition_STATUS
func (condition *DeliveryRuleUrlFileNameCondition_STATUS) AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS(source *v20210601s.DeliveryRuleUrlFileNameCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlFileNameMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileNameCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileNameCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS populates the provided destination DeliveryRuleUrlFileNameCondition_STATUS from our DeliveryRuleUrlFileNameCondition_STATUS
func (condition *DeliveryRuleUrlFileNameCondition_STATUS) AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS(destination *v20210601s.DeliveryRuleUrlFileNameCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.UrlFileNameMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlFileNameCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlFileNameCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleUrlPathCondition
// Deprecated version of DeliveryRuleUrlPathCondition. Use v1api20210601.DeliveryRuleUrlPathCondition instead
type DeliveryRuleUrlPathCondition struct {
	Name        *string                          `json:"name,omitempty"`
	Parameters  *UrlPathMatchConditionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleUrlPathCondition populates our DeliveryRuleUrlPathCondition from the provided source DeliveryRuleUrlPathCondition
func (condition *DeliveryRuleUrlPathCondition) AssignProperties_From_DeliveryRuleUrlPathCondition(source *v20210601s.DeliveryRuleUrlPathCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlPathMatchConditionParameters
		err := parameter.AssignProperties_From_UrlPathMatchConditionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlPathMatchConditionParameters() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlPathCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlPathCondition); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlPathCondition populates the provided destination DeliveryRuleUrlPathCondition from our DeliveryRuleUrlPathCondition
func (condition *DeliveryRuleUrlPathCondition) AssignProperties_To_DeliveryRuleUrlPathCondition(destination *v20210601s.DeliveryRuleUrlPathCondition) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.UrlPathMatchConditionParameters
		err := condition.Parameters.AssignProperties_To_UrlPathMatchConditionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlPathMatchConditionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlPathCondition interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlPathCondition); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.DeliveryRuleUrlPathCondition_STATUS
// Deprecated version of DeliveryRuleUrlPathCondition_STATUS. Use v1api20210601.DeliveryRuleUrlPathCondition_STATUS instead
type DeliveryRuleUrlPathCondition_STATUS struct {
	Name        *string                                 `json:"name,omitempty"`
	Parameters  *UrlPathMatchConditionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                  `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS populates our DeliveryRuleUrlPathCondition_STATUS from the provided source DeliveryRuleUrlPathCondition_STATUS
func (condition *DeliveryRuleUrlPathCondition_STATUS) AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS(source *v20210601s.DeliveryRuleUrlPathCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	condition.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlPathMatchConditionParameters_STATUS
		err := parameter.AssignProperties_From_UrlPathMatchConditionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlPathMatchConditionParameters_STATUS() to populate field Parameters")
		}
		condition.Parameters = &parameter
	} else {
		condition.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		condition.PropertyBag = propertyBag
	} else {
		condition.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlPathCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlPathCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS populates the provided destination DeliveryRuleUrlPathCondition_STATUS from our DeliveryRuleUrlPathCondition_STATUS
func (condition *DeliveryRuleUrlPathCondition_STATUS) AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS(destination *v20210601s.DeliveryRuleUrlPathCondition_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(condition.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(condition.Name)

	// Parameters
	if condition.Parameters != nil {
		var parameter v20210601s.UrlPathMatchConditionParameters_STATUS
		err := condition.Parameters.AssignProperties_To_UrlPathMatchConditionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlPathMatchConditionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForDeliveryRuleUrlPathCondition_STATUS interface (if implemented) to customize the conversion
	var conditionAsAny any = condition
	if augmentedCondition, ok := conditionAsAny.(augmentConversionForDeliveryRuleUrlPathCondition_STATUS); ok {
		err := augmentedCondition.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.OriginGroupOverrideAction
// Deprecated version of OriginGroupOverrideAction. Use v1api20210601.OriginGroupOverrideAction instead
type OriginGroupOverrideAction struct {
	Name        *string                              `json:"name,omitempty"`
	Parameters  *OriginGroupOverrideActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_OriginGroupOverrideAction populates our OriginGroupOverrideAction from the provided source OriginGroupOverrideAction
func (action *OriginGroupOverrideAction) AssignProperties_From_OriginGroupOverrideAction(source *v20210601s.OriginGroupOverrideAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter OriginGroupOverrideActionParameters
		err := parameter.AssignProperties_From_OriginGroupOverrideActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForOriginGroupOverrideAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideAction populates the provided destination OriginGroupOverrideAction from our OriginGroupOverrideAction
func (action *OriginGroupOverrideAction) AssignProperties_To_OriginGroupOverrideAction(destination *v20210601s.OriginGroupOverrideAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.OriginGroupOverrideActionParameters
		err := action.Parameters.AssignProperties_To_OriginGroupOverrideActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForOriginGroupOverrideAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.OriginGroupOverrideAction_STATUS
// Deprecated version of OriginGroupOverrideAction_STATUS. Use v1api20210601.OriginGroupOverrideAction_STATUS instead
type OriginGroupOverrideAction_STATUS struct {
	Name        *string                                     `json:"name,omitempty"`
	Parameters  *OriginGroupOverrideActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_OriginGroupOverrideAction_STATUS populates our OriginGroupOverrideAction_STATUS from the provided source OriginGroupOverrideAction_STATUS
func (action *OriginGroupOverrideAction_STATUS) AssignProperties_From_OriginGroupOverrideAction_STATUS(source *v20210601s.OriginGroupOverrideAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter OriginGroupOverrideActionParameters_STATUS
		err := parameter.AssignProperties_From_OriginGroupOverrideActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverrideActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForOriginGroupOverrideAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideAction_STATUS populates the provided destination OriginGroupOverrideAction_STATUS from our OriginGroupOverrideAction_STATUS
func (action *OriginGroupOverrideAction_STATUS) AssignProperties_To_OriginGroupOverrideAction_STATUS(destination *v20210601s.OriginGroupOverrideAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.OriginGroupOverrideActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_OriginGroupOverrideActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverrideActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForOriginGroupOverrideAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlRedirectAction
// Deprecated version of UrlRedirectAction. Use v1api20210601.UrlRedirectAction instead
type UrlRedirectAction struct {
	Name        *string                      `json:"name,omitempty"`
	Parameters  *UrlRedirectActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlRedirectAction populates our UrlRedirectAction from the provided source UrlRedirectAction
func (action *UrlRedirectAction) AssignProperties_From_UrlRedirectAction(source *v20210601s.UrlRedirectAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRedirectActionParameters
		err := parameter.AssignProperties_From_UrlRedirectActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRedirectAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectAction populates the provided destination UrlRedirectAction from our UrlRedirectAction
func (action *UrlRedirectAction) AssignProperties_To_UrlRedirectAction(destination *v20210601s.UrlRedirectAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.UrlRedirectActionParameters
		err := action.Parameters.AssignProperties_To_UrlRedirectActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRedirectAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlRedirectAction_STATUS
// Deprecated version of UrlRedirectAction_STATUS. Use v1api20210601.UrlRedirectAction_STATUS instead
type UrlRedirectAction_STATUS struct {
	Name        *string                             `json:"name,omitempty"`
	Parameters  *UrlRedirectActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag              `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlRedirectAction_STATUS populates our UrlRedirectAction_STATUS from the provided source UrlRedirectAction_STATUS
func (action *UrlRedirectAction_STATUS) AssignProperties_From_UrlRedirectAction_STATUS(source *v20210601s.UrlRedirectAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRedirectActionParameters_STATUS
		err := parameter.AssignProperties_From_UrlRedirectActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRedirectActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRedirectAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectAction_STATUS populates the provided destination UrlRedirectAction_STATUS from our UrlRedirectAction_STATUS
func (action *UrlRedirectAction_STATUS) AssignProperties_To_UrlRedirectAction_STATUS(destination *v20210601s.UrlRedirectAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.UrlRedirectActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_UrlRedirectActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRedirectActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRedirectAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlRewriteAction
// Deprecated version of UrlRewriteAction. Use v1api20210601.UrlRewriteAction instead
type UrlRewriteAction struct {
	Name        *string                     `json:"name,omitempty"`
	Parameters  *UrlRewriteActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlRewriteAction populates our UrlRewriteAction from the provided source UrlRewriteAction
func (action *UrlRewriteAction) AssignProperties_From_UrlRewriteAction(source *v20210601s.UrlRewriteAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRewriteActionParameters
		err := parameter.AssignProperties_From_UrlRewriteActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRewriteAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteAction populates the provided destination UrlRewriteAction from our UrlRewriteAction
func (action *UrlRewriteAction) AssignProperties_To_UrlRewriteAction(destination *v20210601s.UrlRewriteAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.UrlRewriteActionParameters
		err := action.Parameters.AssignProperties_To_UrlRewriteActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRewriteAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlRewriteAction_STATUS
// Deprecated version of UrlRewriteAction_STATUS. Use v1api20210601.UrlRewriteAction_STATUS instead
type UrlRewriteAction_STATUS struct {
	Name        *string                            `json:"name,omitempty"`
	Parameters  *UrlRewriteActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlRewriteAction_STATUS populates our UrlRewriteAction_STATUS from the provided source UrlRewriteAction_STATUS
func (action *UrlRewriteAction_STATUS) AssignProperties_From_UrlRewriteAction_STATUS(source *v20210601s.UrlRewriteAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlRewriteActionParameters_STATUS
		err := parameter.AssignProperties_From_UrlRewriteActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlRewriteActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRewriteAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteAction_STATUS populates the provided destination UrlRewriteAction_STATUS from our UrlRewriteAction_STATUS
func (action *UrlRewriteAction_STATUS) AssignProperties_To_UrlRewriteAction_STATUS(destination *v20210601s.UrlRewriteAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.UrlRewriteActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_UrlRewriteActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlRewriteActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlRewriteAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlSigningAction
// Deprecated version of UrlSigningAction. Use v1api20210601.UrlSigningAction instead
type UrlSigningAction struct {
	Name        *string                     `json:"name,omitempty"`
	Parameters  *UrlSigningActionParameters `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlSigningAction populates our UrlSigningAction from the provided source UrlSigningAction
func (action *UrlSigningAction) AssignProperties_From_UrlSigningAction(source *v20210601s.UrlSigningAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlSigningActionParameters
		err := parameter.AssignProperties_From_UrlSigningActionParameters(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningActionParameters() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlSigningAction); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningAction populates the provided destination UrlSigningAction from our UrlSigningAction
func (action *UrlSigningAction) AssignProperties_To_UrlSigningAction(destination *v20210601s.UrlSigningAction) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.UrlSigningActionParameters
		err := action.Parameters.AssignProperties_To_UrlSigningActionParameters(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningActionParameters() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningAction interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlSigningAction); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlSigningAction_STATUS
// Deprecated version of UrlSigningAction_STATUS. Use v1api20210601.UrlSigningAction_STATUS instead
type UrlSigningAction_STATUS struct {
	Name        *string                            `json:"name,omitempty"`
	Parameters  *UrlSigningActionParameters_STATUS `json:"parameters,omitempty"`
	PropertyBag genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlSigningAction_STATUS populates our UrlSigningAction_STATUS from the provided source UrlSigningAction_STATUS
func (action *UrlSigningAction_STATUS) AssignProperties_From_UrlSigningAction_STATUS(source *v20210601s.UrlSigningAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	action.Name = genruntime.ClonePointerToString(source.Name)

	// Parameters
	if source.Parameters != nil {
		var parameter UrlSigningActionParameters_STATUS
		err := parameter.AssignProperties_From_UrlSigningActionParameters_STATUS(source.Parameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UrlSigningActionParameters_STATUS() to populate field Parameters")
		}
		action.Parameters = &parameter
	} else {
		action.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		action.PropertyBag = propertyBag
	} else {
		action.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlSigningAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningAction_STATUS populates the provided destination UrlSigningAction_STATUS from our UrlSigningAction_STATUS
func (action *UrlSigningAction_STATUS) AssignProperties_To_UrlSigningAction_STATUS(destination *v20210601s.UrlSigningAction_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(action.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(action.Name)

	// Parameters
	if action.Parameters != nil {
		var parameter v20210601s.UrlSigningActionParameters_STATUS
		err := action.Parameters.AssignProperties_To_UrlSigningActionParameters_STATUS(&parameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UrlSigningActionParameters_STATUS() to populate field Parameters")
		}
		destination.Parameters = &parameter
	} else {
		destination.Parameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningAction_STATUS interface (if implemented) to customize the conversion
	var actionAsAny any = action
	if augmentedAction, ok := actionAsAny.(augmentConversionForUrlSigningAction_STATUS); ok {
		err := augmentedAction.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForDeliveryRuleCacheExpirationAction interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleCacheExpirationAction) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleCacheExpirationAction) error
}

type augmentConversionForDeliveryRuleCacheExpirationAction_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleCacheExpirationAction_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleCacheExpirationAction_STATUS) error
}

type augmentConversionForDeliveryRuleCacheKeyQueryStringAction interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleCacheKeyQueryStringAction) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleCacheKeyQueryStringAction) error
}

type augmentConversionForDeliveryRuleCacheKeyQueryStringAction_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleCacheKeyQueryStringAction_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleCacheKeyQueryStringAction_STATUS) error
}

type augmentConversionForDeliveryRuleClientPortCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleClientPortCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleClientPortCondition) error
}

type augmentConversionForDeliveryRuleClientPortCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleClientPortCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleClientPortCondition_STATUS) error
}

type augmentConversionForDeliveryRuleCookiesCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleCookiesCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleCookiesCondition) error
}

type augmentConversionForDeliveryRuleCookiesCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleCookiesCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleCookiesCondition_STATUS) error
}

type augmentConversionForDeliveryRuleHostNameCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleHostNameCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleHostNameCondition) error
}

type augmentConversionForDeliveryRuleHostNameCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleHostNameCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleHostNameCondition_STATUS) error
}

type augmentConversionForDeliveryRuleHttpVersionCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleHttpVersionCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleHttpVersionCondition) error
}

type augmentConversionForDeliveryRuleHttpVersionCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleHttpVersionCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleHttpVersionCondition_STATUS) error
}

type augmentConversionForDeliveryRuleIsDeviceCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleIsDeviceCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleIsDeviceCondition) error
}

type augmentConversionForDeliveryRuleIsDeviceCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleIsDeviceCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleIsDeviceCondition_STATUS) error
}

type augmentConversionForDeliveryRulePostArgsCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRulePostArgsCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRulePostArgsCondition) error
}

type augmentConversionForDeliveryRulePostArgsCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRulePostArgsCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRulePostArgsCondition_STATUS) error
}

type augmentConversionForDeliveryRuleQueryStringCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleQueryStringCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleQueryStringCondition) error
}

type augmentConversionForDeliveryRuleQueryStringCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleQueryStringCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleQueryStringCondition_STATUS) error
}

type augmentConversionForDeliveryRuleRemoteAddressCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRemoteAddressCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRemoteAddressCondition) error
}

type augmentConversionForDeliveryRuleRemoteAddressCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRemoteAddressCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRemoteAddressCondition_STATUS) error
}

type augmentConversionForDeliveryRuleRequestBodyCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRequestBodyCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRequestBodyCondition) error
}

type augmentConversionForDeliveryRuleRequestBodyCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRequestBodyCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRequestBodyCondition_STATUS) error
}

type augmentConversionForDeliveryRuleRequestHeaderAction interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRequestHeaderAction) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRequestHeaderAction) error
}

type augmentConversionForDeliveryRuleRequestHeaderAction_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRequestHeaderAction_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRequestHeaderAction_STATUS) error
}

type augmentConversionForDeliveryRuleRequestHeaderCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRequestHeaderCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRequestHeaderCondition) error
}

type augmentConversionForDeliveryRuleRequestHeaderCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRequestHeaderCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRequestHeaderCondition_STATUS) error
}

type augmentConversionForDeliveryRuleRequestMethodCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRequestMethodCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRequestMethodCondition) error
}

type augmentConversionForDeliveryRuleRequestMethodCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRequestMethodCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRequestMethodCondition_STATUS) error
}

type augmentConversionForDeliveryRuleRequestSchemeCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRequestSchemeCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRequestSchemeCondition) error
}

type augmentConversionForDeliveryRuleRequestSchemeCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRequestSchemeCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRequestSchemeCondition_STATUS) error
}

type augmentConversionForDeliveryRuleRequestUriCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRequestUriCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRequestUriCondition) error
}

type augmentConversionForDeliveryRuleRequestUriCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRequestUriCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRequestUriCondition_STATUS) error
}

type augmentConversionForDeliveryRuleResponseHeaderAction interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleResponseHeaderAction) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleResponseHeaderAction) error
}

type augmentConversionForDeliveryRuleResponseHeaderAction_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleResponseHeaderAction_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleResponseHeaderAction_STATUS) error
}

type augmentConversionForDeliveryRuleRouteConfigurationOverrideAction interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRouteConfigurationOverrideAction) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRouteConfigurationOverrideAction) error
}

type augmentConversionForDeliveryRuleRouteConfigurationOverrideAction_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleRouteConfigurationOverrideAction_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleRouteConfigurationOverrideAction_STATUS) error
}

type augmentConversionForDeliveryRuleServerPortCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleServerPortCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleServerPortCondition) error
}

type augmentConversionForDeliveryRuleServerPortCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleServerPortCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleServerPortCondition_STATUS) error
}

type augmentConversionForDeliveryRuleSocketAddrCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleSocketAddrCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleSocketAddrCondition) error
}

type augmentConversionForDeliveryRuleSocketAddrCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleSocketAddrCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleSocketAddrCondition_STATUS) error
}

type augmentConversionForDeliveryRuleSslProtocolCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleSslProtocolCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleSslProtocolCondition) error
}

type augmentConversionForDeliveryRuleSslProtocolCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleSslProtocolCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleSslProtocolCondition_STATUS) error
}

type augmentConversionForDeliveryRuleUrlFileExtensionCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleUrlFileExtensionCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleUrlFileExtensionCondition) error
}

type augmentConversionForDeliveryRuleUrlFileExtensionCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleUrlFileExtensionCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleUrlFileExtensionCondition_STATUS) error
}

type augmentConversionForDeliveryRuleUrlFileNameCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleUrlFileNameCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleUrlFileNameCondition) error
}

type augmentConversionForDeliveryRuleUrlFileNameCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleUrlFileNameCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleUrlFileNameCondition_STATUS) error
}

type augmentConversionForDeliveryRuleUrlPathCondition interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleUrlPathCondition) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleUrlPathCondition) error
}

type augmentConversionForDeliveryRuleUrlPathCondition_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.DeliveryRuleUrlPathCondition_STATUS) error
	AssignPropertiesTo(dst *v20210601s.DeliveryRuleUrlPathCondition_STATUS) error
}

type augmentConversionForOriginGroupOverrideAction interface {
	AssignPropertiesFrom(src *v20210601s.OriginGroupOverrideAction) error
	AssignPropertiesTo(dst *v20210601s.OriginGroupOverrideAction) error
}

type augmentConversionForOriginGroupOverrideAction_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.OriginGroupOverrideAction_STATUS) error
	AssignPropertiesTo(dst *v20210601s.OriginGroupOverrideAction_STATUS) error
}

type augmentConversionForUrlRedirectAction interface {
	AssignPropertiesFrom(src *v20210601s.UrlRedirectAction) error
	AssignPropertiesTo(dst *v20210601s.UrlRedirectAction) error
}

type augmentConversionForUrlRedirectAction_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.UrlRedirectAction_STATUS) error
	AssignPropertiesTo(dst *v20210601s.UrlRedirectAction_STATUS) error
}

type augmentConversionForUrlRewriteAction interface {
	AssignPropertiesFrom(src *v20210601s.UrlRewriteAction) error
	AssignPropertiesTo(dst *v20210601s.UrlRewriteAction) error
}

type augmentConversionForUrlRewriteAction_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.UrlRewriteAction_STATUS) error
	AssignPropertiesTo(dst *v20210601s.UrlRewriteAction_STATUS) error
}

type augmentConversionForUrlSigningAction interface {
	AssignPropertiesFrom(src *v20210601s.UrlSigningAction) error
	AssignPropertiesTo(dst *v20210601s.UrlSigningAction) error
}

type augmentConversionForUrlSigningAction_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.UrlSigningAction_STATUS) error
	AssignPropertiesTo(dst *v20210601s.UrlSigningAction_STATUS) error
}

// Storage version of v1beta20210601.CacheExpirationActionParameters
// Deprecated version of CacheExpirationActionParameters. Use v1api20210601.CacheExpirationActionParameters instead
type CacheExpirationActionParameters struct {
	CacheBehavior *string                `json:"cacheBehavior,omitempty"`
	CacheDuration *string                `json:"cacheDuration,omitempty"`
	CacheType     *string                `json:"cacheType,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName      *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_CacheExpirationActionParameters populates our CacheExpirationActionParameters from the provided source CacheExpirationActionParameters
func (parameters *CacheExpirationActionParameters) AssignProperties_From_CacheExpirationActionParameters(source *v20210601s.CacheExpirationActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheBehavior
	parameters.CacheBehavior = genruntime.ClonePointerToString(source.CacheBehavior)

	// CacheDuration
	parameters.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// CacheType
	parameters.CacheType = genruntime.ClonePointerToString(source.CacheType)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheExpirationActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheExpirationActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CacheExpirationActionParameters populates the provided destination CacheExpirationActionParameters from our CacheExpirationActionParameters
func (parameters *CacheExpirationActionParameters) AssignProperties_To_CacheExpirationActionParameters(destination *v20210601s.CacheExpirationActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CacheBehavior
	destination.CacheBehavior = genruntime.ClonePointerToString(parameters.CacheBehavior)

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(parameters.CacheDuration)

	// CacheType
	destination.CacheType = genruntime.ClonePointerToString(parameters.CacheType)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheExpirationActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheExpirationActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.CacheExpirationActionParameters_STATUS
// Deprecated version of CacheExpirationActionParameters_STATUS. Use v1api20210601.CacheExpirationActionParameters_STATUS instead
type CacheExpirationActionParameters_STATUS struct {
	CacheBehavior *string                `json:"cacheBehavior,omitempty"`
	CacheDuration *string                `json:"cacheDuration,omitempty"`
	CacheType     *string                `json:"cacheType,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName      *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_CacheExpirationActionParameters_STATUS populates our CacheExpirationActionParameters_STATUS from the provided source CacheExpirationActionParameters_STATUS
func (parameters *CacheExpirationActionParameters_STATUS) AssignProperties_From_CacheExpirationActionParameters_STATUS(source *v20210601s.CacheExpirationActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheBehavior
	parameters.CacheBehavior = genruntime.ClonePointerToString(source.CacheBehavior)

	// CacheDuration
	parameters.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// CacheType
	parameters.CacheType = genruntime.ClonePointerToString(source.CacheType)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheExpirationActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheExpirationActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CacheExpirationActionParameters_STATUS populates the provided destination CacheExpirationActionParameters_STATUS from our CacheExpirationActionParameters_STATUS
func (parameters *CacheExpirationActionParameters_STATUS) AssignProperties_To_CacheExpirationActionParameters_STATUS(destination *v20210601s.CacheExpirationActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CacheBehavior
	destination.CacheBehavior = genruntime.ClonePointerToString(parameters.CacheBehavior)

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(parameters.CacheDuration)

	// CacheType
	destination.CacheType = genruntime.ClonePointerToString(parameters.CacheType)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheExpirationActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheExpirationActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.CacheKeyQueryStringActionParameters
// Deprecated version of CacheKeyQueryStringActionParameters. Use v1api20210601.CacheKeyQueryStringActionParameters instead
type CacheKeyQueryStringActionParameters struct {
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	QueryParameters     *string                `json:"queryParameters,omitempty"`
	QueryStringBehavior *string                `json:"queryStringBehavior,omitempty"`
	TypeName            *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_CacheKeyQueryStringActionParameters populates our CacheKeyQueryStringActionParameters from the provided source CacheKeyQueryStringActionParameters
func (parameters *CacheKeyQueryStringActionParameters) AssignProperties_From_CacheKeyQueryStringActionParameters(source *v20210601s.CacheKeyQueryStringActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// QueryParameters
	parameters.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringBehavior
	parameters.QueryStringBehavior = genruntime.ClonePointerToString(source.QueryStringBehavior)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheKeyQueryStringActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheKeyQueryStringActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CacheKeyQueryStringActionParameters populates the provided destination CacheKeyQueryStringActionParameters from our CacheKeyQueryStringActionParameters
func (parameters *CacheKeyQueryStringActionParameters) AssignProperties_To_CacheKeyQueryStringActionParameters(destination *v20210601s.CacheKeyQueryStringActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(parameters.QueryParameters)

	// QueryStringBehavior
	destination.QueryStringBehavior = genruntime.ClonePointerToString(parameters.QueryStringBehavior)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheKeyQueryStringActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheKeyQueryStringActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.CacheKeyQueryStringActionParameters_STATUS
// Deprecated version of CacheKeyQueryStringActionParameters_STATUS. Use v1api20210601.CacheKeyQueryStringActionParameters_STATUS instead
type CacheKeyQueryStringActionParameters_STATUS struct {
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	QueryParameters     *string                `json:"queryParameters,omitempty"`
	QueryStringBehavior *string                `json:"queryStringBehavior,omitempty"`
	TypeName            *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS populates our CacheKeyQueryStringActionParameters_STATUS from the provided source CacheKeyQueryStringActionParameters_STATUS
func (parameters *CacheKeyQueryStringActionParameters_STATUS) AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS(source *v20210601s.CacheKeyQueryStringActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// QueryParameters
	parameters.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringBehavior
	parameters.QueryStringBehavior = genruntime.ClonePointerToString(source.QueryStringBehavior)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheKeyQueryStringActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheKeyQueryStringActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS populates the provided destination CacheKeyQueryStringActionParameters_STATUS from our CacheKeyQueryStringActionParameters_STATUS
func (parameters *CacheKeyQueryStringActionParameters_STATUS) AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS(destination *v20210601s.CacheKeyQueryStringActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(parameters.QueryParameters)

	// QueryStringBehavior
	destination.QueryStringBehavior = genruntime.ClonePointerToString(parameters.QueryStringBehavior)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheKeyQueryStringActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCacheKeyQueryStringActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.ClientPortMatchConditionParameters
// Deprecated version of ClientPortMatchConditionParameters. Use v1api20210601.ClientPortMatchConditionParameters instead
type ClientPortMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_ClientPortMatchConditionParameters populates our ClientPortMatchConditionParameters from the provided source ClientPortMatchConditionParameters
func (parameters *ClientPortMatchConditionParameters) AssignProperties_From_ClientPortMatchConditionParameters(source *v20210601s.ClientPortMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForClientPortMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForClientPortMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ClientPortMatchConditionParameters populates the provided destination ClientPortMatchConditionParameters from our ClientPortMatchConditionParameters
func (parameters *ClientPortMatchConditionParameters) AssignProperties_To_ClientPortMatchConditionParameters(destination *v20210601s.ClientPortMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForClientPortMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForClientPortMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.ClientPortMatchConditionParameters_STATUS
// Deprecated version of ClientPortMatchConditionParameters_STATUS. Use v1api20210601.ClientPortMatchConditionParameters_STATUS instead
type ClientPortMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_ClientPortMatchConditionParameters_STATUS populates our ClientPortMatchConditionParameters_STATUS from the provided source ClientPortMatchConditionParameters_STATUS
func (parameters *ClientPortMatchConditionParameters_STATUS) AssignProperties_From_ClientPortMatchConditionParameters_STATUS(source *v20210601s.ClientPortMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForClientPortMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForClientPortMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ClientPortMatchConditionParameters_STATUS populates the provided destination ClientPortMatchConditionParameters_STATUS from our ClientPortMatchConditionParameters_STATUS
func (parameters *ClientPortMatchConditionParameters_STATUS) AssignProperties_To_ClientPortMatchConditionParameters_STATUS(destination *v20210601s.ClientPortMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForClientPortMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForClientPortMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.CookiesMatchConditionParameters
// Deprecated version of CookiesMatchConditionParameters. Use v1api20210601.CookiesMatchConditionParameters instead
type CookiesMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_CookiesMatchConditionParameters populates our CookiesMatchConditionParameters from the provided source CookiesMatchConditionParameters
func (parameters *CookiesMatchConditionParameters) AssignProperties_From_CookiesMatchConditionParameters(source *v20210601s.CookiesMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForCookiesMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCookiesMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CookiesMatchConditionParameters populates the provided destination CookiesMatchConditionParameters from our CookiesMatchConditionParameters
func (parameters *CookiesMatchConditionParameters) AssignProperties_To_CookiesMatchConditionParameters(destination *v20210601s.CookiesMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCookiesMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCookiesMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.CookiesMatchConditionParameters_STATUS
// Deprecated version of CookiesMatchConditionParameters_STATUS. Use v1api20210601.CookiesMatchConditionParameters_STATUS instead
type CookiesMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_CookiesMatchConditionParameters_STATUS populates our CookiesMatchConditionParameters_STATUS from the provided source CookiesMatchConditionParameters_STATUS
func (parameters *CookiesMatchConditionParameters_STATUS) AssignProperties_From_CookiesMatchConditionParameters_STATUS(source *v20210601s.CookiesMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForCookiesMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCookiesMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CookiesMatchConditionParameters_STATUS populates the provided destination CookiesMatchConditionParameters_STATUS from our CookiesMatchConditionParameters_STATUS
func (parameters *CookiesMatchConditionParameters_STATUS) AssignProperties_To_CookiesMatchConditionParameters_STATUS(destination *v20210601s.CookiesMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCookiesMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForCookiesMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.HeaderActionParameters
// Deprecated version of HeaderActionParameters. Use v1api20210601.HeaderActionParameters instead
type HeaderActionParameters struct {
	HeaderAction *string                `json:"headerAction,omitempty"`
	HeaderName   *string                `json:"headerName,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName     *string                `json:"typeName,omitempty"`
	Value        *string                `json:"value,omitempty"`
}

// AssignProperties_From_HeaderActionParameters populates our HeaderActionParameters from the provided source HeaderActionParameters
func (parameters *HeaderActionParameters) AssignProperties_From_HeaderActionParameters(source *v20210601s.HeaderActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HeaderAction
	parameters.HeaderAction = genruntime.ClonePointerToString(source.HeaderAction)

	// HeaderName
	parameters.HeaderName = genruntime.ClonePointerToString(source.HeaderName)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Value
	parameters.Value = genruntime.ClonePointerToString(source.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHeaderActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHeaderActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HeaderActionParameters populates the provided destination HeaderActionParameters from our HeaderActionParameters
func (parameters *HeaderActionParameters) AssignProperties_To_HeaderActionParameters(destination *v20210601s.HeaderActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// HeaderAction
	destination.HeaderAction = genruntime.ClonePointerToString(parameters.HeaderAction)

	// HeaderName
	destination.HeaderName = genruntime.ClonePointerToString(parameters.HeaderName)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Value
	destination.Value = genruntime.ClonePointerToString(parameters.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHeaderActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHeaderActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.HeaderActionParameters_STATUS
// Deprecated version of HeaderActionParameters_STATUS. Use v1api20210601.HeaderActionParameters_STATUS instead
type HeaderActionParameters_STATUS struct {
	HeaderAction *string                `json:"headerAction,omitempty"`
	HeaderName   *string                `json:"headerName,omitempty"`
	PropertyBag  genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName     *string                `json:"typeName,omitempty"`
	Value        *string                `json:"value,omitempty"`
}

// AssignProperties_From_HeaderActionParameters_STATUS populates our HeaderActionParameters_STATUS from the provided source HeaderActionParameters_STATUS
func (parameters *HeaderActionParameters_STATUS) AssignProperties_From_HeaderActionParameters_STATUS(source *v20210601s.HeaderActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HeaderAction
	parameters.HeaderAction = genruntime.ClonePointerToString(source.HeaderAction)

	// HeaderName
	parameters.HeaderName = genruntime.ClonePointerToString(source.HeaderName)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Value
	parameters.Value = genruntime.ClonePointerToString(source.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHeaderActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHeaderActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HeaderActionParameters_STATUS populates the provided destination HeaderActionParameters_STATUS from our HeaderActionParameters_STATUS
func (parameters *HeaderActionParameters_STATUS) AssignProperties_To_HeaderActionParameters_STATUS(destination *v20210601s.HeaderActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// HeaderAction
	destination.HeaderAction = genruntime.ClonePointerToString(parameters.HeaderAction)

	// HeaderName
	destination.HeaderName = genruntime.ClonePointerToString(parameters.HeaderName)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Value
	destination.Value = genruntime.ClonePointerToString(parameters.Value)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHeaderActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHeaderActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.HostNameMatchConditionParameters
// Deprecated version of HostNameMatchConditionParameters. Use v1api20210601.HostNameMatchConditionParameters instead
type HostNameMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_HostNameMatchConditionParameters populates our HostNameMatchConditionParameters from the provided source HostNameMatchConditionParameters
func (parameters *HostNameMatchConditionParameters) AssignProperties_From_HostNameMatchConditionParameters(source *v20210601s.HostNameMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHostNameMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHostNameMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HostNameMatchConditionParameters populates the provided destination HostNameMatchConditionParameters from our HostNameMatchConditionParameters
func (parameters *HostNameMatchConditionParameters) AssignProperties_To_HostNameMatchConditionParameters(destination *v20210601s.HostNameMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHostNameMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHostNameMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.HostNameMatchConditionParameters_STATUS
// Deprecated version of HostNameMatchConditionParameters_STATUS. Use v1api20210601.HostNameMatchConditionParameters_STATUS instead
type HostNameMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_HostNameMatchConditionParameters_STATUS populates our HostNameMatchConditionParameters_STATUS from the provided source HostNameMatchConditionParameters_STATUS
func (parameters *HostNameMatchConditionParameters_STATUS) AssignProperties_From_HostNameMatchConditionParameters_STATUS(source *v20210601s.HostNameMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHostNameMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHostNameMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HostNameMatchConditionParameters_STATUS populates the provided destination HostNameMatchConditionParameters_STATUS from our HostNameMatchConditionParameters_STATUS
func (parameters *HostNameMatchConditionParameters_STATUS) AssignProperties_To_HostNameMatchConditionParameters_STATUS(destination *v20210601s.HostNameMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHostNameMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHostNameMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.HttpVersionMatchConditionParameters
// Deprecated version of HttpVersionMatchConditionParameters. Use v1api20210601.HttpVersionMatchConditionParameters instead
type HttpVersionMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_HttpVersionMatchConditionParameters populates our HttpVersionMatchConditionParameters from the provided source HttpVersionMatchConditionParameters
func (parameters *HttpVersionMatchConditionParameters) AssignProperties_From_HttpVersionMatchConditionParameters(source *v20210601s.HttpVersionMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpVersionMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHttpVersionMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HttpVersionMatchConditionParameters populates the provided destination HttpVersionMatchConditionParameters from our HttpVersionMatchConditionParameters
func (parameters *HttpVersionMatchConditionParameters) AssignProperties_To_HttpVersionMatchConditionParameters(destination *v20210601s.HttpVersionMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpVersionMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHttpVersionMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.HttpVersionMatchConditionParameters_STATUS
// Deprecated version of HttpVersionMatchConditionParameters_STATUS. Use v1api20210601.HttpVersionMatchConditionParameters_STATUS instead
type HttpVersionMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_HttpVersionMatchConditionParameters_STATUS populates our HttpVersionMatchConditionParameters_STATUS from the provided source HttpVersionMatchConditionParameters_STATUS
func (parameters *HttpVersionMatchConditionParameters_STATUS) AssignProperties_From_HttpVersionMatchConditionParameters_STATUS(source *v20210601s.HttpVersionMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpVersionMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHttpVersionMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_HttpVersionMatchConditionParameters_STATUS populates the provided destination HttpVersionMatchConditionParameters_STATUS from our HttpVersionMatchConditionParameters_STATUS
func (parameters *HttpVersionMatchConditionParameters_STATUS) AssignProperties_To_HttpVersionMatchConditionParameters_STATUS(destination *v20210601s.HttpVersionMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForHttpVersionMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForHttpVersionMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.IsDeviceMatchConditionParameters
// Deprecated version of IsDeviceMatchConditionParameters. Use v1api20210601.IsDeviceMatchConditionParameters instead
type IsDeviceMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_IsDeviceMatchConditionParameters populates our IsDeviceMatchConditionParameters from the provided source IsDeviceMatchConditionParameters
func (parameters *IsDeviceMatchConditionParameters) AssignProperties_From_IsDeviceMatchConditionParameters(source *v20210601s.IsDeviceMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForIsDeviceMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForIsDeviceMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IsDeviceMatchConditionParameters populates the provided destination IsDeviceMatchConditionParameters from our IsDeviceMatchConditionParameters
func (parameters *IsDeviceMatchConditionParameters) AssignProperties_To_IsDeviceMatchConditionParameters(destination *v20210601s.IsDeviceMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIsDeviceMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForIsDeviceMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.IsDeviceMatchConditionParameters_STATUS
// Deprecated version of IsDeviceMatchConditionParameters_STATUS. Use v1api20210601.IsDeviceMatchConditionParameters_STATUS instead
type IsDeviceMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_IsDeviceMatchConditionParameters_STATUS populates our IsDeviceMatchConditionParameters_STATUS from the provided source IsDeviceMatchConditionParameters_STATUS
func (parameters *IsDeviceMatchConditionParameters_STATUS) AssignProperties_From_IsDeviceMatchConditionParameters_STATUS(source *v20210601s.IsDeviceMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForIsDeviceMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForIsDeviceMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_IsDeviceMatchConditionParameters_STATUS populates the provided destination IsDeviceMatchConditionParameters_STATUS from our IsDeviceMatchConditionParameters_STATUS
func (parameters *IsDeviceMatchConditionParameters_STATUS) AssignProperties_To_IsDeviceMatchConditionParameters_STATUS(destination *v20210601s.IsDeviceMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForIsDeviceMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForIsDeviceMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.OriginGroupOverrideActionParameters
// Deprecated version of OriginGroupOverrideActionParameters. Use v1api20210601.OriginGroupOverrideActionParameters instead
type OriginGroupOverrideActionParameters struct {
	OriginGroup *ResourceReference     `json:"originGroup,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName    *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_OriginGroupOverrideActionParameters populates our OriginGroupOverrideActionParameters from the provided source OriginGroupOverrideActionParameters
func (parameters *OriginGroupOverrideActionParameters) AssignProperties_From_OriginGroupOverrideActionParameters(source *v20210601s.OriginGroupOverrideActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference
		err := originGroup.AssignProperties_From_ResourceReference(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field OriginGroup")
		}
		parameters.OriginGroup = &originGroup
	} else {
		parameters.OriginGroup = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForOriginGroupOverrideActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideActionParameters populates the provided destination OriginGroupOverrideActionParameters from our OriginGroupOverrideActionParameters
func (parameters *OriginGroupOverrideActionParameters) AssignProperties_To_OriginGroupOverrideActionParameters(destination *v20210601s.OriginGroupOverrideActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// OriginGroup
	if parameters.OriginGroup != nil {
		var originGroup v20210601s.ResourceReference
		err := parameters.OriginGroup.AssignProperties_To_ResourceReference(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForOriginGroupOverrideActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.OriginGroupOverrideActionParameters_STATUS
// Deprecated version of OriginGroupOverrideActionParameters_STATUS. Use v1api20210601.OriginGroupOverrideActionParameters_STATUS instead
type OriginGroupOverrideActionParameters_STATUS struct {
	OriginGroup *ResourceReference_STATUS `json:"originGroup,omitempty"`
	PropertyBag genruntime.PropertyBag    `json:"$propertyBag,omitempty"`
	TypeName    *string                   `json:"typeName,omitempty"`
}

// AssignProperties_From_OriginGroupOverrideActionParameters_STATUS populates our OriginGroupOverrideActionParameters_STATUS from the provided source OriginGroupOverrideActionParameters_STATUS
func (parameters *OriginGroupOverrideActionParameters_STATUS) AssignProperties_From_OriginGroupOverrideActionParameters_STATUS(source *v20210601s.OriginGroupOverrideActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference_STATUS
		err := originGroup.AssignProperties_From_ResourceReference_STATUS(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field OriginGroup")
		}
		parameters.OriginGroup = &originGroup
	} else {
		parameters.OriginGroup = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForOriginGroupOverrideActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverrideActionParameters_STATUS populates the provided destination OriginGroupOverrideActionParameters_STATUS from our OriginGroupOverrideActionParameters_STATUS
func (parameters *OriginGroupOverrideActionParameters_STATUS) AssignProperties_To_OriginGroupOverrideActionParameters_STATUS(destination *v20210601s.OriginGroupOverrideActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// OriginGroup
	if parameters.OriginGroup != nil {
		var originGroup v20210601s.ResourceReference_STATUS
		err := parameters.OriginGroup.AssignProperties_To_ResourceReference_STATUS(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverrideActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForOriginGroupOverrideActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.PostArgsMatchConditionParameters
// Deprecated version of PostArgsMatchConditionParameters. Use v1api20210601.PostArgsMatchConditionParameters instead
type PostArgsMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_PostArgsMatchConditionParameters populates our PostArgsMatchConditionParameters from the provided source PostArgsMatchConditionParameters
func (parameters *PostArgsMatchConditionParameters) AssignProperties_From_PostArgsMatchConditionParameters(source *v20210601s.PostArgsMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForPostArgsMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForPostArgsMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PostArgsMatchConditionParameters populates the provided destination PostArgsMatchConditionParameters from our PostArgsMatchConditionParameters
func (parameters *PostArgsMatchConditionParameters) AssignProperties_To_PostArgsMatchConditionParameters(destination *v20210601s.PostArgsMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPostArgsMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForPostArgsMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.PostArgsMatchConditionParameters_STATUS
// Deprecated version of PostArgsMatchConditionParameters_STATUS. Use v1api20210601.PostArgsMatchConditionParameters_STATUS instead
type PostArgsMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_PostArgsMatchConditionParameters_STATUS populates our PostArgsMatchConditionParameters_STATUS from the provided source PostArgsMatchConditionParameters_STATUS
func (parameters *PostArgsMatchConditionParameters_STATUS) AssignProperties_From_PostArgsMatchConditionParameters_STATUS(source *v20210601s.PostArgsMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForPostArgsMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForPostArgsMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_PostArgsMatchConditionParameters_STATUS populates the provided destination PostArgsMatchConditionParameters_STATUS from our PostArgsMatchConditionParameters_STATUS
func (parameters *PostArgsMatchConditionParameters_STATUS) AssignProperties_To_PostArgsMatchConditionParameters_STATUS(destination *v20210601s.PostArgsMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForPostArgsMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForPostArgsMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.QueryStringMatchConditionParameters
// Deprecated version of QueryStringMatchConditionParameters. Use v1api20210601.QueryStringMatchConditionParameters instead
type QueryStringMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_QueryStringMatchConditionParameters populates our QueryStringMatchConditionParameters from the provided source QueryStringMatchConditionParameters
func (parameters *QueryStringMatchConditionParameters) AssignProperties_From_QueryStringMatchConditionParameters(source *v20210601s.QueryStringMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForQueryStringMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForQueryStringMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_QueryStringMatchConditionParameters populates the provided destination QueryStringMatchConditionParameters from our QueryStringMatchConditionParameters
func (parameters *QueryStringMatchConditionParameters) AssignProperties_To_QueryStringMatchConditionParameters(destination *v20210601s.QueryStringMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForQueryStringMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForQueryStringMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.QueryStringMatchConditionParameters_STATUS
// Deprecated version of QueryStringMatchConditionParameters_STATUS. Use v1api20210601.QueryStringMatchConditionParameters_STATUS instead
type QueryStringMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_QueryStringMatchConditionParameters_STATUS populates our QueryStringMatchConditionParameters_STATUS from the provided source QueryStringMatchConditionParameters_STATUS
func (parameters *QueryStringMatchConditionParameters_STATUS) AssignProperties_From_QueryStringMatchConditionParameters_STATUS(source *v20210601s.QueryStringMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForQueryStringMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForQueryStringMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_QueryStringMatchConditionParameters_STATUS populates the provided destination QueryStringMatchConditionParameters_STATUS from our QueryStringMatchConditionParameters_STATUS
func (parameters *QueryStringMatchConditionParameters_STATUS) AssignProperties_To_QueryStringMatchConditionParameters_STATUS(destination *v20210601s.QueryStringMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForQueryStringMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForQueryStringMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.RemoteAddressMatchConditionParameters
// Deprecated version of RemoteAddressMatchConditionParameters. Use v1api20210601.RemoteAddressMatchConditionParameters instead
type RemoteAddressMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RemoteAddressMatchConditionParameters populates our RemoteAddressMatchConditionParameters from the provided source RemoteAddressMatchConditionParameters
func (parameters *RemoteAddressMatchConditionParameters) AssignProperties_From_RemoteAddressMatchConditionParameters(source *v20210601s.RemoteAddressMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRemoteAddressMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRemoteAddressMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RemoteAddressMatchConditionParameters populates the provided destination RemoteAddressMatchConditionParameters from our RemoteAddressMatchConditionParameters
func (parameters *RemoteAddressMatchConditionParameters) AssignProperties_To_RemoteAddressMatchConditionParameters(destination *v20210601s.RemoteAddressMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRemoteAddressMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRemoteAddressMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.RemoteAddressMatchConditionParameters_STATUS
// Deprecated version of RemoteAddressMatchConditionParameters_STATUS. Use v1api20210601.RemoteAddressMatchConditionParameters_STATUS instead
type RemoteAddressMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS populates our RemoteAddressMatchConditionParameters_STATUS from the provided source RemoteAddressMatchConditionParameters_STATUS
func (parameters *RemoteAddressMatchConditionParameters_STATUS) AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS(source *v20210601s.RemoteAddressMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRemoteAddressMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRemoteAddressMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS populates the provided destination RemoteAddressMatchConditionParameters_STATUS from our RemoteAddressMatchConditionParameters_STATUS
func (parameters *RemoteAddressMatchConditionParameters_STATUS) AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS(destination *v20210601s.RemoteAddressMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRemoteAddressMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRemoteAddressMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.RequestBodyMatchConditionParameters
// Deprecated version of RequestBodyMatchConditionParameters. Use v1api20210601.RequestBodyMatchConditionParameters instead
type RequestBodyMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestBodyMatchConditionParameters populates our RequestBodyMatchConditionParameters from the provided source RequestBodyMatchConditionParameters
func (parameters *RequestBodyMatchConditionParameters) AssignProperties_From_RequestBodyMatchConditionParameters(source *v20210601s.RequestBodyMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestBodyMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestBodyMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestBodyMatchConditionParameters populates the provided destination RequestBodyMatchConditionParameters from our RequestBodyMatchConditionParameters
func (parameters *RequestBodyMatchConditionParameters) AssignProperties_To_RequestBodyMatchConditionParameters(destination *v20210601s.RequestBodyMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestBodyMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestBodyMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.RequestBodyMatchConditionParameters_STATUS
// Deprecated version of RequestBodyMatchConditionParameters_STATUS. Use v1api20210601.RequestBodyMatchConditionParameters_STATUS instead
type RequestBodyMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestBodyMatchConditionParameters_STATUS populates our RequestBodyMatchConditionParameters_STATUS from the provided source RequestBodyMatchConditionParameters_STATUS
func (parameters *RequestBodyMatchConditionParameters_STATUS) AssignProperties_From_RequestBodyMatchConditionParameters_STATUS(source *v20210601s.RequestBodyMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestBodyMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestBodyMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestBodyMatchConditionParameters_STATUS populates the provided destination RequestBodyMatchConditionParameters_STATUS from our RequestBodyMatchConditionParameters_STATUS
func (parameters *RequestBodyMatchConditionParameters_STATUS) AssignProperties_To_RequestBodyMatchConditionParameters_STATUS(destination *v20210601s.RequestBodyMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestBodyMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestBodyMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.RequestHeaderMatchConditionParameters
// Deprecated version of RequestHeaderMatchConditionParameters. Use v1api20210601.RequestHeaderMatchConditionParameters instead
type RequestHeaderMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestHeaderMatchConditionParameters populates our RequestHeaderMatchConditionParameters from the provided source RequestHeaderMatchConditionParameters
func (parameters *RequestHeaderMatchConditionParameters) AssignProperties_From_RequestHeaderMatchConditionParameters(source *v20210601s.RequestHeaderMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestHeaderMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestHeaderMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestHeaderMatchConditionParameters populates the provided destination RequestHeaderMatchConditionParameters from our RequestHeaderMatchConditionParameters
func (parameters *RequestHeaderMatchConditionParameters) AssignProperties_To_RequestHeaderMatchConditionParameters(destination *v20210601s.RequestHeaderMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestHeaderMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestHeaderMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.RequestHeaderMatchConditionParameters_STATUS
// Deprecated version of RequestHeaderMatchConditionParameters_STATUS. Use v1api20210601.RequestHeaderMatchConditionParameters_STATUS instead
type RequestHeaderMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Selector        *string                `json:"selector,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS populates our RequestHeaderMatchConditionParameters_STATUS from the provided source RequestHeaderMatchConditionParameters_STATUS
func (parameters *RequestHeaderMatchConditionParameters_STATUS) AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS(source *v20210601s.RequestHeaderMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Selector
	parameters.Selector = genruntime.ClonePointerToString(source.Selector)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestHeaderMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestHeaderMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS populates the provided destination RequestHeaderMatchConditionParameters_STATUS from our RequestHeaderMatchConditionParameters_STATUS
func (parameters *RequestHeaderMatchConditionParameters_STATUS) AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS(destination *v20210601s.RequestHeaderMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Selector
	destination.Selector = genruntime.ClonePointerToString(parameters.Selector)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestHeaderMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestHeaderMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.RequestMethodMatchConditionParameters
// Deprecated version of RequestMethodMatchConditionParameters. Use v1api20210601.RequestMethodMatchConditionParameters instead
type RequestMethodMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestMethodMatchConditionParameters populates our RequestMethodMatchConditionParameters from the provided source RequestMethodMatchConditionParameters
func (parameters *RequestMethodMatchConditionParameters) AssignProperties_From_RequestMethodMatchConditionParameters(source *v20210601s.RequestMethodMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestMethodMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestMethodMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestMethodMatchConditionParameters populates the provided destination RequestMethodMatchConditionParameters from our RequestMethodMatchConditionParameters
func (parameters *RequestMethodMatchConditionParameters) AssignProperties_To_RequestMethodMatchConditionParameters(destination *v20210601s.RequestMethodMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestMethodMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestMethodMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.RequestMethodMatchConditionParameters_STATUS
// Deprecated version of RequestMethodMatchConditionParameters_STATUS. Use v1api20210601.RequestMethodMatchConditionParameters_STATUS instead
type RequestMethodMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestMethodMatchConditionParameters_STATUS populates our RequestMethodMatchConditionParameters_STATUS from the provided source RequestMethodMatchConditionParameters_STATUS
func (parameters *RequestMethodMatchConditionParameters_STATUS) AssignProperties_From_RequestMethodMatchConditionParameters_STATUS(source *v20210601s.RequestMethodMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestMethodMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestMethodMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestMethodMatchConditionParameters_STATUS populates the provided destination RequestMethodMatchConditionParameters_STATUS from our RequestMethodMatchConditionParameters_STATUS
func (parameters *RequestMethodMatchConditionParameters_STATUS) AssignProperties_To_RequestMethodMatchConditionParameters_STATUS(destination *v20210601s.RequestMethodMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestMethodMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestMethodMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.RequestSchemeMatchConditionParameters
// Deprecated version of RequestSchemeMatchConditionParameters. Use v1api20210601.RequestSchemeMatchConditionParameters instead
type RequestSchemeMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestSchemeMatchConditionParameters populates our RequestSchemeMatchConditionParameters from the provided source RequestSchemeMatchConditionParameters
func (parameters *RequestSchemeMatchConditionParameters) AssignProperties_From_RequestSchemeMatchConditionParameters(source *v20210601s.RequestSchemeMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestSchemeMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestSchemeMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestSchemeMatchConditionParameters populates the provided destination RequestSchemeMatchConditionParameters from our RequestSchemeMatchConditionParameters
func (parameters *RequestSchemeMatchConditionParameters) AssignProperties_To_RequestSchemeMatchConditionParameters(destination *v20210601s.RequestSchemeMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestSchemeMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestSchemeMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.RequestSchemeMatchConditionParameters_STATUS
// Deprecated version of RequestSchemeMatchConditionParameters_STATUS. Use v1api20210601.RequestSchemeMatchConditionParameters_STATUS instead
type RequestSchemeMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS populates our RequestSchemeMatchConditionParameters_STATUS from the provided source RequestSchemeMatchConditionParameters_STATUS
func (parameters *RequestSchemeMatchConditionParameters_STATUS) AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS(source *v20210601s.RequestSchemeMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestSchemeMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestSchemeMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS populates the provided destination RequestSchemeMatchConditionParameters_STATUS from our RequestSchemeMatchConditionParameters_STATUS
func (parameters *RequestSchemeMatchConditionParameters_STATUS) AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS(destination *v20210601s.RequestSchemeMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestSchemeMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestSchemeMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.RequestUriMatchConditionParameters
// Deprecated version of RequestUriMatchConditionParameters. Use v1api20210601.RequestUriMatchConditionParameters instead
type RequestUriMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestUriMatchConditionParameters populates our RequestUriMatchConditionParameters from the provided source RequestUriMatchConditionParameters
func (parameters *RequestUriMatchConditionParameters) AssignProperties_From_RequestUriMatchConditionParameters(source *v20210601s.RequestUriMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestUriMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestUriMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestUriMatchConditionParameters populates the provided destination RequestUriMatchConditionParameters from our RequestUriMatchConditionParameters
func (parameters *RequestUriMatchConditionParameters) AssignProperties_To_RequestUriMatchConditionParameters(destination *v20210601s.RequestUriMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestUriMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestUriMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.RequestUriMatchConditionParameters_STATUS
// Deprecated version of RequestUriMatchConditionParameters_STATUS. Use v1api20210601.RequestUriMatchConditionParameters_STATUS instead
type RequestUriMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RequestUriMatchConditionParameters_STATUS populates our RequestUriMatchConditionParameters_STATUS from the provided source RequestUriMatchConditionParameters_STATUS
func (parameters *RequestUriMatchConditionParameters_STATUS) AssignProperties_From_RequestUriMatchConditionParameters_STATUS(source *v20210601s.RequestUriMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestUriMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestUriMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RequestUriMatchConditionParameters_STATUS populates the provided destination RequestUriMatchConditionParameters_STATUS from our RequestUriMatchConditionParameters_STATUS
func (parameters *RequestUriMatchConditionParameters_STATUS) AssignProperties_To_RequestUriMatchConditionParameters_STATUS(destination *v20210601s.RequestUriMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRequestUriMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRequestUriMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.RouteConfigurationOverrideActionParameters
// Deprecated version of RouteConfigurationOverrideActionParameters. Use v1api20210601.RouteConfigurationOverrideActionParameters instead
type RouteConfigurationOverrideActionParameters struct {
	CacheConfiguration  *CacheConfiguration    `json:"cacheConfiguration,omitempty"`
	OriginGroupOverride *OriginGroupOverride   `json:"originGroupOverride,omitempty"`
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TypeName            *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_RouteConfigurationOverrideActionParameters populates our RouteConfigurationOverrideActionParameters from the provided source RouteConfigurationOverrideActionParameters
func (parameters *RouteConfigurationOverrideActionParameters) AssignProperties_From_RouteConfigurationOverrideActionParameters(source *v20210601s.RouteConfigurationOverrideActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheConfiguration
	if source.CacheConfiguration != nil {
		var cacheConfiguration CacheConfiguration
		err := cacheConfiguration.AssignProperties_From_CacheConfiguration(source.CacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheConfiguration() to populate field CacheConfiguration")
		}
		parameters.CacheConfiguration = &cacheConfiguration
	} else {
		parameters.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverride
		err := originGroupOverride.AssignProperties_From_OriginGroupOverride(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverride() to populate field OriginGroupOverride")
		}
		parameters.OriginGroupOverride = &originGroupOverride
	} else {
		parameters.OriginGroupOverride = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRouteConfigurationOverrideActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRouteConfigurationOverrideActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RouteConfigurationOverrideActionParameters populates the provided destination RouteConfigurationOverrideActionParameters from our RouteConfigurationOverrideActionParameters
func (parameters *RouteConfigurationOverrideActionParameters) AssignProperties_To_RouteConfigurationOverrideActionParameters(destination *v20210601s.RouteConfigurationOverrideActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CacheConfiguration
	if parameters.CacheConfiguration != nil {
		var cacheConfiguration v20210601s.CacheConfiguration
		err := parameters.CacheConfiguration.AssignProperties_To_CacheConfiguration(&cacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheConfiguration() to populate field CacheConfiguration")
		}
		destination.CacheConfiguration = &cacheConfiguration
	} else {
		destination.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if parameters.OriginGroupOverride != nil {
		var originGroupOverride v20210601s.OriginGroupOverride
		err := parameters.OriginGroupOverride.AssignProperties_To_OriginGroupOverride(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverride() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRouteConfigurationOverrideActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRouteConfigurationOverrideActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.RouteConfigurationOverrideActionParameters_STATUS
// Deprecated version of RouteConfigurationOverrideActionParameters_STATUS. Use v1api20210601.RouteConfigurationOverrideActionParameters_STATUS instead
type RouteConfigurationOverrideActionParameters_STATUS struct {
	CacheConfiguration  *CacheConfiguration_STATUS  `json:"cacheConfiguration,omitempty"`
	OriginGroupOverride *OriginGroupOverride_STATUS `json:"originGroupOverride,omitempty"`
	PropertyBag         genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	TypeName            *string                     `json:"typeName,omitempty"`
}

// AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS populates our RouteConfigurationOverrideActionParameters_STATUS from the provided source RouteConfigurationOverrideActionParameters_STATUS
func (parameters *RouteConfigurationOverrideActionParameters_STATUS) AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS(source *v20210601s.RouteConfigurationOverrideActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheConfiguration
	if source.CacheConfiguration != nil {
		var cacheConfiguration CacheConfiguration_STATUS
		err := cacheConfiguration.AssignProperties_From_CacheConfiguration_STATUS(source.CacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_CacheConfiguration_STATUS() to populate field CacheConfiguration")
		}
		parameters.CacheConfiguration = &cacheConfiguration
	} else {
		parameters.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if source.OriginGroupOverride != nil {
		var originGroupOverride OriginGroupOverride_STATUS
		err := originGroupOverride.AssignProperties_From_OriginGroupOverride_STATUS(source.OriginGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_OriginGroupOverride_STATUS() to populate field OriginGroupOverride")
		}
		parameters.OriginGroupOverride = &originGroupOverride
	} else {
		parameters.OriginGroupOverride = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForRouteConfigurationOverrideActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRouteConfigurationOverrideActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS populates the provided destination RouteConfigurationOverrideActionParameters_STATUS from our RouteConfigurationOverrideActionParameters_STATUS
func (parameters *RouteConfigurationOverrideActionParameters_STATUS) AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS(destination *v20210601s.RouteConfigurationOverrideActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CacheConfiguration
	if parameters.CacheConfiguration != nil {
		var cacheConfiguration v20210601s.CacheConfiguration_STATUS
		err := parameters.CacheConfiguration.AssignProperties_To_CacheConfiguration_STATUS(&cacheConfiguration)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_CacheConfiguration_STATUS() to populate field CacheConfiguration")
		}
		destination.CacheConfiguration = &cacheConfiguration
	} else {
		destination.CacheConfiguration = nil
	}

	// OriginGroupOverride
	if parameters.OriginGroupOverride != nil {
		var originGroupOverride v20210601s.OriginGroupOverride_STATUS
		err := parameters.OriginGroupOverride.AssignProperties_To_OriginGroupOverride_STATUS(&originGroupOverride)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_OriginGroupOverride_STATUS() to populate field OriginGroupOverride")
		}
		destination.OriginGroupOverride = &originGroupOverride
	} else {
		destination.OriginGroupOverride = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForRouteConfigurationOverrideActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForRouteConfigurationOverrideActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.ServerPortMatchConditionParameters
// Deprecated version of ServerPortMatchConditionParameters. Use v1api20210601.ServerPortMatchConditionParameters instead
type ServerPortMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_ServerPortMatchConditionParameters populates our ServerPortMatchConditionParameters from the provided source ServerPortMatchConditionParameters
func (parameters *ServerPortMatchConditionParameters) AssignProperties_From_ServerPortMatchConditionParameters(source *v20210601s.ServerPortMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForServerPortMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForServerPortMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPortMatchConditionParameters populates the provided destination ServerPortMatchConditionParameters from our ServerPortMatchConditionParameters
func (parameters *ServerPortMatchConditionParameters) AssignProperties_To_ServerPortMatchConditionParameters(destination *v20210601s.ServerPortMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForServerPortMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForServerPortMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.ServerPortMatchConditionParameters_STATUS
// Deprecated version of ServerPortMatchConditionParameters_STATUS. Use v1api20210601.ServerPortMatchConditionParameters_STATUS instead
type ServerPortMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_ServerPortMatchConditionParameters_STATUS populates our ServerPortMatchConditionParameters_STATUS from the provided source ServerPortMatchConditionParameters_STATUS
func (parameters *ServerPortMatchConditionParameters_STATUS) AssignProperties_From_ServerPortMatchConditionParameters_STATUS(source *v20210601s.ServerPortMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForServerPortMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForServerPortMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ServerPortMatchConditionParameters_STATUS populates the provided destination ServerPortMatchConditionParameters_STATUS from our ServerPortMatchConditionParameters_STATUS
func (parameters *ServerPortMatchConditionParameters_STATUS) AssignProperties_To_ServerPortMatchConditionParameters_STATUS(destination *v20210601s.ServerPortMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForServerPortMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForServerPortMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.SocketAddrMatchConditionParameters
// Deprecated version of SocketAddrMatchConditionParameters. Use v1api20210601.SocketAddrMatchConditionParameters instead
type SocketAddrMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_SocketAddrMatchConditionParameters populates our SocketAddrMatchConditionParameters from the provided source SocketAddrMatchConditionParameters
func (parameters *SocketAddrMatchConditionParameters) AssignProperties_From_SocketAddrMatchConditionParameters(source *v20210601s.SocketAddrMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForSocketAddrMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSocketAddrMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SocketAddrMatchConditionParameters populates the provided destination SocketAddrMatchConditionParameters from our SocketAddrMatchConditionParameters
func (parameters *SocketAddrMatchConditionParameters) AssignProperties_To_SocketAddrMatchConditionParameters(destination *v20210601s.SocketAddrMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSocketAddrMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSocketAddrMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.SocketAddrMatchConditionParameters_STATUS
// Deprecated version of SocketAddrMatchConditionParameters_STATUS. Use v1api20210601.SocketAddrMatchConditionParameters_STATUS instead
type SocketAddrMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_SocketAddrMatchConditionParameters_STATUS populates our SocketAddrMatchConditionParameters_STATUS from the provided source SocketAddrMatchConditionParameters_STATUS
func (parameters *SocketAddrMatchConditionParameters_STATUS) AssignProperties_From_SocketAddrMatchConditionParameters_STATUS(source *v20210601s.SocketAddrMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForSocketAddrMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSocketAddrMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SocketAddrMatchConditionParameters_STATUS populates the provided destination SocketAddrMatchConditionParameters_STATUS from our SocketAddrMatchConditionParameters_STATUS
func (parameters *SocketAddrMatchConditionParameters_STATUS) AssignProperties_To_SocketAddrMatchConditionParameters_STATUS(destination *v20210601s.SocketAddrMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSocketAddrMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSocketAddrMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.SslProtocolMatchConditionParameters
// Deprecated version of SslProtocolMatchConditionParameters. Use v1api20210601.SslProtocolMatchConditionParameters instead
type SslProtocolMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_SslProtocolMatchConditionParameters populates our SslProtocolMatchConditionParameters from the provided source SslProtocolMatchConditionParameters
func (parameters *SslProtocolMatchConditionParameters) AssignProperties_From_SslProtocolMatchConditionParameters(source *v20210601s.SslProtocolMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForSslProtocolMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSslProtocolMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SslProtocolMatchConditionParameters populates the provided destination SslProtocolMatchConditionParameters from our SslProtocolMatchConditionParameters
func (parameters *SslProtocolMatchConditionParameters) AssignProperties_To_SslProtocolMatchConditionParameters(destination *v20210601s.SslProtocolMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSslProtocolMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSslProtocolMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.SslProtocolMatchConditionParameters_STATUS
// Deprecated version of SslProtocolMatchConditionParameters_STATUS. Use v1api20210601.SslProtocolMatchConditionParameters_STATUS instead
type SslProtocolMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_SslProtocolMatchConditionParameters_STATUS populates our SslProtocolMatchConditionParameters_STATUS from the provided source SslProtocolMatchConditionParameters_STATUS
func (parameters *SslProtocolMatchConditionParameters_STATUS) AssignProperties_From_SslProtocolMatchConditionParameters_STATUS(source *v20210601s.SslProtocolMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForSslProtocolMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSslProtocolMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_SslProtocolMatchConditionParameters_STATUS populates the provided destination SslProtocolMatchConditionParameters_STATUS from our SslProtocolMatchConditionParameters_STATUS
func (parameters *SslProtocolMatchConditionParameters_STATUS) AssignProperties_To_SslProtocolMatchConditionParameters_STATUS(destination *v20210601s.SslProtocolMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForSslProtocolMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForSslProtocolMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlFileExtensionMatchConditionParameters
// Deprecated version of UrlFileExtensionMatchConditionParameters. Use v1api20210601.UrlFileExtensionMatchConditionParameters instead
type UrlFileExtensionMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlFileExtensionMatchConditionParameters populates our UrlFileExtensionMatchConditionParameters from the provided source UrlFileExtensionMatchConditionParameters
func (parameters *UrlFileExtensionMatchConditionParameters) AssignProperties_From_UrlFileExtensionMatchConditionParameters(source *v20210601s.UrlFileExtensionMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileExtensionMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileExtensionMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileExtensionMatchConditionParameters populates the provided destination UrlFileExtensionMatchConditionParameters from our UrlFileExtensionMatchConditionParameters
func (parameters *UrlFileExtensionMatchConditionParameters) AssignProperties_To_UrlFileExtensionMatchConditionParameters(destination *v20210601s.UrlFileExtensionMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileExtensionMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileExtensionMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlFileExtensionMatchConditionParameters_STATUS
// Deprecated version of UrlFileExtensionMatchConditionParameters_STATUS. Use v1api20210601.UrlFileExtensionMatchConditionParameters_STATUS instead
type UrlFileExtensionMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS populates our UrlFileExtensionMatchConditionParameters_STATUS from the provided source UrlFileExtensionMatchConditionParameters_STATUS
func (parameters *UrlFileExtensionMatchConditionParameters_STATUS) AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS(source *v20210601s.UrlFileExtensionMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileExtensionMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileExtensionMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS populates the provided destination UrlFileExtensionMatchConditionParameters_STATUS from our UrlFileExtensionMatchConditionParameters_STATUS
func (parameters *UrlFileExtensionMatchConditionParameters_STATUS) AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS(destination *v20210601s.UrlFileExtensionMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileExtensionMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileExtensionMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlFileNameMatchConditionParameters
// Deprecated version of UrlFileNameMatchConditionParameters. Use v1api20210601.UrlFileNameMatchConditionParameters instead
type UrlFileNameMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlFileNameMatchConditionParameters populates our UrlFileNameMatchConditionParameters from the provided source UrlFileNameMatchConditionParameters
func (parameters *UrlFileNameMatchConditionParameters) AssignProperties_From_UrlFileNameMatchConditionParameters(source *v20210601s.UrlFileNameMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileNameMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileNameMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileNameMatchConditionParameters populates the provided destination UrlFileNameMatchConditionParameters from our UrlFileNameMatchConditionParameters
func (parameters *UrlFileNameMatchConditionParameters) AssignProperties_To_UrlFileNameMatchConditionParameters(destination *v20210601s.UrlFileNameMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileNameMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileNameMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlFileNameMatchConditionParameters_STATUS
// Deprecated version of UrlFileNameMatchConditionParameters_STATUS. Use v1api20210601.UrlFileNameMatchConditionParameters_STATUS instead
type UrlFileNameMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS populates our UrlFileNameMatchConditionParameters_STATUS from the provided source UrlFileNameMatchConditionParameters_STATUS
func (parameters *UrlFileNameMatchConditionParameters_STATUS) AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS(source *v20210601s.UrlFileNameMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileNameMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileNameMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS populates the provided destination UrlFileNameMatchConditionParameters_STATUS from our UrlFileNameMatchConditionParameters_STATUS
func (parameters *UrlFileNameMatchConditionParameters_STATUS) AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS(destination *v20210601s.UrlFileNameMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlFileNameMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlFileNameMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlPathMatchConditionParameters
// Deprecated version of UrlPathMatchConditionParameters. Use v1api20210601.UrlPathMatchConditionParameters instead
type UrlPathMatchConditionParameters struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlPathMatchConditionParameters populates our UrlPathMatchConditionParameters from the provided source UrlPathMatchConditionParameters
func (parameters *UrlPathMatchConditionParameters) AssignProperties_From_UrlPathMatchConditionParameters(source *v20210601s.UrlPathMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlPathMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlPathMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlPathMatchConditionParameters populates the provided destination UrlPathMatchConditionParameters from our UrlPathMatchConditionParameters
func (parameters *UrlPathMatchConditionParameters) AssignProperties_To_UrlPathMatchConditionParameters(destination *v20210601s.UrlPathMatchConditionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlPathMatchConditionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlPathMatchConditionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlPathMatchConditionParameters_STATUS
// Deprecated version of UrlPathMatchConditionParameters_STATUS. Use v1api20210601.UrlPathMatchConditionParameters_STATUS instead
type UrlPathMatchConditionParameters_STATUS struct {
	MatchValues     []string               `json:"matchValues,omitempty"`
	NegateCondition *bool                  `json:"negateCondition,omitempty"`
	Operator        *string                `json:"operator,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Transforms      []string               `json:"transforms,omitempty"`
	TypeName        *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlPathMatchConditionParameters_STATUS populates our UrlPathMatchConditionParameters_STATUS from the provided source UrlPathMatchConditionParameters_STATUS
func (parameters *UrlPathMatchConditionParameters_STATUS) AssignProperties_From_UrlPathMatchConditionParameters_STATUS(source *v20210601s.UrlPathMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// MatchValues
	parameters.MatchValues = genruntime.CloneSliceOfString(source.MatchValues)

	// NegateCondition
	if source.NegateCondition != nil {
		negateCondition := *source.NegateCondition
		parameters.NegateCondition = &negateCondition
	} else {
		parameters.NegateCondition = nil
	}

	// Operator
	parameters.Operator = genruntime.ClonePointerToString(source.Operator)

	// Transforms
	parameters.Transforms = genruntime.CloneSliceOfString(source.Transforms)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlPathMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlPathMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlPathMatchConditionParameters_STATUS populates the provided destination UrlPathMatchConditionParameters_STATUS from our UrlPathMatchConditionParameters_STATUS
func (parameters *UrlPathMatchConditionParameters_STATUS) AssignProperties_To_UrlPathMatchConditionParameters_STATUS(destination *v20210601s.UrlPathMatchConditionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// MatchValues
	destination.MatchValues = genruntime.CloneSliceOfString(parameters.MatchValues)

	// NegateCondition
	if parameters.NegateCondition != nil {
		negateCondition := *parameters.NegateCondition
		destination.NegateCondition = &negateCondition
	} else {
		destination.NegateCondition = nil
	}

	// Operator
	destination.Operator = genruntime.ClonePointerToString(parameters.Operator)

	// Transforms
	destination.Transforms = genruntime.CloneSliceOfString(parameters.Transforms)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlPathMatchConditionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlPathMatchConditionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlRedirectActionParameters
// Deprecated version of UrlRedirectActionParameters. Use v1api20210601.UrlRedirectActionParameters instead
type UrlRedirectActionParameters struct {
	CustomFragment      *string                `json:"customFragment,omitempty"`
	CustomHostname      *string                `json:"customHostname,omitempty"`
	CustomPath          *string                `json:"customPath,omitempty"`
	CustomQueryString   *string                `json:"customQueryString,omitempty"`
	DestinationProtocol *string                `json:"destinationProtocol,omitempty"`
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RedirectType        *string                `json:"redirectType,omitempty"`
	TypeName            *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlRedirectActionParameters populates our UrlRedirectActionParameters from the provided source UrlRedirectActionParameters
func (parameters *UrlRedirectActionParameters) AssignProperties_From_UrlRedirectActionParameters(source *v20210601s.UrlRedirectActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CustomFragment
	parameters.CustomFragment = genruntime.ClonePointerToString(source.CustomFragment)

	// CustomHostname
	parameters.CustomHostname = genruntime.ClonePointerToString(source.CustomHostname)

	// CustomPath
	parameters.CustomPath = genruntime.ClonePointerToString(source.CustomPath)

	// CustomQueryString
	parameters.CustomQueryString = genruntime.ClonePointerToString(source.CustomQueryString)

	// DestinationProtocol
	parameters.DestinationProtocol = genruntime.ClonePointerToString(source.DestinationProtocol)

	// RedirectType
	parameters.RedirectType = genruntime.ClonePointerToString(source.RedirectType)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRedirectActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectActionParameters populates the provided destination UrlRedirectActionParameters from our UrlRedirectActionParameters
func (parameters *UrlRedirectActionParameters) AssignProperties_To_UrlRedirectActionParameters(destination *v20210601s.UrlRedirectActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CustomFragment
	destination.CustomFragment = genruntime.ClonePointerToString(parameters.CustomFragment)

	// CustomHostname
	destination.CustomHostname = genruntime.ClonePointerToString(parameters.CustomHostname)

	// CustomPath
	destination.CustomPath = genruntime.ClonePointerToString(parameters.CustomPath)

	// CustomQueryString
	destination.CustomQueryString = genruntime.ClonePointerToString(parameters.CustomQueryString)

	// DestinationProtocol
	destination.DestinationProtocol = genruntime.ClonePointerToString(parameters.DestinationProtocol)

	// RedirectType
	destination.RedirectType = genruntime.ClonePointerToString(parameters.RedirectType)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRedirectActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlRedirectActionParameters_STATUS
// Deprecated version of UrlRedirectActionParameters_STATUS. Use v1api20210601.UrlRedirectActionParameters_STATUS instead
type UrlRedirectActionParameters_STATUS struct {
	CustomFragment      *string                `json:"customFragment,omitempty"`
	CustomHostname      *string                `json:"customHostname,omitempty"`
	CustomPath          *string                `json:"customPath,omitempty"`
	CustomQueryString   *string                `json:"customQueryString,omitempty"`
	DestinationProtocol *string                `json:"destinationProtocol,omitempty"`
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RedirectType        *string                `json:"redirectType,omitempty"`
	TypeName            *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlRedirectActionParameters_STATUS populates our UrlRedirectActionParameters_STATUS from the provided source UrlRedirectActionParameters_STATUS
func (parameters *UrlRedirectActionParameters_STATUS) AssignProperties_From_UrlRedirectActionParameters_STATUS(source *v20210601s.UrlRedirectActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CustomFragment
	parameters.CustomFragment = genruntime.ClonePointerToString(source.CustomFragment)

	// CustomHostname
	parameters.CustomHostname = genruntime.ClonePointerToString(source.CustomHostname)

	// CustomPath
	parameters.CustomPath = genruntime.ClonePointerToString(source.CustomPath)

	// CustomQueryString
	parameters.CustomQueryString = genruntime.ClonePointerToString(source.CustomQueryString)

	// DestinationProtocol
	parameters.DestinationProtocol = genruntime.ClonePointerToString(source.DestinationProtocol)

	// RedirectType
	parameters.RedirectType = genruntime.ClonePointerToString(source.RedirectType)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRedirectActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRedirectActionParameters_STATUS populates the provided destination UrlRedirectActionParameters_STATUS from our UrlRedirectActionParameters_STATUS
func (parameters *UrlRedirectActionParameters_STATUS) AssignProperties_To_UrlRedirectActionParameters_STATUS(destination *v20210601s.UrlRedirectActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// CustomFragment
	destination.CustomFragment = genruntime.ClonePointerToString(parameters.CustomFragment)

	// CustomHostname
	destination.CustomHostname = genruntime.ClonePointerToString(parameters.CustomHostname)

	// CustomPath
	destination.CustomPath = genruntime.ClonePointerToString(parameters.CustomPath)

	// CustomQueryString
	destination.CustomQueryString = genruntime.ClonePointerToString(parameters.CustomQueryString)

	// DestinationProtocol
	destination.DestinationProtocol = genruntime.ClonePointerToString(parameters.DestinationProtocol)

	// RedirectType
	destination.RedirectType = genruntime.ClonePointerToString(parameters.RedirectType)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRedirectActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRedirectActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlRewriteActionParameters
// Deprecated version of UrlRewriteActionParameters. Use v1api20210601.UrlRewriteActionParameters instead
type UrlRewriteActionParameters struct {
	Destination           *string                `json:"destination,omitempty"`
	PreserveUnmatchedPath *bool                  `json:"preserveUnmatchedPath,omitempty"`
	PropertyBag           genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SourcePattern         *string                `json:"sourcePattern,omitempty"`
	TypeName              *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlRewriteActionParameters populates our UrlRewriteActionParameters from the provided source UrlRewriteActionParameters
func (parameters *UrlRewriteActionParameters) AssignProperties_From_UrlRewriteActionParameters(source *v20210601s.UrlRewriteActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Destination
	parameters.Destination = genruntime.ClonePointerToString(source.Destination)

	// PreserveUnmatchedPath
	if source.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *source.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		parameters.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	parameters.SourcePattern = genruntime.ClonePointerToString(source.SourcePattern)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRewriteActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteActionParameters populates the provided destination UrlRewriteActionParameters from our UrlRewriteActionParameters
func (parameters *UrlRewriteActionParameters) AssignProperties_To_UrlRewriteActionParameters(destination *v20210601s.UrlRewriteActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Destination
	destination.Destination = genruntime.ClonePointerToString(parameters.Destination)

	// PreserveUnmatchedPath
	if parameters.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *parameters.PreserveUnmatchedPath
		destination.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		destination.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	destination.SourcePattern = genruntime.ClonePointerToString(parameters.SourcePattern)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRewriteActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlRewriteActionParameters_STATUS
// Deprecated version of UrlRewriteActionParameters_STATUS. Use v1api20210601.UrlRewriteActionParameters_STATUS instead
type UrlRewriteActionParameters_STATUS struct {
	Destination           *string                `json:"destination,omitempty"`
	PreserveUnmatchedPath *bool                  `json:"preserveUnmatchedPath,omitempty"`
	PropertyBag           genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	SourcePattern         *string                `json:"sourcePattern,omitempty"`
	TypeName              *string                `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlRewriteActionParameters_STATUS populates our UrlRewriteActionParameters_STATUS from the provided source UrlRewriteActionParameters_STATUS
func (parameters *UrlRewriteActionParameters_STATUS) AssignProperties_From_UrlRewriteActionParameters_STATUS(source *v20210601s.UrlRewriteActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Destination
	parameters.Destination = genruntime.ClonePointerToString(source.Destination)

	// PreserveUnmatchedPath
	if source.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *source.PreserveUnmatchedPath
		parameters.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		parameters.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	parameters.SourcePattern = genruntime.ClonePointerToString(source.SourcePattern)

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRewriteActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlRewriteActionParameters_STATUS populates the provided destination UrlRewriteActionParameters_STATUS from our UrlRewriteActionParameters_STATUS
func (parameters *UrlRewriteActionParameters_STATUS) AssignProperties_To_UrlRewriteActionParameters_STATUS(destination *v20210601s.UrlRewriteActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Destination
	destination.Destination = genruntime.ClonePointerToString(parameters.Destination)

	// PreserveUnmatchedPath
	if parameters.PreserveUnmatchedPath != nil {
		preserveUnmatchedPath := *parameters.PreserveUnmatchedPath
		destination.PreserveUnmatchedPath = &preserveUnmatchedPath
	} else {
		destination.PreserveUnmatchedPath = nil
	}

	// SourcePattern
	destination.SourcePattern = genruntime.ClonePointerToString(parameters.SourcePattern)

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlRewriteActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlRewriteActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlSigningActionParameters
// Deprecated version of UrlSigningActionParameters. Use v1api20210601.UrlSigningActionParameters instead
type UrlSigningActionParameters struct {
	Algorithm             *string                     `json:"algorithm,omitempty"`
	ParameterNameOverride []UrlSigningParamIdentifier `json:"parameterNameOverride,omitempty"`
	PropertyBag           genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	TypeName              *string                     `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlSigningActionParameters populates our UrlSigningActionParameters from the provided source UrlSigningActionParameters
func (parameters *UrlSigningActionParameters) AssignProperties_From_UrlSigningActionParameters(source *v20210601s.UrlSigningActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Algorithm
	parameters.Algorithm = genruntime.ClonePointerToString(source.Algorithm)

	// ParameterNameOverride
	if source.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]UrlSigningParamIdentifier, len(source.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range source.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride UrlSigningParamIdentifier
			err := parameterNameOverride.AssignProperties_From_UrlSigningParamIdentifier(&parameterNameOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UrlSigningParamIdentifier() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		parameters.ParameterNameOverride = parameterNameOverrideList
	} else {
		parameters.ParameterNameOverride = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlSigningActionParameters); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningActionParameters populates the provided destination UrlSigningActionParameters from our UrlSigningActionParameters
func (parameters *UrlSigningActionParameters) AssignProperties_To_UrlSigningActionParameters(destination *v20210601s.UrlSigningActionParameters) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Algorithm
	destination.Algorithm = genruntime.ClonePointerToString(parameters.Algorithm)

	// ParameterNameOverride
	if parameters.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]v20210601s.UrlSigningParamIdentifier, len(parameters.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range parameters.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride v20210601s.UrlSigningParamIdentifier
			err := parameterNameOverrideItem.AssignProperties_To_UrlSigningParamIdentifier(&parameterNameOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UrlSigningParamIdentifier() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		destination.ParameterNameOverride = parameterNameOverrideList
	} else {
		destination.ParameterNameOverride = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningActionParameters interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlSigningActionParameters); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlSigningActionParameters_STATUS
// Deprecated version of UrlSigningActionParameters_STATUS. Use v1api20210601.UrlSigningActionParameters_STATUS instead
type UrlSigningActionParameters_STATUS struct {
	Algorithm             *string                            `json:"algorithm,omitempty"`
	ParameterNameOverride []UrlSigningParamIdentifier_STATUS `json:"parameterNameOverride,omitempty"`
	PropertyBag           genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	TypeName              *string                            `json:"typeName,omitempty"`
}

// AssignProperties_From_UrlSigningActionParameters_STATUS populates our UrlSigningActionParameters_STATUS from the provided source UrlSigningActionParameters_STATUS
func (parameters *UrlSigningActionParameters_STATUS) AssignProperties_From_UrlSigningActionParameters_STATUS(source *v20210601s.UrlSigningActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Algorithm
	parameters.Algorithm = genruntime.ClonePointerToString(source.Algorithm)

	// ParameterNameOverride
	if source.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]UrlSigningParamIdentifier_STATUS, len(source.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range source.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride UrlSigningParamIdentifier_STATUS
			err := parameterNameOverride.AssignProperties_From_UrlSigningParamIdentifier_STATUS(&parameterNameOverrideItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_UrlSigningParamIdentifier_STATUS() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		parameters.ParameterNameOverride = parameterNameOverrideList
	} else {
		parameters.ParameterNameOverride = nil
	}

	// TypeName
	parameters.TypeName = genruntime.ClonePointerToString(source.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		parameters.PropertyBag = propertyBag
	} else {
		parameters.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlSigningActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningActionParameters_STATUS populates the provided destination UrlSigningActionParameters_STATUS from our UrlSigningActionParameters_STATUS
func (parameters *UrlSigningActionParameters_STATUS) AssignProperties_To_UrlSigningActionParameters_STATUS(destination *v20210601s.UrlSigningActionParameters_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(parameters.PropertyBag)

	// Algorithm
	destination.Algorithm = genruntime.ClonePointerToString(parameters.Algorithm)

	// ParameterNameOverride
	if parameters.ParameterNameOverride != nil {
		parameterNameOverrideList := make([]v20210601s.UrlSigningParamIdentifier_STATUS, len(parameters.ParameterNameOverride))
		for parameterNameOverrideIndex, parameterNameOverrideItem := range parameters.ParameterNameOverride {
			// Shadow the loop variable to avoid aliasing
			parameterNameOverrideItem := parameterNameOverrideItem
			var parameterNameOverride v20210601s.UrlSigningParamIdentifier_STATUS
			err := parameterNameOverrideItem.AssignProperties_To_UrlSigningParamIdentifier_STATUS(&parameterNameOverride)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_UrlSigningParamIdentifier_STATUS() to populate field ParameterNameOverride")
			}
			parameterNameOverrideList[parameterNameOverrideIndex] = parameterNameOverride
		}
		destination.ParameterNameOverride = parameterNameOverrideList
	} else {
		destination.ParameterNameOverride = nil
	}

	// TypeName
	destination.TypeName = genruntime.ClonePointerToString(parameters.TypeName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningActionParameters_STATUS interface (if implemented) to customize the conversion
	var parametersAsAny any = parameters
	if augmentedParameters, ok := parametersAsAny.(augmentConversionForUrlSigningActionParameters_STATUS); ok {
		err := augmentedParameters.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForCacheExpirationActionParameters interface {
	AssignPropertiesFrom(src *v20210601s.CacheExpirationActionParameters) error
	AssignPropertiesTo(dst *v20210601s.CacheExpirationActionParameters) error
}

type augmentConversionForCacheExpirationActionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.CacheExpirationActionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.CacheExpirationActionParameters_STATUS) error
}

type augmentConversionForCacheKeyQueryStringActionParameters interface {
	AssignPropertiesFrom(src *v20210601s.CacheKeyQueryStringActionParameters) error
	AssignPropertiesTo(dst *v20210601s.CacheKeyQueryStringActionParameters) error
}

type augmentConversionForCacheKeyQueryStringActionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.CacheKeyQueryStringActionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.CacheKeyQueryStringActionParameters_STATUS) error
}

type augmentConversionForClientPortMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.ClientPortMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.ClientPortMatchConditionParameters) error
}

type augmentConversionForClientPortMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.ClientPortMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.ClientPortMatchConditionParameters_STATUS) error
}

type augmentConversionForCookiesMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.CookiesMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.CookiesMatchConditionParameters) error
}

type augmentConversionForCookiesMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.CookiesMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.CookiesMatchConditionParameters_STATUS) error
}

type augmentConversionForHeaderActionParameters interface {
	AssignPropertiesFrom(src *v20210601s.HeaderActionParameters) error
	AssignPropertiesTo(dst *v20210601s.HeaderActionParameters) error
}

type augmentConversionForHeaderActionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.HeaderActionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.HeaderActionParameters_STATUS) error
}

type augmentConversionForHostNameMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.HostNameMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.HostNameMatchConditionParameters) error
}

type augmentConversionForHostNameMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.HostNameMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.HostNameMatchConditionParameters_STATUS) error
}

type augmentConversionForHttpVersionMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.HttpVersionMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.HttpVersionMatchConditionParameters) error
}

type augmentConversionForHttpVersionMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.HttpVersionMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.HttpVersionMatchConditionParameters_STATUS) error
}

type augmentConversionForIsDeviceMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.IsDeviceMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.IsDeviceMatchConditionParameters) error
}

type augmentConversionForIsDeviceMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.IsDeviceMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.IsDeviceMatchConditionParameters_STATUS) error
}

type augmentConversionForOriginGroupOverrideActionParameters interface {
	AssignPropertiesFrom(src *v20210601s.OriginGroupOverrideActionParameters) error
	AssignPropertiesTo(dst *v20210601s.OriginGroupOverrideActionParameters) error
}

type augmentConversionForOriginGroupOverrideActionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.OriginGroupOverrideActionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.OriginGroupOverrideActionParameters_STATUS) error
}

type augmentConversionForPostArgsMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.PostArgsMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.PostArgsMatchConditionParameters) error
}

type augmentConversionForPostArgsMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.PostArgsMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.PostArgsMatchConditionParameters_STATUS) error
}

type augmentConversionForQueryStringMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.QueryStringMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.QueryStringMatchConditionParameters) error
}

type augmentConversionForQueryStringMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.QueryStringMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.QueryStringMatchConditionParameters_STATUS) error
}

type augmentConversionForRemoteAddressMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.RemoteAddressMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.RemoteAddressMatchConditionParameters) error
}

type augmentConversionForRemoteAddressMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.RemoteAddressMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.RemoteAddressMatchConditionParameters_STATUS) error
}

type augmentConversionForRequestBodyMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.RequestBodyMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.RequestBodyMatchConditionParameters) error
}

type augmentConversionForRequestBodyMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.RequestBodyMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.RequestBodyMatchConditionParameters_STATUS) error
}

type augmentConversionForRequestHeaderMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.RequestHeaderMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.RequestHeaderMatchConditionParameters) error
}

type augmentConversionForRequestHeaderMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.RequestHeaderMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.RequestHeaderMatchConditionParameters_STATUS) error
}

type augmentConversionForRequestMethodMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.RequestMethodMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.RequestMethodMatchConditionParameters) error
}

type augmentConversionForRequestMethodMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.RequestMethodMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.RequestMethodMatchConditionParameters_STATUS) error
}

type augmentConversionForRequestSchemeMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.RequestSchemeMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.RequestSchemeMatchConditionParameters) error
}

type augmentConversionForRequestSchemeMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.RequestSchemeMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.RequestSchemeMatchConditionParameters_STATUS) error
}

type augmentConversionForRequestUriMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.RequestUriMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.RequestUriMatchConditionParameters) error
}

type augmentConversionForRequestUriMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.RequestUriMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.RequestUriMatchConditionParameters_STATUS) error
}

type augmentConversionForRouteConfigurationOverrideActionParameters interface {
	AssignPropertiesFrom(src *v20210601s.RouteConfigurationOverrideActionParameters) error
	AssignPropertiesTo(dst *v20210601s.RouteConfigurationOverrideActionParameters) error
}

type augmentConversionForRouteConfigurationOverrideActionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.RouteConfigurationOverrideActionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.RouteConfigurationOverrideActionParameters_STATUS) error
}

type augmentConversionForServerPortMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.ServerPortMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.ServerPortMatchConditionParameters) error
}

type augmentConversionForServerPortMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.ServerPortMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.ServerPortMatchConditionParameters_STATUS) error
}

type augmentConversionForSocketAddrMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.SocketAddrMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.SocketAddrMatchConditionParameters) error
}

type augmentConversionForSocketAddrMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.SocketAddrMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.SocketAddrMatchConditionParameters_STATUS) error
}

type augmentConversionForSslProtocolMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.SslProtocolMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.SslProtocolMatchConditionParameters) error
}

type augmentConversionForSslProtocolMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.SslProtocolMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.SslProtocolMatchConditionParameters_STATUS) error
}

type augmentConversionForUrlFileExtensionMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.UrlFileExtensionMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.UrlFileExtensionMatchConditionParameters) error
}

type augmentConversionForUrlFileExtensionMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.UrlFileExtensionMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.UrlFileExtensionMatchConditionParameters_STATUS) error
}

type augmentConversionForUrlFileNameMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.UrlFileNameMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.UrlFileNameMatchConditionParameters) error
}

type augmentConversionForUrlFileNameMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.UrlFileNameMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.UrlFileNameMatchConditionParameters_STATUS) error
}

type augmentConversionForUrlPathMatchConditionParameters interface {
	AssignPropertiesFrom(src *v20210601s.UrlPathMatchConditionParameters) error
	AssignPropertiesTo(dst *v20210601s.UrlPathMatchConditionParameters) error
}

type augmentConversionForUrlPathMatchConditionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.UrlPathMatchConditionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.UrlPathMatchConditionParameters_STATUS) error
}

type augmentConversionForUrlRedirectActionParameters interface {
	AssignPropertiesFrom(src *v20210601s.UrlRedirectActionParameters) error
	AssignPropertiesTo(dst *v20210601s.UrlRedirectActionParameters) error
}

type augmentConversionForUrlRedirectActionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.UrlRedirectActionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.UrlRedirectActionParameters_STATUS) error
}

type augmentConversionForUrlRewriteActionParameters interface {
	AssignPropertiesFrom(src *v20210601s.UrlRewriteActionParameters) error
	AssignPropertiesTo(dst *v20210601s.UrlRewriteActionParameters) error
}

type augmentConversionForUrlRewriteActionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.UrlRewriteActionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.UrlRewriteActionParameters_STATUS) error
}

type augmentConversionForUrlSigningActionParameters interface {
	AssignPropertiesFrom(src *v20210601s.UrlSigningActionParameters) error
	AssignPropertiesTo(dst *v20210601s.UrlSigningActionParameters) error
}

type augmentConversionForUrlSigningActionParameters_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.UrlSigningActionParameters_STATUS) error
	AssignPropertiesTo(dst *v20210601s.UrlSigningActionParameters_STATUS) error
}

// Storage version of v1beta20210601.CacheConfiguration
// Deprecated version of CacheConfiguration. Use v1api20210601.CacheConfiguration instead
type CacheConfiguration struct {
	CacheBehavior              *string                `json:"cacheBehavior,omitempty"`
	CacheDuration              *string                `json:"cacheDuration,omitempty"`
	IsCompressionEnabled       *string                `json:"isCompressionEnabled,omitempty"`
	PropertyBag                genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	QueryParameters            *string                `json:"queryParameters,omitempty"`
	QueryStringCachingBehavior *string                `json:"queryStringCachingBehavior,omitempty"`
}

// AssignProperties_From_CacheConfiguration populates our CacheConfiguration from the provided source CacheConfiguration
func (configuration *CacheConfiguration) AssignProperties_From_CacheConfiguration(source *v20210601s.CacheConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheBehavior
	configuration.CacheBehavior = genruntime.ClonePointerToString(source.CacheBehavior)

	// CacheDuration
	configuration.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// IsCompressionEnabled
	configuration.IsCompressionEnabled = genruntime.ClonePointerToString(source.IsCompressionEnabled)

	// QueryParameters
	configuration.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringCachingBehavior
	configuration.QueryStringCachingBehavior = genruntime.ClonePointerToString(source.QueryStringCachingBehavior)

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForCacheConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CacheConfiguration populates the provided destination CacheConfiguration from our CacheConfiguration
func (configuration *CacheConfiguration) AssignProperties_To_CacheConfiguration(destination *v20210601s.CacheConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// CacheBehavior
	destination.CacheBehavior = genruntime.ClonePointerToString(configuration.CacheBehavior)

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(configuration.CacheDuration)

	// IsCompressionEnabled
	destination.IsCompressionEnabled = genruntime.ClonePointerToString(configuration.IsCompressionEnabled)

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(configuration.QueryParameters)

	// QueryStringCachingBehavior
	destination.QueryStringCachingBehavior = genruntime.ClonePointerToString(configuration.QueryStringCachingBehavior)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheConfiguration interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForCacheConfiguration); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.CacheConfiguration_STATUS
// Deprecated version of CacheConfiguration_STATUS. Use v1api20210601.CacheConfiguration_STATUS instead
type CacheConfiguration_STATUS struct {
	CacheBehavior              *string                `json:"cacheBehavior,omitempty"`
	CacheDuration              *string                `json:"cacheDuration,omitempty"`
	IsCompressionEnabled       *string                `json:"isCompressionEnabled,omitempty"`
	PropertyBag                genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	QueryParameters            *string                `json:"queryParameters,omitempty"`
	QueryStringCachingBehavior *string                `json:"queryStringCachingBehavior,omitempty"`
}

// AssignProperties_From_CacheConfiguration_STATUS populates our CacheConfiguration_STATUS from the provided source CacheConfiguration_STATUS
func (configuration *CacheConfiguration_STATUS) AssignProperties_From_CacheConfiguration_STATUS(source *v20210601s.CacheConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// CacheBehavior
	configuration.CacheBehavior = genruntime.ClonePointerToString(source.CacheBehavior)

	// CacheDuration
	configuration.CacheDuration = genruntime.ClonePointerToString(source.CacheDuration)

	// IsCompressionEnabled
	configuration.IsCompressionEnabled = genruntime.ClonePointerToString(source.IsCompressionEnabled)

	// QueryParameters
	configuration.QueryParameters = genruntime.ClonePointerToString(source.QueryParameters)

	// QueryStringCachingBehavior
	configuration.QueryStringCachingBehavior = genruntime.ClonePointerToString(source.QueryStringCachingBehavior)

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForCacheConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_CacheConfiguration_STATUS populates the provided destination CacheConfiguration_STATUS from our CacheConfiguration_STATUS
func (configuration *CacheConfiguration_STATUS) AssignProperties_To_CacheConfiguration_STATUS(destination *v20210601s.CacheConfiguration_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// CacheBehavior
	destination.CacheBehavior = genruntime.ClonePointerToString(configuration.CacheBehavior)

	// CacheDuration
	destination.CacheDuration = genruntime.ClonePointerToString(configuration.CacheDuration)

	// IsCompressionEnabled
	destination.IsCompressionEnabled = genruntime.ClonePointerToString(configuration.IsCompressionEnabled)

	// QueryParameters
	destination.QueryParameters = genruntime.ClonePointerToString(configuration.QueryParameters)

	// QueryStringCachingBehavior
	destination.QueryStringCachingBehavior = genruntime.ClonePointerToString(configuration.QueryStringCachingBehavior)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForCacheConfiguration_STATUS interface (if implemented) to customize the conversion
	var configurationAsAny any = configuration
	if augmentedConfiguration, ok := configurationAsAny.(augmentConversionForCacheConfiguration_STATUS); ok {
		err := augmentedConfiguration.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.OriginGroupOverride
// Deprecated version of OriginGroupOverride. Use v1api20210601.OriginGroupOverride instead
type OriginGroupOverride struct {
	ForwardingProtocol *string                `json:"forwardingProtocol,omitempty"`
	OriginGroup        *ResourceReference     `json:"originGroup,omitempty"`
	PropertyBag        genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_OriginGroupOverride populates our OriginGroupOverride from the provided source OriginGroupOverride
func (override *OriginGroupOverride) AssignProperties_From_OriginGroupOverride(source *v20210601s.OriginGroupOverride) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ForwardingProtocol
	override.ForwardingProtocol = genruntime.ClonePointerToString(source.ForwardingProtocol)

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference
		err := originGroup.AssignProperties_From_ResourceReference(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field OriginGroup")
		}
		override.OriginGroup = &originGroup
	} else {
		override.OriginGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		override.PropertyBag = propertyBag
	} else {
		override.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverride interface (if implemented) to customize the conversion
	var overrideAsAny any = override
	if augmentedOverride, ok := overrideAsAny.(augmentConversionForOriginGroupOverride); ok {
		err := augmentedOverride.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverride populates the provided destination OriginGroupOverride from our OriginGroupOverride
func (override *OriginGroupOverride) AssignProperties_To_OriginGroupOverride(destination *v20210601s.OriginGroupOverride) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(override.PropertyBag)

	// ForwardingProtocol
	destination.ForwardingProtocol = genruntime.ClonePointerToString(override.ForwardingProtocol)

	// OriginGroup
	if override.OriginGroup != nil {
		var originGroup v20210601s.ResourceReference
		err := override.OriginGroup.AssignProperties_To_ResourceReference(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverride interface (if implemented) to customize the conversion
	var overrideAsAny any = override
	if augmentedOverride, ok := overrideAsAny.(augmentConversionForOriginGroupOverride); ok {
		err := augmentedOverride.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.OriginGroupOverride_STATUS
// Deprecated version of OriginGroupOverride_STATUS. Use v1api20210601.OriginGroupOverride_STATUS instead
type OriginGroupOverride_STATUS struct {
	ForwardingProtocol *string                   `json:"forwardingProtocol,omitempty"`
	OriginGroup        *ResourceReference_STATUS `json:"originGroup,omitempty"`
	PropertyBag        genruntime.PropertyBag    `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_OriginGroupOverride_STATUS populates our OriginGroupOverride_STATUS from the provided source OriginGroupOverride_STATUS
func (override *OriginGroupOverride_STATUS) AssignProperties_From_OriginGroupOverride_STATUS(source *v20210601s.OriginGroupOverride_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ForwardingProtocol
	override.ForwardingProtocol = genruntime.ClonePointerToString(source.ForwardingProtocol)

	// OriginGroup
	if source.OriginGroup != nil {
		var originGroup ResourceReference_STATUS
		err := originGroup.AssignProperties_From_ResourceReference_STATUS(source.OriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field OriginGroup")
		}
		override.OriginGroup = &originGroup
	} else {
		override.OriginGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		override.PropertyBag = propertyBag
	} else {
		override.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverride_STATUS interface (if implemented) to customize the conversion
	var overrideAsAny any = override
	if augmentedOverride, ok := overrideAsAny.(augmentConversionForOriginGroupOverride_STATUS); ok {
		err := augmentedOverride.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_OriginGroupOverride_STATUS populates the provided destination OriginGroupOverride_STATUS from our OriginGroupOverride_STATUS
func (override *OriginGroupOverride_STATUS) AssignProperties_To_OriginGroupOverride_STATUS(destination *v20210601s.OriginGroupOverride_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(override.PropertyBag)

	// ForwardingProtocol
	destination.ForwardingProtocol = genruntime.ClonePointerToString(override.ForwardingProtocol)

	// OriginGroup
	if override.OriginGroup != nil {
		var originGroup v20210601s.ResourceReference_STATUS
		err := override.OriginGroup.AssignProperties_To_ResourceReference_STATUS(&originGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field OriginGroup")
		}
		destination.OriginGroup = &originGroup
	} else {
		destination.OriginGroup = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForOriginGroupOverride_STATUS interface (if implemented) to customize the conversion
	var overrideAsAny any = override
	if augmentedOverride, ok := overrideAsAny.(augmentConversionForOriginGroupOverride_STATUS); ok {
		err := augmentedOverride.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlSigningParamIdentifier
// Deprecated version of UrlSigningParamIdentifier. Use v1api20210601.UrlSigningParamIdentifier instead
type UrlSigningParamIdentifier struct {
	ParamIndicator *string                `json:"paramIndicator,omitempty"`
	ParamName      *string                `json:"paramName,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlSigningParamIdentifier populates our UrlSigningParamIdentifier from the provided source UrlSigningParamIdentifier
func (identifier *UrlSigningParamIdentifier) AssignProperties_From_UrlSigningParamIdentifier(source *v20210601s.UrlSigningParamIdentifier) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ParamIndicator
	identifier.ParamIndicator = genruntime.ClonePointerToString(source.ParamIndicator)

	// ParamName
	identifier.ParamName = genruntime.ClonePointerToString(source.ParamName)

	// Update the property bag
	if len(propertyBag) > 0 {
		identifier.PropertyBag = propertyBag
	} else {
		identifier.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningParamIdentifier interface (if implemented) to customize the conversion
	var identifierAsAny any = identifier
	if augmentedIdentifier, ok := identifierAsAny.(augmentConversionForUrlSigningParamIdentifier); ok {
		err := augmentedIdentifier.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningParamIdentifier populates the provided destination UrlSigningParamIdentifier from our UrlSigningParamIdentifier
func (identifier *UrlSigningParamIdentifier) AssignProperties_To_UrlSigningParamIdentifier(destination *v20210601s.UrlSigningParamIdentifier) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identifier.PropertyBag)

	// ParamIndicator
	destination.ParamIndicator = genruntime.ClonePointerToString(identifier.ParamIndicator)

	// ParamName
	destination.ParamName = genruntime.ClonePointerToString(identifier.ParamName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningParamIdentifier interface (if implemented) to customize the conversion
	var identifierAsAny any = identifier
	if augmentedIdentifier, ok := identifierAsAny.(augmentConversionForUrlSigningParamIdentifier); ok {
		err := augmentedIdentifier.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1beta20210601.UrlSigningParamIdentifier_STATUS
// Deprecated version of UrlSigningParamIdentifier_STATUS. Use v1api20210601.UrlSigningParamIdentifier_STATUS instead
type UrlSigningParamIdentifier_STATUS struct {
	ParamIndicator *string                `json:"paramIndicator,omitempty"`
	ParamName      *string                `json:"paramName,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_UrlSigningParamIdentifier_STATUS populates our UrlSigningParamIdentifier_STATUS from the provided source UrlSigningParamIdentifier_STATUS
func (identifier *UrlSigningParamIdentifier_STATUS) AssignProperties_From_UrlSigningParamIdentifier_STATUS(source *v20210601s.UrlSigningParamIdentifier_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ParamIndicator
	identifier.ParamIndicator = genruntime.ClonePointerToString(source.ParamIndicator)

	// ParamName
	identifier.ParamName = genruntime.ClonePointerToString(source.ParamName)

	// Update the property bag
	if len(propertyBag) > 0 {
		identifier.PropertyBag = propertyBag
	} else {
		identifier.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningParamIdentifier_STATUS interface (if implemented) to customize the conversion
	var identifierAsAny any = identifier
	if augmentedIdentifier, ok := identifierAsAny.(augmentConversionForUrlSigningParamIdentifier_STATUS); ok {
		err := augmentedIdentifier.AssignPropertiesFrom(source)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_UrlSigningParamIdentifier_STATUS populates the provided destination UrlSigningParamIdentifier_STATUS from our UrlSigningParamIdentifier_STATUS
func (identifier *UrlSigningParamIdentifier_STATUS) AssignProperties_To_UrlSigningParamIdentifier_STATUS(destination *v20210601s.UrlSigningParamIdentifier_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identifier.PropertyBag)

	// ParamIndicator
	destination.ParamIndicator = genruntime.ClonePointerToString(identifier.ParamIndicator)

	// ParamName
	destination.ParamName = genruntime.ClonePointerToString(identifier.ParamName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForUrlSigningParamIdentifier_STATUS interface (if implemented) to customize the conversion
	var identifierAsAny any = identifier
	if augmentedIdentifier, ok := identifierAsAny.(augmentConversionForUrlSigningParamIdentifier_STATUS); ok {
		err := augmentedIdentifier.AssignPropertiesTo(destination)
		if err != nil {
			return errors.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

type augmentConversionForCacheConfiguration interface {
	AssignPropertiesFrom(src *v20210601s.CacheConfiguration) error
	AssignPropertiesTo(dst *v20210601s.CacheConfiguration) error
}

type augmentConversionForCacheConfiguration_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.CacheConfiguration_STATUS) error
	AssignPropertiesTo(dst *v20210601s.CacheConfiguration_STATUS) error
}

type augmentConversionForOriginGroupOverride interface {
	AssignPropertiesFrom(src *v20210601s.OriginGroupOverride) error
	AssignPropertiesTo(dst *v20210601s.OriginGroupOverride) error
}

type augmentConversionForOriginGroupOverride_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.OriginGroupOverride_STATUS) error
	AssignPropertiesTo(dst *v20210601s.OriginGroupOverride_STATUS) error
}

type augmentConversionForUrlSigningParamIdentifier interface {
	AssignPropertiesFrom(src *v20210601s.UrlSigningParamIdentifier) error
	AssignPropertiesTo(dst *v20210601s.UrlSigningParamIdentifier) error
}

type augmentConversionForUrlSigningParamIdentifier_STATUS interface {
	AssignPropertiesFrom(src *v20210601s.UrlSigningParamIdentifier_STATUS) error
	AssignPropertiesTo(dst *v20210601s.UrlSigningParamIdentifier_STATUS) error
}

func init() {
	SchemeBuilder.Register(&ProfilesEndpoint{}, &ProfilesEndpointList{})
}
