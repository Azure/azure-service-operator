// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210601

import (
	"fmt"
	v20210601s "github.com/Azure/azure-service-operator/v2/api/cdn/v1beta20210601storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /cdn/resource-manager/Microsoft.Cdn/stable/2021-06-01/cdn.json
type ProfilesEndpoint struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ProfilesEndpoint_Spec `json:"spec,omitempty"`
	Status            Endpoint_STATUS       `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ProfilesEndpoint{}

// GetConditions returns the conditions of the resource
func (endpoint *ProfilesEndpoint) GetConditions() conditions.Conditions {
	return endpoint.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (endpoint *ProfilesEndpoint) SetConditions(conditions conditions.Conditions) {
	endpoint.Status.Conditions = conditions
}

var _ conversion.Convertible = &ProfilesEndpoint{}

// ConvertFrom populates our ProfilesEndpoint from the provided hub ProfilesEndpoint
func (endpoint *ProfilesEndpoint) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20210601s.ProfilesEndpoint)
	if !ok {
		return fmt.Errorf("expected cdn/v1beta20210601storage/ProfilesEndpoint but received %T instead", hub)
	}

	return endpoint.AssignPropertiesFromProfilesEndpoint(source)
}

// ConvertTo populates the provided hub ProfilesEndpoint from our ProfilesEndpoint
func (endpoint *ProfilesEndpoint) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20210601s.ProfilesEndpoint)
	if !ok {
		return fmt.Errorf("expected cdn/v1beta20210601storage/ProfilesEndpoint but received %T instead", hub)
	}

	return endpoint.AssignPropertiesToProfilesEndpoint(destination)
}

// +kubebuilder:webhook:path=/mutate-cdn-azure-com-v1beta20210601-profilesendpoint,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=cdn.azure.com,resources=profilesendpoints,verbs=create;update,versions=v1beta20210601,name=default.v1beta20210601.profilesendpoints.cdn.azure.com,admissionReviewVersions=v1beta1

var _ admission.Defaulter = &ProfilesEndpoint{}

// Default applies defaults to the ProfilesEndpoint resource
func (endpoint *ProfilesEndpoint) Default() {
	endpoint.defaultImpl()
	var temp interface{} = endpoint
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (endpoint *ProfilesEndpoint) defaultAzureName() {
	if endpoint.Spec.AzureName == "" {
		endpoint.Spec.AzureName = endpoint.Name
	}
}

// defaultImpl applies the code generated defaults to the ProfilesEndpoint resource
func (endpoint *ProfilesEndpoint) defaultImpl() { endpoint.defaultAzureName() }

var _ genruntime.KubernetesResource = &ProfilesEndpoint{}

// AzureName returns the Azure name of the resource
func (endpoint *ProfilesEndpoint) AzureName() string {
	return endpoint.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "20210601"
func (endpoint ProfilesEndpoint) GetAPIVersion() string {
	return string(APIVersionValue)
}

// GetResourceKind returns the kind of the resource
func (endpoint *ProfilesEndpoint) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (endpoint *ProfilesEndpoint) GetSpec() genruntime.ConvertibleSpec {
	return &endpoint.Spec
}

// GetStatus returns the status of this resource
func (endpoint *ProfilesEndpoint) GetStatus() genruntime.ConvertibleStatus {
	return &endpoint.Status
}

// GetType returns the ARM Type of the resource. This is always ""
func (endpoint *ProfilesEndpoint) GetType() string {
	return ""
}

// NewEmptyStatus returns a new empty (blank) status
func (endpoint *ProfilesEndpoint) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Endpoint_STATUS{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (endpoint *ProfilesEndpoint) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(endpoint.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  endpoint.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (endpoint *ProfilesEndpoint) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Endpoint_STATUS); ok {
		endpoint.Status = *st
		return nil
	}

	// Convert status to required version
	var st Endpoint_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	endpoint.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-cdn-azure-com-v1beta20210601-profilesendpoint,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=cdn.azure.com,resources=profilesendpoints,verbs=create;update,versions=v1beta20210601,name=validate.v1beta20210601.profilesendpoints.cdn.azure.com,admissionReviewVersions=v1beta1

var _ admission.Validator = &ProfilesEndpoint{}

// ValidateCreate validates the creation of the resource
func (endpoint *ProfilesEndpoint) ValidateCreate() error {
	validations := endpoint.createValidations()
	var temp interface{} = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (endpoint *ProfilesEndpoint) ValidateDelete() error {
	validations := endpoint.deleteValidations()
	var temp interface{} = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (endpoint *ProfilesEndpoint) ValidateUpdate(old runtime.Object) error {
	validations := endpoint.updateValidations()
	var temp interface{} = endpoint
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (endpoint *ProfilesEndpoint) createValidations() []func() error {
	return []func() error{endpoint.validateResourceReferences}
}

// deleteValidations validates the deletion of the resource
func (endpoint *ProfilesEndpoint) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (endpoint *ProfilesEndpoint) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return endpoint.validateResourceReferences()
		},
		endpoint.validateWriteOnceProperties}
}

// validateResourceReferences validates all resource references
func (endpoint *ProfilesEndpoint) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&endpoint.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (endpoint *ProfilesEndpoint) validateWriteOnceProperties(old runtime.Object) error {
	oldObj, ok := old.(*ProfilesEndpoint)
	if !ok {
		return nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, endpoint)
}

// AssignPropertiesFromProfilesEndpoint populates our ProfilesEndpoint from the provided source ProfilesEndpoint
func (endpoint *ProfilesEndpoint) AssignPropertiesFromProfilesEndpoint(source *v20210601s.ProfilesEndpoint) error {

	// ObjectMeta
	endpoint.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec ProfilesEndpoint_Spec
	err := spec.AssignPropertiesFromProfilesEndpoint_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromProfilesEndpoint_Spec() to populate field Spec")
	}
	endpoint.Spec = spec

	// Status
	var status Endpoint_STATUS
	err = status.AssignPropertiesFromEndpoint_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromEndpoint_STATUS() to populate field Status")
	}
	endpoint.Status = status

	// No error
	return nil
}

// AssignPropertiesToProfilesEndpoint populates the provided destination ProfilesEndpoint from our ProfilesEndpoint
func (endpoint *ProfilesEndpoint) AssignPropertiesToProfilesEndpoint(destination *v20210601s.ProfilesEndpoint) error {

	// ObjectMeta
	destination.ObjectMeta = *endpoint.ObjectMeta.DeepCopy()

	// Spec
	var spec v20210601s.ProfilesEndpoint_Spec
	err := endpoint.Spec.AssignPropertiesToProfilesEndpoint_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToProfilesEndpoint_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20210601s.Endpoint_STATUS
	err = endpoint.Status.AssignPropertiesToEndpoint_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToEndpoint_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (endpoint *ProfilesEndpoint) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: endpoint.Spec.OriginalVersion(),
		Kind:    "ProfilesEndpoint",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /cdn/resource-manager/Microsoft.Cdn/stable/2021-06-01/cdn.json
type ProfilesEndpointList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ProfilesEndpoint `json:"items"`
}

type Endpoint_STATUS struct {
	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// ContentTypesToCompress: List of content types on which compression applies. The value should be a valid MIME type.
	ContentTypesToCompress []string `json:"contentTypesToCompress,omitempty"`

	// CustomDomains: The custom domains under the endpoint.
	CustomDomains []CustomDomain_STATUS `json:"customDomains,omitempty"`

	// DefaultOriginGroup: A reference to the origin group.
	DefaultOriginGroup *ResourceReference_STATUS `json:"defaultOriginGroup,omitempty"`

	// DeliveryPolicy: A policy that specifies the delivery rules to be used for an endpoint.
	DeliveryPolicy *EndpointProperties_DeliveryPolicy_STATUS `json:"deliveryPolicy,omitempty"`

	// GeoFilters: List of rules defining the user's geo access within a CDN endpoint. Each geo filter defines an access rule
	// to a specified path or content, e.g. block APAC for path /pictures/
	GeoFilters []GeoFilter_STATUS `json:"geoFilters,omitempty"`

	// HostName: The host name of the endpoint structured as {endpointName}.{DNSZone}, e.g. contoso.azureedge.net
	HostName *string `json:"hostName,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// IsCompressionEnabled: Indicates whether content compression is enabled on CDN. Default value is false. If compression is
	// enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on
	// CDN when requested content is smaller than 1 byte or larger than 1 MB.
	IsCompressionEnabled *bool `json:"isCompressionEnabled,omitempty"`

	// IsHttpAllowed: Indicates whether HTTP traffic is allowed on the endpoint. Default value is true. At least one protocol
	// (HTTP or HTTPS) must be allowed.
	IsHttpAllowed *bool `json:"isHttpAllowed,omitempty"`

	// IsHttpsAllowed: Indicates whether HTTPS traffic is allowed on the endpoint. Default value is true. At least one protocol
	// (HTTP or HTTPS) must be allowed.
	IsHttpsAllowed *bool `json:"isHttpsAllowed,omitempty"`

	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// OptimizationType: Specifies what scenario the customer wants this CDN endpoint to optimize for, e.g. Download, Media
	// services. With this information, CDN can apply scenario driven optimization.
	OptimizationType *OptimizationType_STATUS `json:"optimizationType,omitempty"`

	// OriginGroups: The origin groups comprising of origins that are used for load balancing the traffic based on availability.
	OriginGroups []DeepCreatedOriginGroup_STATUS `json:"originGroups,omitempty"`

	// OriginHostHeader: The host header value sent to the origin with each request. This property at Endpoint is only allowed
	// when endpoint uses single origin and can be overridden by the same property specified at origin.If you leave this blank,
	// the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services
	// require this host header value to match the origin hostname by default.
	OriginHostHeader *string `json:"originHostHeader,omitempty"`

	// OriginPath: A directory path on the origin that CDN can use to retrieve content from, e.g.
	// contoso.cloudapp.net/originpath.
	OriginPath *string `json:"originPath,omitempty"`

	// Origins: The source of the content being delivered via CDN.
	Origins []DeepCreatedOrigin_STATUS `json:"origins,omitempty"`

	// ProbePath: Path to a file hosted on the origin which helps accelerate delivery of the dynamic content and calculate the
	// most optimal routes for the CDN. This is relative to the origin path. This property is only relevant when using a single
	// origin.
	ProbePath *string `json:"probePath,omitempty"`

	// ProvisioningState: Provisioning status of the endpoint.
	ProvisioningState *EndpointProperties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// QueryStringCachingBehavior: Defines how CDN caches requests that include query strings. You can ignore any query strings
	// when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request
	// with a unique URL.
	QueryStringCachingBehavior *QueryStringCachingBehavior_STATUS `json:"queryStringCachingBehavior,omitempty"`

	// ResourceState: Resource status of the endpoint.
	ResourceState *EndpointProperties_ResourceState_STATUS `json:"resourceState,omitempty"`
	SystemData    *SystemData_STATUS                       `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// UrlSigningKeys: List of keys used to validate the signed URL hashes.
	UrlSigningKeys []UrlSigningKey_STATUS `json:"urlSigningKeys,omitempty"`

	// WebApplicationFirewallPolicyLink: Defines the Web Application Firewall policy for the endpoint (if applicable)
	WebApplicationFirewallPolicyLink *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS `json:"webApplicationFirewallPolicyLink,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Endpoint_STATUS{}

// ConvertStatusFrom populates our Endpoint_STATUS from the provided source
func (endpoint *Endpoint_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20210601s.Endpoint_STATUS)
	if ok {
		// Populate our instance from source
		return endpoint.AssignPropertiesFromEndpoint_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20210601s.Endpoint_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignPropertiesFromEndpoint_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Endpoint_STATUS
func (endpoint *Endpoint_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20210601s.Endpoint_STATUS)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignPropertiesToEndpoint_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20210601s.Endpoint_STATUS{}
	err := endpoint.AssignPropertiesToEndpoint_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Endpoint_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *Endpoint_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Endpoint_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *Endpoint_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Endpoint_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Endpoint_STATUSARM, got %T", armInput)
	}

	// no assignment for property ‘Conditions’

	// Set property ‘ContentTypesToCompress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ContentTypesToCompress {
			endpoint.ContentTypesToCompress = append(endpoint.ContentTypesToCompress, item)
		}
	}

	// Set property ‘CustomDomains’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomDomains {
			var item1 CustomDomain_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.CustomDomains = append(endpoint.CustomDomains, item1)
		}
	}

	// Set property ‘DefaultOriginGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultOriginGroup != nil {
			var defaultOriginGroup1 ResourceReference_STATUS
			err := defaultOriginGroup1.PopulateFromARM(owner, *typedInput.Properties.DefaultOriginGroup)
			if err != nil {
				return err
			}
			defaultOriginGroup := defaultOriginGroup1
			endpoint.DefaultOriginGroup = &defaultOriginGroup
		}
	}

	// Set property ‘DeliveryPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeliveryPolicy != nil {
			var deliveryPolicy1 EndpointProperties_DeliveryPolicy_STATUS
			err := deliveryPolicy1.PopulateFromARM(owner, *typedInput.Properties.DeliveryPolicy)
			if err != nil {
				return err
			}
			deliveryPolicy := deliveryPolicy1
			endpoint.DeliveryPolicy = &deliveryPolicy
		}
	}

	// Set property ‘GeoFilters’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GeoFilters {
			var item1 GeoFilter_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.GeoFilters = append(endpoint.GeoFilters, item1)
		}
	}

	// Set property ‘HostName’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			endpoint.HostName = &hostName
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		endpoint.Id = &id
	}

	// Set property ‘IsCompressionEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsCompressionEnabled != nil {
			isCompressionEnabled := *typedInput.Properties.IsCompressionEnabled
			endpoint.IsCompressionEnabled = &isCompressionEnabled
		}
	}

	// Set property ‘IsHttpAllowed’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsHttpAllowed != nil {
			isHttpAllowed := *typedInput.Properties.IsHttpAllowed
			endpoint.IsHttpAllowed = &isHttpAllowed
		}
	}

	// Set property ‘IsHttpsAllowed’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsHttpsAllowed != nil {
			isHttpsAllowed := *typedInput.Properties.IsHttpsAllowed
			endpoint.IsHttpsAllowed = &isHttpsAllowed
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		endpoint.Location = &location
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		endpoint.Name = &name
	}

	// Set property ‘OptimizationType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OptimizationType != nil {
			optimizationType := *typedInput.Properties.OptimizationType
			endpoint.OptimizationType = &optimizationType
		}
	}

	// Set property ‘OriginGroups’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OriginGroups {
			var item1 DeepCreatedOriginGroup_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.OriginGroups = append(endpoint.OriginGroups, item1)
		}
	}

	// Set property ‘OriginHostHeader’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OriginHostHeader != nil {
			originHostHeader := *typedInput.Properties.OriginHostHeader
			endpoint.OriginHostHeader = &originHostHeader
		}
	}

	// Set property ‘OriginPath’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OriginPath != nil {
			originPath := *typedInput.Properties.OriginPath
			endpoint.OriginPath = &originPath
		}
	}

	// Set property ‘Origins’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Origins {
			var item1 DeepCreatedOrigin_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.Origins = append(endpoint.Origins, item1)
		}
	}

	// Set property ‘ProbePath’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProbePath != nil {
			probePath := *typedInput.Properties.ProbePath
			endpoint.ProbePath = &probePath
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			endpoint.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘QueryStringCachingBehavior’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.QueryStringCachingBehavior != nil {
			queryStringCachingBehavior := *typedInput.Properties.QueryStringCachingBehavior
			endpoint.QueryStringCachingBehavior = &queryStringCachingBehavior
		}
	}

	// Set property ‘ResourceState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceState != nil {
			resourceState := *typedInput.Properties.ResourceState
			endpoint.ResourceState = &resourceState
		}
	}

	// Set property ‘SystemData’:
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		endpoint.SystemData = &systemData
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		endpoint.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			endpoint.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		endpoint.Type = &typeVar
	}

	// Set property ‘UrlSigningKeys’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.UrlSigningKeys {
			var item1 UrlSigningKey_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.UrlSigningKeys = append(endpoint.UrlSigningKeys, item1)
		}
	}

	// Set property ‘WebApplicationFirewallPolicyLink’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WebApplicationFirewallPolicyLink != nil {
			var webApplicationFirewallPolicyLink1 EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
			err := webApplicationFirewallPolicyLink1.PopulateFromARM(owner, *typedInput.Properties.WebApplicationFirewallPolicyLink)
			if err != nil {
				return err
			}
			webApplicationFirewallPolicyLink := webApplicationFirewallPolicyLink1
			endpoint.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromEndpoint_STATUS populates our Endpoint_STATUS from the provided source Endpoint_STATUS
func (endpoint *Endpoint_STATUS) AssignPropertiesFromEndpoint_STATUS(source *v20210601s.Endpoint_STATUS) error {

	// Conditions
	endpoint.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// ContentTypesToCompress
	endpoint.ContentTypesToCompress = genruntime.CloneSliceOfString(source.ContentTypesToCompress)

	// CustomDomains
	if source.CustomDomains != nil {
		customDomainList := make([]CustomDomain_STATUS, len(source.CustomDomains))
		for customDomainIndex, customDomainItem := range source.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain CustomDomain_STATUS
			err := customDomain.AssignPropertiesFromCustomDomain_STATUS(&customDomainItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromCustomDomain_STATUS() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		endpoint.CustomDomains = customDomainList
	} else {
		endpoint.CustomDomains = nil
	}

	// DefaultOriginGroup
	if source.DefaultOriginGroup != nil {
		var defaultOriginGroup ResourceReference_STATUS
		err := defaultOriginGroup.AssignPropertiesFromResourceReference_STATUS(source.DefaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceReference_STATUS() to populate field DefaultOriginGroup")
		}
		endpoint.DefaultOriginGroup = &defaultOriginGroup
	} else {
		endpoint.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if source.DeliveryPolicy != nil {
		var deliveryPolicy EndpointProperties_DeliveryPolicy_STATUS
		err := deliveryPolicy.AssignPropertiesFromEndpointProperties_DeliveryPolicy_STATUS(source.DeliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromEndpointProperties_DeliveryPolicy_STATUS() to populate field DeliveryPolicy")
		}
		endpoint.DeliveryPolicy = &deliveryPolicy
	} else {
		endpoint.DeliveryPolicy = nil
	}

	// GeoFilters
	if source.GeoFilters != nil {
		geoFilterList := make([]GeoFilter_STATUS, len(source.GeoFilters))
		for geoFilterIndex, geoFilterItem := range source.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter GeoFilter_STATUS
			err := geoFilter.AssignPropertiesFromGeoFilter_STATUS(&geoFilterItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromGeoFilter_STATUS() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		endpoint.GeoFilters = geoFilterList
	} else {
		endpoint.GeoFilters = nil
	}

	// HostName
	endpoint.HostName = genruntime.ClonePointerToString(source.HostName)

	// Id
	endpoint.Id = genruntime.ClonePointerToString(source.Id)

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := *source.IsCompressionEnabled
		endpoint.IsCompressionEnabled = &isCompressionEnabled
	} else {
		endpoint.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if source.IsHttpAllowed != nil {
		isHttpAllowed := *source.IsHttpAllowed
		endpoint.IsHttpAllowed = &isHttpAllowed
	} else {
		endpoint.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if source.IsHttpsAllowed != nil {
		isHttpsAllowed := *source.IsHttpsAllowed
		endpoint.IsHttpsAllowed = &isHttpsAllowed
	} else {
		endpoint.IsHttpsAllowed = nil
	}

	// Location
	endpoint.Location = genruntime.ClonePointerToString(source.Location)

	// Name
	endpoint.Name = genruntime.ClonePointerToString(source.Name)

	// OptimizationType
	if source.OptimizationType != nil {
		optimizationType := OptimizationType_STATUS(*source.OptimizationType)
		endpoint.OptimizationType = &optimizationType
	} else {
		endpoint.OptimizationType = nil
	}

	// OriginGroups
	if source.OriginGroups != nil {
		originGroupList := make([]DeepCreatedOriginGroup_STATUS, len(source.OriginGroups))
		for originGroupIndex, originGroupItem := range source.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup DeepCreatedOriginGroup_STATUS
			err := originGroup.AssignPropertiesFromDeepCreatedOriginGroup_STATUS(&originGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeepCreatedOriginGroup_STATUS() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		endpoint.OriginGroups = originGroupList
	} else {
		endpoint.OriginGroups = nil
	}

	// OriginHostHeader
	endpoint.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// OriginPath
	endpoint.OriginPath = genruntime.ClonePointerToString(source.OriginPath)

	// Origins
	if source.Origins != nil {
		originList := make([]DeepCreatedOrigin_STATUS, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin DeepCreatedOrigin_STATUS
			err := origin.AssignPropertiesFromDeepCreatedOrigin_STATUS(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeepCreatedOrigin_STATUS() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		endpoint.Origins = originList
	} else {
		endpoint.Origins = nil
	}

	// ProbePath
	endpoint.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := EndpointProperties_ProvisioningState_STATUS(*source.ProvisioningState)
		endpoint.ProvisioningState = &provisioningState
	} else {
		endpoint.ProvisioningState = nil
	}

	// QueryStringCachingBehavior
	if source.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := QueryStringCachingBehavior_STATUS(*source.QueryStringCachingBehavior)
		endpoint.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		endpoint.QueryStringCachingBehavior = nil
	}

	// ResourceState
	if source.ResourceState != nil {
		resourceState := EndpointProperties_ResourceState_STATUS(*source.ResourceState)
		endpoint.ResourceState = &resourceState
	} else {
		endpoint.ResourceState = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignPropertiesFromSystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSystemData_STATUS() to populate field SystemData")
		}
		endpoint.SystemData = &systemDatum
	} else {
		endpoint.SystemData = nil
	}

	// Tags
	endpoint.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// UrlSigningKeys
	if source.UrlSigningKeys != nil {
		urlSigningKeyList := make([]UrlSigningKey_STATUS, len(source.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range source.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey UrlSigningKey_STATUS
			err := urlSigningKey.AssignPropertiesFromUrlSigningKey_STATUS(&urlSigningKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromUrlSigningKey_STATUS() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		endpoint.UrlSigningKeys = urlSigningKeyList
	} else {
		endpoint.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if source.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
		err := webApplicationFirewallPolicyLink.AssignPropertiesFromEndpointProperties_WebApplicationFirewallPolicyLink_STATUS(source.WebApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromEndpointProperties_WebApplicationFirewallPolicyLink_STATUS() to populate field WebApplicationFirewallPolicyLink")
		}
		endpoint.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		endpoint.WebApplicationFirewallPolicyLink = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEndpoint_STATUS populates the provided destination Endpoint_STATUS from our Endpoint_STATUS
func (endpoint *Endpoint_STATUS) AssignPropertiesToEndpoint_STATUS(destination *v20210601s.Endpoint_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(endpoint.Conditions)

	// ContentTypesToCompress
	destination.ContentTypesToCompress = genruntime.CloneSliceOfString(endpoint.ContentTypesToCompress)

	// CustomDomains
	if endpoint.CustomDomains != nil {
		customDomainList := make([]v20210601s.CustomDomain_STATUS, len(endpoint.CustomDomains))
		for customDomainIndex, customDomainItem := range endpoint.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain v20210601s.CustomDomain_STATUS
			err := customDomainItem.AssignPropertiesToCustomDomain_STATUS(&customDomain)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToCustomDomain_STATUS() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		destination.CustomDomains = customDomainList
	} else {
		destination.CustomDomains = nil
	}

	// DefaultOriginGroup
	if endpoint.DefaultOriginGroup != nil {
		var defaultOriginGroup v20210601s.ResourceReference_STATUS
		err := endpoint.DefaultOriginGroup.AssignPropertiesToResourceReference_STATUS(&defaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceReference_STATUS() to populate field DefaultOriginGroup")
		}
		destination.DefaultOriginGroup = &defaultOriginGroup
	} else {
		destination.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if endpoint.DeliveryPolicy != nil {
		var deliveryPolicy v20210601s.EndpointProperties_DeliveryPolicy_STATUS
		err := endpoint.DeliveryPolicy.AssignPropertiesToEndpointProperties_DeliveryPolicy_STATUS(&deliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToEndpointProperties_DeliveryPolicy_STATUS() to populate field DeliveryPolicy")
		}
		destination.DeliveryPolicy = &deliveryPolicy
	} else {
		destination.DeliveryPolicy = nil
	}

	// GeoFilters
	if endpoint.GeoFilters != nil {
		geoFilterList := make([]v20210601s.GeoFilter_STATUS, len(endpoint.GeoFilters))
		for geoFilterIndex, geoFilterItem := range endpoint.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter v20210601s.GeoFilter_STATUS
			err := geoFilterItem.AssignPropertiesToGeoFilter_STATUS(&geoFilter)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToGeoFilter_STATUS() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		destination.GeoFilters = geoFilterList
	} else {
		destination.GeoFilters = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(endpoint.HostName)

	// Id
	destination.Id = genruntime.ClonePointerToString(endpoint.Id)

	// IsCompressionEnabled
	if endpoint.IsCompressionEnabled != nil {
		isCompressionEnabled := *endpoint.IsCompressionEnabled
		destination.IsCompressionEnabled = &isCompressionEnabled
	} else {
		destination.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if endpoint.IsHttpAllowed != nil {
		isHttpAllowed := *endpoint.IsHttpAllowed
		destination.IsHttpAllowed = &isHttpAllowed
	} else {
		destination.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if endpoint.IsHttpsAllowed != nil {
		isHttpsAllowed := *endpoint.IsHttpsAllowed
		destination.IsHttpsAllowed = &isHttpsAllowed
	} else {
		destination.IsHttpsAllowed = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(endpoint.Location)

	// Name
	destination.Name = genruntime.ClonePointerToString(endpoint.Name)

	// OptimizationType
	if endpoint.OptimizationType != nil {
		optimizationType := string(*endpoint.OptimizationType)
		destination.OptimizationType = &optimizationType
	} else {
		destination.OptimizationType = nil
	}

	// OriginGroups
	if endpoint.OriginGroups != nil {
		originGroupList := make([]v20210601s.DeepCreatedOriginGroup_STATUS, len(endpoint.OriginGroups))
		for originGroupIndex, originGroupItem := range endpoint.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup v20210601s.DeepCreatedOriginGroup_STATUS
			err := originGroupItem.AssignPropertiesToDeepCreatedOriginGroup_STATUS(&originGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeepCreatedOriginGroup_STATUS() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		destination.OriginGroups = originGroupList
	} else {
		destination.OriginGroups = nil
	}

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(endpoint.OriginHostHeader)

	// OriginPath
	destination.OriginPath = genruntime.ClonePointerToString(endpoint.OriginPath)

	// Origins
	if endpoint.Origins != nil {
		originList := make([]v20210601s.DeepCreatedOrigin_STATUS, len(endpoint.Origins))
		for originIndex, originItem := range endpoint.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin v20210601s.DeepCreatedOrigin_STATUS
			err := originItem.AssignPropertiesToDeepCreatedOrigin_STATUS(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeepCreatedOrigin_STATUS() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(endpoint.ProbePath)

	// ProvisioningState
	if endpoint.ProvisioningState != nil {
		provisioningState := string(*endpoint.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// QueryStringCachingBehavior
	if endpoint.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := string(*endpoint.QueryStringCachingBehavior)
		destination.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		destination.QueryStringCachingBehavior = nil
	}

	// ResourceState
	if endpoint.ResourceState != nil {
		resourceState := string(*endpoint.ResourceState)
		destination.ResourceState = &resourceState
	} else {
		destination.ResourceState = nil
	}

	// SystemData
	if endpoint.SystemData != nil {
		var systemDatum v20210601s.SystemData_STATUS
		err := endpoint.SystemData.AssignPropertiesToSystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(endpoint.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(endpoint.Type)

	// UrlSigningKeys
	if endpoint.UrlSigningKeys != nil {
		urlSigningKeyList := make([]v20210601s.UrlSigningKey_STATUS, len(endpoint.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range endpoint.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey v20210601s.UrlSigningKey_STATUS
			err := urlSigningKeyItem.AssignPropertiesToUrlSigningKey_STATUS(&urlSigningKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToUrlSigningKey_STATUS() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		destination.UrlSigningKeys = urlSigningKeyList
	} else {
		destination.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if endpoint.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
		err := endpoint.WebApplicationFirewallPolicyLink.AssignPropertiesToEndpointProperties_WebApplicationFirewallPolicyLink_STATUS(&webApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToEndpointProperties_WebApplicationFirewallPolicyLink_STATUS() to populate field WebApplicationFirewallPolicyLink")
		}
		destination.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		destination.WebApplicationFirewallPolicyLink = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ProfilesEndpoint_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// ContentTypesToCompress: List of content types on which compression applies. The value should be a valid MIME type.
	ContentTypesToCompress []string `json:"contentTypesToCompress,omitempty"`

	// CustomDomains: The custom domains under the endpoint.
	CustomDomains []CustomDomain `json:"customDomains,omitempty"`

	// DefaultOriginGroup: A reference to the origin group.
	DefaultOriginGroup *ResourceReference `json:"defaultOriginGroup,omitempty"`

	// DeliveryPolicy: A policy that specifies the delivery rules to be used for an endpoint.
	DeliveryPolicy *EndpointProperties_DeliveryPolicy `json:"deliveryPolicy,omitempty"`

	// GeoFilters: List of rules defining the user's geo access within a CDN endpoint. Each geo filter defines an access rule
	// to a specified path or content, e.g. block APAC for path /pictures/
	GeoFilters []GeoFilter `json:"geoFilters,omitempty"`

	// HostName: The host name of the endpoint structured as {endpointName}.{DNSZone}, e.g. contoso.azureedge.net
	HostName *string `json:"hostName,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// IsCompressionEnabled: Indicates whether content compression is enabled on CDN. Default value is false. If compression is
	// enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on
	// CDN when requested content is smaller than 1 byte or larger than 1 MB.
	IsCompressionEnabled *bool `json:"isCompressionEnabled,omitempty"`

	// IsHttpAllowed: Indicates whether HTTP traffic is allowed on the endpoint. Default value is true. At least one protocol
	// (HTTP or HTTPS) must be allowed.
	IsHttpAllowed *bool `json:"isHttpAllowed,omitempty"`

	// IsHttpsAllowed: Indicates whether HTTPS traffic is allowed on the endpoint. Default value is true. At least one protocol
	// (HTTP or HTTPS) must be allowed.
	IsHttpsAllowed *bool `json:"isHttpsAllowed,omitempty"`

	// +kubebuilder:validation:Required
	// Location: Resource location.
	Location *string `json:"location,omitempty"`

	// OptimizationType: Specifies what scenario the customer wants this CDN endpoint to optimize for, e.g. Download, Media
	// services. With this information, CDN can apply scenario driven optimization.
	OptimizationType *OptimizationType `json:"optimizationType,omitempty"`

	// OriginGroups: The origin groups comprising of origins that are used for load balancing the traffic based on availability.
	OriginGroups []DeepCreatedOriginGroup `json:"originGroups,omitempty"`

	// OriginHostHeader: The host header value sent to the origin with each request. This property at Endpoint is only allowed
	// when endpoint uses single origin and can be overridden by the same property specified at origin.If you leave this blank,
	// the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services
	// require this host header value to match the origin hostname by default.
	OriginHostHeader *string `json:"originHostHeader,omitempty"`

	// OriginPath: A directory path on the origin that CDN can use to retrieve content from, e.g.
	// contoso.cloudapp.net/originpath.
	OriginPath *string `json:"originPath,omitempty"`

	// +kubebuilder:validation:Required
	// Origins: The source of the content being delivered via CDN.
	Origins []DeepCreatedOrigin `json:"origins,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// ProbePath: Path to a file hosted on the origin which helps accelerate delivery of the dynamic content and calculate the
	// most optimal routes for the CDN. This is relative to the origin path. This property is only relevant when using a single
	// origin.
	ProbePath *string `json:"probePath,omitempty"`

	// ProvisioningState: Provisioning status of the endpoint.
	ProvisioningState *EndpointProperties_ProvisioningState `json:"provisioningState,omitempty"`

	// QueryStringCachingBehavior: Defines how CDN caches requests that include query strings. You can ignore any query strings
	// when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request
	// with a unique URL.
	QueryStringCachingBehavior *QueryStringCachingBehavior `json:"queryStringCachingBehavior,omitempty"`

	// ResourceState: Resource status of the endpoint.
	ResourceState *EndpointProperties_ResourceState `json:"resourceState,omitempty"`
	SystemData    *SystemData                       `json:"systemData,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// UrlSigningKeys: List of keys used to validate the signed URL hashes.
	UrlSigningKeys []UrlSigningKey `json:"urlSigningKeys,omitempty"`

	// WebApplicationFirewallPolicyLink: Defines the Web Application Firewall policy for the endpoint (if applicable)
	WebApplicationFirewallPolicyLink *EndpointProperties_WebApplicationFirewallPolicyLink `json:"webApplicationFirewallPolicyLink,omitempty"`
}

var _ genruntime.ARMTransformer = &ProfilesEndpoint_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (endpoint *ProfilesEndpoint_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if endpoint == nil {
		return nil, nil
	}
	result := &ProfilesEndpoint_SpecARM{}

	// Set property ‘AzureName’:
	result.AzureName = endpoint.AzureName

	// Set property ‘Id’:
	if endpoint.Id != nil {
		id := *endpoint.Id
		result.Id = &id
	}

	// Set property ‘Location’:
	if endpoint.Location != nil {
		location := *endpoint.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if endpoint.ContentTypesToCompress != nil ||
		endpoint.CustomDomains != nil ||
		endpoint.DefaultOriginGroup != nil ||
		endpoint.DeliveryPolicy != nil ||
		endpoint.GeoFilters != nil ||
		endpoint.HostName != nil ||
		endpoint.IsCompressionEnabled != nil ||
		endpoint.IsHttpAllowed != nil ||
		endpoint.IsHttpsAllowed != nil ||
		endpoint.OptimizationType != nil ||
		endpoint.OriginGroups != nil ||
		endpoint.OriginHostHeader != nil ||
		endpoint.OriginPath != nil ||
		endpoint.Origins != nil ||
		endpoint.ProbePath != nil ||
		endpoint.ProvisioningState != nil ||
		endpoint.QueryStringCachingBehavior != nil ||
		endpoint.ResourceState != nil ||
		endpoint.UrlSigningKeys != nil ||
		endpoint.WebApplicationFirewallPolicyLink != nil {
		result.Properties = &EndpointPropertiesARM{}
	}
	for _, item := range endpoint.ContentTypesToCompress {
		result.Properties.ContentTypesToCompress = append(result.Properties.ContentTypesToCompress, item)
	}
	for _, item := range endpoint.CustomDomains {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.CustomDomains = append(result.Properties.CustomDomains, *itemARM.(*CustomDomainARM))
	}
	if endpoint.DefaultOriginGroup != nil {
		defaultOriginGroupARM, err := (*endpoint.DefaultOriginGroup).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		defaultOriginGroup := *defaultOriginGroupARM.(*ResourceReferenceARM)
		result.Properties.DefaultOriginGroup = &defaultOriginGroup
	}
	if endpoint.DeliveryPolicy != nil {
		deliveryPolicyARM, err := (*endpoint.DeliveryPolicy).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		deliveryPolicy := *deliveryPolicyARM.(*EndpointProperties_DeliveryPolicyARM)
		result.Properties.DeliveryPolicy = &deliveryPolicy
	}
	for _, item := range endpoint.GeoFilters {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.GeoFilters = append(result.Properties.GeoFilters, *itemARM.(*GeoFilterARM))
	}
	if endpoint.HostName != nil {
		hostName := *endpoint.HostName
		result.Properties.HostName = &hostName
	}
	if endpoint.IsCompressionEnabled != nil {
		isCompressionEnabled := *endpoint.IsCompressionEnabled
		result.Properties.IsCompressionEnabled = &isCompressionEnabled
	}
	if endpoint.IsHttpAllowed != nil {
		isHttpAllowed := *endpoint.IsHttpAllowed
		result.Properties.IsHttpAllowed = &isHttpAllowed
	}
	if endpoint.IsHttpsAllowed != nil {
		isHttpsAllowed := *endpoint.IsHttpsAllowed
		result.Properties.IsHttpsAllowed = &isHttpsAllowed
	}
	if endpoint.OptimizationType != nil {
		optimizationType := *endpoint.OptimizationType
		result.Properties.OptimizationType = &optimizationType
	}
	for _, item := range endpoint.OriginGroups {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.OriginGroups = append(result.Properties.OriginGroups, *itemARM.(*DeepCreatedOriginGroupARM))
	}
	if endpoint.OriginHostHeader != nil {
		originHostHeader := *endpoint.OriginHostHeader
		result.Properties.OriginHostHeader = &originHostHeader
	}
	if endpoint.OriginPath != nil {
		originPath := *endpoint.OriginPath
		result.Properties.OriginPath = &originPath
	}
	for _, item := range endpoint.Origins {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Origins = append(result.Properties.Origins, *itemARM.(*DeepCreatedOriginARM))
	}
	if endpoint.ProbePath != nil {
		probePath := *endpoint.ProbePath
		result.Properties.ProbePath = &probePath
	}
	if endpoint.ProvisioningState != nil {
		provisioningState := *endpoint.ProvisioningState
		result.Properties.ProvisioningState = &provisioningState
	}
	if endpoint.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := *endpoint.QueryStringCachingBehavior
		result.Properties.QueryStringCachingBehavior = &queryStringCachingBehavior
	}
	if endpoint.ResourceState != nil {
		resourceState := *endpoint.ResourceState
		result.Properties.ResourceState = &resourceState
	}
	for _, item := range endpoint.UrlSigningKeys {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.UrlSigningKeys = append(result.Properties.UrlSigningKeys, *itemARM.(*UrlSigningKeyARM))
	}
	if endpoint.WebApplicationFirewallPolicyLink != nil {
		webApplicationFirewallPolicyLinkARM, err := (*endpoint.WebApplicationFirewallPolicyLink).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		webApplicationFirewallPolicyLink := *webApplicationFirewallPolicyLinkARM.(*EndpointProperties_WebApplicationFirewallPolicyLinkARM)
		result.Properties.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	}

	// Set property ‘SystemData’:
	if endpoint.SystemData != nil {
		systemDataARM, err := (*endpoint.SystemData).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		systemData := *systemDataARM.(*SystemDataARM)
		result.SystemData = &systemData
	}

	// Set property ‘Tags’:
	if endpoint.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range endpoint.Tags {
			result.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if endpoint.Type != nil {
		typeVar := *endpoint.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (endpoint *ProfilesEndpoint_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ProfilesEndpoint_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (endpoint *ProfilesEndpoint_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ProfilesEndpoint_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ProfilesEndpoint_SpecARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	endpoint.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘ContentTypesToCompress’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.ContentTypesToCompress {
			endpoint.ContentTypesToCompress = append(endpoint.ContentTypesToCompress, item)
		}
	}

	// Set property ‘CustomDomains’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.CustomDomains {
			var item1 CustomDomain
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.CustomDomains = append(endpoint.CustomDomains, item1)
		}
	}

	// Set property ‘DefaultOriginGroup’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DefaultOriginGroup != nil {
			var defaultOriginGroup1 ResourceReference
			err := defaultOriginGroup1.PopulateFromARM(owner, *typedInput.Properties.DefaultOriginGroup)
			if err != nil {
				return err
			}
			defaultOriginGroup := defaultOriginGroup1
			endpoint.DefaultOriginGroup = &defaultOriginGroup
		}
	}

	// Set property ‘DeliveryPolicy’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.DeliveryPolicy != nil {
			var deliveryPolicy1 EndpointProperties_DeliveryPolicy
			err := deliveryPolicy1.PopulateFromARM(owner, *typedInput.Properties.DeliveryPolicy)
			if err != nil {
				return err
			}
			deliveryPolicy := deliveryPolicy1
			endpoint.DeliveryPolicy = &deliveryPolicy
		}
	}

	// Set property ‘GeoFilters’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.GeoFilters {
			var item1 GeoFilter
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.GeoFilters = append(endpoint.GeoFilters, item1)
		}
	}

	// Set property ‘HostName’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			endpoint.HostName = &hostName
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		endpoint.Id = &id
	}

	// Set property ‘IsCompressionEnabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsCompressionEnabled != nil {
			isCompressionEnabled := *typedInput.Properties.IsCompressionEnabled
			endpoint.IsCompressionEnabled = &isCompressionEnabled
		}
	}

	// Set property ‘IsHttpAllowed’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsHttpAllowed != nil {
			isHttpAllowed := *typedInput.Properties.IsHttpAllowed
			endpoint.IsHttpAllowed = &isHttpAllowed
		}
	}

	// Set property ‘IsHttpsAllowed’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.IsHttpsAllowed != nil {
			isHttpsAllowed := *typedInput.Properties.IsHttpsAllowed
			endpoint.IsHttpsAllowed = &isHttpsAllowed
		}
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		endpoint.Location = &location
	}

	// Set property ‘OptimizationType’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OptimizationType != nil {
			optimizationType := *typedInput.Properties.OptimizationType
			endpoint.OptimizationType = &optimizationType
		}
	}

	// Set property ‘OriginGroups’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.OriginGroups {
			var item1 DeepCreatedOriginGroup
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.OriginGroups = append(endpoint.OriginGroups, item1)
		}
	}

	// Set property ‘OriginHostHeader’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OriginHostHeader != nil {
			originHostHeader := *typedInput.Properties.OriginHostHeader
			endpoint.OriginHostHeader = &originHostHeader
		}
	}

	// Set property ‘OriginPath’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OriginPath != nil {
			originPath := *typedInput.Properties.OriginPath
			endpoint.OriginPath = &originPath
		}
	}

	// Set property ‘Origins’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Origins {
			var item1 DeepCreatedOrigin
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.Origins = append(endpoint.Origins, item1)
		}
	}

	// Set property ‘Owner’:
	endpoint.Owner = &genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘ProbePath’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProbePath != nil {
			probePath := *typedInput.Properties.ProbePath
			endpoint.ProbePath = &probePath
		}
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			endpoint.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘QueryStringCachingBehavior’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.QueryStringCachingBehavior != nil {
			queryStringCachingBehavior := *typedInput.Properties.QueryStringCachingBehavior
			endpoint.QueryStringCachingBehavior = &queryStringCachingBehavior
		}
	}

	// Set property ‘ResourceState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceState != nil {
			resourceState := *typedInput.Properties.ResourceState
			endpoint.ResourceState = &resourceState
		}
	}

	// Set property ‘SystemData’:
	if typedInput.SystemData != nil {
		var systemData1 SystemData
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		endpoint.SystemData = &systemData
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		endpoint.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			endpoint.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		endpoint.Type = &typeVar
	}

	// Set property ‘UrlSigningKeys’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.UrlSigningKeys {
			var item1 UrlSigningKey
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			endpoint.UrlSigningKeys = append(endpoint.UrlSigningKeys, item1)
		}
	}

	// Set property ‘WebApplicationFirewallPolicyLink’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.WebApplicationFirewallPolicyLink != nil {
			var webApplicationFirewallPolicyLink1 EndpointProperties_WebApplicationFirewallPolicyLink
			err := webApplicationFirewallPolicyLink1.PopulateFromARM(owner, *typedInput.Properties.WebApplicationFirewallPolicyLink)
			if err != nil {
				return err
			}
			webApplicationFirewallPolicyLink := webApplicationFirewallPolicyLink1
			endpoint.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &ProfilesEndpoint_Spec{}

// ConvertSpecFrom populates our ProfilesEndpoint_Spec from the provided source
func (endpoint *ProfilesEndpoint_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20210601s.ProfilesEndpoint_Spec)
	if ok {
		// Populate our instance from source
		return endpoint.AssignPropertiesFromProfilesEndpoint_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20210601s.ProfilesEndpoint_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = endpoint.AssignPropertiesFromProfilesEndpoint_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ProfilesEndpoint_Spec
func (endpoint *ProfilesEndpoint_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20210601s.ProfilesEndpoint_Spec)
	if ok {
		// Populate destination from our instance
		return endpoint.AssignPropertiesToProfilesEndpoint_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20210601s.ProfilesEndpoint_Spec{}
	err := endpoint.AssignPropertiesToProfilesEndpoint_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromProfilesEndpoint_Spec populates our ProfilesEndpoint_Spec from the provided source ProfilesEndpoint_Spec
func (endpoint *ProfilesEndpoint_Spec) AssignPropertiesFromProfilesEndpoint_Spec(source *v20210601s.ProfilesEndpoint_Spec) error {

	// AzureName
	endpoint.AzureName = source.AzureName

	// ContentTypesToCompress
	endpoint.ContentTypesToCompress = genruntime.CloneSliceOfString(source.ContentTypesToCompress)

	// CustomDomains
	if source.CustomDomains != nil {
		customDomainList := make([]CustomDomain, len(source.CustomDomains))
		for customDomainIndex, customDomainItem := range source.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain CustomDomain
			err := customDomain.AssignPropertiesFromCustomDomain(&customDomainItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromCustomDomain() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		endpoint.CustomDomains = customDomainList
	} else {
		endpoint.CustomDomains = nil
	}

	// DefaultOriginGroup
	if source.DefaultOriginGroup != nil {
		var defaultOriginGroup ResourceReference
		err := defaultOriginGroup.AssignPropertiesFromResourceReference(source.DefaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResourceReference() to populate field DefaultOriginGroup")
		}
		endpoint.DefaultOriginGroup = &defaultOriginGroup
	} else {
		endpoint.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if source.DeliveryPolicy != nil {
		var deliveryPolicy EndpointProperties_DeliveryPolicy
		err := deliveryPolicy.AssignPropertiesFromEndpointProperties_DeliveryPolicy(source.DeliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromEndpointProperties_DeliveryPolicy() to populate field DeliveryPolicy")
		}
		endpoint.DeliveryPolicy = &deliveryPolicy
	} else {
		endpoint.DeliveryPolicy = nil
	}

	// GeoFilters
	if source.GeoFilters != nil {
		geoFilterList := make([]GeoFilter, len(source.GeoFilters))
		for geoFilterIndex, geoFilterItem := range source.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter GeoFilter
			err := geoFilter.AssignPropertiesFromGeoFilter(&geoFilterItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromGeoFilter() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		endpoint.GeoFilters = geoFilterList
	} else {
		endpoint.GeoFilters = nil
	}

	// HostName
	endpoint.HostName = genruntime.ClonePointerToString(source.HostName)

	// Id
	endpoint.Id = genruntime.ClonePointerToString(source.Id)

	// IsCompressionEnabled
	if source.IsCompressionEnabled != nil {
		isCompressionEnabled := *source.IsCompressionEnabled
		endpoint.IsCompressionEnabled = &isCompressionEnabled
	} else {
		endpoint.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if source.IsHttpAllowed != nil {
		isHttpAllowed := *source.IsHttpAllowed
		endpoint.IsHttpAllowed = &isHttpAllowed
	} else {
		endpoint.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if source.IsHttpsAllowed != nil {
		isHttpsAllowed := *source.IsHttpsAllowed
		endpoint.IsHttpsAllowed = &isHttpsAllowed
	} else {
		endpoint.IsHttpsAllowed = nil
	}

	// Location
	endpoint.Location = genruntime.ClonePointerToString(source.Location)

	// OptimizationType
	if source.OptimizationType != nil {
		optimizationType := OptimizationType(*source.OptimizationType)
		endpoint.OptimizationType = &optimizationType
	} else {
		endpoint.OptimizationType = nil
	}

	// OriginGroups
	if source.OriginGroups != nil {
		originGroupList := make([]DeepCreatedOriginGroup, len(source.OriginGroups))
		for originGroupIndex, originGroupItem := range source.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup DeepCreatedOriginGroup
			err := originGroup.AssignPropertiesFromDeepCreatedOriginGroup(&originGroupItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeepCreatedOriginGroup() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		endpoint.OriginGroups = originGroupList
	} else {
		endpoint.OriginGroups = nil
	}

	// OriginHostHeader
	endpoint.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// OriginPath
	endpoint.OriginPath = genruntime.ClonePointerToString(source.OriginPath)

	// Origins
	if source.Origins != nil {
		originList := make([]DeepCreatedOrigin, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin DeepCreatedOrigin
			err := origin.AssignPropertiesFromDeepCreatedOrigin(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeepCreatedOrigin() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		endpoint.Origins = originList
	} else {
		endpoint.Origins = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		endpoint.Owner = &owner
	} else {
		endpoint.Owner = nil
	}

	// ProbePath
	endpoint.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := EndpointProperties_ProvisioningState(*source.ProvisioningState)
		endpoint.ProvisioningState = &provisioningState
	} else {
		endpoint.ProvisioningState = nil
	}

	// QueryStringCachingBehavior
	if source.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := QueryStringCachingBehavior(*source.QueryStringCachingBehavior)
		endpoint.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		endpoint.QueryStringCachingBehavior = nil
	}

	// ResourceState
	if source.ResourceState != nil {
		resourceState := EndpointProperties_ResourceState(*source.ResourceState)
		endpoint.ResourceState = &resourceState
	} else {
		endpoint.ResourceState = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData
		err := systemDatum.AssignPropertiesFromSystemData(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSystemData() to populate field SystemData")
		}
		endpoint.SystemData = &systemDatum
	} else {
		endpoint.SystemData = nil
	}

	// Tags
	endpoint.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	endpoint.Type = genruntime.ClonePointerToString(source.Type)

	// UrlSigningKeys
	if source.UrlSigningKeys != nil {
		urlSigningKeyList := make([]UrlSigningKey, len(source.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range source.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey UrlSigningKey
			err := urlSigningKey.AssignPropertiesFromUrlSigningKey(&urlSigningKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromUrlSigningKey() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		endpoint.UrlSigningKeys = urlSigningKeyList
	} else {
		endpoint.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if source.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink EndpointProperties_WebApplicationFirewallPolicyLink
		err := webApplicationFirewallPolicyLink.AssignPropertiesFromEndpointProperties_WebApplicationFirewallPolicyLink(source.WebApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromEndpointProperties_WebApplicationFirewallPolicyLink() to populate field WebApplicationFirewallPolicyLink")
		}
		endpoint.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		endpoint.WebApplicationFirewallPolicyLink = nil
	}

	// No error
	return nil
}

// AssignPropertiesToProfilesEndpoint_Spec populates the provided destination ProfilesEndpoint_Spec from our ProfilesEndpoint_Spec
func (endpoint *ProfilesEndpoint_Spec) AssignPropertiesToProfilesEndpoint_Spec(destination *v20210601s.ProfilesEndpoint_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = endpoint.AzureName

	// ContentTypesToCompress
	destination.ContentTypesToCompress = genruntime.CloneSliceOfString(endpoint.ContentTypesToCompress)

	// CustomDomains
	if endpoint.CustomDomains != nil {
		customDomainList := make([]v20210601s.CustomDomain, len(endpoint.CustomDomains))
		for customDomainIndex, customDomainItem := range endpoint.CustomDomains {
			// Shadow the loop variable to avoid aliasing
			customDomainItem := customDomainItem
			var customDomain v20210601s.CustomDomain
			err := customDomainItem.AssignPropertiesToCustomDomain(&customDomain)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToCustomDomain() to populate field CustomDomains")
			}
			customDomainList[customDomainIndex] = customDomain
		}
		destination.CustomDomains = customDomainList
	} else {
		destination.CustomDomains = nil
	}

	// DefaultOriginGroup
	if endpoint.DefaultOriginGroup != nil {
		var defaultOriginGroup v20210601s.ResourceReference
		err := endpoint.DefaultOriginGroup.AssignPropertiesToResourceReference(&defaultOriginGroup)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResourceReference() to populate field DefaultOriginGroup")
		}
		destination.DefaultOriginGroup = &defaultOriginGroup
	} else {
		destination.DefaultOriginGroup = nil
	}

	// DeliveryPolicy
	if endpoint.DeliveryPolicy != nil {
		var deliveryPolicy v20210601s.EndpointProperties_DeliveryPolicy
		err := endpoint.DeliveryPolicy.AssignPropertiesToEndpointProperties_DeliveryPolicy(&deliveryPolicy)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToEndpointProperties_DeliveryPolicy() to populate field DeliveryPolicy")
		}
		destination.DeliveryPolicy = &deliveryPolicy
	} else {
		destination.DeliveryPolicy = nil
	}

	// GeoFilters
	if endpoint.GeoFilters != nil {
		geoFilterList := make([]v20210601s.GeoFilter, len(endpoint.GeoFilters))
		for geoFilterIndex, geoFilterItem := range endpoint.GeoFilters {
			// Shadow the loop variable to avoid aliasing
			geoFilterItem := geoFilterItem
			var geoFilter v20210601s.GeoFilter
			err := geoFilterItem.AssignPropertiesToGeoFilter(&geoFilter)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToGeoFilter() to populate field GeoFilters")
			}
			geoFilterList[geoFilterIndex] = geoFilter
		}
		destination.GeoFilters = geoFilterList
	} else {
		destination.GeoFilters = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(endpoint.HostName)

	// Id
	destination.Id = genruntime.ClonePointerToString(endpoint.Id)

	// IsCompressionEnabled
	if endpoint.IsCompressionEnabled != nil {
		isCompressionEnabled := *endpoint.IsCompressionEnabled
		destination.IsCompressionEnabled = &isCompressionEnabled
	} else {
		destination.IsCompressionEnabled = nil
	}

	// IsHttpAllowed
	if endpoint.IsHttpAllowed != nil {
		isHttpAllowed := *endpoint.IsHttpAllowed
		destination.IsHttpAllowed = &isHttpAllowed
	} else {
		destination.IsHttpAllowed = nil
	}

	// IsHttpsAllowed
	if endpoint.IsHttpsAllowed != nil {
		isHttpsAllowed := *endpoint.IsHttpsAllowed
		destination.IsHttpsAllowed = &isHttpsAllowed
	} else {
		destination.IsHttpsAllowed = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(endpoint.Location)

	// OptimizationType
	if endpoint.OptimizationType != nil {
		optimizationType := string(*endpoint.OptimizationType)
		destination.OptimizationType = &optimizationType
	} else {
		destination.OptimizationType = nil
	}

	// OriginGroups
	if endpoint.OriginGroups != nil {
		originGroupList := make([]v20210601s.DeepCreatedOriginGroup, len(endpoint.OriginGroups))
		for originGroupIndex, originGroupItem := range endpoint.OriginGroups {
			// Shadow the loop variable to avoid aliasing
			originGroupItem := originGroupItem
			var originGroup v20210601s.DeepCreatedOriginGroup
			err := originGroupItem.AssignPropertiesToDeepCreatedOriginGroup(&originGroup)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeepCreatedOriginGroup() to populate field OriginGroups")
			}
			originGroupList[originGroupIndex] = originGroup
		}
		destination.OriginGroups = originGroupList
	} else {
		destination.OriginGroups = nil
	}

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(endpoint.OriginHostHeader)

	// OriginPath
	destination.OriginPath = genruntime.ClonePointerToString(endpoint.OriginPath)

	// OriginalVersion
	destination.OriginalVersion = endpoint.OriginalVersion()

	// Origins
	if endpoint.Origins != nil {
		originList := make([]v20210601s.DeepCreatedOrigin, len(endpoint.Origins))
		for originIndex, originItem := range endpoint.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin v20210601s.DeepCreatedOrigin
			err := originItem.AssignPropertiesToDeepCreatedOrigin(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeepCreatedOrigin() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// Owner
	if endpoint.Owner != nil {
		owner := endpoint.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(endpoint.ProbePath)

	// ProvisioningState
	if endpoint.ProvisioningState != nil {
		provisioningState := string(*endpoint.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// QueryStringCachingBehavior
	if endpoint.QueryStringCachingBehavior != nil {
		queryStringCachingBehavior := string(*endpoint.QueryStringCachingBehavior)
		destination.QueryStringCachingBehavior = &queryStringCachingBehavior
	} else {
		destination.QueryStringCachingBehavior = nil
	}

	// ResourceState
	if endpoint.ResourceState != nil {
		resourceState := string(*endpoint.ResourceState)
		destination.ResourceState = &resourceState
	} else {
		destination.ResourceState = nil
	}

	// SystemData
	if endpoint.SystemData != nil {
		var systemDatum v20210601s.SystemData
		err := endpoint.SystemData.AssignPropertiesToSystemData(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSystemData() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(endpoint.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(endpoint.Type)

	// UrlSigningKeys
	if endpoint.UrlSigningKeys != nil {
		urlSigningKeyList := make([]v20210601s.UrlSigningKey, len(endpoint.UrlSigningKeys))
		for urlSigningKeyIndex, urlSigningKeyItem := range endpoint.UrlSigningKeys {
			// Shadow the loop variable to avoid aliasing
			urlSigningKeyItem := urlSigningKeyItem
			var urlSigningKey v20210601s.UrlSigningKey
			err := urlSigningKeyItem.AssignPropertiesToUrlSigningKey(&urlSigningKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToUrlSigningKey() to populate field UrlSigningKeys")
			}
			urlSigningKeyList[urlSigningKeyIndex] = urlSigningKey
		}
		destination.UrlSigningKeys = urlSigningKeyList
	} else {
		destination.UrlSigningKeys = nil
	}

	// WebApplicationFirewallPolicyLink
	if endpoint.WebApplicationFirewallPolicyLink != nil {
		var webApplicationFirewallPolicyLink v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink
		err := endpoint.WebApplicationFirewallPolicyLink.AssignPropertiesToEndpointProperties_WebApplicationFirewallPolicyLink(&webApplicationFirewallPolicyLink)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToEndpointProperties_WebApplicationFirewallPolicyLink() to populate field WebApplicationFirewallPolicyLink")
		}
		destination.WebApplicationFirewallPolicyLink = &webApplicationFirewallPolicyLink
	} else {
		destination.WebApplicationFirewallPolicyLink = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (endpoint *ProfilesEndpoint_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (endpoint *ProfilesEndpoint_Spec) SetAzureName(azureName string) { endpoint.AzureName = azureName }

type CustomDomain struct {
	// CustomHttpsParameters: Certificate parameters for securing custom HTTPS
	CustomHttpsParameters *CustomDomainHttpsParameters `json:"customHttpsParameters,omitempty"`

	// CustomHttpsProvisioningState: Provisioning status of the custom domain.
	CustomHttpsProvisioningState *CustomDomainProperties_CustomHttpsProvisioningState `json:"customHttpsProvisioningState,omitempty"`

	// CustomHttpsProvisioningSubstate: Provisioning substate shows the progress of custom HTTPS enabling/disabling process
	// step by step.
	CustomHttpsProvisioningSubstate *CustomDomainProperties_CustomHttpsProvisioningSubstate `json:"customHttpsProvisioningSubstate,omitempty"`

	// +kubebuilder:validation:Required
	// HostName: The host name of the custom domain. Must be a domain name.
	HostName *string `json:"hostName,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// ProvisioningState: Provisioning status of Custom Https of the custom domain.
	ProvisioningState *CustomDomainProperties_ProvisioningState `json:"provisioningState,omitempty"`

	// ResourceState: Resource status of the custom domain.
	ResourceState *CustomDomainProperties_ResourceState `json:"resourceState,omitempty"`
	SystemData    *SystemData                           `json:"systemData,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// ValidationData: Special validation or data may be required when delivering CDN to some regions due to local compliance
	// reasons. E.g. ICP license number of a custom domain is required to deliver content in China.
	ValidationData *string `json:"validationData,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomDomain{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (domain *CustomDomain) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if domain == nil {
		return nil, nil
	}
	result := &CustomDomainARM{}

	// Set property ‘Id’:
	if domain.Id != nil {
		id := *domain.Id
		result.Id = &id
	}

	// Set property ‘Name’:
	if domain.Name != nil {
		name := *domain.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if domain.CustomHttpsParameters != nil ||
		domain.CustomHttpsProvisioningState != nil ||
		domain.CustomHttpsProvisioningSubstate != nil ||
		domain.HostName != nil ||
		domain.ProvisioningState != nil ||
		domain.ResourceState != nil ||
		domain.ValidationData != nil {
		result.Properties = &CustomDomainPropertiesARM{}
	}
	if domain.CustomHttpsParameters != nil {
		customHttpsParametersARM, err := (*domain.CustomHttpsParameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		customHttpsParameters := *customHttpsParametersARM.(*CustomDomainHttpsParametersARM)
		result.Properties.CustomHttpsParameters = &customHttpsParameters
	}
	if domain.CustomHttpsProvisioningState != nil {
		customHttpsProvisioningState := *domain.CustomHttpsProvisioningState
		result.Properties.CustomHttpsProvisioningState = &customHttpsProvisioningState
	}
	if domain.CustomHttpsProvisioningSubstate != nil {
		customHttpsProvisioningSubstate := *domain.CustomHttpsProvisioningSubstate
		result.Properties.CustomHttpsProvisioningSubstate = &customHttpsProvisioningSubstate
	}
	if domain.HostName != nil {
		hostName := *domain.HostName
		result.Properties.HostName = &hostName
	}
	if domain.ProvisioningState != nil {
		provisioningState := *domain.ProvisioningState
		result.Properties.ProvisioningState = &provisioningState
	}
	if domain.ResourceState != nil {
		resourceState := *domain.ResourceState
		result.Properties.ResourceState = &resourceState
	}
	if domain.ValidationData != nil {
		validationData := *domain.ValidationData
		result.Properties.ValidationData = &validationData
	}

	// Set property ‘SystemData’:
	if domain.SystemData != nil {
		systemDataARM, err := (*domain.SystemData).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		systemData := *systemDataARM.(*SystemDataARM)
		result.SystemData = &systemData
	}

	// Set property ‘Type’:
	if domain.Type != nil {
		typeVar := *domain.Type
		result.Type = &typeVar
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (domain *CustomDomain) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CustomDomainARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (domain *CustomDomain) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CustomDomainARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CustomDomainARM, got %T", armInput)
	}

	// Set property ‘CustomHttpsParameters’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomHttpsParameters != nil {
			var customHttpsParameters1 CustomDomainHttpsParameters
			err := customHttpsParameters1.PopulateFromARM(owner, *typedInput.Properties.CustomHttpsParameters)
			if err != nil {
				return err
			}
			customHttpsParameters := customHttpsParameters1
			domain.CustomHttpsParameters = &customHttpsParameters
		}
	}

	// Set property ‘CustomHttpsProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomHttpsProvisioningState != nil {
			customHttpsProvisioningState := *typedInput.Properties.CustomHttpsProvisioningState
			domain.CustomHttpsProvisioningState = &customHttpsProvisioningState
		}
	}

	// Set property ‘CustomHttpsProvisioningSubstate’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomHttpsProvisioningSubstate != nil {
			customHttpsProvisioningSubstate := *typedInput.Properties.CustomHttpsProvisioningSubstate
			domain.CustomHttpsProvisioningSubstate = &customHttpsProvisioningSubstate
		}
	}

	// Set property ‘HostName’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			domain.HostName = &hostName
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		domain.Id = &id
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		domain.Name = &name
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			domain.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ResourceState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceState != nil {
			resourceState := *typedInput.Properties.ResourceState
			domain.ResourceState = &resourceState
		}
	}

	// Set property ‘SystemData’:
	if typedInput.SystemData != nil {
		var systemData1 SystemData
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		domain.SystemData = &systemData
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		domain.Type = &typeVar
	}

	// Set property ‘ValidationData’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ValidationData != nil {
			validationData := *typedInput.Properties.ValidationData
			domain.ValidationData = &validationData
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromCustomDomain populates our CustomDomain from the provided source CustomDomain
func (domain *CustomDomain) AssignPropertiesFromCustomDomain(source *v20210601s.CustomDomain) error {

	// CustomHttpsParameters
	if source.CustomHttpsParameters != nil {
		var customHttpsParameter CustomDomainHttpsParameters
		err := customHttpsParameter.AssignPropertiesFromCustomDomainHttpsParameters(source.CustomHttpsParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromCustomDomainHttpsParameters() to populate field CustomHttpsParameters")
		}
		domain.CustomHttpsParameters = &customHttpsParameter
	} else {
		domain.CustomHttpsParameters = nil
	}

	// CustomHttpsProvisioningState
	if source.CustomHttpsProvisioningState != nil {
		customHttpsProvisioningState := CustomDomainProperties_CustomHttpsProvisioningState(*source.CustomHttpsProvisioningState)
		domain.CustomHttpsProvisioningState = &customHttpsProvisioningState
	} else {
		domain.CustomHttpsProvisioningState = nil
	}

	// CustomHttpsProvisioningSubstate
	if source.CustomHttpsProvisioningSubstate != nil {
		customHttpsProvisioningSubstate := CustomDomainProperties_CustomHttpsProvisioningSubstate(*source.CustomHttpsProvisioningSubstate)
		domain.CustomHttpsProvisioningSubstate = &customHttpsProvisioningSubstate
	} else {
		domain.CustomHttpsProvisioningSubstate = nil
	}

	// HostName
	domain.HostName = genruntime.ClonePointerToString(source.HostName)

	// Id
	domain.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	domain.Name = genruntime.ClonePointerToString(source.Name)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := CustomDomainProperties_ProvisioningState(*source.ProvisioningState)
		domain.ProvisioningState = &provisioningState
	} else {
		domain.ProvisioningState = nil
	}

	// ResourceState
	if source.ResourceState != nil {
		resourceState := CustomDomainProperties_ResourceState(*source.ResourceState)
		domain.ResourceState = &resourceState
	} else {
		domain.ResourceState = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData
		err := systemDatum.AssignPropertiesFromSystemData(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSystemData() to populate field SystemData")
		}
		domain.SystemData = &systemDatum
	} else {
		domain.SystemData = nil
	}

	// Type
	domain.Type = genruntime.ClonePointerToString(source.Type)

	// ValidationData
	domain.ValidationData = genruntime.ClonePointerToString(source.ValidationData)

	// No error
	return nil
}

// AssignPropertiesToCustomDomain populates the provided destination CustomDomain from our CustomDomain
func (domain *CustomDomain) AssignPropertiesToCustomDomain(destination *v20210601s.CustomDomain) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomHttpsParameters
	if domain.CustomHttpsParameters != nil {
		var customHttpsParameter v20210601s.CustomDomainHttpsParameters
		err := domain.CustomHttpsParameters.AssignPropertiesToCustomDomainHttpsParameters(&customHttpsParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToCustomDomainHttpsParameters() to populate field CustomHttpsParameters")
		}
		destination.CustomHttpsParameters = &customHttpsParameter
	} else {
		destination.CustomHttpsParameters = nil
	}

	// CustomHttpsProvisioningState
	if domain.CustomHttpsProvisioningState != nil {
		customHttpsProvisioningState := string(*domain.CustomHttpsProvisioningState)
		destination.CustomHttpsProvisioningState = &customHttpsProvisioningState
	} else {
		destination.CustomHttpsProvisioningState = nil
	}

	// CustomHttpsProvisioningSubstate
	if domain.CustomHttpsProvisioningSubstate != nil {
		customHttpsProvisioningSubstate := string(*domain.CustomHttpsProvisioningSubstate)
		destination.CustomHttpsProvisioningSubstate = &customHttpsProvisioningSubstate
	} else {
		destination.CustomHttpsProvisioningSubstate = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(domain.HostName)

	// Id
	destination.Id = genruntime.ClonePointerToString(domain.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(domain.Name)

	// ProvisioningState
	if domain.ProvisioningState != nil {
		provisioningState := string(*domain.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceState
	if domain.ResourceState != nil {
		resourceState := string(*domain.ResourceState)
		destination.ResourceState = &resourceState
	} else {
		destination.ResourceState = nil
	}

	// SystemData
	if domain.SystemData != nil {
		var systemDatum v20210601s.SystemData
		err := domain.SystemData.AssignPropertiesToSystemData(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSystemData() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(domain.Type)

	// ValidationData
	destination.ValidationData = genruntime.ClonePointerToString(domain.ValidationData)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CustomDomain_STATUS struct {
	// CustomHttpsParameters: Certificate parameters for securing custom HTTPS
	CustomHttpsParameters *CustomDomainHttpsParameters_STATUS `json:"customHttpsParameters,omitempty"`

	// CustomHttpsProvisioningState: Provisioning status of the custom domain.
	CustomHttpsProvisioningState *CustomDomainProperties_CustomHttpsProvisioningState_STATUS `json:"customHttpsProvisioningState,omitempty"`

	// CustomHttpsProvisioningSubstate: Provisioning substate shows the progress of custom HTTPS enabling/disabling process
	// step by step.
	CustomHttpsProvisioningSubstate *CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUS `json:"customHttpsProvisioningSubstate,omitempty"`

	// HostName: The host name of the custom domain. Must be a domain name.
	HostName *string `json:"hostName,omitempty"`

	// Id: Resource ID.
	Id *string `json:"id,omitempty"`

	// Name: Resource name.
	Name *string `json:"name,omitempty"`

	// ProvisioningState: Provisioning status of Custom Https of the custom domain.
	ProvisioningState *CustomDomainProperties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`

	// ResourceState: Resource status of the custom domain.
	ResourceState *CustomDomainProperties_ResourceState_STATUS `json:"resourceState,omitempty"`
	SystemData    *SystemData_STATUS                           `json:"systemData,omitempty"`

	// Type: Resource type.
	Type *string `json:"type,omitempty"`

	// ValidationData: Special validation or data may be required when delivering CDN to some regions due to local compliance
	// reasons. E.g. ICP license number of a custom domain is required to deliver content in China.
	ValidationData *string `json:"validationData,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomDomain_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (domain *CustomDomain_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CustomDomain_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (domain *CustomDomain_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CustomDomain_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CustomDomain_STATUSARM, got %T", armInput)
	}

	// Set property ‘CustomHttpsParameters’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomHttpsParameters != nil {
			var customHttpsParameters1 CustomDomainHttpsParameters_STATUS
			err := customHttpsParameters1.PopulateFromARM(owner, *typedInput.Properties.CustomHttpsParameters)
			if err != nil {
				return err
			}
			customHttpsParameters := customHttpsParameters1
			domain.CustomHttpsParameters = &customHttpsParameters
		}
	}

	// Set property ‘CustomHttpsProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomHttpsProvisioningState != nil {
			customHttpsProvisioningState := *typedInput.Properties.CustomHttpsProvisioningState
			domain.CustomHttpsProvisioningState = &customHttpsProvisioningState
		}
	}

	// Set property ‘CustomHttpsProvisioningSubstate’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.CustomHttpsProvisioningSubstate != nil {
			customHttpsProvisioningSubstate := *typedInput.Properties.CustomHttpsProvisioningSubstate
			domain.CustomHttpsProvisioningSubstate = &customHttpsProvisioningSubstate
		}
	}

	// Set property ‘HostName’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			domain.HostName = &hostName
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		domain.Id = &id
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		domain.Name = &name
	}

	// Set property ‘ProvisioningState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ProvisioningState != nil {
			provisioningState := *typedInput.Properties.ProvisioningState
			domain.ProvisioningState = &provisioningState
		}
	}

	// Set property ‘ResourceState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResourceState != nil {
			resourceState := *typedInput.Properties.ResourceState
			domain.ResourceState = &resourceState
		}
	}

	// Set property ‘SystemData’:
	if typedInput.SystemData != nil {
		var systemData1 SystemData_STATUS
		err := systemData1.PopulateFromARM(owner, *typedInput.SystemData)
		if err != nil {
			return err
		}
		systemData := systemData1
		domain.SystemData = &systemData
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		domain.Type = &typeVar
	}

	// Set property ‘ValidationData’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ValidationData != nil {
			validationData := *typedInput.Properties.ValidationData
			domain.ValidationData = &validationData
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromCustomDomain_STATUS populates our CustomDomain_STATUS from the provided source CustomDomain_STATUS
func (domain *CustomDomain_STATUS) AssignPropertiesFromCustomDomain_STATUS(source *v20210601s.CustomDomain_STATUS) error {

	// CustomHttpsParameters
	if source.CustomHttpsParameters != nil {
		var customHttpsParameter CustomDomainHttpsParameters_STATUS
		err := customHttpsParameter.AssignPropertiesFromCustomDomainHttpsParameters_STATUS(source.CustomHttpsParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromCustomDomainHttpsParameters_STATUS() to populate field CustomHttpsParameters")
		}
		domain.CustomHttpsParameters = &customHttpsParameter
	} else {
		domain.CustomHttpsParameters = nil
	}

	// CustomHttpsProvisioningState
	if source.CustomHttpsProvisioningState != nil {
		customHttpsProvisioningState := CustomDomainProperties_CustomHttpsProvisioningState_STATUS(*source.CustomHttpsProvisioningState)
		domain.CustomHttpsProvisioningState = &customHttpsProvisioningState
	} else {
		domain.CustomHttpsProvisioningState = nil
	}

	// CustomHttpsProvisioningSubstate
	if source.CustomHttpsProvisioningSubstate != nil {
		customHttpsProvisioningSubstate := CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUS(*source.CustomHttpsProvisioningSubstate)
		domain.CustomHttpsProvisioningSubstate = &customHttpsProvisioningSubstate
	} else {
		domain.CustomHttpsProvisioningSubstate = nil
	}

	// HostName
	domain.HostName = genruntime.ClonePointerToString(source.HostName)

	// Id
	domain.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	domain.Name = genruntime.ClonePointerToString(source.Name)

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := CustomDomainProperties_ProvisioningState_STATUS(*source.ProvisioningState)
		domain.ProvisioningState = &provisioningState
	} else {
		domain.ProvisioningState = nil
	}

	// ResourceState
	if source.ResourceState != nil {
		resourceState := CustomDomainProperties_ResourceState_STATUS(*source.ResourceState)
		domain.ResourceState = &resourceState
	} else {
		domain.ResourceState = nil
	}

	// SystemData
	if source.SystemData != nil {
		var systemDatum SystemData_STATUS
		err := systemDatum.AssignPropertiesFromSystemData_STATUS(source.SystemData)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSystemData_STATUS() to populate field SystemData")
		}
		domain.SystemData = &systemDatum
	} else {
		domain.SystemData = nil
	}

	// Type
	domain.Type = genruntime.ClonePointerToString(source.Type)

	// ValidationData
	domain.ValidationData = genruntime.ClonePointerToString(source.ValidationData)

	// No error
	return nil
}

// AssignPropertiesToCustomDomain_STATUS populates the provided destination CustomDomain_STATUS from our CustomDomain_STATUS
func (domain *CustomDomain_STATUS) AssignPropertiesToCustomDomain_STATUS(destination *v20210601s.CustomDomain_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CustomHttpsParameters
	if domain.CustomHttpsParameters != nil {
		var customHttpsParameter v20210601s.CustomDomainHttpsParameters_STATUS
		err := domain.CustomHttpsParameters.AssignPropertiesToCustomDomainHttpsParameters_STATUS(&customHttpsParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToCustomDomainHttpsParameters_STATUS() to populate field CustomHttpsParameters")
		}
		destination.CustomHttpsParameters = &customHttpsParameter
	} else {
		destination.CustomHttpsParameters = nil
	}

	// CustomHttpsProvisioningState
	if domain.CustomHttpsProvisioningState != nil {
		customHttpsProvisioningState := string(*domain.CustomHttpsProvisioningState)
		destination.CustomHttpsProvisioningState = &customHttpsProvisioningState
	} else {
		destination.CustomHttpsProvisioningState = nil
	}

	// CustomHttpsProvisioningSubstate
	if domain.CustomHttpsProvisioningSubstate != nil {
		customHttpsProvisioningSubstate := string(*domain.CustomHttpsProvisioningSubstate)
		destination.CustomHttpsProvisioningSubstate = &customHttpsProvisioningSubstate
	} else {
		destination.CustomHttpsProvisioningSubstate = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(domain.HostName)

	// Id
	destination.Id = genruntime.ClonePointerToString(domain.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(domain.Name)

	// ProvisioningState
	if domain.ProvisioningState != nil {
		provisioningState := string(*domain.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// ResourceState
	if domain.ResourceState != nil {
		resourceState := string(*domain.ResourceState)
		destination.ResourceState = &resourceState
	} else {
		destination.ResourceState = nil
	}

	// SystemData
	if domain.SystemData != nil {
		var systemDatum v20210601s.SystemData_STATUS
		err := domain.SystemData.AssignPropertiesToSystemData_STATUS(&systemDatum)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSystemData_STATUS() to populate field SystemData")
		}
		destination.SystemData = &systemDatum
	} else {
		destination.SystemData = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(domain.Type)

	// ValidationData
	destination.ValidationData = genruntime.ClonePointerToString(domain.ValidationData)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeepCreatedOrigin struct {
	// Enabled: Origin is enabled for load balancing or not. By default, origin is always enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// +kubebuilder:validation:Required
	// HostName: The address of the origin. It can be a domain name, IPv4 address, or IPv6 address. This should be unique
	// across all origins in an endpoint.
	HostName *string `json:"hostName,omitempty"`

	// +kubebuilder:validation:Maximum=65535
	// +kubebuilder:validation:Minimum=1
	// HttpPort: The value of the HTTP port. Must be between 1 and 65535.
	HttpPort *int `json:"httpPort,omitempty"`

	// +kubebuilder:validation:Maximum=65535
	// +kubebuilder:validation:Minimum=1
	// HttpsPort: The value of the HTTPS port. Must be between 1 and 65535.
	HttpsPort *int `json:"httpsPort,omitempty"`

	// +kubebuilder:validation:Required
	// Name: Origin name which must be unique within the endpoint.
	Name *string `json:"name,omitempty"`

	// OriginHostHeader: The host header value sent to the origin with each request. If you leave this blank, the request
	// hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this host
	// header value to match the origin hostname by default.
	OriginHostHeader *string `json:"originHostHeader,omitempty"`

	// +kubebuilder:validation:Maximum=5
	// +kubebuilder:validation:Minimum=1
	// Priority: Priority of origin in given origin group for load balancing. Higher priorities will not be used for load
	// balancing if any lower priority origin is healthy.Must be between 1 and 5.
	Priority *int `json:"priority,omitempty"`

	// PrivateEndpointStatus: The approval status for the connection to the Private Link
	PrivateEndpointStatus *PrivateEndpointStatus `json:"privateEndpointStatus,omitempty"`

	// PrivateLinkAlias: The Alias of the Private Link resource. Populating this optional field indicates that this origin is
	// 'Private'
	PrivateLinkAlias *string `json:"privateLinkAlias,omitempty"`

	// PrivateLinkApprovalMessage: A custom message to be included in the approval request to connect to the Private Link.
	PrivateLinkApprovalMessage *string `json:"privateLinkApprovalMessage,omitempty"`

	// PrivateLinkLocationReference: The location of the Private Link resource. Required only if 'privateLinkResourceId' is
	// populated
	PrivateLinkLocationReference *genruntime.ResourceReference `armReference:"PrivateLinkLocation" json:"privateLinkLocationReference,omitempty"`

	// PrivateLinkResourceReference: The Resource Id of the Private Link resource. Populating this optional field indicates
	// that this backend is 'Private'
	PrivateLinkResourceReference *genruntime.ResourceReference `armReference:"PrivateLinkResourceId" json:"privateLinkResourceReference,omitempty"`

	// +kubebuilder:validation:Maximum=1000
	// +kubebuilder:validation:Minimum=1
	// Weight: Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.ARMTransformer = &DeepCreatedOrigin{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (origin *DeepCreatedOrigin) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if origin == nil {
		return nil, nil
	}
	result := &DeepCreatedOriginARM{}

	// Set property ‘Name’:
	if origin.Name != nil {
		name := *origin.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if origin.Enabled != nil ||
		origin.HostName != nil ||
		origin.HttpPort != nil ||
		origin.HttpsPort != nil ||
		origin.OriginHostHeader != nil ||
		origin.Priority != nil ||
		origin.PrivateEndpointStatus != nil ||
		origin.PrivateLinkAlias != nil ||
		origin.PrivateLinkApprovalMessage != nil ||
		origin.PrivateLinkLocationReference != nil ||
		origin.PrivateLinkResourceReference != nil ||
		origin.Weight != nil {
		result.Properties = &DeepCreatedOriginPropertiesARM{}
	}
	if origin.Enabled != nil {
		enabled := *origin.Enabled
		result.Properties.Enabled = &enabled
	}
	if origin.HostName != nil {
		hostName := *origin.HostName
		result.Properties.HostName = &hostName
	}
	if origin.HttpPort != nil {
		httpPort := *origin.HttpPort
		result.Properties.HttpPort = &httpPort
	}
	if origin.HttpsPort != nil {
		httpsPort := *origin.HttpsPort
		result.Properties.HttpsPort = &httpsPort
	}
	if origin.OriginHostHeader != nil {
		originHostHeader := *origin.OriginHostHeader
		result.Properties.OriginHostHeader = &originHostHeader
	}
	if origin.Priority != nil {
		priority := *origin.Priority
		result.Properties.Priority = &priority
	}
	if origin.PrivateEndpointStatus != nil {
		privateEndpointStatus := *origin.PrivateEndpointStatus
		result.Properties.PrivateEndpointStatus = &privateEndpointStatus
	}
	if origin.PrivateLinkAlias != nil {
		privateLinkAlias := *origin.PrivateLinkAlias
		result.Properties.PrivateLinkAlias = &privateLinkAlias
	}
	if origin.PrivateLinkApprovalMessage != nil {
		privateLinkApprovalMessage := *origin.PrivateLinkApprovalMessage
		result.Properties.PrivateLinkApprovalMessage = &privateLinkApprovalMessage
	}
	if origin.PrivateLinkLocationReference != nil {
		privateLinkLocationARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*origin.PrivateLinkLocationReference)
		if err != nil {
			return nil, err
		}
		privateLinkLocation := privateLinkLocationARMID
		result.Properties.PrivateLinkLocation = &privateLinkLocation
	}
	if origin.PrivateLinkResourceReference != nil {
		privateLinkResourceIdARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*origin.PrivateLinkResourceReference)
		if err != nil {
			return nil, err
		}
		privateLinkResourceId := privateLinkResourceIdARMID
		result.Properties.PrivateLinkResourceId = &privateLinkResourceId
	}
	if origin.Weight != nil {
		weight := *origin.Weight
		result.Properties.Weight = &weight
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (origin *DeepCreatedOrigin) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeepCreatedOriginARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (origin *DeepCreatedOrigin) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeepCreatedOriginARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeepCreatedOriginARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			origin.Enabled = &enabled
		}
	}

	// Set property ‘HostName’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			origin.HostName = &hostName
		}
	}

	// Set property ‘HttpPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpPort != nil {
			httpPort := *typedInput.Properties.HttpPort
			origin.HttpPort = &httpPort
		}
	}

	// Set property ‘HttpsPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpsPort != nil {
			httpsPort := *typedInput.Properties.HttpsPort
			origin.HttpsPort = &httpsPort
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		origin.Name = &name
	}

	// Set property ‘OriginHostHeader’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OriginHostHeader != nil {
			originHostHeader := *typedInput.Properties.OriginHostHeader
			origin.OriginHostHeader = &originHostHeader
		}
	}

	// Set property ‘Priority’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			origin.Priority = &priority
		}
	}

	// Set property ‘PrivateEndpointStatus’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateEndpointStatus != nil {
			privateEndpointStatus := *typedInput.Properties.PrivateEndpointStatus
			origin.PrivateEndpointStatus = &privateEndpointStatus
		}
	}

	// Set property ‘PrivateLinkAlias’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkAlias != nil {
			privateLinkAlias := *typedInput.Properties.PrivateLinkAlias
			origin.PrivateLinkAlias = &privateLinkAlias
		}
	}

	// Set property ‘PrivateLinkApprovalMessage’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkApprovalMessage != nil {
			privateLinkApprovalMessage := *typedInput.Properties.PrivateLinkApprovalMessage
			origin.PrivateLinkApprovalMessage = &privateLinkApprovalMessage
		}
	}

	// no assignment for property ‘PrivateLinkLocationReference’

	// no assignment for property ‘PrivateLinkResourceReference’

	// Set property ‘Weight’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Weight != nil {
			weight := *typedInput.Properties.Weight
			origin.Weight = &weight
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromDeepCreatedOrigin populates our DeepCreatedOrigin from the provided source DeepCreatedOrigin
func (origin *DeepCreatedOrigin) AssignPropertiesFromDeepCreatedOrigin(source *v20210601s.DeepCreatedOrigin) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		origin.Enabled = &enabled
	} else {
		origin.Enabled = nil
	}

	// HostName
	origin.HostName = genruntime.ClonePointerToString(source.HostName)

	// HttpPort
	if source.HttpPort != nil {
		httpPort := *source.HttpPort
		origin.HttpPort = &httpPort
	} else {
		origin.HttpPort = nil
	}

	// HttpsPort
	if source.HttpsPort != nil {
		httpsPort := *source.HttpsPort
		origin.HttpsPort = &httpsPort
	} else {
		origin.HttpsPort = nil
	}

	// Name
	origin.Name = genruntime.ClonePointerToString(source.Name)

	// OriginHostHeader
	origin.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// Priority
	if source.Priority != nil {
		priority := *source.Priority
		origin.Priority = &priority
	} else {
		origin.Priority = nil
	}

	// PrivateEndpointStatus
	if source.PrivateEndpointStatus != nil {
		privateEndpointStatus := PrivateEndpointStatus(*source.PrivateEndpointStatus)
		origin.PrivateEndpointStatus = &privateEndpointStatus
	} else {
		origin.PrivateEndpointStatus = nil
	}

	// PrivateLinkAlias
	origin.PrivateLinkAlias = genruntime.ClonePointerToString(source.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	origin.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(source.PrivateLinkApprovalMessage)

	// PrivateLinkLocationReference
	if source.PrivateLinkLocationReference != nil {
		privateLinkLocationReference := source.PrivateLinkLocationReference.Copy()
		origin.PrivateLinkLocationReference = &privateLinkLocationReference
	} else {
		origin.PrivateLinkLocationReference = nil
	}

	// PrivateLinkResourceReference
	if source.PrivateLinkResourceReference != nil {
		privateLinkResourceReference := source.PrivateLinkResourceReference.Copy()
		origin.PrivateLinkResourceReference = &privateLinkResourceReference
	} else {
		origin.PrivateLinkResourceReference = nil
	}

	// Weight
	if source.Weight != nil {
		weight := *source.Weight
		origin.Weight = &weight
	} else {
		origin.Weight = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeepCreatedOrigin populates the provided destination DeepCreatedOrigin from our DeepCreatedOrigin
func (origin *DeepCreatedOrigin) AssignPropertiesToDeepCreatedOrigin(destination *v20210601s.DeepCreatedOrigin) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if origin.Enabled != nil {
		enabled := *origin.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(origin.HostName)

	// HttpPort
	if origin.HttpPort != nil {
		httpPort := *origin.HttpPort
		destination.HttpPort = &httpPort
	} else {
		destination.HttpPort = nil
	}

	// HttpsPort
	if origin.HttpsPort != nil {
		httpsPort := *origin.HttpsPort
		destination.HttpsPort = &httpsPort
	} else {
		destination.HttpsPort = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(origin.Name)

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(origin.OriginHostHeader)

	// Priority
	if origin.Priority != nil {
		priority := *origin.Priority
		destination.Priority = &priority
	} else {
		destination.Priority = nil
	}

	// PrivateEndpointStatus
	if origin.PrivateEndpointStatus != nil {
		privateEndpointStatus := string(*origin.PrivateEndpointStatus)
		destination.PrivateEndpointStatus = &privateEndpointStatus
	} else {
		destination.PrivateEndpointStatus = nil
	}

	// PrivateLinkAlias
	destination.PrivateLinkAlias = genruntime.ClonePointerToString(origin.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	destination.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(origin.PrivateLinkApprovalMessage)

	// PrivateLinkLocationReference
	if origin.PrivateLinkLocationReference != nil {
		privateLinkLocationReference := origin.PrivateLinkLocationReference.Copy()
		destination.PrivateLinkLocationReference = &privateLinkLocationReference
	} else {
		destination.PrivateLinkLocationReference = nil
	}

	// PrivateLinkResourceReference
	if origin.PrivateLinkResourceReference != nil {
		privateLinkResourceReference := origin.PrivateLinkResourceReference.Copy()
		destination.PrivateLinkResourceReference = &privateLinkResourceReference
	} else {
		destination.PrivateLinkResourceReference = nil
	}

	// Weight
	if origin.Weight != nil {
		weight := *origin.Weight
		destination.Weight = &weight
	} else {
		destination.Weight = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeepCreatedOriginGroup struct {
	// HealthProbeSettings: Health probe settings to the origin that is used to determine the health of the origin.
	HealthProbeSettings *HealthProbeParameters `json:"healthProbeSettings,omitempty"`

	// +kubebuilder:validation:Required
	// Name: Origin group name which must be unique within the endpoint.
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Origins: The source of the content being delivered via CDN within given origin group.
	Origins []ResourceReference `json:"origins,omitempty"`

	// ResponseBasedOriginErrorDetectionSettings: The JSON object that contains the properties to determine origin health using
	// real requests/responses.This property is currently not supported.
	ResponseBasedOriginErrorDetectionSettings *ResponseBasedOriginErrorDetectionParameters `json:"responseBasedOriginErrorDetectionSettings,omitempty"`

	// +kubebuilder:validation:Maximum=50
	// +kubebuilder:validation:Minimum=0
	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes: Time in minutes to shift the traffic to the endpoint gradually
	// when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not
	// supported.
	TrafficRestorationTimeToHealedOrNewEndpointsInMinutes *int `json:"trafficRestorationTimeToHealedOrNewEndpointsInMinutes,omitempty"`
}

var _ genruntime.ARMTransformer = &DeepCreatedOriginGroup{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (group *DeepCreatedOriginGroup) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if group == nil {
		return nil, nil
	}
	result := &DeepCreatedOriginGroupARM{}

	// Set property ‘Name’:
	if group.Name != nil {
		name := *group.Name
		result.Name = &name
	}

	// Set property ‘Properties’:
	if group.HealthProbeSettings != nil ||
		group.Origins != nil ||
		group.ResponseBasedOriginErrorDetectionSettings != nil ||
		group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes != nil {
		result.Properties = &DeepCreatedOriginGroupPropertiesARM{}
	}
	if group.HealthProbeSettings != nil {
		healthProbeSettingsARM, err := (*group.HealthProbeSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		healthProbeSettings := *healthProbeSettingsARM.(*HealthProbeParametersARM)
		result.Properties.HealthProbeSettings = &healthProbeSettings
	}
	for _, item := range group.Origins {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Properties.Origins = append(result.Properties.Origins, *itemARM.(*ResourceReferenceARM))
	}
	if group.ResponseBasedOriginErrorDetectionSettings != nil {
		responseBasedOriginErrorDetectionSettingsARM, err := (*group.ResponseBasedOriginErrorDetectionSettings).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		responseBasedOriginErrorDetectionSettings := *responseBasedOriginErrorDetectionSettingsARM.(*ResponseBasedOriginErrorDetectionParametersARM)
		result.Properties.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSettings
	}
	if group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes != nil {
		trafficRestorationTimeToHealedOrNewEndpointsInMinutes := *group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
		result.Properties.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = &trafficRestorationTimeToHealedOrNewEndpointsInMinutes
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *DeepCreatedOriginGroup) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeepCreatedOriginGroupARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *DeepCreatedOriginGroup) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeepCreatedOriginGroupARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeepCreatedOriginGroupARM, got %T", armInput)
	}

	// Set property ‘HealthProbeSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HealthProbeSettings != nil {
			var healthProbeSettings1 HealthProbeParameters
			err := healthProbeSettings1.PopulateFromARM(owner, *typedInput.Properties.HealthProbeSettings)
			if err != nil {
				return err
			}
			healthProbeSettings := healthProbeSettings1
			group.HealthProbeSettings = &healthProbeSettings
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		group.Name = &name
	}

	// Set property ‘Origins’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Origins {
			var item1 ResourceReference
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.Origins = append(group.Origins, item1)
		}
	}

	// Set property ‘ResponseBasedOriginErrorDetectionSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResponseBasedOriginErrorDetectionSettings != nil {
			var responseBasedOriginErrorDetectionSettings1 ResponseBasedOriginErrorDetectionParameters
			err := responseBasedOriginErrorDetectionSettings1.PopulateFromARM(owner, *typedInput.Properties.ResponseBasedOriginErrorDetectionSettings)
			if err != nil {
				return err
			}
			responseBasedOriginErrorDetectionSettings := responseBasedOriginErrorDetectionSettings1
			group.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSettings
		}
	}

	// Set property ‘TrafficRestorationTimeToHealedOrNewEndpointsInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes != nil {
			trafficRestorationTimeToHealedOrNewEndpointsInMinutes := *typedInput.Properties.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
			group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = &trafficRestorationTimeToHealedOrNewEndpointsInMinutes
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromDeepCreatedOriginGroup populates our DeepCreatedOriginGroup from the provided source DeepCreatedOriginGroup
func (group *DeepCreatedOriginGroup) AssignPropertiesFromDeepCreatedOriginGroup(source *v20210601s.DeepCreatedOriginGroup) error {

	// HealthProbeSettings
	if source.HealthProbeSettings != nil {
		var healthProbeSetting HealthProbeParameters
		err := healthProbeSetting.AssignPropertiesFromHealthProbeParameters(source.HealthProbeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromHealthProbeParameters() to populate field HealthProbeSettings")
		}
		group.HealthProbeSettings = &healthProbeSetting
	} else {
		group.HealthProbeSettings = nil
	}

	// Name
	group.Name = genruntime.ClonePointerToString(source.Name)

	// Origins
	if source.Origins != nil {
		originList := make([]ResourceReference, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin ResourceReference
			err := origin.AssignPropertiesFromResourceReference(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromResourceReference() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		group.Origins = originList
	} else {
		group.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if source.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting ResponseBasedOriginErrorDetectionParameters
		err := responseBasedOriginErrorDetectionSetting.AssignPropertiesFromResponseBasedOriginErrorDetectionParameters(source.ResponseBasedOriginErrorDetectionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResponseBasedOriginErrorDetectionParameters() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		group.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		group.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	if source.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes != nil {
		trafficRestorationTimeToHealedOrNewEndpointsInMinute := *source.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
		group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = &trafficRestorationTimeToHealedOrNewEndpointsInMinute
	} else {
		group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeepCreatedOriginGroup populates the provided destination DeepCreatedOriginGroup from our DeepCreatedOriginGroup
func (group *DeepCreatedOriginGroup) AssignPropertiesToDeepCreatedOriginGroup(destination *v20210601s.DeepCreatedOriginGroup) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HealthProbeSettings
	if group.HealthProbeSettings != nil {
		var healthProbeSetting v20210601s.HealthProbeParameters
		err := group.HealthProbeSettings.AssignPropertiesToHealthProbeParameters(&healthProbeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToHealthProbeParameters() to populate field HealthProbeSettings")
		}
		destination.HealthProbeSettings = &healthProbeSetting
	} else {
		destination.HealthProbeSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(group.Name)

	// Origins
	if group.Origins != nil {
		originList := make([]v20210601s.ResourceReference, len(group.Origins))
		for originIndex, originItem := range group.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin v20210601s.ResourceReference
			err := originItem.AssignPropertiesToResourceReference(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToResourceReference() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if group.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting v20210601s.ResponseBasedOriginErrorDetectionParameters
		err := group.ResponseBasedOriginErrorDetectionSettings.AssignPropertiesToResponseBasedOriginErrorDetectionParameters(&responseBasedOriginErrorDetectionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResponseBasedOriginErrorDetectionParameters() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		destination.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		destination.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	if group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes != nil {
		trafficRestorationTimeToHealedOrNewEndpointsInMinute := *group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
		destination.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = &trafficRestorationTimeToHealedOrNewEndpointsInMinute
	} else {
		destination.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeepCreatedOriginGroup_STATUS struct {
	// HealthProbeSettings: Health probe settings to the origin that is used to determine the health of the origin.
	HealthProbeSettings *HealthProbeParameters_STATUS `json:"healthProbeSettings,omitempty"`

	// Name: Origin group name which must be unique within the endpoint.
	Name *string `json:"name,omitempty"`

	// Origins: The source of the content being delivered via CDN within given origin group.
	Origins []ResourceReference_STATUS `json:"origins,omitempty"`

	// ResponseBasedOriginErrorDetectionSettings: The JSON object that contains the properties to determine origin health using
	// real requests/responses.This property is currently not supported.
	ResponseBasedOriginErrorDetectionSettings *ResponseBasedOriginErrorDetectionParameters_STATUS `json:"responseBasedOriginErrorDetectionSettings,omitempty"`

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes: Time in minutes to shift the traffic to the endpoint gradually
	// when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not
	// supported.
	TrafficRestorationTimeToHealedOrNewEndpointsInMinutes *int `json:"trafficRestorationTimeToHealedOrNewEndpointsInMinutes,omitempty"`
}

var _ genruntime.FromARMConverter = &DeepCreatedOriginGroup_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (group *DeepCreatedOriginGroup_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeepCreatedOriginGroup_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (group *DeepCreatedOriginGroup_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeepCreatedOriginGroup_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeepCreatedOriginGroup_STATUSARM, got %T", armInput)
	}

	// Set property ‘HealthProbeSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HealthProbeSettings != nil {
			var healthProbeSettings1 HealthProbeParameters_STATUS
			err := healthProbeSettings1.PopulateFromARM(owner, *typedInput.Properties.HealthProbeSettings)
			if err != nil {
				return err
			}
			healthProbeSettings := healthProbeSettings1
			group.HealthProbeSettings = &healthProbeSettings
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		group.Name = &name
	}

	// Set property ‘Origins’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.Origins {
			var item1 ResourceReference_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			group.Origins = append(group.Origins, item1)
		}
	}

	// Set property ‘ResponseBasedOriginErrorDetectionSettings’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ResponseBasedOriginErrorDetectionSettings != nil {
			var responseBasedOriginErrorDetectionSettings1 ResponseBasedOriginErrorDetectionParameters_STATUS
			err := responseBasedOriginErrorDetectionSettings1.PopulateFromARM(owner, *typedInput.Properties.ResponseBasedOriginErrorDetectionSettings)
			if err != nil {
				return err
			}
			responseBasedOriginErrorDetectionSettings := responseBasedOriginErrorDetectionSettings1
			group.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSettings
		}
	}

	// Set property ‘TrafficRestorationTimeToHealedOrNewEndpointsInMinutes’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes != nil {
			trafficRestorationTimeToHealedOrNewEndpointsInMinutes := *typedInput.Properties.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
			group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = &trafficRestorationTimeToHealedOrNewEndpointsInMinutes
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromDeepCreatedOriginGroup_STATUS populates our DeepCreatedOriginGroup_STATUS from the provided source DeepCreatedOriginGroup_STATUS
func (group *DeepCreatedOriginGroup_STATUS) AssignPropertiesFromDeepCreatedOriginGroup_STATUS(source *v20210601s.DeepCreatedOriginGroup_STATUS) error {

	// HealthProbeSettings
	if source.HealthProbeSettings != nil {
		var healthProbeSetting HealthProbeParameters_STATUS
		err := healthProbeSetting.AssignPropertiesFromHealthProbeParameters_STATUS(source.HealthProbeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromHealthProbeParameters_STATUS() to populate field HealthProbeSettings")
		}
		group.HealthProbeSettings = &healthProbeSetting
	} else {
		group.HealthProbeSettings = nil
	}

	// Name
	group.Name = genruntime.ClonePointerToString(source.Name)

	// Origins
	if source.Origins != nil {
		originList := make([]ResourceReference_STATUS, len(source.Origins))
		for originIndex, originItem := range source.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin ResourceReference_STATUS
			err := origin.AssignPropertiesFromResourceReference_STATUS(&originItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromResourceReference_STATUS() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		group.Origins = originList
	} else {
		group.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if source.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting ResponseBasedOriginErrorDetectionParameters_STATUS
		err := responseBasedOriginErrorDetectionSetting.AssignPropertiesFromResponseBasedOriginErrorDetectionParameters_STATUS(source.ResponseBasedOriginErrorDetectionSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromResponseBasedOriginErrorDetectionParameters_STATUS() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		group.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		group.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = genruntime.ClonePointerToInt(source.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)

	// No error
	return nil
}

// AssignPropertiesToDeepCreatedOriginGroup_STATUS populates the provided destination DeepCreatedOriginGroup_STATUS from our DeepCreatedOriginGroup_STATUS
func (group *DeepCreatedOriginGroup_STATUS) AssignPropertiesToDeepCreatedOriginGroup_STATUS(destination *v20210601s.DeepCreatedOriginGroup_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HealthProbeSettings
	if group.HealthProbeSettings != nil {
		var healthProbeSetting v20210601s.HealthProbeParameters_STATUS
		err := group.HealthProbeSettings.AssignPropertiesToHealthProbeParameters_STATUS(&healthProbeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToHealthProbeParameters_STATUS() to populate field HealthProbeSettings")
		}
		destination.HealthProbeSettings = &healthProbeSetting
	} else {
		destination.HealthProbeSettings = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(group.Name)

	// Origins
	if group.Origins != nil {
		originList := make([]v20210601s.ResourceReference_STATUS, len(group.Origins))
		for originIndex, originItem := range group.Origins {
			// Shadow the loop variable to avoid aliasing
			originItem := originItem
			var origin v20210601s.ResourceReference_STATUS
			err := originItem.AssignPropertiesToResourceReference_STATUS(&origin)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToResourceReference_STATUS() to populate field Origins")
			}
			originList[originIndex] = origin
		}
		destination.Origins = originList
	} else {
		destination.Origins = nil
	}

	// ResponseBasedOriginErrorDetectionSettings
	if group.ResponseBasedOriginErrorDetectionSettings != nil {
		var responseBasedOriginErrorDetectionSetting v20210601s.ResponseBasedOriginErrorDetectionParameters_STATUS
		err := group.ResponseBasedOriginErrorDetectionSettings.AssignPropertiesToResponseBasedOriginErrorDetectionParameters_STATUS(&responseBasedOriginErrorDetectionSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToResponseBasedOriginErrorDetectionParameters_STATUS() to populate field ResponseBasedOriginErrorDetectionSettings")
		}
		destination.ResponseBasedOriginErrorDetectionSettings = &responseBasedOriginErrorDetectionSetting
	} else {
		destination.ResponseBasedOriginErrorDetectionSettings = nil
	}

	// TrafficRestorationTimeToHealedOrNewEndpointsInMinutes
	destination.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes = genruntime.ClonePointerToInt(group.TrafficRestorationTimeToHealedOrNewEndpointsInMinutes)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeepCreatedOrigin_STATUS struct {
	// Enabled: Origin is enabled for load balancing or not. By default, origin is always enabled.
	Enabled *bool `json:"enabled,omitempty"`

	// HostName: The address of the origin. It can be a domain name, IPv4 address, or IPv6 address. This should be unique
	// across all origins in an endpoint.
	HostName *string `json:"hostName,omitempty"`

	// HttpPort: The value of the HTTP port. Must be between 1 and 65535.
	HttpPort *int `json:"httpPort,omitempty"`

	// HttpsPort: The value of the HTTPS port. Must be between 1 and 65535.
	HttpsPort *int `json:"httpsPort,omitempty"`

	// Name: Origin name which must be unique within the endpoint.
	Name *string `json:"name,omitempty"`

	// OriginHostHeader: The host header value sent to the origin with each request. If you leave this blank, the request
	// hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this host
	// header value to match the origin hostname by default.
	OriginHostHeader *string `json:"originHostHeader,omitempty"`

	// Priority: Priority of origin in given origin group for load balancing. Higher priorities will not be used for load
	// balancing if any lower priority origin is healthy.Must be between 1 and 5.
	Priority *int `json:"priority,omitempty"`

	// PrivateEndpointStatus: The approval status for the connection to the Private Link
	PrivateEndpointStatus *PrivateEndpointStatus_STATUS `json:"privateEndpointStatus,omitempty"`

	// PrivateLinkAlias: The Alias of the Private Link resource. Populating this optional field indicates that this origin is
	// 'Private'
	PrivateLinkAlias *string `json:"privateLinkAlias,omitempty"`

	// PrivateLinkApprovalMessage: A custom message to be included in the approval request to connect to the Private Link.
	PrivateLinkApprovalMessage *string `json:"privateLinkApprovalMessage,omitempty"`

	// PrivateLinkLocation: The location of the Private Link resource. Required only if 'privateLinkResourceId' is populated
	PrivateLinkLocation *string `json:"privateLinkLocation,omitempty"`

	// PrivateLinkResourceId: The Resource Id of the Private Link resource. Populating this optional field indicates that this
	// backend is 'Private'
	PrivateLinkResourceId *string `json:"privateLinkResourceId,omitempty"`

	// Weight: Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
	Weight *int `json:"weight,omitempty"`
}

var _ genruntime.FromARMConverter = &DeepCreatedOrigin_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (origin *DeepCreatedOrigin_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeepCreatedOrigin_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (origin *DeepCreatedOrigin_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeepCreatedOrigin_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeepCreatedOrigin_STATUSARM, got %T", armInput)
	}

	// Set property ‘Enabled’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Enabled != nil {
			enabled := *typedInput.Properties.Enabled
			origin.Enabled = &enabled
		}
	}

	// Set property ‘HostName’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HostName != nil {
			hostName := *typedInput.Properties.HostName
			origin.HostName = &hostName
		}
	}

	// Set property ‘HttpPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpPort != nil {
			httpPort := *typedInput.Properties.HttpPort
			origin.HttpPort = &httpPort
		}
	}

	// Set property ‘HttpsPort’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.HttpsPort != nil {
			httpsPort := *typedInput.Properties.HttpsPort
			origin.HttpsPort = &httpsPort
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		origin.Name = &name
	}

	// Set property ‘OriginHostHeader’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.OriginHostHeader != nil {
			originHostHeader := *typedInput.Properties.OriginHostHeader
			origin.OriginHostHeader = &originHostHeader
		}
	}

	// Set property ‘Priority’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Priority != nil {
			priority := *typedInput.Properties.Priority
			origin.Priority = &priority
		}
	}

	// Set property ‘PrivateEndpointStatus’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateEndpointStatus != nil {
			privateEndpointStatus := *typedInput.Properties.PrivateEndpointStatus
			origin.PrivateEndpointStatus = &privateEndpointStatus
		}
	}

	// Set property ‘PrivateLinkAlias’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkAlias != nil {
			privateLinkAlias := *typedInput.Properties.PrivateLinkAlias
			origin.PrivateLinkAlias = &privateLinkAlias
		}
	}

	// Set property ‘PrivateLinkApprovalMessage’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkApprovalMessage != nil {
			privateLinkApprovalMessage := *typedInput.Properties.PrivateLinkApprovalMessage
			origin.PrivateLinkApprovalMessage = &privateLinkApprovalMessage
		}
	}

	// Set property ‘PrivateLinkLocation’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkLocation != nil {
			privateLinkLocation := *typedInput.Properties.PrivateLinkLocation
			origin.PrivateLinkLocation = &privateLinkLocation
		}
	}

	// Set property ‘PrivateLinkResourceId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PrivateLinkResourceId != nil {
			privateLinkResourceId := *typedInput.Properties.PrivateLinkResourceId
			origin.PrivateLinkResourceId = &privateLinkResourceId
		}
	}

	// Set property ‘Weight’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Weight != nil {
			weight := *typedInput.Properties.Weight
			origin.Weight = &weight
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromDeepCreatedOrigin_STATUS populates our DeepCreatedOrigin_STATUS from the provided source DeepCreatedOrigin_STATUS
func (origin *DeepCreatedOrigin_STATUS) AssignPropertiesFromDeepCreatedOrigin_STATUS(source *v20210601s.DeepCreatedOrigin_STATUS) error {

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		origin.Enabled = &enabled
	} else {
		origin.Enabled = nil
	}

	// HostName
	origin.HostName = genruntime.ClonePointerToString(source.HostName)

	// HttpPort
	origin.HttpPort = genruntime.ClonePointerToInt(source.HttpPort)

	// HttpsPort
	origin.HttpsPort = genruntime.ClonePointerToInt(source.HttpsPort)

	// Name
	origin.Name = genruntime.ClonePointerToString(source.Name)

	// OriginHostHeader
	origin.OriginHostHeader = genruntime.ClonePointerToString(source.OriginHostHeader)

	// Priority
	origin.Priority = genruntime.ClonePointerToInt(source.Priority)

	// PrivateEndpointStatus
	if source.PrivateEndpointStatus != nil {
		privateEndpointStatus := PrivateEndpointStatus_STATUS(*source.PrivateEndpointStatus)
		origin.PrivateEndpointStatus = &privateEndpointStatus
	} else {
		origin.PrivateEndpointStatus = nil
	}

	// PrivateLinkAlias
	origin.PrivateLinkAlias = genruntime.ClonePointerToString(source.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	origin.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(source.PrivateLinkApprovalMessage)

	// PrivateLinkLocation
	origin.PrivateLinkLocation = genruntime.ClonePointerToString(source.PrivateLinkLocation)

	// PrivateLinkResourceId
	origin.PrivateLinkResourceId = genruntime.ClonePointerToString(source.PrivateLinkResourceId)

	// Weight
	origin.Weight = genruntime.ClonePointerToInt(source.Weight)

	// No error
	return nil
}

// AssignPropertiesToDeepCreatedOrigin_STATUS populates the provided destination DeepCreatedOrigin_STATUS from our DeepCreatedOrigin_STATUS
func (origin *DeepCreatedOrigin_STATUS) AssignPropertiesToDeepCreatedOrigin_STATUS(destination *v20210601s.DeepCreatedOrigin_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Enabled
	if origin.Enabled != nil {
		enabled := *origin.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// HostName
	destination.HostName = genruntime.ClonePointerToString(origin.HostName)

	// HttpPort
	destination.HttpPort = genruntime.ClonePointerToInt(origin.HttpPort)

	// HttpsPort
	destination.HttpsPort = genruntime.ClonePointerToInt(origin.HttpsPort)

	// Name
	destination.Name = genruntime.ClonePointerToString(origin.Name)

	// OriginHostHeader
	destination.OriginHostHeader = genruntime.ClonePointerToString(origin.OriginHostHeader)

	// Priority
	destination.Priority = genruntime.ClonePointerToInt(origin.Priority)

	// PrivateEndpointStatus
	if origin.PrivateEndpointStatus != nil {
		privateEndpointStatus := string(*origin.PrivateEndpointStatus)
		destination.PrivateEndpointStatus = &privateEndpointStatus
	} else {
		destination.PrivateEndpointStatus = nil
	}

	// PrivateLinkAlias
	destination.PrivateLinkAlias = genruntime.ClonePointerToString(origin.PrivateLinkAlias)

	// PrivateLinkApprovalMessage
	destination.PrivateLinkApprovalMessage = genruntime.ClonePointerToString(origin.PrivateLinkApprovalMessage)

	// PrivateLinkLocation
	destination.PrivateLinkLocation = genruntime.ClonePointerToString(origin.PrivateLinkLocation)

	// PrivateLinkResourceId
	destination.PrivateLinkResourceId = genruntime.ClonePointerToString(origin.PrivateLinkResourceId)

	// Weight
	destination.Weight = genruntime.ClonePointerToInt(origin.Weight)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EndpointProperties_DeliveryPolicy struct {
	// Description: User-friendly description of the policy.
	Description *string `json:"description,omitempty"`

	// +kubebuilder:validation:Required
	// Rules: A list of the delivery rules.
	Rules []DeliveryRule `json:"rules,omitempty"`
}

var _ genruntime.ARMTransformer = &EndpointProperties_DeliveryPolicy{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (policy *EndpointProperties_DeliveryPolicy) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if policy == nil {
		return nil, nil
	}
	result := &EndpointProperties_DeliveryPolicyARM{}

	// Set property ‘Description’:
	if policy.Description != nil {
		description := *policy.Description
		result.Description = &description
	}

	// Set property ‘Rules’:
	for _, item := range policy.Rules {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Rules = append(result.Rules, *itemARM.(*DeliveryRuleARM))
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *EndpointProperties_DeliveryPolicy) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EndpointProperties_DeliveryPolicyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *EndpointProperties_DeliveryPolicy) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EndpointProperties_DeliveryPolicyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EndpointProperties_DeliveryPolicyARM, got %T", armInput)
	}

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		policy.Description = &description
	}

	// Set property ‘Rules’:
	for _, item := range typedInput.Rules {
		var item1 DeliveryRule
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.Rules = append(policy.Rules, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromEndpointProperties_DeliveryPolicy populates our EndpointProperties_DeliveryPolicy from the provided source EndpointProperties_DeliveryPolicy
func (policy *EndpointProperties_DeliveryPolicy) AssignPropertiesFromEndpointProperties_DeliveryPolicy(source *v20210601s.EndpointProperties_DeliveryPolicy) error {

	// Description
	policy.Description = genruntime.ClonePointerToString(source.Description)

	// Rules
	if source.Rules != nil {
		ruleList := make([]DeliveryRule, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule DeliveryRule
			err := rule.AssignPropertiesFromDeliveryRule(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEndpointProperties_DeliveryPolicy populates the provided destination EndpointProperties_DeliveryPolicy from our EndpointProperties_DeliveryPolicy
func (policy *EndpointProperties_DeliveryPolicy) AssignPropertiesToEndpointProperties_DeliveryPolicy(destination *v20210601s.EndpointProperties_DeliveryPolicy) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Description
	destination.Description = genruntime.ClonePointerToString(policy.Description)

	// Rules
	if policy.Rules != nil {
		ruleList := make([]v20210601s.DeliveryRule, len(policy.Rules))
		for ruleIndex, ruleItem := range policy.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule v20210601s.DeliveryRule
			err := ruleItem.AssignPropertiesToDeliveryRule(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeliveryRule() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EndpointProperties_DeliveryPolicy_STATUS struct {
	// Description: User-friendly description of the policy.
	Description *string `json:"description,omitempty"`

	// Rules: A list of the delivery rules.
	Rules []DeliveryRule_STATUS `json:"rules,omitempty"`
}

var _ genruntime.FromARMConverter = &EndpointProperties_DeliveryPolicy_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (policy *EndpointProperties_DeliveryPolicy_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EndpointProperties_DeliveryPolicy_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (policy *EndpointProperties_DeliveryPolicy_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EndpointProperties_DeliveryPolicy_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EndpointProperties_DeliveryPolicy_STATUSARM, got %T", armInput)
	}

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		policy.Description = &description
	}

	// Set property ‘Rules’:
	for _, item := range typedInput.Rules {
		var item1 DeliveryRule_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		policy.Rules = append(policy.Rules, item1)
	}

	// No error
	return nil
}

// AssignPropertiesFromEndpointProperties_DeliveryPolicy_STATUS populates our EndpointProperties_DeliveryPolicy_STATUS from the provided source EndpointProperties_DeliveryPolicy_STATUS
func (policy *EndpointProperties_DeliveryPolicy_STATUS) AssignPropertiesFromEndpointProperties_DeliveryPolicy_STATUS(source *v20210601s.EndpointProperties_DeliveryPolicy_STATUS) error {

	// Description
	policy.Description = genruntime.ClonePointerToString(source.Description)

	// Rules
	if source.Rules != nil {
		ruleList := make([]DeliveryRule_STATUS, len(source.Rules))
		for ruleIndex, ruleItem := range source.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule DeliveryRule_STATUS
			err := rule.AssignPropertiesFromDeliveryRule_STATUS(&ruleItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		policy.Rules = ruleList
	} else {
		policy.Rules = nil
	}

	// No error
	return nil
}

// AssignPropertiesToEndpointProperties_DeliveryPolicy_STATUS populates the provided destination EndpointProperties_DeliveryPolicy_STATUS from our EndpointProperties_DeliveryPolicy_STATUS
func (policy *EndpointProperties_DeliveryPolicy_STATUS) AssignPropertiesToEndpointProperties_DeliveryPolicy_STATUS(destination *v20210601s.EndpointProperties_DeliveryPolicy_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Description
	destination.Description = genruntime.ClonePointerToString(policy.Description)

	// Rules
	if policy.Rules != nil {
		ruleList := make([]v20210601s.DeliveryRule_STATUS, len(policy.Rules))
		for ruleIndex, ruleItem := range policy.Rules {
			// Shadow the loop variable to avoid aliasing
			ruleItem := ruleItem
			var rule v20210601s.DeliveryRule_STATUS
			err := ruleItem.AssignPropertiesToDeliveryRule_STATUS(&rule)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeliveryRule_STATUS() to populate field Rules")
			}
			ruleList[ruleIndex] = rule
		}
		destination.Rules = ruleList
	} else {
		destination.Rules = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Creating","Deleting","Failed","Succeeded","Updating"}
type EndpointProperties_ProvisioningState string

const (
	EndpointProperties_ProvisioningStateCreating  = EndpointProperties_ProvisioningState("Creating")
	EndpointProperties_ProvisioningStateDeleting  = EndpointProperties_ProvisioningState("Deleting")
	EndpointProperties_ProvisioningStateFailed    = EndpointProperties_ProvisioningState("Failed")
	EndpointProperties_ProvisioningStateSucceeded = EndpointProperties_ProvisioningState("Succeeded")
	EndpointProperties_ProvisioningStateUpdating  = EndpointProperties_ProvisioningState("Updating")
)

// +kubebuilder:validation:Enum={"Creating","Deleting","Running","Starting","Stopped","Stopping"}
type EndpointProperties_ResourceState string

const (
	EndpointProperties_ResourceStateCreating = EndpointProperties_ResourceState("Creating")
	EndpointProperties_ResourceStateDeleting = EndpointProperties_ResourceState("Deleting")
	EndpointProperties_ResourceStateRunning  = EndpointProperties_ResourceState("Running")
	EndpointProperties_ResourceStateStarting = EndpointProperties_ResourceState("Starting")
	EndpointProperties_ResourceStateStopped  = EndpointProperties_ResourceState("Stopped")
	EndpointProperties_ResourceStateStopping = EndpointProperties_ResourceState("Stopping")
)

type EndpointProperties_WebApplicationFirewallPolicyLink struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.ARMTransformer = &EndpointProperties_WebApplicationFirewallPolicyLink{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (link *EndpointProperties_WebApplicationFirewallPolicyLink) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if link == nil {
		return nil, nil
	}
	result := &EndpointProperties_WebApplicationFirewallPolicyLinkARM{}

	// Set property ‘Id’:
	if link.Id != nil {
		id := *link.Id
		result.Id = &id
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (link *EndpointProperties_WebApplicationFirewallPolicyLink) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EndpointProperties_WebApplicationFirewallPolicyLinkARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (link *EndpointProperties_WebApplicationFirewallPolicyLink) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EndpointProperties_WebApplicationFirewallPolicyLinkARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EndpointProperties_WebApplicationFirewallPolicyLinkARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		link.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromEndpointProperties_WebApplicationFirewallPolicyLink populates our EndpointProperties_WebApplicationFirewallPolicyLink from the provided source EndpointProperties_WebApplicationFirewallPolicyLink
func (link *EndpointProperties_WebApplicationFirewallPolicyLink) AssignPropertiesFromEndpointProperties_WebApplicationFirewallPolicyLink(source *v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink) error {

	// Id
	link.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToEndpointProperties_WebApplicationFirewallPolicyLink populates the provided destination EndpointProperties_WebApplicationFirewallPolicyLink from our EndpointProperties_WebApplicationFirewallPolicyLink
func (link *EndpointProperties_WebApplicationFirewallPolicyLink) AssignPropertiesToEndpointProperties_WebApplicationFirewallPolicyLink(destination *v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(link.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type EndpointProperties_WebApplicationFirewallPolicyLink_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &EndpointProperties_WebApplicationFirewallPolicyLink_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (link *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &EndpointProperties_WebApplicationFirewallPolicyLink_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (link *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(EndpointProperties_WebApplicationFirewallPolicyLink_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected EndpointProperties_WebApplicationFirewallPolicyLink_STATUSARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		link.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromEndpointProperties_WebApplicationFirewallPolicyLink_STATUS populates our EndpointProperties_WebApplicationFirewallPolicyLink_STATUS from the provided source EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
func (link *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) AssignPropertiesFromEndpointProperties_WebApplicationFirewallPolicyLink_STATUS(source *v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) error {

	// Id
	link.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToEndpointProperties_WebApplicationFirewallPolicyLink_STATUS populates the provided destination EndpointProperties_WebApplicationFirewallPolicyLink_STATUS from our EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
func (link *EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) AssignPropertiesToEndpointProperties_WebApplicationFirewallPolicyLink_STATUS(destination *v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(link.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type GeoFilter struct {
	// +kubebuilder:validation:Required
	// Action: Action of the geo filter, i.e. allow or block access.
	Action *GeoFilter_Action `json:"action,omitempty"`

	// +kubebuilder:validation:Required
	// CountryCodes: Two letter country or region codes defining user country or region access in a geo filter, e.g. AU, MX, US.
	CountryCodes []string `json:"countryCodes,omitempty"`

	// +kubebuilder:validation:Required
	// RelativePath: Relative path applicable to geo filter. (e.g. '/mypictures', '/mypicture/kitty.jpg', and etc.)
	RelativePath *string `json:"relativePath,omitempty"`
}

var _ genruntime.ARMTransformer = &GeoFilter{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (filter *GeoFilter) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if filter == nil {
		return nil, nil
	}
	result := &GeoFilterARM{}

	// Set property ‘Action’:
	if filter.Action != nil {
		action := *filter.Action
		result.Action = &action
	}

	// Set property ‘CountryCodes’:
	for _, item := range filter.CountryCodes {
		result.CountryCodes = append(result.CountryCodes, item)
	}

	// Set property ‘RelativePath’:
	if filter.RelativePath != nil {
		relativePath := *filter.RelativePath
		result.RelativePath = &relativePath
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (filter *GeoFilter) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &GeoFilterARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (filter *GeoFilter) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(GeoFilterARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected GeoFilterARM, got %T", armInput)
	}

	// Set property ‘Action’:
	if typedInput.Action != nil {
		action := *typedInput.Action
		filter.Action = &action
	}

	// Set property ‘CountryCodes’:
	for _, item := range typedInput.CountryCodes {
		filter.CountryCodes = append(filter.CountryCodes, item)
	}

	// Set property ‘RelativePath’:
	if typedInput.RelativePath != nil {
		relativePath := *typedInput.RelativePath
		filter.RelativePath = &relativePath
	}

	// No error
	return nil
}

// AssignPropertiesFromGeoFilter populates our GeoFilter from the provided source GeoFilter
func (filter *GeoFilter) AssignPropertiesFromGeoFilter(source *v20210601s.GeoFilter) error {

	// Action
	if source.Action != nil {
		action := GeoFilter_Action(*source.Action)
		filter.Action = &action
	} else {
		filter.Action = nil
	}

	// CountryCodes
	filter.CountryCodes = genruntime.CloneSliceOfString(source.CountryCodes)

	// RelativePath
	filter.RelativePath = genruntime.ClonePointerToString(source.RelativePath)

	// No error
	return nil
}

// AssignPropertiesToGeoFilter populates the provided destination GeoFilter from our GeoFilter
func (filter *GeoFilter) AssignPropertiesToGeoFilter(destination *v20210601s.GeoFilter) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if filter.Action != nil {
		action := string(*filter.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// CountryCodes
	destination.CountryCodes = genruntime.CloneSliceOfString(filter.CountryCodes)

	// RelativePath
	destination.RelativePath = genruntime.ClonePointerToString(filter.RelativePath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type GeoFilter_STATUS struct {
	// Action: Action of the geo filter, i.e. allow or block access.
	Action *GeoFilter_Action_STATUS `json:"action,omitempty"`

	// CountryCodes: Two letter country or region codes defining user country or region access in a geo filter, e.g. AU, MX, US.
	CountryCodes []string `json:"countryCodes,omitempty"`

	// RelativePath: Relative path applicable to geo filter. (e.g. '/mypictures', '/mypicture/kitty.jpg', and etc.)
	RelativePath *string `json:"relativePath,omitempty"`
}

var _ genruntime.FromARMConverter = &GeoFilter_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (filter *GeoFilter_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &GeoFilter_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (filter *GeoFilter_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(GeoFilter_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected GeoFilter_STATUSARM, got %T", armInput)
	}

	// Set property ‘Action’:
	if typedInput.Action != nil {
		action := *typedInput.Action
		filter.Action = &action
	}

	// Set property ‘CountryCodes’:
	for _, item := range typedInput.CountryCodes {
		filter.CountryCodes = append(filter.CountryCodes, item)
	}

	// Set property ‘RelativePath’:
	if typedInput.RelativePath != nil {
		relativePath := *typedInput.RelativePath
		filter.RelativePath = &relativePath
	}

	// No error
	return nil
}

// AssignPropertiesFromGeoFilter_STATUS populates our GeoFilter_STATUS from the provided source GeoFilter_STATUS
func (filter *GeoFilter_STATUS) AssignPropertiesFromGeoFilter_STATUS(source *v20210601s.GeoFilter_STATUS) error {

	// Action
	if source.Action != nil {
		action := GeoFilter_Action_STATUS(*source.Action)
		filter.Action = &action
	} else {
		filter.Action = nil
	}

	// CountryCodes
	filter.CountryCodes = genruntime.CloneSliceOfString(source.CountryCodes)

	// RelativePath
	filter.RelativePath = genruntime.ClonePointerToString(source.RelativePath)

	// No error
	return nil
}

// AssignPropertiesToGeoFilter_STATUS populates the provided destination GeoFilter_STATUS from our GeoFilter_STATUS
func (filter *GeoFilter_STATUS) AssignPropertiesToGeoFilter_STATUS(destination *v20210601s.GeoFilter_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Action
	if filter.Action != nil {
		action := string(*filter.Action)
		destination.Action = &action
	} else {
		destination.Action = nil
	}

	// CountryCodes
	destination.CountryCodes = genruntime.CloneSliceOfString(filter.CountryCodes)

	// RelativePath
	destination.RelativePath = genruntime.ClonePointerToString(filter.RelativePath)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"DynamicSiteAcceleration","GeneralMediaStreaming","GeneralWebDelivery","LargeFileDownload","VideoOnDemandMediaStreaming"}
type OptimizationType string

const (
	OptimizationTypeDynamicSiteAcceleration     = OptimizationType("DynamicSiteAcceleration")
	OptimizationTypeGeneralMediaStreaming       = OptimizationType("GeneralMediaStreaming")
	OptimizationTypeGeneralWebDelivery          = OptimizationType("GeneralWebDelivery")
	OptimizationTypeLargeFileDownload           = OptimizationType("LargeFileDownload")
	OptimizationTypeVideoOnDemandMediaStreaming = OptimizationType("VideoOnDemandMediaStreaming")
)

// +kubebuilder:validation:Enum={"BypassCaching","IgnoreQueryString","NotSet","UseQueryString"}
type QueryStringCachingBehavior string

const (
	QueryStringCachingBehaviorBypassCaching     = QueryStringCachingBehavior("BypassCaching")
	QueryStringCachingBehaviorIgnoreQueryString = QueryStringCachingBehavior("IgnoreQueryString")
	QueryStringCachingBehaviorNotSet            = QueryStringCachingBehavior("NotSet")
	QueryStringCachingBehaviorUseQueryString    = QueryStringCachingBehavior("UseQueryString")
)

type ResourceReference struct {
	// Reference: Resource ID.
	Reference *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

var _ genruntime.ARMTransformer = &ResourceReference{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (reference *ResourceReference) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if reference == nil {
		return nil, nil
	}
	result := &ResourceReferenceARM{}

	// Set property ‘Id’:
	if reference.Reference != nil {
		referenceARMID, err := resolved.ResolvedReferences.ARMIDOrErr(*reference.Reference)
		if err != nil {
			return nil, err
		}
		reference1 := referenceARMID
		result.Id = &reference1
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ResourceReference) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceReferenceARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ResourceReference) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	_, ok := armInput.(ResourceReferenceARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceReferenceARM, got %T", armInput)
	}

	// no assignment for property ‘Reference’

	// No error
	return nil
}

// AssignPropertiesFromResourceReference populates our ResourceReference from the provided source ResourceReference
func (reference *ResourceReference) AssignPropertiesFromResourceReference(source *v20210601s.ResourceReference) error {

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResourceReference populates the provided destination ResourceReference from our ResourceReference
func (reference *ResourceReference) AssignPropertiesToResourceReference(destination *v20210601s.ResourceReference) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ResourceReference_STATUS struct {
	// Id: Resource ID.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &ResourceReference_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (reference *ResourceReference_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResourceReference_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (reference *ResourceReference_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResourceReference_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResourceReference_STATUSARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		reference.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromResourceReference_STATUS populates our ResourceReference_STATUS from the provided source ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignPropertiesFromResourceReference_STATUS(source *v20210601s.ResourceReference_STATUS) error {

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToResourceReference_STATUS populates the provided destination ResourceReference_STATUS from our ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignPropertiesToResourceReference_STATUS(destination *v20210601s.ResourceReference_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UrlSigningKey struct {
	// +kubebuilder:validation:Required
	// KeyId: Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form
	// the hash.
	KeyId *string `json:"keyId,omitempty"`

	// +kubebuilder:validation:Required
	// KeySourceParameters: Defines the parameters for using customer key vault for Url Signing Key.
	KeySourceParameters *KeyVaultSigningKeyParameters `json:"keySourceParameters,omitempty"`
}

var _ genruntime.ARMTransformer = &UrlSigningKey{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (signingKey *UrlSigningKey) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if signingKey == nil {
		return nil, nil
	}
	result := &UrlSigningKeyARM{}

	// Set property ‘KeyId’:
	if signingKey.KeyId != nil {
		keyId := *signingKey.KeyId
		result.KeyId = &keyId
	}

	// Set property ‘KeySourceParameters’:
	if signingKey.KeySourceParameters != nil {
		keySourceParametersARM, err := (*signingKey.KeySourceParameters).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		keySourceParameters := *keySourceParametersARM.(*KeyVaultSigningKeyParametersARM)
		result.KeySourceParameters = &keySourceParameters
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (signingKey *UrlSigningKey) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlSigningKeyARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (signingKey *UrlSigningKey) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlSigningKeyARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlSigningKeyARM, got %T", armInput)
	}

	// Set property ‘KeyId’:
	if typedInput.KeyId != nil {
		keyId := *typedInput.KeyId
		signingKey.KeyId = &keyId
	}

	// Set property ‘KeySourceParameters’:
	if typedInput.KeySourceParameters != nil {
		var keySourceParameters1 KeyVaultSigningKeyParameters
		err := keySourceParameters1.PopulateFromARM(owner, *typedInput.KeySourceParameters)
		if err != nil {
			return err
		}
		keySourceParameters := keySourceParameters1
		signingKey.KeySourceParameters = &keySourceParameters
	}

	// No error
	return nil
}

// AssignPropertiesFromUrlSigningKey populates our UrlSigningKey from the provided source UrlSigningKey
func (signingKey *UrlSigningKey) AssignPropertiesFromUrlSigningKey(source *v20210601s.UrlSigningKey) error {

	// KeyId
	signingKey.KeyId = genruntime.ClonePointerToString(source.KeyId)

	// KeySourceParameters
	if source.KeySourceParameters != nil {
		var keySourceParameter KeyVaultSigningKeyParameters
		err := keySourceParameter.AssignPropertiesFromKeyVaultSigningKeyParameters(source.KeySourceParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKeyVaultSigningKeyParameters() to populate field KeySourceParameters")
		}
		signingKey.KeySourceParameters = &keySourceParameter
	} else {
		signingKey.KeySourceParameters = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUrlSigningKey populates the provided destination UrlSigningKey from our UrlSigningKey
func (signingKey *UrlSigningKey) AssignPropertiesToUrlSigningKey(destination *v20210601s.UrlSigningKey) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyId
	destination.KeyId = genruntime.ClonePointerToString(signingKey.KeyId)

	// KeySourceParameters
	if signingKey.KeySourceParameters != nil {
		var keySourceParameter v20210601s.KeyVaultSigningKeyParameters
		err := signingKey.KeySourceParameters.AssignPropertiesToKeyVaultSigningKeyParameters(&keySourceParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKeyVaultSigningKeyParameters() to populate field KeySourceParameters")
		}
		destination.KeySourceParameters = &keySourceParameter
	} else {
		destination.KeySourceParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type UrlSigningKey_STATUS struct {
	// KeyId: Defines the customer defined key Id. This id will exist in the incoming request to indicate the key used to form
	// the hash.
	KeyId *string `json:"keyId,omitempty"`

	// KeySourceParameters: Defines the parameters for using customer key vault for Url Signing Key.
	KeySourceParameters *KeyVaultSigningKeyParameters_STATUS `json:"keySourceParameters,omitempty"`
}

var _ genruntime.FromARMConverter = &UrlSigningKey_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (signingKey *UrlSigningKey_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &UrlSigningKey_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (signingKey *UrlSigningKey_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(UrlSigningKey_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected UrlSigningKey_STATUSARM, got %T", armInput)
	}

	// Set property ‘KeyId’:
	if typedInput.KeyId != nil {
		keyId := *typedInput.KeyId
		signingKey.KeyId = &keyId
	}

	// Set property ‘KeySourceParameters’:
	if typedInput.KeySourceParameters != nil {
		var keySourceParameters1 KeyVaultSigningKeyParameters_STATUS
		err := keySourceParameters1.PopulateFromARM(owner, *typedInput.KeySourceParameters)
		if err != nil {
			return err
		}
		keySourceParameters := keySourceParameters1
		signingKey.KeySourceParameters = &keySourceParameters
	}

	// No error
	return nil
}

// AssignPropertiesFromUrlSigningKey_STATUS populates our UrlSigningKey_STATUS from the provided source UrlSigningKey_STATUS
func (signingKey *UrlSigningKey_STATUS) AssignPropertiesFromUrlSigningKey_STATUS(source *v20210601s.UrlSigningKey_STATUS) error {

	// KeyId
	signingKey.KeyId = genruntime.ClonePointerToString(source.KeyId)

	// KeySourceParameters
	if source.KeySourceParameters != nil {
		var keySourceParameter KeyVaultSigningKeyParameters_STATUS
		err := keySourceParameter.AssignPropertiesFromKeyVaultSigningKeyParameters_STATUS(source.KeySourceParameters)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKeyVaultSigningKeyParameters_STATUS() to populate field KeySourceParameters")
		}
		signingKey.KeySourceParameters = &keySourceParameter
	} else {
		signingKey.KeySourceParameters = nil
	}

	// No error
	return nil
}

// AssignPropertiesToUrlSigningKey_STATUS populates the provided destination UrlSigningKey_STATUS from our UrlSigningKey_STATUS
func (signingKey *UrlSigningKey_STATUS) AssignPropertiesToUrlSigningKey_STATUS(destination *v20210601s.UrlSigningKey_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// KeyId
	destination.KeyId = genruntime.ClonePointerToString(signingKey.KeyId)

	// KeySourceParameters
	if signingKey.KeySourceParameters != nil {
		var keySourceParameter v20210601s.KeyVaultSigningKeyParameters_STATUS
		err := signingKey.KeySourceParameters.AssignPropertiesToKeyVaultSigningKeyParameters_STATUS(&keySourceParameter)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKeyVaultSigningKeyParameters_STATUS() to populate field KeySourceParameters")
		}
		destination.KeySourceParameters = &keySourceParameter
	} else {
		destination.KeySourceParameters = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CustomDomainHttpsParameters struct {
	// +kubebuilder:validation:Required
	// CertificateSource: Defines the source of the SSL certificate.
	CertificateSource *CustomDomainHttpsParameters_CertificateSource `json:"certificateSource,omitempty"`

	// MinimumTlsVersion: TLS protocol version that will be used for Https
	MinimumTlsVersion *CustomDomainHttpsParameters_MinimumTlsVersion `json:"minimumTlsVersion,omitempty"`

	// +kubebuilder:validation:Required
	// ProtocolType: Defines the TLS extension protocol that is used for secure delivery.
	ProtocolType *CustomDomainHttpsParameters_ProtocolType `json:"protocolType,omitempty"`
}

var _ genruntime.ARMTransformer = &CustomDomainHttpsParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *CustomDomainHttpsParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &CustomDomainHttpsParametersARM{}

	// Set property ‘CertificateSource’:
	if parameters.CertificateSource != nil {
		certificateSource := *parameters.CertificateSource
		result.CertificateSource = &certificateSource
	}

	// Set property ‘MinimumTlsVersion’:
	if parameters.MinimumTlsVersion != nil {
		minimumTlsVersion := *parameters.MinimumTlsVersion
		result.MinimumTlsVersion = &minimumTlsVersion
	}

	// Set property ‘ProtocolType’:
	if parameters.ProtocolType != nil {
		protocolType := *parameters.ProtocolType
		result.ProtocolType = &protocolType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *CustomDomainHttpsParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CustomDomainHttpsParametersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *CustomDomainHttpsParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CustomDomainHttpsParametersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CustomDomainHttpsParametersARM, got %T", armInput)
	}

	// Set property ‘CertificateSource’:
	if typedInput.CertificateSource != nil {
		certificateSource := *typedInput.CertificateSource
		parameters.CertificateSource = &certificateSource
	}

	// Set property ‘MinimumTlsVersion’:
	if typedInput.MinimumTlsVersion != nil {
		minimumTlsVersion := *typedInput.MinimumTlsVersion
		parameters.MinimumTlsVersion = &minimumTlsVersion
	}

	// Set property ‘ProtocolType’:
	if typedInput.ProtocolType != nil {
		protocolType := *typedInput.ProtocolType
		parameters.ProtocolType = &protocolType
	}

	// No error
	return nil
}

// AssignPropertiesFromCustomDomainHttpsParameters populates our CustomDomainHttpsParameters from the provided source CustomDomainHttpsParameters
func (parameters *CustomDomainHttpsParameters) AssignPropertiesFromCustomDomainHttpsParameters(source *v20210601s.CustomDomainHttpsParameters) error {

	// CertificateSource
	if source.CertificateSource != nil {
		certificateSource := CustomDomainHttpsParameters_CertificateSource(*source.CertificateSource)
		parameters.CertificateSource = &certificateSource
	} else {
		parameters.CertificateSource = nil
	}

	// MinimumTlsVersion
	if source.MinimumTlsVersion != nil {
		minimumTlsVersion := CustomDomainHttpsParameters_MinimumTlsVersion(*source.MinimumTlsVersion)
		parameters.MinimumTlsVersion = &minimumTlsVersion
	} else {
		parameters.MinimumTlsVersion = nil
	}

	// ProtocolType
	if source.ProtocolType != nil {
		protocolType := CustomDomainHttpsParameters_ProtocolType(*source.ProtocolType)
		parameters.ProtocolType = &protocolType
	} else {
		parameters.ProtocolType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCustomDomainHttpsParameters populates the provided destination CustomDomainHttpsParameters from our CustomDomainHttpsParameters
func (parameters *CustomDomainHttpsParameters) AssignPropertiesToCustomDomainHttpsParameters(destination *v20210601s.CustomDomainHttpsParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateSource
	if parameters.CertificateSource != nil {
		certificateSource := string(*parameters.CertificateSource)
		destination.CertificateSource = &certificateSource
	} else {
		destination.CertificateSource = nil
	}

	// MinimumTlsVersion
	if parameters.MinimumTlsVersion != nil {
		minimumTlsVersion := string(*parameters.MinimumTlsVersion)
		destination.MinimumTlsVersion = &minimumTlsVersion
	} else {
		destination.MinimumTlsVersion = nil
	}

	// ProtocolType
	if parameters.ProtocolType != nil {
		protocolType := string(*parameters.ProtocolType)
		destination.ProtocolType = &protocolType
	} else {
		destination.ProtocolType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type CustomDomainHttpsParameters_STATUS struct {
	// CertificateSource: Defines the source of the SSL certificate.
	CertificateSource *CustomDomainHttpsParameters_CertificateSource_STATUS `json:"certificateSource,omitempty"`

	// MinimumTlsVersion: TLS protocol version that will be used for Https
	MinimumTlsVersion *CustomDomainHttpsParameters_MinimumTlsVersion_STATUS `json:"minimumTlsVersion,omitempty"`

	// ProtocolType: Defines the TLS extension protocol that is used for secure delivery.
	ProtocolType *CustomDomainHttpsParameters_ProtocolType_STATUS `json:"protocolType,omitempty"`
}

var _ genruntime.FromARMConverter = &CustomDomainHttpsParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *CustomDomainHttpsParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &CustomDomainHttpsParameters_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *CustomDomainHttpsParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(CustomDomainHttpsParameters_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected CustomDomainHttpsParameters_STATUSARM, got %T", armInput)
	}

	// Set property ‘CertificateSource’:
	if typedInput.CertificateSource != nil {
		certificateSource := *typedInput.CertificateSource
		parameters.CertificateSource = &certificateSource
	}

	// Set property ‘MinimumTlsVersion’:
	if typedInput.MinimumTlsVersion != nil {
		minimumTlsVersion := *typedInput.MinimumTlsVersion
		parameters.MinimumTlsVersion = &minimumTlsVersion
	}

	// Set property ‘ProtocolType’:
	if typedInput.ProtocolType != nil {
		protocolType := *typedInput.ProtocolType
		parameters.ProtocolType = &protocolType
	}

	// No error
	return nil
}

// AssignPropertiesFromCustomDomainHttpsParameters_STATUS populates our CustomDomainHttpsParameters_STATUS from the provided source CustomDomainHttpsParameters_STATUS
func (parameters *CustomDomainHttpsParameters_STATUS) AssignPropertiesFromCustomDomainHttpsParameters_STATUS(source *v20210601s.CustomDomainHttpsParameters_STATUS) error {

	// CertificateSource
	if source.CertificateSource != nil {
		certificateSource := CustomDomainHttpsParameters_CertificateSource_STATUS(*source.CertificateSource)
		parameters.CertificateSource = &certificateSource
	} else {
		parameters.CertificateSource = nil
	}

	// MinimumTlsVersion
	if source.MinimumTlsVersion != nil {
		minimumTlsVersion := CustomDomainHttpsParameters_MinimumTlsVersion_STATUS(*source.MinimumTlsVersion)
		parameters.MinimumTlsVersion = &minimumTlsVersion
	} else {
		parameters.MinimumTlsVersion = nil
	}

	// ProtocolType
	if source.ProtocolType != nil {
		protocolType := CustomDomainHttpsParameters_ProtocolType_STATUS(*source.ProtocolType)
		parameters.ProtocolType = &protocolType
	} else {
		parameters.ProtocolType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToCustomDomainHttpsParameters_STATUS populates the provided destination CustomDomainHttpsParameters_STATUS from our CustomDomainHttpsParameters_STATUS
func (parameters *CustomDomainHttpsParameters_STATUS) AssignPropertiesToCustomDomainHttpsParameters_STATUS(destination *v20210601s.CustomDomainHttpsParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CertificateSource
	if parameters.CertificateSource != nil {
		certificateSource := string(*parameters.CertificateSource)
		destination.CertificateSource = &certificateSource
	} else {
		destination.CertificateSource = nil
	}

	// MinimumTlsVersion
	if parameters.MinimumTlsVersion != nil {
		minimumTlsVersion := string(*parameters.MinimumTlsVersion)
		destination.MinimumTlsVersion = &minimumTlsVersion
	} else {
		destination.MinimumTlsVersion = nil
	}

	// ProtocolType
	if parameters.ProtocolType != nil {
		protocolType := string(*parameters.ProtocolType)
		destination.ProtocolType = &protocolType
	} else {
		destination.ProtocolType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Disabled","Disabling","Enabled","Enabling","Failed"}
type CustomDomainProperties_CustomHttpsProvisioningState string

const (
	CustomDomainProperties_CustomHttpsProvisioningStateDisabled  = CustomDomainProperties_CustomHttpsProvisioningState("Disabled")
	CustomDomainProperties_CustomHttpsProvisioningStateDisabling = CustomDomainProperties_CustomHttpsProvisioningState("Disabling")
	CustomDomainProperties_CustomHttpsProvisioningStateEnabled   = CustomDomainProperties_CustomHttpsProvisioningState("Enabled")
	CustomDomainProperties_CustomHttpsProvisioningStateEnabling  = CustomDomainProperties_CustomHttpsProvisioningState("Enabling")
	CustomDomainProperties_CustomHttpsProvisioningStateFailed    = CustomDomainProperties_CustomHttpsProvisioningState("Failed")
)

type CustomDomainProperties_CustomHttpsProvisioningState_STATUS string

const (
	CustomDomainProperties_CustomHttpsProvisioningState_STATUSDisabled  = CustomDomainProperties_CustomHttpsProvisioningState_STATUS("Disabled")
	CustomDomainProperties_CustomHttpsProvisioningState_STATUSDisabling = CustomDomainProperties_CustomHttpsProvisioningState_STATUS("Disabling")
	CustomDomainProperties_CustomHttpsProvisioningState_STATUSEnabled   = CustomDomainProperties_CustomHttpsProvisioningState_STATUS("Enabled")
	CustomDomainProperties_CustomHttpsProvisioningState_STATUSEnabling  = CustomDomainProperties_CustomHttpsProvisioningState_STATUS("Enabling")
	CustomDomainProperties_CustomHttpsProvisioningState_STATUSFailed    = CustomDomainProperties_CustomHttpsProvisioningState_STATUS("Failed")
)

// +kubebuilder:validation:Enum={"CertificateDeleted","CertificateDeployed","DeletingCertificate","DeployingCertificate","DomainControlValidationRequestApproved","DomainControlValidationRequestRejected","DomainControlValidationRequestTimedOut","IssuingCertificate","PendingDomainControlValidationREquestApproval","SubmittingDomainControlValidationRequest"}
type CustomDomainProperties_CustomHttpsProvisioningSubstate string

const (
	CustomDomainProperties_CustomHttpsProvisioningSubstateCertificateDeleted                            = CustomDomainProperties_CustomHttpsProvisioningSubstate("CertificateDeleted")
	CustomDomainProperties_CustomHttpsProvisioningSubstateCertificateDeployed                           = CustomDomainProperties_CustomHttpsProvisioningSubstate("CertificateDeployed")
	CustomDomainProperties_CustomHttpsProvisioningSubstateDeletingCertificate                           = CustomDomainProperties_CustomHttpsProvisioningSubstate("DeletingCertificate")
	CustomDomainProperties_CustomHttpsProvisioningSubstateDeployingCertificate                          = CustomDomainProperties_CustomHttpsProvisioningSubstate("DeployingCertificate")
	CustomDomainProperties_CustomHttpsProvisioningSubstateDomainControlValidationRequestApproved        = CustomDomainProperties_CustomHttpsProvisioningSubstate("DomainControlValidationRequestApproved")
	CustomDomainProperties_CustomHttpsProvisioningSubstateDomainControlValidationRequestRejected        = CustomDomainProperties_CustomHttpsProvisioningSubstate("DomainControlValidationRequestRejected")
	CustomDomainProperties_CustomHttpsProvisioningSubstateDomainControlValidationRequestTimedOut        = CustomDomainProperties_CustomHttpsProvisioningSubstate("DomainControlValidationRequestTimedOut")
	CustomDomainProperties_CustomHttpsProvisioningSubstateIssuingCertificate                            = CustomDomainProperties_CustomHttpsProvisioningSubstate("IssuingCertificate")
	CustomDomainProperties_CustomHttpsProvisioningSubstatePendingDomainControlValidationREquestApproval = CustomDomainProperties_CustomHttpsProvisioningSubstate("PendingDomainControlValidationREquestApproval")
	CustomDomainProperties_CustomHttpsProvisioningSubstateSubmittingDomainControlValidationRequest      = CustomDomainProperties_CustomHttpsProvisioningSubstate("SubmittingDomainControlValidationRequest")
)

type CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUS string

const (
	CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUSCertificateDeleted                            = CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUS("CertificateDeleted")
	CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUSCertificateDeployed                           = CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUS("CertificateDeployed")
	CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUSDeletingCertificate                           = CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUS("DeletingCertificate")
	CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUSDeployingCertificate                          = CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUS("DeployingCertificate")
	CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUSDomainControlValidationRequestApproved        = CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUS("DomainControlValidationRequestApproved")
	CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUSDomainControlValidationRequestRejected        = CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUS("DomainControlValidationRequestRejected")
	CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUSDomainControlValidationRequestTimedOut        = CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUS("DomainControlValidationRequestTimedOut")
	CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUSIssuingCertificate                            = CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUS("IssuingCertificate")
	CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUSPendingDomainControlValidationREquestApproval = CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUS("PendingDomainControlValidationREquestApproval")
	CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUSSubmittingDomainControlValidationRequest      = CustomDomainProperties_CustomHttpsProvisioningSubstate_STATUS("SubmittingDomainControlValidationRequest")
)

// +kubebuilder:validation:Enum={"Disabled","Disabling","Enabled","Enabling","Failed"}
type CustomDomainProperties_ProvisioningState string

const (
	CustomDomainProperties_ProvisioningStateDisabled  = CustomDomainProperties_ProvisioningState("Disabled")
	CustomDomainProperties_ProvisioningStateDisabling = CustomDomainProperties_ProvisioningState("Disabling")
	CustomDomainProperties_ProvisioningStateEnabled   = CustomDomainProperties_ProvisioningState("Enabled")
	CustomDomainProperties_ProvisioningStateEnabling  = CustomDomainProperties_ProvisioningState("Enabling")
	CustomDomainProperties_ProvisioningStateFailed    = CustomDomainProperties_ProvisioningState("Failed")
)

type CustomDomainProperties_ProvisioningState_STATUS string

const (
	CustomDomainProperties_ProvisioningState_STATUSDisabled  = CustomDomainProperties_ProvisioningState_STATUS("Disabled")
	CustomDomainProperties_ProvisioningState_STATUSDisabling = CustomDomainProperties_ProvisioningState_STATUS("Disabling")
	CustomDomainProperties_ProvisioningState_STATUSEnabled   = CustomDomainProperties_ProvisioningState_STATUS("Enabled")
	CustomDomainProperties_ProvisioningState_STATUSEnabling  = CustomDomainProperties_ProvisioningState_STATUS("Enabling")
	CustomDomainProperties_ProvisioningState_STATUSFailed    = CustomDomainProperties_ProvisioningState_STATUS("Failed")
)

// +kubebuilder:validation:Enum={"Active","Creating","Deleting"}
type CustomDomainProperties_ResourceState string

const (
	CustomDomainProperties_ResourceStateActive   = CustomDomainProperties_ResourceState("Active")
	CustomDomainProperties_ResourceStateCreating = CustomDomainProperties_ResourceState("Creating")
	CustomDomainProperties_ResourceStateDeleting = CustomDomainProperties_ResourceState("Deleting")
)

type CustomDomainProperties_ResourceState_STATUS string

const (
	CustomDomainProperties_ResourceState_STATUSActive   = CustomDomainProperties_ResourceState_STATUS("Active")
	CustomDomainProperties_ResourceState_STATUSCreating = CustomDomainProperties_ResourceState_STATUS("Creating")
	CustomDomainProperties_ResourceState_STATUSDeleting = CustomDomainProperties_ResourceState_STATUS("Deleting")
)

type DeliveryRule struct {
	// +kubebuilder:validation:Required
	// Actions: A list of actions that are executed when all the conditions of a rule are satisfied.
	Actions []DeliveryRuleAction `json:"actions,omitempty"`

	// Conditions: A list of conditions that must be matched for the actions to be executed
	Conditions []DeliveryRuleCondition `json:"conditions,omitempty"`

	// Name: Name of the rule
	Name *string `json:"name,omitempty"`

	// +kubebuilder:validation:Required
	// Order: The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A rule with a
	// lesser order will be applied before a rule with a greater order. Rule with order 0 is a special rule. It does not
	// require any condition and actions listed in it will always be applied.
	Order *int `json:"order,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRule{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (rule *DeliveryRule) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if rule == nil {
		return nil, nil
	}
	result := &DeliveryRuleARM{}

	// Set property ‘Actions’:
	for _, item := range rule.Actions {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Actions = append(result.Actions, *itemARM.(*DeliveryRuleActionARM))
	}

	// Set property ‘Conditions’:
	for _, item := range rule.Conditions {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.Conditions = append(result.Conditions, *itemARM.(*DeliveryRuleConditionARM))
	}

	// Set property ‘Name’:
	if rule.Name != nil {
		name := *rule.Name
		result.Name = &name
	}

	// Set property ‘Order’:
	if rule.Order != nil {
		order := *rule.Order
		result.Order = &order
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *DeliveryRule) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *DeliveryRule) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleARM, got %T", armInput)
	}

	// Set property ‘Actions’:
	for _, item := range typedInput.Actions {
		var item1 DeliveryRuleAction
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Actions = append(rule.Actions, item1)
	}

	// Set property ‘Conditions’:
	for _, item := range typedInput.Conditions {
		var item1 DeliveryRuleCondition
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Conditions = append(rule.Conditions, item1)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘Order’:
	if typedInput.Order != nil {
		order := *typedInput.Order
		rule.Order = &order
	}

	// No error
	return nil
}

// AssignPropertiesFromDeliveryRule populates our DeliveryRule from the provided source DeliveryRule
func (rule *DeliveryRule) AssignPropertiesFromDeliveryRule(source *v20210601s.DeliveryRule) error {

	// Actions
	if source.Actions != nil {
		actionList := make([]DeliveryRuleAction, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action DeliveryRuleAction
			err := action.AssignPropertiesFromDeliveryRuleAction(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleAction() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		rule.Actions = actionList
	} else {
		rule.Actions = nil
	}

	// Conditions
	if source.Conditions != nil {
		conditionList := make([]DeliveryRuleCondition, len(source.Conditions))
		for conditionIndex, conditionItem := range source.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition DeliveryRuleCondition
			err := condition.AssignPropertiesFromDeliveryRuleCondition(&conditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleCondition() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		rule.Conditions = conditionList
	} else {
		rule.Conditions = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Order
	rule.Order = genruntime.ClonePointerToInt(source.Order)

	// No error
	return nil
}

// AssignPropertiesToDeliveryRule populates the provided destination DeliveryRule from our DeliveryRule
func (rule *DeliveryRule) AssignPropertiesToDeliveryRule(destination *v20210601s.DeliveryRule) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if rule.Actions != nil {
		actionList := make([]v20210601s.DeliveryRuleAction, len(rule.Actions))
		for actionIndex, actionItem := range rule.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action v20210601s.DeliveryRuleAction
			err := actionItem.AssignPropertiesToDeliveryRuleAction(&action)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleAction() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		destination.Actions = actionList
	} else {
		destination.Actions = nil
	}

	// Conditions
	if rule.Conditions != nil {
		conditionList := make([]v20210601s.DeliveryRuleCondition, len(rule.Conditions))
		for conditionIndex, conditionItem := range rule.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition v20210601s.DeliveryRuleCondition
			err := conditionItem.AssignPropertiesToDeliveryRuleCondition(&condition)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleCondition() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		destination.Conditions = conditionList
	} else {
		destination.Conditions = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Order
	destination.Order = genruntime.ClonePointerToInt(rule.Order)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRule_STATUS struct {
	// Actions: A list of actions that are executed when all the conditions of a rule are satisfied.
	Actions []DeliveryRuleAction_STATUS `json:"actions,omitempty"`

	// Conditions: A list of conditions that must be matched for the actions to be executed
	Conditions []DeliveryRuleCondition_STATUS `json:"conditions,omitempty"`

	// Name: Name of the rule
	Name *string `json:"name,omitempty"`

	// Order: The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A rule with a
	// lesser order will be applied before a rule with a greater order. Rule with order 0 is a special rule. It does not
	// require any condition and actions listed in it will always be applied.
	Order *int `json:"order,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRule_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (rule *DeliveryRule_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRule_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (rule *DeliveryRule_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRule_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRule_STATUSARM, got %T", armInput)
	}

	// Set property ‘Actions’:
	for _, item := range typedInput.Actions {
		var item1 DeliveryRuleAction_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		rule.Actions = append(rule.Actions, item1)
	}

	// no assignment for property ‘Conditions’

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		rule.Name = &name
	}

	// Set property ‘Order’:
	if typedInput.Order != nil {
		order := *typedInput.Order
		rule.Order = &order
	}

	// No error
	return nil
}

// AssignPropertiesFromDeliveryRule_STATUS populates our DeliveryRule_STATUS from the provided source DeliveryRule_STATUS
func (rule *DeliveryRule_STATUS) AssignPropertiesFromDeliveryRule_STATUS(source *v20210601s.DeliveryRule_STATUS) error {

	// Actions
	if source.Actions != nil {
		actionList := make([]DeliveryRuleAction_STATUS, len(source.Actions))
		for actionIndex, actionItem := range source.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action DeliveryRuleAction_STATUS
			err := action.AssignPropertiesFromDeliveryRuleAction_STATUS(&actionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleAction_STATUS() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		rule.Actions = actionList
	} else {
		rule.Actions = nil
	}

	// Conditions
	if source.Conditions != nil {
		conditionList := make([]DeliveryRuleCondition_STATUS, len(source.Conditions))
		for conditionIndex, conditionItem := range source.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition DeliveryRuleCondition_STATUS
			err := condition.AssignPropertiesFromDeliveryRuleCondition_STATUS(&conditionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromDeliveryRuleCondition_STATUS() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		rule.Conditions = conditionList
	} else {
		rule.Conditions = nil
	}

	// Name
	rule.Name = genruntime.ClonePointerToString(source.Name)

	// Order
	rule.Order = genruntime.ClonePointerToInt(source.Order)

	// No error
	return nil
}

// AssignPropertiesToDeliveryRule_STATUS populates the provided destination DeliveryRule_STATUS from our DeliveryRule_STATUS
func (rule *DeliveryRule_STATUS) AssignPropertiesToDeliveryRule_STATUS(destination *v20210601s.DeliveryRule_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Actions
	if rule.Actions != nil {
		actionList := make([]v20210601s.DeliveryRuleAction_STATUS, len(rule.Actions))
		for actionIndex, actionItem := range rule.Actions {
			// Shadow the loop variable to avoid aliasing
			actionItem := actionItem
			var action v20210601s.DeliveryRuleAction_STATUS
			err := actionItem.AssignPropertiesToDeliveryRuleAction_STATUS(&action)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleAction_STATUS() to populate field Actions")
			}
			actionList[actionIndex] = action
		}
		destination.Actions = actionList
	} else {
		destination.Actions = nil
	}

	// Conditions
	if rule.Conditions != nil {
		conditionList := make([]v20210601s.DeliveryRuleCondition_STATUS, len(rule.Conditions))
		for conditionIndex, conditionItem := range rule.Conditions {
			// Shadow the loop variable to avoid aliasing
			conditionItem := conditionItem
			var condition v20210601s.DeliveryRuleCondition_STATUS
			err := conditionItem.AssignPropertiesToDeliveryRuleCondition_STATUS(&condition)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToDeliveryRuleCondition_STATUS() to populate field Conditions")
			}
			conditionList[conditionIndex] = condition
		}
		destination.Conditions = conditionList
	} else {
		destination.Conditions = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(rule.Name)

	// Order
	destination.Order = genruntime.ClonePointerToInt(rule.Order)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Allow","Block"}
type GeoFilter_Action string

const (
	GeoFilter_ActionAllow = GeoFilter_Action("Allow")
	GeoFilter_ActionBlock = GeoFilter_Action("Block")
)

type HealthProbeParameters struct {
	// +kubebuilder:validation:Maximum=255
	// +kubebuilder:validation:Minimum=1
	// ProbeIntervalInSeconds: The number of seconds between health probes.Default is 240sec.
	ProbeIntervalInSeconds *int `json:"probeIntervalInSeconds,omitempty"`

	// ProbePath: The path relative to the origin that is used to determine the health of the origin.
	ProbePath *string `json:"probePath,omitempty"`

	// ProbeProtocol: Protocol to use for health probe.
	ProbeProtocol *HealthProbeParameters_ProbeProtocol `json:"probeProtocol,omitempty"`

	// ProbeRequestType: The type of health probe request that is made.
	ProbeRequestType *HealthProbeParameters_ProbeRequestType `json:"probeRequestType,omitempty"`
}

var _ genruntime.ARMTransformer = &HealthProbeParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *HealthProbeParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &HealthProbeParametersARM{}

	// Set property ‘ProbeIntervalInSeconds’:
	if parameters.ProbeIntervalInSeconds != nil {
		probeIntervalInSeconds := *parameters.ProbeIntervalInSeconds
		result.ProbeIntervalInSeconds = &probeIntervalInSeconds
	}

	// Set property ‘ProbePath’:
	if parameters.ProbePath != nil {
		probePath := *parameters.ProbePath
		result.ProbePath = &probePath
	}

	// Set property ‘ProbeProtocol’:
	if parameters.ProbeProtocol != nil {
		probeProtocol := *parameters.ProbeProtocol
		result.ProbeProtocol = &probeProtocol
	}

	// Set property ‘ProbeRequestType’:
	if parameters.ProbeRequestType != nil {
		probeRequestType := *parameters.ProbeRequestType
		result.ProbeRequestType = &probeRequestType
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HealthProbeParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HealthProbeParametersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HealthProbeParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HealthProbeParametersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HealthProbeParametersARM, got %T", armInput)
	}

	// Set property ‘ProbeIntervalInSeconds’:
	if typedInput.ProbeIntervalInSeconds != nil {
		probeIntervalInSeconds := *typedInput.ProbeIntervalInSeconds
		parameters.ProbeIntervalInSeconds = &probeIntervalInSeconds
	}

	// Set property ‘ProbePath’:
	if typedInput.ProbePath != nil {
		probePath := *typedInput.ProbePath
		parameters.ProbePath = &probePath
	}

	// Set property ‘ProbeProtocol’:
	if typedInput.ProbeProtocol != nil {
		probeProtocol := *typedInput.ProbeProtocol
		parameters.ProbeProtocol = &probeProtocol
	}

	// Set property ‘ProbeRequestType’:
	if typedInput.ProbeRequestType != nil {
		probeRequestType := *typedInput.ProbeRequestType
		parameters.ProbeRequestType = &probeRequestType
	}

	// No error
	return nil
}

// AssignPropertiesFromHealthProbeParameters populates our HealthProbeParameters from the provided source HealthProbeParameters
func (parameters *HealthProbeParameters) AssignPropertiesFromHealthProbeParameters(source *v20210601s.HealthProbeParameters) error {

	// ProbeIntervalInSeconds
	if source.ProbeIntervalInSeconds != nil {
		probeIntervalInSecond := *source.ProbeIntervalInSeconds
		parameters.ProbeIntervalInSeconds = &probeIntervalInSecond
	} else {
		parameters.ProbeIntervalInSeconds = nil
	}

	// ProbePath
	parameters.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProbeProtocol
	if source.ProbeProtocol != nil {
		probeProtocol := HealthProbeParameters_ProbeProtocol(*source.ProbeProtocol)
		parameters.ProbeProtocol = &probeProtocol
	} else {
		parameters.ProbeProtocol = nil
	}

	// ProbeRequestType
	if source.ProbeRequestType != nil {
		probeRequestType := HealthProbeParameters_ProbeRequestType(*source.ProbeRequestType)
		parameters.ProbeRequestType = &probeRequestType
	} else {
		parameters.ProbeRequestType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHealthProbeParameters populates the provided destination HealthProbeParameters from our HealthProbeParameters
func (parameters *HealthProbeParameters) AssignPropertiesToHealthProbeParameters(destination *v20210601s.HealthProbeParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ProbeIntervalInSeconds
	if parameters.ProbeIntervalInSeconds != nil {
		probeIntervalInSecond := *parameters.ProbeIntervalInSeconds
		destination.ProbeIntervalInSeconds = &probeIntervalInSecond
	} else {
		destination.ProbeIntervalInSeconds = nil
	}

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(parameters.ProbePath)

	// ProbeProtocol
	if parameters.ProbeProtocol != nil {
		probeProtocol := string(*parameters.ProbeProtocol)
		destination.ProbeProtocol = &probeProtocol
	} else {
		destination.ProbeProtocol = nil
	}

	// ProbeRequestType
	if parameters.ProbeRequestType != nil {
		probeRequestType := string(*parameters.ProbeRequestType)
		destination.ProbeRequestType = &probeRequestType
	} else {
		destination.ProbeRequestType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type HealthProbeParameters_STATUS struct {
	// ProbeIntervalInSeconds: The number of seconds between health probes.Default is 240sec.
	ProbeIntervalInSeconds *int `json:"probeIntervalInSeconds,omitempty"`

	// ProbePath: The path relative to the origin that is used to determine the health of the origin.
	ProbePath *string `json:"probePath,omitempty"`

	// ProbeProtocol: Protocol to use for health probe.
	ProbeProtocol *HealthProbeParameters_ProbeProtocol_STATUS `json:"probeProtocol,omitempty"`

	// ProbeRequestType: The type of health probe request that is made.
	ProbeRequestType *HealthProbeParameters_ProbeRequestType_STATUS `json:"probeRequestType,omitempty"`
}

var _ genruntime.FromARMConverter = &HealthProbeParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HealthProbeParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HealthProbeParameters_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HealthProbeParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HealthProbeParameters_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HealthProbeParameters_STATUSARM, got %T", armInput)
	}

	// Set property ‘ProbeIntervalInSeconds’:
	if typedInput.ProbeIntervalInSeconds != nil {
		probeIntervalInSeconds := *typedInput.ProbeIntervalInSeconds
		parameters.ProbeIntervalInSeconds = &probeIntervalInSeconds
	}

	// Set property ‘ProbePath’:
	if typedInput.ProbePath != nil {
		probePath := *typedInput.ProbePath
		parameters.ProbePath = &probePath
	}

	// Set property ‘ProbeProtocol’:
	if typedInput.ProbeProtocol != nil {
		probeProtocol := *typedInput.ProbeProtocol
		parameters.ProbeProtocol = &probeProtocol
	}

	// Set property ‘ProbeRequestType’:
	if typedInput.ProbeRequestType != nil {
		probeRequestType := *typedInput.ProbeRequestType
		parameters.ProbeRequestType = &probeRequestType
	}

	// No error
	return nil
}

// AssignPropertiesFromHealthProbeParameters_STATUS populates our HealthProbeParameters_STATUS from the provided source HealthProbeParameters_STATUS
func (parameters *HealthProbeParameters_STATUS) AssignPropertiesFromHealthProbeParameters_STATUS(source *v20210601s.HealthProbeParameters_STATUS) error {

	// ProbeIntervalInSeconds
	parameters.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(source.ProbeIntervalInSeconds)

	// ProbePath
	parameters.ProbePath = genruntime.ClonePointerToString(source.ProbePath)

	// ProbeProtocol
	if source.ProbeProtocol != nil {
		probeProtocol := HealthProbeParameters_ProbeProtocol_STATUS(*source.ProbeProtocol)
		parameters.ProbeProtocol = &probeProtocol
	} else {
		parameters.ProbeProtocol = nil
	}

	// ProbeRequestType
	if source.ProbeRequestType != nil {
		probeRequestType := HealthProbeParameters_ProbeRequestType_STATUS(*source.ProbeRequestType)
		parameters.ProbeRequestType = &probeRequestType
	} else {
		parameters.ProbeRequestType = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHealthProbeParameters_STATUS populates the provided destination HealthProbeParameters_STATUS from our HealthProbeParameters_STATUS
func (parameters *HealthProbeParameters_STATUS) AssignPropertiesToHealthProbeParameters_STATUS(destination *v20210601s.HealthProbeParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ProbeIntervalInSeconds
	destination.ProbeIntervalInSeconds = genruntime.ClonePointerToInt(parameters.ProbeIntervalInSeconds)

	// ProbePath
	destination.ProbePath = genruntime.ClonePointerToString(parameters.ProbePath)

	// ProbeProtocol
	if parameters.ProbeProtocol != nil {
		probeProtocol := string(*parameters.ProbeProtocol)
		destination.ProbeProtocol = &probeProtocol
	} else {
		destination.ProbeProtocol = nil
	}

	// ProbeRequestType
	if parameters.ProbeRequestType != nil {
		probeRequestType := string(*parameters.ProbeRequestType)
		destination.ProbeRequestType = &probeRequestType
	} else {
		destination.ProbeRequestType = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type KeyVaultSigningKeyParameters struct {
	// +kubebuilder:validation:Required
	// ResourceGroupName: Resource group of the user's Key Vault containing the secret
	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	// +kubebuilder:validation:Required
	// SecretName: The name of secret in Key Vault.
	SecretName *string `json:"secretName,omitempty"`

	// +kubebuilder:validation:Required
	// SecretVersion: The version(GUID) of secret in Key Vault.
	SecretVersion *string `json:"secretVersion,omitempty"`

	// +kubebuilder:validation:Required
	// SubscriptionId: Subscription Id of the user's Key Vault containing the secret
	SubscriptionId *string `json:"subscriptionId,omitempty"`

	// +kubebuilder:validation:Required
	TypeName *KeyVaultSigningKeyParameters_TypeName `json:"typeName,omitempty"`

	// +kubebuilder:validation:Required
	// VaultName: The name of the user's Key Vault containing the secret
	VaultName *string `json:"vaultName,omitempty"`
}

var _ genruntime.ARMTransformer = &KeyVaultSigningKeyParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *KeyVaultSigningKeyParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &KeyVaultSigningKeyParametersARM{}

	// Set property ‘ResourceGroupName’:
	if parameters.ResourceGroupName != nil {
		resourceGroupName := *parameters.ResourceGroupName
		result.ResourceGroupName = &resourceGroupName
	}

	// Set property ‘SecretName’:
	if parameters.SecretName != nil {
		secretName := *parameters.SecretName
		result.SecretName = &secretName
	}

	// Set property ‘SecretVersion’:
	if parameters.SecretVersion != nil {
		secretVersion := *parameters.SecretVersion
		result.SecretVersion = &secretVersion
	}

	// Set property ‘SubscriptionId’:
	if parameters.SubscriptionId != nil {
		subscriptionId := *parameters.SubscriptionId
		result.SubscriptionId = &subscriptionId
	}

	// Set property ‘TypeName’:
	if parameters.TypeName != nil {
		typeName := *parameters.TypeName
		result.TypeName = &typeName
	}

	// Set property ‘VaultName’:
	if parameters.VaultName != nil {
		vaultName := *parameters.VaultName
		result.VaultName = &vaultName
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *KeyVaultSigningKeyParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &KeyVaultSigningKeyParametersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *KeyVaultSigningKeyParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(KeyVaultSigningKeyParametersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected KeyVaultSigningKeyParametersARM, got %T", armInput)
	}

	// Set property ‘ResourceGroupName’:
	if typedInput.ResourceGroupName != nil {
		resourceGroupName := *typedInput.ResourceGroupName
		parameters.ResourceGroupName = &resourceGroupName
	}

	// Set property ‘SecretName’:
	if typedInput.SecretName != nil {
		secretName := *typedInput.SecretName
		parameters.SecretName = &secretName
	}

	// Set property ‘SecretVersion’:
	if typedInput.SecretVersion != nil {
		secretVersion := *typedInput.SecretVersion
		parameters.SecretVersion = &secretVersion
	}

	// Set property ‘SubscriptionId’:
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		parameters.SubscriptionId = &subscriptionId
	}

	// Set property ‘TypeName’:
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// Set property ‘VaultName’:
	if typedInput.VaultName != nil {
		vaultName := *typedInput.VaultName
		parameters.VaultName = &vaultName
	}

	// No error
	return nil
}

// AssignPropertiesFromKeyVaultSigningKeyParameters populates our KeyVaultSigningKeyParameters from the provided source KeyVaultSigningKeyParameters
func (parameters *KeyVaultSigningKeyParameters) AssignPropertiesFromKeyVaultSigningKeyParameters(source *v20210601s.KeyVaultSigningKeyParameters) error {

	// ResourceGroupName
	parameters.ResourceGroupName = genruntime.ClonePointerToString(source.ResourceGroupName)

	// SecretName
	parameters.SecretName = genruntime.ClonePointerToString(source.SecretName)

	// SecretVersion
	parameters.SecretVersion = genruntime.ClonePointerToString(source.SecretVersion)

	// SubscriptionId
	parameters.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// TypeName
	if source.TypeName != nil {
		typeName := KeyVaultSigningKeyParameters_TypeName(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// VaultName
	parameters.VaultName = genruntime.ClonePointerToString(source.VaultName)

	// No error
	return nil
}

// AssignPropertiesToKeyVaultSigningKeyParameters populates the provided destination KeyVaultSigningKeyParameters from our KeyVaultSigningKeyParameters
func (parameters *KeyVaultSigningKeyParameters) AssignPropertiesToKeyVaultSigningKeyParameters(destination *v20210601s.KeyVaultSigningKeyParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ResourceGroupName
	destination.ResourceGroupName = genruntime.ClonePointerToString(parameters.ResourceGroupName)

	// SecretName
	destination.SecretName = genruntime.ClonePointerToString(parameters.SecretName)

	// SecretVersion
	destination.SecretVersion = genruntime.ClonePointerToString(parameters.SecretVersion)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(parameters.SubscriptionId)

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// VaultName
	destination.VaultName = genruntime.ClonePointerToString(parameters.VaultName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type KeyVaultSigningKeyParameters_STATUS struct {
	// ResourceGroupName: Resource group of the user's Key Vault containing the secret
	ResourceGroupName *string `json:"resourceGroupName,omitempty"`

	// SecretName: The name of secret in Key Vault.
	SecretName *string `json:"secretName,omitempty"`

	// SecretVersion: The version(GUID) of secret in Key Vault.
	SecretVersion *string `json:"secretVersion,omitempty"`

	// SubscriptionId: Subscription Id of the user's Key Vault containing the secret
	SubscriptionId *string                                       `json:"subscriptionId,omitempty"`
	TypeName       *KeyVaultSigningKeyParameters_TypeName_STATUS `json:"typeName,omitempty"`

	// VaultName: The name of the user's Key Vault containing the secret
	VaultName *string `json:"vaultName,omitempty"`
}

var _ genruntime.FromARMConverter = &KeyVaultSigningKeyParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *KeyVaultSigningKeyParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &KeyVaultSigningKeyParameters_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *KeyVaultSigningKeyParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(KeyVaultSigningKeyParameters_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected KeyVaultSigningKeyParameters_STATUSARM, got %T", armInput)
	}

	// Set property ‘ResourceGroupName’:
	if typedInput.ResourceGroupName != nil {
		resourceGroupName := *typedInput.ResourceGroupName
		parameters.ResourceGroupName = &resourceGroupName
	}

	// Set property ‘SecretName’:
	if typedInput.SecretName != nil {
		secretName := *typedInput.SecretName
		parameters.SecretName = &secretName
	}

	// Set property ‘SecretVersion’:
	if typedInput.SecretVersion != nil {
		secretVersion := *typedInput.SecretVersion
		parameters.SecretVersion = &secretVersion
	}

	// Set property ‘SubscriptionId’:
	if typedInput.SubscriptionId != nil {
		subscriptionId := *typedInput.SubscriptionId
		parameters.SubscriptionId = &subscriptionId
	}

	// Set property ‘TypeName’:
	if typedInput.TypeName != nil {
		typeName := *typedInput.TypeName
		parameters.TypeName = &typeName
	}

	// Set property ‘VaultName’:
	if typedInput.VaultName != nil {
		vaultName := *typedInput.VaultName
		parameters.VaultName = &vaultName
	}

	// No error
	return nil
}

// AssignPropertiesFromKeyVaultSigningKeyParameters_STATUS populates our KeyVaultSigningKeyParameters_STATUS from the provided source KeyVaultSigningKeyParameters_STATUS
func (parameters *KeyVaultSigningKeyParameters_STATUS) AssignPropertiesFromKeyVaultSigningKeyParameters_STATUS(source *v20210601s.KeyVaultSigningKeyParameters_STATUS) error {

	// ResourceGroupName
	parameters.ResourceGroupName = genruntime.ClonePointerToString(source.ResourceGroupName)

	// SecretName
	parameters.SecretName = genruntime.ClonePointerToString(source.SecretName)

	// SecretVersion
	parameters.SecretVersion = genruntime.ClonePointerToString(source.SecretVersion)

	// SubscriptionId
	parameters.SubscriptionId = genruntime.ClonePointerToString(source.SubscriptionId)

	// TypeName
	if source.TypeName != nil {
		typeName := KeyVaultSigningKeyParameters_TypeName_STATUS(*source.TypeName)
		parameters.TypeName = &typeName
	} else {
		parameters.TypeName = nil
	}

	// VaultName
	parameters.VaultName = genruntime.ClonePointerToString(source.VaultName)

	// No error
	return nil
}

// AssignPropertiesToKeyVaultSigningKeyParameters_STATUS populates the provided destination KeyVaultSigningKeyParameters_STATUS from our KeyVaultSigningKeyParameters_STATUS
func (parameters *KeyVaultSigningKeyParameters_STATUS) AssignPropertiesToKeyVaultSigningKeyParameters_STATUS(destination *v20210601s.KeyVaultSigningKeyParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ResourceGroupName
	destination.ResourceGroupName = genruntime.ClonePointerToString(parameters.ResourceGroupName)

	// SecretName
	destination.SecretName = genruntime.ClonePointerToString(parameters.SecretName)

	// SecretVersion
	destination.SecretVersion = genruntime.ClonePointerToString(parameters.SecretVersion)

	// SubscriptionId
	destination.SubscriptionId = genruntime.ClonePointerToString(parameters.SubscriptionId)

	// TypeName
	if parameters.TypeName != nil {
		typeName := string(*parameters.TypeName)
		destination.TypeName = &typeName
	} else {
		destination.TypeName = nil
	}

	// VaultName
	destination.VaultName = genruntime.ClonePointerToString(parameters.VaultName)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Approved","Disconnected","Pending","Rejected","Timeout"}
type PrivateEndpointStatus string

const (
	PrivateEndpointStatusApproved     = PrivateEndpointStatus("Approved")
	PrivateEndpointStatusDisconnected = PrivateEndpointStatus("Disconnected")
	PrivateEndpointStatusPending      = PrivateEndpointStatus("Pending")
	PrivateEndpointStatusRejected     = PrivateEndpointStatus("Rejected")
	PrivateEndpointStatusTimeout      = PrivateEndpointStatus("Timeout")
)

type PrivateEndpointStatus_STATUS string

const (
	PrivateEndpointStatus_STATUSApproved     = PrivateEndpointStatus_STATUS("Approved")
	PrivateEndpointStatus_STATUSDisconnected = PrivateEndpointStatus_STATUS("Disconnected")
	PrivateEndpointStatus_STATUSPending      = PrivateEndpointStatus_STATUS("Pending")
	PrivateEndpointStatus_STATUSRejected     = PrivateEndpointStatus_STATUS("Rejected")
	PrivateEndpointStatus_STATUSTimeout      = PrivateEndpointStatus_STATUS("Timeout")
)

type ResponseBasedOriginErrorDetectionParameters struct {
	// HttpErrorRanges: The list of Http status code ranges that are considered as server errors for origin and it is marked as
	// unhealthy.
	HttpErrorRanges []HttpErrorRangeParameters `json:"httpErrorRanges,omitempty"`

	// ResponseBasedDetectedErrorTypes: Type of response errors for real user requests for which origin will be deemed unhealthy
	ResponseBasedDetectedErrorTypes *ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes `json:"responseBasedDetectedErrorTypes,omitempty"`

	// +kubebuilder:validation:Maximum=100
	// +kubebuilder:validation:Minimum=0
	// ResponseBasedFailoverThresholdPercentage: The percentage of failed requests in the sample where failover should trigger.
	ResponseBasedFailoverThresholdPercentage *int `json:"responseBasedFailoverThresholdPercentage,omitempty"`
}

var _ genruntime.ARMTransformer = &ResponseBasedOriginErrorDetectionParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *ResponseBasedOriginErrorDetectionParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &ResponseBasedOriginErrorDetectionParametersARM{}

	// Set property ‘HttpErrorRanges’:
	for _, item := range parameters.HttpErrorRanges {
		itemARM, err := item.ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		result.HttpErrorRanges = append(result.HttpErrorRanges, *itemARM.(*HttpErrorRangeParametersARM))
	}

	// Set property ‘ResponseBasedDetectedErrorTypes’:
	if parameters.ResponseBasedDetectedErrorTypes != nil {
		responseBasedDetectedErrorTypes := *parameters.ResponseBasedDetectedErrorTypes
		result.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorTypes
	}

	// Set property ‘ResponseBasedFailoverThresholdPercentage’:
	if parameters.ResponseBasedFailoverThresholdPercentage != nil {
		responseBasedFailoverThresholdPercentage := *parameters.ResponseBasedFailoverThresholdPercentage
		result.ResponseBasedFailoverThresholdPercentage = &responseBasedFailoverThresholdPercentage
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ResponseBasedOriginErrorDetectionParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResponseBasedOriginErrorDetectionParametersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ResponseBasedOriginErrorDetectionParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResponseBasedOriginErrorDetectionParametersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResponseBasedOriginErrorDetectionParametersARM, got %T", armInput)
	}

	// Set property ‘HttpErrorRanges’:
	for _, item := range typedInput.HttpErrorRanges {
		var item1 HttpErrorRangeParameters
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		parameters.HttpErrorRanges = append(parameters.HttpErrorRanges, item1)
	}

	// Set property ‘ResponseBasedDetectedErrorTypes’:
	if typedInput.ResponseBasedDetectedErrorTypes != nil {
		responseBasedDetectedErrorTypes := *typedInput.ResponseBasedDetectedErrorTypes
		parameters.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorTypes
	}

	// Set property ‘ResponseBasedFailoverThresholdPercentage’:
	if typedInput.ResponseBasedFailoverThresholdPercentage != nil {
		responseBasedFailoverThresholdPercentage := *typedInput.ResponseBasedFailoverThresholdPercentage
		parameters.ResponseBasedFailoverThresholdPercentage = &responseBasedFailoverThresholdPercentage
	}

	// No error
	return nil
}

// AssignPropertiesFromResponseBasedOriginErrorDetectionParameters populates our ResponseBasedOriginErrorDetectionParameters from the provided source ResponseBasedOriginErrorDetectionParameters
func (parameters *ResponseBasedOriginErrorDetectionParameters) AssignPropertiesFromResponseBasedOriginErrorDetectionParameters(source *v20210601s.ResponseBasedOriginErrorDetectionParameters) error {

	// HttpErrorRanges
	if source.HttpErrorRanges != nil {
		httpErrorRangeList := make([]HttpErrorRangeParameters, len(source.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range source.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange HttpErrorRangeParameters
			err := httpErrorRange.AssignPropertiesFromHttpErrorRangeParameters(&httpErrorRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromHttpErrorRangeParameters() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		parameters.HttpErrorRanges = httpErrorRangeList
	} else {
		parameters.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	if source.ResponseBasedDetectedErrorTypes != nil {
		responseBasedDetectedErrorType := ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes(*source.ResponseBasedDetectedErrorTypes)
		parameters.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorType
	} else {
		parameters.ResponseBasedDetectedErrorTypes = nil
	}

	// ResponseBasedFailoverThresholdPercentage
	if source.ResponseBasedFailoverThresholdPercentage != nil {
		responseBasedFailoverThresholdPercentage := *source.ResponseBasedFailoverThresholdPercentage
		parameters.ResponseBasedFailoverThresholdPercentage = &responseBasedFailoverThresholdPercentage
	} else {
		parameters.ResponseBasedFailoverThresholdPercentage = nil
	}

	// No error
	return nil
}

// AssignPropertiesToResponseBasedOriginErrorDetectionParameters populates the provided destination ResponseBasedOriginErrorDetectionParameters from our ResponseBasedOriginErrorDetectionParameters
func (parameters *ResponseBasedOriginErrorDetectionParameters) AssignPropertiesToResponseBasedOriginErrorDetectionParameters(destination *v20210601s.ResponseBasedOriginErrorDetectionParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpErrorRanges
	if parameters.HttpErrorRanges != nil {
		httpErrorRangeList := make([]v20210601s.HttpErrorRangeParameters, len(parameters.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range parameters.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange v20210601s.HttpErrorRangeParameters
			err := httpErrorRangeItem.AssignPropertiesToHttpErrorRangeParameters(&httpErrorRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToHttpErrorRangeParameters() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		destination.HttpErrorRanges = httpErrorRangeList
	} else {
		destination.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	if parameters.ResponseBasedDetectedErrorTypes != nil {
		responseBasedDetectedErrorType := string(*parameters.ResponseBasedDetectedErrorTypes)
		destination.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorType
	} else {
		destination.ResponseBasedDetectedErrorTypes = nil
	}

	// ResponseBasedFailoverThresholdPercentage
	if parameters.ResponseBasedFailoverThresholdPercentage != nil {
		responseBasedFailoverThresholdPercentage := *parameters.ResponseBasedFailoverThresholdPercentage
		destination.ResponseBasedFailoverThresholdPercentage = &responseBasedFailoverThresholdPercentage
	} else {
		destination.ResponseBasedFailoverThresholdPercentage = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ResponseBasedOriginErrorDetectionParameters_STATUS struct {
	// HttpErrorRanges: The list of Http status code ranges that are considered as server errors for origin and it is marked as
	// unhealthy.
	HttpErrorRanges []HttpErrorRangeParameters_STATUS `json:"httpErrorRanges,omitempty"`

	// ResponseBasedDetectedErrorTypes: Type of response errors for real user requests for which origin will be deemed unhealthy
	ResponseBasedDetectedErrorTypes *ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS `json:"responseBasedDetectedErrorTypes,omitempty"`

	// ResponseBasedFailoverThresholdPercentage: The percentage of failed requests in the sample where failover should trigger.
	ResponseBasedFailoverThresholdPercentage *int `json:"responseBasedFailoverThresholdPercentage,omitempty"`
}

var _ genruntime.FromARMConverter = &ResponseBasedOriginErrorDetectionParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *ResponseBasedOriginErrorDetectionParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ResponseBasedOriginErrorDetectionParameters_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *ResponseBasedOriginErrorDetectionParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ResponseBasedOriginErrorDetectionParameters_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ResponseBasedOriginErrorDetectionParameters_STATUSARM, got %T", armInput)
	}

	// Set property ‘HttpErrorRanges’:
	for _, item := range typedInput.HttpErrorRanges {
		var item1 HttpErrorRangeParameters_STATUS
		err := item1.PopulateFromARM(owner, item)
		if err != nil {
			return err
		}
		parameters.HttpErrorRanges = append(parameters.HttpErrorRanges, item1)
	}

	// Set property ‘ResponseBasedDetectedErrorTypes’:
	if typedInput.ResponseBasedDetectedErrorTypes != nil {
		responseBasedDetectedErrorTypes := *typedInput.ResponseBasedDetectedErrorTypes
		parameters.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorTypes
	}

	// Set property ‘ResponseBasedFailoverThresholdPercentage’:
	if typedInput.ResponseBasedFailoverThresholdPercentage != nil {
		responseBasedFailoverThresholdPercentage := *typedInput.ResponseBasedFailoverThresholdPercentage
		parameters.ResponseBasedFailoverThresholdPercentage = &responseBasedFailoverThresholdPercentage
	}

	// No error
	return nil
}

// AssignPropertiesFromResponseBasedOriginErrorDetectionParameters_STATUS populates our ResponseBasedOriginErrorDetectionParameters_STATUS from the provided source ResponseBasedOriginErrorDetectionParameters_STATUS
func (parameters *ResponseBasedOriginErrorDetectionParameters_STATUS) AssignPropertiesFromResponseBasedOriginErrorDetectionParameters_STATUS(source *v20210601s.ResponseBasedOriginErrorDetectionParameters_STATUS) error {

	// HttpErrorRanges
	if source.HttpErrorRanges != nil {
		httpErrorRangeList := make([]HttpErrorRangeParameters_STATUS, len(source.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range source.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange HttpErrorRangeParameters_STATUS
			err := httpErrorRange.AssignPropertiesFromHttpErrorRangeParameters_STATUS(&httpErrorRangeItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromHttpErrorRangeParameters_STATUS() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		parameters.HttpErrorRanges = httpErrorRangeList
	} else {
		parameters.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	if source.ResponseBasedDetectedErrorTypes != nil {
		responseBasedDetectedErrorType := ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS(*source.ResponseBasedDetectedErrorTypes)
		parameters.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorType
	} else {
		parameters.ResponseBasedDetectedErrorTypes = nil
	}

	// ResponseBasedFailoverThresholdPercentage
	parameters.ResponseBasedFailoverThresholdPercentage = genruntime.ClonePointerToInt(source.ResponseBasedFailoverThresholdPercentage)

	// No error
	return nil
}

// AssignPropertiesToResponseBasedOriginErrorDetectionParameters_STATUS populates the provided destination ResponseBasedOriginErrorDetectionParameters_STATUS from our ResponseBasedOriginErrorDetectionParameters_STATUS
func (parameters *ResponseBasedOriginErrorDetectionParameters_STATUS) AssignPropertiesToResponseBasedOriginErrorDetectionParameters_STATUS(destination *v20210601s.ResponseBasedOriginErrorDetectionParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// HttpErrorRanges
	if parameters.HttpErrorRanges != nil {
		httpErrorRangeList := make([]v20210601s.HttpErrorRangeParameters_STATUS, len(parameters.HttpErrorRanges))
		for httpErrorRangeIndex, httpErrorRangeItem := range parameters.HttpErrorRanges {
			// Shadow the loop variable to avoid aliasing
			httpErrorRangeItem := httpErrorRangeItem
			var httpErrorRange v20210601s.HttpErrorRangeParameters_STATUS
			err := httpErrorRangeItem.AssignPropertiesToHttpErrorRangeParameters_STATUS(&httpErrorRange)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToHttpErrorRangeParameters_STATUS() to populate field HttpErrorRanges")
			}
			httpErrorRangeList[httpErrorRangeIndex] = httpErrorRange
		}
		destination.HttpErrorRanges = httpErrorRangeList
	} else {
		destination.HttpErrorRanges = nil
	}

	// ResponseBasedDetectedErrorTypes
	if parameters.ResponseBasedDetectedErrorTypes != nil {
		responseBasedDetectedErrorType := string(*parameters.ResponseBasedDetectedErrorTypes)
		destination.ResponseBasedDetectedErrorTypes = &responseBasedDetectedErrorType
	} else {
		destination.ResponseBasedDetectedErrorTypes = nil
	}

	// ResponseBasedFailoverThresholdPercentage
	destination.ResponseBasedFailoverThresholdPercentage = genruntime.ClonePointerToInt(parameters.ResponseBasedFailoverThresholdPercentage)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"AzureKeyVault","Cdn"}
type CustomDomainHttpsParameters_CertificateSource string

const (
	CustomDomainHttpsParameters_CertificateSourceAzureKeyVault = CustomDomainHttpsParameters_CertificateSource("AzureKeyVault")
	CustomDomainHttpsParameters_CertificateSourceCdn           = CustomDomainHttpsParameters_CertificateSource("Cdn")
)

type CustomDomainHttpsParameters_CertificateSource_STATUS string

const (
	CustomDomainHttpsParameters_CertificateSource_STATUSAzureKeyVault = CustomDomainHttpsParameters_CertificateSource_STATUS("AzureKeyVault")
	CustomDomainHttpsParameters_CertificateSource_STATUSCdn           = CustomDomainHttpsParameters_CertificateSource_STATUS("Cdn")
)

// +kubebuilder:validation:Enum={"None","TLS10","TLS12"}
type CustomDomainHttpsParameters_MinimumTlsVersion string

const (
	CustomDomainHttpsParameters_MinimumTlsVersionNone  = CustomDomainHttpsParameters_MinimumTlsVersion("None")
	CustomDomainHttpsParameters_MinimumTlsVersionTLS10 = CustomDomainHttpsParameters_MinimumTlsVersion("TLS10")
	CustomDomainHttpsParameters_MinimumTlsVersionTLS12 = CustomDomainHttpsParameters_MinimumTlsVersion("TLS12")
)

type CustomDomainHttpsParameters_MinimumTlsVersion_STATUS string

const (
	CustomDomainHttpsParameters_MinimumTlsVersion_STATUSNone  = CustomDomainHttpsParameters_MinimumTlsVersion_STATUS("None")
	CustomDomainHttpsParameters_MinimumTlsVersion_STATUSTLS10 = CustomDomainHttpsParameters_MinimumTlsVersion_STATUS("TLS10")
	CustomDomainHttpsParameters_MinimumTlsVersion_STATUSTLS12 = CustomDomainHttpsParameters_MinimumTlsVersion_STATUS("TLS12")
)

// +kubebuilder:validation:Enum={"IPBased","ServerNameIndication"}
type CustomDomainHttpsParameters_ProtocolType string

const (
	CustomDomainHttpsParameters_ProtocolTypeIPBased              = CustomDomainHttpsParameters_ProtocolType("IPBased")
	CustomDomainHttpsParameters_ProtocolTypeServerNameIndication = CustomDomainHttpsParameters_ProtocolType("ServerNameIndication")
)

type CustomDomainHttpsParameters_ProtocolType_STATUS string

const (
	CustomDomainHttpsParameters_ProtocolType_STATUSIPBased              = CustomDomainHttpsParameters_ProtocolType_STATUS("IPBased")
	CustomDomainHttpsParameters_ProtocolType_STATUSServerNameIndication = CustomDomainHttpsParameters_ProtocolType_STATUS("ServerNameIndication")
)

type DeliveryRuleAction struct {
	// +kubebuilder:validation:Required
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleAction_Name `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleAction{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (action *DeliveryRuleAction) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if action == nil {
		return nil, nil
	}
	result := &DeliveryRuleActionARM{}

	// Set property ‘Name’:
	if action.Name != nil {
		name := *action.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleAction) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleActionARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleAction) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleActionARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleActionARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		action.Name = &name
	}

	// No error
	return nil
}

// AssignPropertiesFromDeliveryRuleAction populates our DeliveryRuleAction from the provided source DeliveryRuleAction
func (action *DeliveryRuleAction) AssignPropertiesFromDeliveryRuleAction(source *v20210601s.DeliveryRuleAction) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleAction_Name(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleAction populates the provided destination DeliveryRuleAction from our DeliveryRuleAction
func (action *DeliveryRuleAction) AssignPropertiesToDeliveryRuleAction(destination *v20210601s.DeliveryRuleAction) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleAction_STATUS struct {
	// Name: The name of the action for the delivery rule.
	Name *DeliveryRuleAction_Name_STATUS `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleAction_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (action *DeliveryRuleAction_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleAction_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (action *DeliveryRuleAction_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleAction_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleAction_STATUSARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		action.Name = &name
	}

	// No error
	return nil
}

// AssignPropertiesFromDeliveryRuleAction_STATUS populates our DeliveryRuleAction_STATUS from the provided source DeliveryRuleAction_STATUS
func (action *DeliveryRuleAction_STATUS) AssignPropertiesFromDeliveryRuleAction_STATUS(source *v20210601s.DeliveryRuleAction_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleAction_Name_STATUS(*source.Name)
		action.Name = &name
	} else {
		action.Name = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleAction_STATUS populates the provided destination DeliveryRuleAction_STATUS from our DeliveryRuleAction_STATUS
func (action *DeliveryRuleAction_STATUS) AssignPropertiesToDeliveryRuleAction_STATUS(destination *v20210601s.DeliveryRuleAction_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if action.Name != nil {
		name := string(*action.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleCondition struct {
	// +kubebuilder:validation:Required
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleCondition_Name `json:"name,omitempty"`
}

var _ genruntime.ARMTransformer = &DeliveryRuleCondition{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (condition *DeliveryRuleCondition) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if condition == nil {
		return nil, nil
	}
	result := &DeliveryRuleConditionARM{}

	// Set property ‘Name’:
	if condition.Name != nil {
		name := *condition.Name
		result.Name = &name
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleCondition) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleConditionARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleCondition) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleConditionARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleConditionARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		condition.Name = &name
	}

	// No error
	return nil
}

// AssignPropertiesFromDeliveryRuleCondition populates our DeliveryRuleCondition from the provided source DeliveryRuleCondition
func (condition *DeliveryRuleCondition) AssignPropertiesFromDeliveryRuleCondition(source *v20210601s.DeliveryRuleCondition) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleCondition_Name(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleCondition populates the provided destination DeliveryRuleCondition from our DeliveryRuleCondition
func (condition *DeliveryRuleCondition) AssignPropertiesToDeliveryRuleCondition(destination *v20210601s.DeliveryRuleCondition) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type DeliveryRuleCondition_STATUS struct {
	// Name: The name of the condition for the delivery rule.
	Name *DeliveryRuleCondition_Name_STATUS `json:"name,omitempty"`
}

var _ genruntime.FromARMConverter = &DeliveryRuleCondition_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (condition *DeliveryRuleCondition_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &DeliveryRuleCondition_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (condition *DeliveryRuleCondition_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(DeliveryRuleCondition_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected DeliveryRuleCondition_STATUSARM, got %T", armInput)
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		condition.Name = &name
	}

	// No error
	return nil
}

// AssignPropertiesFromDeliveryRuleCondition_STATUS populates our DeliveryRuleCondition_STATUS from the provided source DeliveryRuleCondition_STATUS
func (condition *DeliveryRuleCondition_STATUS) AssignPropertiesFromDeliveryRuleCondition_STATUS(source *v20210601s.DeliveryRuleCondition_STATUS) error {

	// Name
	if source.Name != nil {
		name := DeliveryRuleCondition_Name_STATUS(*source.Name)
		condition.Name = &name
	} else {
		condition.Name = nil
	}

	// No error
	return nil
}

// AssignPropertiesToDeliveryRuleCondition_STATUS populates the provided destination DeliveryRuleCondition_STATUS from our DeliveryRuleCondition_STATUS
func (condition *DeliveryRuleCondition_STATUS) AssignPropertiesToDeliveryRuleCondition_STATUS(destination *v20210601s.DeliveryRuleCondition_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Name
	if condition.Name != nil {
		name := string(*condition.Name)
		destination.Name = &name
	} else {
		destination.Name = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"Http","Https","NotSet"}
type HealthProbeParameters_ProbeProtocol string

const (
	HealthProbeParameters_ProbeProtocolHttp   = HealthProbeParameters_ProbeProtocol("Http")
	HealthProbeParameters_ProbeProtocolHttps  = HealthProbeParameters_ProbeProtocol("Https")
	HealthProbeParameters_ProbeProtocolNotSet = HealthProbeParameters_ProbeProtocol("NotSet")
)

type HealthProbeParameters_ProbeProtocol_STATUS string

const (
	HealthProbeParameters_ProbeProtocol_STATUSHttp   = HealthProbeParameters_ProbeProtocol_STATUS("Http")
	HealthProbeParameters_ProbeProtocol_STATUSHttps  = HealthProbeParameters_ProbeProtocol_STATUS("Https")
	HealthProbeParameters_ProbeProtocol_STATUSNotSet = HealthProbeParameters_ProbeProtocol_STATUS("NotSet")
)

// +kubebuilder:validation:Enum={"GET","HEAD","NotSet"}
type HealthProbeParameters_ProbeRequestType string

const (
	HealthProbeParameters_ProbeRequestTypeGET    = HealthProbeParameters_ProbeRequestType("GET")
	HealthProbeParameters_ProbeRequestTypeHEAD   = HealthProbeParameters_ProbeRequestType("HEAD")
	HealthProbeParameters_ProbeRequestTypeNotSet = HealthProbeParameters_ProbeRequestType("NotSet")
)

type HealthProbeParameters_ProbeRequestType_STATUS string

const (
	HealthProbeParameters_ProbeRequestType_STATUSGET    = HealthProbeParameters_ProbeRequestType_STATUS("GET")
	HealthProbeParameters_ProbeRequestType_STATUSHEAD   = HealthProbeParameters_ProbeRequestType_STATUS("HEAD")
	HealthProbeParameters_ProbeRequestType_STATUSNotSet = HealthProbeParameters_ProbeRequestType_STATUS("NotSet")
)

type HttpErrorRangeParameters struct {
	// +kubebuilder:validation:Maximum=999
	// +kubebuilder:validation:Minimum=100
	// Begin: The inclusive start of the http status code range.
	Begin *int `json:"begin,omitempty"`

	// +kubebuilder:validation:Maximum=999
	// +kubebuilder:validation:Minimum=100
	// End: The inclusive end of the http status code range.
	End *int `json:"end,omitempty"`
}

var _ genruntime.ARMTransformer = &HttpErrorRangeParameters{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (parameters *HttpErrorRangeParameters) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if parameters == nil {
		return nil, nil
	}
	result := &HttpErrorRangeParametersARM{}

	// Set property ‘Begin’:
	if parameters.Begin != nil {
		begin := *parameters.Begin
		result.Begin = &begin
	}

	// Set property ‘End’:
	if parameters.End != nil {
		end := *parameters.End
		result.End = &end
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HttpErrorRangeParameters) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HttpErrorRangeParametersARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HttpErrorRangeParameters) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HttpErrorRangeParametersARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HttpErrorRangeParametersARM, got %T", armInput)
	}

	// Set property ‘Begin’:
	if typedInput.Begin != nil {
		begin := *typedInput.Begin
		parameters.Begin = &begin
	}

	// Set property ‘End’:
	if typedInput.End != nil {
		end := *typedInput.End
		parameters.End = &end
	}

	// No error
	return nil
}

// AssignPropertiesFromHttpErrorRangeParameters populates our HttpErrorRangeParameters from the provided source HttpErrorRangeParameters
func (parameters *HttpErrorRangeParameters) AssignPropertiesFromHttpErrorRangeParameters(source *v20210601s.HttpErrorRangeParameters) error {

	// Begin
	if source.Begin != nil {
		begin := *source.Begin
		parameters.Begin = &begin
	} else {
		parameters.Begin = nil
	}

	// End
	if source.End != nil {
		end := *source.End
		parameters.End = &end
	} else {
		parameters.End = nil
	}

	// No error
	return nil
}

// AssignPropertiesToHttpErrorRangeParameters populates the provided destination HttpErrorRangeParameters from our HttpErrorRangeParameters
func (parameters *HttpErrorRangeParameters) AssignPropertiesToHttpErrorRangeParameters(destination *v20210601s.HttpErrorRangeParameters) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Begin
	if parameters.Begin != nil {
		begin := *parameters.Begin
		destination.Begin = &begin
	} else {
		destination.Begin = nil
	}

	// End
	if parameters.End != nil {
		end := *parameters.End
		destination.End = &end
	} else {
		destination.End = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type HttpErrorRangeParameters_STATUS struct {
	// Begin: The inclusive start of the http status code range.
	Begin *int `json:"begin,omitempty"`

	// End: The inclusive end of the http status code range.
	End *int `json:"end,omitempty"`
}

var _ genruntime.FromARMConverter = &HttpErrorRangeParameters_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (parameters *HttpErrorRangeParameters_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &HttpErrorRangeParameters_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (parameters *HttpErrorRangeParameters_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(HttpErrorRangeParameters_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected HttpErrorRangeParameters_STATUSARM, got %T", armInput)
	}

	// Set property ‘Begin’:
	if typedInput.Begin != nil {
		begin := *typedInput.Begin
		parameters.Begin = &begin
	}

	// Set property ‘End’:
	if typedInput.End != nil {
		end := *typedInput.End
		parameters.End = &end
	}

	// No error
	return nil
}

// AssignPropertiesFromHttpErrorRangeParameters_STATUS populates our HttpErrorRangeParameters_STATUS from the provided source HttpErrorRangeParameters_STATUS
func (parameters *HttpErrorRangeParameters_STATUS) AssignPropertiesFromHttpErrorRangeParameters_STATUS(source *v20210601s.HttpErrorRangeParameters_STATUS) error {

	// Begin
	parameters.Begin = genruntime.ClonePointerToInt(source.Begin)

	// End
	parameters.End = genruntime.ClonePointerToInt(source.End)

	// No error
	return nil
}

// AssignPropertiesToHttpErrorRangeParameters_STATUS populates the provided destination HttpErrorRangeParameters_STATUS from our HttpErrorRangeParameters_STATUS
func (parameters *HttpErrorRangeParameters_STATUS) AssignPropertiesToHttpErrorRangeParameters_STATUS(destination *v20210601s.HttpErrorRangeParameters_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Begin
	destination.Begin = genruntime.ClonePointerToInt(parameters.Begin)

	// End
	destination.End = genruntime.ClonePointerToInt(parameters.End)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// +kubebuilder:validation:Enum={"KeyVaultSigningKeyParameters"}
type KeyVaultSigningKeyParameters_TypeName string

const KeyVaultSigningKeyParameters_TypeNameKeyVaultSigningKeyParameters = KeyVaultSigningKeyParameters_TypeName("KeyVaultSigningKeyParameters")

// +kubebuilder:validation:Enum={"None","TcpAndHttpErrors","TcpErrorsOnly"}
type ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes string

const (
	ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypesNone             = ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes("None")
	ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypesTcpAndHttpErrors = ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes("TcpAndHttpErrors")
	ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypesTcpErrorsOnly    = ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes("TcpErrorsOnly")
)

type ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS string

const (
	ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUSNone             = ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS("None")
	ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUSTcpAndHttpErrors = ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS("TcpAndHttpErrors")
	ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUSTcpErrorsOnly    = ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS("TcpErrorsOnly")
)

// +kubebuilder:validation:Enum={"CacheExpiration","CacheKeyQueryString","ModifyRequestHeader","ModifyResponseHeader","OriginGroupOverride","RouteConfigurationOverride","UrlRedirect","UrlRewrite","UrlSigning"}
type DeliveryRuleAction_Name string

const (
	DeliveryRuleAction_NameCacheExpiration            = DeliveryRuleAction_Name("CacheExpiration")
	DeliveryRuleAction_NameCacheKeyQueryString        = DeliveryRuleAction_Name("CacheKeyQueryString")
	DeliveryRuleAction_NameModifyRequestHeader        = DeliveryRuleAction_Name("ModifyRequestHeader")
	DeliveryRuleAction_NameModifyResponseHeader       = DeliveryRuleAction_Name("ModifyResponseHeader")
	DeliveryRuleAction_NameOriginGroupOverride        = DeliveryRuleAction_Name("OriginGroupOverride")
	DeliveryRuleAction_NameRouteConfigurationOverride = DeliveryRuleAction_Name("RouteConfigurationOverride")
	DeliveryRuleAction_NameUrlRedirect                = DeliveryRuleAction_Name("UrlRedirect")
	DeliveryRuleAction_NameUrlRewrite                 = DeliveryRuleAction_Name("UrlRewrite")
	DeliveryRuleAction_NameUrlSigning                 = DeliveryRuleAction_Name("UrlSigning")
)

// +kubebuilder:validation:Enum={"ClientPort","Cookies","HostName","HttpVersion","IsDevice","PostArgs","QueryString","RemoteAddress","RequestBody","RequestHeader","RequestMethod","RequestScheme","RequestUri","ServerPort","SocketAddr","SslProtocol","UrlFileExtension","UrlFileName","UrlPath"}
type DeliveryRuleCondition_Name string

const (
	DeliveryRuleCondition_NameClientPort       = DeliveryRuleCondition_Name("ClientPort")
	DeliveryRuleCondition_NameCookies          = DeliveryRuleCondition_Name("Cookies")
	DeliveryRuleCondition_NameHostName         = DeliveryRuleCondition_Name("HostName")
	DeliveryRuleCondition_NameHttpVersion      = DeliveryRuleCondition_Name("HttpVersion")
	DeliveryRuleCondition_NameIsDevice         = DeliveryRuleCondition_Name("IsDevice")
	DeliveryRuleCondition_NamePostArgs         = DeliveryRuleCondition_Name("PostArgs")
	DeliveryRuleCondition_NameQueryString      = DeliveryRuleCondition_Name("QueryString")
	DeliveryRuleCondition_NameRemoteAddress    = DeliveryRuleCondition_Name("RemoteAddress")
	DeliveryRuleCondition_NameRequestBody      = DeliveryRuleCondition_Name("RequestBody")
	DeliveryRuleCondition_NameRequestHeader    = DeliveryRuleCondition_Name("RequestHeader")
	DeliveryRuleCondition_NameRequestMethod    = DeliveryRuleCondition_Name("RequestMethod")
	DeliveryRuleCondition_NameRequestScheme    = DeliveryRuleCondition_Name("RequestScheme")
	DeliveryRuleCondition_NameRequestUri       = DeliveryRuleCondition_Name("RequestUri")
	DeliveryRuleCondition_NameServerPort       = DeliveryRuleCondition_Name("ServerPort")
	DeliveryRuleCondition_NameSocketAddr       = DeliveryRuleCondition_Name("SocketAddr")
	DeliveryRuleCondition_NameSslProtocol      = DeliveryRuleCondition_Name("SslProtocol")
	DeliveryRuleCondition_NameUrlFileExtension = DeliveryRuleCondition_Name("UrlFileExtension")
	DeliveryRuleCondition_NameUrlFileName      = DeliveryRuleCondition_Name("UrlFileName")
	DeliveryRuleCondition_NameUrlPath          = DeliveryRuleCondition_Name("UrlPath")
)

func init() {
	SchemeBuilder.Register(&ProfilesEndpoint{}, &ProfilesEndpointList{})
}
