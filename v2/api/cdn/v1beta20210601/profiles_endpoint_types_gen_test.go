// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210601

import (
	"encoding/json"
	v20210601s "github.com/Azure/azure-service-operator/v2/api/cdn/v1beta20210601storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ProfilesEndpoint_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ProfilesEndpoint to hub returns original",
		prop.ForAll(RunResourceConversionTestForProfilesEndpoint, ProfilesEndpointGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForProfilesEndpoint tests if a specific instance of ProfilesEndpoint round trips to the hub storage version and back losslessly
func RunResourceConversionTestForProfilesEndpoint(subject ProfilesEndpoint) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20210601s.ProfilesEndpoint
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual ProfilesEndpoint
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ProfilesEndpoint_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ProfilesEndpoint to ProfilesEndpoint via AssignProperties_To_ProfilesEndpoint & AssignProperties_From_ProfilesEndpoint returns original",
		prop.ForAll(RunPropertyAssignmentTestForProfilesEndpoint, ProfilesEndpointGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProfilesEndpoint tests if a specific instance of ProfilesEndpoint can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForProfilesEndpoint(subject ProfilesEndpoint) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ProfilesEndpoint
	err := copied.AssignProperties_To_ProfilesEndpoint(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ProfilesEndpoint
	err = actual.AssignProperties_From_ProfilesEndpoint(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ProfilesEndpoint_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProfilesEndpoint via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfilesEndpoint, ProfilesEndpointGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfilesEndpoint runs a test to see if a specific instance of ProfilesEndpoint round trips to JSON and back losslessly
func RunJSONSerializationTestForProfilesEndpoint(subject ProfilesEndpoint) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProfilesEndpoint
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProfilesEndpoint instances for property testing - lazily instantiated by ProfilesEndpointGenerator()
var profilesEndpointGenerator gopter.Gen

// ProfilesEndpointGenerator returns a generator of ProfilesEndpoint instances for property testing.
func ProfilesEndpointGenerator() gopter.Gen {
	if profilesEndpointGenerator != nil {
		return profilesEndpointGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForProfilesEndpoint(generators)
	profilesEndpointGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoint{}), generators)

	return profilesEndpointGenerator
}

// AddRelatedPropertyGeneratorsForProfilesEndpoint is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfilesEndpoint(gens map[string]gopter.Gen) {
	gens["Spec"] = Profiles_Endpoint_SpecGenerator()
	gens["Status"] = Profiles_Endpoint_STATUSGenerator()
}

func Test_Profiles_Endpoint_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Profiles_Endpoint_Spec to Profiles_Endpoint_Spec via AssignProperties_To_Profiles_Endpoint_Spec & AssignProperties_From_Profiles_Endpoint_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForProfiles_Endpoint_Spec, Profiles_Endpoint_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProfiles_Endpoint_Spec tests if a specific instance of Profiles_Endpoint_Spec can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForProfiles_Endpoint_Spec(subject Profiles_Endpoint_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.Profiles_Endpoint_Spec
	err := copied.AssignProperties_To_Profiles_Endpoint_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Profiles_Endpoint_Spec
	err = actual.AssignProperties_From_Profiles_Endpoint_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Profiles_Endpoint_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Profiles_Endpoint_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfiles_Endpoint_Spec, Profiles_Endpoint_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfiles_Endpoint_Spec runs a test to see if a specific instance of Profiles_Endpoint_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForProfiles_Endpoint_Spec(subject Profiles_Endpoint_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Profiles_Endpoint_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Profiles_Endpoint_Spec instances for property testing - lazily instantiated by
// Profiles_Endpoint_SpecGenerator()
var profiles_Endpoint_SpecGenerator gopter.Gen

// Profiles_Endpoint_SpecGenerator returns a generator of Profiles_Endpoint_Spec instances for property testing.
// We first initialize profiles_Endpoint_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Profiles_Endpoint_SpecGenerator() gopter.Gen {
	if profiles_Endpoint_SpecGenerator != nil {
		return profiles_Endpoint_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec(generators)
	profiles_Endpoint_SpecGenerator = gen.Struct(reflect.TypeOf(Profiles_Endpoint_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec(generators)
	AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec(generators)
	profiles_Endpoint_SpecGenerator = gen.Struct(reflect.TypeOf(Profiles_Endpoint_Spec{}), generators)

	return profiles_Endpoint_SpecGenerator
}

// AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["ContentTypesToCompress"] = gen.SliceOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsHttpAllowed"] = gen.PtrOf(gen.Bool())
	gens["IsHttpsAllowed"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OptimizationType"] = gen.PtrOf(gen.OneConstOf(
		OptimizationType_DynamicSiteAcceleration,
		OptimizationType_GeneralMediaStreaming,
		OptimizationType_GeneralWebDelivery,
		OptimizationType_LargeFileDownload,
		OptimizationType_VideoOnDemandMediaStreaming))
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["OriginPath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		QueryStringCachingBehavior_BypassCaching,
		QueryStringCachingBehavior_IgnoreQueryString,
		QueryStringCachingBehavior_NotSet,
		QueryStringCachingBehavior_UseQueryString))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec(gens map[string]gopter.Gen) {
	gens["DefaultOriginGroup"] = gen.PtrOf(ResourceReferenceGenerator())
	gens["DeliveryPolicy"] = gen.PtrOf(EndpointProperties_DeliveryPolicyGenerator())
	gens["GeoFilters"] = gen.SliceOf(GeoFilterGenerator())
	gens["OriginGroups"] = gen.SliceOf(DeepCreatedOriginGroupGenerator())
	gens["Origins"] = gen.SliceOf(DeepCreatedOriginGenerator())
	gens["UrlSigningKeys"] = gen.SliceOf(UrlSigningKeyGenerator())
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(EndpointProperties_WebApplicationFirewallPolicyLinkGenerator())
}

func Test_Profiles_Endpoint_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Profiles_Endpoint_STATUS to Profiles_Endpoint_STATUS via AssignProperties_To_Profiles_Endpoint_STATUS & AssignProperties_From_Profiles_Endpoint_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForProfiles_Endpoint_STATUS, Profiles_Endpoint_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProfiles_Endpoint_STATUS tests if a specific instance of Profiles_Endpoint_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForProfiles_Endpoint_STATUS(subject Profiles_Endpoint_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.Profiles_Endpoint_STATUS
	err := copied.AssignProperties_To_Profiles_Endpoint_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Profiles_Endpoint_STATUS
	err = actual.AssignProperties_From_Profiles_Endpoint_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Profiles_Endpoint_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Profiles_Endpoint_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfiles_Endpoint_STATUS, Profiles_Endpoint_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfiles_Endpoint_STATUS runs a test to see if a specific instance of Profiles_Endpoint_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForProfiles_Endpoint_STATUS(subject Profiles_Endpoint_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Profiles_Endpoint_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Profiles_Endpoint_STATUS instances for property testing - lazily instantiated by
// Profiles_Endpoint_STATUSGenerator()
var profiles_Endpoint_STATUSGenerator gopter.Gen

// Profiles_Endpoint_STATUSGenerator returns a generator of Profiles_Endpoint_STATUS instances for property testing.
// We first initialize profiles_Endpoint_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Profiles_Endpoint_STATUSGenerator() gopter.Gen {
	if profiles_Endpoint_STATUSGenerator != nil {
		return profiles_Endpoint_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfiles_Endpoint_STATUS(generators)
	profiles_Endpoint_STATUSGenerator = gen.Struct(reflect.TypeOf(Profiles_Endpoint_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfiles_Endpoint_STATUS(generators)
	AddRelatedPropertyGeneratorsForProfiles_Endpoint_STATUS(generators)
	profiles_Endpoint_STATUSGenerator = gen.Struct(reflect.TypeOf(Profiles_Endpoint_STATUS{}), generators)

	return profiles_Endpoint_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForProfiles_Endpoint_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfiles_Endpoint_STATUS(gens map[string]gopter.Gen) {
	gens["ContentTypesToCompress"] = gen.SliceOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsHttpAllowed"] = gen.PtrOf(gen.Bool())
	gens["IsHttpsAllowed"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OptimizationType"] = gen.PtrOf(gen.OneConstOf(
		OptimizationType_STATUS_DynamicSiteAcceleration,
		OptimizationType_STATUS_GeneralMediaStreaming,
		OptimizationType_STATUS_GeneralWebDelivery,
		OptimizationType_STATUS_LargeFileDownload,
		OptimizationType_STATUS_VideoOnDemandMediaStreaming))
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["OriginPath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		EndpointProperties_ProvisioningState_STATUS_Creating,
		EndpointProperties_ProvisioningState_STATUS_Deleting,
		EndpointProperties_ProvisioningState_STATUS_Failed,
		EndpointProperties_ProvisioningState_STATUS_Succeeded,
		EndpointProperties_ProvisioningState_STATUS_Updating))
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		QueryStringCachingBehavior_STATUS_BypassCaching,
		QueryStringCachingBehavior_STATUS_IgnoreQueryString,
		QueryStringCachingBehavior_STATUS_NotSet,
		QueryStringCachingBehavior_STATUS_UseQueryString))
	gens["ResourceState"] = gen.PtrOf(gen.OneConstOf(
		EndpointProperties_ResourceState_STATUS_Creating,
		EndpointProperties_ResourceState_STATUS_Deleting,
		EndpointProperties_ResourceState_STATUS_Running,
		EndpointProperties_ResourceState_STATUS_Starting,
		EndpointProperties_ResourceState_STATUS_Stopped,
		EndpointProperties_ResourceState_STATUS_Stopping))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProfiles_Endpoint_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfiles_Endpoint_STATUS(gens map[string]gopter.Gen) {
	gens["CustomDomains"] = gen.SliceOf(DeepCreatedCustomDomain_STATUSGenerator())
	gens["DefaultOriginGroup"] = gen.PtrOf(ResourceReference_STATUSGenerator())
	gens["DeliveryPolicy"] = gen.PtrOf(EndpointProperties_DeliveryPolicy_STATUSGenerator())
	gens["GeoFilters"] = gen.SliceOf(GeoFilter_STATUSGenerator())
	gens["OriginGroups"] = gen.SliceOf(DeepCreatedOriginGroup_STATUSGenerator())
	gens["Origins"] = gen.SliceOf(DeepCreatedOrigin_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
	gens["UrlSigningKeys"] = gen.SliceOf(UrlSigningKey_STATUSGenerator())
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(EndpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator())
}

func Test_DeepCreatedCustomDomain_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeepCreatedCustomDomain_STATUS to DeepCreatedCustomDomain_STATUS via AssignProperties_To_DeepCreatedCustomDomain_STATUS & AssignProperties_From_DeepCreatedCustomDomain_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeepCreatedCustomDomain_STATUS, DeepCreatedCustomDomain_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeepCreatedCustomDomain_STATUS tests if a specific instance of DeepCreatedCustomDomain_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeepCreatedCustomDomain_STATUS(subject DeepCreatedCustomDomain_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeepCreatedCustomDomain_STATUS
	err := copied.AssignProperties_To_DeepCreatedCustomDomain_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeepCreatedCustomDomain_STATUS
	err = actual.AssignProperties_From_DeepCreatedCustomDomain_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeepCreatedCustomDomain_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedCustomDomain_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedCustomDomain_STATUS, DeepCreatedCustomDomain_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedCustomDomain_STATUS runs a test to see if a specific instance of DeepCreatedCustomDomain_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedCustomDomain_STATUS(subject DeepCreatedCustomDomain_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedCustomDomain_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedCustomDomain_STATUS instances for property testing - lazily instantiated by
// DeepCreatedCustomDomain_STATUSGenerator()
var deepCreatedCustomDomain_STATUSGenerator gopter.Gen

// DeepCreatedCustomDomain_STATUSGenerator returns a generator of DeepCreatedCustomDomain_STATUS instances for property testing.
func DeepCreatedCustomDomain_STATUSGenerator() gopter.Gen {
	if deepCreatedCustomDomain_STATUSGenerator != nil {
		return deepCreatedCustomDomain_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedCustomDomain_STATUS(generators)
	deepCreatedCustomDomain_STATUSGenerator = gen.Struct(reflect.TypeOf(DeepCreatedCustomDomain_STATUS{}), generators)

	return deepCreatedCustomDomain_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedCustomDomain_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedCustomDomain_STATUS(gens map[string]gopter.Gen) {
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ValidationData"] = gen.PtrOf(gen.AlphaString())
}

func Test_DeepCreatedOrigin_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeepCreatedOrigin to DeepCreatedOrigin via AssignProperties_To_DeepCreatedOrigin & AssignProperties_From_DeepCreatedOrigin returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeepCreatedOrigin, DeepCreatedOriginGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeepCreatedOrigin tests if a specific instance of DeepCreatedOrigin can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeepCreatedOrigin(subject DeepCreatedOrigin) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeepCreatedOrigin
	err := copied.AssignProperties_To_DeepCreatedOrigin(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeepCreatedOrigin
	err = actual.AssignProperties_From_DeepCreatedOrigin(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeepCreatedOrigin_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOrigin via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOrigin, DeepCreatedOriginGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOrigin runs a test to see if a specific instance of DeepCreatedOrigin round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOrigin(subject DeepCreatedOrigin) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOrigin
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOrigin instances for property testing - lazily instantiated by DeepCreatedOriginGenerator()
var deepCreatedOriginGenerator gopter.Gen

// DeepCreatedOriginGenerator returns a generator of DeepCreatedOrigin instances for property testing.
func DeepCreatedOriginGenerator() gopter.Gen {
	if deepCreatedOriginGenerator != nil {
		return deepCreatedOriginGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOrigin(generators)
	deepCreatedOriginGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOrigin{}), generators)

	return deepCreatedOriginGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOrigin is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOrigin(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["PrivateLinkAlias"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkApprovalMessage"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_DeepCreatedOrigin_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeepCreatedOrigin_STATUS to DeepCreatedOrigin_STATUS via AssignProperties_To_DeepCreatedOrigin_STATUS & AssignProperties_From_DeepCreatedOrigin_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeepCreatedOrigin_STATUS, DeepCreatedOrigin_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeepCreatedOrigin_STATUS tests if a specific instance of DeepCreatedOrigin_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeepCreatedOrigin_STATUS(subject DeepCreatedOrigin_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeepCreatedOrigin_STATUS
	err := copied.AssignProperties_To_DeepCreatedOrigin_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeepCreatedOrigin_STATUS
	err = actual.AssignProperties_From_DeepCreatedOrigin_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeepCreatedOrigin_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOrigin_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOrigin_STATUS, DeepCreatedOrigin_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOrigin_STATUS runs a test to see if a specific instance of DeepCreatedOrigin_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOrigin_STATUS(subject DeepCreatedOrigin_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOrigin_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOrigin_STATUS instances for property testing - lazily instantiated by
// DeepCreatedOrigin_STATUSGenerator()
var deepCreatedOrigin_STATUSGenerator gopter.Gen

// DeepCreatedOrigin_STATUSGenerator returns a generator of DeepCreatedOrigin_STATUS instances for property testing.
func DeepCreatedOrigin_STATUSGenerator() gopter.Gen {
	if deepCreatedOrigin_STATUSGenerator != nil {
		return deepCreatedOrigin_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOrigin_STATUS(generators)
	deepCreatedOrigin_STATUSGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOrigin_STATUS{}), generators)

	return deepCreatedOrigin_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOrigin_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOrigin_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["PrivateEndpointStatus"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointStatus_STATUS_Approved,
		PrivateEndpointStatus_STATUS_Disconnected,
		PrivateEndpointStatus_STATUS_Pending,
		PrivateEndpointStatus_STATUS_Rejected,
		PrivateEndpointStatus_STATUS_Timeout))
	gens["PrivateLinkAlias"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkApprovalMessage"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkLocation"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_DeepCreatedOriginGroup_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeepCreatedOriginGroup to DeepCreatedOriginGroup via AssignProperties_To_DeepCreatedOriginGroup & AssignProperties_From_DeepCreatedOriginGroup returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeepCreatedOriginGroup, DeepCreatedOriginGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeepCreatedOriginGroup tests if a specific instance of DeepCreatedOriginGroup can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeepCreatedOriginGroup(subject DeepCreatedOriginGroup) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeepCreatedOriginGroup
	err := copied.AssignProperties_To_DeepCreatedOriginGroup(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeepCreatedOriginGroup
	err = actual.AssignProperties_From_DeepCreatedOriginGroup(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeepCreatedOriginGroup_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOriginGroup via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOriginGroup, DeepCreatedOriginGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOriginGroup runs a test to see if a specific instance of DeepCreatedOriginGroup round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOriginGroup(subject DeepCreatedOriginGroup) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOriginGroup
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOriginGroup instances for property testing - lazily instantiated by
// DeepCreatedOriginGroupGenerator()
var deepCreatedOriginGroupGenerator gopter.Gen

// DeepCreatedOriginGroupGenerator returns a generator of DeepCreatedOriginGroup instances for property testing.
// We first initialize deepCreatedOriginGroupGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeepCreatedOriginGroupGenerator() gopter.Gen {
	if deepCreatedOriginGroupGenerator != nil {
		return deepCreatedOriginGroupGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup(generators)
	deepCreatedOriginGroupGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroup{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup(generators)
	AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup(generators)
	deepCreatedOriginGroupGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroup{}), generators)

	return deepCreatedOriginGroupGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficRestorationTimeToHealedOrNewEndpointsInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup(gens map[string]gopter.Gen) {
	gens["HealthProbeSettings"] = gen.PtrOf(HealthProbeParametersGenerator())
	gens["Origins"] = gen.SliceOf(ResourceReferenceGenerator())
	gens["ResponseBasedOriginErrorDetectionSettings"] = gen.PtrOf(ResponseBasedOriginErrorDetectionParametersGenerator())
}

func Test_DeepCreatedOriginGroup_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeepCreatedOriginGroup_STATUS to DeepCreatedOriginGroup_STATUS via AssignProperties_To_DeepCreatedOriginGroup_STATUS & AssignProperties_From_DeepCreatedOriginGroup_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeepCreatedOriginGroup_STATUS, DeepCreatedOriginGroup_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeepCreatedOriginGroup_STATUS tests if a specific instance of DeepCreatedOriginGroup_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeepCreatedOriginGroup_STATUS(subject DeepCreatedOriginGroup_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeepCreatedOriginGroup_STATUS
	err := copied.AssignProperties_To_DeepCreatedOriginGroup_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeepCreatedOriginGroup_STATUS
	err = actual.AssignProperties_From_DeepCreatedOriginGroup_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeepCreatedOriginGroup_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOriginGroup_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOriginGroup_STATUS, DeepCreatedOriginGroup_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOriginGroup_STATUS runs a test to see if a specific instance of DeepCreatedOriginGroup_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOriginGroup_STATUS(subject DeepCreatedOriginGroup_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOriginGroup_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOriginGroup_STATUS instances for property testing - lazily instantiated by
// DeepCreatedOriginGroup_STATUSGenerator()
var deepCreatedOriginGroup_STATUSGenerator gopter.Gen

// DeepCreatedOriginGroup_STATUSGenerator returns a generator of DeepCreatedOriginGroup_STATUS instances for property testing.
// We first initialize deepCreatedOriginGroup_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeepCreatedOriginGroup_STATUSGenerator() gopter.Gen {
	if deepCreatedOriginGroup_STATUSGenerator != nil {
		return deepCreatedOriginGroup_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup_STATUS(generators)
	deepCreatedOriginGroup_STATUSGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroup_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup_STATUS(generators)
	deepCreatedOriginGroup_STATUSGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroup_STATUS{}), generators)

	return deepCreatedOriginGroup_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficRestorationTimeToHealedOrNewEndpointsInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup_STATUS(gens map[string]gopter.Gen) {
	gens["HealthProbeSettings"] = gen.PtrOf(HealthProbeParameters_STATUSGenerator())
	gens["Origins"] = gen.SliceOf(ResourceReference_STATUSGenerator())
	gens["ResponseBasedOriginErrorDetectionSettings"] = gen.PtrOf(ResponseBasedOriginErrorDetectionParameters_STATUSGenerator())
}

func Test_EndpointProperties_DeliveryPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EndpointProperties_DeliveryPolicy to EndpointProperties_DeliveryPolicy via AssignProperties_To_EndpointProperties_DeliveryPolicy & AssignProperties_From_EndpointProperties_DeliveryPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForEndpointProperties_DeliveryPolicy, EndpointProperties_DeliveryPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEndpointProperties_DeliveryPolicy tests if a specific instance of EndpointProperties_DeliveryPolicy can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForEndpointProperties_DeliveryPolicy(subject EndpointProperties_DeliveryPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.EndpointProperties_DeliveryPolicy
	err := copied.AssignProperties_To_EndpointProperties_DeliveryPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EndpointProperties_DeliveryPolicy
	err = actual.AssignProperties_From_EndpointProperties_DeliveryPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EndpointProperties_DeliveryPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointProperties_DeliveryPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointProperties_DeliveryPolicy, EndpointProperties_DeliveryPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointProperties_DeliveryPolicy runs a test to see if a specific instance of EndpointProperties_DeliveryPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointProperties_DeliveryPolicy(subject EndpointProperties_DeliveryPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointProperties_DeliveryPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointProperties_DeliveryPolicy instances for property testing - lazily instantiated by
// EndpointProperties_DeliveryPolicyGenerator()
var endpointProperties_DeliveryPolicyGenerator gopter.Gen

// EndpointProperties_DeliveryPolicyGenerator returns a generator of EndpointProperties_DeliveryPolicy instances for property testing.
// We first initialize endpointProperties_DeliveryPolicyGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EndpointProperties_DeliveryPolicyGenerator() gopter.Gen {
	if endpointProperties_DeliveryPolicyGenerator != nil {
		return endpointProperties_DeliveryPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy(generators)
	endpointProperties_DeliveryPolicyGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_DeliveryPolicy{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy(generators)
	AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy(generators)
	endpointProperties_DeliveryPolicyGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_DeliveryPolicy{}), generators)

	return endpointProperties_DeliveryPolicyGenerator
}

// AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(DeliveryRuleGenerator())
}

func Test_EndpointProperties_DeliveryPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EndpointProperties_DeliveryPolicy_STATUS to EndpointProperties_DeliveryPolicy_STATUS via AssignProperties_To_EndpointProperties_DeliveryPolicy_STATUS & AssignProperties_From_EndpointProperties_DeliveryPolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEndpointProperties_DeliveryPolicy_STATUS, EndpointProperties_DeliveryPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEndpointProperties_DeliveryPolicy_STATUS tests if a specific instance of EndpointProperties_DeliveryPolicy_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForEndpointProperties_DeliveryPolicy_STATUS(subject EndpointProperties_DeliveryPolicy_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.EndpointProperties_DeliveryPolicy_STATUS
	err := copied.AssignProperties_To_EndpointProperties_DeliveryPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EndpointProperties_DeliveryPolicy_STATUS
	err = actual.AssignProperties_From_EndpointProperties_DeliveryPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EndpointProperties_DeliveryPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointProperties_DeliveryPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointProperties_DeliveryPolicy_STATUS, EndpointProperties_DeliveryPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointProperties_DeliveryPolicy_STATUS runs a test to see if a specific instance of EndpointProperties_DeliveryPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointProperties_DeliveryPolicy_STATUS(subject EndpointProperties_DeliveryPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointProperties_DeliveryPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointProperties_DeliveryPolicy_STATUS instances for property testing - lazily instantiated by
// EndpointProperties_DeliveryPolicy_STATUSGenerator()
var endpointProperties_DeliveryPolicy_STATUSGenerator gopter.Gen

// EndpointProperties_DeliveryPolicy_STATUSGenerator returns a generator of EndpointProperties_DeliveryPolicy_STATUS instances for property testing.
// We first initialize endpointProperties_DeliveryPolicy_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EndpointProperties_DeliveryPolicy_STATUSGenerator() gopter.Gen {
	if endpointProperties_DeliveryPolicy_STATUSGenerator != nil {
		return endpointProperties_DeliveryPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy_STATUS(generators)
	endpointProperties_DeliveryPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_DeliveryPolicy_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy_STATUS(generators)
	AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy_STATUS(generators)
	endpointProperties_DeliveryPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_DeliveryPolicy_STATUS{}), generators)

	return endpointProperties_DeliveryPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(DeliveryRule_STATUSGenerator())
}

func Test_EndpointProperties_WebApplicationFirewallPolicyLink_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EndpointProperties_WebApplicationFirewallPolicyLink to EndpointProperties_WebApplicationFirewallPolicyLink via AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink & AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink returns original",
		prop.ForAll(RunPropertyAssignmentTestForEndpointProperties_WebApplicationFirewallPolicyLink, EndpointProperties_WebApplicationFirewallPolicyLinkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEndpointProperties_WebApplicationFirewallPolicyLink tests if a specific instance of EndpointProperties_WebApplicationFirewallPolicyLink can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForEndpointProperties_WebApplicationFirewallPolicyLink(subject EndpointProperties_WebApplicationFirewallPolicyLink) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink
	err := copied.AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EndpointProperties_WebApplicationFirewallPolicyLink
	err = actual.AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EndpointProperties_WebApplicationFirewallPolicyLink_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointProperties_WebApplicationFirewallPolicyLink via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink, EndpointProperties_WebApplicationFirewallPolicyLinkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink runs a test to see if a specific instance of EndpointProperties_WebApplicationFirewallPolicyLink round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink(subject EndpointProperties_WebApplicationFirewallPolicyLink) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointProperties_WebApplicationFirewallPolicyLink
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointProperties_WebApplicationFirewallPolicyLink instances for property testing - lazily instantiated
// by EndpointProperties_WebApplicationFirewallPolicyLinkGenerator()
var endpointProperties_WebApplicationFirewallPolicyLinkGenerator gopter.Gen

// EndpointProperties_WebApplicationFirewallPolicyLinkGenerator returns a generator of EndpointProperties_WebApplicationFirewallPolicyLink instances for property testing.
func EndpointProperties_WebApplicationFirewallPolicyLinkGenerator() gopter.Gen {
	if endpointProperties_WebApplicationFirewallPolicyLinkGenerator != nil {
		return endpointProperties_WebApplicationFirewallPolicyLinkGenerator
	}

	generators := make(map[string]gopter.Gen)
	endpointProperties_WebApplicationFirewallPolicyLinkGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_WebApplicationFirewallPolicyLink{}), generators)

	return endpointProperties_WebApplicationFirewallPolicyLinkGenerator
}

func Test_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EndpointProperties_WebApplicationFirewallPolicyLink_STATUS to EndpointProperties_WebApplicationFirewallPolicyLink_STATUS via AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS & AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS, EndpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS tests if a specific instance of EndpointProperties_WebApplicationFirewallPolicyLink_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS(subject EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
	err := copied.AssignProperties_To_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
	err = actual.AssignProperties_From_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointProperties_WebApplicationFirewallPolicyLink_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS, EndpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS runs a test to see if a specific instance of EndpointProperties_WebApplicationFirewallPolicyLink_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS(subject EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointProperties_WebApplicationFirewallPolicyLink_STATUS instances for property testing - lazily
// instantiated by EndpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator()
var endpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator gopter.Gen

// EndpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator returns a generator of EndpointProperties_WebApplicationFirewallPolicyLink_STATUS instances for property testing.
func EndpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator() gopter.Gen {
	if endpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator != nil {
		return endpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS(generators)
	endpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_WebApplicationFirewallPolicyLink_STATUS{}), generators)

	return endpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_GeoFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GeoFilter to GeoFilter via AssignProperties_To_GeoFilter & AssignProperties_From_GeoFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForGeoFilter, GeoFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGeoFilter tests if a specific instance of GeoFilter can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForGeoFilter(subject GeoFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.GeoFilter
	err := copied.AssignProperties_To_GeoFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GeoFilter
	err = actual.AssignProperties_From_GeoFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GeoFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GeoFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGeoFilter, GeoFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGeoFilter runs a test to see if a specific instance of GeoFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForGeoFilter(subject GeoFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GeoFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GeoFilter instances for property testing - lazily instantiated by GeoFilterGenerator()
var geoFilterGenerator gopter.Gen

// GeoFilterGenerator returns a generator of GeoFilter instances for property testing.
func GeoFilterGenerator() gopter.Gen {
	if geoFilterGenerator != nil {
		return geoFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGeoFilter(generators)
	geoFilterGenerator = gen.Struct(reflect.TypeOf(GeoFilter{}), generators)

	return geoFilterGenerator
}

// AddIndependentPropertyGeneratorsForGeoFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGeoFilter(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(GeoFilter_Action_Allow, GeoFilter_Action_Block))
	gens["CountryCodes"] = gen.SliceOf(gen.AlphaString())
	gens["RelativePath"] = gen.PtrOf(gen.AlphaString())
}

func Test_GeoFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GeoFilter_STATUS to GeoFilter_STATUS via AssignProperties_To_GeoFilter_STATUS & AssignProperties_From_GeoFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForGeoFilter_STATUS, GeoFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGeoFilter_STATUS tests if a specific instance of GeoFilter_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForGeoFilter_STATUS(subject GeoFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.GeoFilter_STATUS
	err := copied.AssignProperties_To_GeoFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GeoFilter_STATUS
	err = actual.AssignProperties_From_GeoFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GeoFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GeoFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGeoFilter_STATUS, GeoFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGeoFilter_STATUS runs a test to see if a specific instance of GeoFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGeoFilter_STATUS(subject GeoFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GeoFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GeoFilter_STATUS instances for property testing - lazily instantiated by GeoFilter_STATUSGenerator()
var geoFilter_STATUSGenerator gopter.Gen

// GeoFilter_STATUSGenerator returns a generator of GeoFilter_STATUS instances for property testing.
func GeoFilter_STATUSGenerator() gopter.Gen {
	if geoFilter_STATUSGenerator != nil {
		return geoFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGeoFilter_STATUS(generators)
	geoFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(GeoFilter_STATUS{}), generators)

	return geoFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForGeoFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGeoFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(GeoFilter_Action_STATUS_Allow, GeoFilter_Action_STATUS_Block))
	gens["CountryCodes"] = gen.SliceOf(gen.AlphaString())
	gens["RelativePath"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceReference_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceReference to ResourceReference via AssignProperties_To_ResourceReference & AssignProperties_From_ResourceReference returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceReference, ResourceReferenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceReference tests if a specific instance of ResourceReference can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForResourceReference(subject ResourceReference) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ResourceReference
	err := copied.AssignProperties_To_ResourceReference(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceReference
	err = actual.AssignProperties_From_ResourceReference(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceReference_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceReference via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceReference, ResourceReferenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceReference runs a test to see if a specific instance of ResourceReference round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceReference(subject ResourceReference) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceReference
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceReference instances for property testing - lazily instantiated by ResourceReferenceGenerator()
var resourceReferenceGenerator gopter.Gen

// ResourceReferenceGenerator returns a generator of ResourceReference instances for property testing.
func ResourceReferenceGenerator() gopter.Gen {
	if resourceReferenceGenerator != nil {
		return resourceReferenceGenerator
	}

	generators := make(map[string]gopter.Gen)
	resourceReferenceGenerator = gen.Struct(reflect.TypeOf(ResourceReference{}), generators)

	return resourceReferenceGenerator
}

func Test_ResourceReference_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceReference_STATUS to ResourceReference_STATUS via AssignProperties_To_ResourceReference_STATUS & AssignProperties_From_ResourceReference_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceReference_STATUS, ResourceReference_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceReference_STATUS tests if a specific instance of ResourceReference_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForResourceReference_STATUS(subject ResourceReference_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ResourceReference_STATUS
	err := copied.AssignProperties_To_ResourceReference_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceReference_STATUS
	err = actual.AssignProperties_From_ResourceReference_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceReference_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceReference_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceReference_STATUS, ResourceReference_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceReference_STATUS runs a test to see if a specific instance of ResourceReference_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceReference_STATUS(subject ResourceReference_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceReference_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceReference_STATUS instances for property testing - lazily instantiated by
// ResourceReference_STATUSGenerator()
var resourceReference_STATUSGenerator gopter.Gen

// ResourceReference_STATUSGenerator returns a generator of ResourceReference_STATUS instances for property testing.
func ResourceReference_STATUSGenerator() gopter.Gen {
	if resourceReference_STATUSGenerator != nil {
		return resourceReference_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceReference_STATUS(generators)
	resourceReference_STATUSGenerator = gen.Struct(reflect.TypeOf(ResourceReference_STATUS{}), generators)

	return resourceReference_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForResourceReference_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceReference_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_UrlSigningKey_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningKey to UrlSigningKey via AssignProperties_To_UrlSigningKey & AssignProperties_From_UrlSigningKey returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningKey, UrlSigningKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningKey tests if a specific instance of UrlSigningKey can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningKey(subject UrlSigningKey) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningKey
	err := copied.AssignProperties_To_UrlSigningKey(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningKey
	err = actual.AssignProperties_From_UrlSigningKey(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningKey_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningKey via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningKey, UrlSigningKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningKey runs a test to see if a specific instance of UrlSigningKey round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningKey(subject UrlSigningKey) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningKey
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningKey instances for property testing - lazily instantiated by UrlSigningKeyGenerator()
var urlSigningKeyGenerator gopter.Gen

// UrlSigningKeyGenerator returns a generator of UrlSigningKey instances for property testing.
// We first initialize urlSigningKeyGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningKeyGenerator() gopter.Gen {
	if urlSigningKeyGenerator != nil {
		return urlSigningKeyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKey(generators)
	urlSigningKeyGenerator = gen.Struct(reflect.TypeOf(UrlSigningKey{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKey(generators)
	AddRelatedPropertyGeneratorsForUrlSigningKey(generators)
	urlSigningKeyGenerator = gen.Struct(reflect.TypeOf(UrlSigningKey{}), generators)

	return urlSigningKeyGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningKey is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningKey(gens map[string]gopter.Gen) {
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUrlSigningKey is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningKey(gens map[string]gopter.Gen) {
	gens["KeySourceParameters"] = gen.PtrOf(KeyVaultSigningKeyParametersGenerator())
}

func Test_UrlSigningKey_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningKey_STATUS to UrlSigningKey_STATUS via AssignProperties_To_UrlSigningKey_STATUS & AssignProperties_From_UrlSigningKey_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningKey_STATUS, UrlSigningKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningKey_STATUS tests if a specific instance of UrlSigningKey_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningKey_STATUS(subject UrlSigningKey_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningKey_STATUS
	err := copied.AssignProperties_To_UrlSigningKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningKey_STATUS
	err = actual.AssignProperties_From_UrlSigningKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningKey_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningKey_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningKey_STATUS, UrlSigningKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningKey_STATUS runs a test to see if a specific instance of UrlSigningKey_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningKey_STATUS(subject UrlSigningKey_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningKey_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningKey_STATUS instances for property testing - lazily instantiated by
// UrlSigningKey_STATUSGenerator()
var urlSigningKey_STATUSGenerator gopter.Gen

// UrlSigningKey_STATUSGenerator returns a generator of UrlSigningKey_STATUS instances for property testing.
// We first initialize urlSigningKey_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningKey_STATUSGenerator() gopter.Gen {
	if urlSigningKey_STATUSGenerator != nil {
		return urlSigningKey_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKey_STATUS(generators)
	urlSigningKey_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlSigningKey_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKey_STATUS(generators)
	AddRelatedPropertyGeneratorsForUrlSigningKey_STATUS(generators)
	urlSigningKey_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlSigningKey_STATUS{}), generators)

	return urlSigningKey_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningKey_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningKey_STATUS(gens map[string]gopter.Gen) {
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUrlSigningKey_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningKey_STATUS(gens map[string]gopter.Gen) {
	gens["KeySourceParameters"] = gen.PtrOf(KeyVaultSigningKeyParameters_STATUSGenerator())
}

func Test_DeliveryRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRule to DeliveryRule via AssignProperties_To_DeliveryRule & AssignProperties_From_DeliveryRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRule, DeliveryRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRule tests if a specific instance of DeliveryRule can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRule(subject DeliveryRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRule
	err := copied.AssignProperties_To_DeliveryRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRule
	err = actual.AssignProperties_From_DeliveryRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRule, DeliveryRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRule runs a test to see if a specific instance of DeliveryRule round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRule(subject DeliveryRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRule instances for property testing - lazily instantiated by DeliveryRuleGenerator()
var deliveryRuleGenerator gopter.Gen

// DeliveryRuleGenerator returns a generator of DeliveryRule instances for property testing.
// We first initialize deliveryRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleGenerator() gopter.Gen {
	if deliveryRuleGenerator != nil {
		return deliveryRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRule(generators)
	deliveryRuleGenerator = gen.Struct(reflect.TypeOf(DeliveryRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRule(generators)
	AddRelatedPropertyGeneratorsForDeliveryRule(generators)
	deliveryRuleGenerator = gen.Struct(reflect.TypeOf(DeliveryRule{}), generators)

	return deliveryRuleGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRule(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Order"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeliveryRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRule(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.SliceOf(DeliveryRuleActionGenerator())
	gens["Conditions"] = gen.SliceOf(DeliveryRuleConditionGenerator())
}

func Test_DeliveryRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRule_STATUS to DeliveryRule_STATUS via AssignProperties_To_DeliveryRule_STATUS & AssignProperties_From_DeliveryRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRule_STATUS, DeliveryRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRule_STATUS tests if a specific instance of DeliveryRule_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRule_STATUS(subject DeliveryRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRule_STATUS
	err := copied.AssignProperties_To_DeliveryRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRule_STATUS
	err = actual.AssignProperties_From_DeliveryRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRule_STATUS, DeliveryRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRule_STATUS runs a test to see if a specific instance of DeliveryRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRule_STATUS(subject DeliveryRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRule_STATUS instances for property testing - lazily instantiated by
// DeliveryRule_STATUSGenerator()
var deliveryRule_STATUSGenerator gopter.Gen

// DeliveryRule_STATUSGenerator returns a generator of DeliveryRule_STATUS instances for property testing.
// We first initialize deliveryRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRule_STATUSGenerator() gopter.Gen {
	if deliveryRule_STATUSGenerator != nil {
		return deliveryRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRule_STATUS(generators)
	deliveryRule_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRule_STATUS(generators)
	deliveryRule_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRule_STATUS{}), generators)

	return deliveryRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRule_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Order"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeliveryRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRule_STATUS(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.SliceOf(DeliveryRuleAction_STATUSGenerator())
	gens["Conditions"] = gen.SliceOf(DeliveryRuleCondition_STATUSGenerator())
}

func Test_HealthProbeParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HealthProbeParameters to HealthProbeParameters via AssignProperties_To_HealthProbeParameters & AssignProperties_From_HealthProbeParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForHealthProbeParameters, HealthProbeParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHealthProbeParameters tests if a specific instance of HealthProbeParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHealthProbeParameters(subject HealthProbeParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HealthProbeParameters
	err := copied.AssignProperties_To_HealthProbeParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HealthProbeParameters
	err = actual.AssignProperties_From_HealthProbeParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HealthProbeParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeParameters, HealthProbeParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeParameters runs a test to see if a specific instance of HealthProbeParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeParameters(subject HealthProbeParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeParameters instances for property testing - lazily instantiated by
// HealthProbeParametersGenerator()
var healthProbeParametersGenerator gopter.Gen

// HealthProbeParametersGenerator returns a generator of HealthProbeParameters instances for property testing.
func HealthProbeParametersGenerator() gopter.Gen {
	if healthProbeParametersGenerator != nil {
		return healthProbeParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeParameters(generators)
	healthProbeParametersGenerator = gen.Struct(reflect.TypeOf(HealthProbeParameters{}), generators)

	return healthProbeParametersGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeParameters(gens map[string]gopter.Gen) {
	gens["ProbeIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbeProtocol"] = gen.PtrOf(gen.OneConstOf(HealthProbeParameters_ProbeProtocol_Http, HealthProbeParameters_ProbeProtocol_Https, HealthProbeParameters_ProbeProtocol_NotSet))
	gens["ProbeRequestType"] = gen.PtrOf(gen.OneConstOf(HealthProbeParameters_ProbeRequestType_GET, HealthProbeParameters_ProbeRequestType_HEAD, HealthProbeParameters_ProbeRequestType_NotSet))
}

func Test_HealthProbeParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HealthProbeParameters_STATUS to HealthProbeParameters_STATUS via AssignProperties_To_HealthProbeParameters_STATUS & AssignProperties_From_HealthProbeParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHealthProbeParameters_STATUS, HealthProbeParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHealthProbeParameters_STATUS tests if a specific instance of HealthProbeParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHealthProbeParameters_STATUS(subject HealthProbeParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HealthProbeParameters_STATUS
	err := copied.AssignProperties_To_HealthProbeParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HealthProbeParameters_STATUS
	err = actual.AssignProperties_From_HealthProbeParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HealthProbeParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeParameters_STATUS, HealthProbeParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeParameters_STATUS runs a test to see if a specific instance of HealthProbeParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeParameters_STATUS(subject HealthProbeParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeParameters_STATUS instances for property testing - lazily instantiated by
// HealthProbeParameters_STATUSGenerator()
var healthProbeParameters_STATUSGenerator gopter.Gen

// HealthProbeParameters_STATUSGenerator returns a generator of HealthProbeParameters_STATUS instances for property testing.
func HealthProbeParameters_STATUSGenerator() gopter.Gen {
	if healthProbeParameters_STATUSGenerator != nil {
		return healthProbeParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeParameters_STATUS(generators)
	healthProbeParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(HealthProbeParameters_STATUS{}), generators)

	return healthProbeParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeParameters_STATUS(gens map[string]gopter.Gen) {
	gens["ProbeIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbeProtocol"] = gen.PtrOf(gen.OneConstOf(HealthProbeParameters_ProbeProtocol_STATUS_Http, HealthProbeParameters_ProbeProtocol_STATUS_Https, HealthProbeParameters_ProbeProtocol_STATUS_NotSet))
	gens["ProbeRequestType"] = gen.PtrOf(gen.OneConstOf(HealthProbeParameters_ProbeRequestType_STATUS_GET, HealthProbeParameters_ProbeRequestType_STATUS_HEAD, HealthProbeParameters_ProbeRequestType_STATUS_NotSet))
}

func Test_KeyVaultSigningKeyParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultSigningKeyParameters to KeyVaultSigningKeyParameters via AssignProperties_To_KeyVaultSigningKeyParameters & AssignProperties_From_KeyVaultSigningKeyParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultSigningKeyParameters, KeyVaultSigningKeyParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultSigningKeyParameters tests if a specific instance of KeyVaultSigningKeyParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultSigningKeyParameters(subject KeyVaultSigningKeyParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.KeyVaultSigningKeyParameters
	err := copied.AssignProperties_To_KeyVaultSigningKeyParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultSigningKeyParameters
	err = actual.AssignProperties_From_KeyVaultSigningKeyParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultSigningKeyParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSigningKeyParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSigningKeyParameters, KeyVaultSigningKeyParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSigningKeyParameters runs a test to see if a specific instance of KeyVaultSigningKeyParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSigningKeyParameters(subject KeyVaultSigningKeyParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSigningKeyParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSigningKeyParameters instances for property testing - lazily instantiated by
// KeyVaultSigningKeyParametersGenerator()
var keyVaultSigningKeyParametersGenerator gopter.Gen

// KeyVaultSigningKeyParametersGenerator returns a generator of KeyVaultSigningKeyParameters instances for property testing.
func KeyVaultSigningKeyParametersGenerator() gopter.Gen {
	if keyVaultSigningKeyParametersGenerator != nil {
		return keyVaultSigningKeyParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters(generators)
	keyVaultSigningKeyParametersGenerator = gen.Struct(reflect.TypeOf(KeyVaultSigningKeyParameters{}), generators)

	return keyVaultSigningKeyParametersGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters(gens map[string]gopter.Gen) {
	gens["ResourceGroupName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(KeyVaultSigningKeyParameters_TypeName_KeyVaultSigningKeyParameters))
	gens["VaultName"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultSigningKeyParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultSigningKeyParameters_STATUS to KeyVaultSigningKeyParameters_STATUS via AssignProperties_To_KeyVaultSigningKeyParameters_STATUS & AssignProperties_From_KeyVaultSigningKeyParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultSigningKeyParameters_STATUS, KeyVaultSigningKeyParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultSigningKeyParameters_STATUS tests if a specific instance of KeyVaultSigningKeyParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultSigningKeyParameters_STATUS(subject KeyVaultSigningKeyParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.KeyVaultSigningKeyParameters_STATUS
	err := copied.AssignProperties_To_KeyVaultSigningKeyParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultSigningKeyParameters_STATUS
	err = actual.AssignProperties_From_KeyVaultSigningKeyParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultSigningKeyParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSigningKeyParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSigningKeyParameters_STATUS, KeyVaultSigningKeyParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSigningKeyParameters_STATUS runs a test to see if a specific instance of KeyVaultSigningKeyParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSigningKeyParameters_STATUS(subject KeyVaultSigningKeyParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSigningKeyParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSigningKeyParameters_STATUS instances for property testing - lazily instantiated by
// KeyVaultSigningKeyParameters_STATUSGenerator()
var keyVaultSigningKeyParameters_STATUSGenerator gopter.Gen

// KeyVaultSigningKeyParameters_STATUSGenerator returns a generator of KeyVaultSigningKeyParameters_STATUS instances for property testing.
func KeyVaultSigningKeyParameters_STATUSGenerator() gopter.Gen {
	if keyVaultSigningKeyParameters_STATUSGenerator != nil {
		return keyVaultSigningKeyParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters_STATUS(generators)
	keyVaultSigningKeyParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(KeyVaultSigningKeyParameters_STATUS{}), generators)

	return keyVaultSigningKeyParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters_STATUS(gens map[string]gopter.Gen) {
	gens["ResourceGroupName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(KeyVaultSigningKeyParameters_TypeName_STATUS_KeyVaultSigningKeyParameters))
	gens["VaultName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResponseBasedOriginErrorDetectionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResponseBasedOriginErrorDetectionParameters to ResponseBasedOriginErrorDetectionParameters via AssignProperties_To_ResponseBasedOriginErrorDetectionParameters & AssignProperties_From_ResponseBasedOriginErrorDetectionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters, ResponseBasedOriginErrorDetectionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters tests if a specific instance of ResponseBasedOriginErrorDetectionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters(subject ResponseBasedOriginErrorDetectionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ResponseBasedOriginErrorDetectionParameters
	err := copied.AssignProperties_To_ResponseBasedOriginErrorDetectionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResponseBasedOriginErrorDetectionParameters
	err = actual.AssignProperties_From_ResponseBasedOriginErrorDetectionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResponseBasedOriginErrorDetectionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResponseBasedOriginErrorDetectionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters, ResponseBasedOriginErrorDetectionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters runs a test to see if a specific instance of ResponseBasedOriginErrorDetectionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters(subject ResponseBasedOriginErrorDetectionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResponseBasedOriginErrorDetectionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResponseBasedOriginErrorDetectionParameters instances for property testing - lazily instantiated by
// ResponseBasedOriginErrorDetectionParametersGenerator()
var responseBasedOriginErrorDetectionParametersGenerator gopter.Gen

// ResponseBasedOriginErrorDetectionParametersGenerator returns a generator of ResponseBasedOriginErrorDetectionParameters instances for property testing.
// We first initialize responseBasedOriginErrorDetectionParametersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResponseBasedOriginErrorDetectionParametersGenerator() gopter.Gen {
	if responseBasedOriginErrorDetectionParametersGenerator != nil {
		return responseBasedOriginErrorDetectionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(generators)
	responseBasedOriginErrorDetectionParametersGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParameters{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(generators)
	AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(generators)
	responseBasedOriginErrorDetectionParametersGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParameters{}), generators)

	return responseBasedOriginErrorDetectionParametersGenerator
}

// AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(gens map[string]gopter.Gen) {
	gens["ResponseBasedDetectedErrorTypes"] = gen.PtrOf(gen.OneConstOf(ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_None, ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_TcpAndHttpErrors, ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_TcpErrorsOnly))
	gens["ResponseBasedFailoverThresholdPercentage"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(gens map[string]gopter.Gen) {
	gens["HttpErrorRanges"] = gen.SliceOf(HttpErrorRangeParametersGenerator())
}

func Test_ResponseBasedOriginErrorDetectionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResponseBasedOriginErrorDetectionParameters_STATUS to ResponseBasedOriginErrorDetectionParameters_STATUS via AssignProperties_To_ResponseBasedOriginErrorDetectionParameters_STATUS & AssignProperties_From_ResponseBasedOriginErrorDetectionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters_STATUS, ResponseBasedOriginErrorDetectionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters_STATUS tests if a specific instance of ResponseBasedOriginErrorDetectionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters_STATUS(subject ResponseBasedOriginErrorDetectionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ResponseBasedOriginErrorDetectionParameters_STATUS
	err := copied.AssignProperties_To_ResponseBasedOriginErrorDetectionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResponseBasedOriginErrorDetectionParameters_STATUS
	err = actual.AssignProperties_From_ResponseBasedOriginErrorDetectionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResponseBasedOriginErrorDetectionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResponseBasedOriginErrorDetectionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters_STATUS, ResponseBasedOriginErrorDetectionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters_STATUS runs a test to see if a specific instance of ResponseBasedOriginErrorDetectionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters_STATUS(subject ResponseBasedOriginErrorDetectionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResponseBasedOriginErrorDetectionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResponseBasedOriginErrorDetectionParameters_STATUS instances for property testing - lazily instantiated
// by ResponseBasedOriginErrorDetectionParameters_STATUSGenerator()
var responseBasedOriginErrorDetectionParameters_STATUSGenerator gopter.Gen

// ResponseBasedOriginErrorDetectionParameters_STATUSGenerator returns a generator of ResponseBasedOriginErrorDetectionParameters_STATUS instances for property testing.
// We first initialize responseBasedOriginErrorDetectionParameters_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResponseBasedOriginErrorDetectionParameters_STATUSGenerator() gopter.Gen {
	if responseBasedOriginErrorDetectionParameters_STATUSGenerator != nil {
		return responseBasedOriginErrorDetectionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_STATUS(generators)
	responseBasedOriginErrorDetectionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParameters_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_STATUS(generators)
	AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_STATUS(generators)
	responseBasedOriginErrorDetectionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParameters_STATUS{}), generators)

	return responseBasedOriginErrorDetectionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["ResponseBasedDetectedErrorTypes"] = gen.PtrOf(gen.OneConstOf(ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS_None, ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS_TcpAndHttpErrors, ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_STATUS_TcpErrorsOnly))
	gens["ResponseBasedFailoverThresholdPercentage"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["HttpErrorRanges"] = gen.SliceOf(HttpErrorRangeParameters_STATUSGenerator())
}

func Test_DeliveryRuleAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleAction to DeliveryRuleAction via AssignProperties_To_DeliveryRuleAction & AssignProperties_From_DeliveryRuleAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleAction, DeliveryRuleActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleAction tests if a specific instance of DeliveryRuleAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleAction(subject DeliveryRuleAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleAction
	err := copied.AssignProperties_To_DeliveryRuleAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleAction
	err = actual.AssignProperties_From_DeliveryRuleAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleAction, DeliveryRuleActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleAction runs a test to see if a specific instance of DeliveryRuleAction round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleAction(subject DeliveryRuleAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleAction instances for property testing - lazily instantiated by DeliveryRuleActionGenerator()
var deliveryRuleActionGenerator gopter.Gen

// DeliveryRuleActionGenerator returns a generator of DeliveryRuleAction instances for property testing.
func DeliveryRuleActionGenerator() gopter.Gen {
	if deliveryRuleActionGenerator != nil {
		return deliveryRuleActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeliveryRuleAction(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeliveryRuleAction{}), map[string]gopter.Gen{propName: propGen}))
	}
	deliveryRuleActionGenerator = gen.OneGenOf(gens...)

	return deliveryRuleActionGenerator
}

// AddRelatedPropertyGeneratorsForDeliveryRuleAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleAction(gens map[string]gopter.Gen) {
	gens["DeliveryRuleCacheExpiration"] = DeliveryRuleCacheExpirationActionGenerator().Map(func(it DeliveryRuleCacheExpirationAction) *DeliveryRuleCacheExpirationAction {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleCacheKeyQueryString"] = DeliveryRuleCacheKeyQueryStringActionGenerator().Map(func(it DeliveryRuleCacheKeyQueryStringAction) *DeliveryRuleCacheKeyQueryStringAction {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestHeader"] = DeliveryRuleRequestHeaderActionGenerator().Map(func(it DeliveryRuleRequestHeaderAction) *DeliveryRuleRequestHeaderAction {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleResponseHeader"] = DeliveryRuleResponseHeaderActionGenerator().Map(func(it DeliveryRuleResponseHeaderAction) *DeliveryRuleResponseHeaderAction {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRouteConfigurationOverride"] = DeliveryRuleRouteConfigurationOverrideActionGenerator().Map(func(it DeliveryRuleRouteConfigurationOverrideAction) *DeliveryRuleRouteConfigurationOverrideAction {
		return &it
	}) // generate one case for OneOf type
	gens["OriginGroupOverride"] = OriginGroupOverrideActionGenerator().Map(func(it OriginGroupOverrideAction) *OriginGroupOverrideAction {
		return &it
	}) // generate one case for OneOf type
	gens["UrlRedirect"] = UrlRedirectActionGenerator().Map(func(it UrlRedirectAction) *UrlRedirectAction {
		return &it
	}) // generate one case for OneOf type
	gens["UrlRewrite"] = UrlRewriteActionGenerator().Map(func(it UrlRewriteAction) *UrlRewriteAction {
		return &it
	}) // generate one case for OneOf type
	gens["UrlSigning"] = UrlSigningActionGenerator().Map(func(it UrlSigningAction) *UrlSigningAction {
		return &it
	}) // generate one case for OneOf type
}

func Test_DeliveryRuleAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleAction_STATUS to DeliveryRuleAction_STATUS via AssignProperties_To_DeliveryRuleAction_STATUS & AssignProperties_From_DeliveryRuleAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleAction_STATUS, DeliveryRuleAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleAction_STATUS tests if a specific instance of DeliveryRuleAction_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleAction_STATUS(subject DeliveryRuleAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleAction_STATUS
	err := copied.AssignProperties_To_DeliveryRuleAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleAction_STATUS
	err = actual.AssignProperties_From_DeliveryRuleAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleAction_STATUS, DeliveryRuleAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleAction_STATUS runs a test to see if a specific instance of DeliveryRuleAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleAction_STATUS(subject DeliveryRuleAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleAction_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleAction_STATUSGenerator()
var deliveryRuleAction_STATUSGenerator gopter.Gen

// DeliveryRuleAction_STATUSGenerator returns a generator of DeliveryRuleAction_STATUS instances for property testing.
func DeliveryRuleAction_STATUSGenerator() gopter.Gen {
	if deliveryRuleAction_STATUSGenerator != nil {
		return deliveryRuleAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeliveryRuleAction_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeliveryRuleAction_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	deliveryRuleAction_STATUSGenerator = gen.OneGenOf(gens...)

	return deliveryRuleAction_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForDeliveryRuleAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleAction_STATUS(gens map[string]gopter.Gen) {
	gens["DeliveryRuleCacheExpiration"] = DeliveryRuleCacheExpirationAction_STATUSGenerator().Map(func(it DeliveryRuleCacheExpirationAction_STATUS) *DeliveryRuleCacheExpirationAction_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleCacheKeyQueryString"] = DeliveryRuleCacheKeyQueryStringAction_STATUSGenerator().Map(func(it DeliveryRuleCacheKeyQueryStringAction_STATUS) *DeliveryRuleCacheKeyQueryStringAction_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestHeader"] = DeliveryRuleRequestHeaderAction_STATUSGenerator().Map(func(it DeliveryRuleRequestHeaderAction_STATUS) *DeliveryRuleRequestHeaderAction_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleResponseHeader"] = DeliveryRuleResponseHeaderAction_STATUSGenerator().Map(func(it DeliveryRuleResponseHeaderAction_STATUS) *DeliveryRuleResponseHeaderAction_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRouteConfigurationOverride"] = DeliveryRuleRouteConfigurationOverrideAction_STATUSGenerator().Map(func(it DeliveryRuleRouteConfigurationOverrideAction_STATUS) *DeliveryRuleRouteConfigurationOverrideAction_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["OriginGroupOverride"] = OriginGroupOverrideAction_STATUSGenerator().Map(func(it OriginGroupOverrideAction_STATUS) *OriginGroupOverrideAction_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["UrlRedirect"] = UrlRedirectAction_STATUSGenerator().Map(func(it UrlRedirectAction_STATUS) *UrlRedirectAction_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["UrlRewrite"] = UrlRewriteAction_STATUSGenerator().Map(func(it UrlRewriteAction_STATUS) *UrlRewriteAction_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["UrlSigning"] = UrlSigningAction_STATUSGenerator().Map(func(it UrlSigningAction_STATUS) *UrlSigningAction_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_DeliveryRuleCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCondition to DeliveryRuleCondition via AssignProperties_To_DeliveryRuleCondition & AssignProperties_From_DeliveryRuleCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleCondition, DeliveryRuleConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleCondition tests if a specific instance of DeliveryRuleCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleCondition(subject DeliveryRuleCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCondition
	err := copied.AssignProperties_To_DeliveryRuleCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCondition
	err = actual.AssignProperties_From_DeliveryRuleCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCondition, DeliveryRuleConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCondition runs a test to see if a specific instance of DeliveryRuleCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCondition(subject DeliveryRuleCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCondition instances for property testing - lazily instantiated by
// DeliveryRuleConditionGenerator()
var deliveryRuleConditionGenerator gopter.Gen

// DeliveryRuleConditionGenerator returns a generator of DeliveryRuleCondition instances for property testing.
func DeliveryRuleConditionGenerator() gopter.Gen {
	if deliveryRuleConditionGenerator != nil {
		return deliveryRuleConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeliveryRuleCondition(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeliveryRuleCondition{}), map[string]gopter.Gen{propName: propGen}))
	}
	deliveryRuleConditionGenerator = gen.OneGenOf(gens...)

	return deliveryRuleConditionGenerator
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCondition(gens map[string]gopter.Gen) {
	gens["DeliveryRuleClientPort"] = DeliveryRuleClientPortConditionGenerator().Map(func(it DeliveryRuleClientPortCondition) *DeliveryRuleClientPortCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleCookies"] = DeliveryRuleCookiesConditionGenerator().Map(func(it DeliveryRuleCookiesCondition) *DeliveryRuleCookiesCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleHostName"] = DeliveryRuleHostNameConditionGenerator().Map(func(it DeliveryRuleHostNameCondition) *DeliveryRuleHostNameCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleHttpVersion"] = DeliveryRuleHttpVersionConditionGenerator().Map(func(it DeliveryRuleHttpVersionCondition) *DeliveryRuleHttpVersionCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleIsDevice"] = DeliveryRuleIsDeviceConditionGenerator().Map(func(it DeliveryRuleIsDeviceCondition) *DeliveryRuleIsDeviceCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRulePostArgs"] = DeliveryRulePostArgsConditionGenerator().Map(func(it DeliveryRulePostArgsCondition) *DeliveryRulePostArgsCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleQueryString"] = DeliveryRuleQueryStringConditionGenerator().Map(func(it DeliveryRuleQueryStringCondition) *DeliveryRuleQueryStringCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRemoteAddress"] = DeliveryRuleRemoteAddressConditionGenerator().Map(func(it DeliveryRuleRemoteAddressCondition) *DeliveryRuleRemoteAddressCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestBody"] = DeliveryRuleRequestBodyConditionGenerator().Map(func(it DeliveryRuleRequestBodyCondition) *DeliveryRuleRequestBodyCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestHeader"] = DeliveryRuleRequestHeaderConditionGenerator().Map(func(it DeliveryRuleRequestHeaderCondition) *DeliveryRuleRequestHeaderCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestMethod"] = DeliveryRuleRequestMethodConditionGenerator().Map(func(it DeliveryRuleRequestMethodCondition) *DeliveryRuleRequestMethodCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestScheme"] = DeliveryRuleRequestSchemeConditionGenerator().Map(func(it DeliveryRuleRequestSchemeCondition) *DeliveryRuleRequestSchemeCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestUri"] = DeliveryRuleRequestUriConditionGenerator().Map(func(it DeliveryRuleRequestUriCondition) *DeliveryRuleRequestUriCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleServerPort"] = DeliveryRuleServerPortConditionGenerator().Map(func(it DeliveryRuleServerPortCondition) *DeliveryRuleServerPortCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleSocketAddr"] = DeliveryRuleSocketAddrConditionGenerator().Map(func(it DeliveryRuleSocketAddrCondition) *DeliveryRuleSocketAddrCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleSslProtocol"] = DeliveryRuleSslProtocolConditionGenerator().Map(func(it DeliveryRuleSslProtocolCondition) *DeliveryRuleSslProtocolCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlFileExtension"] = DeliveryRuleUrlFileExtensionConditionGenerator().Map(func(it DeliveryRuleUrlFileExtensionCondition) *DeliveryRuleUrlFileExtensionCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlFileName"] = DeliveryRuleUrlFileNameConditionGenerator().Map(func(it DeliveryRuleUrlFileNameCondition) *DeliveryRuleUrlFileNameCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlPath"] = DeliveryRuleUrlPathConditionGenerator().Map(func(it DeliveryRuleUrlPathCondition) *DeliveryRuleUrlPathCondition {
		return &it
	}) // generate one case for OneOf type
}

func Test_DeliveryRuleCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCondition_STATUS to DeliveryRuleCondition_STATUS via AssignProperties_To_DeliveryRuleCondition_STATUS & AssignProperties_From_DeliveryRuleCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleCondition_STATUS, DeliveryRuleCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleCondition_STATUS tests if a specific instance of DeliveryRuleCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleCondition_STATUS(subject DeliveryRuleCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCondition_STATUS, DeliveryRuleCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCondition_STATUS runs a test to see if a specific instance of DeliveryRuleCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCondition_STATUS(subject DeliveryRuleCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleCondition_STATUSGenerator()
var deliveryRuleCondition_STATUSGenerator gopter.Gen

// DeliveryRuleCondition_STATUSGenerator returns a generator of DeliveryRuleCondition_STATUS instances for property testing.
func DeliveryRuleCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleCondition_STATUSGenerator != nil {
		return deliveryRuleCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeliveryRuleCondition_STATUS(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeliveryRuleCondition_STATUS{}), map[string]gopter.Gen{propName: propGen}))
	}
	deliveryRuleCondition_STATUSGenerator = gen.OneGenOf(gens...)

	return deliveryRuleCondition_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCondition_STATUS(gens map[string]gopter.Gen) {
	gens["DeliveryRuleClientPort"] = DeliveryRuleClientPortCondition_STATUSGenerator().Map(func(it DeliveryRuleClientPortCondition_STATUS) *DeliveryRuleClientPortCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleCookies"] = DeliveryRuleCookiesCondition_STATUSGenerator().Map(func(it DeliveryRuleCookiesCondition_STATUS) *DeliveryRuleCookiesCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleHostName"] = DeliveryRuleHostNameCondition_STATUSGenerator().Map(func(it DeliveryRuleHostNameCondition_STATUS) *DeliveryRuleHostNameCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleHttpVersion"] = DeliveryRuleHttpVersionCondition_STATUSGenerator().Map(func(it DeliveryRuleHttpVersionCondition_STATUS) *DeliveryRuleHttpVersionCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleIsDevice"] = DeliveryRuleIsDeviceCondition_STATUSGenerator().Map(func(it DeliveryRuleIsDeviceCondition_STATUS) *DeliveryRuleIsDeviceCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRulePostArgs"] = DeliveryRulePostArgsCondition_STATUSGenerator().Map(func(it DeliveryRulePostArgsCondition_STATUS) *DeliveryRulePostArgsCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleQueryString"] = DeliveryRuleQueryStringCondition_STATUSGenerator().Map(func(it DeliveryRuleQueryStringCondition_STATUS) *DeliveryRuleQueryStringCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRemoteAddress"] = DeliveryRuleRemoteAddressCondition_STATUSGenerator().Map(func(it DeliveryRuleRemoteAddressCondition_STATUS) *DeliveryRuleRemoteAddressCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestBody"] = DeliveryRuleRequestBodyCondition_STATUSGenerator().Map(func(it DeliveryRuleRequestBodyCondition_STATUS) *DeliveryRuleRequestBodyCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestHeader"] = DeliveryRuleRequestHeaderCondition_STATUSGenerator().Map(func(it DeliveryRuleRequestHeaderCondition_STATUS) *DeliveryRuleRequestHeaderCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestMethod"] = DeliveryRuleRequestMethodCondition_STATUSGenerator().Map(func(it DeliveryRuleRequestMethodCondition_STATUS) *DeliveryRuleRequestMethodCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestScheme"] = DeliveryRuleRequestSchemeCondition_STATUSGenerator().Map(func(it DeliveryRuleRequestSchemeCondition_STATUS) *DeliveryRuleRequestSchemeCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestUri"] = DeliveryRuleRequestUriCondition_STATUSGenerator().Map(func(it DeliveryRuleRequestUriCondition_STATUS) *DeliveryRuleRequestUriCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleServerPort"] = DeliveryRuleServerPortCondition_STATUSGenerator().Map(func(it DeliveryRuleServerPortCondition_STATUS) *DeliveryRuleServerPortCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleSocketAddr"] = DeliveryRuleSocketAddrCondition_STATUSGenerator().Map(func(it DeliveryRuleSocketAddrCondition_STATUS) *DeliveryRuleSocketAddrCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleSslProtocol"] = DeliveryRuleSslProtocolCondition_STATUSGenerator().Map(func(it DeliveryRuleSslProtocolCondition_STATUS) *DeliveryRuleSslProtocolCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlFileExtension"] = DeliveryRuleUrlFileExtensionCondition_STATUSGenerator().Map(func(it DeliveryRuleUrlFileExtensionCondition_STATUS) *DeliveryRuleUrlFileExtensionCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlFileName"] = DeliveryRuleUrlFileNameCondition_STATUSGenerator().Map(func(it DeliveryRuleUrlFileNameCondition_STATUS) *DeliveryRuleUrlFileNameCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlPath"] = DeliveryRuleUrlPathCondition_STATUSGenerator().Map(func(it DeliveryRuleUrlPathCondition_STATUS) *DeliveryRuleUrlPathCondition_STATUS {
		return &it
	}) // generate one case for OneOf type
}

func Test_HttpErrorRangeParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpErrorRangeParameters to HttpErrorRangeParameters via AssignProperties_To_HttpErrorRangeParameters & AssignProperties_From_HttpErrorRangeParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpErrorRangeParameters, HttpErrorRangeParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpErrorRangeParameters tests if a specific instance of HttpErrorRangeParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHttpErrorRangeParameters(subject HttpErrorRangeParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HttpErrorRangeParameters
	err := copied.AssignProperties_To_HttpErrorRangeParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpErrorRangeParameters
	err = actual.AssignProperties_From_HttpErrorRangeParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpErrorRangeParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpErrorRangeParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpErrorRangeParameters, HttpErrorRangeParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpErrorRangeParameters runs a test to see if a specific instance of HttpErrorRangeParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpErrorRangeParameters(subject HttpErrorRangeParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpErrorRangeParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpErrorRangeParameters instances for property testing - lazily instantiated by
// HttpErrorRangeParametersGenerator()
var httpErrorRangeParametersGenerator gopter.Gen

// HttpErrorRangeParametersGenerator returns a generator of HttpErrorRangeParameters instances for property testing.
func HttpErrorRangeParametersGenerator() gopter.Gen {
	if httpErrorRangeParametersGenerator != nil {
		return httpErrorRangeParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpErrorRangeParameters(generators)
	httpErrorRangeParametersGenerator = gen.Struct(reflect.TypeOf(HttpErrorRangeParameters{}), generators)

	return httpErrorRangeParametersGenerator
}

// AddIndependentPropertyGeneratorsForHttpErrorRangeParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpErrorRangeParameters(gens map[string]gopter.Gen) {
	gens["Begin"] = gen.PtrOf(gen.Int())
	gens["End"] = gen.PtrOf(gen.Int())
}

func Test_HttpErrorRangeParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpErrorRangeParameters_STATUS to HttpErrorRangeParameters_STATUS via AssignProperties_To_HttpErrorRangeParameters_STATUS & AssignProperties_From_HttpErrorRangeParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpErrorRangeParameters_STATUS, HttpErrorRangeParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpErrorRangeParameters_STATUS tests if a specific instance of HttpErrorRangeParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHttpErrorRangeParameters_STATUS(subject HttpErrorRangeParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HttpErrorRangeParameters_STATUS
	err := copied.AssignProperties_To_HttpErrorRangeParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpErrorRangeParameters_STATUS
	err = actual.AssignProperties_From_HttpErrorRangeParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpErrorRangeParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpErrorRangeParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpErrorRangeParameters_STATUS, HttpErrorRangeParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpErrorRangeParameters_STATUS runs a test to see if a specific instance of HttpErrorRangeParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpErrorRangeParameters_STATUS(subject HttpErrorRangeParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpErrorRangeParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpErrorRangeParameters_STATUS instances for property testing - lazily instantiated by
// HttpErrorRangeParameters_STATUSGenerator()
var httpErrorRangeParameters_STATUSGenerator gopter.Gen

// HttpErrorRangeParameters_STATUSGenerator returns a generator of HttpErrorRangeParameters_STATUS instances for property testing.
func HttpErrorRangeParameters_STATUSGenerator() gopter.Gen {
	if httpErrorRangeParameters_STATUSGenerator != nil {
		return httpErrorRangeParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpErrorRangeParameters_STATUS(generators)
	httpErrorRangeParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(HttpErrorRangeParameters_STATUS{}), generators)

	return httpErrorRangeParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHttpErrorRangeParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpErrorRangeParameters_STATUS(gens map[string]gopter.Gen) {
	gens["Begin"] = gen.PtrOf(gen.Int())
	gens["End"] = gen.PtrOf(gen.Int())
}

func Test_DeliveryRuleCacheExpirationAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCacheExpirationAction to DeliveryRuleCacheExpirationAction via AssignProperties_To_DeliveryRuleCacheExpirationAction & AssignProperties_From_DeliveryRuleCacheExpirationAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleCacheExpirationAction, DeliveryRuleCacheExpirationActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleCacheExpirationAction tests if a specific instance of DeliveryRuleCacheExpirationAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleCacheExpirationAction(subject DeliveryRuleCacheExpirationAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCacheExpirationAction
	err := copied.AssignProperties_To_DeliveryRuleCacheExpirationAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCacheExpirationAction
	err = actual.AssignProperties_From_DeliveryRuleCacheExpirationAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCacheExpirationAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCacheExpirationAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCacheExpirationAction, DeliveryRuleCacheExpirationActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCacheExpirationAction runs a test to see if a specific instance of DeliveryRuleCacheExpirationAction round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCacheExpirationAction(subject DeliveryRuleCacheExpirationAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCacheExpirationAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCacheExpirationAction instances for property testing - lazily instantiated by
// DeliveryRuleCacheExpirationActionGenerator()
var deliveryRuleCacheExpirationActionGenerator gopter.Gen

// DeliveryRuleCacheExpirationActionGenerator returns a generator of DeliveryRuleCacheExpirationAction instances for property testing.
// We first initialize deliveryRuleCacheExpirationActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCacheExpirationActionGenerator() gopter.Gen {
	if deliveryRuleCacheExpirationActionGenerator != nil {
		return deliveryRuleCacheExpirationActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction(generators)
	deliveryRuleCacheExpirationActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheExpirationAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationAction(generators)
	deliveryRuleCacheExpirationActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheExpirationAction{}), generators)

	return deliveryRuleCacheExpirationActionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCacheExpirationAction_Name_CacheExpiration)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CacheExpirationActionParametersGenerator())
}

func Test_DeliveryRuleCacheExpirationAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCacheExpirationAction_STATUS to DeliveryRuleCacheExpirationAction_STATUS via AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS & AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleCacheExpirationAction_STATUS, DeliveryRuleCacheExpirationAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleCacheExpirationAction_STATUS tests if a specific instance of DeliveryRuleCacheExpirationAction_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleCacheExpirationAction_STATUS(subject DeliveryRuleCacheExpirationAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCacheExpirationAction_STATUS
	err := copied.AssignProperties_To_DeliveryRuleCacheExpirationAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCacheExpirationAction_STATUS
	err = actual.AssignProperties_From_DeliveryRuleCacheExpirationAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCacheExpirationAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCacheExpirationAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCacheExpirationAction_STATUS, DeliveryRuleCacheExpirationAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCacheExpirationAction_STATUS runs a test to see if a specific instance of DeliveryRuleCacheExpirationAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCacheExpirationAction_STATUS(subject DeliveryRuleCacheExpirationAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCacheExpirationAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCacheExpirationAction_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleCacheExpirationAction_STATUSGenerator()
var deliveryRuleCacheExpirationAction_STATUSGenerator gopter.Gen

// DeliveryRuleCacheExpirationAction_STATUSGenerator returns a generator of DeliveryRuleCacheExpirationAction_STATUS instances for property testing.
// We first initialize deliveryRuleCacheExpirationAction_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCacheExpirationAction_STATUSGenerator() gopter.Gen {
	if deliveryRuleCacheExpirationAction_STATUSGenerator != nil {
		return deliveryRuleCacheExpirationAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction_STATUS(generators)
	deliveryRuleCacheExpirationAction_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheExpirationAction_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationAction_STATUS(generators)
	deliveryRuleCacheExpirationAction_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheExpirationAction_STATUS{}), generators)

	return deliveryRuleCacheExpirationAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCacheExpirationAction_Name_STATUS_CacheExpiration)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationAction_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CacheExpirationActionParameters_STATUSGenerator())
}

func Test_DeliveryRuleCacheKeyQueryStringAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCacheKeyQueryStringAction to DeliveryRuleCacheKeyQueryStringAction via AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction & AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleCacheKeyQueryStringAction, DeliveryRuleCacheKeyQueryStringActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleCacheKeyQueryStringAction tests if a specific instance of DeliveryRuleCacheKeyQueryStringAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleCacheKeyQueryStringAction(subject DeliveryRuleCacheKeyQueryStringAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCacheKeyQueryStringAction
	err := copied.AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCacheKeyQueryStringAction
	err = actual.AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCacheKeyQueryStringAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCacheKeyQueryStringAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringAction, DeliveryRuleCacheKeyQueryStringActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringAction runs a test to see if a specific instance of DeliveryRuleCacheKeyQueryStringAction round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringAction(subject DeliveryRuleCacheKeyQueryStringAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCacheKeyQueryStringAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCacheKeyQueryStringAction instances for property testing - lazily instantiated by
// DeliveryRuleCacheKeyQueryStringActionGenerator()
var deliveryRuleCacheKeyQueryStringActionGenerator gopter.Gen

// DeliveryRuleCacheKeyQueryStringActionGenerator returns a generator of DeliveryRuleCacheKeyQueryStringAction instances for property testing.
// We first initialize deliveryRuleCacheKeyQueryStringActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCacheKeyQueryStringActionGenerator() gopter.Gen {
	if deliveryRuleCacheKeyQueryStringActionGenerator != nil {
		return deliveryRuleCacheKeyQueryStringActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction(generators)
	deliveryRuleCacheKeyQueryStringActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheKeyQueryStringAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction(generators)
	deliveryRuleCacheKeyQueryStringActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheKeyQueryStringAction{}), generators)

	return deliveryRuleCacheKeyQueryStringActionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCacheKeyQueryStringAction_Name_CacheKeyQueryString)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CacheKeyQueryStringActionParametersGenerator())
}

func Test_DeliveryRuleCacheKeyQueryStringAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCacheKeyQueryStringAction_STATUS to DeliveryRuleCacheKeyQueryStringAction_STATUS via AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS & AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleCacheKeyQueryStringAction_STATUS, DeliveryRuleCacheKeyQueryStringAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleCacheKeyQueryStringAction_STATUS tests if a specific instance of DeliveryRuleCacheKeyQueryStringAction_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleCacheKeyQueryStringAction_STATUS(subject DeliveryRuleCacheKeyQueryStringAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCacheKeyQueryStringAction_STATUS
	err := copied.AssignProperties_To_DeliveryRuleCacheKeyQueryStringAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCacheKeyQueryStringAction_STATUS
	err = actual.AssignProperties_From_DeliveryRuleCacheKeyQueryStringAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCacheKeyQueryStringAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCacheKeyQueryStringAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringAction_STATUS, DeliveryRuleCacheKeyQueryStringAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringAction_STATUS runs a test to see if a specific instance of DeliveryRuleCacheKeyQueryStringAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringAction_STATUS(subject DeliveryRuleCacheKeyQueryStringAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCacheKeyQueryStringAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCacheKeyQueryStringAction_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleCacheKeyQueryStringAction_STATUSGenerator()
var deliveryRuleCacheKeyQueryStringAction_STATUSGenerator gopter.Gen

// DeliveryRuleCacheKeyQueryStringAction_STATUSGenerator returns a generator of DeliveryRuleCacheKeyQueryStringAction_STATUS instances for property testing.
// We first initialize deliveryRuleCacheKeyQueryStringAction_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCacheKeyQueryStringAction_STATUSGenerator() gopter.Gen {
	if deliveryRuleCacheKeyQueryStringAction_STATUSGenerator != nil {
		return deliveryRuleCacheKeyQueryStringAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction_STATUS(generators)
	deliveryRuleCacheKeyQueryStringAction_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheKeyQueryStringAction_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction_STATUS(generators)
	deliveryRuleCacheKeyQueryStringAction_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheKeyQueryStringAction_STATUS{}), generators)

	return deliveryRuleCacheKeyQueryStringAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCacheKeyQueryStringAction_Name_STATUS_CacheKeyQueryString)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CacheKeyQueryStringActionParameters_STATUSGenerator())
}

func Test_DeliveryRuleClientPortCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleClientPortCondition to DeliveryRuleClientPortCondition via AssignProperties_To_DeliveryRuleClientPortCondition & AssignProperties_From_DeliveryRuleClientPortCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleClientPortCondition, DeliveryRuleClientPortConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleClientPortCondition tests if a specific instance of DeliveryRuleClientPortCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleClientPortCondition(subject DeliveryRuleClientPortCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleClientPortCondition
	err := copied.AssignProperties_To_DeliveryRuleClientPortCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleClientPortCondition
	err = actual.AssignProperties_From_DeliveryRuleClientPortCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleClientPortCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleClientPortCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleClientPortCondition, DeliveryRuleClientPortConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleClientPortCondition runs a test to see if a specific instance of DeliveryRuleClientPortCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleClientPortCondition(subject DeliveryRuleClientPortCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleClientPortCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleClientPortCondition instances for property testing - lazily instantiated by
// DeliveryRuleClientPortConditionGenerator()
var deliveryRuleClientPortConditionGenerator gopter.Gen

// DeliveryRuleClientPortConditionGenerator returns a generator of DeliveryRuleClientPortCondition instances for property testing.
// We first initialize deliveryRuleClientPortConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleClientPortConditionGenerator() gopter.Gen {
	if deliveryRuleClientPortConditionGenerator != nil {
		return deliveryRuleClientPortConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition(generators)
	deliveryRuleClientPortConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleClientPortCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleClientPortCondition(generators)
	deliveryRuleClientPortConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleClientPortCondition{}), generators)

	return deliveryRuleClientPortConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleClientPortCondition_Name_ClientPort)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleClientPortCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleClientPortCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(ClientPortMatchConditionParametersGenerator())
}

func Test_DeliveryRuleClientPortCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleClientPortCondition_STATUS to DeliveryRuleClientPortCondition_STATUS via AssignProperties_To_DeliveryRuleClientPortCondition_STATUS & AssignProperties_From_DeliveryRuleClientPortCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleClientPortCondition_STATUS, DeliveryRuleClientPortCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleClientPortCondition_STATUS tests if a specific instance of DeliveryRuleClientPortCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleClientPortCondition_STATUS(subject DeliveryRuleClientPortCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleClientPortCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleClientPortCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleClientPortCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleClientPortCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleClientPortCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleClientPortCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleClientPortCondition_STATUS, DeliveryRuleClientPortCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleClientPortCondition_STATUS runs a test to see if a specific instance of DeliveryRuleClientPortCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleClientPortCondition_STATUS(subject DeliveryRuleClientPortCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleClientPortCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleClientPortCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleClientPortCondition_STATUSGenerator()
var deliveryRuleClientPortCondition_STATUSGenerator gopter.Gen

// DeliveryRuleClientPortCondition_STATUSGenerator returns a generator of DeliveryRuleClientPortCondition_STATUS instances for property testing.
// We first initialize deliveryRuleClientPortCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleClientPortCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleClientPortCondition_STATUSGenerator != nil {
		return deliveryRuleClientPortCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition_STATUS(generators)
	deliveryRuleClientPortCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleClientPortCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleClientPortCondition_STATUS(generators)
	deliveryRuleClientPortCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleClientPortCondition_STATUS{}), generators)

	return deliveryRuleClientPortCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleClientPortCondition_Name_STATUS_ClientPort)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleClientPortCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleClientPortCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(ClientPortMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleCookiesCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCookiesCondition to DeliveryRuleCookiesCondition via AssignProperties_To_DeliveryRuleCookiesCondition & AssignProperties_From_DeliveryRuleCookiesCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleCookiesCondition, DeliveryRuleCookiesConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleCookiesCondition tests if a specific instance of DeliveryRuleCookiesCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleCookiesCondition(subject DeliveryRuleCookiesCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCookiesCondition
	err := copied.AssignProperties_To_DeliveryRuleCookiesCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCookiesCondition
	err = actual.AssignProperties_From_DeliveryRuleCookiesCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCookiesCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCookiesCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCookiesCondition, DeliveryRuleCookiesConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCookiesCondition runs a test to see if a specific instance of DeliveryRuleCookiesCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCookiesCondition(subject DeliveryRuleCookiesCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCookiesCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCookiesCondition instances for property testing - lazily instantiated by
// DeliveryRuleCookiesConditionGenerator()
var deliveryRuleCookiesConditionGenerator gopter.Gen

// DeliveryRuleCookiesConditionGenerator returns a generator of DeliveryRuleCookiesCondition instances for property testing.
// We first initialize deliveryRuleCookiesConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCookiesConditionGenerator() gopter.Gen {
	if deliveryRuleCookiesConditionGenerator != nil {
		return deliveryRuleCookiesConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition(generators)
	deliveryRuleCookiesConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCookiesCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCookiesCondition(generators)
	deliveryRuleCookiesConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCookiesCondition{}), generators)

	return deliveryRuleCookiesConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCookiesCondition_Name_Cookies)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCookiesCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCookiesCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CookiesMatchConditionParametersGenerator())
}

func Test_DeliveryRuleCookiesCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCookiesCondition_STATUS to DeliveryRuleCookiesCondition_STATUS via AssignProperties_To_DeliveryRuleCookiesCondition_STATUS & AssignProperties_From_DeliveryRuleCookiesCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleCookiesCondition_STATUS, DeliveryRuleCookiesCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleCookiesCondition_STATUS tests if a specific instance of DeliveryRuleCookiesCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleCookiesCondition_STATUS(subject DeliveryRuleCookiesCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCookiesCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleCookiesCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCookiesCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleCookiesCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCookiesCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCookiesCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCookiesCondition_STATUS, DeliveryRuleCookiesCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCookiesCondition_STATUS runs a test to see if a specific instance of DeliveryRuleCookiesCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCookiesCondition_STATUS(subject DeliveryRuleCookiesCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCookiesCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCookiesCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleCookiesCondition_STATUSGenerator()
var deliveryRuleCookiesCondition_STATUSGenerator gopter.Gen

// DeliveryRuleCookiesCondition_STATUSGenerator returns a generator of DeliveryRuleCookiesCondition_STATUS instances for property testing.
// We first initialize deliveryRuleCookiesCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCookiesCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleCookiesCondition_STATUSGenerator != nil {
		return deliveryRuleCookiesCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition_STATUS(generators)
	deliveryRuleCookiesCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCookiesCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCookiesCondition_STATUS(generators)
	deliveryRuleCookiesCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCookiesCondition_STATUS{}), generators)

	return deliveryRuleCookiesCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCookiesCondition_Name_STATUS_Cookies)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCookiesCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCookiesCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CookiesMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleHostNameCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleHostNameCondition to DeliveryRuleHostNameCondition via AssignProperties_To_DeliveryRuleHostNameCondition & AssignProperties_From_DeliveryRuleHostNameCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleHostNameCondition, DeliveryRuleHostNameConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleHostNameCondition tests if a specific instance of DeliveryRuleHostNameCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleHostNameCondition(subject DeliveryRuleHostNameCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleHostNameCondition
	err := copied.AssignProperties_To_DeliveryRuleHostNameCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleHostNameCondition
	err = actual.AssignProperties_From_DeliveryRuleHostNameCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleHostNameCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleHostNameCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleHostNameCondition, DeliveryRuleHostNameConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleHostNameCondition runs a test to see if a specific instance of DeliveryRuleHostNameCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleHostNameCondition(subject DeliveryRuleHostNameCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleHostNameCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleHostNameCondition instances for property testing - lazily instantiated by
// DeliveryRuleHostNameConditionGenerator()
var deliveryRuleHostNameConditionGenerator gopter.Gen

// DeliveryRuleHostNameConditionGenerator returns a generator of DeliveryRuleHostNameCondition instances for property testing.
// We first initialize deliveryRuleHostNameConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleHostNameConditionGenerator() gopter.Gen {
	if deliveryRuleHostNameConditionGenerator != nil {
		return deliveryRuleHostNameConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition(generators)
	deliveryRuleHostNameConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHostNameCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleHostNameCondition(generators)
	deliveryRuleHostNameConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHostNameCondition{}), generators)

	return deliveryRuleHostNameConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleHostNameCondition_Name_HostName)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleHostNameCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleHostNameCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HostNameMatchConditionParametersGenerator())
}

func Test_DeliveryRuleHostNameCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleHostNameCondition_STATUS to DeliveryRuleHostNameCondition_STATUS via AssignProperties_To_DeliveryRuleHostNameCondition_STATUS & AssignProperties_From_DeliveryRuleHostNameCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleHostNameCondition_STATUS, DeliveryRuleHostNameCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleHostNameCondition_STATUS tests if a specific instance of DeliveryRuleHostNameCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleHostNameCondition_STATUS(subject DeliveryRuleHostNameCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleHostNameCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleHostNameCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleHostNameCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleHostNameCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleHostNameCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleHostNameCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleHostNameCondition_STATUS, DeliveryRuleHostNameCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleHostNameCondition_STATUS runs a test to see if a specific instance of DeliveryRuleHostNameCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleHostNameCondition_STATUS(subject DeliveryRuleHostNameCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleHostNameCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleHostNameCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleHostNameCondition_STATUSGenerator()
var deliveryRuleHostNameCondition_STATUSGenerator gopter.Gen

// DeliveryRuleHostNameCondition_STATUSGenerator returns a generator of DeliveryRuleHostNameCondition_STATUS instances for property testing.
// We first initialize deliveryRuleHostNameCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleHostNameCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleHostNameCondition_STATUSGenerator != nil {
		return deliveryRuleHostNameCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition_STATUS(generators)
	deliveryRuleHostNameCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHostNameCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleHostNameCondition_STATUS(generators)
	deliveryRuleHostNameCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHostNameCondition_STATUS{}), generators)

	return deliveryRuleHostNameCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleHostNameCondition_Name_STATUS_HostName)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleHostNameCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleHostNameCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HostNameMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleHttpVersionCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleHttpVersionCondition to DeliveryRuleHttpVersionCondition via AssignProperties_To_DeliveryRuleHttpVersionCondition & AssignProperties_From_DeliveryRuleHttpVersionCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleHttpVersionCondition, DeliveryRuleHttpVersionConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleHttpVersionCondition tests if a specific instance of DeliveryRuleHttpVersionCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleHttpVersionCondition(subject DeliveryRuleHttpVersionCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleHttpVersionCondition
	err := copied.AssignProperties_To_DeliveryRuleHttpVersionCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleHttpVersionCondition
	err = actual.AssignProperties_From_DeliveryRuleHttpVersionCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleHttpVersionCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleHttpVersionCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleHttpVersionCondition, DeliveryRuleHttpVersionConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleHttpVersionCondition runs a test to see if a specific instance of DeliveryRuleHttpVersionCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleHttpVersionCondition(subject DeliveryRuleHttpVersionCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleHttpVersionCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleHttpVersionCondition instances for property testing - lazily instantiated by
// DeliveryRuleHttpVersionConditionGenerator()
var deliveryRuleHttpVersionConditionGenerator gopter.Gen

// DeliveryRuleHttpVersionConditionGenerator returns a generator of DeliveryRuleHttpVersionCondition instances for property testing.
// We first initialize deliveryRuleHttpVersionConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleHttpVersionConditionGenerator() gopter.Gen {
	if deliveryRuleHttpVersionConditionGenerator != nil {
		return deliveryRuleHttpVersionConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition(generators)
	deliveryRuleHttpVersionConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHttpVersionCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionCondition(generators)
	deliveryRuleHttpVersionConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHttpVersionCondition{}), generators)

	return deliveryRuleHttpVersionConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleHttpVersionCondition_Name_HttpVersion)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HttpVersionMatchConditionParametersGenerator())
}

func Test_DeliveryRuleHttpVersionCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleHttpVersionCondition_STATUS to DeliveryRuleHttpVersionCondition_STATUS via AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS & AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleHttpVersionCondition_STATUS, DeliveryRuleHttpVersionCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleHttpVersionCondition_STATUS tests if a specific instance of DeliveryRuleHttpVersionCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleHttpVersionCondition_STATUS(subject DeliveryRuleHttpVersionCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleHttpVersionCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleHttpVersionCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleHttpVersionCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleHttpVersionCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleHttpVersionCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleHttpVersionCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleHttpVersionCondition_STATUS, DeliveryRuleHttpVersionCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleHttpVersionCondition_STATUS runs a test to see if a specific instance of DeliveryRuleHttpVersionCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleHttpVersionCondition_STATUS(subject DeliveryRuleHttpVersionCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleHttpVersionCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleHttpVersionCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleHttpVersionCondition_STATUSGenerator()
var deliveryRuleHttpVersionCondition_STATUSGenerator gopter.Gen

// DeliveryRuleHttpVersionCondition_STATUSGenerator returns a generator of DeliveryRuleHttpVersionCondition_STATUS instances for property testing.
// We first initialize deliveryRuleHttpVersionCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleHttpVersionCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleHttpVersionCondition_STATUSGenerator != nil {
		return deliveryRuleHttpVersionCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition_STATUS(generators)
	deliveryRuleHttpVersionCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHttpVersionCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionCondition_STATUS(generators)
	deliveryRuleHttpVersionCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHttpVersionCondition_STATUS{}), generators)

	return deliveryRuleHttpVersionCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleHttpVersionCondition_Name_STATUS_HttpVersion)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HttpVersionMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleIsDeviceCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleIsDeviceCondition to DeliveryRuleIsDeviceCondition via AssignProperties_To_DeliveryRuleIsDeviceCondition & AssignProperties_From_DeliveryRuleIsDeviceCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleIsDeviceCondition, DeliveryRuleIsDeviceConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleIsDeviceCondition tests if a specific instance of DeliveryRuleIsDeviceCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleIsDeviceCondition(subject DeliveryRuleIsDeviceCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleIsDeviceCondition
	err := copied.AssignProperties_To_DeliveryRuleIsDeviceCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleIsDeviceCondition
	err = actual.AssignProperties_From_DeliveryRuleIsDeviceCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleIsDeviceCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleIsDeviceCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleIsDeviceCondition, DeliveryRuleIsDeviceConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleIsDeviceCondition runs a test to see if a specific instance of DeliveryRuleIsDeviceCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleIsDeviceCondition(subject DeliveryRuleIsDeviceCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleIsDeviceCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleIsDeviceCondition instances for property testing - lazily instantiated by
// DeliveryRuleIsDeviceConditionGenerator()
var deliveryRuleIsDeviceConditionGenerator gopter.Gen

// DeliveryRuleIsDeviceConditionGenerator returns a generator of DeliveryRuleIsDeviceCondition instances for property testing.
// We first initialize deliveryRuleIsDeviceConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleIsDeviceConditionGenerator() gopter.Gen {
	if deliveryRuleIsDeviceConditionGenerator != nil {
		return deliveryRuleIsDeviceConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition(generators)
	deliveryRuleIsDeviceConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleIsDeviceCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceCondition(generators)
	deliveryRuleIsDeviceConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleIsDeviceCondition{}), generators)

	return deliveryRuleIsDeviceConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleIsDeviceCondition_Name_IsDevice)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(IsDeviceMatchConditionParametersGenerator())
}

func Test_DeliveryRuleIsDeviceCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleIsDeviceCondition_STATUS to DeliveryRuleIsDeviceCondition_STATUS via AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS & AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleIsDeviceCondition_STATUS, DeliveryRuleIsDeviceCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleIsDeviceCondition_STATUS tests if a specific instance of DeliveryRuleIsDeviceCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleIsDeviceCondition_STATUS(subject DeliveryRuleIsDeviceCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleIsDeviceCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleIsDeviceCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleIsDeviceCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleIsDeviceCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleIsDeviceCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleIsDeviceCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleIsDeviceCondition_STATUS, DeliveryRuleIsDeviceCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleIsDeviceCondition_STATUS runs a test to see if a specific instance of DeliveryRuleIsDeviceCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleIsDeviceCondition_STATUS(subject DeliveryRuleIsDeviceCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleIsDeviceCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleIsDeviceCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleIsDeviceCondition_STATUSGenerator()
var deliveryRuleIsDeviceCondition_STATUSGenerator gopter.Gen

// DeliveryRuleIsDeviceCondition_STATUSGenerator returns a generator of DeliveryRuleIsDeviceCondition_STATUS instances for property testing.
// We first initialize deliveryRuleIsDeviceCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleIsDeviceCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleIsDeviceCondition_STATUSGenerator != nil {
		return deliveryRuleIsDeviceCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition_STATUS(generators)
	deliveryRuleIsDeviceCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleIsDeviceCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceCondition_STATUS(generators)
	deliveryRuleIsDeviceCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleIsDeviceCondition_STATUS{}), generators)

	return deliveryRuleIsDeviceCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleIsDeviceCondition_Name_STATUS_IsDevice)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(IsDeviceMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRulePostArgsCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRulePostArgsCondition to DeliveryRulePostArgsCondition via AssignProperties_To_DeliveryRulePostArgsCondition & AssignProperties_From_DeliveryRulePostArgsCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRulePostArgsCondition, DeliveryRulePostArgsConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRulePostArgsCondition tests if a specific instance of DeliveryRulePostArgsCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRulePostArgsCondition(subject DeliveryRulePostArgsCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRulePostArgsCondition
	err := copied.AssignProperties_To_DeliveryRulePostArgsCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRulePostArgsCondition
	err = actual.AssignProperties_From_DeliveryRulePostArgsCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRulePostArgsCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRulePostArgsCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRulePostArgsCondition, DeliveryRulePostArgsConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRulePostArgsCondition runs a test to see if a specific instance of DeliveryRulePostArgsCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRulePostArgsCondition(subject DeliveryRulePostArgsCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRulePostArgsCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRulePostArgsCondition instances for property testing - lazily instantiated by
// DeliveryRulePostArgsConditionGenerator()
var deliveryRulePostArgsConditionGenerator gopter.Gen

// DeliveryRulePostArgsConditionGenerator returns a generator of DeliveryRulePostArgsCondition instances for property testing.
// We first initialize deliveryRulePostArgsConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRulePostArgsConditionGenerator() gopter.Gen {
	if deliveryRulePostArgsConditionGenerator != nil {
		return deliveryRulePostArgsConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition(generators)
	deliveryRulePostArgsConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRulePostArgsCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRulePostArgsCondition(generators)
	deliveryRulePostArgsConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRulePostArgsCondition{}), generators)

	return deliveryRulePostArgsConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRulePostArgsCondition_Name_PostArgs)
}

// AddRelatedPropertyGeneratorsForDeliveryRulePostArgsCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRulePostArgsCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(PostArgsMatchConditionParametersGenerator())
}

func Test_DeliveryRulePostArgsCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRulePostArgsCondition_STATUS to DeliveryRulePostArgsCondition_STATUS via AssignProperties_To_DeliveryRulePostArgsCondition_STATUS & AssignProperties_From_DeliveryRulePostArgsCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRulePostArgsCondition_STATUS, DeliveryRulePostArgsCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRulePostArgsCondition_STATUS tests if a specific instance of DeliveryRulePostArgsCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRulePostArgsCondition_STATUS(subject DeliveryRulePostArgsCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRulePostArgsCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRulePostArgsCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRulePostArgsCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRulePostArgsCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRulePostArgsCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRulePostArgsCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRulePostArgsCondition_STATUS, DeliveryRulePostArgsCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRulePostArgsCondition_STATUS runs a test to see if a specific instance of DeliveryRulePostArgsCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRulePostArgsCondition_STATUS(subject DeliveryRulePostArgsCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRulePostArgsCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRulePostArgsCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRulePostArgsCondition_STATUSGenerator()
var deliveryRulePostArgsCondition_STATUSGenerator gopter.Gen

// DeliveryRulePostArgsCondition_STATUSGenerator returns a generator of DeliveryRulePostArgsCondition_STATUS instances for property testing.
// We first initialize deliveryRulePostArgsCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRulePostArgsCondition_STATUSGenerator() gopter.Gen {
	if deliveryRulePostArgsCondition_STATUSGenerator != nil {
		return deliveryRulePostArgsCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition_STATUS(generators)
	deliveryRulePostArgsCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRulePostArgsCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRulePostArgsCondition_STATUS(generators)
	deliveryRulePostArgsCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRulePostArgsCondition_STATUS{}), generators)

	return deliveryRulePostArgsCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRulePostArgsCondition_Name_STATUS_PostArgs)
}

// AddRelatedPropertyGeneratorsForDeliveryRulePostArgsCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRulePostArgsCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(PostArgsMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleQueryStringCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleQueryStringCondition to DeliveryRuleQueryStringCondition via AssignProperties_To_DeliveryRuleQueryStringCondition & AssignProperties_From_DeliveryRuleQueryStringCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleQueryStringCondition, DeliveryRuleQueryStringConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleQueryStringCondition tests if a specific instance of DeliveryRuleQueryStringCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleQueryStringCondition(subject DeliveryRuleQueryStringCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleQueryStringCondition
	err := copied.AssignProperties_To_DeliveryRuleQueryStringCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleQueryStringCondition
	err = actual.AssignProperties_From_DeliveryRuleQueryStringCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleQueryStringCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleQueryStringCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleQueryStringCondition, DeliveryRuleQueryStringConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleQueryStringCondition runs a test to see if a specific instance of DeliveryRuleQueryStringCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleQueryStringCondition(subject DeliveryRuleQueryStringCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleQueryStringCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleQueryStringCondition instances for property testing - lazily instantiated by
// DeliveryRuleQueryStringConditionGenerator()
var deliveryRuleQueryStringConditionGenerator gopter.Gen

// DeliveryRuleQueryStringConditionGenerator returns a generator of DeliveryRuleQueryStringCondition instances for property testing.
// We first initialize deliveryRuleQueryStringConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleQueryStringConditionGenerator() gopter.Gen {
	if deliveryRuleQueryStringConditionGenerator != nil {
		return deliveryRuleQueryStringConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition(generators)
	deliveryRuleQueryStringConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleQueryStringCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringCondition(generators)
	deliveryRuleQueryStringConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleQueryStringCondition{}), generators)

	return deliveryRuleQueryStringConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleQueryStringCondition_Name_QueryString)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(QueryStringMatchConditionParametersGenerator())
}

func Test_DeliveryRuleQueryStringCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleQueryStringCondition_STATUS to DeliveryRuleQueryStringCondition_STATUS via AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS & AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleQueryStringCondition_STATUS, DeliveryRuleQueryStringCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleQueryStringCondition_STATUS tests if a specific instance of DeliveryRuleQueryStringCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleQueryStringCondition_STATUS(subject DeliveryRuleQueryStringCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleQueryStringCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleQueryStringCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleQueryStringCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleQueryStringCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleQueryStringCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleQueryStringCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleQueryStringCondition_STATUS, DeliveryRuleQueryStringCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleQueryStringCondition_STATUS runs a test to see if a specific instance of DeliveryRuleQueryStringCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleQueryStringCondition_STATUS(subject DeliveryRuleQueryStringCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleQueryStringCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleQueryStringCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleQueryStringCondition_STATUSGenerator()
var deliveryRuleQueryStringCondition_STATUSGenerator gopter.Gen

// DeliveryRuleQueryStringCondition_STATUSGenerator returns a generator of DeliveryRuleQueryStringCondition_STATUS instances for property testing.
// We first initialize deliveryRuleQueryStringCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleQueryStringCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleQueryStringCondition_STATUSGenerator != nil {
		return deliveryRuleQueryStringCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition_STATUS(generators)
	deliveryRuleQueryStringCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleQueryStringCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringCondition_STATUS(generators)
	deliveryRuleQueryStringCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleQueryStringCondition_STATUS{}), generators)

	return deliveryRuleQueryStringCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleQueryStringCondition_Name_STATUS_QueryString)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(QueryStringMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleRemoteAddressCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRemoteAddressCondition to DeliveryRuleRemoteAddressCondition via AssignProperties_To_DeliveryRuleRemoteAddressCondition & AssignProperties_From_DeliveryRuleRemoteAddressCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRemoteAddressCondition, DeliveryRuleRemoteAddressConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRemoteAddressCondition tests if a specific instance of DeliveryRuleRemoteAddressCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRemoteAddressCondition(subject DeliveryRuleRemoteAddressCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRemoteAddressCondition
	err := copied.AssignProperties_To_DeliveryRuleRemoteAddressCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRemoteAddressCondition
	err = actual.AssignProperties_From_DeliveryRuleRemoteAddressCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRemoteAddressCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRemoteAddressCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRemoteAddressCondition, DeliveryRuleRemoteAddressConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRemoteAddressCondition runs a test to see if a specific instance of DeliveryRuleRemoteAddressCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRemoteAddressCondition(subject DeliveryRuleRemoteAddressCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRemoteAddressCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRemoteAddressCondition instances for property testing - lazily instantiated by
// DeliveryRuleRemoteAddressConditionGenerator()
var deliveryRuleRemoteAddressConditionGenerator gopter.Gen

// DeliveryRuleRemoteAddressConditionGenerator returns a generator of DeliveryRuleRemoteAddressCondition instances for property testing.
// We first initialize deliveryRuleRemoteAddressConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRemoteAddressConditionGenerator() gopter.Gen {
	if deliveryRuleRemoteAddressConditionGenerator != nil {
		return deliveryRuleRemoteAddressConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition(generators)
	deliveryRuleRemoteAddressConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRemoteAddressCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressCondition(generators)
	deliveryRuleRemoteAddressConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRemoteAddressCondition{}), generators)

	return deliveryRuleRemoteAddressConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRemoteAddressCondition_Name_RemoteAddress)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RemoteAddressMatchConditionParametersGenerator())
}

func Test_DeliveryRuleRemoteAddressCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRemoteAddressCondition_STATUS to DeliveryRuleRemoteAddressCondition_STATUS via AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS & AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRemoteAddressCondition_STATUS, DeliveryRuleRemoteAddressCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRemoteAddressCondition_STATUS tests if a specific instance of DeliveryRuleRemoteAddressCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRemoteAddressCondition_STATUS(subject DeliveryRuleRemoteAddressCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRemoteAddressCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleRemoteAddressCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRemoteAddressCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleRemoteAddressCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRemoteAddressCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRemoteAddressCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRemoteAddressCondition_STATUS, DeliveryRuleRemoteAddressCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRemoteAddressCondition_STATUS runs a test to see if a specific instance of DeliveryRuleRemoteAddressCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRemoteAddressCondition_STATUS(subject DeliveryRuleRemoteAddressCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRemoteAddressCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRemoteAddressCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleRemoteAddressCondition_STATUSGenerator()
var deliveryRuleRemoteAddressCondition_STATUSGenerator gopter.Gen

// DeliveryRuleRemoteAddressCondition_STATUSGenerator returns a generator of DeliveryRuleRemoteAddressCondition_STATUS instances for property testing.
// We first initialize deliveryRuleRemoteAddressCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRemoteAddressCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleRemoteAddressCondition_STATUSGenerator != nil {
		return deliveryRuleRemoteAddressCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition_STATUS(generators)
	deliveryRuleRemoteAddressCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRemoteAddressCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressCondition_STATUS(generators)
	deliveryRuleRemoteAddressCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRemoteAddressCondition_STATUS{}), generators)

	return deliveryRuleRemoteAddressCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRemoteAddressCondition_Name_STATUS_RemoteAddress)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RemoteAddressMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleRequestBodyCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestBodyCondition to DeliveryRuleRequestBodyCondition via AssignProperties_To_DeliveryRuleRequestBodyCondition & AssignProperties_From_DeliveryRuleRequestBodyCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestBodyCondition, DeliveryRuleRequestBodyConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestBodyCondition tests if a specific instance of DeliveryRuleRequestBodyCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestBodyCondition(subject DeliveryRuleRequestBodyCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestBodyCondition
	err := copied.AssignProperties_To_DeliveryRuleRequestBodyCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestBodyCondition
	err = actual.AssignProperties_From_DeliveryRuleRequestBodyCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestBodyCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestBodyCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestBodyCondition, DeliveryRuleRequestBodyConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestBodyCondition runs a test to see if a specific instance of DeliveryRuleRequestBodyCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestBodyCondition(subject DeliveryRuleRequestBodyCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestBodyCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestBodyCondition instances for property testing - lazily instantiated by
// DeliveryRuleRequestBodyConditionGenerator()
var deliveryRuleRequestBodyConditionGenerator gopter.Gen

// DeliveryRuleRequestBodyConditionGenerator returns a generator of DeliveryRuleRequestBodyCondition instances for property testing.
// We first initialize deliveryRuleRequestBodyConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestBodyConditionGenerator() gopter.Gen {
	if deliveryRuleRequestBodyConditionGenerator != nil {
		return deliveryRuleRequestBodyConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition(generators)
	deliveryRuleRequestBodyConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestBodyCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyCondition(generators)
	deliveryRuleRequestBodyConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestBodyCondition{}), generators)

	return deliveryRuleRequestBodyConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestBodyCondition_Name_RequestBody)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestBodyMatchConditionParametersGenerator())
}

func Test_DeliveryRuleRequestBodyCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestBodyCondition_STATUS to DeliveryRuleRequestBodyCondition_STATUS via AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS & AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestBodyCondition_STATUS, DeliveryRuleRequestBodyCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestBodyCondition_STATUS tests if a specific instance of DeliveryRuleRequestBodyCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestBodyCondition_STATUS(subject DeliveryRuleRequestBodyCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestBodyCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleRequestBodyCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestBodyCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleRequestBodyCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestBodyCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestBodyCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestBodyCondition_STATUS, DeliveryRuleRequestBodyCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestBodyCondition_STATUS runs a test to see if a specific instance of DeliveryRuleRequestBodyCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestBodyCondition_STATUS(subject DeliveryRuleRequestBodyCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestBodyCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestBodyCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleRequestBodyCondition_STATUSGenerator()
var deliveryRuleRequestBodyCondition_STATUSGenerator gopter.Gen

// DeliveryRuleRequestBodyCondition_STATUSGenerator returns a generator of DeliveryRuleRequestBodyCondition_STATUS instances for property testing.
// We first initialize deliveryRuleRequestBodyCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestBodyCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleRequestBodyCondition_STATUSGenerator != nil {
		return deliveryRuleRequestBodyCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition_STATUS(generators)
	deliveryRuleRequestBodyCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestBodyCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyCondition_STATUS(generators)
	deliveryRuleRequestBodyCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestBodyCondition_STATUS{}), generators)

	return deliveryRuleRequestBodyCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestBodyCondition_Name_STATUS_RequestBody)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestBodyMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleRequestHeaderAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestHeaderAction to DeliveryRuleRequestHeaderAction via AssignProperties_To_DeliveryRuleRequestHeaderAction & AssignProperties_From_DeliveryRuleRequestHeaderAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestHeaderAction, DeliveryRuleRequestHeaderActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestHeaderAction tests if a specific instance of DeliveryRuleRequestHeaderAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestHeaderAction(subject DeliveryRuleRequestHeaderAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestHeaderAction
	err := copied.AssignProperties_To_DeliveryRuleRequestHeaderAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestHeaderAction
	err = actual.AssignProperties_From_DeliveryRuleRequestHeaderAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestHeaderAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestHeaderAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestHeaderAction, DeliveryRuleRequestHeaderActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestHeaderAction runs a test to see if a specific instance of DeliveryRuleRequestHeaderAction round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestHeaderAction(subject DeliveryRuleRequestHeaderAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestHeaderAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestHeaderAction instances for property testing - lazily instantiated by
// DeliveryRuleRequestHeaderActionGenerator()
var deliveryRuleRequestHeaderActionGenerator gopter.Gen

// DeliveryRuleRequestHeaderActionGenerator returns a generator of DeliveryRuleRequestHeaderAction instances for property testing.
// We first initialize deliveryRuleRequestHeaderActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestHeaderActionGenerator() gopter.Gen {
	if deliveryRuleRequestHeaderActionGenerator != nil {
		return deliveryRuleRequestHeaderActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction(generators)
	deliveryRuleRequestHeaderActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderAction(generators)
	deliveryRuleRequestHeaderActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderAction{}), generators)

	return deliveryRuleRequestHeaderActionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestHeaderAction_Name_ModifyRequestHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HeaderActionParametersGenerator())
}

func Test_DeliveryRuleRequestHeaderAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestHeaderAction_STATUS to DeliveryRuleRequestHeaderAction_STATUS via AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS & AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestHeaderAction_STATUS, DeliveryRuleRequestHeaderAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestHeaderAction_STATUS tests if a specific instance of DeliveryRuleRequestHeaderAction_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestHeaderAction_STATUS(subject DeliveryRuleRequestHeaderAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestHeaderAction_STATUS
	err := copied.AssignProperties_To_DeliveryRuleRequestHeaderAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestHeaderAction_STATUS
	err = actual.AssignProperties_From_DeliveryRuleRequestHeaderAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestHeaderAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestHeaderAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestHeaderAction_STATUS, DeliveryRuleRequestHeaderAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestHeaderAction_STATUS runs a test to see if a specific instance of DeliveryRuleRequestHeaderAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestHeaderAction_STATUS(subject DeliveryRuleRequestHeaderAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestHeaderAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestHeaderAction_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleRequestHeaderAction_STATUSGenerator()
var deliveryRuleRequestHeaderAction_STATUSGenerator gopter.Gen

// DeliveryRuleRequestHeaderAction_STATUSGenerator returns a generator of DeliveryRuleRequestHeaderAction_STATUS instances for property testing.
// We first initialize deliveryRuleRequestHeaderAction_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestHeaderAction_STATUSGenerator() gopter.Gen {
	if deliveryRuleRequestHeaderAction_STATUSGenerator != nil {
		return deliveryRuleRequestHeaderAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction_STATUS(generators)
	deliveryRuleRequestHeaderAction_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderAction_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderAction_STATUS(generators)
	deliveryRuleRequestHeaderAction_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderAction_STATUS{}), generators)

	return deliveryRuleRequestHeaderAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestHeaderAction_Name_STATUS_ModifyRequestHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderAction_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HeaderActionParameters_STATUSGenerator())
}

func Test_DeliveryRuleRequestHeaderCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestHeaderCondition to DeliveryRuleRequestHeaderCondition via AssignProperties_To_DeliveryRuleRequestHeaderCondition & AssignProperties_From_DeliveryRuleRequestHeaderCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestHeaderCondition, DeliveryRuleRequestHeaderConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestHeaderCondition tests if a specific instance of DeliveryRuleRequestHeaderCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestHeaderCondition(subject DeliveryRuleRequestHeaderCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestHeaderCondition
	err := copied.AssignProperties_To_DeliveryRuleRequestHeaderCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestHeaderCondition
	err = actual.AssignProperties_From_DeliveryRuleRequestHeaderCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestHeaderCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestHeaderCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestHeaderCondition, DeliveryRuleRequestHeaderConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestHeaderCondition runs a test to see if a specific instance of DeliveryRuleRequestHeaderCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestHeaderCondition(subject DeliveryRuleRequestHeaderCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestHeaderCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestHeaderCondition instances for property testing - lazily instantiated by
// DeliveryRuleRequestHeaderConditionGenerator()
var deliveryRuleRequestHeaderConditionGenerator gopter.Gen

// DeliveryRuleRequestHeaderConditionGenerator returns a generator of DeliveryRuleRequestHeaderCondition instances for property testing.
// We first initialize deliveryRuleRequestHeaderConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestHeaderConditionGenerator() gopter.Gen {
	if deliveryRuleRequestHeaderConditionGenerator != nil {
		return deliveryRuleRequestHeaderConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition(generators)
	deliveryRuleRequestHeaderConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderCondition(generators)
	deliveryRuleRequestHeaderConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderCondition{}), generators)

	return deliveryRuleRequestHeaderConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestHeaderCondition_Name_RequestHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestHeaderMatchConditionParametersGenerator())
}

func Test_DeliveryRuleRequestHeaderCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestHeaderCondition_STATUS to DeliveryRuleRequestHeaderCondition_STATUS via AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS & AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestHeaderCondition_STATUS, DeliveryRuleRequestHeaderCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestHeaderCondition_STATUS tests if a specific instance of DeliveryRuleRequestHeaderCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestHeaderCondition_STATUS(subject DeliveryRuleRequestHeaderCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestHeaderCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleRequestHeaderCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestHeaderCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleRequestHeaderCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestHeaderCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestHeaderCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestHeaderCondition_STATUS, DeliveryRuleRequestHeaderCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestHeaderCondition_STATUS runs a test to see if a specific instance of DeliveryRuleRequestHeaderCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestHeaderCondition_STATUS(subject DeliveryRuleRequestHeaderCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestHeaderCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestHeaderCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleRequestHeaderCondition_STATUSGenerator()
var deliveryRuleRequestHeaderCondition_STATUSGenerator gopter.Gen

// DeliveryRuleRequestHeaderCondition_STATUSGenerator returns a generator of DeliveryRuleRequestHeaderCondition_STATUS instances for property testing.
// We first initialize deliveryRuleRequestHeaderCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestHeaderCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleRequestHeaderCondition_STATUSGenerator != nil {
		return deliveryRuleRequestHeaderCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition_STATUS(generators)
	deliveryRuleRequestHeaderCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderCondition_STATUS(generators)
	deliveryRuleRequestHeaderCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderCondition_STATUS{}), generators)

	return deliveryRuleRequestHeaderCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestHeaderCondition_Name_STATUS_RequestHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestHeaderMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleRequestMethodCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestMethodCondition to DeliveryRuleRequestMethodCondition via AssignProperties_To_DeliveryRuleRequestMethodCondition & AssignProperties_From_DeliveryRuleRequestMethodCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestMethodCondition, DeliveryRuleRequestMethodConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestMethodCondition tests if a specific instance of DeliveryRuleRequestMethodCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestMethodCondition(subject DeliveryRuleRequestMethodCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestMethodCondition
	err := copied.AssignProperties_To_DeliveryRuleRequestMethodCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestMethodCondition
	err = actual.AssignProperties_From_DeliveryRuleRequestMethodCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestMethodCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestMethodCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestMethodCondition, DeliveryRuleRequestMethodConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestMethodCondition runs a test to see if a specific instance of DeliveryRuleRequestMethodCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestMethodCondition(subject DeliveryRuleRequestMethodCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestMethodCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestMethodCondition instances for property testing - lazily instantiated by
// DeliveryRuleRequestMethodConditionGenerator()
var deliveryRuleRequestMethodConditionGenerator gopter.Gen

// DeliveryRuleRequestMethodConditionGenerator returns a generator of DeliveryRuleRequestMethodCondition instances for property testing.
// We first initialize deliveryRuleRequestMethodConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestMethodConditionGenerator() gopter.Gen {
	if deliveryRuleRequestMethodConditionGenerator != nil {
		return deliveryRuleRequestMethodConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition(generators)
	deliveryRuleRequestMethodConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestMethodCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodCondition(generators)
	deliveryRuleRequestMethodConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestMethodCondition{}), generators)

	return deliveryRuleRequestMethodConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestMethodCondition_Name_RequestMethod)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestMethodMatchConditionParametersGenerator())
}

func Test_DeliveryRuleRequestMethodCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestMethodCondition_STATUS to DeliveryRuleRequestMethodCondition_STATUS via AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS & AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestMethodCondition_STATUS, DeliveryRuleRequestMethodCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestMethodCondition_STATUS tests if a specific instance of DeliveryRuleRequestMethodCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestMethodCondition_STATUS(subject DeliveryRuleRequestMethodCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestMethodCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleRequestMethodCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestMethodCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleRequestMethodCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestMethodCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestMethodCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestMethodCondition_STATUS, DeliveryRuleRequestMethodCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestMethodCondition_STATUS runs a test to see if a specific instance of DeliveryRuleRequestMethodCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestMethodCondition_STATUS(subject DeliveryRuleRequestMethodCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestMethodCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestMethodCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleRequestMethodCondition_STATUSGenerator()
var deliveryRuleRequestMethodCondition_STATUSGenerator gopter.Gen

// DeliveryRuleRequestMethodCondition_STATUSGenerator returns a generator of DeliveryRuleRequestMethodCondition_STATUS instances for property testing.
// We first initialize deliveryRuleRequestMethodCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestMethodCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleRequestMethodCondition_STATUSGenerator != nil {
		return deliveryRuleRequestMethodCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition_STATUS(generators)
	deliveryRuleRequestMethodCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestMethodCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodCondition_STATUS(generators)
	deliveryRuleRequestMethodCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestMethodCondition_STATUS{}), generators)

	return deliveryRuleRequestMethodCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestMethodCondition_Name_STATUS_RequestMethod)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestMethodMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleRequestSchemeCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestSchemeCondition to DeliveryRuleRequestSchemeCondition via AssignProperties_To_DeliveryRuleRequestSchemeCondition & AssignProperties_From_DeliveryRuleRequestSchemeCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestSchemeCondition, DeliveryRuleRequestSchemeConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestSchemeCondition tests if a specific instance of DeliveryRuleRequestSchemeCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestSchemeCondition(subject DeliveryRuleRequestSchemeCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestSchemeCondition
	err := copied.AssignProperties_To_DeliveryRuleRequestSchemeCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestSchemeCondition
	err = actual.AssignProperties_From_DeliveryRuleRequestSchemeCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestSchemeCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestSchemeCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestSchemeCondition, DeliveryRuleRequestSchemeConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestSchemeCondition runs a test to see if a specific instance of DeliveryRuleRequestSchemeCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestSchemeCondition(subject DeliveryRuleRequestSchemeCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestSchemeCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestSchemeCondition instances for property testing - lazily instantiated by
// DeliveryRuleRequestSchemeConditionGenerator()
var deliveryRuleRequestSchemeConditionGenerator gopter.Gen

// DeliveryRuleRequestSchemeConditionGenerator returns a generator of DeliveryRuleRequestSchemeCondition instances for property testing.
// We first initialize deliveryRuleRequestSchemeConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestSchemeConditionGenerator() gopter.Gen {
	if deliveryRuleRequestSchemeConditionGenerator != nil {
		return deliveryRuleRequestSchemeConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition(generators)
	deliveryRuleRequestSchemeConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestSchemeCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeCondition(generators)
	deliveryRuleRequestSchemeConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestSchemeCondition{}), generators)

	return deliveryRuleRequestSchemeConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestSchemeCondition_Name_RequestScheme)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestSchemeMatchConditionParametersGenerator())
}

func Test_DeliveryRuleRequestSchemeCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestSchemeCondition_STATUS to DeliveryRuleRequestSchemeCondition_STATUS via AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS & AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestSchemeCondition_STATUS, DeliveryRuleRequestSchemeCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestSchemeCondition_STATUS tests if a specific instance of DeliveryRuleRequestSchemeCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestSchemeCondition_STATUS(subject DeliveryRuleRequestSchemeCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestSchemeCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleRequestSchemeCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestSchemeCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleRequestSchemeCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestSchemeCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestSchemeCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestSchemeCondition_STATUS, DeliveryRuleRequestSchemeCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestSchemeCondition_STATUS runs a test to see if a specific instance of DeliveryRuleRequestSchemeCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestSchemeCondition_STATUS(subject DeliveryRuleRequestSchemeCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestSchemeCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestSchemeCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleRequestSchemeCondition_STATUSGenerator()
var deliveryRuleRequestSchemeCondition_STATUSGenerator gopter.Gen

// DeliveryRuleRequestSchemeCondition_STATUSGenerator returns a generator of DeliveryRuleRequestSchemeCondition_STATUS instances for property testing.
// We first initialize deliveryRuleRequestSchemeCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestSchemeCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleRequestSchemeCondition_STATUSGenerator != nil {
		return deliveryRuleRequestSchemeCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition_STATUS(generators)
	deliveryRuleRequestSchemeCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestSchemeCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeCondition_STATUS(generators)
	deliveryRuleRequestSchemeCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestSchemeCondition_STATUS{}), generators)

	return deliveryRuleRequestSchemeCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestSchemeCondition_Name_STATUS_RequestScheme)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestSchemeMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleRequestUriCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestUriCondition to DeliveryRuleRequestUriCondition via AssignProperties_To_DeliveryRuleRequestUriCondition & AssignProperties_From_DeliveryRuleRequestUriCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestUriCondition, DeliveryRuleRequestUriConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestUriCondition tests if a specific instance of DeliveryRuleRequestUriCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestUriCondition(subject DeliveryRuleRequestUriCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestUriCondition
	err := copied.AssignProperties_To_DeliveryRuleRequestUriCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestUriCondition
	err = actual.AssignProperties_From_DeliveryRuleRequestUriCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestUriCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestUriCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestUriCondition, DeliveryRuleRequestUriConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestUriCondition runs a test to see if a specific instance of DeliveryRuleRequestUriCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestUriCondition(subject DeliveryRuleRequestUriCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestUriCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestUriCondition instances for property testing - lazily instantiated by
// DeliveryRuleRequestUriConditionGenerator()
var deliveryRuleRequestUriConditionGenerator gopter.Gen

// DeliveryRuleRequestUriConditionGenerator returns a generator of DeliveryRuleRequestUriCondition instances for property testing.
// We first initialize deliveryRuleRequestUriConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestUriConditionGenerator() gopter.Gen {
	if deliveryRuleRequestUriConditionGenerator != nil {
		return deliveryRuleRequestUriConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition(generators)
	deliveryRuleRequestUriConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestUriCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriCondition(generators)
	deliveryRuleRequestUriConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestUriCondition{}), generators)

	return deliveryRuleRequestUriConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestUriCondition_Name_RequestUri)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestUriMatchConditionParametersGenerator())
}

func Test_DeliveryRuleRequestUriCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestUriCondition_STATUS to DeliveryRuleRequestUriCondition_STATUS via AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS & AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestUriCondition_STATUS, DeliveryRuleRequestUriCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestUriCondition_STATUS tests if a specific instance of DeliveryRuleRequestUriCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestUriCondition_STATUS(subject DeliveryRuleRequestUriCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestUriCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleRequestUriCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestUriCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleRequestUriCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestUriCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestUriCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestUriCondition_STATUS, DeliveryRuleRequestUriCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestUriCondition_STATUS runs a test to see if a specific instance of DeliveryRuleRequestUriCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestUriCondition_STATUS(subject DeliveryRuleRequestUriCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestUriCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestUriCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleRequestUriCondition_STATUSGenerator()
var deliveryRuleRequestUriCondition_STATUSGenerator gopter.Gen

// DeliveryRuleRequestUriCondition_STATUSGenerator returns a generator of DeliveryRuleRequestUriCondition_STATUS instances for property testing.
// We first initialize deliveryRuleRequestUriCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestUriCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleRequestUriCondition_STATUSGenerator != nil {
		return deliveryRuleRequestUriCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition_STATUS(generators)
	deliveryRuleRequestUriCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestUriCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriCondition_STATUS(generators)
	deliveryRuleRequestUriCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestUriCondition_STATUS{}), generators)

	return deliveryRuleRequestUriCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestUriCondition_Name_STATUS_RequestUri)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestUriMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleResponseHeaderAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleResponseHeaderAction to DeliveryRuleResponseHeaderAction via AssignProperties_To_DeliveryRuleResponseHeaderAction & AssignProperties_From_DeliveryRuleResponseHeaderAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleResponseHeaderAction, DeliveryRuleResponseHeaderActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleResponseHeaderAction tests if a specific instance of DeliveryRuleResponseHeaderAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleResponseHeaderAction(subject DeliveryRuleResponseHeaderAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleResponseHeaderAction
	err := copied.AssignProperties_To_DeliveryRuleResponseHeaderAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleResponseHeaderAction
	err = actual.AssignProperties_From_DeliveryRuleResponseHeaderAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleResponseHeaderAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleResponseHeaderAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleResponseHeaderAction, DeliveryRuleResponseHeaderActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleResponseHeaderAction runs a test to see if a specific instance of DeliveryRuleResponseHeaderAction round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleResponseHeaderAction(subject DeliveryRuleResponseHeaderAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleResponseHeaderAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleResponseHeaderAction instances for property testing - lazily instantiated by
// DeliveryRuleResponseHeaderActionGenerator()
var deliveryRuleResponseHeaderActionGenerator gopter.Gen

// DeliveryRuleResponseHeaderActionGenerator returns a generator of DeliveryRuleResponseHeaderAction instances for property testing.
// We first initialize deliveryRuleResponseHeaderActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleResponseHeaderActionGenerator() gopter.Gen {
	if deliveryRuleResponseHeaderActionGenerator != nil {
		return deliveryRuleResponseHeaderActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction(generators)
	deliveryRuleResponseHeaderActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleResponseHeaderAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderAction(generators)
	deliveryRuleResponseHeaderActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleResponseHeaderAction{}), generators)

	return deliveryRuleResponseHeaderActionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleResponseHeaderAction_Name_ModifyResponseHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HeaderActionParametersGenerator())
}

func Test_DeliveryRuleResponseHeaderAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleResponseHeaderAction_STATUS to DeliveryRuleResponseHeaderAction_STATUS via AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS & AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleResponseHeaderAction_STATUS, DeliveryRuleResponseHeaderAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleResponseHeaderAction_STATUS tests if a specific instance of DeliveryRuleResponseHeaderAction_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleResponseHeaderAction_STATUS(subject DeliveryRuleResponseHeaderAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleResponseHeaderAction_STATUS
	err := copied.AssignProperties_To_DeliveryRuleResponseHeaderAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleResponseHeaderAction_STATUS
	err = actual.AssignProperties_From_DeliveryRuleResponseHeaderAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleResponseHeaderAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleResponseHeaderAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleResponseHeaderAction_STATUS, DeliveryRuleResponseHeaderAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleResponseHeaderAction_STATUS runs a test to see if a specific instance of DeliveryRuleResponseHeaderAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleResponseHeaderAction_STATUS(subject DeliveryRuleResponseHeaderAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleResponseHeaderAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleResponseHeaderAction_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleResponseHeaderAction_STATUSGenerator()
var deliveryRuleResponseHeaderAction_STATUSGenerator gopter.Gen

// DeliveryRuleResponseHeaderAction_STATUSGenerator returns a generator of DeliveryRuleResponseHeaderAction_STATUS instances for property testing.
// We first initialize deliveryRuleResponseHeaderAction_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleResponseHeaderAction_STATUSGenerator() gopter.Gen {
	if deliveryRuleResponseHeaderAction_STATUSGenerator != nil {
		return deliveryRuleResponseHeaderAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction_STATUS(generators)
	deliveryRuleResponseHeaderAction_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleResponseHeaderAction_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderAction_STATUS(generators)
	deliveryRuleResponseHeaderAction_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleResponseHeaderAction_STATUS{}), generators)

	return deliveryRuleResponseHeaderAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleResponseHeaderAction_Name_STATUS_ModifyResponseHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderAction_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HeaderActionParameters_STATUSGenerator())
}

func Test_DeliveryRuleRouteConfigurationOverrideAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRouteConfigurationOverrideAction to DeliveryRuleRouteConfigurationOverrideAction via AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction & AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRouteConfigurationOverrideAction, DeliveryRuleRouteConfigurationOverrideActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRouteConfigurationOverrideAction tests if a specific instance of DeliveryRuleRouteConfigurationOverrideAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRouteConfigurationOverrideAction(subject DeliveryRuleRouteConfigurationOverrideAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRouteConfigurationOverrideAction
	err := copied.AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRouteConfigurationOverrideAction
	err = actual.AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRouteConfigurationOverrideAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRouteConfigurationOverrideAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideAction, DeliveryRuleRouteConfigurationOverrideActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideAction runs a test to see if a specific instance of DeliveryRuleRouteConfigurationOverrideAction round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideAction(subject DeliveryRuleRouteConfigurationOverrideAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRouteConfigurationOverrideAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRouteConfigurationOverrideAction instances for property testing - lazily instantiated by
// DeliveryRuleRouteConfigurationOverrideActionGenerator()
var deliveryRuleRouteConfigurationOverrideActionGenerator gopter.Gen

// DeliveryRuleRouteConfigurationOverrideActionGenerator returns a generator of DeliveryRuleRouteConfigurationOverrideAction instances for property testing.
// We first initialize deliveryRuleRouteConfigurationOverrideActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRouteConfigurationOverrideActionGenerator() gopter.Gen {
	if deliveryRuleRouteConfigurationOverrideActionGenerator != nil {
		return deliveryRuleRouteConfigurationOverrideActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction(generators)
	deliveryRuleRouteConfigurationOverrideActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRouteConfigurationOverrideAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction(generators)
	deliveryRuleRouteConfigurationOverrideActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRouteConfigurationOverrideAction{}), generators)

	return deliveryRuleRouteConfigurationOverrideActionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRouteConfigurationOverrideAction_Name_RouteConfigurationOverride)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RouteConfigurationOverrideActionParametersGenerator())
}

func Test_DeliveryRuleRouteConfigurationOverrideAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRouteConfigurationOverrideAction_STATUS to DeliveryRuleRouteConfigurationOverrideAction_STATUS via AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS & AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRouteConfigurationOverrideAction_STATUS, DeliveryRuleRouteConfigurationOverrideAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRouteConfigurationOverrideAction_STATUS tests if a specific instance of DeliveryRuleRouteConfigurationOverrideAction_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRouteConfigurationOverrideAction_STATUS(subject DeliveryRuleRouteConfigurationOverrideAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRouteConfigurationOverrideAction_STATUS
	err := copied.AssignProperties_To_DeliveryRuleRouteConfigurationOverrideAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRouteConfigurationOverrideAction_STATUS
	err = actual.AssignProperties_From_DeliveryRuleRouteConfigurationOverrideAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRouteConfigurationOverrideAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRouteConfigurationOverrideAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideAction_STATUS, DeliveryRuleRouteConfigurationOverrideAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideAction_STATUS runs a test to see if a specific instance of DeliveryRuleRouteConfigurationOverrideAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideAction_STATUS(subject DeliveryRuleRouteConfigurationOverrideAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRouteConfigurationOverrideAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRouteConfigurationOverrideAction_STATUS instances for property testing - lazily instantiated
// by DeliveryRuleRouteConfigurationOverrideAction_STATUSGenerator()
var deliveryRuleRouteConfigurationOverrideAction_STATUSGenerator gopter.Gen

// DeliveryRuleRouteConfigurationOverrideAction_STATUSGenerator returns a generator of DeliveryRuleRouteConfigurationOverrideAction_STATUS instances for property testing.
// We first initialize deliveryRuleRouteConfigurationOverrideAction_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRouteConfigurationOverrideAction_STATUSGenerator() gopter.Gen {
	if deliveryRuleRouteConfigurationOverrideAction_STATUSGenerator != nil {
		return deliveryRuleRouteConfigurationOverrideAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction_STATUS(generators)
	deliveryRuleRouteConfigurationOverrideAction_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRouteConfigurationOverrideAction_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction_STATUS(generators)
	deliveryRuleRouteConfigurationOverrideAction_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRouteConfigurationOverrideAction_STATUS{}), generators)

	return deliveryRuleRouteConfigurationOverrideAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRouteConfigurationOverrideAction_Name_STATUS_RouteConfigurationOverride)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RouteConfigurationOverrideActionParameters_STATUSGenerator())
}

func Test_DeliveryRuleServerPortCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleServerPortCondition to DeliveryRuleServerPortCondition via AssignProperties_To_DeliveryRuleServerPortCondition & AssignProperties_From_DeliveryRuleServerPortCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleServerPortCondition, DeliveryRuleServerPortConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleServerPortCondition tests if a specific instance of DeliveryRuleServerPortCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleServerPortCondition(subject DeliveryRuleServerPortCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleServerPortCondition
	err := copied.AssignProperties_To_DeliveryRuleServerPortCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleServerPortCondition
	err = actual.AssignProperties_From_DeliveryRuleServerPortCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleServerPortCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleServerPortCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleServerPortCondition, DeliveryRuleServerPortConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleServerPortCondition runs a test to see if a specific instance of DeliveryRuleServerPortCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleServerPortCondition(subject DeliveryRuleServerPortCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleServerPortCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleServerPortCondition instances for property testing - lazily instantiated by
// DeliveryRuleServerPortConditionGenerator()
var deliveryRuleServerPortConditionGenerator gopter.Gen

// DeliveryRuleServerPortConditionGenerator returns a generator of DeliveryRuleServerPortCondition instances for property testing.
// We first initialize deliveryRuleServerPortConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleServerPortConditionGenerator() gopter.Gen {
	if deliveryRuleServerPortConditionGenerator != nil {
		return deliveryRuleServerPortConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition(generators)
	deliveryRuleServerPortConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleServerPortCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleServerPortCondition(generators)
	deliveryRuleServerPortConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleServerPortCondition{}), generators)

	return deliveryRuleServerPortConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleServerPortCondition_Name_ServerPort)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleServerPortCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleServerPortCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(ServerPortMatchConditionParametersGenerator())
}

func Test_DeliveryRuleServerPortCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleServerPortCondition_STATUS to DeliveryRuleServerPortCondition_STATUS via AssignProperties_To_DeliveryRuleServerPortCondition_STATUS & AssignProperties_From_DeliveryRuleServerPortCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleServerPortCondition_STATUS, DeliveryRuleServerPortCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleServerPortCondition_STATUS tests if a specific instance of DeliveryRuleServerPortCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleServerPortCondition_STATUS(subject DeliveryRuleServerPortCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleServerPortCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleServerPortCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleServerPortCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleServerPortCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleServerPortCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleServerPortCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleServerPortCondition_STATUS, DeliveryRuleServerPortCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleServerPortCondition_STATUS runs a test to see if a specific instance of DeliveryRuleServerPortCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleServerPortCondition_STATUS(subject DeliveryRuleServerPortCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleServerPortCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleServerPortCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleServerPortCondition_STATUSGenerator()
var deliveryRuleServerPortCondition_STATUSGenerator gopter.Gen

// DeliveryRuleServerPortCondition_STATUSGenerator returns a generator of DeliveryRuleServerPortCondition_STATUS instances for property testing.
// We first initialize deliveryRuleServerPortCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleServerPortCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleServerPortCondition_STATUSGenerator != nil {
		return deliveryRuleServerPortCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition_STATUS(generators)
	deliveryRuleServerPortCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleServerPortCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleServerPortCondition_STATUS(generators)
	deliveryRuleServerPortCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleServerPortCondition_STATUS{}), generators)

	return deliveryRuleServerPortCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleServerPortCondition_Name_STATUS_ServerPort)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleServerPortCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleServerPortCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(ServerPortMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleSocketAddrCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleSocketAddrCondition to DeliveryRuleSocketAddrCondition via AssignProperties_To_DeliveryRuleSocketAddrCondition & AssignProperties_From_DeliveryRuleSocketAddrCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleSocketAddrCondition, DeliveryRuleSocketAddrConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleSocketAddrCondition tests if a specific instance of DeliveryRuleSocketAddrCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleSocketAddrCondition(subject DeliveryRuleSocketAddrCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleSocketAddrCondition
	err := copied.AssignProperties_To_DeliveryRuleSocketAddrCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleSocketAddrCondition
	err = actual.AssignProperties_From_DeliveryRuleSocketAddrCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleSocketAddrCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleSocketAddrCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleSocketAddrCondition, DeliveryRuleSocketAddrConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleSocketAddrCondition runs a test to see if a specific instance of DeliveryRuleSocketAddrCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleSocketAddrCondition(subject DeliveryRuleSocketAddrCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleSocketAddrCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleSocketAddrCondition instances for property testing - lazily instantiated by
// DeliveryRuleSocketAddrConditionGenerator()
var deliveryRuleSocketAddrConditionGenerator gopter.Gen

// DeliveryRuleSocketAddrConditionGenerator returns a generator of DeliveryRuleSocketAddrCondition instances for property testing.
// We first initialize deliveryRuleSocketAddrConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleSocketAddrConditionGenerator() gopter.Gen {
	if deliveryRuleSocketAddrConditionGenerator != nil {
		return deliveryRuleSocketAddrConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition(generators)
	deliveryRuleSocketAddrConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSocketAddrCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrCondition(generators)
	deliveryRuleSocketAddrConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSocketAddrCondition{}), generators)

	return deliveryRuleSocketAddrConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleSocketAddrCondition_Name_SocketAddr)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(SocketAddrMatchConditionParametersGenerator())
}

func Test_DeliveryRuleSocketAddrCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleSocketAddrCondition_STATUS to DeliveryRuleSocketAddrCondition_STATUS via AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS & AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleSocketAddrCondition_STATUS, DeliveryRuleSocketAddrCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleSocketAddrCondition_STATUS tests if a specific instance of DeliveryRuleSocketAddrCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleSocketAddrCondition_STATUS(subject DeliveryRuleSocketAddrCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleSocketAddrCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleSocketAddrCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleSocketAddrCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleSocketAddrCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleSocketAddrCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleSocketAddrCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleSocketAddrCondition_STATUS, DeliveryRuleSocketAddrCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleSocketAddrCondition_STATUS runs a test to see if a specific instance of DeliveryRuleSocketAddrCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleSocketAddrCondition_STATUS(subject DeliveryRuleSocketAddrCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleSocketAddrCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleSocketAddrCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleSocketAddrCondition_STATUSGenerator()
var deliveryRuleSocketAddrCondition_STATUSGenerator gopter.Gen

// DeliveryRuleSocketAddrCondition_STATUSGenerator returns a generator of DeliveryRuleSocketAddrCondition_STATUS instances for property testing.
// We first initialize deliveryRuleSocketAddrCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleSocketAddrCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleSocketAddrCondition_STATUSGenerator != nil {
		return deliveryRuleSocketAddrCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition_STATUS(generators)
	deliveryRuleSocketAddrCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSocketAddrCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrCondition_STATUS(generators)
	deliveryRuleSocketAddrCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSocketAddrCondition_STATUS{}), generators)

	return deliveryRuleSocketAddrCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleSocketAddrCondition_Name_STATUS_SocketAddr)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(SocketAddrMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleSslProtocolCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleSslProtocolCondition to DeliveryRuleSslProtocolCondition via AssignProperties_To_DeliveryRuleSslProtocolCondition & AssignProperties_From_DeliveryRuleSslProtocolCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleSslProtocolCondition, DeliveryRuleSslProtocolConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleSslProtocolCondition tests if a specific instance of DeliveryRuleSslProtocolCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleSslProtocolCondition(subject DeliveryRuleSslProtocolCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleSslProtocolCondition
	err := copied.AssignProperties_To_DeliveryRuleSslProtocolCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleSslProtocolCondition
	err = actual.AssignProperties_From_DeliveryRuleSslProtocolCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleSslProtocolCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleSslProtocolCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleSslProtocolCondition, DeliveryRuleSslProtocolConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleSslProtocolCondition runs a test to see if a specific instance of DeliveryRuleSslProtocolCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleSslProtocolCondition(subject DeliveryRuleSslProtocolCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleSslProtocolCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleSslProtocolCondition instances for property testing - lazily instantiated by
// DeliveryRuleSslProtocolConditionGenerator()
var deliveryRuleSslProtocolConditionGenerator gopter.Gen

// DeliveryRuleSslProtocolConditionGenerator returns a generator of DeliveryRuleSslProtocolCondition instances for property testing.
// We first initialize deliveryRuleSslProtocolConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleSslProtocolConditionGenerator() gopter.Gen {
	if deliveryRuleSslProtocolConditionGenerator != nil {
		return deliveryRuleSslProtocolConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition(generators)
	deliveryRuleSslProtocolConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSslProtocolCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolCondition(generators)
	deliveryRuleSslProtocolConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSslProtocolCondition{}), generators)

	return deliveryRuleSslProtocolConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleSslProtocolCondition_Name_SslProtocol)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(SslProtocolMatchConditionParametersGenerator())
}

func Test_DeliveryRuleSslProtocolCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleSslProtocolCondition_STATUS to DeliveryRuleSslProtocolCondition_STATUS via AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS & AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleSslProtocolCondition_STATUS, DeliveryRuleSslProtocolCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleSslProtocolCondition_STATUS tests if a specific instance of DeliveryRuleSslProtocolCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleSslProtocolCondition_STATUS(subject DeliveryRuleSslProtocolCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleSslProtocolCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleSslProtocolCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleSslProtocolCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleSslProtocolCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleSslProtocolCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleSslProtocolCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleSslProtocolCondition_STATUS, DeliveryRuleSslProtocolCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleSslProtocolCondition_STATUS runs a test to see if a specific instance of DeliveryRuleSslProtocolCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleSslProtocolCondition_STATUS(subject DeliveryRuleSslProtocolCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleSslProtocolCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleSslProtocolCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleSslProtocolCondition_STATUSGenerator()
var deliveryRuleSslProtocolCondition_STATUSGenerator gopter.Gen

// DeliveryRuleSslProtocolCondition_STATUSGenerator returns a generator of DeliveryRuleSslProtocolCondition_STATUS instances for property testing.
// We first initialize deliveryRuleSslProtocolCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleSslProtocolCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleSslProtocolCondition_STATUSGenerator != nil {
		return deliveryRuleSslProtocolCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition_STATUS(generators)
	deliveryRuleSslProtocolCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSslProtocolCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolCondition_STATUS(generators)
	deliveryRuleSslProtocolCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSslProtocolCondition_STATUS{}), generators)

	return deliveryRuleSslProtocolCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleSslProtocolCondition_Name_STATUS_SslProtocol)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(SslProtocolMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleUrlFileExtensionCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleUrlFileExtensionCondition to DeliveryRuleUrlFileExtensionCondition via AssignProperties_To_DeliveryRuleUrlFileExtensionCondition & AssignProperties_From_DeliveryRuleUrlFileExtensionCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleUrlFileExtensionCondition, DeliveryRuleUrlFileExtensionConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleUrlFileExtensionCondition tests if a specific instance of DeliveryRuleUrlFileExtensionCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleUrlFileExtensionCondition(subject DeliveryRuleUrlFileExtensionCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleUrlFileExtensionCondition
	err := copied.AssignProperties_To_DeliveryRuleUrlFileExtensionCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleUrlFileExtensionCondition
	err = actual.AssignProperties_From_DeliveryRuleUrlFileExtensionCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleUrlFileExtensionCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlFileExtensionCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlFileExtensionCondition, DeliveryRuleUrlFileExtensionConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlFileExtensionCondition runs a test to see if a specific instance of DeliveryRuleUrlFileExtensionCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlFileExtensionCondition(subject DeliveryRuleUrlFileExtensionCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlFileExtensionCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlFileExtensionCondition instances for property testing - lazily instantiated by
// DeliveryRuleUrlFileExtensionConditionGenerator()
var deliveryRuleUrlFileExtensionConditionGenerator gopter.Gen

// DeliveryRuleUrlFileExtensionConditionGenerator returns a generator of DeliveryRuleUrlFileExtensionCondition instances for property testing.
// We first initialize deliveryRuleUrlFileExtensionConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlFileExtensionConditionGenerator() gopter.Gen {
	if deliveryRuleUrlFileExtensionConditionGenerator != nil {
		return deliveryRuleUrlFileExtensionConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition(generators)
	deliveryRuleUrlFileExtensionConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileExtensionCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition(generators)
	deliveryRuleUrlFileExtensionConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileExtensionCondition{}), generators)

	return deliveryRuleUrlFileExtensionConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlFileExtensionCondition_Name_UrlFileExtension)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlFileExtensionMatchConditionParametersGenerator())
}

func Test_DeliveryRuleUrlFileExtensionCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleUrlFileExtensionCondition_STATUS to DeliveryRuleUrlFileExtensionCondition_STATUS via AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS & AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleUrlFileExtensionCondition_STATUS, DeliveryRuleUrlFileExtensionCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleUrlFileExtensionCondition_STATUS tests if a specific instance of DeliveryRuleUrlFileExtensionCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleUrlFileExtensionCondition_STATUS(subject DeliveryRuleUrlFileExtensionCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleUrlFileExtensionCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleUrlFileExtensionCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleUrlFileExtensionCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleUrlFileExtensionCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleUrlFileExtensionCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlFileExtensionCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlFileExtensionCondition_STATUS, DeliveryRuleUrlFileExtensionCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlFileExtensionCondition_STATUS runs a test to see if a specific instance of DeliveryRuleUrlFileExtensionCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlFileExtensionCondition_STATUS(subject DeliveryRuleUrlFileExtensionCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlFileExtensionCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlFileExtensionCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleUrlFileExtensionCondition_STATUSGenerator()
var deliveryRuleUrlFileExtensionCondition_STATUSGenerator gopter.Gen

// DeliveryRuleUrlFileExtensionCondition_STATUSGenerator returns a generator of DeliveryRuleUrlFileExtensionCondition_STATUS instances for property testing.
// We first initialize deliveryRuleUrlFileExtensionCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlFileExtensionCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleUrlFileExtensionCondition_STATUSGenerator != nil {
		return deliveryRuleUrlFileExtensionCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition_STATUS(generators)
	deliveryRuleUrlFileExtensionCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileExtensionCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition_STATUS(generators)
	deliveryRuleUrlFileExtensionCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileExtensionCondition_STATUS{}), generators)

	return deliveryRuleUrlFileExtensionCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlFileExtensionCondition_Name_STATUS_UrlFileExtension)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlFileExtensionMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleUrlFileNameCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleUrlFileNameCondition to DeliveryRuleUrlFileNameCondition via AssignProperties_To_DeliveryRuleUrlFileNameCondition & AssignProperties_From_DeliveryRuleUrlFileNameCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleUrlFileNameCondition, DeliveryRuleUrlFileNameConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleUrlFileNameCondition tests if a specific instance of DeliveryRuleUrlFileNameCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleUrlFileNameCondition(subject DeliveryRuleUrlFileNameCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleUrlFileNameCondition
	err := copied.AssignProperties_To_DeliveryRuleUrlFileNameCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleUrlFileNameCondition
	err = actual.AssignProperties_From_DeliveryRuleUrlFileNameCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleUrlFileNameCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlFileNameCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlFileNameCondition, DeliveryRuleUrlFileNameConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlFileNameCondition runs a test to see if a specific instance of DeliveryRuleUrlFileNameCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlFileNameCondition(subject DeliveryRuleUrlFileNameCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlFileNameCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlFileNameCondition instances for property testing - lazily instantiated by
// DeliveryRuleUrlFileNameConditionGenerator()
var deliveryRuleUrlFileNameConditionGenerator gopter.Gen

// DeliveryRuleUrlFileNameConditionGenerator returns a generator of DeliveryRuleUrlFileNameCondition instances for property testing.
// We first initialize deliveryRuleUrlFileNameConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlFileNameConditionGenerator() gopter.Gen {
	if deliveryRuleUrlFileNameConditionGenerator != nil {
		return deliveryRuleUrlFileNameConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition(generators)
	deliveryRuleUrlFileNameConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileNameCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameCondition(generators)
	deliveryRuleUrlFileNameConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileNameCondition{}), generators)

	return deliveryRuleUrlFileNameConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlFileNameCondition_Name_UrlFileName)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlFileNameMatchConditionParametersGenerator())
}

func Test_DeliveryRuleUrlFileNameCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleUrlFileNameCondition_STATUS to DeliveryRuleUrlFileNameCondition_STATUS via AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS & AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleUrlFileNameCondition_STATUS, DeliveryRuleUrlFileNameCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleUrlFileNameCondition_STATUS tests if a specific instance of DeliveryRuleUrlFileNameCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleUrlFileNameCondition_STATUS(subject DeliveryRuleUrlFileNameCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleUrlFileNameCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleUrlFileNameCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleUrlFileNameCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleUrlFileNameCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleUrlFileNameCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlFileNameCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlFileNameCondition_STATUS, DeliveryRuleUrlFileNameCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlFileNameCondition_STATUS runs a test to see if a specific instance of DeliveryRuleUrlFileNameCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlFileNameCondition_STATUS(subject DeliveryRuleUrlFileNameCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlFileNameCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlFileNameCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleUrlFileNameCondition_STATUSGenerator()
var deliveryRuleUrlFileNameCondition_STATUSGenerator gopter.Gen

// DeliveryRuleUrlFileNameCondition_STATUSGenerator returns a generator of DeliveryRuleUrlFileNameCondition_STATUS instances for property testing.
// We first initialize deliveryRuleUrlFileNameCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlFileNameCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleUrlFileNameCondition_STATUSGenerator != nil {
		return deliveryRuleUrlFileNameCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition_STATUS(generators)
	deliveryRuleUrlFileNameCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileNameCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameCondition_STATUS(generators)
	deliveryRuleUrlFileNameCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileNameCondition_STATUS{}), generators)

	return deliveryRuleUrlFileNameCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlFileNameCondition_Name_STATUS_UrlFileName)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlFileNameMatchConditionParameters_STATUSGenerator())
}

func Test_DeliveryRuleUrlPathCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleUrlPathCondition to DeliveryRuleUrlPathCondition via AssignProperties_To_DeliveryRuleUrlPathCondition & AssignProperties_From_DeliveryRuleUrlPathCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleUrlPathCondition, DeliveryRuleUrlPathConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleUrlPathCondition tests if a specific instance of DeliveryRuleUrlPathCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleUrlPathCondition(subject DeliveryRuleUrlPathCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleUrlPathCondition
	err := copied.AssignProperties_To_DeliveryRuleUrlPathCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleUrlPathCondition
	err = actual.AssignProperties_From_DeliveryRuleUrlPathCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleUrlPathCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlPathCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlPathCondition, DeliveryRuleUrlPathConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlPathCondition runs a test to see if a specific instance of DeliveryRuleUrlPathCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlPathCondition(subject DeliveryRuleUrlPathCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlPathCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlPathCondition instances for property testing - lazily instantiated by
// DeliveryRuleUrlPathConditionGenerator()
var deliveryRuleUrlPathConditionGenerator gopter.Gen

// DeliveryRuleUrlPathConditionGenerator returns a generator of DeliveryRuleUrlPathCondition instances for property testing.
// We first initialize deliveryRuleUrlPathConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlPathConditionGenerator() gopter.Gen {
	if deliveryRuleUrlPathConditionGenerator != nil {
		return deliveryRuleUrlPathConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition(generators)
	deliveryRuleUrlPathConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlPathCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathCondition(generators)
	deliveryRuleUrlPathConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlPathCondition{}), generators)

	return deliveryRuleUrlPathConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlPathCondition_Name_UrlPath)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlPathMatchConditionParametersGenerator())
}

func Test_DeliveryRuleUrlPathCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleUrlPathCondition_STATUS to DeliveryRuleUrlPathCondition_STATUS via AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS & AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleUrlPathCondition_STATUS, DeliveryRuleUrlPathCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleUrlPathCondition_STATUS tests if a specific instance of DeliveryRuleUrlPathCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleUrlPathCondition_STATUS(subject DeliveryRuleUrlPathCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleUrlPathCondition_STATUS
	err := copied.AssignProperties_To_DeliveryRuleUrlPathCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleUrlPathCondition_STATUS
	err = actual.AssignProperties_From_DeliveryRuleUrlPathCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleUrlPathCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlPathCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlPathCondition_STATUS, DeliveryRuleUrlPathCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlPathCondition_STATUS runs a test to see if a specific instance of DeliveryRuleUrlPathCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlPathCondition_STATUS(subject DeliveryRuleUrlPathCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlPathCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlPathCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleUrlPathCondition_STATUSGenerator()
var deliveryRuleUrlPathCondition_STATUSGenerator gopter.Gen

// DeliveryRuleUrlPathCondition_STATUSGenerator returns a generator of DeliveryRuleUrlPathCondition_STATUS instances for property testing.
// We first initialize deliveryRuleUrlPathCondition_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlPathCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleUrlPathCondition_STATUSGenerator != nil {
		return deliveryRuleUrlPathCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition_STATUS(generators)
	deliveryRuleUrlPathCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlPathCondition_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathCondition_STATUS(generators)
	deliveryRuleUrlPathCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlPathCondition_STATUS{}), generators)

	return deliveryRuleUrlPathCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlPathCondition_Name_STATUS_UrlPath)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathCondition_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlPathMatchConditionParameters_STATUSGenerator())
}

func Test_OriginGroupOverrideAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OriginGroupOverrideAction to OriginGroupOverrideAction via AssignProperties_To_OriginGroupOverrideAction & AssignProperties_From_OriginGroupOverrideAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForOriginGroupOverrideAction, OriginGroupOverrideActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOriginGroupOverrideAction tests if a specific instance of OriginGroupOverrideAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForOriginGroupOverrideAction(subject OriginGroupOverrideAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.OriginGroupOverrideAction
	err := copied.AssignProperties_To_OriginGroupOverrideAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OriginGroupOverrideAction
	err = actual.AssignProperties_From_OriginGroupOverrideAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OriginGroupOverrideAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverrideAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverrideAction, OriginGroupOverrideActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverrideAction runs a test to see if a specific instance of OriginGroupOverrideAction round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverrideAction(subject OriginGroupOverrideAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverrideAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverrideAction instances for property testing - lazily instantiated by
// OriginGroupOverrideActionGenerator()
var originGroupOverrideActionGenerator gopter.Gen

// OriginGroupOverrideActionGenerator returns a generator of OriginGroupOverrideAction instances for property testing.
// We first initialize originGroupOverrideActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideActionGenerator() gopter.Gen {
	if originGroupOverrideActionGenerator != nil {
		return originGroupOverrideActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideAction(generators)
	originGroupOverrideActionGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideAction(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverrideAction(generators)
	originGroupOverrideActionGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideAction{}), generators)

	return originGroupOverrideActionGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverrideAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverrideAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(OriginGroupOverrideAction_Name_OriginGroupOverride)
}

// AddRelatedPropertyGeneratorsForOriginGroupOverrideAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverrideAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(OriginGroupOverrideActionParametersGenerator())
}

func Test_OriginGroupOverrideAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OriginGroupOverrideAction_STATUS to OriginGroupOverrideAction_STATUS via AssignProperties_To_OriginGroupOverrideAction_STATUS & AssignProperties_From_OriginGroupOverrideAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForOriginGroupOverrideAction_STATUS, OriginGroupOverrideAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOriginGroupOverrideAction_STATUS tests if a specific instance of OriginGroupOverrideAction_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForOriginGroupOverrideAction_STATUS(subject OriginGroupOverrideAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.OriginGroupOverrideAction_STATUS
	err := copied.AssignProperties_To_OriginGroupOverrideAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OriginGroupOverrideAction_STATUS
	err = actual.AssignProperties_From_OriginGroupOverrideAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OriginGroupOverrideAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverrideAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverrideAction_STATUS, OriginGroupOverrideAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverrideAction_STATUS runs a test to see if a specific instance of OriginGroupOverrideAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverrideAction_STATUS(subject OriginGroupOverrideAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverrideAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverrideAction_STATUS instances for property testing - lazily instantiated by
// OriginGroupOverrideAction_STATUSGenerator()
var originGroupOverrideAction_STATUSGenerator gopter.Gen

// OriginGroupOverrideAction_STATUSGenerator returns a generator of OriginGroupOverrideAction_STATUS instances for property testing.
// We first initialize originGroupOverrideAction_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideAction_STATUSGenerator() gopter.Gen {
	if originGroupOverrideAction_STATUSGenerator != nil {
		return originGroupOverrideAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideAction_STATUS(generators)
	originGroupOverrideAction_STATUSGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideAction_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideAction_STATUS(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverrideAction_STATUS(generators)
	originGroupOverrideAction_STATUSGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideAction_STATUS{}), generators)

	return originGroupOverrideAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverrideAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverrideAction_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(OriginGroupOverrideAction_Name_STATUS_OriginGroupOverride)
}

// AddRelatedPropertyGeneratorsForOriginGroupOverrideAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverrideAction_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(OriginGroupOverrideActionParameters_STATUSGenerator())
}

func Test_UrlRedirectAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlRedirectAction to UrlRedirectAction via AssignProperties_To_UrlRedirectAction & AssignProperties_From_UrlRedirectAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlRedirectAction, UrlRedirectActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlRedirectAction tests if a specific instance of UrlRedirectAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlRedirectAction(subject UrlRedirectAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlRedirectAction
	err := copied.AssignProperties_To_UrlRedirectAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlRedirectAction
	err = actual.AssignProperties_From_UrlRedirectAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlRedirectAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRedirectAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRedirectAction, UrlRedirectActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRedirectAction runs a test to see if a specific instance of UrlRedirectAction round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRedirectAction(subject UrlRedirectAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRedirectAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRedirectAction instances for property testing - lazily instantiated by UrlRedirectActionGenerator()
var urlRedirectActionGenerator gopter.Gen

// UrlRedirectActionGenerator returns a generator of UrlRedirectAction instances for property testing.
// We first initialize urlRedirectActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlRedirectActionGenerator() gopter.Gen {
	if urlRedirectActionGenerator != nil {
		return urlRedirectActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectAction(generators)
	urlRedirectActionGenerator = gen.Struct(reflect.TypeOf(UrlRedirectAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectAction(generators)
	AddRelatedPropertyGeneratorsForUrlRedirectAction(generators)
	urlRedirectActionGenerator = gen.Struct(reflect.TypeOf(UrlRedirectAction{}), generators)

	return urlRedirectActionGenerator
}

// AddIndependentPropertyGeneratorsForUrlRedirectAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRedirectAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlRedirectAction_Name_UrlRedirect)
}

// AddRelatedPropertyGeneratorsForUrlRedirectAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlRedirectAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlRedirectActionParametersGenerator())
}

func Test_UrlRedirectAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlRedirectAction_STATUS to UrlRedirectAction_STATUS via AssignProperties_To_UrlRedirectAction_STATUS & AssignProperties_From_UrlRedirectAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlRedirectAction_STATUS, UrlRedirectAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlRedirectAction_STATUS tests if a specific instance of UrlRedirectAction_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlRedirectAction_STATUS(subject UrlRedirectAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlRedirectAction_STATUS
	err := copied.AssignProperties_To_UrlRedirectAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlRedirectAction_STATUS
	err = actual.AssignProperties_From_UrlRedirectAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlRedirectAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRedirectAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRedirectAction_STATUS, UrlRedirectAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRedirectAction_STATUS runs a test to see if a specific instance of UrlRedirectAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRedirectAction_STATUS(subject UrlRedirectAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRedirectAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRedirectAction_STATUS instances for property testing - lazily instantiated by
// UrlRedirectAction_STATUSGenerator()
var urlRedirectAction_STATUSGenerator gopter.Gen

// UrlRedirectAction_STATUSGenerator returns a generator of UrlRedirectAction_STATUS instances for property testing.
// We first initialize urlRedirectAction_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlRedirectAction_STATUSGenerator() gopter.Gen {
	if urlRedirectAction_STATUSGenerator != nil {
		return urlRedirectAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectAction_STATUS(generators)
	urlRedirectAction_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlRedirectAction_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectAction_STATUS(generators)
	AddRelatedPropertyGeneratorsForUrlRedirectAction_STATUS(generators)
	urlRedirectAction_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlRedirectAction_STATUS{}), generators)

	return urlRedirectAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUrlRedirectAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRedirectAction_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlRedirectAction_Name_STATUS_UrlRedirect)
}

// AddRelatedPropertyGeneratorsForUrlRedirectAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlRedirectAction_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlRedirectActionParameters_STATUSGenerator())
}

func Test_UrlRewriteAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlRewriteAction to UrlRewriteAction via AssignProperties_To_UrlRewriteAction & AssignProperties_From_UrlRewriteAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlRewriteAction, UrlRewriteActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlRewriteAction tests if a specific instance of UrlRewriteAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlRewriteAction(subject UrlRewriteAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlRewriteAction
	err := copied.AssignProperties_To_UrlRewriteAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlRewriteAction
	err = actual.AssignProperties_From_UrlRewriteAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlRewriteAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRewriteAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRewriteAction, UrlRewriteActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRewriteAction runs a test to see if a specific instance of UrlRewriteAction round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRewriteAction(subject UrlRewriteAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRewriteAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRewriteAction instances for property testing - lazily instantiated by UrlRewriteActionGenerator()
var urlRewriteActionGenerator gopter.Gen

// UrlRewriteActionGenerator returns a generator of UrlRewriteAction instances for property testing.
// We first initialize urlRewriteActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlRewriteActionGenerator() gopter.Gen {
	if urlRewriteActionGenerator != nil {
		return urlRewriteActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteAction(generators)
	urlRewriteActionGenerator = gen.Struct(reflect.TypeOf(UrlRewriteAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteAction(generators)
	AddRelatedPropertyGeneratorsForUrlRewriteAction(generators)
	urlRewriteActionGenerator = gen.Struct(reflect.TypeOf(UrlRewriteAction{}), generators)

	return urlRewriteActionGenerator
}

// AddIndependentPropertyGeneratorsForUrlRewriteAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRewriteAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlRewriteAction_Name_UrlRewrite)
}

// AddRelatedPropertyGeneratorsForUrlRewriteAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlRewriteAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlRewriteActionParametersGenerator())
}

func Test_UrlRewriteAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlRewriteAction_STATUS to UrlRewriteAction_STATUS via AssignProperties_To_UrlRewriteAction_STATUS & AssignProperties_From_UrlRewriteAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlRewriteAction_STATUS, UrlRewriteAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlRewriteAction_STATUS tests if a specific instance of UrlRewriteAction_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlRewriteAction_STATUS(subject UrlRewriteAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlRewriteAction_STATUS
	err := copied.AssignProperties_To_UrlRewriteAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlRewriteAction_STATUS
	err = actual.AssignProperties_From_UrlRewriteAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlRewriteAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRewriteAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRewriteAction_STATUS, UrlRewriteAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRewriteAction_STATUS runs a test to see if a specific instance of UrlRewriteAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRewriteAction_STATUS(subject UrlRewriteAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRewriteAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRewriteAction_STATUS instances for property testing - lazily instantiated by
// UrlRewriteAction_STATUSGenerator()
var urlRewriteAction_STATUSGenerator gopter.Gen

// UrlRewriteAction_STATUSGenerator returns a generator of UrlRewriteAction_STATUS instances for property testing.
// We first initialize urlRewriteAction_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlRewriteAction_STATUSGenerator() gopter.Gen {
	if urlRewriteAction_STATUSGenerator != nil {
		return urlRewriteAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteAction_STATUS(generators)
	urlRewriteAction_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlRewriteAction_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteAction_STATUS(generators)
	AddRelatedPropertyGeneratorsForUrlRewriteAction_STATUS(generators)
	urlRewriteAction_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlRewriteAction_STATUS{}), generators)

	return urlRewriteAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUrlRewriteAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRewriteAction_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlRewriteAction_Name_STATUS_UrlRewrite)
}

// AddRelatedPropertyGeneratorsForUrlRewriteAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlRewriteAction_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlRewriteActionParameters_STATUSGenerator())
}

func Test_UrlSigningAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningAction to UrlSigningAction via AssignProperties_To_UrlSigningAction & AssignProperties_From_UrlSigningAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningAction, UrlSigningActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningAction tests if a specific instance of UrlSigningAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningAction(subject UrlSigningAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningAction
	err := copied.AssignProperties_To_UrlSigningAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningAction
	err = actual.AssignProperties_From_UrlSigningAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningAction, UrlSigningActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningAction runs a test to see if a specific instance of UrlSigningAction round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningAction(subject UrlSigningAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningAction instances for property testing - lazily instantiated by UrlSigningActionGenerator()
var urlSigningActionGenerator gopter.Gen

// UrlSigningActionGenerator returns a generator of UrlSigningAction instances for property testing.
// We first initialize urlSigningActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningActionGenerator() gopter.Gen {
	if urlSigningActionGenerator != nil {
		return urlSigningActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningAction(generators)
	urlSigningActionGenerator = gen.Struct(reflect.TypeOf(UrlSigningAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningAction(generators)
	AddRelatedPropertyGeneratorsForUrlSigningAction(generators)
	urlSigningActionGenerator = gen.Struct(reflect.TypeOf(UrlSigningAction{}), generators)

	return urlSigningActionGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlSigningAction_Name_UrlSigning)
}

// AddRelatedPropertyGeneratorsForUrlSigningAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlSigningActionParametersGenerator())
}

func Test_UrlSigningAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningAction_STATUS to UrlSigningAction_STATUS via AssignProperties_To_UrlSigningAction_STATUS & AssignProperties_From_UrlSigningAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningAction_STATUS, UrlSigningAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningAction_STATUS tests if a specific instance of UrlSigningAction_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningAction_STATUS(subject UrlSigningAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningAction_STATUS
	err := copied.AssignProperties_To_UrlSigningAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningAction_STATUS
	err = actual.AssignProperties_From_UrlSigningAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningAction_STATUS, UrlSigningAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningAction_STATUS runs a test to see if a specific instance of UrlSigningAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningAction_STATUS(subject UrlSigningAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningAction_STATUS instances for property testing - lazily instantiated by
// UrlSigningAction_STATUSGenerator()
var urlSigningAction_STATUSGenerator gopter.Gen

// UrlSigningAction_STATUSGenerator returns a generator of UrlSigningAction_STATUS instances for property testing.
// We first initialize urlSigningAction_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningAction_STATUSGenerator() gopter.Gen {
	if urlSigningAction_STATUSGenerator != nil {
		return urlSigningAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningAction_STATUS(generators)
	urlSigningAction_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlSigningAction_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningAction_STATUS(generators)
	AddRelatedPropertyGeneratorsForUrlSigningAction_STATUS(generators)
	urlSigningAction_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlSigningAction_STATUS{}), generators)

	return urlSigningAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningAction_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlSigningAction_Name_STATUS_UrlSigning)
}

// AddRelatedPropertyGeneratorsForUrlSigningAction_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningAction_STATUS(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlSigningActionParameters_STATUSGenerator())
}

func Test_CacheExpirationActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CacheExpirationActionParameters to CacheExpirationActionParameters via AssignProperties_To_CacheExpirationActionParameters & AssignProperties_From_CacheExpirationActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForCacheExpirationActionParameters, CacheExpirationActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCacheExpirationActionParameters tests if a specific instance of CacheExpirationActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCacheExpirationActionParameters(subject CacheExpirationActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CacheExpirationActionParameters
	err := copied.AssignProperties_To_CacheExpirationActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CacheExpirationActionParameters
	err = actual.AssignProperties_From_CacheExpirationActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CacheExpirationActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheExpirationActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheExpirationActionParameters, CacheExpirationActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheExpirationActionParameters runs a test to see if a specific instance of CacheExpirationActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheExpirationActionParameters(subject CacheExpirationActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheExpirationActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheExpirationActionParameters instances for property testing - lazily instantiated by
// CacheExpirationActionParametersGenerator()
var cacheExpirationActionParametersGenerator gopter.Gen

// CacheExpirationActionParametersGenerator returns a generator of CacheExpirationActionParameters instances for property testing.
func CacheExpirationActionParametersGenerator() gopter.Gen {
	if cacheExpirationActionParametersGenerator != nil {
		return cacheExpirationActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheExpirationActionParameters(generators)
	cacheExpirationActionParametersGenerator = gen.Struct(reflect.TypeOf(CacheExpirationActionParameters{}), generators)

	return cacheExpirationActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForCacheExpirationActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheExpirationActionParameters(gens map[string]gopter.Gen) {
	gens["CacheBehavior"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParameters_CacheBehavior_BypassCache, CacheExpirationActionParameters_CacheBehavior_Override, CacheExpirationActionParameters_CacheBehavior_SetIfMissing))
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["CacheType"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParameters_CacheType_All))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParameters_TypeName_DeliveryRuleCacheExpirationActionParameters))
}

func Test_CacheExpirationActionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CacheExpirationActionParameters_STATUS to CacheExpirationActionParameters_STATUS via AssignProperties_To_CacheExpirationActionParameters_STATUS & AssignProperties_From_CacheExpirationActionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCacheExpirationActionParameters_STATUS, CacheExpirationActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCacheExpirationActionParameters_STATUS tests if a specific instance of CacheExpirationActionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCacheExpirationActionParameters_STATUS(subject CacheExpirationActionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CacheExpirationActionParameters_STATUS
	err := copied.AssignProperties_To_CacheExpirationActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CacheExpirationActionParameters_STATUS
	err = actual.AssignProperties_From_CacheExpirationActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CacheExpirationActionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheExpirationActionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheExpirationActionParameters_STATUS, CacheExpirationActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheExpirationActionParameters_STATUS runs a test to see if a specific instance of CacheExpirationActionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheExpirationActionParameters_STATUS(subject CacheExpirationActionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheExpirationActionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheExpirationActionParameters_STATUS instances for property testing - lazily instantiated by
// CacheExpirationActionParameters_STATUSGenerator()
var cacheExpirationActionParameters_STATUSGenerator gopter.Gen

// CacheExpirationActionParameters_STATUSGenerator returns a generator of CacheExpirationActionParameters_STATUS instances for property testing.
func CacheExpirationActionParameters_STATUSGenerator() gopter.Gen {
	if cacheExpirationActionParameters_STATUSGenerator != nil {
		return cacheExpirationActionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheExpirationActionParameters_STATUS(generators)
	cacheExpirationActionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(CacheExpirationActionParameters_STATUS{}), generators)

	return cacheExpirationActionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCacheExpirationActionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheExpirationActionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["CacheBehavior"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParameters_CacheBehavior_STATUS_BypassCache, CacheExpirationActionParameters_CacheBehavior_STATUS_Override, CacheExpirationActionParameters_CacheBehavior_STATUS_SetIfMissing))
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["CacheType"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParameters_CacheType_STATUS_All))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParameters_TypeName_STATUS_DeliveryRuleCacheExpirationActionParameters))
}

func Test_CacheKeyQueryStringActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CacheKeyQueryStringActionParameters to CacheKeyQueryStringActionParameters via AssignProperties_To_CacheKeyQueryStringActionParameters & AssignProperties_From_CacheKeyQueryStringActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForCacheKeyQueryStringActionParameters, CacheKeyQueryStringActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCacheKeyQueryStringActionParameters tests if a specific instance of CacheKeyQueryStringActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCacheKeyQueryStringActionParameters(subject CacheKeyQueryStringActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CacheKeyQueryStringActionParameters
	err := copied.AssignProperties_To_CacheKeyQueryStringActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CacheKeyQueryStringActionParameters
	err = actual.AssignProperties_From_CacheKeyQueryStringActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CacheKeyQueryStringActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheKeyQueryStringActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheKeyQueryStringActionParameters, CacheKeyQueryStringActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheKeyQueryStringActionParameters runs a test to see if a specific instance of CacheKeyQueryStringActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheKeyQueryStringActionParameters(subject CacheKeyQueryStringActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheKeyQueryStringActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheKeyQueryStringActionParameters instances for property testing - lazily instantiated by
// CacheKeyQueryStringActionParametersGenerator()
var cacheKeyQueryStringActionParametersGenerator gopter.Gen

// CacheKeyQueryStringActionParametersGenerator returns a generator of CacheKeyQueryStringActionParameters instances for property testing.
func CacheKeyQueryStringActionParametersGenerator() gopter.Gen {
	if cacheKeyQueryStringActionParametersGenerator != nil {
		return cacheKeyQueryStringActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParameters(generators)
	cacheKeyQueryStringActionParametersGenerator = gen.Struct(reflect.TypeOf(CacheKeyQueryStringActionParameters{}), generators)

	return cacheKeyQueryStringActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParameters(gens map[string]gopter.Gen) {
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringBehavior"] = gen.PtrOf(gen.OneConstOf(
		CacheKeyQueryStringActionParameters_QueryStringBehavior_Exclude,
		CacheKeyQueryStringActionParameters_QueryStringBehavior_ExcludeAll,
		CacheKeyQueryStringActionParameters_QueryStringBehavior_Include,
		CacheKeyQueryStringActionParameters_QueryStringBehavior_IncludeAll))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CacheKeyQueryStringActionParameters_TypeName_DeliveryRuleCacheKeyQueryStringBehaviorActionParameters))
}

func Test_CacheKeyQueryStringActionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CacheKeyQueryStringActionParameters_STATUS to CacheKeyQueryStringActionParameters_STATUS via AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS & AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCacheKeyQueryStringActionParameters_STATUS, CacheKeyQueryStringActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCacheKeyQueryStringActionParameters_STATUS tests if a specific instance of CacheKeyQueryStringActionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCacheKeyQueryStringActionParameters_STATUS(subject CacheKeyQueryStringActionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CacheKeyQueryStringActionParameters_STATUS
	err := copied.AssignProperties_To_CacheKeyQueryStringActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CacheKeyQueryStringActionParameters_STATUS
	err = actual.AssignProperties_From_CacheKeyQueryStringActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CacheKeyQueryStringActionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheKeyQueryStringActionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheKeyQueryStringActionParameters_STATUS, CacheKeyQueryStringActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheKeyQueryStringActionParameters_STATUS runs a test to see if a specific instance of CacheKeyQueryStringActionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheKeyQueryStringActionParameters_STATUS(subject CacheKeyQueryStringActionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheKeyQueryStringActionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheKeyQueryStringActionParameters_STATUS instances for property testing - lazily instantiated by
// CacheKeyQueryStringActionParameters_STATUSGenerator()
var cacheKeyQueryStringActionParameters_STATUSGenerator gopter.Gen

// CacheKeyQueryStringActionParameters_STATUSGenerator returns a generator of CacheKeyQueryStringActionParameters_STATUS instances for property testing.
func CacheKeyQueryStringActionParameters_STATUSGenerator() gopter.Gen {
	if cacheKeyQueryStringActionParameters_STATUSGenerator != nil {
		return cacheKeyQueryStringActionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParameters_STATUS(generators)
	cacheKeyQueryStringActionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(CacheKeyQueryStringActionParameters_STATUS{}), generators)

	return cacheKeyQueryStringActionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringBehavior"] = gen.PtrOf(gen.OneConstOf(
		CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS_Exclude,
		CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS_ExcludeAll,
		CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS_Include,
		CacheKeyQueryStringActionParameters_QueryStringBehavior_STATUS_IncludeAll))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CacheKeyQueryStringActionParameters_TypeName_STATUS_DeliveryRuleCacheKeyQueryStringBehaviorActionParameters))
}

func Test_ClientPortMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ClientPortMatchConditionParameters to ClientPortMatchConditionParameters via AssignProperties_To_ClientPortMatchConditionParameters & AssignProperties_From_ClientPortMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForClientPortMatchConditionParameters, ClientPortMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForClientPortMatchConditionParameters tests if a specific instance of ClientPortMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForClientPortMatchConditionParameters(subject ClientPortMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ClientPortMatchConditionParameters
	err := copied.AssignProperties_To_ClientPortMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ClientPortMatchConditionParameters
	err = actual.AssignProperties_From_ClientPortMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ClientPortMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClientPortMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClientPortMatchConditionParameters, ClientPortMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClientPortMatchConditionParameters runs a test to see if a specific instance of ClientPortMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForClientPortMatchConditionParameters(subject ClientPortMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClientPortMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClientPortMatchConditionParameters instances for property testing - lazily instantiated by
// ClientPortMatchConditionParametersGenerator()
var clientPortMatchConditionParametersGenerator gopter.Gen

// ClientPortMatchConditionParametersGenerator returns a generator of ClientPortMatchConditionParameters instances for property testing.
func ClientPortMatchConditionParametersGenerator() gopter.Gen {
	if clientPortMatchConditionParametersGenerator != nil {
		return clientPortMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClientPortMatchConditionParameters(generators)
	clientPortMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(ClientPortMatchConditionParameters{}), generators)

	return clientPortMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForClientPortMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClientPortMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		ClientPortMatchConditionParameters_Operator_Any,
		ClientPortMatchConditionParameters_Operator_BeginsWith,
		ClientPortMatchConditionParameters_Operator_Contains,
		ClientPortMatchConditionParameters_Operator_EndsWith,
		ClientPortMatchConditionParameters_Operator_Equal,
		ClientPortMatchConditionParameters_Operator_GreaterThan,
		ClientPortMatchConditionParameters_Operator_GreaterThanOrEqual,
		ClientPortMatchConditionParameters_Operator_LessThan,
		ClientPortMatchConditionParameters_Operator_LessThanOrEqual,
		ClientPortMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(ClientPortMatchConditionParameters_TypeName_DeliveryRuleClientPortConditionParameters))
}

func Test_ClientPortMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ClientPortMatchConditionParameters_STATUS to ClientPortMatchConditionParameters_STATUS via AssignProperties_To_ClientPortMatchConditionParameters_STATUS & AssignProperties_From_ClientPortMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForClientPortMatchConditionParameters_STATUS, ClientPortMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForClientPortMatchConditionParameters_STATUS tests if a specific instance of ClientPortMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForClientPortMatchConditionParameters_STATUS(subject ClientPortMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ClientPortMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_ClientPortMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ClientPortMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_ClientPortMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ClientPortMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClientPortMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClientPortMatchConditionParameters_STATUS, ClientPortMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClientPortMatchConditionParameters_STATUS runs a test to see if a specific instance of ClientPortMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForClientPortMatchConditionParameters_STATUS(subject ClientPortMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClientPortMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClientPortMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// ClientPortMatchConditionParameters_STATUSGenerator()
var clientPortMatchConditionParameters_STATUSGenerator gopter.Gen

// ClientPortMatchConditionParameters_STATUSGenerator returns a generator of ClientPortMatchConditionParameters_STATUS instances for property testing.
func ClientPortMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if clientPortMatchConditionParameters_STATUSGenerator != nil {
		return clientPortMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClientPortMatchConditionParameters_STATUS(generators)
	clientPortMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(ClientPortMatchConditionParameters_STATUS{}), generators)

	return clientPortMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForClientPortMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClientPortMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		ClientPortMatchConditionParameters_Operator_STATUS_Any,
		ClientPortMatchConditionParameters_Operator_STATUS_BeginsWith,
		ClientPortMatchConditionParameters_Operator_STATUS_Contains,
		ClientPortMatchConditionParameters_Operator_STATUS_EndsWith,
		ClientPortMatchConditionParameters_Operator_STATUS_Equal,
		ClientPortMatchConditionParameters_Operator_STATUS_GreaterThan,
		ClientPortMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
		ClientPortMatchConditionParameters_Operator_STATUS_LessThan,
		ClientPortMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
		ClientPortMatchConditionParameters_Operator_STATUS_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(ClientPortMatchConditionParameters_TypeName_STATUS_DeliveryRuleClientPortConditionParameters))
}

func Test_CookiesMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CookiesMatchConditionParameters to CookiesMatchConditionParameters via AssignProperties_To_CookiesMatchConditionParameters & AssignProperties_From_CookiesMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForCookiesMatchConditionParameters, CookiesMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCookiesMatchConditionParameters tests if a specific instance of CookiesMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCookiesMatchConditionParameters(subject CookiesMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CookiesMatchConditionParameters
	err := copied.AssignProperties_To_CookiesMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CookiesMatchConditionParameters
	err = actual.AssignProperties_From_CookiesMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CookiesMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CookiesMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCookiesMatchConditionParameters, CookiesMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCookiesMatchConditionParameters runs a test to see if a specific instance of CookiesMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForCookiesMatchConditionParameters(subject CookiesMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CookiesMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CookiesMatchConditionParameters instances for property testing - lazily instantiated by
// CookiesMatchConditionParametersGenerator()
var cookiesMatchConditionParametersGenerator gopter.Gen

// CookiesMatchConditionParametersGenerator returns a generator of CookiesMatchConditionParameters instances for property testing.
func CookiesMatchConditionParametersGenerator() gopter.Gen {
	if cookiesMatchConditionParametersGenerator != nil {
		return cookiesMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCookiesMatchConditionParameters(generators)
	cookiesMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(CookiesMatchConditionParameters{}), generators)

	return cookiesMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForCookiesMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCookiesMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		CookiesMatchConditionParameters_Operator_Any,
		CookiesMatchConditionParameters_Operator_BeginsWith,
		CookiesMatchConditionParameters_Operator_Contains,
		CookiesMatchConditionParameters_Operator_EndsWith,
		CookiesMatchConditionParameters_Operator_Equal,
		CookiesMatchConditionParameters_Operator_GreaterThan,
		CookiesMatchConditionParameters_Operator_GreaterThanOrEqual,
		CookiesMatchConditionParameters_Operator_LessThan,
		CookiesMatchConditionParameters_Operator_LessThanOrEqual,
		CookiesMatchConditionParameters_Operator_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CookiesMatchConditionParameters_TypeName_DeliveryRuleCookiesConditionParameters))
}

func Test_CookiesMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CookiesMatchConditionParameters_STATUS to CookiesMatchConditionParameters_STATUS via AssignProperties_To_CookiesMatchConditionParameters_STATUS & AssignProperties_From_CookiesMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCookiesMatchConditionParameters_STATUS, CookiesMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCookiesMatchConditionParameters_STATUS tests if a specific instance of CookiesMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCookiesMatchConditionParameters_STATUS(subject CookiesMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CookiesMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_CookiesMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CookiesMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_CookiesMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CookiesMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CookiesMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCookiesMatchConditionParameters_STATUS, CookiesMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCookiesMatchConditionParameters_STATUS runs a test to see if a specific instance of CookiesMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCookiesMatchConditionParameters_STATUS(subject CookiesMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CookiesMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CookiesMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// CookiesMatchConditionParameters_STATUSGenerator()
var cookiesMatchConditionParameters_STATUSGenerator gopter.Gen

// CookiesMatchConditionParameters_STATUSGenerator returns a generator of CookiesMatchConditionParameters_STATUS instances for property testing.
func CookiesMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if cookiesMatchConditionParameters_STATUSGenerator != nil {
		return cookiesMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCookiesMatchConditionParameters_STATUS(generators)
	cookiesMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(CookiesMatchConditionParameters_STATUS{}), generators)

	return cookiesMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCookiesMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCookiesMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		CookiesMatchConditionParameters_Operator_STATUS_Any,
		CookiesMatchConditionParameters_Operator_STATUS_BeginsWith,
		CookiesMatchConditionParameters_Operator_STATUS_Contains,
		CookiesMatchConditionParameters_Operator_STATUS_EndsWith,
		CookiesMatchConditionParameters_Operator_STATUS_Equal,
		CookiesMatchConditionParameters_Operator_STATUS_GreaterThan,
		CookiesMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
		CookiesMatchConditionParameters_Operator_STATUS_LessThan,
		CookiesMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
		CookiesMatchConditionParameters_Operator_STATUS_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CookiesMatchConditionParameters_TypeName_STATUS_DeliveryRuleCookiesConditionParameters))
}

func Test_HeaderActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HeaderActionParameters to HeaderActionParameters via AssignProperties_To_HeaderActionParameters & AssignProperties_From_HeaderActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForHeaderActionParameters, HeaderActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHeaderActionParameters tests if a specific instance of HeaderActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHeaderActionParameters(subject HeaderActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HeaderActionParameters
	err := copied.AssignProperties_To_HeaderActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HeaderActionParameters
	err = actual.AssignProperties_From_HeaderActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HeaderActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderActionParameters, HeaderActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderActionParameters runs a test to see if a specific instance of HeaderActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderActionParameters(subject HeaderActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderActionParameters instances for property testing - lazily instantiated by
// HeaderActionParametersGenerator()
var headerActionParametersGenerator gopter.Gen

// HeaderActionParametersGenerator returns a generator of HeaderActionParameters instances for property testing.
func HeaderActionParametersGenerator() gopter.Gen {
	if headerActionParametersGenerator != nil {
		return headerActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderActionParameters(generators)
	headerActionParametersGenerator = gen.Struct(reflect.TypeOf(HeaderActionParameters{}), generators)

	return headerActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForHeaderActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderActionParameters(gens map[string]gopter.Gen) {
	gens["HeaderAction"] = gen.PtrOf(gen.OneConstOf(HeaderActionParameters_HeaderAction_Append, HeaderActionParameters_HeaderAction_Delete, HeaderActionParameters_HeaderAction_Overwrite))
	gens["HeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HeaderActionParameters_TypeName_DeliveryRuleHeaderActionParameters))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_HeaderActionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HeaderActionParameters_STATUS to HeaderActionParameters_STATUS via AssignProperties_To_HeaderActionParameters_STATUS & AssignProperties_From_HeaderActionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHeaderActionParameters_STATUS, HeaderActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHeaderActionParameters_STATUS tests if a specific instance of HeaderActionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHeaderActionParameters_STATUS(subject HeaderActionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HeaderActionParameters_STATUS
	err := copied.AssignProperties_To_HeaderActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HeaderActionParameters_STATUS
	err = actual.AssignProperties_From_HeaderActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HeaderActionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderActionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderActionParameters_STATUS, HeaderActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderActionParameters_STATUS runs a test to see if a specific instance of HeaderActionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderActionParameters_STATUS(subject HeaderActionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderActionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderActionParameters_STATUS instances for property testing - lazily instantiated by
// HeaderActionParameters_STATUSGenerator()
var headerActionParameters_STATUSGenerator gopter.Gen

// HeaderActionParameters_STATUSGenerator returns a generator of HeaderActionParameters_STATUS instances for property testing.
func HeaderActionParameters_STATUSGenerator() gopter.Gen {
	if headerActionParameters_STATUSGenerator != nil {
		return headerActionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderActionParameters_STATUS(generators)
	headerActionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(HeaderActionParameters_STATUS{}), generators)

	return headerActionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHeaderActionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderActionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["HeaderAction"] = gen.PtrOf(gen.OneConstOf(HeaderActionParameters_HeaderAction_STATUS_Append, HeaderActionParameters_HeaderAction_STATUS_Delete, HeaderActionParameters_HeaderAction_STATUS_Overwrite))
	gens["HeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HeaderActionParameters_TypeName_STATUS_DeliveryRuleHeaderActionParameters))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_HostNameMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HostNameMatchConditionParameters to HostNameMatchConditionParameters via AssignProperties_To_HostNameMatchConditionParameters & AssignProperties_From_HostNameMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForHostNameMatchConditionParameters, HostNameMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHostNameMatchConditionParameters tests if a specific instance of HostNameMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHostNameMatchConditionParameters(subject HostNameMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HostNameMatchConditionParameters
	err := copied.AssignProperties_To_HostNameMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HostNameMatchConditionParameters
	err = actual.AssignProperties_From_HostNameMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HostNameMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostNameMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostNameMatchConditionParameters, HostNameMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostNameMatchConditionParameters runs a test to see if a specific instance of HostNameMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForHostNameMatchConditionParameters(subject HostNameMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostNameMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostNameMatchConditionParameters instances for property testing - lazily instantiated by
// HostNameMatchConditionParametersGenerator()
var hostNameMatchConditionParametersGenerator gopter.Gen

// HostNameMatchConditionParametersGenerator returns a generator of HostNameMatchConditionParameters instances for property testing.
func HostNameMatchConditionParametersGenerator() gopter.Gen {
	if hostNameMatchConditionParametersGenerator != nil {
		return hostNameMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostNameMatchConditionParameters(generators)
	hostNameMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(HostNameMatchConditionParameters{}), generators)

	return hostNameMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForHostNameMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostNameMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		HostNameMatchConditionParameters_Operator_Any,
		HostNameMatchConditionParameters_Operator_BeginsWith,
		HostNameMatchConditionParameters_Operator_Contains,
		HostNameMatchConditionParameters_Operator_EndsWith,
		HostNameMatchConditionParameters_Operator_Equal,
		HostNameMatchConditionParameters_Operator_GreaterThan,
		HostNameMatchConditionParameters_Operator_GreaterThanOrEqual,
		HostNameMatchConditionParameters_Operator_LessThan,
		HostNameMatchConditionParameters_Operator_LessThanOrEqual,
		HostNameMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HostNameMatchConditionParameters_TypeName_DeliveryRuleHostNameConditionParameters))
}

func Test_HostNameMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HostNameMatchConditionParameters_STATUS to HostNameMatchConditionParameters_STATUS via AssignProperties_To_HostNameMatchConditionParameters_STATUS & AssignProperties_From_HostNameMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHostNameMatchConditionParameters_STATUS, HostNameMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHostNameMatchConditionParameters_STATUS tests if a specific instance of HostNameMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHostNameMatchConditionParameters_STATUS(subject HostNameMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HostNameMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_HostNameMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HostNameMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_HostNameMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HostNameMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostNameMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostNameMatchConditionParameters_STATUS, HostNameMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostNameMatchConditionParameters_STATUS runs a test to see if a specific instance of HostNameMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHostNameMatchConditionParameters_STATUS(subject HostNameMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostNameMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostNameMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// HostNameMatchConditionParameters_STATUSGenerator()
var hostNameMatchConditionParameters_STATUSGenerator gopter.Gen

// HostNameMatchConditionParameters_STATUSGenerator returns a generator of HostNameMatchConditionParameters_STATUS instances for property testing.
func HostNameMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if hostNameMatchConditionParameters_STATUSGenerator != nil {
		return hostNameMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostNameMatchConditionParameters_STATUS(generators)
	hostNameMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(HostNameMatchConditionParameters_STATUS{}), generators)

	return hostNameMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHostNameMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostNameMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		HostNameMatchConditionParameters_Operator_STATUS_Any,
		HostNameMatchConditionParameters_Operator_STATUS_BeginsWith,
		HostNameMatchConditionParameters_Operator_STATUS_Contains,
		HostNameMatchConditionParameters_Operator_STATUS_EndsWith,
		HostNameMatchConditionParameters_Operator_STATUS_Equal,
		HostNameMatchConditionParameters_Operator_STATUS_GreaterThan,
		HostNameMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
		HostNameMatchConditionParameters_Operator_STATUS_LessThan,
		HostNameMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
		HostNameMatchConditionParameters_Operator_STATUS_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HostNameMatchConditionParameters_TypeName_STATUS_DeliveryRuleHostNameConditionParameters))
}

func Test_HttpVersionMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpVersionMatchConditionParameters to HttpVersionMatchConditionParameters via AssignProperties_To_HttpVersionMatchConditionParameters & AssignProperties_From_HttpVersionMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpVersionMatchConditionParameters, HttpVersionMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpVersionMatchConditionParameters tests if a specific instance of HttpVersionMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHttpVersionMatchConditionParameters(subject HttpVersionMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HttpVersionMatchConditionParameters
	err := copied.AssignProperties_To_HttpVersionMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpVersionMatchConditionParameters
	err = actual.AssignProperties_From_HttpVersionMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpVersionMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpVersionMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpVersionMatchConditionParameters, HttpVersionMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpVersionMatchConditionParameters runs a test to see if a specific instance of HttpVersionMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpVersionMatchConditionParameters(subject HttpVersionMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpVersionMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpVersionMatchConditionParameters instances for property testing - lazily instantiated by
// HttpVersionMatchConditionParametersGenerator()
var httpVersionMatchConditionParametersGenerator gopter.Gen

// HttpVersionMatchConditionParametersGenerator returns a generator of HttpVersionMatchConditionParameters instances for property testing.
func HttpVersionMatchConditionParametersGenerator() gopter.Gen {
	if httpVersionMatchConditionParametersGenerator != nil {
		return httpVersionMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParameters(generators)
	httpVersionMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(HttpVersionMatchConditionParameters{}), generators)

	return httpVersionMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(HttpVersionMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HttpVersionMatchConditionParameters_TypeName_DeliveryRuleHttpVersionConditionParameters))
}

func Test_HttpVersionMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpVersionMatchConditionParameters_STATUS to HttpVersionMatchConditionParameters_STATUS via AssignProperties_To_HttpVersionMatchConditionParameters_STATUS & AssignProperties_From_HttpVersionMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpVersionMatchConditionParameters_STATUS, HttpVersionMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpVersionMatchConditionParameters_STATUS tests if a specific instance of HttpVersionMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHttpVersionMatchConditionParameters_STATUS(subject HttpVersionMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HttpVersionMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_HttpVersionMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpVersionMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_HttpVersionMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpVersionMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpVersionMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpVersionMatchConditionParameters_STATUS, HttpVersionMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpVersionMatchConditionParameters_STATUS runs a test to see if a specific instance of HttpVersionMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpVersionMatchConditionParameters_STATUS(subject HttpVersionMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpVersionMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpVersionMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// HttpVersionMatchConditionParameters_STATUSGenerator()
var httpVersionMatchConditionParameters_STATUSGenerator gopter.Gen

// HttpVersionMatchConditionParameters_STATUSGenerator returns a generator of HttpVersionMatchConditionParameters_STATUS instances for property testing.
func HttpVersionMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if httpVersionMatchConditionParameters_STATUSGenerator != nil {
		return httpVersionMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParameters_STATUS(generators)
	httpVersionMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(HttpVersionMatchConditionParameters_STATUS{}), generators)

	return httpVersionMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(HttpVersionMatchConditionParameters_Operator_STATUS_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HttpVersionMatchConditionParameters_TypeName_STATUS_DeliveryRuleHttpVersionConditionParameters))
}

func Test_IsDeviceMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IsDeviceMatchConditionParameters to IsDeviceMatchConditionParameters via AssignProperties_To_IsDeviceMatchConditionParameters & AssignProperties_From_IsDeviceMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForIsDeviceMatchConditionParameters, IsDeviceMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIsDeviceMatchConditionParameters tests if a specific instance of IsDeviceMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForIsDeviceMatchConditionParameters(subject IsDeviceMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.IsDeviceMatchConditionParameters
	err := copied.AssignProperties_To_IsDeviceMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IsDeviceMatchConditionParameters
	err = actual.AssignProperties_From_IsDeviceMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IsDeviceMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IsDeviceMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIsDeviceMatchConditionParameters, IsDeviceMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIsDeviceMatchConditionParameters runs a test to see if a specific instance of IsDeviceMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForIsDeviceMatchConditionParameters(subject IsDeviceMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IsDeviceMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IsDeviceMatchConditionParameters instances for property testing - lazily instantiated by
// IsDeviceMatchConditionParametersGenerator()
var isDeviceMatchConditionParametersGenerator gopter.Gen

// IsDeviceMatchConditionParametersGenerator returns a generator of IsDeviceMatchConditionParameters instances for property testing.
func IsDeviceMatchConditionParametersGenerator() gopter.Gen {
	if isDeviceMatchConditionParametersGenerator != nil {
		return isDeviceMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParameters(generators)
	isDeviceMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(IsDeviceMatchConditionParameters{}), generators)

	return isDeviceMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(IsDeviceMatchConditionParameters_MatchValues_Desktop, IsDeviceMatchConditionParameters_MatchValues_Mobile))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(IsDeviceMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(IsDeviceMatchConditionParameters_TypeName_DeliveryRuleIsDeviceConditionParameters))
}

func Test_IsDeviceMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IsDeviceMatchConditionParameters_STATUS to IsDeviceMatchConditionParameters_STATUS via AssignProperties_To_IsDeviceMatchConditionParameters_STATUS & AssignProperties_From_IsDeviceMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForIsDeviceMatchConditionParameters_STATUS, IsDeviceMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIsDeviceMatchConditionParameters_STATUS tests if a specific instance of IsDeviceMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForIsDeviceMatchConditionParameters_STATUS(subject IsDeviceMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.IsDeviceMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_IsDeviceMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IsDeviceMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_IsDeviceMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IsDeviceMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IsDeviceMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIsDeviceMatchConditionParameters_STATUS, IsDeviceMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIsDeviceMatchConditionParameters_STATUS runs a test to see if a specific instance of IsDeviceMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForIsDeviceMatchConditionParameters_STATUS(subject IsDeviceMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IsDeviceMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IsDeviceMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// IsDeviceMatchConditionParameters_STATUSGenerator()
var isDeviceMatchConditionParameters_STATUSGenerator gopter.Gen

// IsDeviceMatchConditionParameters_STATUSGenerator returns a generator of IsDeviceMatchConditionParameters_STATUS instances for property testing.
func IsDeviceMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if isDeviceMatchConditionParameters_STATUSGenerator != nil {
		return isDeviceMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParameters_STATUS(generators)
	isDeviceMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(IsDeviceMatchConditionParameters_STATUS{}), generators)

	return isDeviceMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(IsDeviceMatchConditionParameters_MatchValues_STATUS_Desktop, IsDeviceMatchConditionParameters_MatchValues_STATUS_Mobile))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(IsDeviceMatchConditionParameters_Operator_STATUS_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(IsDeviceMatchConditionParameters_TypeName_STATUS_DeliveryRuleIsDeviceConditionParameters))
}

func Test_OriginGroupOverrideActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OriginGroupOverrideActionParameters to OriginGroupOverrideActionParameters via AssignProperties_To_OriginGroupOverrideActionParameters & AssignProperties_From_OriginGroupOverrideActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForOriginGroupOverrideActionParameters, OriginGroupOverrideActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOriginGroupOverrideActionParameters tests if a specific instance of OriginGroupOverrideActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForOriginGroupOverrideActionParameters(subject OriginGroupOverrideActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.OriginGroupOverrideActionParameters
	err := copied.AssignProperties_To_OriginGroupOverrideActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OriginGroupOverrideActionParameters
	err = actual.AssignProperties_From_OriginGroupOverrideActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OriginGroupOverrideActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverrideActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverrideActionParameters, OriginGroupOverrideActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverrideActionParameters runs a test to see if a specific instance of OriginGroupOverrideActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverrideActionParameters(subject OriginGroupOverrideActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverrideActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverrideActionParameters instances for property testing - lazily instantiated by
// OriginGroupOverrideActionParametersGenerator()
var originGroupOverrideActionParametersGenerator gopter.Gen

// OriginGroupOverrideActionParametersGenerator returns a generator of OriginGroupOverrideActionParameters instances for property testing.
// We first initialize originGroupOverrideActionParametersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideActionParametersGenerator() gopter.Gen {
	if originGroupOverrideActionParametersGenerator != nil {
		return originGroupOverrideActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters(generators)
	originGroupOverrideActionParametersGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionParameters{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParameters(generators)
	originGroupOverrideActionParametersGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionParameters{}), generators)

	return originGroupOverrideActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters(gens map[string]gopter.Gen) {
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(OriginGroupOverrideActionParameters_TypeName_DeliveryRuleOriginGroupOverrideActionParameters))
}

// AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParameters(gens map[string]gopter.Gen) {
	gens["OriginGroup"] = gen.PtrOf(ResourceReferenceGenerator())
}

func Test_OriginGroupOverrideActionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OriginGroupOverrideActionParameters_STATUS to OriginGroupOverrideActionParameters_STATUS via AssignProperties_To_OriginGroupOverrideActionParameters_STATUS & AssignProperties_From_OriginGroupOverrideActionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForOriginGroupOverrideActionParameters_STATUS, OriginGroupOverrideActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOriginGroupOverrideActionParameters_STATUS tests if a specific instance of OriginGroupOverrideActionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForOriginGroupOverrideActionParameters_STATUS(subject OriginGroupOverrideActionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.OriginGroupOverrideActionParameters_STATUS
	err := copied.AssignProperties_To_OriginGroupOverrideActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OriginGroupOverrideActionParameters_STATUS
	err = actual.AssignProperties_From_OriginGroupOverrideActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OriginGroupOverrideActionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverrideActionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverrideActionParameters_STATUS, OriginGroupOverrideActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverrideActionParameters_STATUS runs a test to see if a specific instance of OriginGroupOverrideActionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverrideActionParameters_STATUS(subject OriginGroupOverrideActionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverrideActionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverrideActionParameters_STATUS instances for property testing - lazily instantiated by
// OriginGroupOverrideActionParameters_STATUSGenerator()
var originGroupOverrideActionParameters_STATUSGenerator gopter.Gen

// OriginGroupOverrideActionParameters_STATUSGenerator returns a generator of OriginGroupOverrideActionParameters_STATUS instances for property testing.
// We first initialize originGroupOverrideActionParameters_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideActionParameters_STATUSGenerator() gopter.Gen {
	if originGroupOverrideActionParameters_STATUSGenerator != nil {
		return originGroupOverrideActionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters_STATUS(generators)
	originGroupOverrideActionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionParameters_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters_STATUS(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParameters_STATUS(generators)
	originGroupOverrideActionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionParameters_STATUS{}), generators)

	return originGroupOverrideActionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(OriginGroupOverrideActionParameters_TypeName_STATUS_DeliveryRuleOriginGroupOverrideActionParameters))
}

// AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["OriginGroup"] = gen.PtrOf(ResourceReference_STATUSGenerator())
}

func Test_PostArgsMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PostArgsMatchConditionParameters to PostArgsMatchConditionParameters via AssignProperties_To_PostArgsMatchConditionParameters & AssignProperties_From_PostArgsMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForPostArgsMatchConditionParameters, PostArgsMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPostArgsMatchConditionParameters tests if a specific instance of PostArgsMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForPostArgsMatchConditionParameters(subject PostArgsMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.PostArgsMatchConditionParameters
	err := copied.AssignProperties_To_PostArgsMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PostArgsMatchConditionParameters
	err = actual.AssignProperties_From_PostArgsMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PostArgsMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PostArgsMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPostArgsMatchConditionParameters, PostArgsMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPostArgsMatchConditionParameters runs a test to see if a specific instance of PostArgsMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForPostArgsMatchConditionParameters(subject PostArgsMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PostArgsMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PostArgsMatchConditionParameters instances for property testing - lazily instantiated by
// PostArgsMatchConditionParametersGenerator()
var postArgsMatchConditionParametersGenerator gopter.Gen

// PostArgsMatchConditionParametersGenerator returns a generator of PostArgsMatchConditionParameters instances for property testing.
func PostArgsMatchConditionParametersGenerator() gopter.Gen {
	if postArgsMatchConditionParametersGenerator != nil {
		return postArgsMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPostArgsMatchConditionParameters(generators)
	postArgsMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(PostArgsMatchConditionParameters{}), generators)

	return postArgsMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForPostArgsMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPostArgsMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		PostArgsMatchConditionParameters_Operator_Any,
		PostArgsMatchConditionParameters_Operator_BeginsWith,
		PostArgsMatchConditionParameters_Operator_Contains,
		PostArgsMatchConditionParameters_Operator_EndsWith,
		PostArgsMatchConditionParameters_Operator_Equal,
		PostArgsMatchConditionParameters_Operator_GreaterThan,
		PostArgsMatchConditionParameters_Operator_GreaterThanOrEqual,
		PostArgsMatchConditionParameters_Operator_LessThan,
		PostArgsMatchConditionParameters_Operator_LessThanOrEqual,
		PostArgsMatchConditionParameters_Operator_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(PostArgsMatchConditionParameters_TypeName_DeliveryRulePostArgsConditionParameters))
}

func Test_PostArgsMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PostArgsMatchConditionParameters_STATUS to PostArgsMatchConditionParameters_STATUS via AssignProperties_To_PostArgsMatchConditionParameters_STATUS & AssignProperties_From_PostArgsMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForPostArgsMatchConditionParameters_STATUS, PostArgsMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPostArgsMatchConditionParameters_STATUS tests if a specific instance of PostArgsMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForPostArgsMatchConditionParameters_STATUS(subject PostArgsMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.PostArgsMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_PostArgsMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PostArgsMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_PostArgsMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PostArgsMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PostArgsMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPostArgsMatchConditionParameters_STATUS, PostArgsMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPostArgsMatchConditionParameters_STATUS runs a test to see if a specific instance of PostArgsMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForPostArgsMatchConditionParameters_STATUS(subject PostArgsMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PostArgsMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PostArgsMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// PostArgsMatchConditionParameters_STATUSGenerator()
var postArgsMatchConditionParameters_STATUSGenerator gopter.Gen

// PostArgsMatchConditionParameters_STATUSGenerator returns a generator of PostArgsMatchConditionParameters_STATUS instances for property testing.
func PostArgsMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if postArgsMatchConditionParameters_STATUSGenerator != nil {
		return postArgsMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPostArgsMatchConditionParameters_STATUS(generators)
	postArgsMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(PostArgsMatchConditionParameters_STATUS{}), generators)

	return postArgsMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForPostArgsMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPostArgsMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		PostArgsMatchConditionParameters_Operator_STATUS_Any,
		PostArgsMatchConditionParameters_Operator_STATUS_BeginsWith,
		PostArgsMatchConditionParameters_Operator_STATUS_Contains,
		PostArgsMatchConditionParameters_Operator_STATUS_EndsWith,
		PostArgsMatchConditionParameters_Operator_STATUS_Equal,
		PostArgsMatchConditionParameters_Operator_STATUS_GreaterThan,
		PostArgsMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
		PostArgsMatchConditionParameters_Operator_STATUS_LessThan,
		PostArgsMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
		PostArgsMatchConditionParameters_Operator_STATUS_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(PostArgsMatchConditionParameters_TypeName_STATUS_DeliveryRulePostArgsConditionParameters))
}

func Test_QueryStringMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from QueryStringMatchConditionParameters to QueryStringMatchConditionParameters via AssignProperties_To_QueryStringMatchConditionParameters & AssignProperties_From_QueryStringMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForQueryStringMatchConditionParameters, QueryStringMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForQueryStringMatchConditionParameters tests if a specific instance of QueryStringMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForQueryStringMatchConditionParameters(subject QueryStringMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.QueryStringMatchConditionParameters
	err := copied.AssignProperties_To_QueryStringMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual QueryStringMatchConditionParameters
	err = actual.AssignProperties_From_QueryStringMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_QueryStringMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QueryStringMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForQueryStringMatchConditionParameters, QueryStringMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQueryStringMatchConditionParameters runs a test to see if a specific instance of QueryStringMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForQueryStringMatchConditionParameters(subject QueryStringMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QueryStringMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QueryStringMatchConditionParameters instances for property testing - lazily instantiated by
// QueryStringMatchConditionParametersGenerator()
var queryStringMatchConditionParametersGenerator gopter.Gen

// QueryStringMatchConditionParametersGenerator returns a generator of QueryStringMatchConditionParameters instances for property testing.
func QueryStringMatchConditionParametersGenerator() gopter.Gen {
	if queryStringMatchConditionParametersGenerator != nil {
		return queryStringMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQueryStringMatchConditionParameters(generators)
	queryStringMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(QueryStringMatchConditionParameters{}), generators)

	return queryStringMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForQueryStringMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQueryStringMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		QueryStringMatchConditionParameters_Operator_Any,
		QueryStringMatchConditionParameters_Operator_BeginsWith,
		QueryStringMatchConditionParameters_Operator_Contains,
		QueryStringMatchConditionParameters_Operator_EndsWith,
		QueryStringMatchConditionParameters_Operator_Equal,
		QueryStringMatchConditionParameters_Operator_GreaterThan,
		QueryStringMatchConditionParameters_Operator_GreaterThanOrEqual,
		QueryStringMatchConditionParameters_Operator_LessThan,
		QueryStringMatchConditionParameters_Operator_LessThanOrEqual,
		QueryStringMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(QueryStringMatchConditionParameters_TypeName_DeliveryRuleQueryStringConditionParameters))
}

func Test_QueryStringMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from QueryStringMatchConditionParameters_STATUS to QueryStringMatchConditionParameters_STATUS via AssignProperties_To_QueryStringMatchConditionParameters_STATUS & AssignProperties_From_QueryStringMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForQueryStringMatchConditionParameters_STATUS, QueryStringMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForQueryStringMatchConditionParameters_STATUS tests if a specific instance of QueryStringMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForQueryStringMatchConditionParameters_STATUS(subject QueryStringMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.QueryStringMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_QueryStringMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual QueryStringMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_QueryStringMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_QueryStringMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QueryStringMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForQueryStringMatchConditionParameters_STATUS, QueryStringMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQueryStringMatchConditionParameters_STATUS runs a test to see if a specific instance of QueryStringMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForQueryStringMatchConditionParameters_STATUS(subject QueryStringMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QueryStringMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QueryStringMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// QueryStringMatchConditionParameters_STATUSGenerator()
var queryStringMatchConditionParameters_STATUSGenerator gopter.Gen

// QueryStringMatchConditionParameters_STATUSGenerator returns a generator of QueryStringMatchConditionParameters_STATUS instances for property testing.
func QueryStringMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if queryStringMatchConditionParameters_STATUSGenerator != nil {
		return queryStringMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQueryStringMatchConditionParameters_STATUS(generators)
	queryStringMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(QueryStringMatchConditionParameters_STATUS{}), generators)

	return queryStringMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForQueryStringMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQueryStringMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		QueryStringMatchConditionParameters_Operator_STATUS_Any,
		QueryStringMatchConditionParameters_Operator_STATUS_BeginsWith,
		QueryStringMatchConditionParameters_Operator_STATUS_Contains,
		QueryStringMatchConditionParameters_Operator_STATUS_EndsWith,
		QueryStringMatchConditionParameters_Operator_STATUS_Equal,
		QueryStringMatchConditionParameters_Operator_STATUS_GreaterThan,
		QueryStringMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
		QueryStringMatchConditionParameters_Operator_STATUS_LessThan,
		QueryStringMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
		QueryStringMatchConditionParameters_Operator_STATUS_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(QueryStringMatchConditionParameters_TypeName_STATUS_DeliveryRuleQueryStringConditionParameters))
}

func Test_RemoteAddressMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RemoteAddressMatchConditionParameters to RemoteAddressMatchConditionParameters via AssignProperties_To_RemoteAddressMatchConditionParameters & AssignProperties_From_RemoteAddressMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForRemoteAddressMatchConditionParameters, RemoteAddressMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRemoteAddressMatchConditionParameters tests if a specific instance of RemoteAddressMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRemoteAddressMatchConditionParameters(subject RemoteAddressMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RemoteAddressMatchConditionParameters
	err := copied.AssignProperties_To_RemoteAddressMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RemoteAddressMatchConditionParameters
	err = actual.AssignProperties_From_RemoteAddressMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RemoteAddressMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RemoteAddressMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRemoteAddressMatchConditionParameters, RemoteAddressMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRemoteAddressMatchConditionParameters runs a test to see if a specific instance of RemoteAddressMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForRemoteAddressMatchConditionParameters(subject RemoteAddressMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RemoteAddressMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RemoteAddressMatchConditionParameters instances for property testing - lazily instantiated by
// RemoteAddressMatchConditionParametersGenerator()
var remoteAddressMatchConditionParametersGenerator gopter.Gen

// RemoteAddressMatchConditionParametersGenerator returns a generator of RemoteAddressMatchConditionParameters instances for property testing.
func RemoteAddressMatchConditionParametersGenerator() gopter.Gen {
	if remoteAddressMatchConditionParametersGenerator != nil {
		return remoteAddressMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParameters(generators)
	remoteAddressMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(RemoteAddressMatchConditionParameters{}), generators)

	return remoteAddressMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RemoteAddressMatchConditionParameters_Operator_Any, RemoteAddressMatchConditionParameters_Operator_GeoMatch, RemoteAddressMatchConditionParameters_Operator_IPMatch))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RemoteAddressMatchConditionParameters_TypeName_DeliveryRuleRemoteAddressConditionParameters))
}

func Test_RemoteAddressMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RemoteAddressMatchConditionParameters_STATUS to RemoteAddressMatchConditionParameters_STATUS via AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS & AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRemoteAddressMatchConditionParameters_STATUS, RemoteAddressMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRemoteAddressMatchConditionParameters_STATUS tests if a specific instance of RemoteAddressMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRemoteAddressMatchConditionParameters_STATUS(subject RemoteAddressMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RemoteAddressMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_RemoteAddressMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RemoteAddressMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_RemoteAddressMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RemoteAddressMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RemoteAddressMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRemoteAddressMatchConditionParameters_STATUS, RemoteAddressMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRemoteAddressMatchConditionParameters_STATUS runs a test to see if a specific instance of RemoteAddressMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRemoteAddressMatchConditionParameters_STATUS(subject RemoteAddressMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RemoteAddressMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RemoteAddressMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// RemoteAddressMatchConditionParameters_STATUSGenerator()
var remoteAddressMatchConditionParameters_STATUSGenerator gopter.Gen

// RemoteAddressMatchConditionParameters_STATUSGenerator returns a generator of RemoteAddressMatchConditionParameters_STATUS instances for property testing.
func RemoteAddressMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if remoteAddressMatchConditionParameters_STATUSGenerator != nil {
		return remoteAddressMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParameters_STATUS(generators)
	remoteAddressMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(RemoteAddressMatchConditionParameters_STATUS{}), generators)

	return remoteAddressMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RemoteAddressMatchConditionParameters_Operator_STATUS_Any, RemoteAddressMatchConditionParameters_Operator_STATUS_GeoMatch, RemoteAddressMatchConditionParameters_Operator_STATUS_IPMatch))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RemoteAddressMatchConditionParameters_TypeName_STATUS_DeliveryRuleRemoteAddressConditionParameters))
}

func Test_RequestBodyMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestBodyMatchConditionParameters to RequestBodyMatchConditionParameters via AssignProperties_To_RequestBodyMatchConditionParameters & AssignProperties_From_RequestBodyMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestBodyMatchConditionParameters, RequestBodyMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestBodyMatchConditionParameters tests if a specific instance of RequestBodyMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestBodyMatchConditionParameters(subject RequestBodyMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestBodyMatchConditionParameters
	err := copied.AssignProperties_To_RequestBodyMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestBodyMatchConditionParameters
	err = actual.AssignProperties_From_RequestBodyMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestBodyMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestBodyMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestBodyMatchConditionParameters, RequestBodyMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestBodyMatchConditionParameters runs a test to see if a specific instance of RequestBodyMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestBodyMatchConditionParameters(subject RequestBodyMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestBodyMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestBodyMatchConditionParameters instances for property testing - lazily instantiated by
// RequestBodyMatchConditionParametersGenerator()
var requestBodyMatchConditionParametersGenerator gopter.Gen

// RequestBodyMatchConditionParametersGenerator returns a generator of RequestBodyMatchConditionParameters instances for property testing.
func RequestBodyMatchConditionParametersGenerator() gopter.Gen {
	if requestBodyMatchConditionParametersGenerator != nil {
		return requestBodyMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParameters(generators)
	requestBodyMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(RequestBodyMatchConditionParameters{}), generators)

	return requestBodyMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestBodyMatchConditionParameters_Operator_Any,
		RequestBodyMatchConditionParameters_Operator_BeginsWith,
		RequestBodyMatchConditionParameters_Operator_Contains,
		RequestBodyMatchConditionParameters_Operator_EndsWith,
		RequestBodyMatchConditionParameters_Operator_Equal,
		RequestBodyMatchConditionParameters_Operator_GreaterThan,
		RequestBodyMatchConditionParameters_Operator_GreaterThanOrEqual,
		RequestBodyMatchConditionParameters_Operator_LessThan,
		RequestBodyMatchConditionParameters_Operator_LessThanOrEqual,
		RequestBodyMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestBodyMatchConditionParameters_TypeName_DeliveryRuleRequestBodyConditionParameters))
}

func Test_RequestBodyMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestBodyMatchConditionParameters_STATUS to RequestBodyMatchConditionParameters_STATUS via AssignProperties_To_RequestBodyMatchConditionParameters_STATUS & AssignProperties_From_RequestBodyMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestBodyMatchConditionParameters_STATUS, RequestBodyMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestBodyMatchConditionParameters_STATUS tests if a specific instance of RequestBodyMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestBodyMatchConditionParameters_STATUS(subject RequestBodyMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestBodyMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_RequestBodyMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestBodyMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_RequestBodyMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestBodyMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestBodyMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestBodyMatchConditionParameters_STATUS, RequestBodyMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestBodyMatchConditionParameters_STATUS runs a test to see if a specific instance of RequestBodyMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestBodyMatchConditionParameters_STATUS(subject RequestBodyMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestBodyMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestBodyMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// RequestBodyMatchConditionParameters_STATUSGenerator()
var requestBodyMatchConditionParameters_STATUSGenerator gopter.Gen

// RequestBodyMatchConditionParameters_STATUSGenerator returns a generator of RequestBodyMatchConditionParameters_STATUS instances for property testing.
func RequestBodyMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if requestBodyMatchConditionParameters_STATUSGenerator != nil {
		return requestBodyMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParameters_STATUS(generators)
	requestBodyMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(RequestBodyMatchConditionParameters_STATUS{}), generators)

	return requestBodyMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestBodyMatchConditionParameters_Operator_STATUS_Any,
		RequestBodyMatchConditionParameters_Operator_STATUS_BeginsWith,
		RequestBodyMatchConditionParameters_Operator_STATUS_Contains,
		RequestBodyMatchConditionParameters_Operator_STATUS_EndsWith,
		RequestBodyMatchConditionParameters_Operator_STATUS_Equal,
		RequestBodyMatchConditionParameters_Operator_STATUS_GreaterThan,
		RequestBodyMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
		RequestBodyMatchConditionParameters_Operator_STATUS_LessThan,
		RequestBodyMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
		RequestBodyMatchConditionParameters_Operator_STATUS_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestBodyMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestBodyConditionParameters))
}

func Test_RequestHeaderMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestHeaderMatchConditionParameters to RequestHeaderMatchConditionParameters via AssignProperties_To_RequestHeaderMatchConditionParameters & AssignProperties_From_RequestHeaderMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestHeaderMatchConditionParameters, RequestHeaderMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestHeaderMatchConditionParameters tests if a specific instance of RequestHeaderMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestHeaderMatchConditionParameters(subject RequestHeaderMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestHeaderMatchConditionParameters
	err := copied.AssignProperties_To_RequestHeaderMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestHeaderMatchConditionParameters
	err = actual.AssignProperties_From_RequestHeaderMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestHeaderMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestHeaderMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestHeaderMatchConditionParameters, RequestHeaderMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestHeaderMatchConditionParameters runs a test to see if a specific instance of RequestHeaderMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestHeaderMatchConditionParameters(subject RequestHeaderMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestHeaderMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestHeaderMatchConditionParameters instances for property testing - lazily instantiated by
// RequestHeaderMatchConditionParametersGenerator()
var requestHeaderMatchConditionParametersGenerator gopter.Gen

// RequestHeaderMatchConditionParametersGenerator returns a generator of RequestHeaderMatchConditionParameters instances for property testing.
func RequestHeaderMatchConditionParametersGenerator() gopter.Gen {
	if requestHeaderMatchConditionParametersGenerator != nil {
		return requestHeaderMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParameters(generators)
	requestHeaderMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(RequestHeaderMatchConditionParameters{}), generators)

	return requestHeaderMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestHeaderMatchConditionParameters_Operator_Any,
		RequestHeaderMatchConditionParameters_Operator_BeginsWith,
		RequestHeaderMatchConditionParameters_Operator_Contains,
		RequestHeaderMatchConditionParameters_Operator_EndsWith,
		RequestHeaderMatchConditionParameters_Operator_Equal,
		RequestHeaderMatchConditionParameters_Operator_GreaterThan,
		RequestHeaderMatchConditionParameters_Operator_GreaterThanOrEqual,
		RequestHeaderMatchConditionParameters_Operator_LessThan,
		RequestHeaderMatchConditionParameters_Operator_LessThanOrEqual,
		RequestHeaderMatchConditionParameters_Operator_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestHeaderMatchConditionParameters_TypeName_DeliveryRuleRequestHeaderConditionParameters))
}

func Test_RequestHeaderMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestHeaderMatchConditionParameters_STATUS to RequestHeaderMatchConditionParameters_STATUS via AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS & AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestHeaderMatchConditionParameters_STATUS, RequestHeaderMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestHeaderMatchConditionParameters_STATUS tests if a specific instance of RequestHeaderMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestHeaderMatchConditionParameters_STATUS(subject RequestHeaderMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestHeaderMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_RequestHeaderMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestHeaderMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_RequestHeaderMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestHeaderMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestHeaderMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestHeaderMatchConditionParameters_STATUS, RequestHeaderMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestHeaderMatchConditionParameters_STATUS runs a test to see if a specific instance of RequestHeaderMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestHeaderMatchConditionParameters_STATUS(subject RequestHeaderMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestHeaderMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestHeaderMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// RequestHeaderMatchConditionParameters_STATUSGenerator()
var requestHeaderMatchConditionParameters_STATUSGenerator gopter.Gen

// RequestHeaderMatchConditionParameters_STATUSGenerator returns a generator of RequestHeaderMatchConditionParameters_STATUS instances for property testing.
func RequestHeaderMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if requestHeaderMatchConditionParameters_STATUSGenerator != nil {
		return requestHeaderMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParameters_STATUS(generators)
	requestHeaderMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(RequestHeaderMatchConditionParameters_STATUS{}), generators)

	return requestHeaderMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestHeaderMatchConditionParameters_Operator_STATUS_Any,
		RequestHeaderMatchConditionParameters_Operator_STATUS_BeginsWith,
		RequestHeaderMatchConditionParameters_Operator_STATUS_Contains,
		RequestHeaderMatchConditionParameters_Operator_STATUS_EndsWith,
		RequestHeaderMatchConditionParameters_Operator_STATUS_Equal,
		RequestHeaderMatchConditionParameters_Operator_STATUS_GreaterThan,
		RequestHeaderMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
		RequestHeaderMatchConditionParameters_Operator_STATUS_LessThan,
		RequestHeaderMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
		RequestHeaderMatchConditionParameters_Operator_STATUS_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestHeaderMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestHeaderConditionParameters))
}

func Test_RequestMethodMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestMethodMatchConditionParameters to RequestMethodMatchConditionParameters via AssignProperties_To_RequestMethodMatchConditionParameters & AssignProperties_From_RequestMethodMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestMethodMatchConditionParameters, RequestMethodMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestMethodMatchConditionParameters tests if a specific instance of RequestMethodMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestMethodMatchConditionParameters(subject RequestMethodMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestMethodMatchConditionParameters
	err := copied.AssignProperties_To_RequestMethodMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestMethodMatchConditionParameters
	err = actual.AssignProperties_From_RequestMethodMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestMethodMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestMethodMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestMethodMatchConditionParameters, RequestMethodMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestMethodMatchConditionParameters runs a test to see if a specific instance of RequestMethodMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestMethodMatchConditionParameters(subject RequestMethodMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestMethodMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestMethodMatchConditionParameters instances for property testing - lazily instantiated by
// RequestMethodMatchConditionParametersGenerator()
var requestMethodMatchConditionParametersGenerator gopter.Gen

// RequestMethodMatchConditionParametersGenerator returns a generator of RequestMethodMatchConditionParameters instances for property testing.
func RequestMethodMatchConditionParametersGenerator() gopter.Gen {
	if requestMethodMatchConditionParametersGenerator != nil {
		return requestMethodMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParameters(generators)
	requestMethodMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(RequestMethodMatchConditionParameters{}), generators)

	return requestMethodMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(
		RequestMethodMatchConditionParameters_MatchValues_DELETE,
		RequestMethodMatchConditionParameters_MatchValues_GET,
		RequestMethodMatchConditionParameters_MatchValues_HEAD,
		RequestMethodMatchConditionParameters_MatchValues_OPTIONS,
		RequestMethodMatchConditionParameters_MatchValues_POST,
		RequestMethodMatchConditionParameters_MatchValues_PUT,
		RequestMethodMatchConditionParameters_MatchValues_TRACE))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RequestMethodMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestMethodMatchConditionParameters_TypeName_DeliveryRuleRequestMethodConditionParameters))
}

func Test_RequestMethodMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestMethodMatchConditionParameters_STATUS to RequestMethodMatchConditionParameters_STATUS via AssignProperties_To_RequestMethodMatchConditionParameters_STATUS & AssignProperties_From_RequestMethodMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestMethodMatchConditionParameters_STATUS, RequestMethodMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestMethodMatchConditionParameters_STATUS tests if a specific instance of RequestMethodMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestMethodMatchConditionParameters_STATUS(subject RequestMethodMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestMethodMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_RequestMethodMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestMethodMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_RequestMethodMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestMethodMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestMethodMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestMethodMatchConditionParameters_STATUS, RequestMethodMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestMethodMatchConditionParameters_STATUS runs a test to see if a specific instance of RequestMethodMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestMethodMatchConditionParameters_STATUS(subject RequestMethodMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestMethodMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestMethodMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// RequestMethodMatchConditionParameters_STATUSGenerator()
var requestMethodMatchConditionParameters_STATUSGenerator gopter.Gen

// RequestMethodMatchConditionParameters_STATUSGenerator returns a generator of RequestMethodMatchConditionParameters_STATUS instances for property testing.
func RequestMethodMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if requestMethodMatchConditionParameters_STATUSGenerator != nil {
		return requestMethodMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParameters_STATUS(generators)
	requestMethodMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(RequestMethodMatchConditionParameters_STATUS{}), generators)

	return requestMethodMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(
		RequestMethodMatchConditionParameters_MatchValues_STATUS_DELETE,
		RequestMethodMatchConditionParameters_MatchValues_STATUS_GET,
		RequestMethodMatchConditionParameters_MatchValues_STATUS_HEAD,
		RequestMethodMatchConditionParameters_MatchValues_STATUS_OPTIONS,
		RequestMethodMatchConditionParameters_MatchValues_STATUS_POST,
		RequestMethodMatchConditionParameters_MatchValues_STATUS_PUT,
		RequestMethodMatchConditionParameters_MatchValues_STATUS_TRACE))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RequestMethodMatchConditionParameters_Operator_STATUS_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestMethodMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestMethodConditionParameters))
}

func Test_RequestSchemeMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestSchemeMatchConditionParameters to RequestSchemeMatchConditionParameters via AssignProperties_To_RequestSchemeMatchConditionParameters & AssignProperties_From_RequestSchemeMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestSchemeMatchConditionParameters, RequestSchemeMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestSchemeMatchConditionParameters tests if a specific instance of RequestSchemeMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestSchemeMatchConditionParameters(subject RequestSchemeMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestSchemeMatchConditionParameters
	err := copied.AssignProperties_To_RequestSchemeMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestSchemeMatchConditionParameters
	err = actual.AssignProperties_From_RequestSchemeMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestSchemeMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestSchemeMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestSchemeMatchConditionParameters, RequestSchemeMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestSchemeMatchConditionParameters runs a test to see if a specific instance of RequestSchemeMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestSchemeMatchConditionParameters(subject RequestSchemeMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestSchemeMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestSchemeMatchConditionParameters instances for property testing - lazily instantiated by
// RequestSchemeMatchConditionParametersGenerator()
var requestSchemeMatchConditionParametersGenerator gopter.Gen

// RequestSchemeMatchConditionParametersGenerator returns a generator of RequestSchemeMatchConditionParameters instances for property testing.
func RequestSchemeMatchConditionParametersGenerator() gopter.Gen {
	if requestSchemeMatchConditionParametersGenerator != nil {
		return requestSchemeMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParameters(generators)
	requestSchemeMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(RequestSchemeMatchConditionParameters{}), generators)

	return requestSchemeMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(RequestSchemeMatchConditionParameters_MatchValues_HTTP, RequestSchemeMatchConditionParameters_MatchValues_HTTPS))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RequestSchemeMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestSchemeMatchConditionParameters_TypeName_DeliveryRuleRequestSchemeConditionParameters))
}

func Test_RequestSchemeMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestSchemeMatchConditionParameters_STATUS to RequestSchemeMatchConditionParameters_STATUS via AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS & AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestSchemeMatchConditionParameters_STATUS, RequestSchemeMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestSchemeMatchConditionParameters_STATUS tests if a specific instance of RequestSchemeMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestSchemeMatchConditionParameters_STATUS(subject RequestSchemeMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestSchemeMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_RequestSchemeMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestSchemeMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_RequestSchemeMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestSchemeMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestSchemeMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestSchemeMatchConditionParameters_STATUS, RequestSchemeMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestSchemeMatchConditionParameters_STATUS runs a test to see if a specific instance of RequestSchemeMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestSchemeMatchConditionParameters_STATUS(subject RequestSchemeMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestSchemeMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestSchemeMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// RequestSchemeMatchConditionParameters_STATUSGenerator()
var requestSchemeMatchConditionParameters_STATUSGenerator gopter.Gen

// RequestSchemeMatchConditionParameters_STATUSGenerator returns a generator of RequestSchemeMatchConditionParameters_STATUS instances for property testing.
func RequestSchemeMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if requestSchemeMatchConditionParameters_STATUSGenerator != nil {
		return requestSchemeMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParameters_STATUS(generators)
	requestSchemeMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(RequestSchemeMatchConditionParameters_STATUS{}), generators)

	return requestSchemeMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(RequestSchemeMatchConditionParameters_MatchValues_STATUS_HTTP, RequestSchemeMatchConditionParameters_MatchValues_STATUS_HTTPS))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RequestSchemeMatchConditionParameters_Operator_STATUS_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestSchemeMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestSchemeConditionParameters))
}

func Test_RequestUriMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestUriMatchConditionParameters to RequestUriMatchConditionParameters via AssignProperties_To_RequestUriMatchConditionParameters & AssignProperties_From_RequestUriMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestUriMatchConditionParameters, RequestUriMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestUriMatchConditionParameters tests if a specific instance of RequestUriMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestUriMatchConditionParameters(subject RequestUriMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestUriMatchConditionParameters
	err := copied.AssignProperties_To_RequestUriMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestUriMatchConditionParameters
	err = actual.AssignProperties_From_RequestUriMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestUriMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestUriMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestUriMatchConditionParameters, RequestUriMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestUriMatchConditionParameters runs a test to see if a specific instance of RequestUriMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestUriMatchConditionParameters(subject RequestUriMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestUriMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestUriMatchConditionParameters instances for property testing - lazily instantiated by
// RequestUriMatchConditionParametersGenerator()
var requestUriMatchConditionParametersGenerator gopter.Gen

// RequestUriMatchConditionParametersGenerator returns a generator of RequestUriMatchConditionParameters instances for property testing.
func RequestUriMatchConditionParametersGenerator() gopter.Gen {
	if requestUriMatchConditionParametersGenerator != nil {
		return requestUriMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestUriMatchConditionParameters(generators)
	requestUriMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(RequestUriMatchConditionParameters{}), generators)

	return requestUriMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForRequestUriMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestUriMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestUriMatchConditionParameters_Operator_Any,
		RequestUriMatchConditionParameters_Operator_BeginsWith,
		RequestUriMatchConditionParameters_Operator_Contains,
		RequestUriMatchConditionParameters_Operator_EndsWith,
		RequestUriMatchConditionParameters_Operator_Equal,
		RequestUriMatchConditionParameters_Operator_GreaterThan,
		RequestUriMatchConditionParameters_Operator_GreaterThanOrEqual,
		RequestUriMatchConditionParameters_Operator_LessThan,
		RequestUriMatchConditionParameters_Operator_LessThanOrEqual,
		RequestUriMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestUriMatchConditionParameters_TypeName_DeliveryRuleRequestUriConditionParameters))
}

func Test_RequestUriMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestUriMatchConditionParameters_STATUS to RequestUriMatchConditionParameters_STATUS via AssignProperties_To_RequestUriMatchConditionParameters_STATUS & AssignProperties_From_RequestUriMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestUriMatchConditionParameters_STATUS, RequestUriMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestUriMatchConditionParameters_STATUS tests if a specific instance of RequestUriMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestUriMatchConditionParameters_STATUS(subject RequestUriMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestUriMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_RequestUriMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestUriMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_RequestUriMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestUriMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestUriMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestUriMatchConditionParameters_STATUS, RequestUriMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestUriMatchConditionParameters_STATUS runs a test to see if a specific instance of RequestUriMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestUriMatchConditionParameters_STATUS(subject RequestUriMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestUriMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestUriMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// RequestUriMatchConditionParameters_STATUSGenerator()
var requestUriMatchConditionParameters_STATUSGenerator gopter.Gen

// RequestUriMatchConditionParameters_STATUSGenerator returns a generator of RequestUriMatchConditionParameters_STATUS instances for property testing.
func RequestUriMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if requestUriMatchConditionParameters_STATUSGenerator != nil {
		return requestUriMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestUriMatchConditionParameters_STATUS(generators)
	requestUriMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(RequestUriMatchConditionParameters_STATUS{}), generators)

	return requestUriMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRequestUriMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestUriMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestUriMatchConditionParameters_Operator_STATUS_Any,
		RequestUriMatchConditionParameters_Operator_STATUS_BeginsWith,
		RequestUriMatchConditionParameters_Operator_STATUS_Contains,
		RequestUriMatchConditionParameters_Operator_STATUS_EndsWith,
		RequestUriMatchConditionParameters_Operator_STATUS_Equal,
		RequestUriMatchConditionParameters_Operator_STATUS_GreaterThan,
		RequestUriMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
		RequestUriMatchConditionParameters_Operator_STATUS_LessThan,
		RequestUriMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
		RequestUriMatchConditionParameters_Operator_STATUS_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestUriMatchConditionParameters_TypeName_STATUS_DeliveryRuleRequestUriConditionParameters))
}

func Test_RouteConfigurationOverrideActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RouteConfigurationOverrideActionParameters to RouteConfigurationOverrideActionParameters via AssignProperties_To_RouteConfigurationOverrideActionParameters & AssignProperties_From_RouteConfigurationOverrideActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForRouteConfigurationOverrideActionParameters, RouteConfigurationOverrideActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRouteConfigurationOverrideActionParameters tests if a specific instance of RouteConfigurationOverrideActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRouteConfigurationOverrideActionParameters(subject RouteConfigurationOverrideActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RouteConfigurationOverrideActionParameters
	err := copied.AssignProperties_To_RouteConfigurationOverrideActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RouteConfigurationOverrideActionParameters
	err = actual.AssignProperties_From_RouteConfigurationOverrideActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RouteConfigurationOverrideActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteConfigurationOverrideActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteConfigurationOverrideActionParameters, RouteConfigurationOverrideActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteConfigurationOverrideActionParameters runs a test to see if a specific instance of RouteConfigurationOverrideActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteConfigurationOverrideActionParameters(subject RouteConfigurationOverrideActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteConfigurationOverrideActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteConfigurationOverrideActionParameters instances for property testing - lazily instantiated by
// RouteConfigurationOverrideActionParametersGenerator()
var routeConfigurationOverrideActionParametersGenerator gopter.Gen

// RouteConfigurationOverrideActionParametersGenerator returns a generator of RouteConfigurationOverrideActionParameters instances for property testing.
// We first initialize routeConfigurationOverrideActionParametersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RouteConfigurationOverrideActionParametersGenerator() gopter.Gen {
	if routeConfigurationOverrideActionParametersGenerator != nil {
		return routeConfigurationOverrideActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters(generators)
	routeConfigurationOverrideActionParametersGenerator = gen.Struct(reflect.TypeOf(RouteConfigurationOverrideActionParameters{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters(generators)
	AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParameters(generators)
	routeConfigurationOverrideActionParametersGenerator = gen.Struct(reflect.TypeOf(RouteConfigurationOverrideActionParameters{}), generators)

	return routeConfigurationOverrideActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters(gens map[string]gopter.Gen) {
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RouteConfigurationOverrideActionParameters_TypeName_DeliveryRuleRouteConfigurationOverrideActionParameters))
}

// AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParameters(gens map[string]gopter.Gen) {
	gens["CacheConfiguration"] = gen.PtrOf(CacheConfigurationGenerator())
	gens["OriginGroupOverride"] = gen.PtrOf(OriginGroupOverrideGenerator())
}

func Test_RouteConfigurationOverrideActionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RouteConfigurationOverrideActionParameters_STATUS to RouteConfigurationOverrideActionParameters_STATUS via AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS & AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForRouteConfigurationOverrideActionParameters_STATUS, RouteConfigurationOverrideActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRouteConfigurationOverrideActionParameters_STATUS tests if a specific instance of RouteConfigurationOverrideActionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRouteConfigurationOverrideActionParameters_STATUS(subject RouteConfigurationOverrideActionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RouteConfigurationOverrideActionParameters_STATUS
	err := copied.AssignProperties_To_RouteConfigurationOverrideActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RouteConfigurationOverrideActionParameters_STATUS
	err = actual.AssignProperties_From_RouteConfigurationOverrideActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RouteConfigurationOverrideActionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteConfigurationOverrideActionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteConfigurationOverrideActionParameters_STATUS, RouteConfigurationOverrideActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteConfigurationOverrideActionParameters_STATUS runs a test to see if a specific instance of RouteConfigurationOverrideActionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteConfigurationOverrideActionParameters_STATUS(subject RouteConfigurationOverrideActionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteConfigurationOverrideActionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteConfigurationOverrideActionParameters_STATUS instances for property testing - lazily instantiated
// by RouteConfigurationOverrideActionParameters_STATUSGenerator()
var routeConfigurationOverrideActionParameters_STATUSGenerator gopter.Gen

// RouteConfigurationOverrideActionParameters_STATUSGenerator returns a generator of RouteConfigurationOverrideActionParameters_STATUS instances for property testing.
// We first initialize routeConfigurationOverrideActionParameters_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RouteConfigurationOverrideActionParameters_STATUSGenerator() gopter.Gen {
	if routeConfigurationOverrideActionParameters_STATUSGenerator != nil {
		return routeConfigurationOverrideActionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters_STATUS(generators)
	routeConfigurationOverrideActionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(RouteConfigurationOverrideActionParameters_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters_STATUS(generators)
	AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParameters_STATUS(generators)
	routeConfigurationOverrideActionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(RouteConfigurationOverrideActionParameters_STATUS{}), generators)

	return routeConfigurationOverrideActionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RouteConfigurationOverrideActionParameters_TypeName_STATUS_DeliveryRuleRouteConfigurationOverrideActionParameters))
}

// AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["CacheConfiguration"] = gen.PtrOf(CacheConfiguration_STATUSGenerator())
	gens["OriginGroupOverride"] = gen.PtrOf(OriginGroupOverride_STATUSGenerator())
}

func Test_ServerPortMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerPortMatchConditionParameters to ServerPortMatchConditionParameters via AssignProperties_To_ServerPortMatchConditionParameters & AssignProperties_From_ServerPortMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerPortMatchConditionParameters, ServerPortMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerPortMatchConditionParameters tests if a specific instance of ServerPortMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForServerPortMatchConditionParameters(subject ServerPortMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ServerPortMatchConditionParameters
	err := copied.AssignProperties_To_ServerPortMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerPortMatchConditionParameters
	err = actual.AssignProperties_From_ServerPortMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerPortMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerPortMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerPortMatchConditionParameters, ServerPortMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerPortMatchConditionParameters runs a test to see if a specific instance of ServerPortMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForServerPortMatchConditionParameters(subject ServerPortMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerPortMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerPortMatchConditionParameters instances for property testing - lazily instantiated by
// ServerPortMatchConditionParametersGenerator()
var serverPortMatchConditionParametersGenerator gopter.Gen

// ServerPortMatchConditionParametersGenerator returns a generator of ServerPortMatchConditionParameters instances for property testing.
func ServerPortMatchConditionParametersGenerator() gopter.Gen {
	if serverPortMatchConditionParametersGenerator != nil {
		return serverPortMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerPortMatchConditionParameters(generators)
	serverPortMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(ServerPortMatchConditionParameters{}), generators)

	return serverPortMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForServerPortMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerPortMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		ServerPortMatchConditionParameters_Operator_Any,
		ServerPortMatchConditionParameters_Operator_BeginsWith,
		ServerPortMatchConditionParameters_Operator_Contains,
		ServerPortMatchConditionParameters_Operator_EndsWith,
		ServerPortMatchConditionParameters_Operator_Equal,
		ServerPortMatchConditionParameters_Operator_GreaterThan,
		ServerPortMatchConditionParameters_Operator_GreaterThanOrEqual,
		ServerPortMatchConditionParameters_Operator_LessThan,
		ServerPortMatchConditionParameters_Operator_LessThanOrEqual,
		ServerPortMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(ServerPortMatchConditionParameters_TypeName_DeliveryRuleServerPortConditionParameters))
}

func Test_ServerPortMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerPortMatchConditionParameters_STATUS to ServerPortMatchConditionParameters_STATUS via AssignProperties_To_ServerPortMatchConditionParameters_STATUS & AssignProperties_From_ServerPortMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerPortMatchConditionParameters_STATUS, ServerPortMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerPortMatchConditionParameters_STATUS tests if a specific instance of ServerPortMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForServerPortMatchConditionParameters_STATUS(subject ServerPortMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ServerPortMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_ServerPortMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerPortMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_ServerPortMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerPortMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerPortMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerPortMatchConditionParameters_STATUS, ServerPortMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerPortMatchConditionParameters_STATUS runs a test to see if a specific instance of ServerPortMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForServerPortMatchConditionParameters_STATUS(subject ServerPortMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerPortMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerPortMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// ServerPortMatchConditionParameters_STATUSGenerator()
var serverPortMatchConditionParameters_STATUSGenerator gopter.Gen

// ServerPortMatchConditionParameters_STATUSGenerator returns a generator of ServerPortMatchConditionParameters_STATUS instances for property testing.
func ServerPortMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if serverPortMatchConditionParameters_STATUSGenerator != nil {
		return serverPortMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerPortMatchConditionParameters_STATUS(generators)
	serverPortMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(ServerPortMatchConditionParameters_STATUS{}), generators)

	return serverPortMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForServerPortMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerPortMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		ServerPortMatchConditionParameters_Operator_STATUS_Any,
		ServerPortMatchConditionParameters_Operator_STATUS_BeginsWith,
		ServerPortMatchConditionParameters_Operator_STATUS_Contains,
		ServerPortMatchConditionParameters_Operator_STATUS_EndsWith,
		ServerPortMatchConditionParameters_Operator_STATUS_Equal,
		ServerPortMatchConditionParameters_Operator_STATUS_GreaterThan,
		ServerPortMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
		ServerPortMatchConditionParameters_Operator_STATUS_LessThan,
		ServerPortMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
		ServerPortMatchConditionParameters_Operator_STATUS_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(ServerPortMatchConditionParameters_TypeName_STATUS_DeliveryRuleServerPortConditionParameters))
}

func Test_SocketAddrMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SocketAddrMatchConditionParameters to SocketAddrMatchConditionParameters via AssignProperties_To_SocketAddrMatchConditionParameters & AssignProperties_From_SocketAddrMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForSocketAddrMatchConditionParameters, SocketAddrMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSocketAddrMatchConditionParameters tests if a specific instance of SocketAddrMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForSocketAddrMatchConditionParameters(subject SocketAddrMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.SocketAddrMatchConditionParameters
	err := copied.AssignProperties_To_SocketAddrMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SocketAddrMatchConditionParameters
	err = actual.AssignProperties_From_SocketAddrMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SocketAddrMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SocketAddrMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSocketAddrMatchConditionParameters, SocketAddrMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSocketAddrMatchConditionParameters runs a test to see if a specific instance of SocketAddrMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForSocketAddrMatchConditionParameters(subject SocketAddrMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SocketAddrMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SocketAddrMatchConditionParameters instances for property testing - lazily instantiated by
// SocketAddrMatchConditionParametersGenerator()
var socketAddrMatchConditionParametersGenerator gopter.Gen

// SocketAddrMatchConditionParametersGenerator returns a generator of SocketAddrMatchConditionParameters instances for property testing.
func SocketAddrMatchConditionParametersGenerator() gopter.Gen {
	if socketAddrMatchConditionParametersGenerator != nil {
		return socketAddrMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParameters(generators)
	socketAddrMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(SocketAddrMatchConditionParameters{}), generators)

	return socketAddrMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(SocketAddrMatchConditionParameters_Operator_Any, SocketAddrMatchConditionParameters_Operator_IPMatch))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(SocketAddrMatchConditionParameters_TypeName_DeliveryRuleSocketAddrConditionParameters))
}

func Test_SocketAddrMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SocketAddrMatchConditionParameters_STATUS to SocketAddrMatchConditionParameters_STATUS via AssignProperties_To_SocketAddrMatchConditionParameters_STATUS & AssignProperties_From_SocketAddrMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSocketAddrMatchConditionParameters_STATUS, SocketAddrMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSocketAddrMatchConditionParameters_STATUS tests if a specific instance of SocketAddrMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForSocketAddrMatchConditionParameters_STATUS(subject SocketAddrMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.SocketAddrMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_SocketAddrMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SocketAddrMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_SocketAddrMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SocketAddrMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SocketAddrMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSocketAddrMatchConditionParameters_STATUS, SocketAddrMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSocketAddrMatchConditionParameters_STATUS runs a test to see if a specific instance of SocketAddrMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSocketAddrMatchConditionParameters_STATUS(subject SocketAddrMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SocketAddrMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SocketAddrMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// SocketAddrMatchConditionParameters_STATUSGenerator()
var socketAddrMatchConditionParameters_STATUSGenerator gopter.Gen

// SocketAddrMatchConditionParameters_STATUSGenerator returns a generator of SocketAddrMatchConditionParameters_STATUS instances for property testing.
func SocketAddrMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if socketAddrMatchConditionParameters_STATUSGenerator != nil {
		return socketAddrMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParameters_STATUS(generators)
	socketAddrMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(SocketAddrMatchConditionParameters_STATUS{}), generators)

	return socketAddrMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(SocketAddrMatchConditionParameters_Operator_STATUS_Any, SocketAddrMatchConditionParameters_Operator_STATUS_IPMatch))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(SocketAddrMatchConditionParameters_TypeName_STATUS_DeliveryRuleSocketAddrConditionParameters))
}

func Test_SslProtocolMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SslProtocolMatchConditionParameters to SslProtocolMatchConditionParameters via AssignProperties_To_SslProtocolMatchConditionParameters & AssignProperties_From_SslProtocolMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForSslProtocolMatchConditionParameters, SslProtocolMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSslProtocolMatchConditionParameters tests if a specific instance of SslProtocolMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForSslProtocolMatchConditionParameters(subject SslProtocolMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.SslProtocolMatchConditionParameters
	err := copied.AssignProperties_To_SslProtocolMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SslProtocolMatchConditionParameters
	err = actual.AssignProperties_From_SslProtocolMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SslProtocolMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SslProtocolMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSslProtocolMatchConditionParameters, SslProtocolMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSslProtocolMatchConditionParameters runs a test to see if a specific instance of SslProtocolMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForSslProtocolMatchConditionParameters(subject SslProtocolMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SslProtocolMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SslProtocolMatchConditionParameters instances for property testing - lazily instantiated by
// SslProtocolMatchConditionParametersGenerator()
var sslProtocolMatchConditionParametersGenerator gopter.Gen

// SslProtocolMatchConditionParametersGenerator returns a generator of SslProtocolMatchConditionParameters instances for property testing.
func SslProtocolMatchConditionParametersGenerator() gopter.Gen {
	if sslProtocolMatchConditionParametersGenerator != nil {
		return sslProtocolMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParameters(generators)
	sslProtocolMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(SslProtocolMatchConditionParameters{}), generators)

	return sslProtocolMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(SslProtocol_TLSv1, SslProtocol_TLSv11, SslProtocol_TLSv12))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(SslProtocolMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(SslProtocolMatchConditionParameters_TypeName_DeliveryRuleSslProtocolConditionParameters))
}

func Test_SslProtocolMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SslProtocolMatchConditionParameters_STATUS to SslProtocolMatchConditionParameters_STATUS via AssignProperties_To_SslProtocolMatchConditionParameters_STATUS & AssignProperties_From_SslProtocolMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForSslProtocolMatchConditionParameters_STATUS, SslProtocolMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSslProtocolMatchConditionParameters_STATUS tests if a specific instance of SslProtocolMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForSslProtocolMatchConditionParameters_STATUS(subject SslProtocolMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.SslProtocolMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_SslProtocolMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SslProtocolMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_SslProtocolMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SslProtocolMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SslProtocolMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSslProtocolMatchConditionParameters_STATUS, SslProtocolMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSslProtocolMatchConditionParameters_STATUS runs a test to see if a specific instance of SslProtocolMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForSslProtocolMatchConditionParameters_STATUS(subject SslProtocolMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SslProtocolMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SslProtocolMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// SslProtocolMatchConditionParameters_STATUSGenerator()
var sslProtocolMatchConditionParameters_STATUSGenerator gopter.Gen

// SslProtocolMatchConditionParameters_STATUSGenerator returns a generator of SslProtocolMatchConditionParameters_STATUS instances for property testing.
func SslProtocolMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if sslProtocolMatchConditionParameters_STATUSGenerator != nil {
		return sslProtocolMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParameters_STATUS(generators)
	sslProtocolMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(SslProtocolMatchConditionParameters_STATUS{}), generators)

	return sslProtocolMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(SslProtocol_STATUS_TLSv1, SslProtocol_STATUS_TLSv11, SslProtocol_STATUS_TLSv12))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(SslProtocolMatchConditionParameters_Operator_STATUS_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(SslProtocolMatchConditionParameters_TypeName_STATUS_DeliveryRuleSslProtocolConditionParameters))
}

func Test_UrlFileExtensionMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlFileExtensionMatchConditionParameters to UrlFileExtensionMatchConditionParameters via AssignProperties_To_UrlFileExtensionMatchConditionParameters & AssignProperties_From_UrlFileExtensionMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlFileExtensionMatchConditionParameters, UrlFileExtensionMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlFileExtensionMatchConditionParameters tests if a specific instance of UrlFileExtensionMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlFileExtensionMatchConditionParameters(subject UrlFileExtensionMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlFileExtensionMatchConditionParameters
	err := copied.AssignProperties_To_UrlFileExtensionMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlFileExtensionMatchConditionParameters
	err = actual.AssignProperties_From_UrlFileExtensionMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlFileExtensionMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlFileExtensionMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlFileExtensionMatchConditionParameters, UrlFileExtensionMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlFileExtensionMatchConditionParameters runs a test to see if a specific instance of UrlFileExtensionMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlFileExtensionMatchConditionParameters(subject UrlFileExtensionMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlFileExtensionMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlFileExtensionMatchConditionParameters instances for property testing - lazily instantiated by
// UrlFileExtensionMatchConditionParametersGenerator()
var urlFileExtensionMatchConditionParametersGenerator gopter.Gen

// UrlFileExtensionMatchConditionParametersGenerator returns a generator of UrlFileExtensionMatchConditionParameters instances for property testing.
func UrlFileExtensionMatchConditionParametersGenerator() gopter.Gen {
	if urlFileExtensionMatchConditionParametersGenerator != nil {
		return urlFileExtensionMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParameters(generators)
	urlFileExtensionMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(UrlFileExtensionMatchConditionParameters{}), generators)

	return urlFileExtensionMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlFileExtensionMatchConditionParameters_Operator_Any,
		UrlFileExtensionMatchConditionParameters_Operator_BeginsWith,
		UrlFileExtensionMatchConditionParameters_Operator_Contains,
		UrlFileExtensionMatchConditionParameters_Operator_EndsWith,
		UrlFileExtensionMatchConditionParameters_Operator_Equal,
		UrlFileExtensionMatchConditionParameters_Operator_GreaterThan,
		UrlFileExtensionMatchConditionParameters_Operator_GreaterThanOrEqual,
		UrlFileExtensionMatchConditionParameters_Operator_LessThan,
		UrlFileExtensionMatchConditionParameters_Operator_LessThanOrEqual,
		UrlFileExtensionMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlFileExtensionMatchConditionParameters_TypeName_DeliveryRuleUrlFileExtensionMatchConditionParameters))
}

func Test_UrlFileExtensionMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlFileExtensionMatchConditionParameters_STATUS to UrlFileExtensionMatchConditionParameters_STATUS via AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS & AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlFileExtensionMatchConditionParameters_STATUS, UrlFileExtensionMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlFileExtensionMatchConditionParameters_STATUS tests if a specific instance of UrlFileExtensionMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlFileExtensionMatchConditionParameters_STATUS(subject UrlFileExtensionMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlFileExtensionMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_UrlFileExtensionMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlFileExtensionMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_UrlFileExtensionMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlFileExtensionMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlFileExtensionMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlFileExtensionMatchConditionParameters_STATUS, UrlFileExtensionMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlFileExtensionMatchConditionParameters_STATUS runs a test to see if a specific instance of UrlFileExtensionMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlFileExtensionMatchConditionParameters_STATUS(subject UrlFileExtensionMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlFileExtensionMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlFileExtensionMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// UrlFileExtensionMatchConditionParameters_STATUSGenerator()
var urlFileExtensionMatchConditionParameters_STATUSGenerator gopter.Gen

// UrlFileExtensionMatchConditionParameters_STATUSGenerator returns a generator of UrlFileExtensionMatchConditionParameters_STATUS instances for property testing.
func UrlFileExtensionMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if urlFileExtensionMatchConditionParameters_STATUSGenerator != nil {
		return urlFileExtensionMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParameters_STATUS(generators)
	urlFileExtensionMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlFileExtensionMatchConditionParameters_STATUS{}), generators)

	return urlFileExtensionMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlFileExtensionMatchConditionParameters_Operator_STATUS_Any,
		UrlFileExtensionMatchConditionParameters_Operator_STATUS_BeginsWith,
		UrlFileExtensionMatchConditionParameters_Operator_STATUS_Contains,
		UrlFileExtensionMatchConditionParameters_Operator_STATUS_EndsWith,
		UrlFileExtensionMatchConditionParameters_Operator_STATUS_Equal,
		UrlFileExtensionMatchConditionParameters_Operator_STATUS_GreaterThan,
		UrlFileExtensionMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
		UrlFileExtensionMatchConditionParameters_Operator_STATUS_LessThan,
		UrlFileExtensionMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
		UrlFileExtensionMatchConditionParameters_Operator_STATUS_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlFileExtensionMatchConditionParameters_TypeName_STATUS_DeliveryRuleUrlFileExtensionMatchConditionParameters))
}

func Test_UrlFileNameMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlFileNameMatchConditionParameters to UrlFileNameMatchConditionParameters via AssignProperties_To_UrlFileNameMatchConditionParameters & AssignProperties_From_UrlFileNameMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlFileNameMatchConditionParameters, UrlFileNameMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlFileNameMatchConditionParameters tests if a specific instance of UrlFileNameMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlFileNameMatchConditionParameters(subject UrlFileNameMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlFileNameMatchConditionParameters
	err := copied.AssignProperties_To_UrlFileNameMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlFileNameMatchConditionParameters
	err = actual.AssignProperties_From_UrlFileNameMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlFileNameMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlFileNameMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlFileNameMatchConditionParameters, UrlFileNameMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlFileNameMatchConditionParameters runs a test to see if a specific instance of UrlFileNameMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlFileNameMatchConditionParameters(subject UrlFileNameMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlFileNameMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlFileNameMatchConditionParameters instances for property testing - lazily instantiated by
// UrlFileNameMatchConditionParametersGenerator()
var urlFileNameMatchConditionParametersGenerator gopter.Gen

// UrlFileNameMatchConditionParametersGenerator returns a generator of UrlFileNameMatchConditionParameters instances for property testing.
func UrlFileNameMatchConditionParametersGenerator() gopter.Gen {
	if urlFileNameMatchConditionParametersGenerator != nil {
		return urlFileNameMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParameters(generators)
	urlFileNameMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(UrlFileNameMatchConditionParameters{}), generators)

	return urlFileNameMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlFileNameMatchConditionParameters_Operator_Any,
		UrlFileNameMatchConditionParameters_Operator_BeginsWith,
		UrlFileNameMatchConditionParameters_Operator_Contains,
		UrlFileNameMatchConditionParameters_Operator_EndsWith,
		UrlFileNameMatchConditionParameters_Operator_Equal,
		UrlFileNameMatchConditionParameters_Operator_GreaterThan,
		UrlFileNameMatchConditionParameters_Operator_GreaterThanOrEqual,
		UrlFileNameMatchConditionParameters_Operator_LessThan,
		UrlFileNameMatchConditionParameters_Operator_LessThanOrEqual,
		UrlFileNameMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlFileNameMatchConditionParameters_TypeName_DeliveryRuleUrlFilenameConditionParameters))
}

func Test_UrlFileNameMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlFileNameMatchConditionParameters_STATUS to UrlFileNameMatchConditionParameters_STATUS via AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS & AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlFileNameMatchConditionParameters_STATUS, UrlFileNameMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlFileNameMatchConditionParameters_STATUS tests if a specific instance of UrlFileNameMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlFileNameMatchConditionParameters_STATUS(subject UrlFileNameMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlFileNameMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_UrlFileNameMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlFileNameMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_UrlFileNameMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlFileNameMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlFileNameMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlFileNameMatchConditionParameters_STATUS, UrlFileNameMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlFileNameMatchConditionParameters_STATUS runs a test to see if a specific instance of UrlFileNameMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlFileNameMatchConditionParameters_STATUS(subject UrlFileNameMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlFileNameMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlFileNameMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// UrlFileNameMatchConditionParameters_STATUSGenerator()
var urlFileNameMatchConditionParameters_STATUSGenerator gopter.Gen

// UrlFileNameMatchConditionParameters_STATUSGenerator returns a generator of UrlFileNameMatchConditionParameters_STATUS instances for property testing.
func UrlFileNameMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if urlFileNameMatchConditionParameters_STATUSGenerator != nil {
		return urlFileNameMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParameters_STATUS(generators)
	urlFileNameMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlFileNameMatchConditionParameters_STATUS{}), generators)

	return urlFileNameMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlFileNameMatchConditionParameters_Operator_STATUS_Any,
		UrlFileNameMatchConditionParameters_Operator_STATUS_BeginsWith,
		UrlFileNameMatchConditionParameters_Operator_STATUS_Contains,
		UrlFileNameMatchConditionParameters_Operator_STATUS_EndsWith,
		UrlFileNameMatchConditionParameters_Operator_STATUS_Equal,
		UrlFileNameMatchConditionParameters_Operator_STATUS_GreaterThan,
		UrlFileNameMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
		UrlFileNameMatchConditionParameters_Operator_STATUS_LessThan,
		UrlFileNameMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
		UrlFileNameMatchConditionParameters_Operator_STATUS_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlFileNameMatchConditionParameters_TypeName_STATUS_DeliveryRuleUrlFilenameConditionParameters))
}

func Test_UrlPathMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlPathMatchConditionParameters to UrlPathMatchConditionParameters via AssignProperties_To_UrlPathMatchConditionParameters & AssignProperties_From_UrlPathMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlPathMatchConditionParameters, UrlPathMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlPathMatchConditionParameters tests if a specific instance of UrlPathMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlPathMatchConditionParameters(subject UrlPathMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlPathMatchConditionParameters
	err := copied.AssignProperties_To_UrlPathMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlPathMatchConditionParameters
	err = actual.AssignProperties_From_UrlPathMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlPathMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlPathMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlPathMatchConditionParameters, UrlPathMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlPathMatchConditionParameters runs a test to see if a specific instance of UrlPathMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlPathMatchConditionParameters(subject UrlPathMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlPathMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlPathMatchConditionParameters instances for property testing - lazily instantiated by
// UrlPathMatchConditionParametersGenerator()
var urlPathMatchConditionParametersGenerator gopter.Gen

// UrlPathMatchConditionParametersGenerator returns a generator of UrlPathMatchConditionParameters instances for property testing.
func UrlPathMatchConditionParametersGenerator() gopter.Gen {
	if urlPathMatchConditionParametersGenerator != nil {
		return urlPathMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlPathMatchConditionParameters(generators)
	urlPathMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(UrlPathMatchConditionParameters{}), generators)

	return urlPathMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForUrlPathMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlPathMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlPathMatchConditionParameters_Operator_Any,
		UrlPathMatchConditionParameters_Operator_BeginsWith,
		UrlPathMatchConditionParameters_Operator_Contains,
		UrlPathMatchConditionParameters_Operator_EndsWith,
		UrlPathMatchConditionParameters_Operator_Equal,
		UrlPathMatchConditionParameters_Operator_GreaterThan,
		UrlPathMatchConditionParameters_Operator_GreaterThanOrEqual,
		UrlPathMatchConditionParameters_Operator_LessThan,
		UrlPathMatchConditionParameters_Operator_LessThanOrEqual,
		UrlPathMatchConditionParameters_Operator_RegEx,
		UrlPathMatchConditionParameters_Operator_Wildcard))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlPathMatchConditionParameters_TypeName_DeliveryRuleUrlPathMatchConditionParameters))
}

func Test_UrlPathMatchConditionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlPathMatchConditionParameters_STATUS to UrlPathMatchConditionParameters_STATUS via AssignProperties_To_UrlPathMatchConditionParameters_STATUS & AssignProperties_From_UrlPathMatchConditionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlPathMatchConditionParameters_STATUS, UrlPathMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlPathMatchConditionParameters_STATUS tests if a specific instance of UrlPathMatchConditionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlPathMatchConditionParameters_STATUS(subject UrlPathMatchConditionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlPathMatchConditionParameters_STATUS
	err := copied.AssignProperties_To_UrlPathMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlPathMatchConditionParameters_STATUS
	err = actual.AssignProperties_From_UrlPathMatchConditionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlPathMatchConditionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlPathMatchConditionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlPathMatchConditionParameters_STATUS, UrlPathMatchConditionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlPathMatchConditionParameters_STATUS runs a test to see if a specific instance of UrlPathMatchConditionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlPathMatchConditionParameters_STATUS(subject UrlPathMatchConditionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlPathMatchConditionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlPathMatchConditionParameters_STATUS instances for property testing - lazily instantiated by
// UrlPathMatchConditionParameters_STATUSGenerator()
var urlPathMatchConditionParameters_STATUSGenerator gopter.Gen

// UrlPathMatchConditionParameters_STATUSGenerator returns a generator of UrlPathMatchConditionParameters_STATUS instances for property testing.
func UrlPathMatchConditionParameters_STATUSGenerator() gopter.Gen {
	if urlPathMatchConditionParameters_STATUSGenerator != nil {
		return urlPathMatchConditionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlPathMatchConditionParameters_STATUS(generators)
	urlPathMatchConditionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlPathMatchConditionParameters_STATUS{}), generators)

	return urlPathMatchConditionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUrlPathMatchConditionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlPathMatchConditionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlPathMatchConditionParameters_Operator_STATUS_Any,
		UrlPathMatchConditionParameters_Operator_STATUS_BeginsWith,
		UrlPathMatchConditionParameters_Operator_STATUS_Contains,
		UrlPathMatchConditionParameters_Operator_STATUS_EndsWith,
		UrlPathMatchConditionParameters_Operator_STATUS_Equal,
		UrlPathMatchConditionParameters_Operator_STATUS_GreaterThan,
		UrlPathMatchConditionParameters_Operator_STATUS_GreaterThanOrEqual,
		UrlPathMatchConditionParameters_Operator_STATUS_LessThan,
		UrlPathMatchConditionParameters_Operator_STATUS_LessThanOrEqual,
		UrlPathMatchConditionParameters_Operator_STATUS_RegEx,
		UrlPathMatchConditionParameters_Operator_STATUS_Wildcard))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_STATUS_Lowercase,
		Transform_STATUS_RemoveNulls,
		Transform_STATUS_Trim,
		Transform_STATUS_Uppercase,
		Transform_STATUS_UrlDecode,
		Transform_STATUS_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlPathMatchConditionParameters_TypeName_STATUS_DeliveryRuleUrlPathMatchConditionParameters))
}

func Test_UrlRedirectActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlRedirectActionParameters to UrlRedirectActionParameters via AssignProperties_To_UrlRedirectActionParameters & AssignProperties_From_UrlRedirectActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlRedirectActionParameters, UrlRedirectActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlRedirectActionParameters tests if a specific instance of UrlRedirectActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlRedirectActionParameters(subject UrlRedirectActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlRedirectActionParameters
	err := copied.AssignProperties_To_UrlRedirectActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlRedirectActionParameters
	err = actual.AssignProperties_From_UrlRedirectActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlRedirectActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRedirectActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRedirectActionParameters, UrlRedirectActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRedirectActionParameters runs a test to see if a specific instance of UrlRedirectActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRedirectActionParameters(subject UrlRedirectActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRedirectActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRedirectActionParameters instances for property testing - lazily instantiated by
// UrlRedirectActionParametersGenerator()
var urlRedirectActionParametersGenerator gopter.Gen

// UrlRedirectActionParametersGenerator returns a generator of UrlRedirectActionParameters instances for property testing.
func UrlRedirectActionParametersGenerator() gopter.Gen {
	if urlRedirectActionParametersGenerator != nil {
		return urlRedirectActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectActionParameters(generators)
	urlRedirectActionParametersGenerator = gen.Struct(reflect.TypeOf(UrlRedirectActionParameters{}), generators)

	return urlRedirectActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForUrlRedirectActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRedirectActionParameters(gens map[string]gopter.Gen) {
	gens["CustomFragment"] = gen.PtrOf(gen.AlphaString())
	gens["CustomHostname"] = gen.PtrOf(gen.AlphaString())
	gens["CustomPath"] = gen.PtrOf(gen.AlphaString())
	gens["CustomQueryString"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationProtocol"] = gen.PtrOf(gen.OneConstOf(UrlRedirectActionParameters_DestinationProtocol_Http, UrlRedirectActionParameters_DestinationProtocol_Https, UrlRedirectActionParameters_DestinationProtocol_MatchRequest))
	gens["RedirectType"] = gen.PtrOf(gen.OneConstOf(
		UrlRedirectActionParameters_RedirectType_Found,
		UrlRedirectActionParameters_RedirectType_Moved,
		UrlRedirectActionParameters_RedirectType_PermanentRedirect,
		UrlRedirectActionParameters_RedirectType_TemporaryRedirect))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlRedirectActionParameters_TypeName_DeliveryRuleUrlRedirectActionParameters))
}

func Test_UrlRedirectActionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlRedirectActionParameters_STATUS to UrlRedirectActionParameters_STATUS via AssignProperties_To_UrlRedirectActionParameters_STATUS & AssignProperties_From_UrlRedirectActionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlRedirectActionParameters_STATUS, UrlRedirectActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlRedirectActionParameters_STATUS tests if a specific instance of UrlRedirectActionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlRedirectActionParameters_STATUS(subject UrlRedirectActionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlRedirectActionParameters_STATUS
	err := copied.AssignProperties_To_UrlRedirectActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlRedirectActionParameters_STATUS
	err = actual.AssignProperties_From_UrlRedirectActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlRedirectActionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRedirectActionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRedirectActionParameters_STATUS, UrlRedirectActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRedirectActionParameters_STATUS runs a test to see if a specific instance of UrlRedirectActionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRedirectActionParameters_STATUS(subject UrlRedirectActionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRedirectActionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRedirectActionParameters_STATUS instances for property testing - lazily instantiated by
// UrlRedirectActionParameters_STATUSGenerator()
var urlRedirectActionParameters_STATUSGenerator gopter.Gen

// UrlRedirectActionParameters_STATUSGenerator returns a generator of UrlRedirectActionParameters_STATUS instances for property testing.
func UrlRedirectActionParameters_STATUSGenerator() gopter.Gen {
	if urlRedirectActionParameters_STATUSGenerator != nil {
		return urlRedirectActionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectActionParameters_STATUS(generators)
	urlRedirectActionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlRedirectActionParameters_STATUS{}), generators)

	return urlRedirectActionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUrlRedirectActionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRedirectActionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["CustomFragment"] = gen.PtrOf(gen.AlphaString())
	gens["CustomHostname"] = gen.PtrOf(gen.AlphaString())
	gens["CustomPath"] = gen.PtrOf(gen.AlphaString())
	gens["CustomQueryString"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationProtocol"] = gen.PtrOf(gen.OneConstOf(UrlRedirectActionParameters_DestinationProtocol_STATUS_Http, UrlRedirectActionParameters_DestinationProtocol_STATUS_Https, UrlRedirectActionParameters_DestinationProtocol_STATUS_MatchRequest))
	gens["RedirectType"] = gen.PtrOf(gen.OneConstOf(
		UrlRedirectActionParameters_RedirectType_STATUS_Found,
		UrlRedirectActionParameters_RedirectType_STATUS_Moved,
		UrlRedirectActionParameters_RedirectType_STATUS_PermanentRedirect,
		UrlRedirectActionParameters_RedirectType_STATUS_TemporaryRedirect))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlRedirectActionParameters_TypeName_STATUS_DeliveryRuleUrlRedirectActionParameters))
}

func Test_UrlRewriteActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlRewriteActionParameters to UrlRewriteActionParameters via AssignProperties_To_UrlRewriteActionParameters & AssignProperties_From_UrlRewriteActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlRewriteActionParameters, UrlRewriteActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlRewriteActionParameters tests if a specific instance of UrlRewriteActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlRewriteActionParameters(subject UrlRewriteActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlRewriteActionParameters
	err := copied.AssignProperties_To_UrlRewriteActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlRewriteActionParameters
	err = actual.AssignProperties_From_UrlRewriteActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlRewriteActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRewriteActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRewriteActionParameters, UrlRewriteActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRewriteActionParameters runs a test to see if a specific instance of UrlRewriteActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRewriteActionParameters(subject UrlRewriteActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRewriteActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRewriteActionParameters instances for property testing - lazily instantiated by
// UrlRewriteActionParametersGenerator()
var urlRewriteActionParametersGenerator gopter.Gen

// UrlRewriteActionParametersGenerator returns a generator of UrlRewriteActionParameters instances for property testing.
func UrlRewriteActionParametersGenerator() gopter.Gen {
	if urlRewriteActionParametersGenerator != nil {
		return urlRewriteActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteActionParameters(generators)
	urlRewriteActionParametersGenerator = gen.Struct(reflect.TypeOf(UrlRewriteActionParameters{}), generators)

	return urlRewriteActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForUrlRewriteActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRewriteActionParameters(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(gen.AlphaString())
	gens["PreserveUnmatchedPath"] = gen.PtrOf(gen.Bool())
	gens["SourcePattern"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlRewriteActionParameters_TypeName_DeliveryRuleUrlRewriteActionParameters))
}

func Test_UrlRewriteActionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlRewriteActionParameters_STATUS to UrlRewriteActionParameters_STATUS via AssignProperties_To_UrlRewriteActionParameters_STATUS & AssignProperties_From_UrlRewriteActionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlRewriteActionParameters_STATUS, UrlRewriteActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlRewriteActionParameters_STATUS tests if a specific instance of UrlRewriteActionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlRewriteActionParameters_STATUS(subject UrlRewriteActionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlRewriteActionParameters_STATUS
	err := copied.AssignProperties_To_UrlRewriteActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlRewriteActionParameters_STATUS
	err = actual.AssignProperties_From_UrlRewriteActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlRewriteActionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRewriteActionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRewriteActionParameters_STATUS, UrlRewriteActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRewriteActionParameters_STATUS runs a test to see if a specific instance of UrlRewriteActionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRewriteActionParameters_STATUS(subject UrlRewriteActionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRewriteActionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRewriteActionParameters_STATUS instances for property testing - lazily instantiated by
// UrlRewriteActionParameters_STATUSGenerator()
var urlRewriteActionParameters_STATUSGenerator gopter.Gen

// UrlRewriteActionParameters_STATUSGenerator returns a generator of UrlRewriteActionParameters_STATUS instances for property testing.
func UrlRewriteActionParameters_STATUSGenerator() gopter.Gen {
	if urlRewriteActionParameters_STATUSGenerator != nil {
		return urlRewriteActionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteActionParameters_STATUS(generators)
	urlRewriteActionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlRewriteActionParameters_STATUS{}), generators)

	return urlRewriteActionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUrlRewriteActionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRewriteActionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(gen.AlphaString())
	gens["PreserveUnmatchedPath"] = gen.PtrOf(gen.Bool())
	gens["SourcePattern"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlRewriteActionParameters_TypeName_STATUS_DeliveryRuleUrlRewriteActionParameters))
}

func Test_UrlSigningActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningActionParameters to UrlSigningActionParameters via AssignProperties_To_UrlSigningActionParameters & AssignProperties_From_UrlSigningActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningActionParameters, UrlSigningActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningActionParameters tests if a specific instance of UrlSigningActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningActionParameters(subject UrlSigningActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningActionParameters
	err := copied.AssignProperties_To_UrlSigningActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningActionParameters
	err = actual.AssignProperties_From_UrlSigningActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningActionParameters, UrlSigningActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningActionParameters runs a test to see if a specific instance of UrlSigningActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningActionParameters(subject UrlSigningActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningActionParameters instances for property testing - lazily instantiated by
// UrlSigningActionParametersGenerator()
var urlSigningActionParametersGenerator gopter.Gen

// UrlSigningActionParametersGenerator returns a generator of UrlSigningActionParameters instances for property testing.
// We first initialize urlSigningActionParametersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningActionParametersGenerator() gopter.Gen {
	if urlSigningActionParametersGenerator != nil {
		return urlSigningActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionParameters(generators)
	urlSigningActionParametersGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionParameters{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionParameters(generators)
	AddRelatedPropertyGeneratorsForUrlSigningActionParameters(generators)
	urlSigningActionParametersGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionParameters{}), generators)

	return urlSigningActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningActionParameters(gens map[string]gopter.Gen) {
	gens["Algorithm"] = gen.PtrOf(gen.OneConstOf(UrlSigningActionParameters_Algorithm_SHA256))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlSigningActionParameters_TypeName_DeliveryRuleUrlSigningActionParameters))
}

// AddRelatedPropertyGeneratorsForUrlSigningActionParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningActionParameters(gens map[string]gopter.Gen) {
	gens["ParameterNameOverride"] = gen.SliceOf(UrlSigningParamIdentifierGenerator())
}

func Test_UrlSigningActionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningActionParameters_STATUS to UrlSigningActionParameters_STATUS via AssignProperties_To_UrlSigningActionParameters_STATUS & AssignProperties_From_UrlSigningActionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningActionParameters_STATUS, UrlSigningActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningActionParameters_STATUS tests if a specific instance of UrlSigningActionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningActionParameters_STATUS(subject UrlSigningActionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningActionParameters_STATUS
	err := copied.AssignProperties_To_UrlSigningActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningActionParameters_STATUS
	err = actual.AssignProperties_From_UrlSigningActionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningActionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningActionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningActionParameters_STATUS, UrlSigningActionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningActionParameters_STATUS runs a test to see if a specific instance of UrlSigningActionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningActionParameters_STATUS(subject UrlSigningActionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningActionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningActionParameters_STATUS instances for property testing - lazily instantiated by
// UrlSigningActionParameters_STATUSGenerator()
var urlSigningActionParameters_STATUSGenerator gopter.Gen

// UrlSigningActionParameters_STATUSGenerator returns a generator of UrlSigningActionParameters_STATUS instances for property testing.
// We first initialize urlSigningActionParameters_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningActionParameters_STATUSGenerator() gopter.Gen {
	if urlSigningActionParameters_STATUSGenerator != nil {
		return urlSigningActionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionParameters_STATUS(generators)
	urlSigningActionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionParameters_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionParameters_STATUS(generators)
	AddRelatedPropertyGeneratorsForUrlSigningActionParameters_STATUS(generators)
	urlSigningActionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionParameters_STATUS{}), generators)

	return urlSigningActionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningActionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningActionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["Algorithm"] = gen.PtrOf(gen.OneConstOf(UrlSigningActionParameters_Algorithm_STATUS_SHA256))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlSigningActionParameters_TypeName_STATUS_DeliveryRuleUrlSigningActionParameters))
}

// AddRelatedPropertyGeneratorsForUrlSigningActionParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningActionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["ParameterNameOverride"] = gen.SliceOf(UrlSigningParamIdentifier_STATUSGenerator())
}

func Test_CacheConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CacheConfiguration to CacheConfiguration via AssignProperties_To_CacheConfiguration & AssignProperties_From_CacheConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForCacheConfiguration, CacheConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCacheConfiguration tests if a specific instance of CacheConfiguration can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCacheConfiguration(subject CacheConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CacheConfiguration
	err := copied.AssignProperties_To_CacheConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CacheConfiguration
	err = actual.AssignProperties_From_CacheConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CacheConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheConfiguration, CacheConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheConfiguration runs a test to see if a specific instance of CacheConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheConfiguration(subject CacheConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheConfiguration instances for property testing - lazily instantiated by CacheConfigurationGenerator()
var cacheConfigurationGenerator gopter.Gen

// CacheConfigurationGenerator returns a generator of CacheConfiguration instances for property testing.
func CacheConfigurationGenerator() gopter.Gen {
	if cacheConfigurationGenerator != nil {
		return cacheConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheConfiguration(generators)
	cacheConfigurationGenerator = gen.Struct(reflect.TypeOf(CacheConfiguration{}), generators)

	return cacheConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForCacheConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheConfiguration(gens map[string]gopter.Gen) {
	gens["CacheBehavior"] = gen.PtrOf(gen.OneConstOf(CacheConfiguration_CacheBehavior_HonorOrigin, CacheConfiguration_CacheBehavior_OverrideAlways, CacheConfiguration_CacheBehavior_OverrideIfOriginMissing))
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.OneConstOf(CacheConfiguration_IsCompressionEnabled_Disabled, CacheConfiguration_IsCompressionEnabled_Enabled))
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		CacheConfiguration_QueryStringCachingBehavior_IgnoreQueryString,
		CacheConfiguration_QueryStringCachingBehavior_IgnoreSpecifiedQueryStrings,
		CacheConfiguration_QueryStringCachingBehavior_IncludeSpecifiedQueryStrings,
		CacheConfiguration_QueryStringCachingBehavior_UseQueryString))
}

func Test_CacheConfiguration_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CacheConfiguration_STATUS to CacheConfiguration_STATUS via AssignProperties_To_CacheConfiguration_STATUS & AssignProperties_From_CacheConfiguration_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCacheConfiguration_STATUS, CacheConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCacheConfiguration_STATUS tests if a specific instance of CacheConfiguration_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCacheConfiguration_STATUS(subject CacheConfiguration_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CacheConfiguration_STATUS
	err := copied.AssignProperties_To_CacheConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CacheConfiguration_STATUS
	err = actual.AssignProperties_From_CacheConfiguration_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CacheConfiguration_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheConfiguration_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheConfiguration_STATUS, CacheConfiguration_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheConfiguration_STATUS runs a test to see if a specific instance of CacheConfiguration_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheConfiguration_STATUS(subject CacheConfiguration_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheConfiguration_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheConfiguration_STATUS instances for property testing - lazily instantiated by
// CacheConfiguration_STATUSGenerator()
var cacheConfiguration_STATUSGenerator gopter.Gen

// CacheConfiguration_STATUSGenerator returns a generator of CacheConfiguration_STATUS instances for property testing.
func CacheConfiguration_STATUSGenerator() gopter.Gen {
	if cacheConfiguration_STATUSGenerator != nil {
		return cacheConfiguration_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheConfiguration_STATUS(generators)
	cacheConfiguration_STATUSGenerator = gen.Struct(reflect.TypeOf(CacheConfiguration_STATUS{}), generators)

	return cacheConfiguration_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCacheConfiguration_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheConfiguration_STATUS(gens map[string]gopter.Gen) {
	gens["CacheBehavior"] = gen.PtrOf(gen.OneConstOf(CacheConfiguration_CacheBehavior_STATUS_HonorOrigin, CacheConfiguration_CacheBehavior_STATUS_OverrideAlways, CacheConfiguration_CacheBehavior_STATUS_OverrideIfOriginMissing))
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.OneConstOf(CacheConfiguration_IsCompressionEnabled_STATUS_Disabled, CacheConfiguration_IsCompressionEnabled_STATUS_Enabled))
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		CacheConfiguration_QueryStringCachingBehavior_STATUS_IgnoreQueryString,
		CacheConfiguration_QueryStringCachingBehavior_STATUS_IgnoreSpecifiedQueryStrings,
		CacheConfiguration_QueryStringCachingBehavior_STATUS_IncludeSpecifiedQueryStrings,
		CacheConfiguration_QueryStringCachingBehavior_STATUS_UseQueryString))
}

func Test_OriginGroupOverride_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OriginGroupOverride to OriginGroupOverride via AssignProperties_To_OriginGroupOverride & AssignProperties_From_OriginGroupOverride returns original",
		prop.ForAll(RunPropertyAssignmentTestForOriginGroupOverride, OriginGroupOverrideGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOriginGroupOverride tests if a specific instance of OriginGroupOverride can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForOriginGroupOverride(subject OriginGroupOverride) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.OriginGroupOverride
	err := copied.AssignProperties_To_OriginGroupOverride(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OriginGroupOverride
	err = actual.AssignProperties_From_OriginGroupOverride(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OriginGroupOverride_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverride via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverride, OriginGroupOverrideGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverride runs a test to see if a specific instance of OriginGroupOverride round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverride(subject OriginGroupOverride) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverride
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverride instances for property testing - lazily instantiated by
// OriginGroupOverrideGenerator()
var originGroupOverrideGenerator gopter.Gen

// OriginGroupOverrideGenerator returns a generator of OriginGroupOverride instances for property testing.
// We first initialize originGroupOverrideGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideGenerator() gopter.Gen {
	if originGroupOverrideGenerator != nil {
		return originGroupOverrideGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverride(generators)
	originGroupOverrideGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverride{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverride(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverride(generators)
	originGroupOverrideGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverride{}), generators)

	return originGroupOverrideGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverride is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverride(gens map[string]gopter.Gen) {
	gens["ForwardingProtocol"] = gen.PtrOf(gen.OneConstOf(OriginGroupOverride_ForwardingProtocol_HttpOnly, OriginGroupOverride_ForwardingProtocol_HttpsOnly, OriginGroupOverride_ForwardingProtocol_MatchRequest))
}

// AddRelatedPropertyGeneratorsForOriginGroupOverride is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverride(gens map[string]gopter.Gen) {
	gens["OriginGroup"] = gen.PtrOf(ResourceReferenceGenerator())
}

func Test_OriginGroupOverride_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OriginGroupOverride_STATUS to OriginGroupOverride_STATUS via AssignProperties_To_OriginGroupOverride_STATUS & AssignProperties_From_OriginGroupOverride_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForOriginGroupOverride_STATUS, OriginGroupOverride_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOriginGroupOverride_STATUS tests if a specific instance of OriginGroupOverride_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForOriginGroupOverride_STATUS(subject OriginGroupOverride_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.OriginGroupOverride_STATUS
	err := copied.AssignProperties_To_OriginGroupOverride_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OriginGroupOverride_STATUS
	err = actual.AssignProperties_From_OriginGroupOverride_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OriginGroupOverride_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverride_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverride_STATUS, OriginGroupOverride_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverride_STATUS runs a test to see if a specific instance of OriginGroupOverride_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverride_STATUS(subject OriginGroupOverride_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverride_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverride_STATUS instances for property testing - lazily instantiated by
// OriginGroupOverride_STATUSGenerator()
var originGroupOverride_STATUSGenerator gopter.Gen

// OriginGroupOverride_STATUSGenerator returns a generator of OriginGroupOverride_STATUS instances for property testing.
// We first initialize originGroupOverride_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverride_STATUSGenerator() gopter.Gen {
	if originGroupOverride_STATUSGenerator != nil {
		return originGroupOverride_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverride_STATUS(generators)
	originGroupOverride_STATUSGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverride_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverride_STATUS(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverride_STATUS(generators)
	originGroupOverride_STATUSGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverride_STATUS{}), generators)

	return originGroupOverride_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverride_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverride_STATUS(gens map[string]gopter.Gen) {
	gens["ForwardingProtocol"] = gen.PtrOf(gen.OneConstOf(OriginGroupOverride_ForwardingProtocol_STATUS_HttpOnly, OriginGroupOverride_ForwardingProtocol_STATUS_HttpsOnly, OriginGroupOverride_ForwardingProtocol_STATUS_MatchRequest))
}

// AddRelatedPropertyGeneratorsForOriginGroupOverride_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverride_STATUS(gens map[string]gopter.Gen) {
	gens["OriginGroup"] = gen.PtrOf(ResourceReference_STATUSGenerator())
}

func Test_UrlSigningParamIdentifier_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningParamIdentifier to UrlSigningParamIdentifier via AssignProperties_To_UrlSigningParamIdentifier & AssignProperties_From_UrlSigningParamIdentifier returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningParamIdentifier, UrlSigningParamIdentifierGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningParamIdentifier tests if a specific instance of UrlSigningParamIdentifier can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningParamIdentifier(subject UrlSigningParamIdentifier) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningParamIdentifier
	err := copied.AssignProperties_To_UrlSigningParamIdentifier(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningParamIdentifier
	err = actual.AssignProperties_From_UrlSigningParamIdentifier(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningParamIdentifier_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningParamIdentifier via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningParamIdentifier, UrlSigningParamIdentifierGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningParamIdentifier runs a test to see if a specific instance of UrlSigningParamIdentifier round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningParamIdentifier(subject UrlSigningParamIdentifier) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningParamIdentifier
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningParamIdentifier instances for property testing - lazily instantiated by
// UrlSigningParamIdentifierGenerator()
var urlSigningParamIdentifierGenerator gopter.Gen

// UrlSigningParamIdentifierGenerator returns a generator of UrlSigningParamIdentifier instances for property testing.
func UrlSigningParamIdentifierGenerator() gopter.Gen {
	if urlSigningParamIdentifierGenerator != nil {
		return urlSigningParamIdentifierGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningParamIdentifier(generators)
	urlSigningParamIdentifierGenerator = gen.Struct(reflect.TypeOf(UrlSigningParamIdentifier{}), generators)

	return urlSigningParamIdentifierGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningParamIdentifier is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningParamIdentifier(gens map[string]gopter.Gen) {
	gens["ParamIndicator"] = gen.PtrOf(gen.OneConstOf(UrlSigningParamIdentifier_ParamIndicator_Expires, UrlSigningParamIdentifier_ParamIndicator_KeyId, UrlSigningParamIdentifier_ParamIndicator_Signature))
	gens["ParamName"] = gen.PtrOf(gen.AlphaString())
}

func Test_UrlSigningParamIdentifier_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningParamIdentifier_STATUS to UrlSigningParamIdentifier_STATUS via AssignProperties_To_UrlSigningParamIdentifier_STATUS & AssignProperties_From_UrlSigningParamIdentifier_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningParamIdentifier_STATUS, UrlSigningParamIdentifier_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningParamIdentifier_STATUS tests if a specific instance of UrlSigningParamIdentifier_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningParamIdentifier_STATUS(subject UrlSigningParamIdentifier_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningParamIdentifier_STATUS
	err := copied.AssignProperties_To_UrlSigningParamIdentifier_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningParamIdentifier_STATUS
	err = actual.AssignProperties_From_UrlSigningParamIdentifier_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningParamIdentifier_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningParamIdentifier_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningParamIdentifier_STATUS, UrlSigningParamIdentifier_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningParamIdentifier_STATUS runs a test to see if a specific instance of UrlSigningParamIdentifier_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningParamIdentifier_STATUS(subject UrlSigningParamIdentifier_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningParamIdentifier_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningParamIdentifier_STATUS instances for property testing - lazily instantiated by
// UrlSigningParamIdentifier_STATUSGenerator()
var urlSigningParamIdentifier_STATUSGenerator gopter.Gen

// UrlSigningParamIdentifier_STATUSGenerator returns a generator of UrlSigningParamIdentifier_STATUS instances for property testing.
func UrlSigningParamIdentifier_STATUSGenerator() gopter.Gen {
	if urlSigningParamIdentifier_STATUSGenerator != nil {
		return urlSigningParamIdentifier_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningParamIdentifier_STATUS(generators)
	urlSigningParamIdentifier_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlSigningParamIdentifier_STATUS{}), generators)

	return urlSigningParamIdentifier_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningParamIdentifier_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningParamIdentifier_STATUS(gens map[string]gopter.Gen) {
	gens["ParamIndicator"] = gen.PtrOf(gen.OneConstOf(UrlSigningParamIdentifier_ParamIndicator_STATUS_Expires, UrlSigningParamIdentifier_ParamIndicator_STATUS_KeyId, UrlSigningParamIdentifier_ParamIndicator_STATUS_Signature))
	gens["ParamName"] = gen.PtrOf(gen.AlphaString())
}
