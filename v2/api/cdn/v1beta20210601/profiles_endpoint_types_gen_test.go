// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210601

import (
	"encoding/json"
	v20210601s "github.com/Azure/azure-service-operator/v2/api/cdn/v1beta20210601storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ProfilesEndpoint_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	parameters.MinSuccessfulTests = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ProfilesEndpoint to hub returns original",
		prop.ForAll(RunResourceConversionTestForProfilesEndpoint, ProfilesEndpointGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForProfilesEndpoint tests if a specific instance of ProfilesEndpoint round trips to the hub storage version and back losslessly
func RunResourceConversionTestForProfilesEndpoint(subject ProfilesEndpoint) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20210601s.ProfilesEndpoint
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual ProfilesEndpoint
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ProfilesEndpoint_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ProfilesEndpoint to ProfilesEndpoint via AssignPropertiesToProfilesEndpoint & AssignPropertiesFromProfilesEndpoint returns original",
		prop.ForAll(RunPropertyAssignmentTestForProfilesEndpoint, ProfilesEndpointGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProfilesEndpoint tests if a specific instance of ProfilesEndpoint can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForProfilesEndpoint(subject ProfilesEndpoint) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ProfilesEndpoint
	err := copied.AssignPropertiesToProfilesEndpoint(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ProfilesEndpoint
	err = actual.AssignPropertiesFromProfilesEndpoint(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ProfilesEndpoint_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProfilesEndpoint via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfilesEndpoint, ProfilesEndpointGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfilesEndpoint runs a test to see if a specific instance of ProfilesEndpoint round trips to JSON and back losslessly
func RunJSONSerializationTestForProfilesEndpoint(subject ProfilesEndpoint) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProfilesEndpoint
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProfilesEndpoint instances for property testing - lazily instantiated by ProfilesEndpointGenerator()
var profilesEndpointGenerator gopter.Gen

// ProfilesEndpointGenerator returns a generator of ProfilesEndpoint instances for property testing.
func ProfilesEndpointGenerator() gopter.Gen {
	if profilesEndpointGenerator != nil {
		return profilesEndpointGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForProfilesEndpoint(generators)
	profilesEndpointGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoint{}), generators)

	return profilesEndpointGenerator
}

// AddRelatedPropertyGeneratorsForProfilesEndpoint is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfilesEndpoint(gens map[string]gopter.Gen) {
	gens["Spec"] = ProfilesEndpointsSpecGenerator()
	gens["Status"] = EndpointSTATUSGenerator()
}

func Test_Endpoint_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from Endpoint_STATUS to Endpoint_STATUS via AssignPropertiesToEndpointSTATUS & AssignPropertiesFromEndpointSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEndpointSTATUS, EndpointSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEndpointSTATUS tests if a specific instance of Endpoint_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForEndpointSTATUS(subject Endpoint_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.Endpoint_STATUS
	err := copied.AssignPropertiesToEndpointSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual Endpoint_STATUS
	err = actual.AssignPropertiesFromEndpointSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_Endpoint_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Endpoint_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointSTATUS, EndpointSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointSTATUS runs a test to see if a specific instance of Endpoint_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointSTATUS(subject Endpoint_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Endpoint_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Endpoint_STATUS instances for property testing - lazily instantiated by EndpointSTATUSGenerator()
var endpointSTATUSGenerator gopter.Gen

// EndpointSTATUSGenerator returns a generator of Endpoint_STATUS instances for property testing.
// We first initialize endpointSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EndpointSTATUSGenerator() gopter.Gen {
	if endpointSTATUSGenerator != nil {
		return endpointSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointSTATUS(generators)
	endpointSTATUSGenerator = gen.Struct(reflect.TypeOf(Endpoint_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointSTATUS(generators)
	AddRelatedPropertyGeneratorsForEndpointSTATUS(generators)
	endpointSTATUSGenerator = gen.Struct(reflect.TypeOf(Endpoint_STATUS{}), generators)

	return endpointSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForEndpointSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointSTATUS(gens map[string]gopter.Gen) {
	gens["ContentTypesToCompress"] = gen.SliceOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsHttpAllowed"] = gen.PtrOf(gen.Bool())
	gens["IsHttpsAllowed"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OptimizationType"] = gen.PtrOf(gen.OneConstOf(
		OptimizationType_STATUS_DynamicSiteAcceleration,
		OptimizationType_STATUS_GeneralMediaStreaming,
		OptimizationType_STATUS_GeneralWebDelivery,
		OptimizationType_STATUS_LargeFileDownload,
		OptimizationType_STATUS_VideoOnDemandMediaStreaming))
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["OriginPath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		EndpointPropertiesSTATUSProvisioningState_Creating,
		EndpointPropertiesSTATUSProvisioningState_Deleting,
		EndpointPropertiesSTATUSProvisioningState_Failed,
		EndpointPropertiesSTATUSProvisioningState_Succeeded,
		EndpointPropertiesSTATUSProvisioningState_Updating))
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		QueryStringCachingBehavior_STATUS_BypassCaching,
		QueryStringCachingBehavior_STATUS_IgnoreQueryString,
		QueryStringCachingBehavior_STATUS_NotSet,
		QueryStringCachingBehavior_STATUS_UseQueryString))
	gens["ResourceState"] = gen.PtrOf(gen.OneConstOf(
		EndpointPropertiesSTATUSResourceState_Creating,
		EndpointPropertiesSTATUSResourceState_Deleting,
		EndpointPropertiesSTATUSResourceState_Running,
		EndpointPropertiesSTATUSResourceState_Starting,
		EndpointPropertiesSTATUSResourceState_Stopped,
		EndpointPropertiesSTATUSResourceState_Stopping))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEndpointSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpointSTATUS(gens map[string]gopter.Gen) {
	gens["CustomDomains"] = gen.SliceOf(CustomDomainSTATUSSubResourceEmbeddedGenerator())
	gens["DefaultOriginGroup"] = gen.PtrOf(ResourceReferenceSTATUSGenerator())
	gens["DeliveryPolicy"] = gen.PtrOf(EndpointPropertiesSTATUSDeliveryPolicyGenerator())
	gens["GeoFilters"] = gen.SliceOf(GeoFilterSTATUSGenerator())
	gens["OriginGroups"] = gen.SliceOf(DeepCreatedOriginGroupSTATUSGenerator())
	gens["Origins"] = gen.SliceOf(DeepCreatedOriginSTATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSGenerator())
	gens["UrlSigningKeys"] = gen.SliceOf(UrlSigningKeySTATUSGenerator())
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(EndpointPropertiesSTATUSWebApplicationFirewallPolicyLinkGenerator())
}

func Test_ProfilesEndpoints_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ProfilesEndpoints_Spec to ProfilesEndpoints_Spec via AssignPropertiesToProfilesEndpointsSpec & AssignPropertiesFromProfilesEndpointsSpec returns original",
		prop.ForAll(RunPropertyAssignmentTestForProfilesEndpointsSpec, ProfilesEndpointsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProfilesEndpointsSpec tests if a specific instance of ProfilesEndpoints_Spec can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForProfilesEndpointsSpec(subject ProfilesEndpoints_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ProfilesEndpoints_Spec
	err := copied.AssignPropertiesToProfilesEndpointsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ProfilesEndpoints_Spec
	err = actual.AssignPropertiesFromProfilesEndpointsSpec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ProfilesEndpoints_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProfilesEndpoints_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfilesEndpointsSpec, ProfilesEndpointsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfilesEndpointsSpec runs a test to see if a specific instance of ProfilesEndpoints_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForProfilesEndpointsSpec(subject ProfilesEndpoints_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProfilesEndpoints_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProfilesEndpoints_Spec instances for property testing - lazily instantiated by
// ProfilesEndpointsSpecGenerator()
var profilesEndpointsSpecGenerator gopter.Gen

// ProfilesEndpointsSpecGenerator returns a generator of ProfilesEndpoints_Spec instances for property testing.
// We first initialize profilesEndpointsSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProfilesEndpointsSpecGenerator() gopter.Gen {
	if profilesEndpointsSpecGenerator != nil {
		return profilesEndpointsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpointsSpec(generators)
	profilesEndpointsSpecGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoints_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpointsSpec(generators)
	AddRelatedPropertyGeneratorsForProfilesEndpointsSpec(generators)
	profilesEndpointsSpecGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoints_Spec{}), generators)

	return profilesEndpointsSpecGenerator
}

// AddIndependentPropertyGeneratorsForProfilesEndpointsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfilesEndpointsSpec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["ContentTypesToCompress"] = gen.SliceOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsHttpAllowed"] = gen.PtrOf(gen.Bool())
	gens["IsHttpsAllowed"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OptimizationType"] = gen.PtrOf(gen.OneConstOf(
		ProfilesEndpointsSpecPropertiesOptimizationType_DynamicSiteAcceleration,
		ProfilesEndpointsSpecPropertiesOptimizationType_GeneralMediaStreaming,
		ProfilesEndpointsSpecPropertiesOptimizationType_GeneralWebDelivery,
		ProfilesEndpointsSpecPropertiesOptimizationType_LargeFileDownload,
		ProfilesEndpointsSpecPropertiesOptimizationType_VideoOnDemandMediaStreaming))
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["OriginPath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		ProfilesEndpointsSpecPropertiesQueryStringCachingBehavior_BypassCaching,
		ProfilesEndpointsSpecPropertiesQueryStringCachingBehavior_IgnoreQueryString,
		ProfilesEndpointsSpecPropertiesQueryStringCachingBehavior_NotSet,
		ProfilesEndpointsSpecPropertiesQueryStringCachingBehavior_UseQueryString))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProfilesEndpointsSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfilesEndpointsSpec(gens map[string]gopter.Gen) {
	gens["DefaultOriginGroup"] = gen.PtrOf(ResourceReferenceGenerator())
	gens["DeliveryPolicy"] = gen.PtrOf(EndpointPropertiesUpdateParametersDeliveryPolicyGenerator())
	gens["GeoFilters"] = gen.SliceOf(GeoFilterGenerator())
	gens["OriginGroups"] = gen.SliceOf(ProfilesEndpointsSpecPropertiesOriginGroupsGenerator())
	gens["Origins"] = gen.SliceOf(ProfilesEndpointsSpecPropertiesOriginsGenerator())
	gens["UrlSigningKeys"] = gen.SliceOf(UrlSigningKeyGenerator())
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkGenerator())
}

func Test_CustomDomain_STATUS_SubResourceEmbedded_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomDomain_STATUS_SubResourceEmbedded to CustomDomain_STATUS_SubResourceEmbedded via AssignPropertiesToCustomDomainSTATUSSubResourceEmbedded & AssignPropertiesFromCustomDomainSTATUSSubResourceEmbedded returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomDomainSTATUSSubResourceEmbedded, CustomDomainSTATUSSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomDomainSTATUSSubResourceEmbedded tests if a specific instance of CustomDomain_STATUS_SubResourceEmbedded can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCustomDomainSTATUSSubResourceEmbedded(subject CustomDomain_STATUS_SubResourceEmbedded) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CustomDomain_STATUS_SubResourceEmbedded
	err := copied.AssignPropertiesToCustomDomainSTATUSSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomDomain_STATUS_SubResourceEmbedded
	err = actual.AssignPropertiesFromCustomDomainSTATUSSubResourceEmbedded(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomDomain_STATUS_SubResourceEmbedded_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_STATUS_SubResourceEmbedded via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomainSTATUSSubResourceEmbedded, CustomDomainSTATUSSubResourceEmbeddedGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomainSTATUSSubResourceEmbedded runs a test to see if a specific instance of CustomDomain_STATUS_SubResourceEmbedded round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomainSTATUSSubResourceEmbedded(subject CustomDomain_STATUS_SubResourceEmbedded) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_STATUS_SubResourceEmbedded
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_STATUS_SubResourceEmbedded instances for property testing - lazily instantiated by
// CustomDomainSTATUSSubResourceEmbeddedGenerator()
var customDomainSTATUSSubResourceEmbeddedGenerator gopter.Gen

// CustomDomainSTATUSSubResourceEmbeddedGenerator returns a generator of CustomDomain_STATUS_SubResourceEmbedded instances for property testing.
// We first initialize customDomainSTATUSSubResourceEmbeddedGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomDomainSTATUSSubResourceEmbeddedGenerator() gopter.Gen {
	if customDomainSTATUSSubResourceEmbeddedGenerator != nil {
		return customDomainSTATUSSubResourceEmbeddedGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainSTATUSSubResourceEmbedded(generators)
	customDomainSTATUSSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(CustomDomain_STATUS_SubResourceEmbedded{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainSTATUSSubResourceEmbedded(generators)
	AddRelatedPropertyGeneratorsForCustomDomainSTATUSSubResourceEmbedded(generators)
	customDomainSTATUSSubResourceEmbeddedGenerator = gen.Struct(reflect.TypeOf(CustomDomain_STATUS_SubResourceEmbedded{}), generators)

	return customDomainSTATUSSubResourceEmbeddedGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomainSTATUSSubResourceEmbedded is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomainSTATUSSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCustomDomainSTATUSSubResourceEmbedded is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomDomainSTATUSSubResourceEmbedded(gens map[string]gopter.Gen) {
	gens["SystemData"] = gen.PtrOf(SystemDataSTATUSGenerator())
}

func Test_DeepCreatedOrigin_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeepCreatedOrigin_STATUS to DeepCreatedOrigin_STATUS via AssignPropertiesToDeepCreatedOriginSTATUS & AssignPropertiesFromDeepCreatedOriginSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeepCreatedOriginSTATUS, DeepCreatedOriginSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeepCreatedOriginSTATUS tests if a specific instance of DeepCreatedOrigin_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeepCreatedOriginSTATUS(subject DeepCreatedOrigin_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeepCreatedOrigin_STATUS
	err := copied.AssignPropertiesToDeepCreatedOriginSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeepCreatedOrigin_STATUS
	err = actual.AssignPropertiesFromDeepCreatedOriginSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeepCreatedOrigin_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOrigin_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOriginSTATUS, DeepCreatedOriginSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOriginSTATUS runs a test to see if a specific instance of DeepCreatedOrigin_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOriginSTATUS(subject DeepCreatedOrigin_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOrigin_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOrigin_STATUS instances for property testing - lazily instantiated by
// DeepCreatedOriginSTATUSGenerator()
var deepCreatedOriginSTATUSGenerator gopter.Gen

// DeepCreatedOriginSTATUSGenerator returns a generator of DeepCreatedOrigin_STATUS instances for property testing.
func DeepCreatedOriginSTATUSGenerator() gopter.Gen {
	if deepCreatedOriginSTATUSGenerator != nil {
		return deepCreatedOriginSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginSTATUS(generators)
	deepCreatedOriginSTATUSGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOrigin_STATUS{}), generators)

	return deepCreatedOriginSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOriginSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOriginSTATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["PrivateEndpointStatus"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointStatus_STATUS_Approved,
		PrivateEndpointStatus_STATUS_Disconnected,
		PrivateEndpointStatus_STATUS_Pending,
		PrivateEndpointStatus_STATUS_Rejected,
		PrivateEndpointStatus_STATUS_Timeout))
	gens["PrivateLinkAlias"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkApprovalMessage"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkLocation"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_DeepCreatedOriginGroup_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeepCreatedOriginGroup_STATUS to DeepCreatedOriginGroup_STATUS via AssignPropertiesToDeepCreatedOriginGroupSTATUS & AssignPropertiesFromDeepCreatedOriginGroupSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeepCreatedOriginGroupSTATUS, DeepCreatedOriginGroupSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeepCreatedOriginGroupSTATUS tests if a specific instance of DeepCreatedOriginGroup_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeepCreatedOriginGroupSTATUS(subject DeepCreatedOriginGroup_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeepCreatedOriginGroup_STATUS
	err := copied.AssignPropertiesToDeepCreatedOriginGroupSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeepCreatedOriginGroup_STATUS
	err = actual.AssignPropertiesFromDeepCreatedOriginGroupSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeepCreatedOriginGroup_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOriginGroup_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOriginGroupSTATUS, DeepCreatedOriginGroupSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOriginGroupSTATUS runs a test to see if a specific instance of DeepCreatedOriginGroup_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOriginGroupSTATUS(subject DeepCreatedOriginGroup_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOriginGroup_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOriginGroup_STATUS instances for property testing - lazily instantiated by
// DeepCreatedOriginGroupSTATUSGenerator()
var deepCreatedOriginGroupSTATUSGenerator gopter.Gen

// DeepCreatedOriginGroupSTATUSGenerator returns a generator of DeepCreatedOriginGroup_STATUS instances for property testing.
// We first initialize deepCreatedOriginGroupSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeepCreatedOriginGroupSTATUSGenerator() gopter.Gen {
	if deepCreatedOriginGroupSTATUSGenerator != nil {
		return deepCreatedOriginGroupSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupSTATUS(generators)
	deepCreatedOriginGroupSTATUSGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroup_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupSTATUS(generators)
	AddRelatedPropertyGeneratorsForDeepCreatedOriginGroupSTATUS(generators)
	deepCreatedOriginGroupSTATUSGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroup_STATUS{}), generators)

	return deepCreatedOriginGroupSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupSTATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficRestorationTimeToHealedOrNewEndpointsInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeepCreatedOriginGroupSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeepCreatedOriginGroupSTATUS(gens map[string]gopter.Gen) {
	gens["HealthProbeSettings"] = gen.PtrOf(HealthProbeParametersSTATUSGenerator())
	gens["Origins"] = gen.SliceOf(ResourceReferenceSTATUSGenerator())
	gens["ResponseBasedOriginErrorDetectionSettings"] = gen.PtrOf(ResponseBasedOriginErrorDetectionParametersSTATUSGenerator())
}

func Test_EndpointProperties_STATUS_DeliveryPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EndpointProperties_STATUS_DeliveryPolicy to EndpointProperties_STATUS_DeliveryPolicy via AssignPropertiesToEndpointPropertiesSTATUSDeliveryPolicy & AssignPropertiesFromEndpointPropertiesSTATUSDeliveryPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForEndpointPropertiesSTATUSDeliveryPolicy, EndpointPropertiesSTATUSDeliveryPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEndpointPropertiesSTATUSDeliveryPolicy tests if a specific instance of EndpointProperties_STATUS_DeliveryPolicy can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForEndpointPropertiesSTATUSDeliveryPolicy(subject EndpointProperties_STATUS_DeliveryPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.EndpointProperties_STATUS_DeliveryPolicy
	err := copied.AssignPropertiesToEndpointPropertiesSTATUSDeliveryPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EndpointProperties_STATUS_DeliveryPolicy
	err = actual.AssignPropertiesFromEndpointPropertiesSTATUSDeliveryPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EndpointProperties_STATUS_DeliveryPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointProperties_STATUS_DeliveryPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointPropertiesSTATUSDeliveryPolicy, EndpointPropertiesSTATUSDeliveryPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointPropertiesSTATUSDeliveryPolicy runs a test to see if a specific instance of EndpointProperties_STATUS_DeliveryPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointPropertiesSTATUSDeliveryPolicy(subject EndpointProperties_STATUS_DeliveryPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointProperties_STATUS_DeliveryPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointProperties_STATUS_DeliveryPolicy instances for property testing - lazily instantiated by
// EndpointPropertiesSTATUSDeliveryPolicyGenerator()
var endpointPropertiesSTATUSDeliveryPolicyGenerator gopter.Gen

// EndpointPropertiesSTATUSDeliveryPolicyGenerator returns a generator of EndpointProperties_STATUS_DeliveryPolicy instances for property testing.
// We first initialize endpointPropertiesSTATUSDeliveryPolicyGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EndpointPropertiesSTATUSDeliveryPolicyGenerator() gopter.Gen {
	if endpointPropertiesSTATUSDeliveryPolicyGenerator != nil {
		return endpointPropertiesSTATUSDeliveryPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointPropertiesSTATUSDeliveryPolicy(generators)
	endpointPropertiesSTATUSDeliveryPolicyGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_STATUS_DeliveryPolicy{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointPropertiesSTATUSDeliveryPolicy(generators)
	AddRelatedPropertyGeneratorsForEndpointPropertiesSTATUSDeliveryPolicy(generators)
	endpointPropertiesSTATUSDeliveryPolicyGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_STATUS_DeliveryPolicy{}), generators)

	return endpointPropertiesSTATUSDeliveryPolicyGenerator
}

// AddIndependentPropertyGeneratorsForEndpointPropertiesSTATUSDeliveryPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointPropertiesSTATUSDeliveryPolicy(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEndpointPropertiesSTATUSDeliveryPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpointPropertiesSTATUSDeliveryPolicy(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(DeliveryRuleSTATUSGenerator())
}

func Test_EndpointProperties_STATUS_WebApplicationFirewallPolicyLink_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EndpointProperties_STATUS_WebApplicationFirewallPolicyLink to EndpointProperties_STATUS_WebApplicationFirewallPolicyLink via AssignPropertiesToEndpointPropertiesSTATUSWebApplicationFirewallPolicyLink & AssignPropertiesFromEndpointPropertiesSTATUSWebApplicationFirewallPolicyLink returns original",
		prop.ForAll(RunPropertyAssignmentTestForEndpointPropertiesSTATUSWebApplicationFirewallPolicyLink, EndpointPropertiesSTATUSWebApplicationFirewallPolicyLinkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEndpointPropertiesSTATUSWebApplicationFirewallPolicyLink tests if a specific instance of EndpointProperties_STATUS_WebApplicationFirewallPolicyLink can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForEndpointPropertiesSTATUSWebApplicationFirewallPolicyLink(subject EndpointProperties_STATUS_WebApplicationFirewallPolicyLink) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.EndpointProperties_STATUS_WebApplicationFirewallPolicyLink
	err := copied.AssignPropertiesToEndpointPropertiesSTATUSWebApplicationFirewallPolicyLink(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EndpointProperties_STATUS_WebApplicationFirewallPolicyLink
	err = actual.AssignPropertiesFromEndpointPropertiesSTATUSWebApplicationFirewallPolicyLink(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EndpointProperties_STATUS_WebApplicationFirewallPolicyLink_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointProperties_STATUS_WebApplicationFirewallPolicyLink via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointPropertiesSTATUSWebApplicationFirewallPolicyLink, EndpointPropertiesSTATUSWebApplicationFirewallPolicyLinkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointPropertiesSTATUSWebApplicationFirewallPolicyLink runs a test to see if a specific instance of EndpointProperties_STATUS_WebApplicationFirewallPolicyLink round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointPropertiesSTATUSWebApplicationFirewallPolicyLink(subject EndpointProperties_STATUS_WebApplicationFirewallPolicyLink) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointProperties_STATUS_WebApplicationFirewallPolicyLink
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointProperties_STATUS_WebApplicationFirewallPolicyLink instances for property testing - lazily
// instantiated by EndpointPropertiesSTATUSWebApplicationFirewallPolicyLinkGenerator()
var endpointPropertiesSTATUSWebApplicationFirewallPolicyLinkGenerator gopter.Gen

// EndpointPropertiesSTATUSWebApplicationFirewallPolicyLinkGenerator returns a generator of EndpointProperties_STATUS_WebApplicationFirewallPolicyLink instances for property testing.
func EndpointPropertiesSTATUSWebApplicationFirewallPolicyLinkGenerator() gopter.Gen {
	if endpointPropertiesSTATUSWebApplicationFirewallPolicyLinkGenerator != nil {
		return endpointPropertiesSTATUSWebApplicationFirewallPolicyLinkGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointPropertiesSTATUSWebApplicationFirewallPolicyLink(generators)
	endpointPropertiesSTATUSWebApplicationFirewallPolicyLinkGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_STATUS_WebApplicationFirewallPolicyLink{}), generators)

	return endpointPropertiesSTATUSWebApplicationFirewallPolicyLinkGenerator
}

// AddIndependentPropertyGeneratorsForEndpointPropertiesSTATUSWebApplicationFirewallPolicyLink is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointPropertiesSTATUSWebApplicationFirewallPolicyLink(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_EndpointPropertiesUpdateParametersDeliveryPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EndpointPropertiesUpdateParametersDeliveryPolicy to EndpointPropertiesUpdateParametersDeliveryPolicy via AssignPropertiesToEndpointPropertiesUpdateParametersDeliveryPolicy & AssignPropertiesFromEndpointPropertiesUpdateParametersDeliveryPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForEndpointPropertiesUpdateParametersDeliveryPolicy, EndpointPropertiesUpdateParametersDeliveryPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEndpointPropertiesUpdateParametersDeliveryPolicy tests if a specific instance of EndpointPropertiesUpdateParametersDeliveryPolicy can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForEndpointPropertiesUpdateParametersDeliveryPolicy(subject EndpointPropertiesUpdateParametersDeliveryPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.EndpointPropertiesUpdateParametersDeliveryPolicy
	err := copied.AssignPropertiesToEndpointPropertiesUpdateParametersDeliveryPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EndpointPropertiesUpdateParametersDeliveryPolicy
	err = actual.AssignPropertiesFromEndpointPropertiesUpdateParametersDeliveryPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EndpointPropertiesUpdateParametersDeliveryPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointPropertiesUpdateParametersDeliveryPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointPropertiesUpdateParametersDeliveryPolicy, EndpointPropertiesUpdateParametersDeliveryPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointPropertiesUpdateParametersDeliveryPolicy runs a test to see if a specific instance of EndpointPropertiesUpdateParametersDeliveryPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointPropertiesUpdateParametersDeliveryPolicy(subject EndpointPropertiesUpdateParametersDeliveryPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointPropertiesUpdateParametersDeliveryPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointPropertiesUpdateParametersDeliveryPolicy instances for property testing - lazily instantiated by
// EndpointPropertiesUpdateParametersDeliveryPolicyGenerator()
var endpointPropertiesUpdateParametersDeliveryPolicyGenerator gopter.Gen

// EndpointPropertiesUpdateParametersDeliveryPolicyGenerator returns a generator of EndpointPropertiesUpdateParametersDeliveryPolicy instances for property testing.
// We first initialize endpointPropertiesUpdateParametersDeliveryPolicyGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EndpointPropertiesUpdateParametersDeliveryPolicyGenerator() gopter.Gen {
	if endpointPropertiesUpdateParametersDeliveryPolicyGenerator != nil {
		return endpointPropertiesUpdateParametersDeliveryPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicy(generators)
	endpointPropertiesUpdateParametersDeliveryPolicyGenerator = gen.Struct(reflect.TypeOf(EndpointPropertiesUpdateParametersDeliveryPolicy{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicy(generators)
	AddRelatedPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicy(generators)
	endpointPropertiesUpdateParametersDeliveryPolicyGenerator = gen.Struct(reflect.TypeOf(EndpointPropertiesUpdateParametersDeliveryPolicy{}), generators)

	return endpointPropertiesUpdateParametersDeliveryPolicyGenerator
}

// AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicy(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicy(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(DeliveryRuleGenerator())
}

func Test_EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink to EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink via AssignPropertiesToEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink & AssignPropertiesFromEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink returns original",
		prop.ForAll(RunPropertyAssignmentTestForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink, EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink tests if a specific instance of EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink(subject EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink
	err := copied.AssignPropertiesToEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink
	err = actual.AssignPropertiesFromEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink, EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink runs a test to see if a specific instance of EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink(subject EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink instances for property testing -
// lazily instantiated by EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkGenerator()
var endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkGenerator gopter.Gen

// EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkGenerator returns a generator of EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink instances for property testing.
func EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkGenerator() gopter.Gen {
	if endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkGenerator != nil {
		return endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkGenerator
	}

	generators := make(map[string]gopter.Gen)
	endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkGenerator = gen.Struct(reflect.TypeOf(EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLink{}), generators)

	return endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkGenerator
}

func Test_GeoFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GeoFilter to GeoFilter via AssignPropertiesToGeoFilter & AssignPropertiesFromGeoFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForGeoFilter, GeoFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGeoFilter tests if a specific instance of GeoFilter can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForGeoFilter(subject GeoFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.GeoFilter
	err := copied.AssignPropertiesToGeoFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GeoFilter
	err = actual.AssignPropertiesFromGeoFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GeoFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GeoFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGeoFilter, GeoFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGeoFilter runs a test to see if a specific instance of GeoFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForGeoFilter(subject GeoFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GeoFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GeoFilter instances for property testing - lazily instantiated by GeoFilterGenerator()
var geoFilterGenerator gopter.Gen

// GeoFilterGenerator returns a generator of GeoFilter instances for property testing.
func GeoFilterGenerator() gopter.Gen {
	if geoFilterGenerator != nil {
		return geoFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGeoFilter(generators)
	geoFilterGenerator = gen.Struct(reflect.TypeOf(GeoFilter{}), generators)

	return geoFilterGenerator
}

// AddIndependentPropertyGeneratorsForGeoFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGeoFilter(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(GeoFilterAction_Allow, GeoFilterAction_Block))
	gens["CountryCodes"] = gen.SliceOf(gen.AlphaString())
	gens["RelativePath"] = gen.PtrOf(gen.AlphaString())
}

func Test_GeoFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GeoFilter_STATUS to GeoFilter_STATUS via AssignPropertiesToGeoFilterSTATUS & AssignPropertiesFromGeoFilterSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForGeoFilterSTATUS, GeoFilterSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGeoFilterSTATUS tests if a specific instance of GeoFilter_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForGeoFilterSTATUS(subject GeoFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.GeoFilter_STATUS
	err := copied.AssignPropertiesToGeoFilterSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GeoFilter_STATUS
	err = actual.AssignPropertiesFromGeoFilterSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GeoFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GeoFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGeoFilterSTATUS, GeoFilterSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGeoFilterSTATUS runs a test to see if a specific instance of GeoFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGeoFilterSTATUS(subject GeoFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GeoFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GeoFilter_STATUS instances for property testing - lazily instantiated by GeoFilterSTATUSGenerator()
var geoFilterSTATUSGenerator gopter.Gen

// GeoFilterSTATUSGenerator returns a generator of GeoFilter_STATUS instances for property testing.
func GeoFilterSTATUSGenerator() gopter.Gen {
	if geoFilterSTATUSGenerator != nil {
		return geoFilterSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGeoFilterSTATUS(generators)
	geoFilterSTATUSGenerator = gen.Struct(reflect.TypeOf(GeoFilter_STATUS{}), generators)

	return geoFilterSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForGeoFilterSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGeoFilterSTATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(GeoFilterSTATUSAction_Allow, GeoFilterSTATUSAction_Block))
	gens["CountryCodes"] = gen.SliceOf(gen.AlphaString())
	gens["RelativePath"] = gen.PtrOf(gen.AlphaString())
}

func Test_ProfilesEndpoints_Spec_Properties_OriginGroups_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ProfilesEndpoints_Spec_Properties_OriginGroups to ProfilesEndpoints_Spec_Properties_OriginGroups via AssignPropertiesToProfilesEndpointsSpecPropertiesOriginGroups & AssignPropertiesFromProfilesEndpointsSpecPropertiesOriginGroups returns original",
		prop.ForAll(RunPropertyAssignmentTestForProfilesEndpointsSpecPropertiesOriginGroups, ProfilesEndpointsSpecPropertiesOriginGroupsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProfilesEndpointsSpecPropertiesOriginGroups tests if a specific instance of ProfilesEndpoints_Spec_Properties_OriginGroups can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForProfilesEndpointsSpecPropertiesOriginGroups(subject ProfilesEndpoints_Spec_Properties_OriginGroups) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ProfilesEndpoints_Spec_Properties_OriginGroups
	err := copied.AssignPropertiesToProfilesEndpointsSpecPropertiesOriginGroups(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ProfilesEndpoints_Spec_Properties_OriginGroups
	err = actual.AssignPropertiesFromProfilesEndpointsSpecPropertiesOriginGroups(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ProfilesEndpoints_Spec_Properties_OriginGroups_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProfilesEndpoints_Spec_Properties_OriginGroups via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfilesEndpointsSpecPropertiesOriginGroups, ProfilesEndpointsSpecPropertiesOriginGroupsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfilesEndpointsSpecPropertiesOriginGroups runs a test to see if a specific instance of ProfilesEndpoints_Spec_Properties_OriginGroups round trips to JSON and back losslessly
func RunJSONSerializationTestForProfilesEndpointsSpecPropertiesOriginGroups(subject ProfilesEndpoints_Spec_Properties_OriginGroups) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProfilesEndpoints_Spec_Properties_OriginGroups
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProfilesEndpoints_Spec_Properties_OriginGroups instances for property testing - lazily instantiated by
// ProfilesEndpointsSpecPropertiesOriginGroupsGenerator()
var profilesEndpointsSpecPropertiesOriginGroupsGenerator gopter.Gen

// ProfilesEndpointsSpecPropertiesOriginGroupsGenerator returns a generator of ProfilesEndpoints_Spec_Properties_OriginGroups instances for property testing.
// We first initialize profilesEndpointsSpecPropertiesOriginGroupsGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProfilesEndpointsSpecPropertiesOriginGroupsGenerator() gopter.Gen {
	if profilesEndpointsSpecPropertiesOriginGroupsGenerator != nil {
		return profilesEndpointsSpecPropertiesOriginGroupsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginGroups(generators)
	profilesEndpointsSpecPropertiesOriginGroupsGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoints_Spec_Properties_OriginGroups{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginGroups(generators)
	AddRelatedPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginGroups(generators)
	profilesEndpointsSpecPropertiesOriginGroupsGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoints_Spec_Properties_OriginGroups{}), generators)

	return profilesEndpointsSpecPropertiesOriginGroupsGenerator
}

// AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginGroups is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginGroups(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficRestorationTimeToHealedOrNewEndpointsInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginGroups is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginGroups(gens map[string]gopter.Gen) {
	gens["HealthProbeSettings"] = gen.PtrOf(HealthProbeParametersGenerator())
	gens["Origins"] = gen.SliceOf(ResourceReferenceGenerator())
	gens["ResponseBasedOriginErrorDetectionSettings"] = gen.PtrOf(ResponseBasedOriginErrorDetectionParametersGenerator())
}

func Test_ProfilesEndpoints_Spec_Properties_Origins_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ProfilesEndpoints_Spec_Properties_Origins to ProfilesEndpoints_Spec_Properties_Origins via AssignPropertiesToProfilesEndpointsSpecPropertiesOrigins & AssignPropertiesFromProfilesEndpointsSpecPropertiesOrigins returns original",
		prop.ForAll(RunPropertyAssignmentTestForProfilesEndpointsSpecPropertiesOrigins, ProfilesEndpointsSpecPropertiesOriginsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProfilesEndpointsSpecPropertiesOrigins tests if a specific instance of ProfilesEndpoints_Spec_Properties_Origins can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForProfilesEndpointsSpecPropertiesOrigins(subject ProfilesEndpoints_Spec_Properties_Origins) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ProfilesEndpoints_Spec_Properties_Origins
	err := copied.AssignPropertiesToProfilesEndpointsSpecPropertiesOrigins(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ProfilesEndpoints_Spec_Properties_Origins
	err = actual.AssignPropertiesFromProfilesEndpointsSpecPropertiesOrigins(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ProfilesEndpoints_Spec_Properties_Origins_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProfilesEndpoints_Spec_Properties_Origins via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfilesEndpointsSpecPropertiesOrigins, ProfilesEndpointsSpecPropertiesOriginsGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfilesEndpointsSpecPropertiesOrigins runs a test to see if a specific instance of ProfilesEndpoints_Spec_Properties_Origins round trips to JSON and back losslessly
func RunJSONSerializationTestForProfilesEndpointsSpecPropertiesOrigins(subject ProfilesEndpoints_Spec_Properties_Origins) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProfilesEndpoints_Spec_Properties_Origins
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProfilesEndpoints_Spec_Properties_Origins instances for property testing - lazily instantiated by
// ProfilesEndpointsSpecPropertiesOriginsGenerator()
var profilesEndpointsSpecPropertiesOriginsGenerator gopter.Gen

// ProfilesEndpointsSpecPropertiesOriginsGenerator returns a generator of ProfilesEndpoints_Spec_Properties_Origins instances for property testing.
func ProfilesEndpointsSpecPropertiesOriginsGenerator() gopter.Gen {
	if profilesEndpointsSpecPropertiesOriginsGenerator != nil {
		return profilesEndpointsSpecPropertiesOriginsGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOrigins(generators)
	profilesEndpointsSpecPropertiesOriginsGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoints_Spec_Properties_Origins{}), generators)

	return profilesEndpointsSpecPropertiesOriginsGenerator
}

// AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOrigins is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOrigins(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["PrivateLinkAlias"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkApprovalMessage"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_ResourceReference_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceReference to ResourceReference via AssignPropertiesToResourceReference & AssignPropertiesFromResourceReference returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceReference, ResourceReferenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceReference tests if a specific instance of ResourceReference can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForResourceReference(subject ResourceReference) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ResourceReference
	err := copied.AssignPropertiesToResourceReference(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceReference
	err = actual.AssignPropertiesFromResourceReference(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceReference_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceReference via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceReference, ResourceReferenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceReference runs a test to see if a specific instance of ResourceReference round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceReference(subject ResourceReference) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceReference
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceReference instances for property testing - lazily instantiated by ResourceReferenceGenerator()
var resourceReferenceGenerator gopter.Gen

// ResourceReferenceGenerator returns a generator of ResourceReference instances for property testing.
func ResourceReferenceGenerator() gopter.Gen {
	if resourceReferenceGenerator != nil {
		return resourceReferenceGenerator
	}

	generators := make(map[string]gopter.Gen)
	resourceReferenceGenerator = gen.Struct(reflect.TypeOf(ResourceReference{}), generators)

	return resourceReferenceGenerator
}

func Test_ResourceReference_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceReference_STATUS to ResourceReference_STATUS via AssignPropertiesToResourceReferenceSTATUS & AssignPropertiesFromResourceReferenceSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceReferenceSTATUS, ResourceReferenceSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceReferenceSTATUS tests if a specific instance of ResourceReference_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForResourceReferenceSTATUS(subject ResourceReference_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ResourceReference_STATUS
	err := copied.AssignPropertiesToResourceReferenceSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceReference_STATUS
	err = actual.AssignPropertiesFromResourceReferenceSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceReference_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceReference_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceReferenceSTATUS, ResourceReferenceSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceReferenceSTATUS runs a test to see if a specific instance of ResourceReference_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceReferenceSTATUS(subject ResourceReference_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceReference_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceReference_STATUS instances for property testing - lazily instantiated by
// ResourceReferenceSTATUSGenerator()
var resourceReferenceSTATUSGenerator gopter.Gen

// ResourceReferenceSTATUSGenerator returns a generator of ResourceReference_STATUS instances for property testing.
func ResourceReferenceSTATUSGenerator() gopter.Gen {
	if resourceReferenceSTATUSGenerator != nil {
		return resourceReferenceSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceReferenceSTATUS(generators)
	resourceReferenceSTATUSGenerator = gen.Struct(reflect.TypeOf(ResourceReference_STATUS{}), generators)

	return resourceReferenceSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForResourceReferenceSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceReferenceSTATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_UrlSigningKey_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningKey to UrlSigningKey via AssignPropertiesToUrlSigningKey & AssignPropertiesFromUrlSigningKey returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningKey, UrlSigningKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningKey tests if a specific instance of UrlSigningKey can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningKey(subject UrlSigningKey) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningKey
	err := copied.AssignPropertiesToUrlSigningKey(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningKey
	err = actual.AssignPropertiesFromUrlSigningKey(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningKey_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningKey via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningKey, UrlSigningKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningKey runs a test to see if a specific instance of UrlSigningKey round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningKey(subject UrlSigningKey) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningKey
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningKey instances for property testing - lazily instantiated by UrlSigningKeyGenerator()
var urlSigningKeyGenerator gopter.Gen

// UrlSigningKeyGenerator returns a generator of UrlSigningKey instances for property testing.
// We first initialize urlSigningKeyGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningKeyGenerator() gopter.Gen {
	if urlSigningKeyGenerator != nil {
		return urlSigningKeyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKey(generators)
	urlSigningKeyGenerator = gen.Struct(reflect.TypeOf(UrlSigningKey{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKey(generators)
	AddRelatedPropertyGeneratorsForUrlSigningKey(generators)
	urlSigningKeyGenerator = gen.Struct(reflect.TypeOf(UrlSigningKey{}), generators)

	return urlSigningKeyGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningKey is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningKey(gens map[string]gopter.Gen) {
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUrlSigningKey is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningKey(gens map[string]gopter.Gen) {
	gens["KeySourceParameters"] = gen.PtrOf(KeyVaultSigningKeyParametersGenerator())
}

func Test_UrlSigningKey_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningKey_STATUS to UrlSigningKey_STATUS via AssignPropertiesToUrlSigningKeySTATUS & AssignPropertiesFromUrlSigningKeySTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningKeySTATUS, UrlSigningKeySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningKeySTATUS tests if a specific instance of UrlSigningKey_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningKeySTATUS(subject UrlSigningKey_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningKey_STATUS
	err := copied.AssignPropertiesToUrlSigningKeySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningKey_STATUS
	err = actual.AssignPropertiesFromUrlSigningKeySTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningKey_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningKey_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningKeySTATUS, UrlSigningKeySTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningKeySTATUS runs a test to see if a specific instance of UrlSigningKey_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningKeySTATUS(subject UrlSigningKey_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningKey_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningKey_STATUS instances for property testing - lazily instantiated by
// UrlSigningKeySTATUSGenerator()
var urlSigningKeySTATUSGenerator gopter.Gen

// UrlSigningKeySTATUSGenerator returns a generator of UrlSigningKey_STATUS instances for property testing.
// We first initialize urlSigningKeySTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningKeySTATUSGenerator() gopter.Gen {
	if urlSigningKeySTATUSGenerator != nil {
		return urlSigningKeySTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKeySTATUS(generators)
	urlSigningKeySTATUSGenerator = gen.Struct(reflect.TypeOf(UrlSigningKey_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKeySTATUS(generators)
	AddRelatedPropertyGeneratorsForUrlSigningKeySTATUS(generators)
	urlSigningKeySTATUSGenerator = gen.Struct(reflect.TypeOf(UrlSigningKey_STATUS{}), generators)

	return urlSigningKeySTATUSGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningKeySTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningKeySTATUS(gens map[string]gopter.Gen) {
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUrlSigningKeySTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningKeySTATUS(gens map[string]gopter.Gen) {
	gens["KeySourceParameters"] = gen.PtrOf(KeyVaultSigningKeyParametersSTATUSGenerator())
}

func Test_DeliveryRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRule to DeliveryRule via AssignPropertiesToDeliveryRule & AssignPropertiesFromDeliveryRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRule, DeliveryRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRule tests if a specific instance of DeliveryRule can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRule(subject DeliveryRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRule
	err := copied.AssignPropertiesToDeliveryRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRule
	err = actual.AssignPropertiesFromDeliveryRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRule, DeliveryRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRule runs a test to see if a specific instance of DeliveryRule round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRule(subject DeliveryRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRule instances for property testing - lazily instantiated by DeliveryRuleGenerator()
var deliveryRuleGenerator gopter.Gen

// DeliveryRuleGenerator returns a generator of DeliveryRule instances for property testing.
// We first initialize deliveryRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleGenerator() gopter.Gen {
	if deliveryRuleGenerator != nil {
		return deliveryRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRule(generators)
	deliveryRuleGenerator = gen.Struct(reflect.TypeOf(DeliveryRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRule(generators)
	AddRelatedPropertyGeneratorsForDeliveryRule(generators)
	deliveryRuleGenerator = gen.Struct(reflect.TypeOf(DeliveryRule{}), generators)

	return deliveryRuleGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRule(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Order"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeliveryRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRule(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.SliceOf(DeliveryRuleAction1Generator())
	gens["Conditions"] = gen.SliceOf(DeliveryRuleConditionGenerator())
}

func Test_DeliveryRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRule_STATUS to DeliveryRule_STATUS via AssignPropertiesToDeliveryRuleSTATUS & AssignPropertiesFromDeliveryRuleSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleSTATUS, DeliveryRuleSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleSTATUS tests if a specific instance of DeliveryRule_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleSTATUS(subject DeliveryRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRule_STATUS
	err := copied.AssignPropertiesToDeliveryRuleSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRule_STATUS
	err = actual.AssignPropertiesFromDeliveryRuleSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleSTATUS, DeliveryRuleSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleSTATUS runs a test to see if a specific instance of DeliveryRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleSTATUS(subject DeliveryRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRule_STATUS instances for property testing - lazily instantiated by DeliveryRuleSTATUSGenerator()
var deliveryRuleSTATUSGenerator gopter.Gen

// DeliveryRuleSTATUSGenerator returns a generator of DeliveryRule_STATUS instances for property testing.
// We first initialize deliveryRuleSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleSTATUSGenerator() gopter.Gen {
	if deliveryRuleSTATUSGenerator != nil {
		return deliveryRuleSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSTATUS(generators)
	deliveryRuleSTATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSTATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleSTATUS(generators)
	deliveryRuleSTATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRule_STATUS{}), generators)

	return deliveryRuleSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleSTATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Order"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeliveryRuleSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleSTATUS(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.SliceOf(DeliveryRuleActionSTATUSGenerator())
	gens["Conditions"] = gen.SliceOf(DeliveryRuleConditionSTATUSGenerator())
}

func Test_HealthProbeParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HealthProbeParameters to HealthProbeParameters via AssignPropertiesToHealthProbeParameters & AssignPropertiesFromHealthProbeParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForHealthProbeParameters, HealthProbeParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHealthProbeParameters tests if a specific instance of HealthProbeParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHealthProbeParameters(subject HealthProbeParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HealthProbeParameters
	err := copied.AssignPropertiesToHealthProbeParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HealthProbeParameters
	err = actual.AssignPropertiesFromHealthProbeParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HealthProbeParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeParameters, HealthProbeParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeParameters runs a test to see if a specific instance of HealthProbeParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeParameters(subject HealthProbeParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeParameters instances for property testing - lazily instantiated by
// HealthProbeParametersGenerator()
var healthProbeParametersGenerator gopter.Gen

// HealthProbeParametersGenerator returns a generator of HealthProbeParameters instances for property testing.
func HealthProbeParametersGenerator() gopter.Gen {
	if healthProbeParametersGenerator != nil {
		return healthProbeParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeParameters(generators)
	healthProbeParametersGenerator = gen.Struct(reflect.TypeOf(HealthProbeParameters{}), generators)

	return healthProbeParametersGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeParameters(gens map[string]gopter.Gen) {
	gens["ProbeIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbeProtocol"] = gen.PtrOf(gen.OneConstOf(HealthProbeParametersProbeProtocol_Http, HealthProbeParametersProbeProtocol_Https, HealthProbeParametersProbeProtocol_NotSet))
	gens["ProbeRequestType"] = gen.PtrOf(gen.OneConstOf(HealthProbeParametersProbeRequestType_GET, HealthProbeParametersProbeRequestType_HEAD, HealthProbeParametersProbeRequestType_NotSet))
}

func Test_HealthProbeParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HealthProbeParameters_STATUS to HealthProbeParameters_STATUS via AssignPropertiesToHealthProbeParametersSTATUS & AssignPropertiesFromHealthProbeParametersSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHealthProbeParametersSTATUS, HealthProbeParametersSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHealthProbeParametersSTATUS tests if a specific instance of HealthProbeParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHealthProbeParametersSTATUS(subject HealthProbeParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HealthProbeParameters_STATUS
	err := copied.AssignPropertiesToHealthProbeParametersSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HealthProbeParameters_STATUS
	err = actual.AssignPropertiesFromHealthProbeParametersSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HealthProbeParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeParametersSTATUS, HealthProbeParametersSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeParametersSTATUS runs a test to see if a specific instance of HealthProbeParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeParametersSTATUS(subject HealthProbeParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeParameters_STATUS instances for property testing - lazily instantiated by
// HealthProbeParametersSTATUSGenerator()
var healthProbeParametersSTATUSGenerator gopter.Gen

// HealthProbeParametersSTATUSGenerator returns a generator of HealthProbeParameters_STATUS instances for property testing.
func HealthProbeParametersSTATUSGenerator() gopter.Gen {
	if healthProbeParametersSTATUSGenerator != nil {
		return healthProbeParametersSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeParametersSTATUS(generators)
	healthProbeParametersSTATUSGenerator = gen.Struct(reflect.TypeOf(HealthProbeParameters_STATUS{}), generators)

	return healthProbeParametersSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeParametersSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeParametersSTATUS(gens map[string]gopter.Gen) {
	gens["ProbeIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbeProtocol"] = gen.PtrOf(gen.OneConstOf(HealthProbeParametersSTATUSProbeProtocol_Http, HealthProbeParametersSTATUSProbeProtocol_Https, HealthProbeParametersSTATUSProbeProtocol_NotSet))
	gens["ProbeRequestType"] = gen.PtrOf(gen.OneConstOf(HealthProbeParametersSTATUSProbeRequestType_GET, HealthProbeParametersSTATUSProbeRequestType_HEAD, HealthProbeParametersSTATUSProbeRequestType_NotSet))
}

func Test_KeyVaultSigningKeyParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultSigningKeyParameters to KeyVaultSigningKeyParameters via AssignPropertiesToKeyVaultSigningKeyParameters & AssignPropertiesFromKeyVaultSigningKeyParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultSigningKeyParameters, KeyVaultSigningKeyParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultSigningKeyParameters tests if a specific instance of KeyVaultSigningKeyParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultSigningKeyParameters(subject KeyVaultSigningKeyParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.KeyVaultSigningKeyParameters
	err := copied.AssignPropertiesToKeyVaultSigningKeyParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultSigningKeyParameters
	err = actual.AssignPropertiesFromKeyVaultSigningKeyParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultSigningKeyParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSigningKeyParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSigningKeyParameters, KeyVaultSigningKeyParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSigningKeyParameters runs a test to see if a specific instance of KeyVaultSigningKeyParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSigningKeyParameters(subject KeyVaultSigningKeyParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSigningKeyParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSigningKeyParameters instances for property testing - lazily instantiated by
// KeyVaultSigningKeyParametersGenerator()
var keyVaultSigningKeyParametersGenerator gopter.Gen

// KeyVaultSigningKeyParametersGenerator returns a generator of KeyVaultSigningKeyParameters instances for property testing.
func KeyVaultSigningKeyParametersGenerator() gopter.Gen {
	if keyVaultSigningKeyParametersGenerator != nil {
		return keyVaultSigningKeyParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters(generators)
	keyVaultSigningKeyParametersGenerator = gen.Struct(reflect.TypeOf(KeyVaultSigningKeyParameters{}), generators)

	return keyVaultSigningKeyParametersGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters(gens map[string]gopter.Gen) {
	gens["ResourceGroupName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(KeyVaultSigningKeyParametersTypeName_KeyVaultSigningKeyParameters))
	gens["VaultName"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultSigningKeyParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultSigningKeyParameters_STATUS to KeyVaultSigningKeyParameters_STATUS via AssignPropertiesToKeyVaultSigningKeyParametersSTATUS & AssignPropertiesFromKeyVaultSigningKeyParametersSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultSigningKeyParametersSTATUS, KeyVaultSigningKeyParametersSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultSigningKeyParametersSTATUS tests if a specific instance of KeyVaultSigningKeyParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultSigningKeyParametersSTATUS(subject KeyVaultSigningKeyParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.KeyVaultSigningKeyParameters_STATUS
	err := copied.AssignPropertiesToKeyVaultSigningKeyParametersSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultSigningKeyParameters_STATUS
	err = actual.AssignPropertiesFromKeyVaultSigningKeyParametersSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultSigningKeyParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSigningKeyParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSigningKeyParametersSTATUS, KeyVaultSigningKeyParametersSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSigningKeyParametersSTATUS runs a test to see if a specific instance of KeyVaultSigningKeyParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSigningKeyParametersSTATUS(subject KeyVaultSigningKeyParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSigningKeyParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSigningKeyParameters_STATUS instances for property testing - lazily instantiated by
// KeyVaultSigningKeyParametersSTATUSGenerator()
var keyVaultSigningKeyParametersSTATUSGenerator gopter.Gen

// KeyVaultSigningKeyParametersSTATUSGenerator returns a generator of KeyVaultSigningKeyParameters_STATUS instances for property testing.
func KeyVaultSigningKeyParametersSTATUSGenerator() gopter.Gen {
	if keyVaultSigningKeyParametersSTATUSGenerator != nil {
		return keyVaultSigningKeyParametersSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParametersSTATUS(generators)
	keyVaultSigningKeyParametersSTATUSGenerator = gen.Struct(reflect.TypeOf(KeyVaultSigningKeyParameters_STATUS{}), generators)

	return keyVaultSigningKeyParametersSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParametersSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParametersSTATUS(gens map[string]gopter.Gen) {
	gens["ResourceGroupName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(KeyVaultSigningKeyParametersSTATUSTypeName_KeyVaultSigningKeyParameters))
	gens["VaultName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResponseBasedOriginErrorDetectionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResponseBasedOriginErrorDetectionParameters to ResponseBasedOriginErrorDetectionParameters via AssignPropertiesToResponseBasedOriginErrorDetectionParameters & AssignPropertiesFromResponseBasedOriginErrorDetectionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters, ResponseBasedOriginErrorDetectionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters tests if a specific instance of ResponseBasedOriginErrorDetectionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters(subject ResponseBasedOriginErrorDetectionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ResponseBasedOriginErrorDetectionParameters
	err := copied.AssignPropertiesToResponseBasedOriginErrorDetectionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResponseBasedOriginErrorDetectionParameters
	err = actual.AssignPropertiesFromResponseBasedOriginErrorDetectionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResponseBasedOriginErrorDetectionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResponseBasedOriginErrorDetectionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters, ResponseBasedOriginErrorDetectionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters runs a test to see if a specific instance of ResponseBasedOriginErrorDetectionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters(subject ResponseBasedOriginErrorDetectionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResponseBasedOriginErrorDetectionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResponseBasedOriginErrorDetectionParameters instances for property testing - lazily instantiated by
// ResponseBasedOriginErrorDetectionParametersGenerator()
var responseBasedOriginErrorDetectionParametersGenerator gopter.Gen

// ResponseBasedOriginErrorDetectionParametersGenerator returns a generator of ResponseBasedOriginErrorDetectionParameters instances for property testing.
// We first initialize responseBasedOriginErrorDetectionParametersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResponseBasedOriginErrorDetectionParametersGenerator() gopter.Gen {
	if responseBasedOriginErrorDetectionParametersGenerator != nil {
		return responseBasedOriginErrorDetectionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(generators)
	responseBasedOriginErrorDetectionParametersGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParameters{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(generators)
	AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(generators)
	responseBasedOriginErrorDetectionParametersGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParameters{}), generators)

	return responseBasedOriginErrorDetectionParametersGenerator
}

// AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(gens map[string]gopter.Gen) {
	gens["ResponseBasedDetectedErrorTypes"] = gen.PtrOf(gen.OneConstOf(ResponseBasedOriginErrorDetectionParametersResponseBasedDetectedErrorTypes_None, ResponseBasedOriginErrorDetectionParametersResponseBasedDetectedErrorTypes_TcpAndHttpErrors, ResponseBasedOriginErrorDetectionParametersResponseBasedDetectedErrorTypes_TcpErrorsOnly))
	gens["ResponseBasedFailoverThresholdPercentage"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(gens map[string]gopter.Gen) {
	gens["HttpErrorRanges"] = gen.SliceOf(HttpErrorRangeParametersGenerator())
}

func Test_ResponseBasedOriginErrorDetectionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResponseBasedOriginErrorDetectionParameters_STATUS to ResponseBasedOriginErrorDetectionParameters_STATUS via AssignPropertiesToResponseBasedOriginErrorDetectionParametersSTATUS & AssignPropertiesFromResponseBasedOriginErrorDetectionParametersSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParametersSTATUS, ResponseBasedOriginErrorDetectionParametersSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParametersSTATUS tests if a specific instance of ResponseBasedOriginErrorDetectionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParametersSTATUS(subject ResponseBasedOriginErrorDetectionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ResponseBasedOriginErrorDetectionParameters_STATUS
	err := copied.AssignPropertiesToResponseBasedOriginErrorDetectionParametersSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResponseBasedOriginErrorDetectionParameters_STATUS
	err = actual.AssignPropertiesFromResponseBasedOriginErrorDetectionParametersSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResponseBasedOriginErrorDetectionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResponseBasedOriginErrorDetectionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResponseBasedOriginErrorDetectionParametersSTATUS, ResponseBasedOriginErrorDetectionParametersSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResponseBasedOriginErrorDetectionParametersSTATUS runs a test to see if a specific instance of ResponseBasedOriginErrorDetectionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResponseBasedOriginErrorDetectionParametersSTATUS(subject ResponseBasedOriginErrorDetectionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResponseBasedOriginErrorDetectionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResponseBasedOriginErrorDetectionParameters_STATUS instances for property testing - lazily instantiated
// by ResponseBasedOriginErrorDetectionParametersSTATUSGenerator()
var responseBasedOriginErrorDetectionParametersSTATUSGenerator gopter.Gen

// ResponseBasedOriginErrorDetectionParametersSTATUSGenerator returns a generator of ResponseBasedOriginErrorDetectionParameters_STATUS instances for property testing.
// We first initialize responseBasedOriginErrorDetectionParametersSTATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResponseBasedOriginErrorDetectionParametersSTATUSGenerator() gopter.Gen {
	if responseBasedOriginErrorDetectionParametersSTATUSGenerator != nil {
		return responseBasedOriginErrorDetectionParametersSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersSTATUS(generators)
	responseBasedOriginErrorDetectionParametersSTATUSGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParameters_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersSTATUS(generators)
	AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersSTATUS(generators)
	responseBasedOriginErrorDetectionParametersSTATUSGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParameters_STATUS{}), generators)

	return responseBasedOriginErrorDetectionParametersSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersSTATUS(gens map[string]gopter.Gen) {
	gens["ResponseBasedDetectedErrorTypes"] = gen.PtrOf(gen.OneConstOf(ResponseBasedOriginErrorDetectionParametersSTATUSResponseBasedDetectedErrorTypes_None, ResponseBasedOriginErrorDetectionParametersSTATUSResponseBasedDetectedErrorTypes_TcpAndHttpErrors, ResponseBasedOriginErrorDetectionParametersSTATUSResponseBasedDetectedErrorTypes_TcpErrorsOnly))
	gens["ResponseBasedFailoverThresholdPercentage"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersSTATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersSTATUS(gens map[string]gopter.Gen) {
	gens["HttpErrorRanges"] = gen.SliceOf(HttpErrorRangeParametersSTATUSGenerator())
}

func Test_DeliveryRuleAction1_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleAction1 to DeliveryRuleAction1 via AssignPropertiesToDeliveryRuleAction1 & AssignPropertiesFromDeliveryRuleAction1 returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleAction1, DeliveryRuleAction1Generator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleAction1 tests if a specific instance of DeliveryRuleAction1 can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleAction1(subject DeliveryRuleAction1) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleAction1
	err := copied.AssignPropertiesToDeliveryRuleAction1(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleAction1
	err = actual.AssignPropertiesFromDeliveryRuleAction1(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleAction1_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleAction1 via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleAction1, DeliveryRuleAction1Generator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleAction1 runs a test to see if a specific instance of DeliveryRuleAction1 round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleAction1(subject DeliveryRuleAction1) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleAction1
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleAction1 instances for property testing - lazily instantiated by
// DeliveryRuleAction1Generator()
var deliveryRuleAction1Generator gopter.Gen

// DeliveryRuleAction1Generator returns a generator of DeliveryRuleAction1 instances for property testing.
func DeliveryRuleAction1Generator() gopter.Gen {
	if deliveryRuleAction1Generator != nil {
		return deliveryRuleAction1Generator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeliveryRuleAction1(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeliveryRuleAction1{}), map[string]gopter.Gen{
			propName: propGen,
		}))
	}
	deliveryRuleAction1Generator = gen.OneGenOf(gens...)

	return deliveryRuleAction1Generator
}

// AddRelatedPropertyGeneratorsForDeliveryRuleAction1 is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleAction1(gens map[string]gopter.Gen) {
	gens["DeliveryRuleCacheExpiration"] = DeliveryRuleCacheExpirationActionGenerator().Map(func(it DeliveryRuleCacheExpirationAction) *DeliveryRuleCacheExpirationAction {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleCacheKeyQueryString"] = DeliveryRuleCacheKeyQueryStringActionGenerator().Map(func(it DeliveryRuleCacheKeyQueryStringAction) *DeliveryRuleCacheKeyQueryStringAction {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestHeader"] = DeliveryRuleRequestHeaderActionGenerator().Map(func(it DeliveryRuleRequestHeaderAction) *DeliveryRuleRequestHeaderAction {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleResponseHeader"] = DeliveryRuleResponseHeaderActionGenerator().Map(func(it DeliveryRuleResponseHeaderAction) *DeliveryRuleResponseHeaderAction {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRouteConfigurationOverride"] = DeliveryRuleRouteConfigurationOverrideActionGenerator().Map(func(it DeliveryRuleRouteConfigurationOverrideAction) *DeliveryRuleRouteConfigurationOverrideAction {
		return &it
	}) // generate one case for OneOf type
	gens["OriginGroupOverride"] = OriginGroupOverrideActionGenerator().Map(func(it OriginGroupOverrideAction) *OriginGroupOverrideAction {
		return &it
	}) // generate one case for OneOf type
	gens["UrlRedirect"] = UrlRedirectActionGenerator().Map(func(it UrlRedirectAction) *UrlRedirectAction {
		return &it
	}) // generate one case for OneOf type
	gens["UrlRewrite"] = UrlRewriteActionGenerator().Map(func(it UrlRewriteAction) *UrlRewriteAction {
		return &it
	}) // generate one case for OneOf type
	gens["UrlSigning"] = UrlSigningActionGenerator().Map(func(it UrlSigningAction) *UrlSigningAction {
		return &it
	}) // generate one case for OneOf type
}

func Test_DeliveryRuleAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleAction_STATUS to DeliveryRuleAction_STATUS via AssignPropertiesToDeliveryRuleActionSTATUS & AssignPropertiesFromDeliveryRuleActionSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleActionSTATUS, DeliveryRuleActionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleActionSTATUS tests if a specific instance of DeliveryRuleAction_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleActionSTATUS(subject DeliveryRuleAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleAction_STATUS
	err := copied.AssignPropertiesToDeliveryRuleActionSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleAction_STATUS
	err = actual.AssignPropertiesFromDeliveryRuleActionSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleActionSTATUS, DeliveryRuleActionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleActionSTATUS runs a test to see if a specific instance of DeliveryRuleAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleActionSTATUS(subject DeliveryRuleAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleAction_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleActionSTATUSGenerator()
var deliveryRuleActionSTATUSGenerator gopter.Gen

// DeliveryRuleActionSTATUSGenerator returns a generator of DeliveryRuleAction_STATUS instances for property testing.
func DeliveryRuleActionSTATUSGenerator() gopter.Gen {
	if deliveryRuleActionSTATUSGenerator != nil {
		return deliveryRuleActionSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleActionSTATUS(generators)
	deliveryRuleActionSTATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleAction_STATUS{}), generators)

	return deliveryRuleActionSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleActionSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleActionSTATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DeliveryRuleActionSTATUSName_CacheExpiration,
		DeliveryRuleActionSTATUSName_CacheKeyQueryString,
		DeliveryRuleActionSTATUSName_ModifyRequestHeader,
		DeliveryRuleActionSTATUSName_ModifyResponseHeader,
		DeliveryRuleActionSTATUSName_OriginGroupOverride,
		DeliveryRuleActionSTATUSName_RouteConfigurationOverride,
		DeliveryRuleActionSTATUSName_UrlRedirect,
		DeliveryRuleActionSTATUSName_UrlRewrite,
		DeliveryRuleActionSTATUSName_UrlSigning))
}

func Test_DeliveryRuleCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCondition to DeliveryRuleCondition via AssignPropertiesToDeliveryRuleCondition & AssignPropertiesFromDeliveryRuleCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleCondition, DeliveryRuleConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleCondition tests if a specific instance of DeliveryRuleCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleCondition(subject DeliveryRuleCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCondition
	err := copied.AssignPropertiesToDeliveryRuleCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCondition
	err = actual.AssignPropertiesFromDeliveryRuleCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCondition, DeliveryRuleConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCondition runs a test to see if a specific instance of DeliveryRuleCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCondition(subject DeliveryRuleCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCondition instances for property testing - lazily instantiated by
// DeliveryRuleConditionGenerator()
var deliveryRuleConditionGenerator gopter.Gen

// DeliveryRuleConditionGenerator returns a generator of DeliveryRuleCondition instances for property testing.
func DeliveryRuleConditionGenerator() gopter.Gen {
	if deliveryRuleConditionGenerator != nil {
		return deliveryRuleConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeliveryRuleCondition(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeliveryRuleCondition{}), map[string]gopter.Gen{
			propName: propGen,
		}))
	}
	deliveryRuleConditionGenerator = gen.OneGenOf(gens...)

	return deliveryRuleConditionGenerator
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCondition(gens map[string]gopter.Gen) {
	gens["DeliveryRuleClientPort"] = DeliveryRuleClientPortConditionGenerator().Map(func(it DeliveryRuleClientPortCondition) *DeliveryRuleClientPortCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleCookies"] = DeliveryRuleCookiesConditionGenerator().Map(func(it DeliveryRuleCookiesCondition) *DeliveryRuleCookiesCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleHostName"] = DeliveryRuleHostNameConditionGenerator().Map(func(it DeliveryRuleHostNameCondition) *DeliveryRuleHostNameCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleHttpVersion"] = DeliveryRuleHttpVersionConditionGenerator().Map(func(it DeliveryRuleHttpVersionCondition) *DeliveryRuleHttpVersionCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleIsDevice"] = DeliveryRuleIsDeviceConditionGenerator().Map(func(it DeliveryRuleIsDeviceCondition) *DeliveryRuleIsDeviceCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRulePostArgs"] = DeliveryRulePostArgsConditionGenerator().Map(func(it DeliveryRulePostArgsCondition) *DeliveryRulePostArgsCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleQueryString"] = DeliveryRuleQueryStringConditionGenerator().Map(func(it DeliveryRuleQueryStringCondition) *DeliveryRuleQueryStringCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRemoteAddress"] = DeliveryRuleRemoteAddressConditionGenerator().Map(func(it DeliveryRuleRemoteAddressCondition) *DeliveryRuleRemoteAddressCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestBody"] = DeliveryRuleRequestBodyConditionGenerator().Map(func(it DeliveryRuleRequestBodyCondition) *DeliveryRuleRequestBodyCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestHeader"] = DeliveryRuleRequestHeaderConditionGenerator().Map(func(it DeliveryRuleRequestHeaderCondition) *DeliveryRuleRequestHeaderCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestMethod"] = DeliveryRuleRequestMethodConditionGenerator().Map(func(it DeliveryRuleRequestMethodCondition) *DeliveryRuleRequestMethodCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestScheme"] = DeliveryRuleRequestSchemeConditionGenerator().Map(func(it DeliveryRuleRequestSchemeCondition) *DeliveryRuleRequestSchemeCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestUri"] = DeliveryRuleRequestUriConditionGenerator().Map(func(it DeliveryRuleRequestUriCondition) *DeliveryRuleRequestUriCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleServerPort"] = DeliveryRuleServerPortConditionGenerator().Map(func(it DeliveryRuleServerPortCondition) *DeliveryRuleServerPortCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleSocketAddr"] = DeliveryRuleSocketAddrConditionGenerator().Map(func(it DeliveryRuleSocketAddrCondition) *DeliveryRuleSocketAddrCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleSslProtocol"] = DeliveryRuleSslProtocolConditionGenerator().Map(func(it DeliveryRuleSslProtocolCondition) *DeliveryRuleSslProtocolCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlFileExtension"] = DeliveryRuleUrlFileExtensionConditionGenerator().Map(func(it DeliveryRuleUrlFileExtensionCondition) *DeliveryRuleUrlFileExtensionCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlFileName"] = DeliveryRuleUrlFileNameConditionGenerator().Map(func(it DeliveryRuleUrlFileNameCondition) *DeliveryRuleUrlFileNameCondition {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlPath"] = DeliveryRuleUrlPathConditionGenerator().Map(func(it DeliveryRuleUrlPathCondition) *DeliveryRuleUrlPathCondition {
		return &it
	}) // generate one case for OneOf type
}

func Test_DeliveryRuleCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCondition_STATUS to DeliveryRuleCondition_STATUS via AssignPropertiesToDeliveryRuleConditionSTATUS & AssignPropertiesFromDeliveryRuleConditionSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleConditionSTATUS, DeliveryRuleConditionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleConditionSTATUS tests if a specific instance of DeliveryRuleCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleConditionSTATUS(subject DeliveryRuleCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCondition_STATUS
	err := copied.AssignPropertiesToDeliveryRuleConditionSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCondition_STATUS
	err = actual.AssignPropertiesFromDeliveryRuleConditionSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleConditionSTATUS, DeliveryRuleConditionSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleConditionSTATUS runs a test to see if a specific instance of DeliveryRuleCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleConditionSTATUS(subject DeliveryRuleCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleConditionSTATUSGenerator()
var deliveryRuleConditionSTATUSGenerator gopter.Gen

// DeliveryRuleConditionSTATUSGenerator returns a generator of DeliveryRuleCondition_STATUS instances for property testing.
func DeliveryRuleConditionSTATUSGenerator() gopter.Gen {
	if deliveryRuleConditionSTATUSGenerator != nil {
		return deliveryRuleConditionSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleConditionSTATUS(generators)
	deliveryRuleConditionSTATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCondition_STATUS{}), generators)

	return deliveryRuleConditionSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleConditionSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleConditionSTATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DeliveryRuleConditionSTATUSName_ClientPort,
		DeliveryRuleConditionSTATUSName_Cookies,
		DeliveryRuleConditionSTATUSName_HostName,
		DeliveryRuleConditionSTATUSName_HttpVersion,
		DeliveryRuleConditionSTATUSName_IsDevice,
		DeliveryRuleConditionSTATUSName_PostArgs,
		DeliveryRuleConditionSTATUSName_QueryString,
		DeliveryRuleConditionSTATUSName_RemoteAddress,
		DeliveryRuleConditionSTATUSName_RequestBody,
		DeliveryRuleConditionSTATUSName_RequestHeader,
		DeliveryRuleConditionSTATUSName_RequestMethod,
		DeliveryRuleConditionSTATUSName_RequestScheme,
		DeliveryRuleConditionSTATUSName_RequestUri,
		DeliveryRuleConditionSTATUSName_ServerPort,
		DeliveryRuleConditionSTATUSName_SocketAddr,
		DeliveryRuleConditionSTATUSName_SslProtocol,
		DeliveryRuleConditionSTATUSName_UrlFileExtension,
		DeliveryRuleConditionSTATUSName_UrlFileName,
		DeliveryRuleConditionSTATUSName_UrlPath))
}

func Test_HttpErrorRangeParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpErrorRangeParameters to HttpErrorRangeParameters via AssignPropertiesToHttpErrorRangeParameters & AssignPropertiesFromHttpErrorRangeParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpErrorRangeParameters, HttpErrorRangeParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpErrorRangeParameters tests if a specific instance of HttpErrorRangeParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHttpErrorRangeParameters(subject HttpErrorRangeParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HttpErrorRangeParameters
	err := copied.AssignPropertiesToHttpErrorRangeParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpErrorRangeParameters
	err = actual.AssignPropertiesFromHttpErrorRangeParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpErrorRangeParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpErrorRangeParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpErrorRangeParameters, HttpErrorRangeParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpErrorRangeParameters runs a test to see if a specific instance of HttpErrorRangeParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpErrorRangeParameters(subject HttpErrorRangeParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpErrorRangeParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpErrorRangeParameters instances for property testing - lazily instantiated by
// HttpErrorRangeParametersGenerator()
var httpErrorRangeParametersGenerator gopter.Gen

// HttpErrorRangeParametersGenerator returns a generator of HttpErrorRangeParameters instances for property testing.
func HttpErrorRangeParametersGenerator() gopter.Gen {
	if httpErrorRangeParametersGenerator != nil {
		return httpErrorRangeParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpErrorRangeParameters(generators)
	httpErrorRangeParametersGenerator = gen.Struct(reflect.TypeOf(HttpErrorRangeParameters{}), generators)

	return httpErrorRangeParametersGenerator
}

// AddIndependentPropertyGeneratorsForHttpErrorRangeParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpErrorRangeParameters(gens map[string]gopter.Gen) {
	gens["Begin"] = gen.PtrOf(gen.Int())
	gens["End"] = gen.PtrOf(gen.Int())
}

func Test_HttpErrorRangeParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpErrorRangeParameters_STATUS to HttpErrorRangeParameters_STATUS via AssignPropertiesToHttpErrorRangeParametersSTATUS & AssignPropertiesFromHttpErrorRangeParametersSTATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpErrorRangeParametersSTATUS, HttpErrorRangeParametersSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpErrorRangeParametersSTATUS tests if a specific instance of HttpErrorRangeParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHttpErrorRangeParametersSTATUS(subject HttpErrorRangeParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HttpErrorRangeParameters_STATUS
	err := copied.AssignPropertiesToHttpErrorRangeParametersSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpErrorRangeParameters_STATUS
	err = actual.AssignPropertiesFromHttpErrorRangeParametersSTATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpErrorRangeParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpErrorRangeParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpErrorRangeParametersSTATUS, HttpErrorRangeParametersSTATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpErrorRangeParametersSTATUS runs a test to see if a specific instance of HttpErrorRangeParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpErrorRangeParametersSTATUS(subject HttpErrorRangeParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpErrorRangeParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpErrorRangeParameters_STATUS instances for property testing - lazily instantiated by
// HttpErrorRangeParametersSTATUSGenerator()
var httpErrorRangeParametersSTATUSGenerator gopter.Gen

// HttpErrorRangeParametersSTATUSGenerator returns a generator of HttpErrorRangeParameters_STATUS instances for property testing.
func HttpErrorRangeParametersSTATUSGenerator() gopter.Gen {
	if httpErrorRangeParametersSTATUSGenerator != nil {
		return httpErrorRangeParametersSTATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpErrorRangeParametersSTATUS(generators)
	httpErrorRangeParametersSTATUSGenerator = gen.Struct(reflect.TypeOf(HttpErrorRangeParameters_STATUS{}), generators)

	return httpErrorRangeParametersSTATUSGenerator
}

// AddIndependentPropertyGeneratorsForHttpErrorRangeParametersSTATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpErrorRangeParametersSTATUS(gens map[string]gopter.Gen) {
	gens["Begin"] = gen.PtrOf(gen.Int())
	gens["End"] = gen.PtrOf(gen.Int())
}

func Test_DeliveryRuleCacheExpirationAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCacheExpirationAction to DeliveryRuleCacheExpirationAction via AssignPropertiesToDeliveryRuleCacheExpirationAction & AssignPropertiesFromDeliveryRuleCacheExpirationAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleCacheExpirationAction, DeliveryRuleCacheExpirationActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleCacheExpirationAction tests if a specific instance of DeliveryRuleCacheExpirationAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleCacheExpirationAction(subject DeliveryRuleCacheExpirationAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCacheExpirationAction
	err := copied.AssignPropertiesToDeliveryRuleCacheExpirationAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCacheExpirationAction
	err = actual.AssignPropertiesFromDeliveryRuleCacheExpirationAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCacheExpirationAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCacheExpirationAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCacheExpirationAction, DeliveryRuleCacheExpirationActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCacheExpirationAction runs a test to see if a specific instance of DeliveryRuleCacheExpirationAction round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCacheExpirationAction(subject DeliveryRuleCacheExpirationAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCacheExpirationAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCacheExpirationAction instances for property testing - lazily instantiated by
// DeliveryRuleCacheExpirationActionGenerator()
var deliveryRuleCacheExpirationActionGenerator gopter.Gen

// DeliveryRuleCacheExpirationActionGenerator returns a generator of DeliveryRuleCacheExpirationAction instances for property testing.
// We first initialize deliveryRuleCacheExpirationActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCacheExpirationActionGenerator() gopter.Gen {
	if deliveryRuleCacheExpirationActionGenerator != nil {
		return deliveryRuleCacheExpirationActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction(generators)
	deliveryRuleCacheExpirationActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheExpirationAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationAction(generators)
	deliveryRuleCacheExpirationActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheExpirationAction{}), generators)

	return deliveryRuleCacheExpirationActionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleCacheExpirationActionName_CacheExpiration))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CacheExpirationActionParametersGenerator())
}

func Test_DeliveryRuleCacheKeyQueryStringAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCacheKeyQueryStringAction to DeliveryRuleCacheKeyQueryStringAction via AssignPropertiesToDeliveryRuleCacheKeyQueryStringAction & AssignPropertiesFromDeliveryRuleCacheKeyQueryStringAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleCacheKeyQueryStringAction, DeliveryRuleCacheKeyQueryStringActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleCacheKeyQueryStringAction tests if a specific instance of DeliveryRuleCacheKeyQueryStringAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleCacheKeyQueryStringAction(subject DeliveryRuleCacheKeyQueryStringAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCacheKeyQueryStringAction
	err := copied.AssignPropertiesToDeliveryRuleCacheKeyQueryStringAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCacheKeyQueryStringAction
	err = actual.AssignPropertiesFromDeliveryRuleCacheKeyQueryStringAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCacheKeyQueryStringAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCacheKeyQueryStringAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringAction, DeliveryRuleCacheKeyQueryStringActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringAction runs a test to see if a specific instance of DeliveryRuleCacheKeyQueryStringAction round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringAction(subject DeliveryRuleCacheKeyQueryStringAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCacheKeyQueryStringAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCacheKeyQueryStringAction instances for property testing - lazily instantiated by
// DeliveryRuleCacheKeyQueryStringActionGenerator()
var deliveryRuleCacheKeyQueryStringActionGenerator gopter.Gen

// DeliveryRuleCacheKeyQueryStringActionGenerator returns a generator of DeliveryRuleCacheKeyQueryStringAction instances for property testing.
// We first initialize deliveryRuleCacheKeyQueryStringActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCacheKeyQueryStringActionGenerator() gopter.Gen {
	if deliveryRuleCacheKeyQueryStringActionGenerator != nil {
		return deliveryRuleCacheKeyQueryStringActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction(generators)
	deliveryRuleCacheKeyQueryStringActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheKeyQueryStringAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction(generators)
	deliveryRuleCacheKeyQueryStringActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheKeyQueryStringAction{}), generators)

	return deliveryRuleCacheKeyQueryStringActionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleCacheKeyQueryStringActionName_CacheKeyQueryString))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CacheKeyQueryStringActionParametersGenerator())
}

func Test_DeliveryRuleClientPortCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleClientPortCondition to DeliveryRuleClientPortCondition via AssignPropertiesToDeliveryRuleClientPortCondition & AssignPropertiesFromDeliveryRuleClientPortCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleClientPortCondition, DeliveryRuleClientPortConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleClientPortCondition tests if a specific instance of DeliveryRuleClientPortCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleClientPortCondition(subject DeliveryRuleClientPortCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleClientPortCondition
	err := copied.AssignPropertiesToDeliveryRuleClientPortCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleClientPortCondition
	err = actual.AssignPropertiesFromDeliveryRuleClientPortCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleClientPortCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleClientPortCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleClientPortCondition, DeliveryRuleClientPortConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleClientPortCondition runs a test to see if a specific instance of DeliveryRuleClientPortCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleClientPortCondition(subject DeliveryRuleClientPortCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleClientPortCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleClientPortCondition instances for property testing - lazily instantiated by
// DeliveryRuleClientPortConditionGenerator()
var deliveryRuleClientPortConditionGenerator gopter.Gen

// DeliveryRuleClientPortConditionGenerator returns a generator of DeliveryRuleClientPortCondition instances for property testing.
// We first initialize deliveryRuleClientPortConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleClientPortConditionGenerator() gopter.Gen {
	if deliveryRuleClientPortConditionGenerator != nil {
		return deliveryRuleClientPortConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition(generators)
	deliveryRuleClientPortConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleClientPortCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleClientPortCondition(generators)
	deliveryRuleClientPortConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleClientPortCondition{}), generators)

	return deliveryRuleClientPortConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleClientPortConditionName_ClientPort))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleClientPortCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleClientPortCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(ClientPortMatchConditionParametersGenerator())
}

func Test_DeliveryRuleCookiesCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCookiesCondition to DeliveryRuleCookiesCondition via AssignPropertiesToDeliveryRuleCookiesCondition & AssignPropertiesFromDeliveryRuleCookiesCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleCookiesCondition, DeliveryRuleCookiesConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleCookiesCondition tests if a specific instance of DeliveryRuleCookiesCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleCookiesCondition(subject DeliveryRuleCookiesCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCookiesCondition
	err := copied.AssignPropertiesToDeliveryRuleCookiesCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCookiesCondition
	err = actual.AssignPropertiesFromDeliveryRuleCookiesCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCookiesCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCookiesCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCookiesCondition, DeliveryRuleCookiesConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCookiesCondition runs a test to see if a specific instance of DeliveryRuleCookiesCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCookiesCondition(subject DeliveryRuleCookiesCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCookiesCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCookiesCondition instances for property testing - lazily instantiated by
// DeliveryRuleCookiesConditionGenerator()
var deliveryRuleCookiesConditionGenerator gopter.Gen

// DeliveryRuleCookiesConditionGenerator returns a generator of DeliveryRuleCookiesCondition instances for property testing.
// We first initialize deliveryRuleCookiesConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCookiesConditionGenerator() gopter.Gen {
	if deliveryRuleCookiesConditionGenerator != nil {
		return deliveryRuleCookiesConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition(generators)
	deliveryRuleCookiesConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCookiesCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCookiesCondition(generators)
	deliveryRuleCookiesConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCookiesCondition{}), generators)

	return deliveryRuleCookiesConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleCookiesConditionName_Cookies))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCookiesCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCookiesCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CookiesMatchConditionParametersGenerator())
}

func Test_DeliveryRuleHostNameCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleHostNameCondition to DeliveryRuleHostNameCondition via AssignPropertiesToDeliveryRuleHostNameCondition & AssignPropertiesFromDeliveryRuleHostNameCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleHostNameCondition, DeliveryRuleHostNameConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleHostNameCondition tests if a specific instance of DeliveryRuleHostNameCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleHostNameCondition(subject DeliveryRuleHostNameCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleHostNameCondition
	err := copied.AssignPropertiesToDeliveryRuleHostNameCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleHostNameCondition
	err = actual.AssignPropertiesFromDeliveryRuleHostNameCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleHostNameCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleHostNameCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleHostNameCondition, DeliveryRuleHostNameConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleHostNameCondition runs a test to see if a specific instance of DeliveryRuleHostNameCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleHostNameCondition(subject DeliveryRuleHostNameCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleHostNameCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleHostNameCondition instances for property testing - lazily instantiated by
// DeliveryRuleHostNameConditionGenerator()
var deliveryRuleHostNameConditionGenerator gopter.Gen

// DeliveryRuleHostNameConditionGenerator returns a generator of DeliveryRuleHostNameCondition instances for property testing.
// We first initialize deliveryRuleHostNameConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleHostNameConditionGenerator() gopter.Gen {
	if deliveryRuleHostNameConditionGenerator != nil {
		return deliveryRuleHostNameConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition(generators)
	deliveryRuleHostNameConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHostNameCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleHostNameCondition(generators)
	deliveryRuleHostNameConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHostNameCondition{}), generators)

	return deliveryRuleHostNameConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleHostNameConditionName_HostName))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleHostNameCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleHostNameCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HostNameMatchConditionParametersGenerator())
}

func Test_DeliveryRuleHttpVersionCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleHttpVersionCondition to DeliveryRuleHttpVersionCondition via AssignPropertiesToDeliveryRuleHttpVersionCondition & AssignPropertiesFromDeliveryRuleHttpVersionCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleHttpVersionCondition, DeliveryRuleHttpVersionConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleHttpVersionCondition tests if a specific instance of DeliveryRuleHttpVersionCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleHttpVersionCondition(subject DeliveryRuleHttpVersionCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleHttpVersionCondition
	err := copied.AssignPropertiesToDeliveryRuleHttpVersionCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleHttpVersionCondition
	err = actual.AssignPropertiesFromDeliveryRuleHttpVersionCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleHttpVersionCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleHttpVersionCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleHttpVersionCondition, DeliveryRuleHttpVersionConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleHttpVersionCondition runs a test to see if a specific instance of DeliveryRuleHttpVersionCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleHttpVersionCondition(subject DeliveryRuleHttpVersionCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleHttpVersionCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleHttpVersionCondition instances for property testing - lazily instantiated by
// DeliveryRuleHttpVersionConditionGenerator()
var deliveryRuleHttpVersionConditionGenerator gopter.Gen

// DeliveryRuleHttpVersionConditionGenerator returns a generator of DeliveryRuleHttpVersionCondition instances for property testing.
// We first initialize deliveryRuleHttpVersionConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleHttpVersionConditionGenerator() gopter.Gen {
	if deliveryRuleHttpVersionConditionGenerator != nil {
		return deliveryRuleHttpVersionConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition(generators)
	deliveryRuleHttpVersionConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHttpVersionCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionCondition(generators)
	deliveryRuleHttpVersionConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHttpVersionCondition{}), generators)

	return deliveryRuleHttpVersionConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleHttpVersionConditionName_HttpVersion))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HttpVersionMatchConditionParametersGenerator())
}

func Test_DeliveryRuleIsDeviceCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleIsDeviceCondition to DeliveryRuleIsDeviceCondition via AssignPropertiesToDeliveryRuleIsDeviceCondition & AssignPropertiesFromDeliveryRuleIsDeviceCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleIsDeviceCondition, DeliveryRuleIsDeviceConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleIsDeviceCondition tests if a specific instance of DeliveryRuleIsDeviceCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleIsDeviceCondition(subject DeliveryRuleIsDeviceCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleIsDeviceCondition
	err := copied.AssignPropertiesToDeliveryRuleIsDeviceCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleIsDeviceCondition
	err = actual.AssignPropertiesFromDeliveryRuleIsDeviceCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleIsDeviceCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleIsDeviceCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleIsDeviceCondition, DeliveryRuleIsDeviceConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleIsDeviceCondition runs a test to see if a specific instance of DeliveryRuleIsDeviceCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleIsDeviceCondition(subject DeliveryRuleIsDeviceCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleIsDeviceCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleIsDeviceCondition instances for property testing - lazily instantiated by
// DeliveryRuleIsDeviceConditionGenerator()
var deliveryRuleIsDeviceConditionGenerator gopter.Gen

// DeliveryRuleIsDeviceConditionGenerator returns a generator of DeliveryRuleIsDeviceCondition instances for property testing.
// We first initialize deliveryRuleIsDeviceConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleIsDeviceConditionGenerator() gopter.Gen {
	if deliveryRuleIsDeviceConditionGenerator != nil {
		return deliveryRuleIsDeviceConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition(generators)
	deliveryRuleIsDeviceConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleIsDeviceCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceCondition(generators)
	deliveryRuleIsDeviceConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleIsDeviceCondition{}), generators)

	return deliveryRuleIsDeviceConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleIsDeviceConditionName_IsDevice))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(IsDeviceMatchConditionParametersGenerator())
}

func Test_DeliveryRulePostArgsCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRulePostArgsCondition to DeliveryRulePostArgsCondition via AssignPropertiesToDeliveryRulePostArgsCondition & AssignPropertiesFromDeliveryRulePostArgsCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRulePostArgsCondition, DeliveryRulePostArgsConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRulePostArgsCondition tests if a specific instance of DeliveryRulePostArgsCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRulePostArgsCondition(subject DeliveryRulePostArgsCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRulePostArgsCondition
	err := copied.AssignPropertiesToDeliveryRulePostArgsCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRulePostArgsCondition
	err = actual.AssignPropertiesFromDeliveryRulePostArgsCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRulePostArgsCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRulePostArgsCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRulePostArgsCondition, DeliveryRulePostArgsConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRulePostArgsCondition runs a test to see if a specific instance of DeliveryRulePostArgsCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRulePostArgsCondition(subject DeliveryRulePostArgsCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRulePostArgsCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRulePostArgsCondition instances for property testing - lazily instantiated by
// DeliveryRulePostArgsConditionGenerator()
var deliveryRulePostArgsConditionGenerator gopter.Gen

// DeliveryRulePostArgsConditionGenerator returns a generator of DeliveryRulePostArgsCondition instances for property testing.
// We first initialize deliveryRulePostArgsConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRulePostArgsConditionGenerator() gopter.Gen {
	if deliveryRulePostArgsConditionGenerator != nil {
		return deliveryRulePostArgsConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition(generators)
	deliveryRulePostArgsConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRulePostArgsCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRulePostArgsCondition(generators)
	deliveryRulePostArgsConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRulePostArgsCondition{}), generators)

	return deliveryRulePostArgsConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRulePostArgsConditionName_PostArgs))
}

// AddRelatedPropertyGeneratorsForDeliveryRulePostArgsCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRulePostArgsCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(PostArgsMatchConditionParametersGenerator())
}

func Test_DeliveryRuleQueryStringCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleQueryStringCondition to DeliveryRuleQueryStringCondition via AssignPropertiesToDeliveryRuleQueryStringCondition & AssignPropertiesFromDeliveryRuleQueryStringCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleQueryStringCondition, DeliveryRuleQueryStringConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleQueryStringCondition tests if a specific instance of DeliveryRuleQueryStringCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleQueryStringCondition(subject DeliveryRuleQueryStringCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleQueryStringCondition
	err := copied.AssignPropertiesToDeliveryRuleQueryStringCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleQueryStringCondition
	err = actual.AssignPropertiesFromDeliveryRuleQueryStringCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleQueryStringCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleQueryStringCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleQueryStringCondition, DeliveryRuleQueryStringConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleQueryStringCondition runs a test to see if a specific instance of DeliveryRuleQueryStringCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleQueryStringCondition(subject DeliveryRuleQueryStringCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleQueryStringCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleQueryStringCondition instances for property testing - lazily instantiated by
// DeliveryRuleQueryStringConditionGenerator()
var deliveryRuleQueryStringConditionGenerator gopter.Gen

// DeliveryRuleQueryStringConditionGenerator returns a generator of DeliveryRuleQueryStringCondition instances for property testing.
// We first initialize deliveryRuleQueryStringConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleQueryStringConditionGenerator() gopter.Gen {
	if deliveryRuleQueryStringConditionGenerator != nil {
		return deliveryRuleQueryStringConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition(generators)
	deliveryRuleQueryStringConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleQueryStringCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringCondition(generators)
	deliveryRuleQueryStringConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleQueryStringCondition{}), generators)

	return deliveryRuleQueryStringConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleQueryStringConditionName_QueryString))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(QueryStringMatchConditionParametersGenerator())
}

func Test_DeliveryRuleRemoteAddressCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRemoteAddressCondition to DeliveryRuleRemoteAddressCondition via AssignPropertiesToDeliveryRuleRemoteAddressCondition & AssignPropertiesFromDeliveryRuleRemoteAddressCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRemoteAddressCondition, DeliveryRuleRemoteAddressConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRemoteAddressCondition tests if a specific instance of DeliveryRuleRemoteAddressCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRemoteAddressCondition(subject DeliveryRuleRemoteAddressCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRemoteAddressCondition
	err := copied.AssignPropertiesToDeliveryRuleRemoteAddressCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRemoteAddressCondition
	err = actual.AssignPropertiesFromDeliveryRuleRemoteAddressCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRemoteAddressCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRemoteAddressCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRemoteAddressCondition, DeliveryRuleRemoteAddressConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRemoteAddressCondition runs a test to see if a specific instance of DeliveryRuleRemoteAddressCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRemoteAddressCondition(subject DeliveryRuleRemoteAddressCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRemoteAddressCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRemoteAddressCondition instances for property testing - lazily instantiated by
// DeliveryRuleRemoteAddressConditionGenerator()
var deliveryRuleRemoteAddressConditionGenerator gopter.Gen

// DeliveryRuleRemoteAddressConditionGenerator returns a generator of DeliveryRuleRemoteAddressCondition instances for property testing.
// We first initialize deliveryRuleRemoteAddressConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRemoteAddressConditionGenerator() gopter.Gen {
	if deliveryRuleRemoteAddressConditionGenerator != nil {
		return deliveryRuleRemoteAddressConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition(generators)
	deliveryRuleRemoteAddressConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRemoteAddressCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressCondition(generators)
	deliveryRuleRemoteAddressConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRemoteAddressCondition{}), generators)

	return deliveryRuleRemoteAddressConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleRemoteAddressConditionName_RemoteAddress))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RemoteAddressMatchConditionParametersGenerator())
}

func Test_DeliveryRuleRequestBodyCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestBodyCondition to DeliveryRuleRequestBodyCondition via AssignPropertiesToDeliveryRuleRequestBodyCondition & AssignPropertiesFromDeliveryRuleRequestBodyCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestBodyCondition, DeliveryRuleRequestBodyConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestBodyCondition tests if a specific instance of DeliveryRuleRequestBodyCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestBodyCondition(subject DeliveryRuleRequestBodyCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestBodyCondition
	err := copied.AssignPropertiesToDeliveryRuleRequestBodyCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestBodyCondition
	err = actual.AssignPropertiesFromDeliveryRuleRequestBodyCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestBodyCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestBodyCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestBodyCondition, DeliveryRuleRequestBodyConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestBodyCondition runs a test to see if a specific instance of DeliveryRuleRequestBodyCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestBodyCondition(subject DeliveryRuleRequestBodyCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestBodyCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestBodyCondition instances for property testing - lazily instantiated by
// DeliveryRuleRequestBodyConditionGenerator()
var deliveryRuleRequestBodyConditionGenerator gopter.Gen

// DeliveryRuleRequestBodyConditionGenerator returns a generator of DeliveryRuleRequestBodyCondition instances for property testing.
// We first initialize deliveryRuleRequestBodyConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestBodyConditionGenerator() gopter.Gen {
	if deliveryRuleRequestBodyConditionGenerator != nil {
		return deliveryRuleRequestBodyConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition(generators)
	deliveryRuleRequestBodyConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestBodyCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyCondition(generators)
	deliveryRuleRequestBodyConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestBodyCondition{}), generators)

	return deliveryRuleRequestBodyConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleRequestBodyConditionName_RequestBody))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestBodyMatchConditionParametersGenerator())
}

func Test_DeliveryRuleRequestHeaderAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestHeaderAction to DeliveryRuleRequestHeaderAction via AssignPropertiesToDeliveryRuleRequestHeaderAction & AssignPropertiesFromDeliveryRuleRequestHeaderAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestHeaderAction, DeliveryRuleRequestHeaderActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestHeaderAction tests if a specific instance of DeliveryRuleRequestHeaderAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestHeaderAction(subject DeliveryRuleRequestHeaderAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestHeaderAction
	err := copied.AssignPropertiesToDeliveryRuleRequestHeaderAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestHeaderAction
	err = actual.AssignPropertiesFromDeliveryRuleRequestHeaderAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestHeaderAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestHeaderAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestHeaderAction, DeliveryRuleRequestHeaderActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestHeaderAction runs a test to see if a specific instance of DeliveryRuleRequestHeaderAction round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestHeaderAction(subject DeliveryRuleRequestHeaderAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestHeaderAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestHeaderAction instances for property testing - lazily instantiated by
// DeliveryRuleRequestHeaderActionGenerator()
var deliveryRuleRequestHeaderActionGenerator gopter.Gen

// DeliveryRuleRequestHeaderActionGenerator returns a generator of DeliveryRuleRequestHeaderAction instances for property testing.
// We first initialize deliveryRuleRequestHeaderActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestHeaderActionGenerator() gopter.Gen {
	if deliveryRuleRequestHeaderActionGenerator != nil {
		return deliveryRuleRequestHeaderActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction(generators)
	deliveryRuleRequestHeaderActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderAction(generators)
	deliveryRuleRequestHeaderActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderAction{}), generators)

	return deliveryRuleRequestHeaderActionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleRequestHeaderActionName_ModifyRequestHeader))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HeaderActionParametersGenerator())
}

func Test_DeliveryRuleRequestHeaderCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestHeaderCondition to DeliveryRuleRequestHeaderCondition via AssignPropertiesToDeliveryRuleRequestHeaderCondition & AssignPropertiesFromDeliveryRuleRequestHeaderCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestHeaderCondition, DeliveryRuleRequestHeaderConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestHeaderCondition tests if a specific instance of DeliveryRuleRequestHeaderCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestHeaderCondition(subject DeliveryRuleRequestHeaderCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestHeaderCondition
	err := copied.AssignPropertiesToDeliveryRuleRequestHeaderCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestHeaderCondition
	err = actual.AssignPropertiesFromDeliveryRuleRequestHeaderCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestHeaderCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestHeaderCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestHeaderCondition, DeliveryRuleRequestHeaderConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestHeaderCondition runs a test to see if a specific instance of DeliveryRuleRequestHeaderCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestHeaderCondition(subject DeliveryRuleRequestHeaderCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestHeaderCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestHeaderCondition instances for property testing - lazily instantiated by
// DeliveryRuleRequestHeaderConditionGenerator()
var deliveryRuleRequestHeaderConditionGenerator gopter.Gen

// DeliveryRuleRequestHeaderConditionGenerator returns a generator of DeliveryRuleRequestHeaderCondition instances for property testing.
// We first initialize deliveryRuleRequestHeaderConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestHeaderConditionGenerator() gopter.Gen {
	if deliveryRuleRequestHeaderConditionGenerator != nil {
		return deliveryRuleRequestHeaderConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition(generators)
	deliveryRuleRequestHeaderConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderCondition(generators)
	deliveryRuleRequestHeaderConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderCondition{}), generators)

	return deliveryRuleRequestHeaderConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleRequestHeaderConditionName_RequestHeader))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestHeaderMatchConditionParametersGenerator())
}

func Test_DeliveryRuleRequestMethodCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestMethodCondition to DeliveryRuleRequestMethodCondition via AssignPropertiesToDeliveryRuleRequestMethodCondition & AssignPropertiesFromDeliveryRuleRequestMethodCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestMethodCondition, DeliveryRuleRequestMethodConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestMethodCondition tests if a specific instance of DeliveryRuleRequestMethodCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestMethodCondition(subject DeliveryRuleRequestMethodCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestMethodCondition
	err := copied.AssignPropertiesToDeliveryRuleRequestMethodCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestMethodCondition
	err = actual.AssignPropertiesFromDeliveryRuleRequestMethodCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestMethodCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestMethodCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestMethodCondition, DeliveryRuleRequestMethodConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestMethodCondition runs a test to see if a specific instance of DeliveryRuleRequestMethodCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestMethodCondition(subject DeliveryRuleRequestMethodCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestMethodCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestMethodCondition instances for property testing - lazily instantiated by
// DeliveryRuleRequestMethodConditionGenerator()
var deliveryRuleRequestMethodConditionGenerator gopter.Gen

// DeliveryRuleRequestMethodConditionGenerator returns a generator of DeliveryRuleRequestMethodCondition instances for property testing.
// We first initialize deliveryRuleRequestMethodConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestMethodConditionGenerator() gopter.Gen {
	if deliveryRuleRequestMethodConditionGenerator != nil {
		return deliveryRuleRequestMethodConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition(generators)
	deliveryRuleRequestMethodConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestMethodCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodCondition(generators)
	deliveryRuleRequestMethodConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestMethodCondition{}), generators)

	return deliveryRuleRequestMethodConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleRequestMethodConditionName_RequestMethod))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestMethodMatchConditionParametersGenerator())
}

func Test_DeliveryRuleRequestSchemeCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestSchemeCondition to DeliveryRuleRequestSchemeCondition via AssignPropertiesToDeliveryRuleRequestSchemeCondition & AssignPropertiesFromDeliveryRuleRequestSchemeCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestSchemeCondition, DeliveryRuleRequestSchemeConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestSchemeCondition tests if a specific instance of DeliveryRuleRequestSchemeCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestSchemeCondition(subject DeliveryRuleRequestSchemeCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestSchemeCondition
	err := copied.AssignPropertiesToDeliveryRuleRequestSchemeCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestSchemeCondition
	err = actual.AssignPropertiesFromDeliveryRuleRequestSchemeCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestSchemeCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestSchemeCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestSchemeCondition, DeliveryRuleRequestSchemeConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestSchemeCondition runs a test to see if a specific instance of DeliveryRuleRequestSchemeCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestSchemeCondition(subject DeliveryRuleRequestSchemeCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestSchemeCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestSchemeCondition instances for property testing - lazily instantiated by
// DeliveryRuleRequestSchemeConditionGenerator()
var deliveryRuleRequestSchemeConditionGenerator gopter.Gen

// DeliveryRuleRequestSchemeConditionGenerator returns a generator of DeliveryRuleRequestSchemeCondition instances for property testing.
// We first initialize deliveryRuleRequestSchemeConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestSchemeConditionGenerator() gopter.Gen {
	if deliveryRuleRequestSchemeConditionGenerator != nil {
		return deliveryRuleRequestSchemeConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition(generators)
	deliveryRuleRequestSchemeConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestSchemeCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeCondition(generators)
	deliveryRuleRequestSchemeConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestSchemeCondition{}), generators)

	return deliveryRuleRequestSchemeConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleRequestSchemeConditionName_RequestScheme))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestSchemeMatchConditionParametersGenerator())
}

func Test_DeliveryRuleRequestUriCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRequestUriCondition to DeliveryRuleRequestUriCondition via AssignPropertiesToDeliveryRuleRequestUriCondition & AssignPropertiesFromDeliveryRuleRequestUriCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRequestUriCondition, DeliveryRuleRequestUriConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRequestUriCondition tests if a specific instance of DeliveryRuleRequestUriCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRequestUriCondition(subject DeliveryRuleRequestUriCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRequestUriCondition
	err := copied.AssignPropertiesToDeliveryRuleRequestUriCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRequestUriCondition
	err = actual.AssignPropertiesFromDeliveryRuleRequestUriCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRequestUriCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestUriCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestUriCondition, DeliveryRuleRequestUriConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestUriCondition runs a test to see if a specific instance of DeliveryRuleRequestUriCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestUriCondition(subject DeliveryRuleRequestUriCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestUriCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestUriCondition instances for property testing - lazily instantiated by
// DeliveryRuleRequestUriConditionGenerator()
var deliveryRuleRequestUriConditionGenerator gopter.Gen

// DeliveryRuleRequestUriConditionGenerator returns a generator of DeliveryRuleRequestUriCondition instances for property testing.
// We first initialize deliveryRuleRequestUriConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestUriConditionGenerator() gopter.Gen {
	if deliveryRuleRequestUriConditionGenerator != nil {
		return deliveryRuleRequestUriConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition(generators)
	deliveryRuleRequestUriConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestUriCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriCondition(generators)
	deliveryRuleRequestUriConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestUriCondition{}), generators)

	return deliveryRuleRequestUriConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleRequestUriConditionName_RequestUri))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestUriMatchConditionParametersGenerator())
}

func Test_DeliveryRuleResponseHeaderAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleResponseHeaderAction to DeliveryRuleResponseHeaderAction via AssignPropertiesToDeliveryRuleResponseHeaderAction & AssignPropertiesFromDeliveryRuleResponseHeaderAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleResponseHeaderAction, DeliveryRuleResponseHeaderActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleResponseHeaderAction tests if a specific instance of DeliveryRuleResponseHeaderAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleResponseHeaderAction(subject DeliveryRuleResponseHeaderAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleResponseHeaderAction
	err := copied.AssignPropertiesToDeliveryRuleResponseHeaderAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleResponseHeaderAction
	err = actual.AssignPropertiesFromDeliveryRuleResponseHeaderAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleResponseHeaderAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleResponseHeaderAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleResponseHeaderAction, DeliveryRuleResponseHeaderActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleResponseHeaderAction runs a test to see if a specific instance of DeliveryRuleResponseHeaderAction round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleResponseHeaderAction(subject DeliveryRuleResponseHeaderAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleResponseHeaderAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleResponseHeaderAction instances for property testing - lazily instantiated by
// DeliveryRuleResponseHeaderActionGenerator()
var deliveryRuleResponseHeaderActionGenerator gopter.Gen

// DeliveryRuleResponseHeaderActionGenerator returns a generator of DeliveryRuleResponseHeaderAction instances for property testing.
// We first initialize deliveryRuleResponseHeaderActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleResponseHeaderActionGenerator() gopter.Gen {
	if deliveryRuleResponseHeaderActionGenerator != nil {
		return deliveryRuleResponseHeaderActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction(generators)
	deliveryRuleResponseHeaderActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleResponseHeaderAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderAction(generators)
	deliveryRuleResponseHeaderActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleResponseHeaderAction{}), generators)

	return deliveryRuleResponseHeaderActionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleResponseHeaderActionName_ModifyResponseHeader))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HeaderActionParametersGenerator())
}

func Test_DeliveryRuleRouteConfigurationOverrideAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleRouteConfigurationOverrideAction to DeliveryRuleRouteConfigurationOverrideAction via AssignPropertiesToDeliveryRuleRouteConfigurationOverrideAction & AssignPropertiesFromDeliveryRuleRouteConfigurationOverrideAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleRouteConfigurationOverrideAction, DeliveryRuleRouteConfigurationOverrideActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleRouteConfigurationOverrideAction tests if a specific instance of DeliveryRuleRouteConfigurationOverrideAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleRouteConfigurationOverrideAction(subject DeliveryRuleRouteConfigurationOverrideAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleRouteConfigurationOverrideAction
	err := copied.AssignPropertiesToDeliveryRuleRouteConfigurationOverrideAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleRouteConfigurationOverrideAction
	err = actual.AssignPropertiesFromDeliveryRuleRouteConfigurationOverrideAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleRouteConfigurationOverrideAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRouteConfigurationOverrideAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideAction, DeliveryRuleRouteConfigurationOverrideActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideAction runs a test to see if a specific instance of DeliveryRuleRouteConfigurationOverrideAction round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideAction(subject DeliveryRuleRouteConfigurationOverrideAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRouteConfigurationOverrideAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRouteConfigurationOverrideAction instances for property testing - lazily instantiated by
// DeliveryRuleRouteConfigurationOverrideActionGenerator()
var deliveryRuleRouteConfigurationOverrideActionGenerator gopter.Gen

// DeliveryRuleRouteConfigurationOverrideActionGenerator returns a generator of DeliveryRuleRouteConfigurationOverrideAction instances for property testing.
// We first initialize deliveryRuleRouteConfigurationOverrideActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRouteConfigurationOverrideActionGenerator() gopter.Gen {
	if deliveryRuleRouteConfigurationOverrideActionGenerator != nil {
		return deliveryRuleRouteConfigurationOverrideActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction(generators)
	deliveryRuleRouteConfigurationOverrideActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRouteConfigurationOverrideAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction(generators)
	deliveryRuleRouteConfigurationOverrideActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRouteConfigurationOverrideAction{}), generators)

	return deliveryRuleRouteConfigurationOverrideActionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleRouteConfigurationOverrideActionName_RouteConfigurationOverride))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RouteConfigurationOverrideActionParametersGenerator())
}

func Test_DeliveryRuleServerPortCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleServerPortCondition to DeliveryRuleServerPortCondition via AssignPropertiesToDeliveryRuleServerPortCondition & AssignPropertiesFromDeliveryRuleServerPortCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleServerPortCondition, DeliveryRuleServerPortConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleServerPortCondition tests if a specific instance of DeliveryRuleServerPortCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleServerPortCondition(subject DeliveryRuleServerPortCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleServerPortCondition
	err := copied.AssignPropertiesToDeliveryRuleServerPortCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleServerPortCondition
	err = actual.AssignPropertiesFromDeliveryRuleServerPortCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleServerPortCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleServerPortCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleServerPortCondition, DeliveryRuleServerPortConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleServerPortCondition runs a test to see if a specific instance of DeliveryRuleServerPortCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleServerPortCondition(subject DeliveryRuleServerPortCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleServerPortCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleServerPortCondition instances for property testing - lazily instantiated by
// DeliveryRuleServerPortConditionGenerator()
var deliveryRuleServerPortConditionGenerator gopter.Gen

// DeliveryRuleServerPortConditionGenerator returns a generator of DeliveryRuleServerPortCondition instances for property testing.
// We first initialize deliveryRuleServerPortConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleServerPortConditionGenerator() gopter.Gen {
	if deliveryRuleServerPortConditionGenerator != nil {
		return deliveryRuleServerPortConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition(generators)
	deliveryRuleServerPortConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleServerPortCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleServerPortCondition(generators)
	deliveryRuleServerPortConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleServerPortCondition{}), generators)

	return deliveryRuleServerPortConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleServerPortConditionName_ServerPort))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleServerPortCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleServerPortCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(ServerPortMatchConditionParametersGenerator())
}

func Test_DeliveryRuleSocketAddrCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleSocketAddrCondition to DeliveryRuleSocketAddrCondition via AssignPropertiesToDeliveryRuleSocketAddrCondition & AssignPropertiesFromDeliveryRuleSocketAddrCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleSocketAddrCondition, DeliveryRuleSocketAddrConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleSocketAddrCondition tests if a specific instance of DeliveryRuleSocketAddrCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleSocketAddrCondition(subject DeliveryRuleSocketAddrCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleSocketAddrCondition
	err := copied.AssignPropertiesToDeliveryRuleSocketAddrCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleSocketAddrCondition
	err = actual.AssignPropertiesFromDeliveryRuleSocketAddrCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleSocketAddrCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleSocketAddrCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleSocketAddrCondition, DeliveryRuleSocketAddrConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleSocketAddrCondition runs a test to see if a specific instance of DeliveryRuleSocketAddrCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleSocketAddrCondition(subject DeliveryRuleSocketAddrCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleSocketAddrCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleSocketAddrCondition instances for property testing - lazily instantiated by
// DeliveryRuleSocketAddrConditionGenerator()
var deliveryRuleSocketAddrConditionGenerator gopter.Gen

// DeliveryRuleSocketAddrConditionGenerator returns a generator of DeliveryRuleSocketAddrCondition instances for property testing.
// We first initialize deliveryRuleSocketAddrConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleSocketAddrConditionGenerator() gopter.Gen {
	if deliveryRuleSocketAddrConditionGenerator != nil {
		return deliveryRuleSocketAddrConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition(generators)
	deliveryRuleSocketAddrConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSocketAddrCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrCondition(generators)
	deliveryRuleSocketAddrConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSocketAddrCondition{}), generators)

	return deliveryRuleSocketAddrConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleSocketAddrConditionName_SocketAddr))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(SocketAddrMatchConditionParametersGenerator())
}

func Test_DeliveryRuleSslProtocolCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleSslProtocolCondition to DeliveryRuleSslProtocolCondition via AssignPropertiesToDeliveryRuleSslProtocolCondition & AssignPropertiesFromDeliveryRuleSslProtocolCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleSslProtocolCondition, DeliveryRuleSslProtocolConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleSslProtocolCondition tests if a specific instance of DeliveryRuleSslProtocolCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleSslProtocolCondition(subject DeliveryRuleSslProtocolCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleSslProtocolCondition
	err := copied.AssignPropertiesToDeliveryRuleSslProtocolCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleSslProtocolCondition
	err = actual.AssignPropertiesFromDeliveryRuleSslProtocolCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleSslProtocolCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleSslProtocolCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleSslProtocolCondition, DeliveryRuleSslProtocolConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleSslProtocolCondition runs a test to see if a specific instance of DeliveryRuleSslProtocolCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleSslProtocolCondition(subject DeliveryRuleSslProtocolCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleSslProtocolCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleSslProtocolCondition instances for property testing - lazily instantiated by
// DeliveryRuleSslProtocolConditionGenerator()
var deliveryRuleSslProtocolConditionGenerator gopter.Gen

// DeliveryRuleSslProtocolConditionGenerator returns a generator of DeliveryRuleSslProtocolCondition instances for property testing.
// We first initialize deliveryRuleSslProtocolConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleSslProtocolConditionGenerator() gopter.Gen {
	if deliveryRuleSslProtocolConditionGenerator != nil {
		return deliveryRuleSslProtocolConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition(generators)
	deliveryRuleSslProtocolConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSslProtocolCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolCondition(generators)
	deliveryRuleSslProtocolConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSslProtocolCondition{}), generators)

	return deliveryRuleSslProtocolConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleSslProtocolConditionName_SslProtocol))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(SslProtocolMatchConditionParametersGenerator())
}

func Test_DeliveryRuleUrlFileExtensionCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleUrlFileExtensionCondition to DeliveryRuleUrlFileExtensionCondition via AssignPropertiesToDeliveryRuleUrlFileExtensionCondition & AssignPropertiesFromDeliveryRuleUrlFileExtensionCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleUrlFileExtensionCondition, DeliveryRuleUrlFileExtensionConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleUrlFileExtensionCondition tests if a specific instance of DeliveryRuleUrlFileExtensionCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleUrlFileExtensionCondition(subject DeliveryRuleUrlFileExtensionCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleUrlFileExtensionCondition
	err := copied.AssignPropertiesToDeliveryRuleUrlFileExtensionCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleUrlFileExtensionCondition
	err = actual.AssignPropertiesFromDeliveryRuleUrlFileExtensionCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleUrlFileExtensionCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlFileExtensionCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlFileExtensionCondition, DeliveryRuleUrlFileExtensionConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlFileExtensionCondition runs a test to see if a specific instance of DeliveryRuleUrlFileExtensionCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlFileExtensionCondition(subject DeliveryRuleUrlFileExtensionCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlFileExtensionCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlFileExtensionCondition instances for property testing - lazily instantiated by
// DeliveryRuleUrlFileExtensionConditionGenerator()
var deliveryRuleUrlFileExtensionConditionGenerator gopter.Gen

// DeliveryRuleUrlFileExtensionConditionGenerator returns a generator of DeliveryRuleUrlFileExtensionCondition instances for property testing.
// We first initialize deliveryRuleUrlFileExtensionConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlFileExtensionConditionGenerator() gopter.Gen {
	if deliveryRuleUrlFileExtensionConditionGenerator != nil {
		return deliveryRuleUrlFileExtensionConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition(generators)
	deliveryRuleUrlFileExtensionConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileExtensionCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition(generators)
	deliveryRuleUrlFileExtensionConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileExtensionCondition{}), generators)

	return deliveryRuleUrlFileExtensionConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleUrlFileExtensionConditionName_UrlFileExtension))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlFileExtensionMatchConditionParametersGenerator())
}

func Test_DeliveryRuleUrlFileNameCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleUrlFileNameCondition to DeliveryRuleUrlFileNameCondition via AssignPropertiesToDeliveryRuleUrlFileNameCondition & AssignPropertiesFromDeliveryRuleUrlFileNameCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleUrlFileNameCondition, DeliveryRuleUrlFileNameConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleUrlFileNameCondition tests if a specific instance of DeliveryRuleUrlFileNameCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleUrlFileNameCondition(subject DeliveryRuleUrlFileNameCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleUrlFileNameCondition
	err := copied.AssignPropertiesToDeliveryRuleUrlFileNameCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleUrlFileNameCondition
	err = actual.AssignPropertiesFromDeliveryRuleUrlFileNameCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleUrlFileNameCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlFileNameCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlFileNameCondition, DeliveryRuleUrlFileNameConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlFileNameCondition runs a test to see if a specific instance of DeliveryRuleUrlFileNameCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlFileNameCondition(subject DeliveryRuleUrlFileNameCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlFileNameCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlFileNameCondition instances for property testing - lazily instantiated by
// DeliveryRuleUrlFileNameConditionGenerator()
var deliveryRuleUrlFileNameConditionGenerator gopter.Gen

// DeliveryRuleUrlFileNameConditionGenerator returns a generator of DeliveryRuleUrlFileNameCondition instances for property testing.
// We first initialize deliveryRuleUrlFileNameConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlFileNameConditionGenerator() gopter.Gen {
	if deliveryRuleUrlFileNameConditionGenerator != nil {
		return deliveryRuleUrlFileNameConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition(generators)
	deliveryRuleUrlFileNameConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileNameCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameCondition(generators)
	deliveryRuleUrlFileNameConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileNameCondition{}), generators)

	return deliveryRuleUrlFileNameConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleUrlFileNameConditionName_UrlFileName))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlFileNameMatchConditionParametersGenerator())
}

func Test_DeliveryRuleUrlPathCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleUrlPathCondition to DeliveryRuleUrlPathCondition via AssignPropertiesToDeliveryRuleUrlPathCondition & AssignPropertiesFromDeliveryRuleUrlPathCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleUrlPathCondition, DeliveryRuleUrlPathConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleUrlPathCondition tests if a specific instance of DeliveryRuleUrlPathCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleUrlPathCondition(subject DeliveryRuleUrlPathCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleUrlPathCondition
	err := copied.AssignPropertiesToDeliveryRuleUrlPathCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleUrlPathCondition
	err = actual.AssignPropertiesFromDeliveryRuleUrlPathCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleUrlPathCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlPathCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlPathCondition, DeliveryRuleUrlPathConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlPathCondition runs a test to see if a specific instance of DeliveryRuleUrlPathCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlPathCondition(subject DeliveryRuleUrlPathCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlPathCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlPathCondition instances for property testing - lazily instantiated by
// DeliveryRuleUrlPathConditionGenerator()
var deliveryRuleUrlPathConditionGenerator gopter.Gen

// DeliveryRuleUrlPathConditionGenerator returns a generator of DeliveryRuleUrlPathCondition instances for property testing.
// We first initialize deliveryRuleUrlPathConditionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlPathConditionGenerator() gopter.Gen {
	if deliveryRuleUrlPathConditionGenerator != nil {
		return deliveryRuleUrlPathConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition(generators)
	deliveryRuleUrlPathConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlPathCondition{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathCondition(generators)
	deliveryRuleUrlPathConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlPathCondition{}), generators)

	return deliveryRuleUrlPathConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(DeliveryRuleUrlPathConditionName_UrlPath))
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathCondition is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathCondition(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlPathMatchConditionParametersGenerator())
}

func Test_OriginGroupOverrideAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OriginGroupOverrideAction to OriginGroupOverrideAction via AssignPropertiesToOriginGroupOverrideAction & AssignPropertiesFromOriginGroupOverrideAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForOriginGroupOverrideAction, OriginGroupOverrideActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOriginGroupOverrideAction tests if a specific instance of OriginGroupOverrideAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForOriginGroupOverrideAction(subject OriginGroupOverrideAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.OriginGroupOverrideAction
	err := copied.AssignPropertiesToOriginGroupOverrideAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OriginGroupOverrideAction
	err = actual.AssignPropertiesFromOriginGroupOverrideAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OriginGroupOverrideAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverrideAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverrideAction, OriginGroupOverrideActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverrideAction runs a test to see if a specific instance of OriginGroupOverrideAction round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverrideAction(subject OriginGroupOverrideAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverrideAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverrideAction instances for property testing - lazily instantiated by
// OriginGroupOverrideActionGenerator()
var originGroupOverrideActionGenerator gopter.Gen

// OriginGroupOverrideActionGenerator returns a generator of OriginGroupOverrideAction instances for property testing.
// We first initialize originGroupOverrideActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideActionGenerator() gopter.Gen {
	if originGroupOverrideActionGenerator != nil {
		return originGroupOverrideActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideAction(generators)
	originGroupOverrideActionGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideAction(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverrideAction(generators)
	originGroupOverrideActionGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideAction{}), generators)

	return originGroupOverrideActionGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverrideAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverrideAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(OriginGroupOverrideActionName_OriginGroupOverride))
}

// AddRelatedPropertyGeneratorsForOriginGroupOverrideAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverrideAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(OriginGroupOverrideActionParametersGenerator())
}

func Test_UrlRedirectAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlRedirectAction to UrlRedirectAction via AssignPropertiesToUrlRedirectAction & AssignPropertiesFromUrlRedirectAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlRedirectAction, UrlRedirectActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlRedirectAction tests if a specific instance of UrlRedirectAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlRedirectAction(subject UrlRedirectAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlRedirectAction
	err := copied.AssignPropertiesToUrlRedirectAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlRedirectAction
	err = actual.AssignPropertiesFromUrlRedirectAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlRedirectAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRedirectAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRedirectAction, UrlRedirectActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRedirectAction runs a test to see if a specific instance of UrlRedirectAction round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRedirectAction(subject UrlRedirectAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRedirectAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRedirectAction instances for property testing - lazily instantiated by UrlRedirectActionGenerator()
var urlRedirectActionGenerator gopter.Gen

// UrlRedirectActionGenerator returns a generator of UrlRedirectAction instances for property testing.
// We first initialize urlRedirectActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlRedirectActionGenerator() gopter.Gen {
	if urlRedirectActionGenerator != nil {
		return urlRedirectActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectAction(generators)
	urlRedirectActionGenerator = gen.Struct(reflect.TypeOf(UrlRedirectAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectAction(generators)
	AddRelatedPropertyGeneratorsForUrlRedirectAction(generators)
	urlRedirectActionGenerator = gen.Struct(reflect.TypeOf(UrlRedirectAction{}), generators)

	return urlRedirectActionGenerator
}

// AddIndependentPropertyGeneratorsForUrlRedirectAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRedirectAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(UrlRedirectActionName_UrlRedirect))
}

// AddRelatedPropertyGeneratorsForUrlRedirectAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlRedirectAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlRedirectActionParametersGenerator())
}

func Test_UrlRewriteAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlRewriteAction to UrlRewriteAction via AssignPropertiesToUrlRewriteAction & AssignPropertiesFromUrlRewriteAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlRewriteAction, UrlRewriteActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlRewriteAction tests if a specific instance of UrlRewriteAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlRewriteAction(subject UrlRewriteAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlRewriteAction
	err := copied.AssignPropertiesToUrlRewriteAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlRewriteAction
	err = actual.AssignPropertiesFromUrlRewriteAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlRewriteAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRewriteAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRewriteAction, UrlRewriteActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRewriteAction runs a test to see if a specific instance of UrlRewriteAction round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRewriteAction(subject UrlRewriteAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRewriteAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRewriteAction instances for property testing - lazily instantiated by UrlRewriteActionGenerator()
var urlRewriteActionGenerator gopter.Gen

// UrlRewriteActionGenerator returns a generator of UrlRewriteAction instances for property testing.
// We first initialize urlRewriteActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlRewriteActionGenerator() gopter.Gen {
	if urlRewriteActionGenerator != nil {
		return urlRewriteActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteAction(generators)
	urlRewriteActionGenerator = gen.Struct(reflect.TypeOf(UrlRewriteAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteAction(generators)
	AddRelatedPropertyGeneratorsForUrlRewriteAction(generators)
	urlRewriteActionGenerator = gen.Struct(reflect.TypeOf(UrlRewriteAction{}), generators)

	return urlRewriteActionGenerator
}

// AddIndependentPropertyGeneratorsForUrlRewriteAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRewriteAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(UrlRewriteActionName_UrlRewrite))
}

// AddRelatedPropertyGeneratorsForUrlRewriteAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlRewriteAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlRewriteActionParametersGenerator())
}

func Test_UrlSigningAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningAction to UrlSigningAction via AssignPropertiesToUrlSigningAction & AssignPropertiesFromUrlSigningAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningAction, UrlSigningActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningAction tests if a specific instance of UrlSigningAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningAction(subject UrlSigningAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningAction
	err := copied.AssignPropertiesToUrlSigningAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningAction
	err = actual.AssignPropertiesFromUrlSigningAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningAction, UrlSigningActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningAction runs a test to see if a specific instance of UrlSigningAction round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningAction(subject UrlSigningAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningAction instances for property testing - lazily instantiated by UrlSigningActionGenerator()
var urlSigningActionGenerator gopter.Gen

// UrlSigningActionGenerator returns a generator of UrlSigningAction instances for property testing.
// We first initialize urlSigningActionGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningActionGenerator() gopter.Gen {
	if urlSigningActionGenerator != nil {
		return urlSigningActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningAction(generators)
	urlSigningActionGenerator = gen.Struct(reflect.TypeOf(UrlSigningAction{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningAction(generators)
	AddRelatedPropertyGeneratorsForUrlSigningAction(generators)
	urlSigningActionGenerator = gen.Struct(reflect.TypeOf(UrlSigningAction{}), generators)

	return urlSigningActionGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(UrlSigningActionName_UrlSigning))
}

// AddRelatedPropertyGeneratorsForUrlSigningAction is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningAction(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlSigningActionParametersGenerator())
}

func Test_CacheExpirationActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CacheExpirationActionParameters to CacheExpirationActionParameters via AssignPropertiesToCacheExpirationActionParameters & AssignPropertiesFromCacheExpirationActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForCacheExpirationActionParameters, CacheExpirationActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCacheExpirationActionParameters tests if a specific instance of CacheExpirationActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCacheExpirationActionParameters(subject CacheExpirationActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CacheExpirationActionParameters
	err := copied.AssignPropertiesToCacheExpirationActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CacheExpirationActionParameters
	err = actual.AssignPropertiesFromCacheExpirationActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CacheExpirationActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheExpirationActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheExpirationActionParameters, CacheExpirationActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheExpirationActionParameters runs a test to see if a specific instance of CacheExpirationActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheExpirationActionParameters(subject CacheExpirationActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheExpirationActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheExpirationActionParameters instances for property testing - lazily instantiated by
// CacheExpirationActionParametersGenerator()
var cacheExpirationActionParametersGenerator gopter.Gen

// CacheExpirationActionParametersGenerator returns a generator of CacheExpirationActionParameters instances for property testing.
func CacheExpirationActionParametersGenerator() gopter.Gen {
	if cacheExpirationActionParametersGenerator != nil {
		return cacheExpirationActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheExpirationActionParameters(generators)
	cacheExpirationActionParametersGenerator = gen.Struct(reflect.TypeOf(CacheExpirationActionParameters{}), generators)

	return cacheExpirationActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForCacheExpirationActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheExpirationActionParameters(gens map[string]gopter.Gen) {
	gens["CacheBehavior"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParametersCacheBehavior_BypassCache, CacheExpirationActionParametersCacheBehavior_Override, CacheExpirationActionParametersCacheBehavior_SetIfMissing))
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["CacheType"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParametersCacheType_All))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParametersTypeName_DeliveryRuleCacheExpirationActionParameters))
}

func Test_CacheKeyQueryStringActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CacheKeyQueryStringActionParameters to CacheKeyQueryStringActionParameters via AssignPropertiesToCacheKeyQueryStringActionParameters & AssignPropertiesFromCacheKeyQueryStringActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForCacheKeyQueryStringActionParameters, CacheKeyQueryStringActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCacheKeyQueryStringActionParameters tests if a specific instance of CacheKeyQueryStringActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCacheKeyQueryStringActionParameters(subject CacheKeyQueryStringActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CacheKeyQueryStringActionParameters
	err := copied.AssignPropertiesToCacheKeyQueryStringActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CacheKeyQueryStringActionParameters
	err = actual.AssignPropertiesFromCacheKeyQueryStringActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CacheKeyQueryStringActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheKeyQueryStringActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheKeyQueryStringActionParameters, CacheKeyQueryStringActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheKeyQueryStringActionParameters runs a test to see if a specific instance of CacheKeyQueryStringActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheKeyQueryStringActionParameters(subject CacheKeyQueryStringActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheKeyQueryStringActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheKeyQueryStringActionParameters instances for property testing - lazily instantiated by
// CacheKeyQueryStringActionParametersGenerator()
var cacheKeyQueryStringActionParametersGenerator gopter.Gen

// CacheKeyQueryStringActionParametersGenerator returns a generator of CacheKeyQueryStringActionParameters instances for property testing.
func CacheKeyQueryStringActionParametersGenerator() gopter.Gen {
	if cacheKeyQueryStringActionParametersGenerator != nil {
		return cacheKeyQueryStringActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParameters(generators)
	cacheKeyQueryStringActionParametersGenerator = gen.Struct(reflect.TypeOf(CacheKeyQueryStringActionParameters{}), generators)

	return cacheKeyQueryStringActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParameters(gens map[string]gopter.Gen) {
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringBehavior"] = gen.PtrOf(gen.OneConstOf(
		CacheKeyQueryStringActionParametersQueryStringBehavior_Exclude,
		CacheKeyQueryStringActionParametersQueryStringBehavior_ExcludeAll,
		CacheKeyQueryStringActionParametersQueryStringBehavior_Include,
		CacheKeyQueryStringActionParametersQueryStringBehavior_IncludeAll))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CacheKeyQueryStringActionParametersTypeName_DeliveryRuleCacheKeyQueryStringBehaviorActionParameters))
}

func Test_ClientPortMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ClientPortMatchConditionParameters to ClientPortMatchConditionParameters via AssignPropertiesToClientPortMatchConditionParameters & AssignPropertiesFromClientPortMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForClientPortMatchConditionParameters, ClientPortMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForClientPortMatchConditionParameters tests if a specific instance of ClientPortMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForClientPortMatchConditionParameters(subject ClientPortMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ClientPortMatchConditionParameters
	err := copied.AssignPropertiesToClientPortMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ClientPortMatchConditionParameters
	err = actual.AssignPropertiesFromClientPortMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ClientPortMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClientPortMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClientPortMatchConditionParameters, ClientPortMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClientPortMatchConditionParameters runs a test to see if a specific instance of ClientPortMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForClientPortMatchConditionParameters(subject ClientPortMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClientPortMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClientPortMatchConditionParameters instances for property testing - lazily instantiated by
// ClientPortMatchConditionParametersGenerator()
var clientPortMatchConditionParametersGenerator gopter.Gen

// ClientPortMatchConditionParametersGenerator returns a generator of ClientPortMatchConditionParameters instances for property testing.
func ClientPortMatchConditionParametersGenerator() gopter.Gen {
	if clientPortMatchConditionParametersGenerator != nil {
		return clientPortMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClientPortMatchConditionParameters(generators)
	clientPortMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(ClientPortMatchConditionParameters{}), generators)

	return clientPortMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForClientPortMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClientPortMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		ClientPortMatchConditionParametersOperator_Any,
		ClientPortMatchConditionParametersOperator_BeginsWith,
		ClientPortMatchConditionParametersOperator_Contains,
		ClientPortMatchConditionParametersOperator_EndsWith,
		ClientPortMatchConditionParametersOperator_Equal,
		ClientPortMatchConditionParametersOperator_GreaterThan,
		ClientPortMatchConditionParametersOperator_GreaterThanOrEqual,
		ClientPortMatchConditionParametersOperator_LessThan,
		ClientPortMatchConditionParametersOperator_LessThanOrEqual,
		ClientPortMatchConditionParametersOperator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		ClientPortMatchConditionParametersTransforms_Lowercase,
		ClientPortMatchConditionParametersTransforms_RemoveNulls,
		ClientPortMatchConditionParametersTransforms_Trim,
		ClientPortMatchConditionParametersTransforms_Uppercase,
		ClientPortMatchConditionParametersTransforms_UrlDecode,
		ClientPortMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(ClientPortMatchConditionParametersTypeName_DeliveryRuleClientPortConditionParameters))
}

func Test_CookiesMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CookiesMatchConditionParameters to CookiesMatchConditionParameters via AssignPropertiesToCookiesMatchConditionParameters & AssignPropertiesFromCookiesMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForCookiesMatchConditionParameters, CookiesMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCookiesMatchConditionParameters tests if a specific instance of CookiesMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCookiesMatchConditionParameters(subject CookiesMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CookiesMatchConditionParameters
	err := copied.AssignPropertiesToCookiesMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CookiesMatchConditionParameters
	err = actual.AssignPropertiesFromCookiesMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CookiesMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CookiesMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCookiesMatchConditionParameters, CookiesMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCookiesMatchConditionParameters runs a test to see if a specific instance of CookiesMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForCookiesMatchConditionParameters(subject CookiesMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CookiesMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CookiesMatchConditionParameters instances for property testing - lazily instantiated by
// CookiesMatchConditionParametersGenerator()
var cookiesMatchConditionParametersGenerator gopter.Gen

// CookiesMatchConditionParametersGenerator returns a generator of CookiesMatchConditionParameters instances for property testing.
func CookiesMatchConditionParametersGenerator() gopter.Gen {
	if cookiesMatchConditionParametersGenerator != nil {
		return cookiesMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCookiesMatchConditionParameters(generators)
	cookiesMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(CookiesMatchConditionParameters{}), generators)

	return cookiesMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForCookiesMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCookiesMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		CookiesMatchConditionParametersOperator_Any,
		CookiesMatchConditionParametersOperator_BeginsWith,
		CookiesMatchConditionParametersOperator_Contains,
		CookiesMatchConditionParametersOperator_EndsWith,
		CookiesMatchConditionParametersOperator_Equal,
		CookiesMatchConditionParametersOperator_GreaterThan,
		CookiesMatchConditionParametersOperator_GreaterThanOrEqual,
		CookiesMatchConditionParametersOperator_LessThan,
		CookiesMatchConditionParametersOperator_LessThanOrEqual,
		CookiesMatchConditionParametersOperator_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		CookiesMatchConditionParametersTransforms_Lowercase,
		CookiesMatchConditionParametersTransforms_RemoveNulls,
		CookiesMatchConditionParametersTransforms_Trim,
		CookiesMatchConditionParametersTransforms_Uppercase,
		CookiesMatchConditionParametersTransforms_UrlDecode,
		CookiesMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CookiesMatchConditionParametersTypeName_DeliveryRuleCookiesConditionParameters))
}

func Test_HeaderActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HeaderActionParameters to HeaderActionParameters via AssignPropertiesToHeaderActionParameters & AssignPropertiesFromHeaderActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForHeaderActionParameters, HeaderActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHeaderActionParameters tests if a specific instance of HeaderActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHeaderActionParameters(subject HeaderActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HeaderActionParameters
	err := copied.AssignPropertiesToHeaderActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HeaderActionParameters
	err = actual.AssignPropertiesFromHeaderActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HeaderActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderActionParameters, HeaderActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderActionParameters runs a test to see if a specific instance of HeaderActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderActionParameters(subject HeaderActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderActionParameters instances for property testing - lazily instantiated by
// HeaderActionParametersGenerator()
var headerActionParametersGenerator gopter.Gen

// HeaderActionParametersGenerator returns a generator of HeaderActionParameters instances for property testing.
func HeaderActionParametersGenerator() gopter.Gen {
	if headerActionParametersGenerator != nil {
		return headerActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderActionParameters(generators)
	headerActionParametersGenerator = gen.Struct(reflect.TypeOf(HeaderActionParameters{}), generators)

	return headerActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForHeaderActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderActionParameters(gens map[string]gopter.Gen) {
	gens["HeaderAction"] = gen.PtrOf(gen.OneConstOf(HeaderActionParametersHeaderAction_Append, HeaderActionParametersHeaderAction_Delete, HeaderActionParametersHeaderAction_Overwrite))
	gens["HeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HeaderActionParametersTypeName_DeliveryRuleHeaderActionParameters))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_HostNameMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HostNameMatchConditionParameters to HostNameMatchConditionParameters via AssignPropertiesToHostNameMatchConditionParameters & AssignPropertiesFromHostNameMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForHostNameMatchConditionParameters, HostNameMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHostNameMatchConditionParameters tests if a specific instance of HostNameMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHostNameMatchConditionParameters(subject HostNameMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HostNameMatchConditionParameters
	err := copied.AssignPropertiesToHostNameMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HostNameMatchConditionParameters
	err = actual.AssignPropertiesFromHostNameMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HostNameMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostNameMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostNameMatchConditionParameters, HostNameMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostNameMatchConditionParameters runs a test to see if a specific instance of HostNameMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForHostNameMatchConditionParameters(subject HostNameMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostNameMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostNameMatchConditionParameters instances for property testing - lazily instantiated by
// HostNameMatchConditionParametersGenerator()
var hostNameMatchConditionParametersGenerator gopter.Gen

// HostNameMatchConditionParametersGenerator returns a generator of HostNameMatchConditionParameters instances for property testing.
func HostNameMatchConditionParametersGenerator() gopter.Gen {
	if hostNameMatchConditionParametersGenerator != nil {
		return hostNameMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostNameMatchConditionParameters(generators)
	hostNameMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(HostNameMatchConditionParameters{}), generators)

	return hostNameMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForHostNameMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostNameMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		HostNameMatchConditionParametersOperator_Any,
		HostNameMatchConditionParametersOperator_BeginsWith,
		HostNameMatchConditionParametersOperator_Contains,
		HostNameMatchConditionParametersOperator_EndsWith,
		HostNameMatchConditionParametersOperator_Equal,
		HostNameMatchConditionParametersOperator_GreaterThan,
		HostNameMatchConditionParametersOperator_GreaterThanOrEqual,
		HostNameMatchConditionParametersOperator_LessThan,
		HostNameMatchConditionParametersOperator_LessThanOrEqual,
		HostNameMatchConditionParametersOperator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		HostNameMatchConditionParametersTransforms_Lowercase,
		HostNameMatchConditionParametersTransforms_RemoveNulls,
		HostNameMatchConditionParametersTransforms_Trim,
		HostNameMatchConditionParametersTransforms_Uppercase,
		HostNameMatchConditionParametersTransforms_UrlDecode,
		HostNameMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HostNameMatchConditionParametersTypeName_DeliveryRuleHostNameConditionParameters))
}

func Test_HttpVersionMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpVersionMatchConditionParameters to HttpVersionMatchConditionParameters via AssignPropertiesToHttpVersionMatchConditionParameters & AssignPropertiesFromHttpVersionMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpVersionMatchConditionParameters, HttpVersionMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpVersionMatchConditionParameters tests if a specific instance of HttpVersionMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHttpVersionMatchConditionParameters(subject HttpVersionMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HttpVersionMatchConditionParameters
	err := copied.AssignPropertiesToHttpVersionMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpVersionMatchConditionParameters
	err = actual.AssignPropertiesFromHttpVersionMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpVersionMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpVersionMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpVersionMatchConditionParameters, HttpVersionMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpVersionMatchConditionParameters runs a test to see if a specific instance of HttpVersionMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpVersionMatchConditionParameters(subject HttpVersionMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpVersionMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpVersionMatchConditionParameters instances for property testing - lazily instantiated by
// HttpVersionMatchConditionParametersGenerator()
var httpVersionMatchConditionParametersGenerator gopter.Gen

// HttpVersionMatchConditionParametersGenerator returns a generator of HttpVersionMatchConditionParameters instances for property testing.
func HttpVersionMatchConditionParametersGenerator() gopter.Gen {
	if httpVersionMatchConditionParametersGenerator != nil {
		return httpVersionMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParameters(generators)
	httpVersionMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(HttpVersionMatchConditionParameters{}), generators)

	return httpVersionMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(HttpVersionMatchConditionParametersOperator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		HttpVersionMatchConditionParametersTransforms_Lowercase,
		HttpVersionMatchConditionParametersTransforms_RemoveNulls,
		HttpVersionMatchConditionParametersTransforms_Trim,
		HttpVersionMatchConditionParametersTransforms_Uppercase,
		HttpVersionMatchConditionParametersTransforms_UrlDecode,
		HttpVersionMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HttpVersionMatchConditionParametersTypeName_DeliveryRuleHttpVersionConditionParameters))
}

func Test_IsDeviceMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from IsDeviceMatchConditionParameters to IsDeviceMatchConditionParameters via AssignPropertiesToIsDeviceMatchConditionParameters & AssignPropertiesFromIsDeviceMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForIsDeviceMatchConditionParameters, IsDeviceMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForIsDeviceMatchConditionParameters tests if a specific instance of IsDeviceMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForIsDeviceMatchConditionParameters(subject IsDeviceMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.IsDeviceMatchConditionParameters
	err := copied.AssignPropertiesToIsDeviceMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual IsDeviceMatchConditionParameters
	err = actual.AssignPropertiesFromIsDeviceMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_IsDeviceMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IsDeviceMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIsDeviceMatchConditionParameters, IsDeviceMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIsDeviceMatchConditionParameters runs a test to see if a specific instance of IsDeviceMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForIsDeviceMatchConditionParameters(subject IsDeviceMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IsDeviceMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IsDeviceMatchConditionParameters instances for property testing - lazily instantiated by
// IsDeviceMatchConditionParametersGenerator()
var isDeviceMatchConditionParametersGenerator gopter.Gen

// IsDeviceMatchConditionParametersGenerator returns a generator of IsDeviceMatchConditionParameters instances for property testing.
func IsDeviceMatchConditionParametersGenerator() gopter.Gen {
	if isDeviceMatchConditionParametersGenerator != nil {
		return isDeviceMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParameters(generators)
	isDeviceMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(IsDeviceMatchConditionParameters{}), generators)

	return isDeviceMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(IsDeviceMatchConditionParametersMatchValues_Desktop, IsDeviceMatchConditionParametersMatchValues_Mobile))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(IsDeviceMatchConditionParametersOperator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		IsDeviceMatchConditionParametersTransforms_Lowercase,
		IsDeviceMatchConditionParametersTransforms_RemoveNulls,
		IsDeviceMatchConditionParametersTransforms_Trim,
		IsDeviceMatchConditionParametersTransforms_Uppercase,
		IsDeviceMatchConditionParametersTransforms_UrlDecode,
		IsDeviceMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(IsDeviceMatchConditionParametersTypeName_DeliveryRuleIsDeviceConditionParameters))
}

func Test_OriginGroupOverrideActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OriginGroupOverrideActionParameters to OriginGroupOverrideActionParameters via AssignPropertiesToOriginGroupOverrideActionParameters & AssignPropertiesFromOriginGroupOverrideActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForOriginGroupOverrideActionParameters, OriginGroupOverrideActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOriginGroupOverrideActionParameters tests if a specific instance of OriginGroupOverrideActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForOriginGroupOverrideActionParameters(subject OriginGroupOverrideActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.OriginGroupOverrideActionParameters
	err := copied.AssignPropertiesToOriginGroupOverrideActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OriginGroupOverrideActionParameters
	err = actual.AssignPropertiesFromOriginGroupOverrideActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OriginGroupOverrideActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverrideActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverrideActionParameters, OriginGroupOverrideActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverrideActionParameters runs a test to see if a specific instance of OriginGroupOverrideActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverrideActionParameters(subject OriginGroupOverrideActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverrideActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverrideActionParameters instances for property testing - lazily instantiated by
// OriginGroupOverrideActionParametersGenerator()
var originGroupOverrideActionParametersGenerator gopter.Gen

// OriginGroupOverrideActionParametersGenerator returns a generator of OriginGroupOverrideActionParameters instances for property testing.
// We first initialize originGroupOverrideActionParametersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideActionParametersGenerator() gopter.Gen {
	if originGroupOverrideActionParametersGenerator != nil {
		return originGroupOverrideActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters(generators)
	originGroupOverrideActionParametersGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionParameters{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParameters(generators)
	originGroupOverrideActionParametersGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionParameters{}), generators)

	return originGroupOverrideActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters(gens map[string]gopter.Gen) {
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(OriginGroupOverrideActionParametersTypeName_DeliveryRuleOriginGroupOverrideActionParameters))
}

// AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParameters(gens map[string]gopter.Gen) {
	gens["OriginGroup"] = gen.PtrOf(ResourceReferenceGenerator())
}

func Test_PostArgsMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from PostArgsMatchConditionParameters to PostArgsMatchConditionParameters via AssignPropertiesToPostArgsMatchConditionParameters & AssignPropertiesFromPostArgsMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForPostArgsMatchConditionParameters, PostArgsMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForPostArgsMatchConditionParameters tests if a specific instance of PostArgsMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForPostArgsMatchConditionParameters(subject PostArgsMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.PostArgsMatchConditionParameters
	err := copied.AssignPropertiesToPostArgsMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual PostArgsMatchConditionParameters
	err = actual.AssignPropertiesFromPostArgsMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_PostArgsMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PostArgsMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPostArgsMatchConditionParameters, PostArgsMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPostArgsMatchConditionParameters runs a test to see if a specific instance of PostArgsMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForPostArgsMatchConditionParameters(subject PostArgsMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PostArgsMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PostArgsMatchConditionParameters instances for property testing - lazily instantiated by
// PostArgsMatchConditionParametersGenerator()
var postArgsMatchConditionParametersGenerator gopter.Gen

// PostArgsMatchConditionParametersGenerator returns a generator of PostArgsMatchConditionParameters instances for property testing.
func PostArgsMatchConditionParametersGenerator() gopter.Gen {
	if postArgsMatchConditionParametersGenerator != nil {
		return postArgsMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPostArgsMatchConditionParameters(generators)
	postArgsMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(PostArgsMatchConditionParameters{}), generators)

	return postArgsMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForPostArgsMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPostArgsMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		PostArgsMatchConditionParametersOperator_Any,
		PostArgsMatchConditionParametersOperator_BeginsWith,
		PostArgsMatchConditionParametersOperator_Contains,
		PostArgsMatchConditionParametersOperator_EndsWith,
		PostArgsMatchConditionParametersOperator_Equal,
		PostArgsMatchConditionParametersOperator_GreaterThan,
		PostArgsMatchConditionParametersOperator_GreaterThanOrEqual,
		PostArgsMatchConditionParametersOperator_LessThan,
		PostArgsMatchConditionParametersOperator_LessThanOrEqual,
		PostArgsMatchConditionParametersOperator_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		PostArgsMatchConditionParametersTransforms_Lowercase,
		PostArgsMatchConditionParametersTransforms_RemoveNulls,
		PostArgsMatchConditionParametersTransforms_Trim,
		PostArgsMatchConditionParametersTransforms_Uppercase,
		PostArgsMatchConditionParametersTransforms_UrlDecode,
		PostArgsMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(PostArgsMatchConditionParametersTypeName_DeliveryRulePostArgsConditionParameters))
}

func Test_QueryStringMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from QueryStringMatchConditionParameters to QueryStringMatchConditionParameters via AssignPropertiesToQueryStringMatchConditionParameters & AssignPropertiesFromQueryStringMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForQueryStringMatchConditionParameters, QueryStringMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForQueryStringMatchConditionParameters tests if a specific instance of QueryStringMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForQueryStringMatchConditionParameters(subject QueryStringMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.QueryStringMatchConditionParameters
	err := copied.AssignPropertiesToQueryStringMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual QueryStringMatchConditionParameters
	err = actual.AssignPropertiesFromQueryStringMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_QueryStringMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QueryStringMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForQueryStringMatchConditionParameters, QueryStringMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQueryStringMatchConditionParameters runs a test to see if a specific instance of QueryStringMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForQueryStringMatchConditionParameters(subject QueryStringMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QueryStringMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QueryStringMatchConditionParameters instances for property testing - lazily instantiated by
// QueryStringMatchConditionParametersGenerator()
var queryStringMatchConditionParametersGenerator gopter.Gen

// QueryStringMatchConditionParametersGenerator returns a generator of QueryStringMatchConditionParameters instances for property testing.
func QueryStringMatchConditionParametersGenerator() gopter.Gen {
	if queryStringMatchConditionParametersGenerator != nil {
		return queryStringMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQueryStringMatchConditionParameters(generators)
	queryStringMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(QueryStringMatchConditionParameters{}), generators)

	return queryStringMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForQueryStringMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQueryStringMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		QueryStringMatchConditionParametersOperator_Any,
		QueryStringMatchConditionParametersOperator_BeginsWith,
		QueryStringMatchConditionParametersOperator_Contains,
		QueryStringMatchConditionParametersOperator_EndsWith,
		QueryStringMatchConditionParametersOperator_Equal,
		QueryStringMatchConditionParametersOperator_GreaterThan,
		QueryStringMatchConditionParametersOperator_GreaterThanOrEqual,
		QueryStringMatchConditionParametersOperator_LessThan,
		QueryStringMatchConditionParametersOperator_LessThanOrEqual,
		QueryStringMatchConditionParametersOperator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		QueryStringMatchConditionParametersTransforms_Lowercase,
		QueryStringMatchConditionParametersTransforms_RemoveNulls,
		QueryStringMatchConditionParametersTransforms_Trim,
		QueryStringMatchConditionParametersTransforms_Uppercase,
		QueryStringMatchConditionParametersTransforms_UrlDecode,
		QueryStringMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(QueryStringMatchConditionParametersTypeName_DeliveryRuleQueryStringConditionParameters))
}

func Test_RemoteAddressMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RemoteAddressMatchConditionParameters to RemoteAddressMatchConditionParameters via AssignPropertiesToRemoteAddressMatchConditionParameters & AssignPropertiesFromRemoteAddressMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForRemoteAddressMatchConditionParameters, RemoteAddressMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRemoteAddressMatchConditionParameters tests if a specific instance of RemoteAddressMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRemoteAddressMatchConditionParameters(subject RemoteAddressMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RemoteAddressMatchConditionParameters
	err := copied.AssignPropertiesToRemoteAddressMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RemoteAddressMatchConditionParameters
	err = actual.AssignPropertiesFromRemoteAddressMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RemoteAddressMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RemoteAddressMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRemoteAddressMatchConditionParameters, RemoteAddressMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRemoteAddressMatchConditionParameters runs a test to see if a specific instance of RemoteAddressMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForRemoteAddressMatchConditionParameters(subject RemoteAddressMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RemoteAddressMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RemoteAddressMatchConditionParameters instances for property testing - lazily instantiated by
// RemoteAddressMatchConditionParametersGenerator()
var remoteAddressMatchConditionParametersGenerator gopter.Gen

// RemoteAddressMatchConditionParametersGenerator returns a generator of RemoteAddressMatchConditionParameters instances for property testing.
func RemoteAddressMatchConditionParametersGenerator() gopter.Gen {
	if remoteAddressMatchConditionParametersGenerator != nil {
		return remoteAddressMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParameters(generators)
	remoteAddressMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(RemoteAddressMatchConditionParameters{}), generators)

	return remoteAddressMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RemoteAddressMatchConditionParametersOperator_Any, RemoteAddressMatchConditionParametersOperator_GeoMatch, RemoteAddressMatchConditionParametersOperator_IPMatch))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RemoteAddressMatchConditionParametersTransforms_Lowercase,
		RemoteAddressMatchConditionParametersTransforms_RemoveNulls,
		RemoteAddressMatchConditionParametersTransforms_Trim,
		RemoteAddressMatchConditionParametersTransforms_Uppercase,
		RemoteAddressMatchConditionParametersTransforms_UrlDecode,
		RemoteAddressMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RemoteAddressMatchConditionParametersTypeName_DeliveryRuleRemoteAddressConditionParameters))
}

func Test_RequestBodyMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestBodyMatchConditionParameters to RequestBodyMatchConditionParameters via AssignPropertiesToRequestBodyMatchConditionParameters & AssignPropertiesFromRequestBodyMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestBodyMatchConditionParameters, RequestBodyMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestBodyMatchConditionParameters tests if a specific instance of RequestBodyMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestBodyMatchConditionParameters(subject RequestBodyMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestBodyMatchConditionParameters
	err := copied.AssignPropertiesToRequestBodyMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestBodyMatchConditionParameters
	err = actual.AssignPropertiesFromRequestBodyMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestBodyMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestBodyMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestBodyMatchConditionParameters, RequestBodyMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestBodyMatchConditionParameters runs a test to see if a specific instance of RequestBodyMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestBodyMatchConditionParameters(subject RequestBodyMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestBodyMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestBodyMatchConditionParameters instances for property testing - lazily instantiated by
// RequestBodyMatchConditionParametersGenerator()
var requestBodyMatchConditionParametersGenerator gopter.Gen

// RequestBodyMatchConditionParametersGenerator returns a generator of RequestBodyMatchConditionParameters instances for property testing.
func RequestBodyMatchConditionParametersGenerator() gopter.Gen {
	if requestBodyMatchConditionParametersGenerator != nil {
		return requestBodyMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParameters(generators)
	requestBodyMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(RequestBodyMatchConditionParameters{}), generators)

	return requestBodyMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestBodyMatchConditionParametersOperator_Any,
		RequestBodyMatchConditionParametersOperator_BeginsWith,
		RequestBodyMatchConditionParametersOperator_Contains,
		RequestBodyMatchConditionParametersOperator_EndsWith,
		RequestBodyMatchConditionParametersOperator_Equal,
		RequestBodyMatchConditionParametersOperator_GreaterThan,
		RequestBodyMatchConditionParametersOperator_GreaterThanOrEqual,
		RequestBodyMatchConditionParametersOperator_LessThan,
		RequestBodyMatchConditionParametersOperator_LessThanOrEqual,
		RequestBodyMatchConditionParametersOperator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestBodyMatchConditionParametersTransforms_Lowercase,
		RequestBodyMatchConditionParametersTransforms_RemoveNulls,
		RequestBodyMatchConditionParametersTransforms_Trim,
		RequestBodyMatchConditionParametersTransforms_Uppercase,
		RequestBodyMatchConditionParametersTransforms_UrlDecode,
		RequestBodyMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestBodyMatchConditionParametersTypeName_DeliveryRuleRequestBodyConditionParameters))
}

func Test_RequestHeaderMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestHeaderMatchConditionParameters to RequestHeaderMatchConditionParameters via AssignPropertiesToRequestHeaderMatchConditionParameters & AssignPropertiesFromRequestHeaderMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestHeaderMatchConditionParameters, RequestHeaderMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestHeaderMatchConditionParameters tests if a specific instance of RequestHeaderMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestHeaderMatchConditionParameters(subject RequestHeaderMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestHeaderMatchConditionParameters
	err := copied.AssignPropertiesToRequestHeaderMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestHeaderMatchConditionParameters
	err = actual.AssignPropertiesFromRequestHeaderMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestHeaderMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestHeaderMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestHeaderMatchConditionParameters, RequestHeaderMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestHeaderMatchConditionParameters runs a test to see if a specific instance of RequestHeaderMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestHeaderMatchConditionParameters(subject RequestHeaderMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestHeaderMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestHeaderMatchConditionParameters instances for property testing - lazily instantiated by
// RequestHeaderMatchConditionParametersGenerator()
var requestHeaderMatchConditionParametersGenerator gopter.Gen

// RequestHeaderMatchConditionParametersGenerator returns a generator of RequestHeaderMatchConditionParameters instances for property testing.
func RequestHeaderMatchConditionParametersGenerator() gopter.Gen {
	if requestHeaderMatchConditionParametersGenerator != nil {
		return requestHeaderMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParameters(generators)
	requestHeaderMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(RequestHeaderMatchConditionParameters{}), generators)

	return requestHeaderMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestHeaderMatchConditionParametersOperator_Any,
		RequestHeaderMatchConditionParametersOperator_BeginsWith,
		RequestHeaderMatchConditionParametersOperator_Contains,
		RequestHeaderMatchConditionParametersOperator_EndsWith,
		RequestHeaderMatchConditionParametersOperator_Equal,
		RequestHeaderMatchConditionParametersOperator_GreaterThan,
		RequestHeaderMatchConditionParametersOperator_GreaterThanOrEqual,
		RequestHeaderMatchConditionParametersOperator_LessThan,
		RequestHeaderMatchConditionParametersOperator_LessThanOrEqual,
		RequestHeaderMatchConditionParametersOperator_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestHeaderMatchConditionParametersTransforms_Lowercase,
		RequestHeaderMatchConditionParametersTransforms_RemoveNulls,
		RequestHeaderMatchConditionParametersTransforms_Trim,
		RequestHeaderMatchConditionParametersTransforms_Uppercase,
		RequestHeaderMatchConditionParametersTransforms_UrlDecode,
		RequestHeaderMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestHeaderMatchConditionParametersTypeName_DeliveryRuleRequestHeaderConditionParameters))
}

func Test_RequestMethodMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestMethodMatchConditionParameters to RequestMethodMatchConditionParameters via AssignPropertiesToRequestMethodMatchConditionParameters & AssignPropertiesFromRequestMethodMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestMethodMatchConditionParameters, RequestMethodMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestMethodMatchConditionParameters tests if a specific instance of RequestMethodMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestMethodMatchConditionParameters(subject RequestMethodMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestMethodMatchConditionParameters
	err := copied.AssignPropertiesToRequestMethodMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestMethodMatchConditionParameters
	err = actual.AssignPropertiesFromRequestMethodMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestMethodMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestMethodMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestMethodMatchConditionParameters, RequestMethodMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestMethodMatchConditionParameters runs a test to see if a specific instance of RequestMethodMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestMethodMatchConditionParameters(subject RequestMethodMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestMethodMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestMethodMatchConditionParameters instances for property testing - lazily instantiated by
// RequestMethodMatchConditionParametersGenerator()
var requestMethodMatchConditionParametersGenerator gopter.Gen

// RequestMethodMatchConditionParametersGenerator returns a generator of RequestMethodMatchConditionParameters instances for property testing.
func RequestMethodMatchConditionParametersGenerator() gopter.Gen {
	if requestMethodMatchConditionParametersGenerator != nil {
		return requestMethodMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParameters(generators)
	requestMethodMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(RequestMethodMatchConditionParameters{}), generators)

	return requestMethodMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(
		RequestMethodMatchConditionParametersMatchValues_DELETE,
		RequestMethodMatchConditionParametersMatchValues_GET,
		RequestMethodMatchConditionParametersMatchValues_HEAD,
		RequestMethodMatchConditionParametersMatchValues_OPTIONS,
		RequestMethodMatchConditionParametersMatchValues_POST,
		RequestMethodMatchConditionParametersMatchValues_PUT,
		RequestMethodMatchConditionParametersMatchValues_TRACE))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RequestMethodMatchConditionParametersOperator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestMethodMatchConditionParametersTransforms_Lowercase,
		RequestMethodMatchConditionParametersTransforms_RemoveNulls,
		RequestMethodMatchConditionParametersTransforms_Trim,
		RequestMethodMatchConditionParametersTransforms_Uppercase,
		RequestMethodMatchConditionParametersTransforms_UrlDecode,
		RequestMethodMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestMethodMatchConditionParametersTypeName_DeliveryRuleRequestMethodConditionParameters))
}

func Test_RequestSchemeMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestSchemeMatchConditionParameters to RequestSchemeMatchConditionParameters via AssignPropertiesToRequestSchemeMatchConditionParameters & AssignPropertiesFromRequestSchemeMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestSchemeMatchConditionParameters, RequestSchemeMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestSchemeMatchConditionParameters tests if a specific instance of RequestSchemeMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestSchemeMatchConditionParameters(subject RequestSchemeMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestSchemeMatchConditionParameters
	err := copied.AssignPropertiesToRequestSchemeMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestSchemeMatchConditionParameters
	err = actual.AssignPropertiesFromRequestSchemeMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestSchemeMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestSchemeMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestSchemeMatchConditionParameters, RequestSchemeMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestSchemeMatchConditionParameters runs a test to see if a specific instance of RequestSchemeMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestSchemeMatchConditionParameters(subject RequestSchemeMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestSchemeMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestSchemeMatchConditionParameters instances for property testing - lazily instantiated by
// RequestSchemeMatchConditionParametersGenerator()
var requestSchemeMatchConditionParametersGenerator gopter.Gen

// RequestSchemeMatchConditionParametersGenerator returns a generator of RequestSchemeMatchConditionParameters instances for property testing.
func RequestSchemeMatchConditionParametersGenerator() gopter.Gen {
	if requestSchemeMatchConditionParametersGenerator != nil {
		return requestSchemeMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParameters(generators)
	requestSchemeMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(RequestSchemeMatchConditionParameters{}), generators)

	return requestSchemeMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(RequestSchemeMatchConditionParametersMatchValues_HTTP, RequestSchemeMatchConditionParametersMatchValues_HTTPS))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RequestSchemeMatchConditionParametersOperator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestSchemeMatchConditionParametersTransforms_Lowercase,
		RequestSchemeMatchConditionParametersTransforms_RemoveNulls,
		RequestSchemeMatchConditionParametersTransforms_Trim,
		RequestSchemeMatchConditionParametersTransforms_Uppercase,
		RequestSchemeMatchConditionParametersTransforms_UrlDecode,
		RequestSchemeMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestSchemeMatchConditionParametersTypeName_DeliveryRuleRequestSchemeConditionParameters))
}

func Test_RequestUriMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RequestUriMatchConditionParameters to RequestUriMatchConditionParameters via AssignPropertiesToRequestUriMatchConditionParameters & AssignPropertiesFromRequestUriMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForRequestUriMatchConditionParameters, RequestUriMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRequestUriMatchConditionParameters tests if a specific instance of RequestUriMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRequestUriMatchConditionParameters(subject RequestUriMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RequestUriMatchConditionParameters
	err := copied.AssignPropertiesToRequestUriMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RequestUriMatchConditionParameters
	err = actual.AssignPropertiesFromRequestUriMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RequestUriMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestUriMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestUriMatchConditionParameters, RequestUriMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestUriMatchConditionParameters runs a test to see if a specific instance of RequestUriMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestUriMatchConditionParameters(subject RequestUriMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestUriMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestUriMatchConditionParameters instances for property testing - lazily instantiated by
// RequestUriMatchConditionParametersGenerator()
var requestUriMatchConditionParametersGenerator gopter.Gen

// RequestUriMatchConditionParametersGenerator returns a generator of RequestUriMatchConditionParameters instances for property testing.
func RequestUriMatchConditionParametersGenerator() gopter.Gen {
	if requestUriMatchConditionParametersGenerator != nil {
		return requestUriMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestUriMatchConditionParameters(generators)
	requestUriMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(RequestUriMatchConditionParameters{}), generators)

	return requestUriMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForRequestUriMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestUriMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestUriMatchConditionParametersOperator_Any,
		RequestUriMatchConditionParametersOperator_BeginsWith,
		RequestUriMatchConditionParametersOperator_Contains,
		RequestUriMatchConditionParametersOperator_EndsWith,
		RequestUriMatchConditionParametersOperator_Equal,
		RequestUriMatchConditionParametersOperator_GreaterThan,
		RequestUriMatchConditionParametersOperator_GreaterThanOrEqual,
		RequestUriMatchConditionParametersOperator_LessThan,
		RequestUriMatchConditionParametersOperator_LessThanOrEqual,
		RequestUriMatchConditionParametersOperator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestUriMatchConditionParametersTransforms_Lowercase,
		RequestUriMatchConditionParametersTransforms_RemoveNulls,
		RequestUriMatchConditionParametersTransforms_Trim,
		RequestUriMatchConditionParametersTransforms_Uppercase,
		RequestUriMatchConditionParametersTransforms_UrlDecode,
		RequestUriMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestUriMatchConditionParametersTypeName_DeliveryRuleRequestUriConditionParameters))
}

func Test_RouteConfigurationOverrideActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from RouteConfigurationOverrideActionParameters to RouteConfigurationOverrideActionParameters via AssignPropertiesToRouteConfigurationOverrideActionParameters & AssignPropertiesFromRouteConfigurationOverrideActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForRouteConfigurationOverrideActionParameters, RouteConfigurationOverrideActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForRouteConfigurationOverrideActionParameters tests if a specific instance of RouteConfigurationOverrideActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForRouteConfigurationOverrideActionParameters(subject RouteConfigurationOverrideActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.RouteConfigurationOverrideActionParameters
	err := copied.AssignPropertiesToRouteConfigurationOverrideActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual RouteConfigurationOverrideActionParameters
	err = actual.AssignPropertiesFromRouteConfigurationOverrideActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_RouteConfigurationOverrideActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteConfigurationOverrideActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteConfigurationOverrideActionParameters, RouteConfigurationOverrideActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteConfigurationOverrideActionParameters runs a test to see if a specific instance of RouteConfigurationOverrideActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteConfigurationOverrideActionParameters(subject RouteConfigurationOverrideActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteConfigurationOverrideActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteConfigurationOverrideActionParameters instances for property testing - lazily instantiated by
// RouteConfigurationOverrideActionParametersGenerator()
var routeConfigurationOverrideActionParametersGenerator gopter.Gen

// RouteConfigurationOverrideActionParametersGenerator returns a generator of RouteConfigurationOverrideActionParameters instances for property testing.
// We first initialize routeConfigurationOverrideActionParametersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RouteConfigurationOverrideActionParametersGenerator() gopter.Gen {
	if routeConfigurationOverrideActionParametersGenerator != nil {
		return routeConfigurationOverrideActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters(generators)
	routeConfigurationOverrideActionParametersGenerator = gen.Struct(reflect.TypeOf(RouteConfigurationOverrideActionParameters{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters(generators)
	AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParameters(generators)
	routeConfigurationOverrideActionParametersGenerator = gen.Struct(reflect.TypeOf(RouteConfigurationOverrideActionParameters{}), generators)

	return routeConfigurationOverrideActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters(gens map[string]gopter.Gen) {
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RouteConfigurationOverrideActionParametersTypeName_DeliveryRuleRouteConfigurationOverrideActionParameters))
}

// AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParameters(gens map[string]gopter.Gen) {
	gens["CacheConfiguration"] = gen.PtrOf(CacheConfigurationGenerator())
	gens["OriginGroupOverride"] = gen.PtrOf(OriginGroupOverrideGenerator())
}

func Test_ServerPortMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ServerPortMatchConditionParameters to ServerPortMatchConditionParameters via AssignPropertiesToServerPortMatchConditionParameters & AssignPropertiesFromServerPortMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForServerPortMatchConditionParameters, ServerPortMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForServerPortMatchConditionParameters tests if a specific instance of ServerPortMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForServerPortMatchConditionParameters(subject ServerPortMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ServerPortMatchConditionParameters
	err := copied.AssignPropertiesToServerPortMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ServerPortMatchConditionParameters
	err = actual.AssignPropertiesFromServerPortMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ServerPortMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerPortMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerPortMatchConditionParameters, ServerPortMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerPortMatchConditionParameters runs a test to see if a specific instance of ServerPortMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForServerPortMatchConditionParameters(subject ServerPortMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerPortMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerPortMatchConditionParameters instances for property testing - lazily instantiated by
// ServerPortMatchConditionParametersGenerator()
var serverPortMatchConditionParametersGenerator gopter.Gen

// ServerPortMatchConditionParametersGenerator returns a generator of ServerPortMatchConditionParameters instances for property testing.
func ServerPortMatchConditionParametersGenerator() gopter.Gen {
	if serverPortMatchConditionParametersGenerator != nil {
		return serverPortMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerPortMatchConditionParameters(generators)
	serverPortMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(ServerPortMatchConditionParameters{}), generators)

	return serverPortMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForServerPortMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerPortMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		ServerPortMatchConditionParametersOperator_Any,
		ServerPortMatchConditionParametersOperator_BeginsWith,
		ServerPortMatchConditionParametersOperator_Contains,
		ServerPortMatchConditionParametersOperator_EndsWith,
		ServerPortMatchConditionParametersOperator_Equal,
		ServerPortMatchConditionParametersOperator_GreaterThan,
		ServerPortMatchConditionParametersOperator_GreaterThanOrEqual,
		ServerPortMatchConditionParametersOperator_LessThan,
		ServerPortMatchConditionParametersOperator_LessThanOrEqual,
		ServerPortMatchConditionParametersOperator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		ServerPortMatchConditionParametersTransforms_Lowercase,
		ServerPortMatchConditionParametersTransforms_RemoveNulls,
		ServerPortMatchConditionParametersTransforms_Trim,
		ServerPortMatchConditionParametersTransforms_Uppercase,
		ServerPortMatchConditionParametersTransforms_UrlDecode,
		ServerPortMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(ServerPortMatchConditionParametersTypeName_DeliveryRuleServerPortConditionParameters))
}

func Test_SocketAddrMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SocketAddrMatchConditionParameters to SocketAddrMatchConditionParameters via AssignPropertiesToSocketAddrMatchConditionParameters & AssignPropertiesFromSocketAddrMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForSocketAddrMatchConditionParameters, SocketAddrMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSocketAddrMatchConditionParameters tests if a specific instance of SocketAddrMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForSocketAddrMatchConditionParameters(subject SocketAddrMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.SocketAddrMatchConditionParameters
	err := copied.AssignPropertiesToSocketAddrMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SocketAddrMatchConditionParameters
	err = actual.AssignPropertiesFromSocketAddrMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SocketAddrMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SocketAddrMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSocketAddrMatchConditionParameters, SocketAddrMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSocketAddrMatchConditionParameters runs a test to see if a specific instance of SocketAddrMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForSocketAddrMatchConditionParameters(subject SocketAddrMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SocketAddrMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SocketAddrMatchConditionParameters instances for property testing - lazily instantiated by
// SocketAddrMatchConditionParametersGenerator()
var socketAddrMatchConditionParametersGenerator gopter.Gen

// SocketAddrMatchConditionParametersGenerator returns a generator of SocketAddrMatchConditionParameters instances for property testing.
func SocketAddrMatchConditionParametersGenerator() gopter.Gen {
	if socketAddrMatchConditionParametersGenerator != nil {
		return socketAddrMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParameters(generators)
	socketAddrMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(SocketAddrMatchConditionParameters{}), generators)

	return socketAddrMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(SocketAddrMatchConditionParametersOperator_Any, SocketAddrMatchConditionParametersOperator_IPMatch))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		SocketAddrMatchConditionParametersTransforms_Lowercase,
		SocketAddrMatchConditionParametersTransforms_RemoveNulls,
		SocketAddrMatchConditionParametersTransforms_Trim,
		SocketAddrMatchConditionParametersTransforms_Uppercase,
		SocketAddrMatchConditionParametersTransforms_UrlDecode,
		SocketAddrMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(SocketAddrMatchConditionParametersTypeName_DeliveryRuleSocketAddrConditionParameters))
}

func Test_SslProtocolMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from SslProtocolMatchConditionParameters to SslProtocolMatchConditionParameters via AssignPropertiesToSslProtocolMatchConditionParameters & AssignPropertiesFromSslProtocolMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForSslProtocolMatchConditionParameters, SslProtocolMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForSslProtocolMatchConditionParameters tests if a specific instance of SslProtocolMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForSslProtocolMatchConditionParameters(subject SslProtocolMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.SslProtocolMatchConditionParameters
	err := copied.AssignPropertiesToSslProtocolMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual SslProtocolMatchConditionParameters
	err = actual.AssignPropertiesFromSslProtocolMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_SslProtocolMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SslProtocolMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSslProtocolMatchConditionParameters, SslProtocolMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSslProtocolMatchConditionParameters runs a test to see if a specific instance of SslProtocolMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForSslProtocolMatchConditionParameters(subject SslProtocolMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SslProtocolMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SslProtocolMatchConditionParameters instances for property testing - lazily instantiated by
// SslProtocolMatchConditionParametersGenerator()
var sslProtocolMatchConditionParametersGenerator gopter.Gen

// SslProtocolMatchConditionParametersGenerator returns a generator of SslProtocolMatchConditionParameters instances for property testing.
func SslProtocolMatchConditionParametersGenerator() gopter.Gen {
	if sslProtocolMatchConditionParametersGenerator != nil {
		return sslProtocolMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParameters(generators)
	sslProtocolMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(SslProtocolMatchConditionParameters{}), generators)

	return sslProtocolMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(SslProtocolMatchConditionParametersMatchValues_TLSv1, SslProtocolMatchConditionParametersMatchValues_TLSv11, SslProtocolMatchConditionParametersMatchValues_TLSv12))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(SslProtocolMatchConditionParametersOperator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		SslProtocolMatchConditionParametersTransforms_Lowercase,
		SslProtocolMatchConditionParametersTransforms_RemoveNulls,
		SslProtocolMatchConditionParametersTransforms_Trim,
		SslProtocolMatchConditionParametersTransforms_Uppercase,
		SslProtocolMatchConditionParametersTransforms_UrlDecode,
		SslProtocolMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(SslProtocolMatchConditionParametersTypeName_DeliveryRuleSslProtocolConditionParameters))
}

func Test_UrlFileExtensionMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlFileExtensionMatchConditionParameters to UrlFileExtensionMatchConditionParameters via AssignPropertiesToUrlFileExtensionMatchConditionParameters & AssignPropertiesFromUrlFileExtensionMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlFileExtensionMatchConditionParameters, UrlFileExtensionMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlFileExtensionMatchConditionParameters tests if a specific instance of UrlFileExtensionMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlFileExtensionMatchConditionParameters(subject UrlFileExtensionMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlFileExtensionMatchConditionParameters
	err := copied.AssignPropertiesToUrlFileExtensionMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlFileExtensionMatchConditionParameters
	err = actual.AssignPropertiesFromUrlFileExtensionMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlFileExtensionMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlFileExtensionMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlFileExtensionMatchConditionParameters, UrlFileExtensionMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlFileExtensionMatchConditionParameters runs a test to see if a specific instance of UrlFileExtensionMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlFileExtensionMatchConditionParameters(subject UrlFileExtensionMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlFileExtensionMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlFileExtensionMatchConditionParameters instances for property testing - lazily instantiated by
// UrlFileExtensionMatchConditionParametersGenerator()
var urlFileExtensionMatchConditionParametersGenerator gopter.Gen

// UrlFileExtensionMatchConditionParametersGenerator returns a generator of UrlFileExtensionMatchConditionParameters instances for property testing.
func UrlFileExtensionMatchConditionParametersGenerator() gopter.Gen {
	if urlFileExtensionMatchConditionParametersGenerator != nil {
		return urlFileExtensionMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParameters(generators)
	urlFileExtensionMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(UrlFileExtensionMatchConditionParameters{}), generators)

	return urlFileExtensionMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlFileExtensionMatchConditionParametersOperator_Any,
		UrlFileExtensionMatchConditionParametersOperator_BeginsWith,
		UrlFileExtensionMatchConditionParametersOperator_Contains,
		UrlFileExtensionMatchConditionParametersOperator_EndsWith,
		UrlFileExtensionMatchConditionParametersOperator_Equal,
		UrlFileExtensionMatchConditionParametersOperator_GreaterThan,
		UrlFileExtensionMatchConditionParametersOperator_GreaterThanOrEqual,
		UrlFileExtensionMatchConditionParametersOperator_LessThan,
		UrlFileExtensionMatchConditionParametersOperator_LessThanOrEqual,
		UrlFileExtensionMatchConditionParametersOperator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		UrlFileExtensionMatchConditionParametersTransforms_Lowercase,
		UrlFileExtensionMatchConditionParametersTransforms_RemoveNulls,
		UrlFileExtensionMatchConditionParametersTransforms_Trim,
		UrlFileExtensionMatchConditionParametersTransforms_Uppercase,
		UrlFileExtensionMatchConditionParametersTransforms_UrlDecode,
		UrlFileExtensionMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlFileExtensionMatchConditionParametersTypeName_DeliveryRuleUrlFileExtensionMatchConditionParameters))
}

func Test_UrlFileNameMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlFileNameMatchConditionParameters to UrlFileNameMatchConditionParameters via AssignPropertiesToUrlFileNameMatchConditionParameters & AssignPropertiesFromUrlFileNameMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlFileNameMatchConditionParameters, UrlFileNameMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlFileNameMatchConditionParameters tests if a specific instance of UrlFileNameMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlFileNameMatchConditionParameters(subject UrlFileNameMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlFileNameMatchConditionParameters
	err := copied.AssignPropertiesToUrlFileNameMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlFileNameMatchConditionParameters
	err = actual.AssignPropertiesFromUrlFileNameMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlFileNameMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlFileNameMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlFileNameMatchConditionParameters, UrlFileNameMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlFileNameMatchConditionParameters runs a test to see if a specific instance of UrlFileNameMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlFileNameMatchConditionParameters(subject UrlFileNameMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlFileNameMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlFileNameMatchConditionParameters instances for property testing - lazily instantiated by
// UrlFileNameMatchConditionParametersGenerator()
var urlFileNameMatchConditionParametersGenerator gopter.Gen

// UrlFileNameMatchConditionParametersGenerator returns a generator of UrlFileNameMatchConditionParameters instances for property testing.
func UrlFileNameMatchConditionParametersGenerator() gopter.Gen {
	if urlFileNameMatchConditionParametersGenerator != nil {
		return urlFileNameMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParameters(generators)
	urlFileNameMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(UrlFileNameMatchConditionParameters{}), generators)

	return urlFileNameMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlFileNameMatchConditionParametersOperator_Any,
		UrlFileNameMatchConditionParametersOperator_BeginsWith,
		UrlFileNameMatchConditionParametersOperator_Contains,
		UrlFileNameMatchConditionParametersOperator_EndsWith,
		UrlFileNameMatchConditionParametersOperator_Equal,
		UrlFileNameMatchConditionParametersOperator_GreaterThan,
		UrlFileNameMatchConditionParametersOperator_GreaterThanOrEqual,
		UrlFileNameMatchConditionParametersOperator_LessThan,
		UrlFileNameMatchConditionParametersOperator_LessThanOrEqual,
		UrlFileNameMatchConditionParametersOperator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		UrlFileNameMatchConditionParametersTransforms_Lowercase,
		UrlFileNameMatchConditionParametersTransforms_RemoveNulls,
		UrlFileNameMatchConditionParametersTransforms_Trim,
		UrlFileNameMatchConditionParametersTransforms_Uppercase,
		UrlFileNameMatchConditionParametersTransforms_UrlDecode,
		UrlFileNameMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlFileNameMatchConditionParametersTypeName_DeliveryRuleUrlFilenameConditionParameters))
}

func Test_UrlPathMatchConditionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlPathMatchConditionParameters to UrlPathMatchConditionParameters via AssignPropertiesToUrlPathMatchConditionParameters & AssignPropertiesFromUrlPathMatchConditionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlPathMatchConditionParameters, UrlPathMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlPathMatchConditionParameters tests if a specific instance of UrlPathMatchConditionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlPathMatchConditionParameters(subject UrlPathMatchConditionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlPathMatchConditionParameters
	err := copied.AssignPropertiesToUrlPathMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlPathMatchConditionParameters
	err = actual.AssignPropertiesFromUrlPathMatchConditionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlPathMatchConditionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlPathMatchConditionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlPathMatchConditionParameters, UrlPathMatchConditionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlPathMatchConditionParameters runs a test to see if a specific instance of UrlPathMatchConditionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlPathMatchConditionParameters(subject UrlPathMatchConditionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlPathMatchConditionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlPathMatchConditionParameters instances for property testing - lazily instantiated by
// UrlPathMatchConditionParametersGenerator()
var urlPathMatchConditionParametersGenerator gopter.Gen

// UrlPathMatchConditionParametersGenerator returns a generator of UrlPathMatchConditionParameters instances for property testing.
func UrlPathMatchConditionParametersGenerator() gopter.Gen {
	if urlPathMatchConditionParametersGenerator != nil {
		return urlPathMatchConditionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlPathMatchConditionParameters(generators)
	urlPathMatchConditionParametersGenerator = gen.Struct(reflect.TypeOf(UrlPathMatchConditionParameters{}), generators)

	return urlPathMatchConditionParametersGenerator
}

// AddIndependentPropertyGeneratorsForUrlPathMatchConditionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlPathMatchConditionParameters(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlPathMatchConditionParametersOperator_Any,
		UrlPathMatchConditionParametersOperator_BeginsWith,
		UrlPathMatchConditionParametersOperator_Contains,
		UrlPathMatchConditionParametersOperator_EndsWith,
		UrlPathMatchConditionParametersOperator_Equal,
		UrlPathMatchConditionParametersOperator_GreaterThan,
		UrlPathMatchConditionParametersOperator_GreaterThanOrEqual,
		UrlPathMatchConditionParametersOperator_LessThan,
		UrlPathMatchConditionParametersOperator_LessThanOrEqual,
		UrlPathMatchConditionParametersOperator_RegEx,
		UrlPathMatchConditionParametersOperator_Wildcard))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		UrlPathMatchConditionParametersTransforms_Lowercase,
		UrlPathMatchConditionParametersTransforms_RemoveNulls,
		UrlPathMatchConditionParametersTransforms_Trim,
		UrlPathMatchConditionParametersTransforms_Uppercase,
		UrlPathMatchConditionParametersTransforms_UrlDecode,
		UrlPathMatchConditionParametersTransforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlPathMatchConditionParametersTypeName_DeliveryRuleUrlPathMatchConditionParameters))
}

func Test_UrlRedirectActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlRedirectActionParameters to UrlRedirectActionParameters via AssignPropertiesToUrlRedirectActionParameters & AssignPropertiesFromUrlRedirectActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlRedirectActionParameters, UrlRedirectActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlRedirectActionParameters tests if a specific instance of UrlRedirectActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlRedirectActionParameters(subject UrlRedirectActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlRedirectActionParameters
	err := copied.AssignPropertiesToUrlRedirectActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlRedirectActionParameters
	err = actual.AssignPropertiesFromUrlRedirectActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlRedirectActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRedirectActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRedirectActionParameters, UrlRedirectActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRedirectActionParameters runs a test to see if a specific instance of UrlRedirectActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRedirectActionParameters(subject UrlRedirectActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRedirectActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRedirectActionParameters instances for property testing - lazily instantiated by
// UrlRedirectActionParametersGenerator()
var urlRedirectActionParametersGenerator gopter.Gen

// UrlRedirectActionParametersGenerator returns a generator of UrlRedirectActionParameters instances for property testing.
func UrlRedirectActionParametersGenerator() gopter.Gen {
	if urlRedirectActionParametersGenerator != nil {
		return urlRedirectActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectActionParameters(generators)
	urlRedirectActionParametersGenerator = gen.Struct(reflect.TypeOf(UrlRedirectActionParameters{}), generators)

	return urlRedirectActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForUrlRedirectActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRedirectActionParameters(gens map[string]gopter.Gen) {
	gens["CustomFragment"] = gen.PtrOf(gen.AlphaString())
	gens["CustomHostname"] = gen.PtrOf(gen.AlphaString())
	gens["CustomPath"] = gen.PtrOf(gen.AlphaString())
	gens["CustomQueryString"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationProtocol"] = gen.PtrOf(gen.OneConstOf(UrlRedirectActionParametersDestinationProtocol_Http, UrlRedirectActionParametersDestinationProtocol_Https, UrlRedirectActionParametersDestinationProtocol_MatchRequest))
	gens["RedirectType"] = gen.PtrOf(gen.OneConstOf(
		UrlRedirectActionParametersRedirectType_Found,
		UrlRedirectActionParametersRedirectType_Moved,
		UrlRedirectActionParametersRedirectType_PermanentRedirect,
		UrlRedirectActionParametersRedirectType_TemporaryRedirect))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlRedirectActionParametersTypeName_DeliveryRuleUrlRedirectActionParameters))
}

func Test_UrlRewriteActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlRewriteActionParameters to UrlRewriteActionParameters via AssignPropertiesToUrlRewriteActionParameters & AssignPropertiesFromUrlRewriteActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlRewriteActionParameters, UrlRewriteActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlRewriteActionParameters tests if a specific instance of UrlRewriteActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlRewriteActionParameters(subject UrlRewriteActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlRewriteActionParameters
	err := copied.AssignPropertiesToUrlRewriteActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlRewriteActionParameters
	err = actual.AssignPropertiesFromUrlRewriteActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlRewriteActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRewriteActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRewriteActionParameters, UrlRewriteActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRewriteActionParameters runs a test to see if a specific instance of UrlRewriteActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRewriteActionParameters(subject UrlRewriteActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRewriteActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRewriteActionParameters instances for property testing - lazily instantiated by
// UrlRewriteActionParametersGenerator()
var urlRewriteActionParametersGenerator gopter.Gen

// UrlRewriteActionParametersGenerator returns a generator of UrlRewriteActionParameters instances for property testing.
func UrlRewriteActionParametersGenerator() gopter.Gen {
	if urlRewriteActionParametersGenerator != nil {
		return urlRewriteActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteActionParameters(generators)
	urlRewriteActionParametersGenerator = gen.Struct(reflect.TypeOf(UrlRewriteActionParameters{}), generators)

	return urlRewriteActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForUrlRewriteActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRewriteActionParameters(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(gen.AlphaString())
	gens["PreserveUnmatchedPath"] = gen.PtrOf(gen.Bool())
	gens["SourcePattern"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlRewriteActionParametersTypeName_DeliveryRuleUrlRewriteActionParameters))
}

func Test_UrlSigningActionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningActionParameters to UrlSigningActionParameters via AssignPropertiesToUrlSigningActionParameters & AssignPropertiesFromUrlSigningActionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningActionParameters, UrlSigningActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningActionParameters tests if a specific instance of UrlSigningActionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningActionParameters(subject UrlSigningActionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningActionParameters
	err := copied.AssignPropertiesToUrlSigningActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningActionParameters
	err = actual.AssignPropertiesFromUrlSigningActionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningActionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningActionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningActionParameters, UrlSigningActionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningActionParameters runs a test to see if a specific instance of UrlSigningActionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningActionParameters(subject UrlSigningActionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningActionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningActionParameters instances for property testing - lazily instantiated by
// UrlSigningActionParametersGenerator()
var urlSigningActionParametersGenerator gopter.Gen

// UrlSigningActionParametersGenerator returns a generator of UrlSigningActionParameters instances for property testing.
// We first initialize urlSigningActionParametersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningActionParametersGenerator() gopter.Gen {
	if urlSigningActionParametersGenerator != nil {
		return urlSigningActionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionParameters(generators)
	urlSigningActionParametersGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionParameters{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionParameters(generators)
	AddRelatedPropertyGeneratorsForUrlSigningActionParameters(generators)
	urlSigningActionParametersGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionParameters{}), generators)

	return urlSigningActionParametersGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningActionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningActionParameters(gens map[string]gopter.Gen) {
	gens["Algorithm"] = gen.PtrOf(gen.OneConstOf(UrlSigningActionParametersAlgorithm_SHA256))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlSigningActionParametersTypeName_DeliveryRuleUrlSigningActionParameters))
}

// AddRelatedPropertyGeneratorsForUrlSigningActionParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningActionParameters(gens map[string]gopter.Gen) {
	gens["ParameterNameOverride"] = gen.SliceOf(UrlSigningParamIdentifierGenerator())
}

func Test_CacheConfiguration_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CacheConfiguration to CacheConfiguration via AssignPropertiesToCacheConfiguration & AssignPropertiesFromCacheConfiguration returns original",
		prop.ForAll(RunPropertyAssignmentTestForCacheConfiguration, CacheConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCacheConfiguration tests if a specific instance of CacheConfiguration can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCacheConfiguration(subject CacheConfiguration) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CacheConfiguration
	err := copied.AssignPropertiesToCacheConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CacheConfiguration
	err = actual.AssignPropertiesFromCacheConfiguration(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CacheConfiguration_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheConfiguration via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheConfiguration, CacheConfigurationGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheConfiguration runs a test to see if a specific instance of CacheConfiguration round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheConfiguration(subject CacheConfiguration) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheConfiguration
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheConfiguration instances for property testing - lazily instantiated by CacheConfigurationGenerator()
var cacheConfigurationGenerator gopter.Gen

// CacheConfigurationGenerator returns a generator of CacheConfiguration instances for property testing.
func CacheConfigurationGenerator() gopter.Gen {
	if cacheConfigurationGenerator != nil {
		return cacheConfigurationGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheConfiguration(generators)
	cacheConfigurationGenerator = gen.Struct(reflect.TypeOf(CacheConfiguration{}), generators)

	return cacheConfigurationGenerator
}

// AddIndependentPropertyGeneratorsForCacheConfiguration is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheConfiguration(gens map[string]gopter.Gen) {
	gens["CacheBehavior"] = gen.PtrOf(gen.OneConstOf(CacheConfigurationCacheBehavior_HonorOrigin, CacheConfigurationCacheBehavior_OverrideAlways, CacheConfigurationCacheBehavior_OverrideIfOriginMissing))
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.OneConstOf(CacheConfigurationIsCompressionEnabled_Disabled, CacheConfigurationIsCompressionEnabled_Enabled))
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		CacheConfigurationQueryStringCachingBehavior_IgnoreQueryString,
		CacheConfigurationQueryStringCachingBehavior_IgnoreSpecifiedQueryStrings,
		CacheConfigurationQueryStringCachingBehavior_IncludeSpecifiedQueryStrings,
		CacheConfigurationQueryStringCachingBehavior_UseQueryString))
}

func Test_OriginGroupOverride_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from OriginGroupOverride to OriginGroupOverride via AssignPropertiesToOriginGroupOverride & AssignPropertiesFromOriginGroupOverride returns original",
		prop.ForAll(RunPropertyAssignmentTestForOriginGroupOverride, OriginGroupOverrideGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForOriginGroupOverride tests if a specific instance of OriginGroupOverride can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForOriginGroupOverride(subject OriginGroupOverride) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.OriginGroupOverride
	err := copied.AssignPropertiesToOriginGroupOverride(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual OriginGroupOverride
	err = actual.AssignPropertiesFromOriginGroupOverride(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_OriginGroupOverride_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverride via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverride, OriginGroupOverrideGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverride runs a test to see if a specific instance of OriginGroupOverride round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverride(subject OriginGroupOverride) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverride
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverride instances for property testing - lazily instantiated by
// OriginGroupOverrideGenerator()
var originGroupOverrideGenerator gopter.Gen

// OriginGroupOverrideGenerator returns a generator of OriginGroupOverride instances for property testing.
// We first initialize originGroupOverrideGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideGenerator() gopter.Gen {
	if originGroupOverrideGenerator != nil {
		return originGroupOverrideGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverride(generators)
	originGroupOverrideGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverride{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverride(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverride(generators)
	originGroupOverrideGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverride{}), generators)

	return originGroupOverrideGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverride is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverride(gens map[string]gopter.Gen) {
	gens["ForwardingProtocol"] = gen.PtrOf(gen.OneConstOf(OriginGroupOverrideForwardingProtocol_HttpOnly, OriginGroupOverrideForwardingProtocol_HttpsOnly, OriginGroupOverrideForwardingProtocol_MatchRequest))
}

// AddRelatedPropertyGeneratorsForOriginGroupOverride is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverride(gens map[string]gopter.Gen) {
	gens["OriginGroup"] = gen.PtrOf(ResourceReferenceGenerator())
}

func Test_UrlSigningParamIdentifier_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningParamIdentifier to UrlSigningParamIdentifier via AssignPropertiesToUrlSigningParamIdentifier & AssignPropertiesFromUrlSigningParamIdentifier returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningParamIdentifier, UrlSigningParamIdentifierGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningParamIdentifier tests if a specific instance of UrlSigningParamIdentifier can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningParamIdentifier(subject UrlSigningParamIdentifier) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningParamIdentifier
	err := copied.AssignPropertiesToUrlSigningParamIdentifier(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningParamIdentifier
	err = actual.AssignPropertiesFromUrlSigningParamIdentifier(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningParamIdentifier_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningParamIdentifier via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningParamIdentifier, UrlSigningParamIdentifierGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningParamIdentifier runs a test to see if a specific instance of UrlSigningParamIdentifier round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningParamIdentifier(subject UrlSigningParamIdentifier) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningParamIdentifier
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningParamIdentifier instances for property testing - lazily instantiated by
// UrlSigningParamIdentifierGenerator()
var urlSigningParamIdentifierGenerator gopter.Gen

// UrlSigningParamIdentifierGenerator returns a generator of UrlSigningParamIdentifier instances for property testing.
func UrlSigningParamIdentifierGenerator() gopter.Gen {
	if urlSigningParamIdentifierGenerator != nil {
		return urlSigningParamIdentifierGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningParamIdentifier(generators)
	urlSigningParamIdentifierGenerator = gen.Struct(reflect.TypeOf(UrlSigningParamIdentifier{}), generators)

	return urlSigningParamIdentifierGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningParamIdentifier is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningParamIdentifier(gens map[string]gopter.Gen) {
	gens["ParamIndicator"] = gen.PtrOf(gen.OneConstOf(UrlSigningParamIdentifierParamIndicator_Expires, UrlSigningParamIdentifierParamIndicator_KeyId, UrlSigningParamIdentifierParamIndicator_Signature))
	gens["ParamName"] = gen.PtrOf(gen.AlphaString())
}
