// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210601

import (
	"encoding/json"
	v20210601s "github.com/Azure/azure-service-operator/v2/api/cdn/v1beta20210601storage"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ProfilesEndpoint_WhenConvertedToHub_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ProfilesEndpoint to hub returns original",
		prop.ForAll(RunResourceConversionTestForProfilesEndpoint, ProfilesEndpointGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunResourceConversionTestForProfilesEndpoint tests if a specific instance of ProfilesEndpoint round trips to the hub storage version and back losslessly
func RunResourceConversionTestForProfilesEndpoint(subject ProfilesEndpoint) string {
	// Copy subject to make sure conversion doesn't modify it
	copied := subject.DeepCopy()

	// Convert to our hub version
	var hub v20210601s.ProfilesEndpoint
	err := copied.ConvertTo(&hub)
	if err != nil {
		return err.Error()
	}

	// Convert from our hub version
	var actual ProfilesEndpoint
	err = actual.ConvertFrom(&hub)
	if err != nil {
		return err.Error()
	}

	// Compare actual with what we started with
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ProfilesEndpoint_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ProfilesEndpoint to ProfilesEndpoint via AssignPropertiesToProfilesEndpoint & AssignPropertiesFromProfilesEndpoint returns original",
		prop.ForAll(RunPropertyAssignmentTestForProfilesEndpoint, ProfilesEndpointGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProfilesEndpoint tests if a specific instance of ProfilesEndpoint can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForProfilesEndpoint(subject ProfilesEndpoint) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ProfilesEndpoint
	err := copied.AssignPropertiesToProfilesEndpoint(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ProfilesEndpoint
	err = actual.AssignPropertiesFromProfilesEndpoint(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ProfilesEndpoint_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProfilesEndpoint via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfilesEndpoint, ProfilesEndpointGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfilesEndpoint runs a test to see if a specific instance of ProfilesEndpoint round trips to JSON and back losslessly
func RunJSONSerializationTestForProfilesEndpoint(subject ProfilesEndpoint) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProfilesEndpoint
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProfilesEndpoint instances for property testing - lazily instantiated by ProfilesEndpointGenerator()
var profilesEndpointGenerator gopter.Gen

// ProfilesEndpointGenerator returns a generator of ProfilesEndpoint instances for property testing.
func ProfilesEndpointGenerator() gopter.Gen {
	if profilesEndpointGenerator != nil {
		return profilesEndpointGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForProfilesEndpoint(generators)
	profilesEndpointGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoint{}), generators)

	return profilesEndpointGenerator
}

// AddRelatedPropertyGeneratorsForProfilesEndpoint is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfilesEndpoint(gens map[string]gopter.Gen) {
	gens["Spec"] = ProfilesEndpoint_SpecGenerator()
	gens["Status"] = ProfilesEndpoint_STATUSGenerator()
}

func Test_ProfilesEndpoint_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ProfilesEndpoint_STATUS to ProfilesEndpoint_STATUS via AssignPropertiesToProfilesEndpoint_STATUS & AssignPropertiesFromProfilesEndpoint_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForProfilesEndpoint_STATUS, ProfilesEndpoint_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProfilesEndpoint_STATUS tests if a specific instance of ProfilesEndpoint_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForProfilesEndpoint_STATUS(subject ProfilesEndpoint_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ProfilesEndpoint_STATUS
	err := copied.AssignPropertiesToProfilesEndpoint_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ProfilesEndpoint_STATUS
	err = actual.AssignPropertiesFromProfilesEndpoint_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ProfilesEndpoint_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProfilesEndpoint_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfilesEndpoint_STATUS, ProfilesEndpoint_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfilesEndpoint_STATUS runs a test to see if a specific instance of ProfilesEndpoint_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForProfilesEndpoint_STATUS(subject ProfilesEndpoint_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProfilesEndpoint_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProfilesEndpoint_STATUS instances for property testing - lazily instantiated by
// ProfilesEndpoint_STATUSGenerator()
var profilesEndpoint_STATUSGenerator gopter.Gen

// ProfilesEndpoint_STATUSGenerator returns a generator of ProfilesEndpoint_STATUS instances for property testing.
// We first initialize profilesEndpoint_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProfilesEndpoint_STATUSGenerator() gopter.Gen {
	if profilesEndpoint_STATUSGenerator != nil {
		return profilesEndpoint_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpoint_STATUS(generators)
	profilesEndpoint_STATUSGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoint_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpoint_STATUS(generators)
	AddRelatedPropertyGeneratorsForProfilesEndpoint_STATUS(generators)
	profilesEndpoint_STATUSGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoint_STATUS{}), generators)

	return profilesEndpoint_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForProfilesEndpoint_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfilesEndpoint_STATUS(gens map[string]gopter.Gen) {
	gens["ContentTypesToCompress"] = gen.SliceOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsHttpAllowed"] = gen.PtrOf(gen.Bool())
	gens["IsHttpsAllowed"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OptimizationType"] = gen.PtrOf(gen.OneConstOf(
		OptimizationType_DynamicSiteAcceleration_STATUS,
		OptimizationType_GeneralMediaStreaming_STATUS,
		OptimizationType_GeneralWebDelivery_STATUS,
		OptimizationType_LargeFileDownload_STATUS,
		OptimizationType_VideoOnDemandMediaStreaming_STATUS))
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["OriginPath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		EndpointProperties_ProvisioningState_Creating_STATUS,
		EndpointProperties_ProvisioningState_Deleting_STATUS,
		EndpointProperties_ProvisioningState_Failed_STATUS,
		EndpointProperties_ProvisioningState_Succeeded_STATUS,
		EndpointProperties_ProvisioningState_Updating_STATUS))
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		QueryStringCachingBehavior_BypassCaching_STATUS,
		QueryStringCachingBehavior_IgnoreQueryString_STATUS,
		QueryStringCachingBehavior_NotSet_STATUS,
		QueryStringCachingBehavior_UseQueryString_STATUS))
	gens["ResourceState"] = gen.PtrOf(gen.OneConstOf(
		EndpointProperties_ResourceState_Creating_STATUS,
		EndpointProperties_ResourceState_Deleting_STATUS,
		EndpointProperties_ResourceState_Running_STATUS,
		EndpointProperties_ResourceState_Starting_STATUS,
		EndpointProperties_ResourceState_Stopped_STATUS,
		EndpointProperties_ResourceState_Stopping_STATUS))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProfilesEndpoint_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfilesEndpoint_STATUS(gens map[string]gopter.Gen) {
	gens["CustomDomains"] = gen.SliceOf(CustomDomain_STATUSGenerator())
	gens["DefaultOriginGroup"] = gen.PtrOf(ResourceReference_STATUSGenerator())
	gens["DeliveryPolicy"] = gen.PtrOf(EndpointProperties_DeliveryPolicy_STATUSGenerator())
	gens["GeoFilters"] = gen.SliceOf(GeoFilter_STATUSGenerator())
	gens["OriginGroups"] = gen.SliceOf(DeepCreatedOriginGroup_STATUSGenerator())
	gens["Origins"] = gen.SliceOf(DeepCreatedOrigin_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
	gens["UrlSigningKeys"] = gen.SliceOf(UrlSigningKey_STATUSGenerator())
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(EndpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator())
}

func Test_ProfilesEndpoint_Spec_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ProfilesEndpoint_Spec to ProfilesEndpoint_Spec via AssignPropertiesToProfilesEndpoint_Spec & AssignPropertiesFromProfilesEndpoint_Spec returns original",
		prop.ForAll(RunPropertyAssignmentTestForProfilesEndpoint_Spec, ProfilesEndpoint_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForProfilesEndpoint_Spec tests if a specific instance of ProfilesEndpoint_Spec can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForProfilesEndpoint_Spec(subject ProfilesEndpoint_Spec) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ProfilesEndpoint_Spec
	err := copied.AssignPropertiesToProfilesEndpoint_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ProfilesEndpoint_Spec
	err = actual.AssignPropertiesFromProfilesEndpoint_Spec(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ProfilesEndpoint_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProfilesEndpoint_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfilesEndpoint_Spec, ProfilesEndpoint_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfilesEndpoint_Spec runs a test to see if a specific instance of ProfilesEndpoint_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForProfilesEndpoint_Spec(subject ProfilesEndpoint_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProfilesEndpoint_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProfilesEndpoint_Spec instances for property testing - lazily instantiated by
// ProfilesEndpoint_SpecGenerator()
var profilesEndpoint_SpecGenerator gopter.Gen

// ProfilesEndpoint_SpecGenerator returns a generator of ProfilesEndpoint_Spec instances for property testing.
// We first initialize profilesEndpoint_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProfilesEndpoint_SpecGenerator() gopter.Gen {
	if profilesEndpoint_SpecGenerator != nil {
		return profilesEndpoint_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpoint_Spec(generators)
	profilesEndpoint_SpecGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoint_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpoint_Spec(generators)
	AddRelatedPropertyGeneratorsForProfilesEndpoint_Spec(generators)
	profilesEndpoint_SpecGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoint_Spec{}), generators)

	return profilesEndpoint_SpecGenerator
}

// AddIndependentPropertyGeneratorsForProfilesEndpoint_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfilesEndpoint_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["ContentTypesToCompress"] = gen.SliceOf(gen.AlphaString())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsHttpAllowed"] = gen.PtrOf(gen.Bool())
	gens["IsHttpsAllowed"] = gen.PtrOf(gen.Bool())
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["OptimizationType"] = gen.PtrOf(gen.OneConstOf(
		OptimizationType_DynamicSiteAcceleration,
		OptimizationType_GeneralMediaStreaming,
		OptimizationType_GeneralWebDelivery,
		OptimizationType_LargeFileDownload,
		OptimizationType_VideoOnDemandMediaStreaming))
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["OriginPath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		EndpointProperties_ProvisioningState_Creating,
		EndpointProperties_ProvisioningState_Deleting,
		EndpointProperties_ProvisioningState_Failed,
		EndpointProperties_ProvisioningState_Succeeded,
		EndpointProperties_ProvisioningState_Updating))
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		QueryStringCachingBehavior_BypassCaching,
		QueryStringCachingBehavior_IgnoreQueryString,
		QueryStringCachingBehavior_NotSet,
		QueryStringCachingBehavior_UseQueryString))
	gens["ResourceState"] = gen.PtrOf(gen.OneConstOf(
		EndpointProperties_ResourceState_Creating,
		EndpointProperties_ResourceState_Deleting,
		EndpointProperties_ResourceState_Running,
		EndpointProperties_ResourceState_Starting,
		EndpointProperties_ResourceState_Stopped,
		EndpointProperties_ResourceState_Stopping))
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProfilesEndpoint_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfilesEndpoint_Spec(gens map[string]gopter.Gen) {
	gens["CustomDomains"] = gen.SliceOf(CustomDomainGenerator())
	gens["DefaultOriginGroup"] = gen.PtrOf(ResourceReferenceGenerator())
	gens["DeliveryPolicy"] = gen.PtrOf(EndpointProperties_DeliveryPolicyGenerator())
	gens["GeoFilters"] = gen.SliceOf(GeoFilterGenerator())
	gens["OriginGroups"] = gen.SliceOf(DeepCreatedOriginGroupGenerator())
	gens["Origins"] = gen.SliceOf(DeepCreatedOriginGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataGenerator())
	gens["UrlSigningKeys"] = gen.SliceOf(UrlSigningKeyGenerator())
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(EndpointProperties_WebApplicationFirewallPolicyLinkGenerator())
}

func Test_CustomDomain_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomDomain to CustomDomain via AssignPropertiesToCustomDomain & AssignPropertiesFromCustomDomain returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomDomain, CustomDomainGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomDomain tests if a specific instance of CustomDomain can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCustomDomain(subject CustomDomain) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CustomDomain
	err := copied.AssignPropertiesToCustomDomain(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomDomain
	err = actual.AssignPropertiesFromCustomDomain(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomDomain_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomain, CustomDomainGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomain runs a test to see if a specific instance of CustomDomain round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomain(subject CustomDomain) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain instances for property testing - lazily instantiated by CustomDomainGenerator()
var customDomainGenerator gopter.Gen

// CustomDomainGenerator returns a generator of CustomDomain instances for property testing.
// We first initialize customDomainGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomDomainGenerator() gopter.Gen {
	if customDomainGenerator != nil {
		return customDomainGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomain(generators)
	customDomainGenerator = gen.Struct(reflect.TypeOf(CustomDomain{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomain(generators)
	AddRelatedPropertyGeneratorsForCustomDomain(generators)
	customDomainGenerator = gen.Struct(reflect.TypeOf(CustomDomain{}), generators)

	return customDomainGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomain is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomain(gens map[string]gopter.Gen) {
	gens["CustomHttpsProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		CustomDomainProperties_CustomHttpsProvisioningState_Disabled,
		CustomDomainProperties_CustomHttpsProvisioningState_Disabling,
		CustomDomainProperties_CustomHttpsProvisioningState_Enabled,
		CustomDomainProperties_CustomHttpsProvisioningState_Enabling,
		CustomDomainProperties_CustomHttpsProvisioningState_Failed))
	gens["CustomHttpsProvisioningSubstate"] = gen.PtrOf(gen.OneConstOf(
		CustomDomainProperties_CustomHttpsProvisioningSubstate_CertificateDeleted,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_CertificateDeployed,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_DeletingCertificate,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_DeployingCertificate,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_DomainControlValidationRequestApproved,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_DomainControlValidationRequestRejected,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_DomainControlValidationRequestTimedOut,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_IssuingCertificate,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_PendingDomainControlValidationREquestApproval,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_SubmittingDomainControlValidationRequest))
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		CustomDomainProperties_ProvisioningState_Disabled,
		CustomDomainProperties_ProvisioningState_Disabling,
		CustomDomainProperties_ProvisioningState_Enabled,
		CustomDomainProperties_ProvisioningState_Enabling,
		CustomDomainProperties_ProvisioningState_Failed))
	gens["ResourceState"] = gen.PtrOf(gen.OneConstOf(CustomDomainProperties_ResourceState_Active, CustomDomainProperties_ResourceState_Creating, CustomDomainProperties_ResourceState_Deleting))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["ValidationData"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCustomDomain is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomDomain(gens map[string]gopter.Gen) {
	gens["CustomHttpsParameters"] = gen.PtrOf(CustomDomainHttpsParametersGenerator())
	gens["SystemData"] = gen.PtrOf(SystemDataGenerator())
}

func Test_CustomDomain_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomDomain_STATUS to CustomDomain_STATUS via AssignPropertiesToCustomDomain_STATUS & AssignPropertiesFromCustomDomain_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomDomain_STATUS, CustomDomain_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomDomain_STATUS tests if a specific instance of CustomDomain_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCustomDomain_STATUS(subject CustomDomain_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CustomDomain_STATUS
	err := copied.AssignPropertiesToCustomDomain_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomDomain_STATUS
	err = actual.AssignPropertiesFromCustomDomain_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomDomain_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomain_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomain_STATUS, CustomDomain_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomain_STATUS runs a test to see if a specific instance of CustomDomain_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomain_STATUS(subject CustomDomain_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomain_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomain_STATUS instances for property testing - lazily instantiated by
// CustomDomain_STATUSGenerator()
var customDomain_STATUSGenerator gopter.Gen

// CustomDomain_STATUSGenerator returns a generator of CustomDomain_STATUS instances for property testing.
// We first initialize customDomain_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func CustomDomain_STATUSGenerator() gopter.Gen {
	if customDomain_STATUSGenerator != nil {
		return customDomain_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomain_STATUS(generators)
	customDomain_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomDomain_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomain_STATUS(generators)
	AddRelatedPropertyGeneratorsForCustomDomain_STATUS(generators)
	customDomain_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomDomain_STATUS{}), generators)

	return customDomain_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomain_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomain_STATUS(gens map[string]gopter.Gen) {
	gens["CustomHttpsProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		CustomDomainProperties_CustomHttpsProvisioningState_Disabled_STATUS,
		CustomDomainProperties_CustomHttpsProvisioningState_Disabling_STATUS,
		CustomDomainProperties_CustomHttpsProvisioningState_Enabled_STATUS,
		CustomDomainProperties_CustomHttpsProvisioningState_Enabling_STATUS,
		CustomDomainProperties_CustomHttpsProvisioningState_Failed_STATUS))
	gens["CustomHttpsProvisioningSubstate"] = gen.PtrOf(gen.OneConstOf(
		CustomDomainProperties_CustomHttpsProvisioningSubstate_CertificateDeleted_STATUS,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_CertificateDeployed_STATUS,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_DeletingCertificate_STATUS,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_DeployingCertificate_STATUS,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_DomainControlValidationRequestApproved_STATUS,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_DomainControlValidationRequestRejected_STATUS,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_DomainControlValidationRequestTimedOut_STATUS,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_IssuingCertificate_STATUS,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_PendingDomainControlValidationREquestApproval_STATUS,
		CustomDomainProperties_CustomHttpsProvisioningSubstate_SubmittingDomainControlValidationRequest_STATUS))
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.OneConstOf(
		CustomDomainProperties_ProvisioningState_Disabled_STATUS,
		CustomDomainProperties_ProvisioningState_Disabling_STATUS,
		CustomDomainProperties_ProvisioningState_Enabled_STATUS,
		CustomDomainProperties_ProvisioningState_Enabling_STATUS,
		CustomDomainProperties_ProvisioningState_Failed_STATUS))
	gens["ResourceState"] = gen.PtrOf(gen.OneConstOf(CustomDomainProperties_ResourceState_Active_STATUS, CustomDomainProperties_ResourceState_Creating_STATUS, CustomDomainProperties_ResourceState_Deleting_STATUS))
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["ValidationData"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForCustomDomain_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForCustomDomain_STATUS(gens map[string]gopter.Gen) {
	gens["CustomHttpsParameters"] = gen.PtrOf(CustomDomainHttpsParameters_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_DeepCreatedOrigin_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeepCreatedOrigin to DeepCreatedOrigin via AssignPropertiesToDeepCreatedOrigin & AssignPropertiesFromDeepCreatedOrigin returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeepCreatedOrigin, DeepCreatedOriginGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeepCreatedOrigin tests if a specific instance of DeepCreatedOrigin can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeepCreatedOrigin(subject DeepCreatedOrigin) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeepCreatedOrigin
	err := copied.AssignPropertiesToDeepCreatedOrigin(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeepCreatedOrigin
	err = actual.AssignPropertiesFromDeepCreatedOrigin(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeepCreatedOrigin_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOrigin via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOrigin, DeepCreatedOriginGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOrigin runs a test to see if a specific instance of DeepCreatedOrigin round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOrigin(subject DeepCreatedOrigin) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOrigin
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOrigin instances for property testing - lazily instantiated by DeepCreatedOriginGenerator()
var deepCreatedOriginGenerator gopter.Gen

// DeepCreatedOriginGenerator returns a generator of DeepCreatedOrigin instances for property testing.
func DeepCreatedOriginGenerator() gopter.Gen {
	if deepCreatedOriginGenerator != nil {
		return deepCreatedOriginGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOrigin(generators)
	deepCreatedOriginGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOrigin{}), generators)

	return deepCreatedOriginGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOrigin is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOrigin(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["PrivateEndpointStatus"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointStatus_Approved,
		PrivateEndpointStatus_Disconnected,
		PrivateEndpointStatus_Pending,
		PrivateEndpointStatus_Rejected,
		PrivateEndpointStatus_Timeout))
	gens["PrivateLinkAlias"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkApprovalMessage"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_DeepCreatedOriginGroup_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeepCreatedOriginGroup to DeepCreatedOriginGroup via AssignPropertiesToDeepCreatedOriginGroup & AssignPropertiesFromDeepCreatedOriginGroup returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeepCreatedOriginGroup, DeepCreatedOriginGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeepCreatedOriginGroup tests if a specific instance of DeepCreatedOriginGroup can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeepCreatedOriginGroup(subject DeepCreatedOriginGroup) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeepCreatedOriginGroup
	err := copied.AssignPropertiesToDeepCreatedOriginGroup(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeepCreatedOriginGroup
	err = actual.AssignPropertiesFromDeepCreatedOriginGroup(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeepCreatedOriginGroup_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOriginGroup via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOriginGroup, DeepCreatedOriginGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOriginGroup runs a test to see if a specific instance of DeepCreatedOriginGroup round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOriginGroup(subject DeepCreatedOriginGroup) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOriginGroup
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOriginGroup instances for property testing - lazily instantiated by
// DeepCreatedOriginGroupGenerator()
var deepCreatedOriginGroupGenerator gopter.Gen

// DeepCreatedOriginGroupGenerator returns a generator of DeepCreatedOriginGroup instances for property testing.
// We first initialize deepCreatedOriginGroupGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeepCreatedOriginGroupGenerator() gopter.Gen {
	if deepCreatedOriginGroupGenerator != nil {
		return deepCreatedOriginGroupGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup(generators)
	deepCreatedOriginGroupGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroup{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup(generators)
	AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup(generators)
	deepCreatedOriginGroupGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroup{}), generators)

	return deepCreatedOriginGroupGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficRestorationTimeToHealedOrNewEndpointsInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup(gens map[string]gopter.Gen) {
	gens["HealthProbeSettings"] = gen.PtrOf(HealthProbeParametersGenerator())
	gens["Origins"] = gen.SliceOf(ResourceReferenceGenerator())
	gens["ResponseBasedOriginErrorDetectionSettings"] = gen.PtrOf(ResponseBasedOriginErrorDetectionParametersGenerator())
}

func Test_DeepCreatedOriginGroup_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeepCreatedOriginGroup_STATUS to DeepCreatedOriginGroup_STATUS via AssignPropertiesToDeepCreatedOriginGroup_STATUS & AssignPropertiesFromDeepCreatedOriginGroup_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeepCreatedOriginGroup_STATUS, DeepCreatedOriginGroup_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeepCreatedOriginGroup_STATUS tests if a specific instance of DeepCreatedOriginGroup_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeepCreatedOriginGroup_STATUS(subject DeepCreatedOriginGroup_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeepCreatedOriginGroup_STATUS
	err := copied.AssignPropertiesToDeepCreatedOriginGroup_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeepCreatedOriginGroup_STATUS
	err = actual.AssignPropertiesFromDeepCreatedOriginGroup_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeepCreatedOriginGroup_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOriginGroup_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOriginGroup_STATUS, DeepCreatedOriginGroup_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOriginGroup_STATUS runs a test to see if a specific instance of DeepCreatedOriginGroup_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOriginGroup_STATUS(subject DeepCreatedOriginGroup_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOriginGroup_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOriginGroup_STATUS instances for property testing - lazily instantiated by
// DeepCreatedOriginGroup_STATUSGenerator()
var deepCreatedOriginGroup_STATUSGenerator gopter.Gen

// DeepCreatedOriginGroup_STATUSGenerator returns a generator of DeepCreatedOriginGroup_STATUS instances for property testing.
// We first initialize deepCreatedOriginGroup_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeepCreatedOriginGroup_STATUSGenerator() gopter.Gen {
	if deepCreatedOriginGroup_STATUSGenerator != nil {
		return deepCreatedOriginGroup_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup_STATUS(generators)
	deepCreatedOriginGroup_STATUSGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroup_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup_STATUS(generators)
	deepCreatedOriginGroup_STATUSGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroup_STATUS{}), generators)

	return deepCreatedOriginGroup_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["TrafficRestorationTimeToHealedOrNewEndpointsInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup_STATUS(gens map[string]gopter.Gen) {
	gens["HealthProbeSettings"] = gen.PtrOf(HealthProbeParameters_STATUSGenerator())
	gens["Origins"] = gen.SliceOf(ResourceReference_STATUSGenerator())
	gens["ResponseBasedOriginErrorDetectionSettings"] = gen.PtrOf(ResponseBasedOriginErrorDetectionParameters_STATUSGenerator())
}

func Test_DeepCreatedOrigin_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeepCreatedOrigin_STATUS to DeepCreatedOrigin_STATUS via AssignPropertiesToDeepCreatedOrigin_STATUS & AssignPropertiesFromDeepCreatedOrigin_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeepCreatedOrigin_STATUS, DeepCreatedOrigin_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeepCreatedOrigin_STATUS tests if a specific instance of DeepCreatedOrigin_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeepCreatedOrigin_STATUS(subject DeepCreatedOrigin_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeepCreatedOrigin_STATUS
	err := copied.AssignPropertiesToDeepCreatedOrigin_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeepCreatedOrigin_STATUS
	err = actual.AssignPropertiesFromDeepCreatedOrigin_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeepCreatedOrigin_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOrigin_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOrigin_STATUS, DeepCreatedOrigin_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOrigin_STATUS runs a test to see if a specific instance of DeepCreatedOrigin_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOrigin_STATUS(subject DeepCreatedOrigin_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOrigin_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOrigin_STATUS instances for property testing - lazily instantiated by
// DeepCreatedOrigin_STATUSGenerator()
var deepCreatedOrigin_STATUSGenerator gopter.Gen

// DeepCreatedOrigin_STATUSGenerator returns a generator of DeepCreatedOrigin_STATUS instances for property testing.
func DeepCreatedOrigin_STATUSGenerator() gopter.Gen {
	if deepCreatedOrigin_STATUSGenerator != nil {
		return deepCreatedOrigin_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOrigin_STATUS(generators)
	deepCreatedOrigin_STATUSGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOrigin_STATUS{}), generators)

	return deepCreatedOrigin_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOrigin_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOrigin_STATUS(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["PrivateEndpointStatus"] = gen.PtrOf(gen.OneConstOf(
		PrivateEndpointStatus_Approved_STATUS,
		PrivateEndpointStatus_Disconnected_STATUS,
		PrivateEndpointStatus_Pending_STATUS,
		PrivateEndpointStatus_Rejected_STATUS,
		PrivateEndpointStatus_Timeout_STATUS))
	gens["PrivateLinkAlias"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkApprovalMessage"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkLocation"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_EndpointProperties_DeliveryPolicy_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EndpointProperties_DeliveryPolicy to EndpointProperties_DeliveryPolicy via AssignPropertiesToEndpointProperties_DeliveryPolicy & AssignPropertiesFromEndpointProperties_DeliveryPolicy returns original",
		prop.ForAll(RunPropertyAssignmentTestForEndpointProperties_DeliveryPolicy, EndpointProperties_DeliveryPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEndpointProperties_DeliveryPolicy tests if a specific instance of EndpointProperties_DeliveryPolicy can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForEndpointProperties_DeliveryPolicy(subject EndpointProperties_DeliveryPolicy) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.EndpointProperties_DeliveryPolicy
	err := copied.AssignPropertiesToEndpointProperties_DeliveryPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EndpointProperties_DeliveryPolicy
	err = actual.AssignPropertiesFromEndpointProperties_DeliveryPolicy(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EndpointProperties_DeliveryPolicy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointProperties_DeliveryPolicy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointProperties_DeliveryPolicy, EndpointProperties_DeliveryPolicyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointProperties_DeliveryPolicy runs a test to see if a specific instance of EndpointProperties_DeliveryPolicy round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointProperties_DeliveryPolicy(subject EndpointProperties_DeliveryPolicy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointProperties_DeliveryPolicy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointProperties_DeliveryPolicy instances for property testing - lazily instantiated by
// EndpointProperties_DeliveryPolicyGenerator()
var endpointProperties_DeliveryPolicyGenerator gopter.Gen

// EndpointProperties_DeliveryPolicyGenerator returns a generator of EndpointProperties_DeliveryPolicy instances for property testing.
// We first initialize endpointProperties_DeliveryPolicyGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EndpointProperties_DeliveryPolicyGenerator() gopter.Gen {
	if endpointProperties_DeliveryPolicyGenerator != nil {
		return endpointProperties_DeliveryPolicyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy(generators)
	endpointProperties_DeliveryPolicyGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_DeliveryPolicy{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy(generators)
	AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy(generators)
	endpointProperties_DeliveryPolicyGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_DeliveryPolicy{}), generators)

	return endpointProperties_DeliveryPolicyGenerator
}

// AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(DeliveryRuleGenerator())
}

func Test_EndpointProperties_DeliveryPolicy_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EndpointProperties_DeliveryPolicy_STATUS to EndpointProperties_DeliveryPolicy_STATUS via AssignPropertiesToEndpointProperties_DeliveryPolicy_STATUS & AssignPropertiesFromEndpointProperties_DeliveryPolicy_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEndpointProperties_DeliveryPolicy_STATUS, EndpointProperties_DeliveryPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEndpointProperties_DeliveryPolicy_STATUS tests if a specific instance of EndpointProperties_DeliveryPolicy_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForEndpointProperties_DeliveryPolicy_STATUS(subject EndpointProperties_DeliveryPolicy_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.EndpointProperties_DeliveryPolicy_STATUS
	err := copied.AssignPropertiesToEndpointProperties_DeliveryPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EndpointProperties_DeliveryPolicy_STATUS
	err = actual.AssignPropertiesFromEndpointProperties_DeliveryPolicy_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EndpointProperties_DeliveryPolicy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointProperties_DeliveryPolicy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointProperties_DeliveryPolicy_STATUS, EndpointProperties_DeliveryPolicy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointProperties_DeliveryPolicy_STATUS runs a test to see if a specific instance of EndpointProperties_DeliveryPolicy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointProperties_DeliveryPolicy_STATUS(subject EndpointProperties_DeliveryPolicy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointProperties_DeliveryPolicy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointProperties_DeliveryPolicy_STATUS instances for property testing - lazily instantiated by
// EndpointProperties_DeliveryPolicy_STATUSGenerator()
var endpointProperties_DeliveryPolicy_STATUSGenerator gopter.Gen

// EndpointProperties_DeliveryPolicy_STATUSGenerator returns a generator of EndpointProperties_DeliveryPolicy_STATUS instances for property testing.
// We first initialize endpointProperties_DeliveryPolicy_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EndpointProperties_DeliveryPolicy_STATUSGenerator() gopter.Gen {
	if endpointProperties_DeliveryPolicy_STATUSGenerator != nil {
		return endpointProperties_DeliveryPolicy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy_STATUS(generators)
	endpointProperties_DeliveryPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_DeliveryPolicy_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy_STATUS(generators)
	AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy_STATUS(generators)
	endpointProperties_DeliveryPolicy_STATUSGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_DeliveryPolicy_STATUS{}), generators)

	return endpointProperties_DeliveryPolicy_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy_STATUS(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(DeliveryRule_STATUSGenerator())
}

func Test_EndpointProperties_WebApplicationFirewallPolicyLink_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EndpointProperties_WebApplicationFirewallPolicyLink to EndpointProperties_WebApplicationFirewallPolicyLink via AssignPropertiesToEndpointProperties_WebApplicationFirewallPolicyLink & AssignPropertiesFromEndpointProperties_WebApplicationFirewallPolicyLink returns original",
		prop.ForAll(RunPropertyAssignmentTestForEndpointProperties_WebApplicationFirewallPolicyLink, EndpointProperties_WebApplicationFirewallPolicyLinkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEndpointProperties_WebApplicationFirewallPolicyLink tests if a specific instance of EndpointProperties_WebApplicationFirewallPolicyLink can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForEndpointProperties_WebApplicationFirewallPolicyLink(subject EndpointProperties_WebApplicationFirewallPolicyLink) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink
	err := copied.AssignPropertiesToEndpointProperties_WebApplicationFirewallPolicyLink(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EndpointProperties_WebApplicationFirewallPolicyLink
	err = actual.AssignPropertiesFromEndpointProperties_WebApplicationFirewallPolicyLink(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EndpointProperties_WebApplicationFirewallPolicyLink_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointProperties_WebApplicationFirewallPolicyLink via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink, EndpointProperties_WebApplicationFirewallPolicyLinkGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink runs a test to see if a specific instance of EndpointProperties_WebApplicationFirewallPolicyLink round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink(subject EndpointProperties_WebApplicationFirewallPolicyLink) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointProperties_WebApplicationFirewallPolicyLink
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointProperties_WebApplicationFirewallPolicyLink instances for property testing - lazily instantiated
// by EndpointProperties_WebApplicationFirewallPolicyLinkGenerator()
var endpointProperties_WebApplicationFirewallPolicyLinkGenerator gopter.Gen

// EndpointProperties_WebApplicationFirewallPolicyLinkGenerator returns a generator of EndpointProperties_WebApplicationFirewallPolicyLink instances for property testing.
func EndpointProperties_WebApplicationFirewallPolicyLinkGenerator() gopter.Gen {
	if endpointProperties_WebApplicationFirewallPolicyLinkGenerator != nil {
		return endpointProperties_WebApplicationFirewallPolicyLinkGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_WebApplicationFirewallPolicyLink(generators)
	endpointProperties_WebApplicationFirewallPolicyLinkGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_WebApplicationFirewallPolicyLink{}), generators)

	return endpointProperties_WebApplicationFirewallPolicyLinkGenerator
}

// AddIndependentPropertyGeneratorsForEndpointProperties_WebApplicationFirewallPolicyLink is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointProperties_WebApplicationFirewallPolicyLink(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from EndpointProperties_WebApplicationFirewallPolicyLink_STATUS to EndpointProperties_WebApplicationFirewallPolicyLink_STATUS via AssignPropertiesToEndpointProperties_WebApplicationFirewallPolicyLink_STATUS & AssignPropertiesFromEndpointProperties_WebApplicationFirewallPolicyLink_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS, EndpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS tests if a specific instance of EndpointProperties_WebApplicationFirewallPolicyLink_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS(subject EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
	err := copied.AssignPropertiesToEndpointProperties_WebApplicationFirewallPolicyLink_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
	err = actual.AssignPropertiesFromEndpointProperties_WebApplicationFirewallPolicyLink_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_EndpointProperties_WebApplicationFirewallPolicyLink_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointProperties_WebApplicationFirewallPolicyLink_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS, EndpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS runs a test to see if a specific instance of EndpointProperties_WebApplicationFirewallPolicyLink_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS(subject EndpointProperties_WebApplicationFirewallPolicyLink_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointProperties_WebApplicationFirewallPolicyLink_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointProperties_WebApplicationFirewallPolicyLink_STATUS instances for property testing - lazily
// instantiated by EndpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator()
var endpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator gopter.Gen

// EndpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator returns a generator of EndpointProperties_WebApplicationFirewallPolicyLink_STATUS instances for property testing.
func EndpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator() gopter.Gen {
	if endpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator != nil {
		return endpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS(generators)
	endpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_WebApplicationFirewallPolicyLink_STATUS{}), generators)

	return endpointProperties_WebApplicationFirewallPolicyLink_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointProperties_WebApplicationFirewallPolicyLink_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_GeoFilter_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GeoFilter to GeoFilter via AssignPropertiesToGeoFilter & AssignPropertiesFromGeoFilter returns original",
		prop.ForAll(RunPropertyAssignmentTestForGeoFilter, GeoFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGeoFilter tests if a specific instance of GeoFilter can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForGeoFilter(subject GeoFilter) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.GeoFilter
	err := copied.AssignPropertiesToGeoFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GeoFilter
	err = actual.AssignPropertiesFromGeoFilter(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GeoFilter_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GeoFilter via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGeoFilter, GeoFilterGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGeoFilter runs a test to see if a specific instance of GeoFilter round trips to JSON and back losslessly
func RunJSONSerializationTestForGeoFilter(subject GeoFilter) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GeoFilter
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GeoFilter instances for property testing - lazily instantiated by GeoFilterGenerator()
var geoFilterGenerator gopter.Gen

// GeoFilterGenerator returns a generator of GeoFilter instances for property testing.
func GeoFilterGenerator() gopter.Gen {
	if geoFilterGenerator != nil {
		return geoFilterGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGeoFilter(generators)
	geoFilterGenerator = gen.Struct(reflect.TypeOf(GeoFilter{}), generators)

	return geoFilterGenerator
}

// AddIndependentPropertyGeneratorsForGeoFilter is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGeoFilter(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(GeoFilter_Action_Allow, GeoFilter_Action_Block))
	gens["CountryCodes"] = gen.SliceOf(gen.AlphaString())
	gens["RelativePath"] = gen.PtrOf(gen.AlphaString())
}

func Test_GeoFilter_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from GeoFilter_STATUS to GeoFilter_STATUS via AssignPropertiesToGeoFilter_STATUS & AssignPropertiesFromGeoFilter_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForGeoFilter_STATUS, GeoFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForGeoFilter_STATUS tests if a specific instance of GeoFilter_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForGeoFilter_STATUS(subject GeoFilter_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.GeoFilter_STATUS
	err := copied.AssignPropertiesToGeoFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual GeoFilter_STATUS
	err = actual.AssignPropertiesFromGeoFilter_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_GeoFilter_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GeoFilter_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGeoFilter_STATUS, GeoFilter_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGeoFilter_STATUS runs a test to see if a specific instance of GeoFilter_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForGeoFilter_STATUS(subject GeoFilter_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GeoFilter_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GeoFilter_STATUS instances for property testing - lazily instantiated by GeoFilter_STATUSGenerator()
var geoFilter_STATUSGenerator gopter.Gen

// GeoFilter_STATUSGenerator returns a generator of GeoFilter_STATUS instances for property testing.
func GeoFilter_STATUSGenerator() gopter.Gen {
	if geoFilter_STATUSGenerator != nil {
		return geoFilter_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGeoFilter_STATUS(generators)
	geoFilter_STATUSGenerator = gen.Struct(reflect.TypeOf(GeoFilter_STATUS{}), generators)

	return geoFilter_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForGeoFilter_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGeoFilter_STATUS(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(GeoFilter_Action_Allow_STATUS, GeoFilter_Action_Block_STATUS))
	gens["CountryCodes"] = gen.SliceOf(gen.AlphaString())
	gens["RelativePath"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResourceReference_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceReference to ResourceReference via AssignPropertiesToResourceReference & AssignPropertiesFromResourceReference returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceReference, ResourceReferenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceReference tests if a specific instance of ResourceReference can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForResourceReference(subject ResourceReference) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ResourceReference
	err := copied.AssignPropertiesToResourceReference(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceReference
	err = actual.AssignPropertiesFromResourceReference(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceReference_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceReference via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceReference, ResourceReferenceGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceReference runs a test to see if a specific instance of ResourceReference round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceReference(subject ResourceReference) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceReference
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceReference instances for property testing - lazily instantiated by ResourceReferenceGenerator()
var resourceReferenceGenerator gopter.Gen

// ResourceReferenceGenerator returns a generator of ResourceReference instances for property testing.
func ResourceReferenceGenerator() gopter.Gen {
	if resourceReferenceGenerator != nil {
		return resourceReferenceGenerator
	}

	generators := make(map[string]gopter.Gen)
	resourceReferenceGenerator = gen.Struct(reflect.TypeOf(ResourceReference{}), generators)

	return resourceReferenceGenerator
}

func Test_ResourceReference_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResourceReference_STATUS to ResourceReference_STATUS via AssignPropertiesToResourceReference_STATUS & AssignPropertiesFromResourceReference_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForResourceReference_STATUS, ResourceReference_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResourceReference_STATUS tests if a specific instance of ResourceReference_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForResourceReference_STATUS(subject ResourceReference_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ResourceReference_STATUS
	err := copied.AssignPropertiesToResourceReference_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResourceReference_STATUS
	err = actual.AssignPropertiesFromResourceReference_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResourceReference_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceReference_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceReference_STATUS, ResourceReference_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceReference_STATUS runs a test to see if a specific instance of ResourceReference_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceReference_STATUS(subject ResourceReference_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceReference_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceReference_STATUS instances for property testing - lazily instantiated by
// ResourceReference_STATUSGenerator()
var resourceReference_STATUSGenerator gopter.Gen

// ResourceReference_STATUSGenerator returns a generator of ResourceReference_STATUS instances for property testing.
func ResourceReference_STATUSGenerator() gopter.Gen {
	if resourceReference_STATUSGenerator != nil {
		return resourceReference_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceReference_STATUS(generators)
	resourceReference_STATUSGenerator = gen.Struct(reflect.TypeOf(ResourceReference_STATUS{}), generators)

	return resourceReference_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForResourceReference_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceReference_STATUS(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_UrlSigningKey_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningKey to UrlSigningKey via AssignPropertiesToUrlSigningKey & AssignPropertiesFromUrlSigningKey returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningKey, UrlSigningKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningKey tests if a specific instance of UrlSigningKey can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningKey(subject UrlSigningKey) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningKey
	err := copied.AssignPropertiesToUrlSigningKey(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningKey
	err = actual.AssignPropertiesFromUrlSigningKey(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningKey_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningKey via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningKey, UrlSigningKeyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningKey runs a test to see if a specific instance of UrlSigningKey round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningKey(subject UrlSigningKey) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningKey
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningKey instances for property testing - lazily instantiated by UrlSigningKeyGenerator()
var urlSigningKeyGenerator gopter.Gen

// UrlSigningKeyGenerator returns a generator of UrlSigningKey instances for property testing.
// We first initialize urlSigningKeyGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningKeyGenerator() gopter.Gen {
	if urlSigningKeyGenerator != nil {
		return urlSigningKeyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKey(generators)
	urlSigningKeyGenerator = gen.Struct(reflect.TypeOf(UrlSigningKey{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKey(generators)
	AddRelatedPropertyGeneratorsForUrlSigningKey(generators)
	urlSigningKeyGenerator = gen.Struct(reflect.TypeOf(UrlSigningKey{}), generators)

	return urlSigningKeyGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningKey is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningKey(gens map[string]gopter.Gen) {
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUrlSigningKey is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningKey(gens map[string]gopter.Gen) {
	gens["KeySourceParameters"] = gen.PtrOf(KeyVaultSigningKeyParametersGenerator())
}

func Test_UrlSigningKey_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from UrlSigningKey_STATUS to UrlSigningKey_STATUS via AssignPropertiesToUrlSigningKey_STATUS & AssignPropertiesFromUrlSigningKey_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForUrlSigningKey_STATUS, UrlSigningKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForUrlSigningKey_STATUS tests if a specific instance of UrlSigningKey_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForUrlSigningKey_STATUS(subject UrlSigningKey_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.UrlSigningKey_STATUS
	err := copied.AssignPropertiesToUrlSigningKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual UrlSigningKey_STATUS
	err = actual.AssignPropertiesFromUrlSigningKey_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_UrlSigningKey_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningKey_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningKey_STATUS, UrlSigningKey_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningKey_STATUS runs a test to see if a specific instance of UrlSigningKey_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningKey_STATUS(subject UrlSigningKey_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningKey_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningKey_STATUS instances for property testing - lazily instantiated by
// UrlSigningKey_STATUSGenerator()
var urlSigningKey_STATUSGenerator gopter.Gen

// UrlSigningKey_STATUSGenerator returns a generator of UrlSigningKey_STATUS instances for property testing.
// We first initialize urlSigningKey_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningKey_STATUSGenerator() gopter.Gen {
	if urlSigningKey_STATUSGenerator != nil {
		return urlSigningKey_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKey_STATUS(generators)
	urlSigningKey_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlSigningKey_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKey_STATUS(generators)
	AddRelatedPropertyGeneratorsForUrlSigningKey_STATUS(generators)
	urlSigningKey_STATUSGenerator = gen.Struct(reflect.TypeOf(UrlSigningKey_STATUS{}), generators)

	return urlSigningKey_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningKey_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningKey_STATUS(gens map[string]gopter.Gen) {
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUrlSigningKey_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningKey_STATUS(gens map[string]gopter.Gen) {
	gens["KeySourceParameters"] = gen.PtrOf(KeyVaultSigningKeyParameters_STATUSGenerator())
}

func Test_CustomDomainHttpsParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomDomainHttpsParameters to CustomDomainHttpsParameters via AssignPropertiesToCustomDomainHttpsParameters & AssignPropertiesFromCustomDomainHttpsParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomDomainHttpsParameters, CustomDomainHttpsParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomDomainHttpsParameters tests if a specific instance of CustomDomainHttpsParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCustomDomainHttpsParameters(subject CustomDomainHttpsParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CustomDomainHttpsParameters
	err := copied.AssignPropertiesToCustomDomainHttpsParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomDomainHttpsParameters
	err = actual.AssignPropertiesFromCustomDomainHttpsParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomDomainHttpsParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomainHttpsParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomainHttpsParameters, CustomDomainHttpsParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomainHttpsParameters runs a test to see if a specific instance of CustomDomainHttpsParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomainHttpsParameters(subject CustomDomainHttpsParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomainHttpsParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomainHttpsParameters instances for property testing - lazily instantiated by
// CustomDomainHttpsParametersGenerator()
var customDomainHttpsParametersGenerator gopter.Gen

// CustomDomainHttpsParametersGenerator returns a generator of CustomDomainHttpsParameters instances for property testing.
func CustomDomainHttpsParametersGenerator() gopter.Gen {
	if customDomainHttpsParametersGenerator != nil {
		return customDomainHttpsParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainHttpsParameters(generators)
	customDomainHttpsParametersGenerator = gen.Struct(reflect.TypeOf(CustomDomainHttpsParameters{}), generators)

	return customDomainHttpsParametersGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomainHttpsParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomainHttpsParameters(gens map[string]gopter.Gen) {
	gens["CertificateSource"] = gen.PtrOf(gen.OneConstOf(CustomDomainHttpsParameters_CertificateSource_AzureKeyVault, CustomDomainHttpsParameters_CertificateSource_Cdn))
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.OneConstOf(CustomDomainHttpsParameters_MinimumTlsVersion_None, CustomDomainHttpsParameters_MinimumTlsVersion_TLS10, CustomDomainHttpsParameters_MinimumTlsVersion_TLS12))
	gens["ProtocolType"] = gen.PtrOf(gen.OneConstOf(CustomDomainHttpsParameters_ProtocolType_IPBased, CustomDomainHttpsParameters_ProtocolType_ServerNameIndication))
}

func Test_CustomDomainHttpsParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from CustomDomainHttpsParameters_STATUS to CustomDomainHttpsParameters_STATUS via AssignPropertiesToCustomDomainHttpsParameters_STATUS & AssignPropertiesFromCustomDomainHttpsParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForCustomDomainHttpsParameters_STATUS, CustomDomainHttpsParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForCustomDomainHttpsParameters_STATUS tests if a specific instance of CustomDomainHttpsParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForCustomDomainHttpsParameters_STATUS(subject CustomDomainHttpsParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.CustomDomainHttpsParameters_STATUS
	err := copied.AssignPropertiesToCustomDomainHttpsParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual CustomDomainHttpsParameters_STATUS
	err = actual.AssignPropertiesFromCustomDomainHttpsParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_CustomDomainHttpsParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CustomDomainHttpsParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCustomDomainHttpsParameters_STATUS, CustomDomainHttpsParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCustomDomainHttpsParameters_STATUS runs a test to see if a specific instance of CustomDomainHttpsParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForCustomDomainHttpsParameters_STATUS(subject CustomDomainHttpsParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CustomDomainHttpsParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CustomDomainHttpsParameters_STATUS instances for property testing - lazily instantiated by
// CustomDomainHttpsParameters_STATUSGenerator()
var customDomainHttpsParameters_STATUSGenerator gopter.Gen

// CustomDomainHttpsParameters_STATUSGenerator returns a generator of CustomDomainHttpsParameters_STATUS instances for property testing.
func CustomDomainHttpsParameters_STATUSGenerator() gopter.Gen {
	if customDomainHttpsParameters_STATUSGenerator != nil {
		return customDomainHttpsParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCustomDomainHttpsParameters_STATUS(generators)
	customDomainHttpsParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(CustomDomainHttpsParameters_STATUS{}), generators)

	return customDomainHttpsParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForCustomDomainHttpsParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCustomDomainHttpsParameters_STATUS(gens map[string]gopter.Gen) {
	gens["CertificateSource"] = gen.PtrOf(gen.OneConstOf(CustomDomainHttpsParameters_CertificateSource_AzureKeyVault_STATUS, CustomDomainHttpsParameters_CertificateSource_Cdn_STATUS))
	gens["MinimumTlsVersion"] = gen.PtrOf(gen.OneConstOf(CustomDomainHttpsParameters_MinimumTlsVersion_None_STATUS, CustomDomainHttpsParameters_MinimumTlsVersion_TLS10_STATUS, CustomDomainHttpsParameters_MinimumTlsVersion_TLS12_STATUS))
	gens["ProtocolType"] = gen.PtrOf(gen.OneConstOf(CustomDomainHttpsParameters_ProtocolType_IPBased_STATUS, CustomDomainHttpsParameters_ProtocolType_ServerNameIndication_STATUS))
}

func Test_DeliveryRule_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRule to DeliveryRule via AssignPropertiesToDeliveryRule & AssignPropertiesFromDeliveryRule returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRule, DeliveryRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRule tests if a specific instance of DeliveryRule can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRule(subject DeliveryRule) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRule
	err := copied.AssignPropertiesToDeliveryRule(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRule
	err = actual.AssignPropertiesFromDeliveryRule(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRule_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRule via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRule, DeliveryRuleGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRule runs a test to see if a specific instance of DeliveryRule round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRule(subject DeliveryRule) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRule
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRule instances for property testing - lazily instantiated by DeliveryRuleGenerator()
var deliveryRuleGenerator gopter.Gen

// DeliveryRuleGenerator returns a generator of DeliveryRule instances for property testing.
// We first initialize deliveryRuleGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleGenerator() gopter.Gen {
	if deliveryRuleGenerator != nil {
		return deliveryRuleGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRule(generators)
	deliveryRuleGenerator = gen.Struct(reflect.TypeOf(DeliveryRule{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRule(generators)
	AddRelatedPropertyGeneratorsForDeliveryRule(generators)
	deliveryRuleGenerator = gen.Struct(reflect.TypeOf(DeliveryRule{}), generators)

	return deliveryRuleGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRule is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRule(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Order"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeliveryRule is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRule(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.SliceOf(DeliveryRuleActionGenerator())
	gens["Conditions"] = gen.SliceOf(DeliveryRuleConditionGenerator())
}

func Test_DeliveryRule_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRule_STATUS to DeliveryRule_STATUS via AssignPropertiesToDeliveryRule_STATUS & AssignPropertiesFromDeliveryRule_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRule_STATUS, DeliveryRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRule_STATUS tests if a specific instance of DeliveryRule_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRule_STATUS(subject DeliveryRule_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRule_STATUS
	err := copied.AssignPropertiesToDeliveryRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRule_STATUS
	err = actual.AssignPropertiesFromDeliveryRule_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRule_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRule_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRule_STATUS, DeliveryRule_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRule_STATUS runs a test to see if a specific instance of DeliveryRule_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRule_STATUS(subject DeliveryRule_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRule_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRule_STATUS instances for property testing - lazily instantiated by
// DeliveryRule_STATUSGenerator()
var deliveryRule_STATUSGenerator gopter.Gen

// DeliveryRule_STATUSGenerator returns a generator of DeliveryRule_STATUS instances for property testing.
// We first initialize deliveryRule_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRule_STATUSGenerator() gopter.Gen {
	if deliveryRule_STATUSGenerator != nil {
		return deliveryRule_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRule_STATUS(generators)
	deliveryRule_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRule_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRule_STATUS(generators)
	AddRelatedPropertyGeneratorsForDeliveryRule_STATUS(generators)
	deliveryRule_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRule_STATUS{}), generators)

	return deliveryRule_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRule_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRule_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Order"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeliveryRule_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRule_STATUS(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.SliceOf(DeliveryRuleAction_STATUSGenerator())
	gens["Conditions"] = gen.SliceOf(DeliveryRuleCondition_STATUSGenerator())
}

func Test_HealthProbeParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HealthProbeParameters to HealthProbeParameters via AssignPropertiesToHealthProbeParameters & AssignPropertiesFromHealthProbeParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForHealthProbeParameters, HealthProbeParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHealthProbeParameters tests if a specific instance of HealthProbeParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHealthProbeParameters(subject HealthProbeParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HealthProbeParameters
	err := copied.AssignPropertiesToHealthProbeParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HealthProbeParameters
	err = actual.AssignPropertiesFromHealthProbeParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HealthProbeParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeParameters, HealthProbeParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeParameters runs a test to see if a specific instance of HealthProbeParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeParameters(subject HealthProbeParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeParameters instances for property testing - lazily instantiated by
// HealthProbeParametersGenerator()
var healthProbeParametersGenerator gopter.Gen

// HealthProbeParametersGenerator returns a generator of HealthProbeParameters instances for property testing.
func HealthProbeParametersGenerator() gopter.Gen {
	if healthProbeParametersGenerator != nil {
		return healthProbeParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeParameters(generators)
	healthProbeParametersGenerator = gen.Struct(reflect.TypeOf(HealthProbeParameters{}), generators)

	return healthProbeParametersGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeParameters(gens map[string]gopter.Gen) {
	gens["ProbeIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbeProtocol"] = gen.PtrOf(gen.OneConstOf(HealthProbeParameters_ProbeProtocol_Http, HealthProbeParameters_ProbeProtocol_Https, HealthProbeParameters_ProbeProtocol_NotSet))
	gens["ProbeRequestType"] = gen.PtrOf(gen.OneConstOf(HealthProbeParameters_ProbeRequestType_GET, HealthProbeParameters_ProbeRequestType_HEAD, HealthProbeParameters_ProbeRequestType_NotSet))
}

func Test_HealthProbeParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HealthProbeParameters_STATUS to HealthProbeParameters_STATUS via AssignPropertiesToHealthProbeParameters_STATUS & AssignPropertiesFromHealthProbeParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHealthProbeParameters_STATUS, HealthProbeParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHealthProbeParameters_STATUS tests if a specific instance of HealthProbeParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHealthProbeParameters_STATUS(subject HealthProbeParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HealthProbeParameters_STATUS
	err := copied.AssignPropertiesToHealthProbeParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HealthProbeParameters_STATUS
	err = actual.AssignPropertiesFromHealthProbeParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HealthProbeParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeParameters_STATUS, HealthProbeParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeParameters_STATUS runs a test to see if a specific instance of HealthProbeParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeParameters_STATUS(subject HealthProbeParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeParameters_STATUS instances for property testing - lazily instantiated by
// HealthProbeParameters_STATUSGenerator()
var healthProbeParameters_STATUSGenerator gopter.Gen

// HealthProbeParameters_STATUSGenerator returns a generator of HealthProbeParameters_STATUS instances for property testing.
func HealthProbeParameters_STATUSGenerator() gopter.Gen {
	if healthProbeParameters_STATUSGenerator != nil {
		return healthProbeParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeParameters_STATUS(generators)
	healthProbeParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(HealthProbeParameters_STATUS{}), generators)

	return healthProbeParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeParameters_STATUS(gens map[string]gopter.Gen) {
	gens["ProbeIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbeProtocol"] = gen.PtrOf(gen.OneConstOf(HealthProbeParameters_ProbeProtocol_Http_STATUS, HealthProbeParameters_ProbeProtocol_Https_STATUS, HealthProbeParameters_ProbeProtocol_NotSet_STATUS))
	gens["ProbeRequestType"] = gen.PtrOf(gen.OneConstOf(HealthProbeParameters_ProbeRequestType_GET_STATUS, HealthProbeParameters_ProbeRequestType_HEAD_STATUS, HealthProbeParameters_ProbeRequestType_NotSet_STATUS))
}

func Test_KeyVaultSigningKeyParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultSigningKeyParameters to KeyVaultSigningKeyParameters via AssignPropertiesToKeyVaultSigningKeyParameters & AssignPropertiesFromKeyVaultSigningKeyParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultSigningKeyParameters, KeyVaultSigningKeyParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultSigningKeyParameters tests if a specific instance of KeyVaultSigningKeyParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultSigningKeyParameters(subject KeyVaultSigningKeyParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.KeyVaultSigningKeyParameters
	err := copied.AssignPropertiesToKeyVaultSigningKeyParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultSigningKeyParameters
	err = actual.AssignPropertiesFromKeyVaultSigningKeyParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultSigningKeyParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSigningKeyParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSigningKeyParameters, KeyVaultSigningKeyParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSigningKeyParameters runs a test to see if a specific instance of KeyVaultSigningKeyParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSigningKeyParameters(subject KeyVaultSigningKeyParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSigningKeyParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSigningKeyParameters instances for property testing - lazily instantiated by
// KeyVaultSigningKeyParametersGenerator()
var keyVaultSigningKeyParametersGenerator gopter.Gen

// KeyVaultSigningKeyParametersGenerator returns a generator of KeyVaultSigningKeyParameters instances for property testing.
func KeyVaultSigningKeyParametersGenerator() gopter.Gen {
	if keyVaultSigningKeyParametersGenerator != nil {
		return keyVaultSigningKeyParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters(generators)
	keyVaultSigningKeyParametersGenerator = gen.Struct(reflect.TypeOf(KeyVaultSigningKeyParameters{}), generators)

	return keyVaultSigningKeyParametersGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters(gens map[string]gopter.Gen) {
	gens["ResourceGroupName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(KeyVaultSigningKeyParameters_TypeName_KeyVaultSigningKeyParameters))
	gens["VaultName"] = gen.PtrOf(gen.AlphaString())
}

func Test_KeyVaultSigningKeyParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from KeyVaultSigningKeyParameters_STATUS to KeyVaultSigningKeyParameters_STATUS via AssignPropertiesToKeyVaultSigningKeyParameters_STATUS & AssignPropertiesFromKeyVaultSigningKeyParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForKeyVaultSigningKeyParameters_STATUS, KeyVaultSigningKeyParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForKeyVaultSigningKeyParameters_STATUS tests if a specific instance of KeyVaultSigningKeyParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForKeyVaultSigningKeyParameters_STATUS(subject KeyVaultSigningKeyParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.KeyVaultSigningKeyParameters_STATUS
	err := copied.AssignPropertiesToKeyVaultSigningKeyParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual KeyVaultSigningKeyParameters_STATUS
	err = actual.AssignPropertiesFromKeyVaultSigningKeyParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_KeyVaultSigningKeyParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSigningKeyParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSigningKeyParameters_STATUS, KeyVaultSigningKeyParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSigningKeyParameters_STATUS runs a test to see if a specific instance of KeyVaultSigningKeyParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSigningKeyParameters_STATUS(subject KeyVaultSigningKeyParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSigningKeyParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSigningKeyParameters_STATUS instances for property testing - lazily instantiated by
// KeyVaultSigningKeyParameters_STATUSGenerator()
var keyVaultSigningKeyParameters_STATUSGenerator gopter.Gen

// KeyVaultSigningKeyParameters_STATUSGenerator returns a generator of KeyVaultSigningKeyParameters_STATUS instances for property testing.
func KeyVaultSigningKeyParameters_STATUSGenerator() gopter.Gen {
	if keyVaultSigningKeyParameters_STATUSGenerator != nil {
		return keyVaultSigningKeyParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters_STATUS(generators)
	keyVaultSigningKeyParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(KeyVaultSigningKeyParameters_STATUS{}), generators)

	return keyVaultSigningKeyParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters_STATUS(gens map[string]gopter.Gen) {
	gens["ResourceGroupName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(KeyVaultSigningKeyParameters_TypeName_KeyVaultSigningKeyParameters_STATUS))
	gens["VaultName"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResponseBasedOriginErrorDetectionParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResponseBasedOriginErrorDetectionParameters to ResponseBasedOriginErrorDetectionParameters via AssignPropertiesToResponseBasedOriginErrorDetectionParameters & AssignPropertiesFromResponseBasedOriginErrorDetectionParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters, ResponseBasedOriginErrorDetectionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters tests if a specific instance of ResponseBasedOriginErrorDetectionParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters(subject ResponseBasedOriginErrorDetectionParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ResponseBasedOriginErrorDetectionParameters
	err := copied.AssignPropertiesToResponseBasedOriginErrorDetectionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResponseBasedOriginErrorDetectionParameters
	err = actual.AssignPropertiesFromResponseBasedOriginErrorDetectionParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResponseBasedOriginErrorDetectionParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResponseBasedOriginErrorDetectionParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters, ResponseBasedOriginErrorDetectionParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters runs a test to see if a specific instance of ResponseBasedOriginErrorDetectionParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters(subject ResponseBasedOriginErrorDetectionParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResponseBasedOriginErrorDetectionParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResponseBasedOriginErrorDetectionParameters instances for property testing - lazily instantiated by
// ResponseBasedOriginErrorDetectionParametersGenerator()
var responseBasedOriginErrorDetectionParametersGenerator gopter.Gen

// ResponseBasedOriginErrorDetectionParametersGenerator returns a generator of ResponseBasedOriginErrorDetectionParameters instances for property testing.
// We first initialize responseBasedOriginErrorDetectionParametersGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResponseBasedOriginErrorDetectionParametersGenerator() gopter.Gen {
	if responseBasedOriginErrorDetectionParametersGenerator != nil {
		return responseBasedOriginErrorDetectionParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(generators)
	responseBasedOriginErrorDetectionParametersGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParameters{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(generators)
	AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(generators)
	responseBasedOriginErrorDetectionParametersGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParameters{}), generators)

	return responseBasedOriginErrorDetectionParametersGenerator
}

// AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(gens map[string]gopter.Gen) {
	gens["ResponseBasedDetectedErrorTypes"] = gen.PtrOf(gen.OneConstOf(ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_None, ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_TcpAndHttpErrors, ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_TcpErrorsOnly))
	gens["ResponseBasedFailoverThresholdPercentage"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters(gens map[string]gopter.Gen) {
	gens["HttpErrorRanges"] = gen.SliceOf(HttpErrorRangeParametersGenerator())
}

func Test_ResponseBasedOriginErrorDetectionParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from ResponseBasedOriginErrorDetectionParameters_STATUS to ResponseBasedOriginErrorDetectionParameters_STATUS via AssignPropertiesToResponseBasedOriginErrorDetectionParameters_STATUS & AssignPropertiesFromResponseBasedOriginErrorDetectionParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters_STATUS, ResponseBasedOriginErrorDetectionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters_STATUS tests if a specific instance of ResponseBasedOriginErrorDetectionParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForResponseBasedOriginErrorDetectionParameters_STATUS(subject ResponseBasedOriginErrorDetectionParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.ResponseBasedOriginErrorDetectionParameters_STATUS
	err := copied.AssignPropertiesToResponseBasedOriginErrorDetectionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual ResponseBasedOriginErrorDetectionParameters_STATUS
	err = actual.AssignPropertiesFromResponseBasedOriginErrorDetectionParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_ResponseBasedOriginErrorDetectionParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResponseBasedOriginErrorDetectionParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters_STATUS, ResponseBasedOriginErrorDetectionParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters_STATUS runs a test to see if a specific instance of ResponseBasedOriginErrorDetectionParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters_STATUS(subject ResponseBasedOriginErrorDetectionParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResponseBasedOriginErrorDetectionParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResponseBasedOriginErrorDetectionParameters_STATUS instances for property testing - lazily instantiated
// by ResponseBasedOriginErrorDetectionParameters_STATUSGenerator()
var responseBasedOriginErrorDetectionParameters_STATUSGenerator gopter.Gen

// ResponseBasedOriginErrorDetectionParameters_STATUSGenerator returns a generator of ResponseBasedOriginErrorDetectionParameters_STATUS instances for property testing.
// We first initialize responseBasedOriginErrorDetectionParameters_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResponseBasedOriginErrorDetectionParameters_STATUSGenerator() gopter.Gen {
	if responseBasedOriginErrorDetectionParameters_STATUSGenerator != nil {
		return responseBasedOriginErrorDetectionParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_STATUS(generators)
	responseBasedOriginErrorDetectionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParameters_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_STATUS(generators)
	AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_STATUS(generators)
	responseBasedOriginErrorDetectionParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParameters_STATUS{}), generators)

	return responseBasedOriginErrorDetectionParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["ResponseBasedDetectedErrorTypes"] = gen.PtrOf(gen.OneConstOf(ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_None_STATUS, ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_TcpAndHttpErrors_STATUS, ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_TcpErrorsOnly_STATUS))
	gens["ResponseBasedFailoverThresholdPercentage"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_STATUS(gens map[string]gopter.Gen) {
	gens["HttpErrorRanges"] = gen.SliceOf(HttpErrorRangeParameters_STATUSGenerator())
}

func Test_DeliveryRuleAction_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleAction to DeliveryRuleAction via AssignPropertiesToDeliveryRuleAction & AssignPropertiesFromDeliveryRuleAction returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleAction, DeliveryRuleActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleAction tests if a specific instance of DeliveryRuleAction can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleAction(subject DeliveryRuleAction) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleAction
	err := copied.AssignPropertiesToDeliveryRuleAction(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleAction
	err = actual.AssignPropertiesFromDeliveryRuleAction(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleAction_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleAction via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleAction, DeliveryRuleActionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleAction runs a test to see if a specific instance of DeliveryRuleAction round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleAction(subject DeliveryRuleAction) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleAction
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleAction instances for property testing - lazily instantiated by DeliveryRuleActionGenerator()
var deliveryRuleActionGenerator gopter.Gen

// DeliveryRuleActionGenerator returns a generator of DeliveryRuleAction instances for property testing.
func DeliveryRuleActionGenerator() gopter.Gen {
	if deliveryRuleActionGenerator != nil {
		return deliveryRuleActionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleAction(generators)
	deliveryRuleActionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleAction{}), generators)

	return deliveryRuleActionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleAction is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleAction(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DeliveryRuleAction_Name_CacheExpiration,
		DeliveryRuleAction_Name_CacheKeyQueryString,
		DeliveryRuleAction_Name_ModifyRequestHeader,
		DeliveryRuleAction_Name_ModifyResponseHeader,
		DeliveryRuleAction_Name_OriginGroupOverride,
		DeliveryRuleAction_Name_RouteConfigurationOverride,
		DeliveryRuleAction_Name_UrlRedirect,
		DeliveryRuleAction_Name_UrlRewrite,
		DeliveryRuleAction_Name_UrlSigning))
}

func Test_DeliveryRuleAction_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleAction_STATUS to DeliveryRuleAction_STATUS via AssignPropertiesToDeliveryRuleAction_STATUS & AssignPropertiesFromDeliveryRuleAction_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleAction_STATUS, DeliveryRuleAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleAction_STATUS tests if a specific instance of DeliveryRuleAction_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleAction_STATUS(subject DeliveryRuleAction_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleAction_STATUS
	err := copied.AssignPropertiesToDeliveryRuleAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleAction_STATUS
	err = actual.AssignPropertiesFromDeliveryRuleAction_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleAction_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleAction_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleAction_STATUS, DeliveryRuleAction_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleAction_STATUS runs a test to see if a specific instance of DeliveryRuleAction_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleAction_STATUS(subject DeliveryRuleAction_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleAction_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleAction_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleAction_STATUSGenerator()
var deliveryRuleAction_STATUSGenerator gopter.Gen

// DeliveryRuleAction_STATUSGenerator returns a generator of DeliveryRuleAction_STATUS instances for property testing.
func DeliveryRuleAction_STATUSGenerator() gopter.Gen {
	if deliveryRuleAction_STATUSGenerator != nil {
		return deliveryRuleAction_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleAction_STATUS(generators)
	deliveryRuleAction_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleAction_STATUS{}), generators)

	return deliveryRuleAction_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleAction_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleAction_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DeliveryRuleAction_Name_CacheExpiration_STATUS,
		DeliveryRuleAction_Name_CacheKeyQueryString_STATUS,
		DeliveryRuleAction_Name_ModifyRequestHeader_STATUS,
		DeliveryRuleAction_Name_ModifyResponseHeader_STATUS,
		DeliveryRuleAction_Name_OriginGroupOverride_STATUS,
		DeliveryRuleAction_Name_RouteConfigurationOverride_STATUS,
		DeliveryRuleAction_Name_UrlRedirect_STATUS,
		DeliveryRuleAction_Name_UrlRewrite_STATUS,
		DeliveryRuleAction_Name_UrlSigning_STATUS))
}

func Test_DeliveryRuleCondition_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCondition to DeliveryRuleCondition via AssignPropertiesToDeliveryRuleCondition & AssignPropertiesFromDeliveryRuleCondition returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleCondition, DeliveryRuleConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleCondition tests if a specific instance of DeliveryRuleCondition can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleCondition(subject DeliveryRuleCondition) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCondition
	err := copied.AssignPropertiesToDeliveryRuleCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCondition
	err = actual.AssignPropertiesFromDeliveryRuleCondition(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCondition_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCondition via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCondition, DeliveryRuleConditionGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCondition runs a test to see if a specific instance of DeliveryRuleCondition round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCondition(subject DeliveryRuleCondition) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCondition
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCondition instances for property testing - lazily instantiated by
// DeliveryRuleConditionGenerator()
var deliveryRuleConditionGenerator gopter.Gen

// DeliveryRuleConditionGenerator returns a generator of DeliveryRuleCondition instances for property testing.
func DeliveryRuleConditionGenerator() gopter.Gen {
	if deliveryRuleConditionGenerator != nil {
		return deliveryRuleConditionGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCondition(generators)
	deliveryRuleConditionGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCondition{}), generators)

	return deliveryRuleConditionGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCondition is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCondition(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DeliveryRuleCondition_Name_ClientPort,
		DeliveryRuleCondition_Name_Cookies,
		DeliveryRuleCondition_Name_HostName,
		DeliveryRuleCondition_Name_HttpVersion,
		DeliveryRuleCondition_Name_IsDevice,
		DeliveryRuleCondition_Name_PostArgs,
		DeliveryRuleCondition_Name_QueryString,
		DeliveryRuleCondition_Name_RemoteAddress,
		DeliveryRuleCondition_Name_RequestBody,
		DeliveryRuleCondition_Name_RequestHeader,
		DeliveryRuleCondition_Name_RequestMethod,
		DeliveryRuleCondition_Name_RequestScheme,
		DeliveryRuleCondition_Name_RequestUri,
		DeliveryRuleCondition_Name_ServerPort,
		DeliveryRuleCondition_Name_SocketAddr,
		DeliveryRuleCondition_Name_SslProtocol,
		DeliveryRuleCondition_Name_UrlFileExtension,
		DeliveryRuleCondition_Name_UrlFileName,
		DeliveryRuleCondition_Name_UrlPath))
}

func Test_DeliveryRuleCondition_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from DeliveryRuleCondition_STATUS to DeliveryRuleCondition_STATUS via AssignPropertiesToDeliveryRuleCondition_STATUS & AssignPropertiesFromDeliveryRuleCondition_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForDeliveryRuleCondition_STATUS, DeliveryRuleCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForDeliveryRuleCondition_STATUS tests if a specific instance of DeliveryRuleCondition_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForDeliveryRuleCondition_STATUS(subject DeliveryRuleCondition_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.DeliveryRuleCondition_STATUS
	err := copied.AssignPropertiesToDeliveryRuleCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual DeliveryRuleCondition_STATUS
	err = actual.AssignPropertiesFromDeliveryRuleCondition_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_DeliveryRuleCondition_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCondition_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCondition_STATUS, DeliveryRuleCondition_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCondition_STATUS runs a test to see if a specific instance of DeliveryRuleCondition_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCondition_STATUS(subject DeliveryRuleCondition_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCondition_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCondition_STATUS instances for property testing - lazily instantiated by
// DeliveryRuleCondition_STATUSGenerator()
var deliveryRuleCondition_STATUSGenerator gopter.Gen

// DeliveryRuleCondition_STATUSGenerator returns a generator of DeliveryRuleCondition_STATUS instances for property testing.
func DeliveryRuleCondition_STATUSGenerator() gopter.Gen {
	if deliveryRuleCondition_STATUSGenerator != nil {
		return deliveryRuleCondition_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCondition_STATUS(generators)
	deliveryRuleCondition_STATUSGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCondition_STATUS{}), generators)

	return deliveryRuleCondition_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCondition_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCondition_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(
		DeliveryRuleCondition_Name_ClientPort_STATUS,
		DeliveryRuleCondition_Name_Cookies_STATUS,
		DeliveryRuleCondition_Name_HostName_STATUS,
		DeliveryRuleCondition_Name_HttpVersion_STATUS,
		DeliveryRuleCondition_Name_IsDevice_STATUS,
		DeliveryRuleCondition_Name_PostArgs_STATUS,
		DeliveryRuleCondition_Name_QueryString_STATUS,
		DeliveryRuleCondition_Name_RemoteAddress_STATUS,
		DeliveryRuleCondition_Name_RequestBody_STATUS,
		DeliveryRuleCondition_Name_RequestHeader_STATUS,
		DeliveryRuleCondition_Name_RequestMethod_STATUS,
		DeliveryRuleCondition_Name_RequestScheme_STATUS,
		DeliveryRuleCondition_Name_RequestUri_STATUS,
		DeliveryRuleCondition_Name_ServerPort_STATUS,
		DeliveryRuleCondition_Name_SocketAddr_STATUS,
		DeliveryRuleCondition_Name_SslProtocol_STATUS,
		DeliveryRuleCondition_Name_UrlFileExtension_STATUS,
		DeliveryRuleCondition_Name_UrlFileName_STATUS,
		DeliveryRuleCondition_Name_UrlPath_STATUS))
}

func Test_HttpErrorRangeParameters_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpErrorRangeParameters to HttpErrorRangeParameters via AssignPropertiesToHttpErrorRangeParameters & AssignPropertiesFromHttpErrorRangeParameters returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpErrorRangeParameters, HttpErrorRangeParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpErrorRangeParameters tests if a specific instance of HttpErrorRangeParameters can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHttpErrorRangeParameters(subject HttpErrorRangeParameters) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HttpErrorRangeParameters
	err := copied.AssignPropertiesToHttpErrorRangeParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpErrorRangeParameters
	err = actual.AssignPropertiesFromHttpErrorRangeParameters(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpErrorRangeParameters_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpErrorRangeParameters via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpErrorRangeParameters, HttpErrorRangeParametersGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpErrorRangeParameters runs a test to see if a specific instance of HttpErrorRangeParameters round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpErrorRangeParameters(subject HttpErrorRangeParameters) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpErrorRangeParameters
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpErrorRangeParameters instances for property testing - lazily instantiated by
// HttpErrorRangeParametersGenerator()
var httpErrorRangeParametersGenerator gopter.Gen

// HttpErrorRangeParametersGenerator returns a generator of HttpErrorRangeParameters instances for property testing.
func HttpErrorRangeParametersGenerator() gopter.Gen {
	if httpErrorRangeParametersGenerator != nil {
		return httpErrorRangeParametersGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpErrorRangeParameters(generators)
	httpErrorRangeParametersGenerator = gen.Struct(reflect.TypeOf(HttpErrorRangeParameters{}), generators)

	return httpErrorRangeParametersGenerator
}

// AddIndependentPropertyGeneratorsForHttpErrorRangeParameters is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpErrorRangeParameters(gens map[string]gopter.Gen) {
	gens["Begin"] = gen.PtrOf(gen.Int())
	gens["End"] = gen.PtrOf(gen.Int())
}

func Test_HttpErrorRangeParameters_STATUS_WhenPropertiesConverted_RoundTripsWithoutLoss(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip from HttpErrorRangeParameters_STATUS to HttpErrorRangeParameters_STATUS via AssignPropertiesToHttpErrorRangeParameters_STATUS & AssignPropertiesFromHttpErrorRangeParameters_STATUS returns original",
		prop.ForAll(RunPropertyAssignmentTestForHttpErrorRangeParameters_STATUS, HttpErrorRangeParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(false, 240, os.Stdout))
}

// RunPropertyAssignmentTestForHttpErrorRangeParameters_STATUS tests if a specific instance of HttpErrorRangeParameters_STATUS can be assigned to v1beta20210601storage and back losslessly
func RunPropertyAssignmentTestForHttpErrorRangeParameters_STATUS(subject HttpErrorRangeParameters_STATUS) string {
	// Copy subject to make sure assignment doesn't modify it
	copied := subject.DeepCopy()

	// Use AssignPropertiesTo() for the first stage of conversion
	var other v20210601s.HttpErrorRangeParameters_STATUS
	err := copied.AssignPropertiesToHttpErrorRangeParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Use AssignPropertiesFrom() to convert back to our original type
	var actual HttpErrorRangeParameters_STATUS
	err = actual.AssignPropertiesFromHttpErrorRangeParameters_STATUS(&other)
	if err != nil {
		return err.Error()
	}

	// Check for a match
	match := cmp.Equal(subject, actual)
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

func Test_HttpErrorRangeParameters_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpErrorRangeParameters_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpErrorRangeParameters_STATUS, HttpErrorRangeParameters_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpErrorRangeParameters_STATUS runs a test to see if a specific instance of HttpErrorRangeParameters_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpErrorRangeParameters_STATUS(subject HttpErrorRangeParameters_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpErrorRangeParameters_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpErrorRangeParameters_STATUS instances for property testing - lazily instantiated by
// HttpErrorRangeParameters_STATUSGenerator()
var httpErrorRangeParameters_STATUSGenerator gopter.Gen

// HttpErrorRangeParameters_STATUSGenerator returns a generator of HttpErrorRangeParameters_STATUS instances for property testing.
func HttpErrorRangeParameters_STATUSGenerator() gopter.Gen {
	if httpErrorRangeParameters_STATUSGenerator != nil {
		return httpErrorRangeParameters_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpErrorRangeParameters_STATUS(generators)
	httpErrorRangeParameters_STATUSGenerator = gen.Struct(reflect.TypeOf(HttpErrorRangeParameters_STATUS{}), generators)

	return httpErrorRangeParameters_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForHttpErrorRangeParameters_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpErrorRangeParameters_STATUS(gens map[string]gopter.Gen) {
	gens["Begin"] = gen.PtrOf(gen.Int())
	gens["End"] = gen.PtrOf(gen.Int())
}
