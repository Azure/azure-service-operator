// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210601

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_Profiles_Endpoint_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Profiles_Endpoint_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfiles_Endpoint_SpecARM, Profiles_Endpoint_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfiles_Endpoint_SpecARM runs a test to see if a specific instance of Profiles_Endpoint_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProfiles_Endpoint_SpecARM(subject Profiles_Endpoint_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Profiles_Endpoint_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Profiles_Endpoint_SpecARM instances for property testing - lazily instantiated by
// Profiles_Endpoint_SpecARMGenerator()
var profiles_Endpoint_SpecARMGenerator gopter.Gen

// Profiles_Endpoint_SpecARMGenerator returns a generator of Profiles_Endpoint_SpecARM instances for property testing.
// We first initialize profiles_Endpoint_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Profiles_Endpoint_SpecARMGenerator() gopter.Gen {
	if profiles_Endpoint_SpecARMGenerator != nil {
		return profiles_Endpoint_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfiles_Endpoint_SpecARM(generators)
	profiles_Endpoint_SpecARMGenerator = gen.Struct(reflect.TypeOf(Profiles_Endpoint_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfiles_Endpoint_SpecARM(generators)
	AddRelatedPropertyGeneratorsForProfiles_Endpoint_SpecARM(generators)
	profiles_Endpoint_SpecARMGenerator = gen.Struct(reflect.TypeOf(Profiles_Endpoint_SpecARM{}), generators)

	return profiles_Endpoint_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForProfiles_Endpoint_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfiles_Endpoint_SpecARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProfiles_Endpoint_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfiles_Endpoint_SpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(Profiles_Endpoint_Spec_PropertiesARMGenerator())
}

func Test_Profiles_Endpoint_Spec_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Profiles_Endpoint_Spec_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfiles_Endpoint_Spec_PropertiesARM, Profiles_Endpoint_Spec_PropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfiles_Endpoint_Spec_PropertiesARM runs a test to see if a specific instance of Profiles_Endpoint_Spec_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProfiles_Endpoint_Spec_PropertiesARM(subject Profiles_Endpoint_Spec_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Profiles_Endpoint_Spec_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Profiles_Endpoint_Spec_PropertiesARM instances for property testing - lazily instantiated by
// Profiles_Endpoint_Spec_PropertiesARMGenerator()
var profiles_Endpoint_Spec_PropertiesARMGenerator gopter.Gen

// Profiles_Endpoint_Spec_PropertiesARMGenerator returns a generator of Profiles_Endpoint_Spec_PropertiesARM instances for property testing.
// We first initialize profiles_Endpoint_Spec_PropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Profiles_Endpoint_Spec_PropertiesARMGenerator() gopter.Gen {
	if profiles_Endpoint_Spec_PropertiesARMGenerator != nil {
		return profiles_Endpoint_Spec_PropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_PropertiesARM(generators)
	profiles_Endpoint_Spec_PropertiesARMGenerator = gen.Struct(reflect.TypeOf(Profiles_Endpoint_Spec_PropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_PropertiesARM(generators)
	AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec_PropertiesARM(generators)
	profiles_Endpoint_Spec_PropertiesARMGenerator = gen.Struct(reflect.TypeOf(Profiles_Endpoint_Spec_PropertiesARM{}), generators)

	return profiles_Endpoint_Spec_PropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_PropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_PropertiesARM(gens map[string]gopter.Gen) {
	gens["ContentTypesToCompress"] = gen.SliceOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsHttpAllowed"] = gen.PtrOf(gen.Bool())
	gens["IsHttpsAllowed"] = gen.PtrOf(gen.Bool())
	gens["OptimizationType"] = gen.PtrOf(gen.OneConstOf(
		Profiles_Endpoint_Spec_Properties_OptimizationType_DynamicSiteAcceleration,
		Profiles_Endpoint_Spec_Properties_OptimizationType_GeneralMediaStreaming,
		Profiles_Endpoint_Spec_Properties_OptimizationType_GeneralWebDelivery,
		Profiles_Endpoint_Spec_Properties_OptimizationType_LargeFileDownload,
		Profiles_Endpoint_Spec_Properties_OptimizationType_VideoOnDemandMediaStreaming))
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["OriginPath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		Profiles_Endpoint_Spec_Properties_QueryStringCachingBehavior_BypassCaching,
		Profiles_Endpoint_Spec_Properties_QueryStringCachingBehavior_IgnoreQueryString,
		Profiles_Endpoint_Spec_Properties_QueryStringCachingBehavior_NotSet,
		Profiles_Endpoint_Spec_Properties_QueryStringCachingBehavior_UseQueryString))
}

// AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec_PropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec_PropertiesARM(gens map[string]gopter.Gen) {
	gens["DefaultOriginGroup"] = gen.PtrOf(ResourceReferenceARMGenerator())
	gens["DeliveryPolicy"] = gen.PtrOf(EndpointPropertiesUpdateParametersDeliveryPolicyARMGenerator())
	gens["GeoFilters"] = gen.SliceOf(GeoFilterARMGenerator())
	gens["OriginGroups"] = gen.SliceOf(Profiles_Endpoint_Spec_Properties_OriginGroupsARMGenerator())
	gens["Origins"] = gen.SliceOf(Profiles_Endpoint_Spec_Properties_OriginsARMGenerator())
	gens["UrlSigningKeys"] = gen.SliceOf(UrlSigningKeyARMGenerator())
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator())
}

func Test_EndpointPropertiesUpdateParametersDeliveryPolicyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointPropertiesUpdateParametersDeliveryPolicyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointPropertiesUpdateParametersDeliveryPolicyARM, EndpointPropertiesUpdateParametersDeliveryPolicyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointPropertiesUpdateParametersDeliveryPolicyARM runs a test to see if a specific instance of EndpointPropertiesUpdateParametersDeliveryPolicyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointPropertiesUpdateParametersDeliveryPolicyARM(subject EndpointPropertiesUpdateParametersDeliveryPolicyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointPropertiesUpdateParametersDeliveryPolicyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointPropertiesUpdateParametersDeliveryPolicyARM instances for property testing - lazily instantiated
// by EndpointPropertiesUpdateParametersDeliveryPolicyARMGenerator()
var endpointPropertiesUpdateParametersDeliveryPolicyARMGenerator gopter.Gen

// EndpointPropertiesUpdateParametersDeliveryPolicyARMGenerator returns a generator of EndpointPropertiesUpdateParametersDeliveryPolicyARM instances for property testing.
// We first initialize endpointPropertiesUpdateParametersDeliveryPolicyARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EndpointPropertiesUpdateParametersDeliveryPolicyARMGenerator() gopter.Gen {
	if endpointPropertiesUpdateParametersDeliveryPolicyARMGenerator != nil {
		return endpointPropertiesUpdateParametersDeliveryPolicyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicyARM(generators)
	endpointPropertiesUpdateParametersDeliveryPolicyARMGenerator = gen.Struct(reflect.TypeOf(EndpointPropertiesUpdateParametersDeliveryPolicyARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicyARM(generators)
	AddRelatedPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicyARM(generators)
	endpointPropertiesUpdateParametersDeliveryPolicyARMGenerator = gen.Struct(reflect.TypeOf(EndpointPropertiesUpdateParametersDeliveryPolicyARM{}), generators)

	return endpointPropertiesUpdateParametersDeliveryPolicyARMGenerator
}

// AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicyARM(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicyARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicyARM(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(DeliveryRuleARMGenerator())
}

func Test_EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM, EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM runs a test to see if a specific instance of EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM(subject EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM instances for property testing -
// lazily instantiated by EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator()
var endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator gopter.Gen

// EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator returns a generator of EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM instances for property testing.
func EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator() gopter.Gen {
	if endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator != nil {
		return endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM(generators)
	endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator = gen.Struct(reflect.TypeOf(EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM{}), generators)

	return endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator
}

// AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_GeoFilterARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GeoFilterARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGeoFilterARM, GeoFilterARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGeoFilterARM runs a test to see if a specific instance of GeoFilterARM round trips to JSON and back losslessly
func RunJSONSerializationTestForGeoFilterARM(subject GeoFilterARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GeoFilterARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GeoFilterARM instances for property testing - lazily instantiated by GeoFilterARMGenerator()
var geoFilterARMGenerator gopter.Gen

// GeoFilterARMGenerator returns a generator of GeoFilterARM instances for property testing.
func GeoFilterARMGenerator() gopter.Gen {
	if geoFilterARMGenerator != nil {
		return geoFilterARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGeoFilterARM(generators)
	geoFilterARMGenerator = gen.Struct(reflect.TypeOf(GeoFilterARM{}), generators)

	return geoFilterARMGenerator
}

// AddIndependentPropertyGeneratorsForGeoFilterARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGeoFilterARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(GeoFilter_Action_Allow, GeoFilter_Action_Block))
	gens["CountryCodes"] = gen.SliceOf(gen.AlphaString())
	gens["RelativePath"] = gen.PtrOf(gen.AlphaString())
}

func Test_Profiles_Endpoint_Spec_Properties_OriginGroupsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Profiles_Endpoint_Spec_Properties_OriginGroupsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfiles_Endpoint_Spec_Properties_OriginGroupsARM, Profiles_Endpoint_Spec_Properties_OriginGroupsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfiles_Endpoint_Spec_Properties_OriginGroupsARM runs a test to see if a specific instance of Profiles_Endpoint_Spec_Properties_OriginGroupsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProfiles_Endpoint_Spec_Properties_OriginGroupsARM(subject Profiles_Endpoint_Spec_Properties_OriginGroupsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Profiles_Endpoint_Spec_Properties_OriginGroupsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Profiles_Endpoint_Spec_Properties_OriginGroupsARM instances for property testing - lazily instantiated
// by Profiles_Endpoint_Spec_Properties_OriginGroupsARMGenerator()
var profiles_Endpoint_Spec_Properties_OriginGroupsARMGenerator gopter.Gen

// Profiles_Endpoint_Spec_Properties_OriginGroupsARMGenerator returns a generator of Profiles_Endpoint_Spec_Properties_OriginGroupsARM instances for property testing.
// We first initialize profiles_Endpoint_Spec_Properties_OriginGroupsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Profiles_Endpoint_Spec_Properties_OriginGroupsARMGenerator() gopter.Gen {
	if profiles_Endpoint_Spec_Properties_OriginGroupsARMGenerator != nil {
		return profiles_Endpoint_Spec_Properties_OriginGroupsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_Properties_OriginGroupsARM(generators)
	profiles_Endpoint_Spec_Properties_OriginGroupsARMGenerator = gen.Struct(reflect.TypeOf(Profiles_Endpoint_Spec_Properties_OriginGroupsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_Properties_OriginGroupsARM(generators)
	AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec_Properties_OriginGroupsARM(generators)
	profiles_Endpoint_Spec_Properties_OriginGroupsARMGenerator = gen.Struct(reflect.TypeOf(Profiles_Endpoint_Spec_Properties_OriginGroupsARM{}), generators)

	return profiles_Endpoint_Spec_Properties_OriginGroupsARMGenerator
}

// AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_Properties_OriginGroupsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_Properties_OriginGroupsARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec_Properties_OriginGroupsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec_Properties_OriginGroupsARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(DeepCreatedOriginGroupPropertiesARMGenerator())
}

func Test_Profiles_Endpoint_Spec_Properties_OriginsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Profiles_Endpoint_Spec_Properties_OriginsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfiles_Endpoint_Spec_Properties_OriginsARM, Profiles_Endpoint_Spec_Properties_OriginsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfiles_Endpoint_Spec_Properties_OriginsARM runs a test to see if a specific instance of Profiles_Endpoint_Spec_Properties_OriginsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProfiles_Endpoint_Spec_Properties_OriginsARM(subject Profiles_Endpoint_Spec_Properties_OriginsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Profiles_Endpoint_Spec_Properties_OriginsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Profiles_Endpoint_Spec_Properties_OriginsARM instances for property testing - lazily instantiated by
// Profiles_Endpoint_Spec_Properties_OriginsARMGenerator()
var profiles_Endpoint_Spec_Properties_OriginsARMGenerator gopter.Gen

// Profiles_Endpoint_Spec_Properties_OriginsARMGenerator returns a generator of Profiles_Endpoint_Spec_Properties_OriginsARM instances for property testing.
// We first initialize profiles_Endpoint_Spec_Properties_OriginsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Profiles_Endpoint_Spec_Properties_OriginsARMGenerator() gopter.Gen {
	if profiles_Endpoint_Spec_Properties_OriginsARMGenerator != nil {
		return profiles_Endpoint_Spec_Properties_OriginsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_Properties_OriginsARM(generators)
	profiles_Endpoint_Spec_Properties_OriginsARMGenerator = gen.Struct(reflect.TypeOf(Profiles_Endpoint_Spec_Properties_OriginsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_Properties_OriginsARM(generators)
	AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec_Properties_OriginsARM(generators)
	profiles_Endpoint_Spec_Properties_OriginsARMGenerator = gen.Struct(reflect.TypeOf(Profiles_Endpoint_Spec_Properties_OriginsARM{}), generators)

	return profiles_Endpoint_Spec_Properties_OriginsARMGenerator
}

// AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_Properties_OriginsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_Properties_OriginsARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec_Properties_OriginsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec_Properties_OriginsARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(DeepCreatedOriginPropertiesARMGenerator())
}

func Test_ResourceReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceReferenceARM, ResourceReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceReferenceARM runs a test to see if a specific instance of ResourceReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceReferenceARM(subject ResourceReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceReferenceARM instances for property testing - lazily instantiated by
// ResourceReferenceARMGenerator()
var resourceReferenceARMGenerator gopter.Gen

// ResourceReferenceARMGenerator returns a generator of ResourceReferenceARM instances for property testing.
func ResourceReferenceARMGenerator() gopter.Gen {
	if resourceReferenceARMGenerator != nil {
		return resourceReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceReferenceARM(generators)
	resourceReferenceARMGenerator = gen.Struct(reflect.TypeOf(ResourceReferenceARM{}), generators)

	return resourceReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceReferenceARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_UrlSigningKeyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningKeyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningKeyARM, UrlSigningKeyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningKeyARM runs a test to see if a specific instance of UrlSigningKeyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningKeyARM(subject UrlSigningKeyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningKeyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningKeyARM instances for property testing - lazily instantiated by UrlSigningKeyARMGenerator()
var urlSigningKeyARMGenerator gopter.Gen

// UrlSigningKeyARMGenerator returns a generator of UrlSigningKeyARM instances for property testing.
// We first initialize urlSigningKeyARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningKeyARMGenerator() gopter.Gen {
	if urlSigningKeyARMGenerator != nil {
		return urlSigningKeyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKeyARM(generators)
	urlSigningKeyARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningKeyARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKeyARM(generators)
	AddRelatedPropertyGeneratorsForUrlSigningKeyARM(generators)
	urlSigningKeyARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningKeyARM{}), generators)

	return urlSigningKeyARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningKeyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningKeyARM(gens map[string]gopter.Gen) {
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUrlSigningKeyARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningKeyARM(gens map[string]gopter.Gen) {
	gens["KeySourceParameters"] = gen.PtrOf(KeyVaultSigningKeyParametersARMGenerator())
}

func Test_DeepCreatedOriginGroupPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOriginGroupPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOriginGroupPropertiesARM, DeepCreatedOriginGroupPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOriginGroupPropertiesARM runs a test to see if a specific instance of DeepCreatedOriginGroupPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOriginGroupPropertiesARM(subject DeepCreatedOriginGroupPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOriginGroupPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOriginGroupPropertiesARM instances for property testing - lazily instantiated by
// DeepCreatedOriginGroupPropertiesARMGenerator()
var deepCreatedOriginGroupPropertiesARMGenerator gopter.Gen

// DeepCreatedOriginGroupPropertiesARMGenerator returns a generator of DeepCreatedOriginGroupPropertiesARM instances for property testing.
// We first initialize deepCreatedOriginGroupPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeepCreatedOriginGroupPropertiesARMGenerator() gopter.Gen {
	if deepCreatedOriginGroupPropertiesARMGenerator != nil {
		return deepCreatedOriginGroupPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupPropertiesARM(generators)
	deepCreatedOriginGroupPropertiesARMGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroupPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForDeepCreatedOriginGroupPropertiesARM(generators)
	deepCreatedOriginGroupPropertiesARMGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroupPropertiesARM{}), generators)

	return deepCreatedOriginGroupPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupPropertiesARM(gens map[string]gopter.Gen) {
	gens["TrafficRestorationTimeToHealedOrNewEndpointsInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeepCreatedOriginGroupPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeepCreatedOriginGroupPropertiesARM(gens map[string]gopter.Gen) {
	gens["HealthProbeSettings"] = gen.PtrOf(HealthProbeParametersARMGenerator())
	gens["Origins"] = gen.SliceOf(ResourceReferenceARMGenerator())
	gens["ResponseBasedOriginErrorDetectionSettings"] = gen.PtrOf(ResponseBasedOriginErrorDetectionParametersARMGenerator())
}

func Test_DeepCreatedOriginPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOriginPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOriginPropertiesARM, DeepCreatedOriginPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOriginPropertiesARM runs a test to see if a specific instance of DeepCreatedOriginPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOriginPropertiesARM(subject DeepCreatedOriginPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOriginPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOriginPropertiesARM instances for property testing - lazily instantiated by
// DeepCreatedOriginPropertiesARMGenerator()
var deepCreatedOriginPropertiesARMGenerator gopter.Gen

// DeepCreatedOriginPropertiesARMGenerator returns a generator of DeepCreatedOriginPropertiesARM instances for property testing.
func DeepCreatedOriginPropertiesARMGenerator() gopter.Gen {
	if deepCreatedOriginPropertiesARMGenerator != nil {
		return deepCreatedOriginPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginPropertiesARM(generators)
	deepCreatedOriginPropertiesARMGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginPropertiesARM{}), generators)

	return deepCreatedOriginPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOriginPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOriginPropertiesARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["PrivateLinkAlias"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkApprovalMessage"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkLocation"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_DeliveryRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleARM, DeliveryRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleARM runs a test to see if a specific instance of DeliveryRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleARM(subject DeliveryRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleARM instances for property testing - lazily instantiated by DeliveryRuleARMGenerator()
var deliveryRuleARMGenerator gopter.Gen

// DeliveryRuleARMGenerator returns a generator of DeliveryRuleARM instances for property testing.
// We first initialize deliveryRuleARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleARMGenerator() gopter.Gen {
	if deliveryRuleARMGenerator != nil {
		return deliveryRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleARM(generators)
	deliveryRuleARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleARM(generators)
	deliveryRuleARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleARM{}), generators)

	return deliveryRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Order"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeliveryRuleARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleARM(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.SliceOf(DeliveryRuleAction1ARMGenerator())
	gens["Conditions"] = gen.SliceOf(DeliveryRuleConditionARMGenerator())
}

func Test_KeyVaultSigningKeyParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSigningKeyParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSigningKeyParametersARM, KeyVaultSigningKeyParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSigningKeyParametersARM runs a test to see if a specific instance of KeyVaultSigningKeyParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSigningKeyParametersARM(subject KeyVaultSigningKeyParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSigningKeyParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSigningKeyParametersARM instances for property testing - lazily instantiated by
// KeyVaultSigningKeyParametersARMGenerator()
var keyVaultSigningKeyParametersARMGenerator gopter.Gen

// KeyVaultSigningKeyParametersARMGenerator returns a generator of KeyVaultSigningKeyParametersARM instances for property testing.
func KeyVaultSigningKeyParametersARMGenerator() gopter.Gen {
	if keyVaultSigningKeyParametersARMGenerator != nil {
		return keyVaultSigningKeyParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParametersARM(generators)
	keyVaultSigningKeyParametersARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSigningKeyParametersARM{}), generators)

	return keyVaultSigningKeyParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParametersARM(gens map[string]gopter.Gen) {
	gens["ResourceGroupName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(KeyVaultSigningKeyParameters_TypeName_KeyVaultSigningKeyParameters))
	gens["VaultName"] = gen.PtrOf(gen.AlphaString())
}

func Test_DeliveryRuleAction1ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleAction1ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleAction1ARM, DeliveryRuleAction1ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleAction1ARM runs a test to see if a specific instance of DeliveryRuleAction1ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleAction1ARM(subject DeliveryRuleAction1ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleAction1ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleAction1ARM instances for property testing - lazily instantiated by
// DeliveryRuleAction1ARMGenerator()
var deliveryRuleAction1ARMGenerator gopter.Gen

// DeliveryRuleAction1ARMGenerator returns a generator of DeliveryRuleAction1ARM instances for property testing.
func DeliveryRuleAction1ARMGenerator() gopter.Gen {
	if deliveryRuleAction1ARMGenerator != nil {
		return deliveryRuleAction1ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeliveryRuleAction1ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeliveryRuleAction1ARM{}), map[string]gopter.Gen{
			propName: propGen,
		}))
	}
	deliveryRuleAction1ARMGenerator = gen.OneGenOf(gens...)

	return deliveryRuleAction1ARMGenerator
}

// AddRelatedPropertyGeneratorsForDeliveryRuleAction1ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleAction1ARM(gens map[string]gopter.Gen) {
	gens["DeliveryRuleCacheExpiration"] = DeliveryRuleCacheExpirationActionARMGenerator().Map(func(it DeliveryRuleCacheExpirationActionARM) *DeliveryRuleCacheExpirationActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleCacheKeyQueryString"] = DeliveryRuleCacheKeyQueryStringActionARMGenerator().Map(func(it DeliveryRuleCacheKeyQueryStringActionARM) *DeliveryRuleCacheKeyQueryStringActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestHeader"] = DeliveryRuleRequestHeaderActionARMGenerator().Map(func(it DeliveryRuleRequestHeaderActionARM) *DeliveryRuleRequestHeaderActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleResponseHeader"] = DeliveryRuleResponseHeaderActionARMGenerator().Map(func(it DeliveryRuleResponseHeaderActionARM) *DeliveryRuleResponseHeaderActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRouteConfigurationOverride"] = DeliveryRuleRouteConfigurationOverrideActionARMGenerator().Map(func(it DeliveryRuleRouteConfigurationOverrideActionARM) *DeliveryRuleRouteConfigurationOverrideActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["OriginGroupOverride"] = OriginGroupOverrideActionARMGenerator().Map(func(it OriginGroupOverrideActionARM) *OriginGroupOverrideActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["UrlRedirect"] = UrlRedirectActionARMGenerator().Map(func(it UrlRedirectActionARM) *UrlRedirectActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["UrlRewrite"] = UrlRewriteActionARMGenerator().Map(func(it UrlRewriteActionARM) *UrlRewriteActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["UrlSigning"] = UrlSigningActionARMGenerator().Map(func(it UrlSigningActionARM) *UrlSigningActionARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_DeliveryRuleConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleConditionARM, DeliveryRuleConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleConditionARM runs a test to see if a specific instance of DeliveryRuleConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleConditionARM(subject DeliveryRuleConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleConditionARMGenerator()
var deliveryRuleConditionARMGenerator gopter.Gen

// DeliveryRuleConditionARMGenerator returns a generator of DeliveryRuleConditionARM instances for property testing.
func DeliveryRuleConditionARMGenerator() gopter.Gen {
	if deliveryRuleConditionARMGenerator != nil {
		return deliveryRuleConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeliveryRuleConditionARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeliveryRuleConditionARM{}), map[string]gopter.Gen{
			propName: propGen,
		}))
	}
	deliveryRuleConditionARMGenerator = gen.OneGenOf(gens...)

	return deliveryRuleConditionARMGenerator
}

// AddRelatedPropertyGeneratorsForDeliveryRuleConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleConditionARM(gens map[string]gopter.Gen) {
	gens["DeliveryRuleClientPort"] = DeliveryRuleClientPortConditionARMGenerator().Map(func(it DeliveryRuleClientPortConditionARM) *DeliveryRuleClientPortConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleCookies"] = DeliveryRuleCookiesConditionARMGenerator().Map(func(it DeliveryRuleCookiesConditionARM) *DeliveryRuleCookiesConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleHostName"] = DeliveryRuleHostNameConditionARMGenerator().Map(func(it DeliveryRuleHostNameConditionARM) *DeliveryRuleHostNameConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleHttpVersion"] = DeliveryRuleHttpVersionConditionARMGenerator().Map(func(it DeliveryRuleHttpVersionConditionARM) *DeliveryRuleHttpVersionConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleIsDevice"] = DeliveryRuleIsDeviceConditionARMGenerator().Map(func(it DeliveryRuleIsDeviceConditionARM) *DeliveryRuleIsDeviceConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRulePostArgs"] = DeliveryRulePostArgsConditionARMGenerator().Map(func(it DeliveryRulePostArgsConditionARM) *DeliveryRulePostArgsConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleQueryString"] = DeliveryRuleQueryStringConditionARMGenerator().Map(func(it DeliveryRuleQueryStringConditionARM) *DeliveryRuleQueryStringConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRemoteAddress"] = DeliveryRuleRemoteAddressConditionARMGenerator().Map(func(it DeliveryRuleRemoteAddressConditionARM) *DeliveryRuleRemoteAddressConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestBody"] = DeliveryRuleRequestBodyConditionARMGenerator().Map(func(it DeliveryRuleRequestBodyConditionARM) *DeliveryRuleRequestBodyConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestHeader"] = DeliveryRuleRequestHeaderConditionARMGenerator().Map(func(it DeliveryRuleRequestHeaderConditionARM) *DeliveryRuleRequestHeaderConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestMethod"] = DeliveryRuleRequestMethodConditionARMGenerator().Map(func(it DeliveryRuleRequestMethodConditionARM) *DeliveryRuleRequestMethodConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestScheme"] = DeliveryRuleRequestSchemeConditionARMGenerator().Map(func(it DeliveryRuleRequestSchemeConditionARM) *DeliveryRuleRequestSchemeConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestUri"] = DeliveryRuleRequestUriConditionARMGenerator().Map(func(it DeliveryRuleRequestUriConditionARM) *DeliveryRuleRequestUriConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleServerPort"] = DeliveryRuleServerPortConditionARMGenerator().Map(func(it DeliveryRuleServerPortConditionARM) *DeliveryRuleServerPortConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleSocketAddr"] = DeliveryRuleSocketAddrConditionARMGenerator().Map(func(it DeliveryRuleSocketAddrConditionARM) *DeliveryRuleSocketAddrConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleSslProtocol"] = DeliveryRuleSslProtocolConditionARMGenerator().Map(func(it DeliveryRuleSslProtocolConditionARM) *DeliveryRuleSslProtocolConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlFileExtension"] = DeliveryRuleUrlFileExtensionConditionARMGenerator().Map(func(it DeliveryRuleUrlFileExtensionConditionARM) *DeliveryRuleUrlFileExtensionConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlFileName"] = DeliveryRuleUrlFileNameConditionARMGenerator().Map(func(it DeliveryRuleUrlFileNameConditionARM) *DeliveryRuleUrlFileNameConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlPath"] = DeliveryRuleUrlPathConditionARMGenerator().Map(func(it DeliveryRuleUrlPathConditionARM) *DeliveryRuleUrlPathConditionARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_HealthProbeParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeParametersARM, HealthProbeParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeParametersARM runs a test to see if a specific instance of HealthProbeParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeParametersARM(subject HealthProbeParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeParametersARM instances for property testing - lazily instantiated by
// HealthProbeParametersARMGenerator()
var healthProbeParametersARMGenerator gopter.Gen

// HealthProbeParametersARMGenerator returns a generator of HealthProbeParametersARM instances for property testing.
func HealthProbeParametersARMGenerator() gopter.Gen {
	if healthProbeParametersARMGenerator != nil {
		return healthProbeParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeParametersARM(generators)
	healthProbeParametersARMGenerator = gen.Struct(reflect.TypeOf(HealthProbeParametersARM{}), generators)

	return healthProbeParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeParametersARM(gens map[string]gopter.Gen) {
	gens["ProbeIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbeProtocol"] = gen.PtrOf(gen.OneConstOf(HealthProbeParameters_ProbeProtocol_Http, HealthProbeParameters_ProbeProtocol_Https, HealthProbeParameters_ProbeProtocol_NotSet))
	gens["ProbeRequestType"] = gen.PtrOf(gen.OneConstOf(HealthProbeParameters_ProbeRequestType_GET, HealthProbeParameters_ProbeRequestType_HEAD, HealthProbeParameters_ProbeRequestType_NotSet))
}

func Test_ResponseBasedOriginErrorDetectionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResponseBasedOriginErrorDetectionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResponseBasedOriginErrorDetectionParametersARM, ResponseBasedOriginErrorDetectionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResponseBasedOriginErrorDetectionParametersARM runs a test to see if a specific instance of ResponseBasedOriginErrorDetectionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResponseBasedOriginErrorDetectionParametersARM(subject ResponseBasedOriginErrorDetectionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResponseBasedOriginErrorDetectionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResponseBasedOriginErrorDetectionParametersARM instances for property testing - lazily instantiated by
// ResponseBasedOriginErrorDetectionParametersARMGenerator()
var responseBasedOriginErrorDetectionParametersARMGenerator gopter.Gen

// ResponseBasedOriginErrorDetectionParametersARMGenerator returns a generator of ResponseBasedOriginErrorDetectionParametersARM instances for property testing.
// We first initialize responseBasedOriginErrorDetectionParametersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResponseBasedOriginErrorDetectionParametersARMGenerator() gopter.Gen {
	if responseBasedOriginErrorDetectionParametersARMGenerator != nil {
		return responseBasedOriginErrorDetectionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersARM(generators)
	responseBasedOriginErrorDetectionParametersARMGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParametersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersARM(generators)
	AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersARM(generators)
	responseBasedOriginErrorDetectionParametersARMGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParametersARM{}), generators)

	return responseBasedOriginErrorDetectionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersARM(gens map[string]gopter.Gen) {
	gens["ResponseBasedDetectedErrorTypes"] = gen.PtrOf(gen.OneConstOf(ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_None, ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_TcpAndHttpErrors, ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_TcpErrorsOnly))
	gens["ResponseBasedFailoverThresholdPercentage"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersARM(gens map[string]gopter.Gen) {
	gens["HttpErrorRanges"] = gen.SliceOf(HttpErrorRangeParametersARMGenerator())
}

func Test_DeliveryRuleCacheExpirationActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCacheExpirationActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCacheExpirationActionARM, DeliveryRuleCacheExpirationActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCacheExpirationActionARM runs a test to see if a specific instance of DeliveryRuleCacheExpirationActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCacheExpirationActionARM(subject DeliveryRuleCacheExpirationActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCacheExpirationActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCacheExpirationActionARM instances for property testing - lazily instantiated by
// DeliveryRuleCacheExpirationActionARMGenerator()
var deliveryRuleCacheExpirationActionARMGenerator gopter.Gen

// DeliveryRuleCacheExpirationActionARMGenerator returns a generator of DeliveryRuleCacheExpirationActionARM instances for property testing.
// We first initialize deliveryRuleCacheExpirationActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCacheExpirationActionARMGenerator() gopter.Gen {
	if deliveryRuleCacheExpirationActionARMGenerator != nil {
		return deliveryRuleCacheExpirationActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationActionARM(generators)
	deliveryRuleCacheExpirationActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheExpirationActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationActionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationActionARM(generators)
	deliveryRuleCacheExpirationActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheExpirationActionARM{}), generators)

	return deliveryRuleCacheExpirationActionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCacheExpirationAction_Name_CacheExpiration)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CacheExpirationActionParametersARMGenerator())
}

func Test_DeliveryRuleCacheKeyQueryStringActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCacheKeyQueryStringActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringActionARM, DeliveryRuleCacheKeyQueryStringActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringActionARM runs a test to see if a specific instance of DeliveryRuleCacheKeyQueryStringActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringActionARM(subject DeliveryRuleCacheKeyQueryStringActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCacheKeyQueryStringActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCacheKeyQueryStringActionARM instances for property testing - lazily instantiated by
// DeliveryRuleCacheKeyQueryStringActionARMGenerator()
var deliveryRuleCacheKeyQueryStringActionARMGenerator gopter.Gen

// DeliveryRuleCacheKeyQueryStringActionARMGenerator returns a generator of DeliveryRuleCacheKeyQueryStringActionARM instances for property testing.
// We first initialize deliveryRuleCacheKeyQueryStringActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCacheKeyQueryStringActionARMGenerator() gopter.Gen {
	if deliveryRuleCacheKeyQueryStringActionARMGenerator != nil {
		return deliveryRuleCacheKeyQueryStringActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringActionARM(generators)
	deliveryRuleCacheKeyQueryStringActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheKeyQueryStringActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringActionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringActionARM(generators)
	deliveryRuleCacheKeyQueryStringActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheKeyQueryStringActionARM{}), generators)

	return deliveryRuleCacheKeyQueryStringActionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCacheKeyQueryStringAction_Name_CacheKeyQueryString)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CacheKeyQueryStringActionParametersARMGenerator())
}

func Test_DeliveryRuleClientPortConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleClientPortConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleClientPortConditionARM, DeliveryRuleClientPortConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleClientPortConditionARM runs a test to see if a specific instance of DeliveryRuleClientPortConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleClientPortConditionARM(subject DeliveryRuleClientPortConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleClientPortConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleClientPortConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleClientPortConditionARMGenerator()
var deliveryRuleClientPortConditionARMGenerator gopter.Gen

// DeliveryRuleClientPortConditionARMGenerator returns a generator of DeliveryRuleClientPortConditionARM instances for property testing.
// We first initialize deliveryRuleClientPortConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleClientPortConditionARMGenerator() gopter.Gen {
	if deliveryRuleClientPortConditionARMGenerator != nil {
		return deliveryRuleClientPortConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleClientPortConditionARM(generators)
	deliveryRuleClientPortConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleClientPortConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleClientPortConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleClientPortConditionARM(generators)
	deliveryRuleClientPortConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleClientPortConditionARM{}), generators)

	return deliveryRuleClientPortConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleClientPortConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleClientPortConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleClientPortCondition_Name_ClientPort)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleClientPortConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleClientPortConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(ClientPortMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleCookiesConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCookiesConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCookiesConditionARM, DeliveryRuleCookiesConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCookiesConditionARM runs a test to see if a specific instance of DeliveryRuleCookiesConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCookiesConditionARM(subject DeliveryRuleCookiesConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCookiesConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCookiesConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleCookiesConditionARMGenerator()
var deliveryRuleCookiesConditionARMGenerator gopter.Gen

// DeliveryRuleCookiesConditionARMGenerator returns a generator of DeliveryRuleCookiesConditionARM instances for property testing.
// We first initialize deliveryRuleCookiesConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCookiesConditionARMGenerator() gopter.Gen {
	if deliveryRuleCookiesConditionARMGenerator != nil {
		return deliveryRuleCookiesConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCookiesConditionARM(generators)
	deliveryRuleCookiesConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCookiesConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCookiesConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCookiesConditionARM(generators)
	deliveryRuleCookiesConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCookiesConditionARM{}), generators)

	return deliveryRuleCookiesConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCookiesConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCookiesConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCookiesCondition_Name_Cookies)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCookiesConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCookiesConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CookiesMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleHostNameConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleHostNameConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleHostNameConditionARM, DeliveryRuleHostNameConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleHostNameConditionARM runs a test to see if a specific instance of DeliveryRuleHostNameConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleHostNameConditionARM(subject DeliveryRuleHostNameConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleHostNameConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleHostNameConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleHostNameConditionARMGenerator()
var deliveryRuleHostNameConditionARMGenerator gopter.Gen

// DeliveryRuleHostNameConditionARMGenerator returns a generator of DeliveryRuleHostNameConditionARM instances for property testing.
// We first initialize deliveryRuleHostNameConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleHostNameConditionARMGenerator() gopter.Gen {
	if deliveryRuleHostNameConditionARMGenerator != nil {
		return deliveryRuleHostNameConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHostNameConditionARM(generators)
	deliveryRuleHostNameConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHostNameConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHostNameConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleHostNameConditionARM(generators)
	deliveryRuleHostNameConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHostNameConditionARM{}), generators)

	return deliveryRuleHostNameConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleHostNameConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleHostNameConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleHostNameCondition_Name_HostName)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleHostNameConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleHostNameConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HostNameMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleHttpVersionConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleHttpVersionConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleHttpVersionConditionARM, DeliveryRuleHttpVersionConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleHttpVersionConditionARM runs a test to see if a specific instance of DeliveryRuleHttpVersionConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleHttpVersionConditionARM(subject DeliveryRuleHttpVersionConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleHttpVersionConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleHttpVersionConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleHttpVersionConditionARMGenerator()
var deliveryRuleHttpVersionConditionARMGenerator gopter.Gen

// DeliveryRuleHttpVersionConditionARMGenerator returns a generator of DeliveryRuleHttpVersionConditionARM instances for property testing.
// We first initialize deliveryRuleHttpVersionConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleHttpVersionConditionARMGenerator() gopter.Gen {
	if deliveryRuleHttpVersionConditionARMGenerator != nil {
		return deliveryRuleHttpVersionConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionConditionARM(generators)
	deliveryRuleHttpVersionConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHttpVersionConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionConditionARM(generators)
	deliveryRuleHttpVersionConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHttpVersionConditionARM{}), generators)

	return deliveryRuleHttpVersionConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleHttpVersionCondition_Name_HttpVersion)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HttpVersionMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleIsDeviceConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleIsDeviceConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleIsDeviceConditionARM, DeliveryRuleIsDeviceConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleIsDeviceConditionARM runs a test to see if a specific instance of DeliveryRuleIsDeviceConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleIsDeviceConditionARM(subject DeliveryRuleIsDeviceConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleIsDeviceConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleIsDeviceConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleIsDeviceConditionARMGenerator()
var deliveryRuleIsDeviceConditionARMGenerator gopter.Gen

// DeliveryRuleIsDeviceConditionARMGenerator returns a generator of DeliveryRuleIsDeviceConditionARM instances for property testing.
// We first initialize deliveryRuleIsDeviceConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleIsDeviceConditionARMGenerator() gopter.Gen {
	if deliveryRuleIsDeviceConditionARMGenerator != nil {
		return deliveryRuleIsDeviceConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceConditionARM(generators)
	deliveryRuleIsDeviceConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleIsDeviceConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceConditionARM(generators)
	deliveryRuleIsDeviceConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleIsDeviceConditionARM{}), generators)

	return deliveryRuleIsDeviceConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleIsDeviceCondition_Name_IsDevice)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(IsDeviceMatchConditionParametersARMGenerator())
}

func Test_DeliveryRulePostArgsConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRulePostArgsConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRulePostArgsConditionARM, DeliveryRulePostArgsConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRulePostArgsConditionARM runs a test to see if a specific instance of DeliveryRulePostArgsConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRulePostArgsConditionARM(subject DeliveryRulePostArgsConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRulePostArgsConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRulePostArgsConditionARM instances for property testing - lazily instantiated by
// DeliveryRulePostArgsConditionARMGenerator()
var deliveryRulePostArgsConditionARMGenerator gopter.Gen

// DeliveryRulePostArgsConditionARMGenerator returns a generator of DeliveryRulePostArgsConditionARM instances for property testing.
// We first initialize deliveryRulePostArgsConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRulePostArgsConditionARMGenerator() gopter.Gen {
	if deliveryRulePostArgsConditionARMGenerator != nil {
		return deliveryRulePostArgsConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRulePostArgsConditionARM(generators)
	deliveryRulePostArgsConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRulePostArgsConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRulePostArgsConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRulePostArgsConditionARM(generators)
	deliveryRulePostArgsConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRulePostArgsConditionARM{}), generators)

	return deliveryRulePostArgsConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRulePostArgsConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRulePostArgsConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRulePostArgsCondition_Name_PostArgs)
}

// AddRelatedPropertyGeneratorsForDeliveryRulePostArgsConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRulePostArgsConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(PostArgsMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleQueryStringConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleQueryStringConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleQueryStringConditionARM, DeliveryRuleQueryStringConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleQueryStringConditionARM runs a test to see if a specific instance of DeliveryRuleQueryStringConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleQueryStringConditionARM(subject DeliveryRuleQueryStringConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleQueryStringConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleQueryStringConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleQueryStringConditionARMGenerator()
var deliveryRuleQueryStringConditionARMGenerator gopter.Gen

// DeliveryRuleQueryStringConditionARMGenerator returns a generator of DeliveryRuleQueryStringConditionARM instances for property testing.
// We first initialize deliveryRuleQueryStringConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleQueryStringConditionARMGenerator() gopter.Gen {
	if deliveryRuleQueryStringConditionARMGenerator != nil {
		return deliveryRuleQueryStringConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringConditionARM(generators)
	deliveryRuleQueryStringConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleQueryStringConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringConditionARM(generators)
	deliveryRuleQueryStringConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleQueryStringConditionARM{}), generators)

	return deliveryRuleQueryStringConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleQueryStringCondition_Name_QueryString)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(QueryStringMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleRemoteAddressConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRemoteAddressConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRemoteAddressConditionARM, DeliveryRuleRemoteAddressConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRemoteAddressConditionARM runs a test to see if a specific instance of DeliveryRuleRemoteAddressConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRemoteAddressConditionARM(subject DeliveryRuleRemoteAddressConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRemoteAddressConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRemoteAddressConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleRemoteAddressConditionARMGenerator()
var deliveryRuleRemoteAddressConditionARMGenerator gopter.Gen

// DeliveryRuleRemoteAddressConditionARMGenerator returns a generator of DeliveryRuleRemoteAddressConditionARM instances for property testing.
// We first initialize deliveryRuleRemoteAddressConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRemoteAddressConditionARMGenerator() gopter.Gen {
	if deliveryRuleRemoteAddressConditionARMGenerator != nil {
		return deliveryRuleRemoteAddressConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressConditionARM(generators)
	deliveryRuleRemoteAddressConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRemoteAddressConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressConditionARM(generators)
	deliveryRuleRemoteAddressConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRemoteAddressConditionARM{}), generators)

	return deliveryRuleRemoteAddressConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRemoteAddressCondition_Name_RemoteAddress)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RemoteAddressMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleRequestBodyConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestBodyConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestBodyConditionARM, DeliveryRuleRequestBodyConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestBodyConditionARM runs a test to see if a specific instance of DeliveryRuleRequestBodyConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestBodyConditionARM(subject DeliveryRuleRequestBodyConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestBodyConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestBodyConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestBodyConditionARMGenerator()
var deliveryRuleRequestBodyConditionARMGenerator gopter.Gen

// DeliveryRuleRequestBodyConditionARMGenerator returns a generator of DeliveryRuleRequestBodyConditionARM instances for property testing.
// We first initialize deliveryRuleRequestBodyConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestBodyConditionARMGenerator() gopter.Gen {
	if deliveryRuleRequestBodyConditionARMGenerator != nil {
		return deliveryRuleRequestBodyConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyConditionARM(generators)
	deliveryRuleRequestBodyConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestBodyConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyConditionARM(generators)
	deliveryRuleRequestBodyConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestBodyConditionARM{}), generators)

	return deliveryRuleRequestBodyConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestBodyCondition_Name_RequestBody)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestBodyMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleRequestHeaderActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestHeaderActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestHeaderActionARM, DeliveryRuleRequestHeaderActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestHeaderActionARM runs a test to see if a specific instance of DeliveryRuleRequestHeaderActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestHeaderActionARM(subject DeliveryRuleRequestHeaderActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestHeaderActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestHeaderActionARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestHeaderActionARMGenerator()
var deliveryRuleRequestHeaderActionARMGenerator gopter.Gen

// DeliveryRuleRequestHeaderActionARMGenerator returns a generator of DeliveryRuleRequestHeaderActionARM instances for property testing.
// We first initialize deliveryRuleRequestHeaderActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestHeaderActionARMGenerator() gopter.Gen {
	if deliveryRuleRequestHeaderActionARMGenerator != nil {
		return deliveryRuleRequestHeaderActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderActionARM(generators)
	deliveryRuleRequestHeaderActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderActionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderActionARM(generators)
	deliveryRuleRequestHeaderActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderActionARM{}), generators)

	return deliveryRuleRequestHeaderActionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestHeaderAction_Name_ModifyRequestHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HeaderActionParametersARMGenerator())
}

func Test_DeliveryRuleRequestHeaderConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestHeaderConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestHeaderConditionARM, DeliveryRuleRequestHeaderConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestHeaderConditionARM runs a test to see if a specific instance of DeliveryRuleRequestHeaderConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestHeaderConditionARM(subject DeliveryRuleRequestHeaderConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestHeaderConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestHeaderConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestHeaderConditionARMGenerator()
var deliveryRuleRequestHeaderConditionARMGenerator gopter.Gen

// DeliveryRuleRequestHeaderConditionARMGenerator returns a generator of DeliveryRuleRequestHeaderConditionARM instances for property testing.
// We first initialize deliveryRuleRequestHeaderConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestHeaderConditionARMGenerator() gopter.Gen {
	if deliveryRuleRequestHeaderConditionARMGenerator != nil {
		return deliveryRuleRequestHeaderConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderConditionARM(generators)
	deliveryRuleRequestHeaderConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderConditionARM(generators)
	deliveryRuleRequestHeaderConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderConditionARM{}), generators)

	return deliveryRuleRequestHeaderConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestHeaderCondition_Name_RequestHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestHeaderMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleRequestMethodConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestMethodConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestMethodConditionARM, DeliveryRuleRequestMethodConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestMethodConditionARM runs a test to see if a specific instance of DeliveryRuleRequestMethodConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestMethodConditionARM(subject DeliveryRuleRequestMethodConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestMethodConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestMethodConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestMethodConditionARMGenerator()
var deliveryRuleRequestMethodConditionARMGenerator gopter.Gen

// DeliveryRuleRequestMethodConditionARMGenerator returns a generator of DeliveryRuleRequestMethodConditionARM instances for property testing.
// We first initialize deliveryRuleRequestMethodConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestMethodConditionARMGenerator() gopter.Gen {
	if deliveryRuleRequestMethodConditionARMGenerator != nil {
		return deliveryRuleRequestMethodConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodConditionARM(generators)
	deliveryRuleRequestMethodConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestMethodConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodConditionARM(generators)
	deliveryRuleRequestMethodConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestMethodConditionARM{}), generators)

	return deliveryRuleRequestMethodConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestMethodCondition_Name_RequestMethod)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestMethodMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleRequestSchemeConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestSchemeConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestSchemeConditionARM, DeliveryRuleRequestSchemeConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestSchemeConditionARM runs a test to see if a specific instance of DeliveryRuleRequestSchemeConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestSchemeConditionARM(subject DeliveryRuleRequestSchemeConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestSchemeConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestSchemeConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestSchemeConditionARMGenerator()
var deliveryRuleRequestSchemeConditionARMGenerator gopter.Gen

// DeliveryRuleRequestSchemeConditionARMGenerator returns a generator of DeliveryRuleRequestSchemeConditionARM instances for property testing.
// We first initialize deliveryRuleRequestSchemeConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestSchemeConditionARMGenerator() gopter.Gen {
	if deliveryRuleRequestSchemeConditionARMGenerator != nil {
		return deliveryRuleRequestSchemeConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeConditionARM(generators)
	deliveryRuleRequestSchemeConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestSchemeConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeConditionARM(generators)
	deliveryRuleRequestSchemeConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestSchemeConditionARM{}), generators)

	return deliveryRuleRequestSchemeConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestSchemeCondition_Name_RequestScheme)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestSchemeMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleRequestUriConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestUriConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestUriConditionARM, DeliveryRuleRequestUriConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestUriConditionARM runs a test to see if a specific instance of DeliveryRuleRequestUriConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestUriConditionARM(subject DeliveryRuleRequestUriConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestUriConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestUriConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestUriConditionARMGenerator()
var deliveryRuleRequestUriConditionARMGenerator gopter.Gen

// DeliveryRuleRequestUriConditionARMGenerator returns a generator of DeliveryRuleRequestUriConditionARM instances for property testing.
// We first initialize deliveryRuleRequestUriConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestUriConditionARMGenerator() gopter.Gen {
	if deliveryRuleRequestUriConditionARMGenerator != nil {
		return deliveryRuleRequestUriConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriConditionARM(generators)
	deliveryRuleRequestUriConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestUriConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriConditionARM(generators)
	deliveryRuleRequestUriConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestUriConditionARM{}), generators)

	return deliveryRuleRequestUriConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestUriCondition_Name_RequestUri)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestUriMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleResponseHeaderActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleResponseHeaderActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleResponseHeaderActionARM, DeliveryRuleResponseHeaderActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleResponseHeaderActionARM runs a test to see if a specific instance of DeliveryRuleResponseHeaderActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleResponseHeaderActionARM(subject DeliveryRuleResponseHeaderActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleResponseHeaderActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleResponseHeaderActionARM instances for property testing - lazily instantiated by
// DeliveryRuleResponseHeaderActionARMGenerator()
var deliveryRuleResponseHeaderActionARMGenerator gopter.Gen

// DeliveryRuleResponseHeaderActionARMGenerator returns a generator of DeliveryRuleResponseHeaderActionARM instances for property testing.
// We first initialize deliveryRuleResponseHeaderActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleResponseHeaderActionARMGenerator() gopter.Gen {
	if deliveryRuleResponseHeaderActionARMGenerator != nil {
		return deliveryRuleResponseHeaderActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderActionARM(generators)
	deliveryRuleResponseHeaderActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleResponseHeaderActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderActionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderActionARM(generators)
	deliveryRuleResponseHeaderActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleResponseHeaderActionARM{}), generators)

	return deliveryRuleResponseHeaderActionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleResponseHeaderAction_Name_ModifyResponseHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HeaderActionParametersARMGenerator())
}

func Test_DeliveryRuleRouteConfigurationOverrideActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRouteConfigurationOverrideActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideActionARM, DeliveryRuleRouteConfigurationOverrideActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideActionARM runs a test to see if a specific instance of DeliveryRuleRouteConfigurationOverrideActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideActionARM(subject DeliveryRuleRouteConfigurationOverrideActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRouteConfigurationOverrideActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRouteConfigurationOverrideActionARM instances for property testing - lazily instantiated by
// DeliveryRuleRouteConfigurationOverrideActionARMGenerator()
var deliveryRuleRouteConfigurationOverrideActionARMGenerator gopter.Gen

// DeliveryRuleRouteConfigurationOverrideActionARMGenerator returns a generator of DeliveryRuleRouteConfigurationOverrideActionARM instances for property testing.
// We first initialize deliveryRuleRouteConfigurationOverrideActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRouteConfigurationOverrideActionARMGenerator() gopter.Gen {
	if deliveryRuleRouteConfigurationOverrideActionARMGenerator != nil {
		return deliveryRuleRouteConfigurationOverrideActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideActionARM(generators)
	deliveryRuleRouteConfigurationOverrideActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRouteConfigurationOverrideActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideActionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideActionARM(generators)
	deliveryRuleRouteConfigurationOverrideActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRouteConfigurationOverrideActionARM{}), generators)

	return deliveryRuleRouteConfigurationOverrideActionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRouteConfigurationOverrideAction_Name_RouteConfigurationOverride)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RouteConfigurationOverrideActionParametersARMGenerator())
}

func Test_DeliveryRuleServerPortConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleServerPortConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleServerPortConditionARM, DeliveryRuleServerPortConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleServerPortConditionARM runs a test to see if a specific instance of DeliveryRuleServerPortConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleServerPortConditionARM(subject DeliveryRuleServerPortConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleServerPortConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleServerPortConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleServerPortConditionARMGenerator()
var deliveryRuleServerPortConditionARMGenerator gopter.Gen

// DeliveryRuleServerPortConditionARMGenerator returns a generator of DeliveryRuleServerPortConditionARM instances for property testing.
// We first initialize deliveryRuleServerPortConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleServerPortConditionARMGenerator() gopter.Gen {
	if deliveryRuleServerPortConditionARMGenerator != nil {
		return deliveryRuleServerPortConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleServerPortConditionARM(generators)
	deliveryRuleServerPortConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleServerPortConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleServerPortConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleServerPortConditionARM(generators)
	deliveryRuleServerPortConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleServerPortConditionARM{}), generators)

	return deliveryRuleServerPortConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleServerPortConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleServerPortConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleServerPortCondition_Name_ServerPort)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleServerPortConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleServerPortConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(ServerPortMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleSocketAddrConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleSocketAddrConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleSocketAddrConditionARM, DeliveryRuleSocketAddrConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleSocketAddrConditionARM runs a test to see if a specific instance of DeliveryRuleSocketAddrConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleSocketAddrConditionARM(subject DeliveryRuleSocketAddrConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleSocketAddrConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleSocketAddrConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleSocketAddrConditionARMGenerator()
var deliveryRuleSocketAddrConditionARMGenerator gopter.Gen

// DeliveryRuleSocketAddrConditionARMGenerator returns a generator of DeliveryRuleSocketAddrConditionARM instances for property testing.
// We first initialize deliveryRuleSocketAddrConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleSocketAddrConditionARMGenerator() gopter.Gen {
	if deliveryRuleSocketAddrConditionARMGenerator != nil {
		return deliveryRuleSocketAddrConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrConditionARM(generators)
	deliveryRuleSocketAddrConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSocketAddrConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrConditionARM(generators)
	deliveryRuleSocketAddrConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSocketAddrConditionARM{}), generators)

	return deliveryRuleSocketAddrConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleSocketAddrCondition_Name_SocketAddr)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(SocketAddrMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleSslProtocolConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleSslProtocolConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleSslProtocolConditionARM, DeliveryRuleSslProtocolConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleSslProtocolConditionARM runs a test to see if a specific instance of DeliveryRuleSslProtocolConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleSslProtocolConditionARM(subject DeliveryRuleSslProtocolConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleSslProtocolConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleSslProtocolConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleSslProtocolConditionARMGenerator()
var deliveryRuleSslProtocolConditionARMGenerator gopter.Gen

// DeliveryRuleSslProtocolConditionARMGenerator returns a generator of DeliveryRuleSslProtocolConditionARM instances for property testing.
// We first initialize deliveryRuleSslProtocolConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleSslProtocolConditionARMGenerator() gopter.Gen {
	if deliveryRuleSslProtocolConditionARMGenerator != nil {
		return deliveryRuleSslProtocolConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolConditionARM(generators)
	deliveryRuleSslProtocolConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSslProtocolConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolConditionARM(generators)
	deliveryRuleSslProtocolConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSslProtocolConditionARM{}), generators)

	return deliveryRuleSslProtocolConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleSslProtocolCondition_Name_SslProtocol)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(SslProtocolMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleUrlFileExtensionConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlFileExtensionConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlFileExtensionConditionARM, DeliveryRuleUrlFileExtensionConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlFileExtensionConditionARM runs a test to see if a specific instance of DeliveryRuleUrlFileExtensionConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlFileExtensionConditionARM(subject DeliveryRuleUrlFileExtensionConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlFileExtensionConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlFileExtensionConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleUrlFileExtensionConditionARMGenerator()
var deliveryRuleUrlFileExtensionConditionARMGenerator gopter.Gen

// DeliveryRuleUrlFileExtensionConditionARMGenerator returns a generator of DeliveryRuleUrlFileExtensionConditionARM instances for property testing.
// We first initialize deliveryRuleUrlFileExtensionConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlFileExtensionConditionARMGenerator() gopter.Gen {
	if deliveryRuleUrlFileExtensionConditionARMGenerator != nil {
		return deliveryRuleUrlFileExtensionConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionConditionARM(generators)
	deliveryRuleUrlFileExtensionConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileExtensionConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionConditionARM(generators)
	deliveryRuleUrlFileExtensionConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileExtensionConditionARM{}), generators)

	return deliveryRuleUrlFileExtensionConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlFileExtensionCondition_Name_UrlFileExtension)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlFileExtensionMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleUrlFileNameConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlFileNameConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlFileNameConditionARM, DeliveryRuleUrlFileNameConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlFileNameConditionARM runs a test to see if a specific instance of DeliveryRuleUrlFileNameConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlFileNameConditionARM(subject DeliveryRuleUrlFileNameConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlFileNameConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlFileNameConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleUrlFileNameConditionARMGenerator()
var deliveryRuleUrlFileNameConditionARMGenerator gopter.Gen

// DeliveryRuleUrlFileNameConditionARMGenerator returns a generator of DeliveryRuleUrlFileNameConditionARM instances for property testing.
// We first initialize deliveryRuleUrlFileNameConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlFileNameConditionARMGenerator() gopter.Gen {
	if deliveryRuleUrlFileNameConditionARMGenerator != nil {
		return deliveryRuleUrlFileNameConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameConditionARM(generators)
	deliveryRuleUrlFileNameConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileNameConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameConditionARM(generators)
	deliveryRuleUrlFileNameConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileNameConditionARM{}), generators)

	return deliveryRuleUrlFileNameConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlFileNameCondition_Name_UrlFileName)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlFileNameMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleUrlPathConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlPathConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlPathConditionARM, DeliveryRuleUrlPathConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlPathConditionARM runs a test to see if a specific instance of DeliveryRuleUrlPathConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlPathConditionARM(subject DeliveryRuleUrlPathConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlPathConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlPathConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleUrlPathConditionARMGenerator()
var deliveryRuleUrlPathConditionARMGenerator gopter.Gen

// DeliveryRuleUrlPathConditionARMGenerator returns a generator of DeliveryRuleUrlPathConditionARM instances for property testing.
// We first initialize deliveryRuleUrlPathConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlPathConditionARMGenerator() gopter.Gen {
	if deliveryRuleUrlPathConditionARMGenerator != nil {
		return deliveryRuleUrlPathConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathConditionARM(generators)
	deliveryRuleUrlPathConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlPathConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathConditionARM(generators)
	deliveryRuleUrlPathConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlPathConditionARM{}), generators)

	return deliveryRuleUrlPathConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlPathCondition_Name_UrlPath)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlPathMatchConditionParametersARMGenerator())
}

func Test_HttpErrorRangeParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpErrorRangeParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpErrorRangeParametersARM, HttpErrorRangeParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpErrorRangeParametersARM runs a test to see if a specific instance of HttpErrorRangeParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpErrorRangeParametersARM(subject HttpErrorRangeParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpErrorRangeParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpErrorRangeParametersARM instances for property testing - lazily instantiated by
// HttpErrorRangeParametersARMGenerator()
var httpErrorRangeParametersARMGenerator gopter.Gen

// HttpErrorRangeParametersARMGenerator returns a generator of HttpErrorRangeParametersARM instances for property testing.
func HttpErrorRangeParametersARMGenerator() gopter.Gen {
	if httpErrorRangeParametersARMGenerator != nil {
		return httpErrorRangeParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpErrorRangeParametersARM(generators)
	httpErrorRangeParametersARMGenerator = gen.Struct(reflect.TypeOf(HttpErrorRangeParametersARM{}), generators)

	return httpErrorRangeParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForHttpErrorRangeParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpErrorRangeParametersARM(gens map[string]gopter.Gen) {
	gens["Begin"] = gen.PtrOf(gen.Int())
	gens["End"] = gen.PtrOf(gen.Int())
}

func Test_OriginGroupOverrideActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverrideActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverrideActionARM, OriginGroupOverrideActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverrideActionARM runs a test to see if a specific instance of OriginGroupOverrideActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverrideActionARM(subject OriginGroupOverrideActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverrideActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverrideActionARM instances for property testing - lazily instantiated by
// OriginGroupOverrideActionARMGenerator()
var originGroupOverrideActionARMGenerator gopter.Gen

// OriginGroupOverrideActionARMGenerator returns a generator of OriginGroupOverrideActionARM instances for property testing.
// We first initialize originGroupOverrideActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideActionARMGenerator() gopter.Gen {
	if originGroupOverrideActionARMGenerator != nil {
		return originGroupOverrideActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionARM(generators)
	originGroupOverrideActionARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionARM(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverrideActionARM(generators)
	originGroupOverrideActionARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionARM{}), generators)

	return originGroupOverrideActionARMGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverrideActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverrideActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(OriginGroupOverrideAction_Name_OriginGroupOverride)
}

// AddRelatedPropertyGeneratorsForOriginGroupOverrideActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverrideActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(OriginGroupOverrideActionParametersARMGenerator())
}

func Test_UrlRedirectActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRedirectActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRedirectActionARM, UrlRedirectActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRedirectActionARM runs a test to see if a specific instance of UrlRedirectActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRedirectActionARM(subject UrlRedirectActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRedirectActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRedirectActionARM instances for property testing - lazily instantiated by
// UrlRedirectActionARMGenerator()
var urlRedirectActionARMGenerator gopter.Gen

// UrlRedirectActionARMGenerator returns a generator of UrlRedirectActionARM instances for property testing.
// We first initialize urlRedirectActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlRedirectActionARMGenerator() gopter.Gen {
	if urlRedirectActionARMGenerator != nil {
		return urlRedirectActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectActionARM(generators)
	urlRedirectActionARMGenerator = gen.Struct(reflect.TypeOf(UrlRedirectActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectActionARM(generators)
	AddRelatedPropertyGeneratorsForUrlRedirectActionARM(generators)
	urlRedirectActionARMGenerator = gen.Struct(reflect.TypeOf(UrlRedirectActionARM{}), generators)

	return urlRedirectActionARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlRedirectActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRedirectActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlRedirectAction_Name_UrlRedirect)
}

// AddRelatedPropertyGeneratorsForUrlRedirectActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlRedirectActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlRedirectActionParametersARMGenerator())
}

func Test_UrlRewriteActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRewriteActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRewriteActionARM, UrlRewriteActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRewriteActionARM runs a test to see if a specific instance of UrlRewriteActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRewriteActionARM(subject UrlRewriteActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRewriteActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRewriteActionARM instances for property testing - lazily instantiated by
// UrlRewriteActionARMGenerator()
var urlRewriteActionARMGenerator gopter.Gen

// UrlRewriteActionARMGenerator returns a generator of UrlRewriteActionARM instances for property testing.
// We first initialize urlRewriteActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlRewriteActionARMGenerator() gopter.Gen {
	if urlRewriteActionARMGenerator != nil {
		return urlRewriteActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteActionARM(generators)
	urlRewriteActionARMGenerator = gen.Struct(reflect.TypeOf(UrlRewriteActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteActionARM(generators)
	AddRelatedPropertyGeneratorsForUrlRewriteActionARM(generators)
	urlRewriteActionARMGenerator = gen.Struct(reflect.TypeOf(UrlRewriteActionARM{}), generators)

	return urlRewriteActionARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlRewriteActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRewriteActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlRewriteAction_Name_UrlRewrite)
}

// AddRelatedPropertyGeneratorsForUrlRewriteActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlRewriteActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlRewriteActionParametersARMGenerator())
}

func Test_UrlSigningActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningActionARM, UrlSigningActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningActionARM runs a test to see if a specific instance of UrlSigningActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningActionARM(subject UrlSigningActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningActionARM instances for property testing - lazily instantiated by
// UrlSigningActionARMGenerator()
var urlSigningActionARMGenerator gopter.Gen

// UrlSigningActionARMGenerator returns a generator of UrlSigningActionARM instances for property testing.
// We first initialize urlSigningActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningActionARMGenerator() gopter.Gen {
	if urlSigningActionARMGenerator != nil {
		return urlSigningActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionARM(generators)
	urlSigningActionARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionARM(generators)
	AddRelatedPropertyGeneratorsForUrlSigningActionARM(generators)
	urlSigningActionARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionARM{}), generators)

	return urlSigningActionARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlSigningAction_Name_UrlSigning)
}

// AddRelatedPropertyGeneratorsForUrlSigningActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlSigningActionParametersARMGenerator())
}

func Test_CacheExpirationActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheExpirationActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheExpirationActionParametersARM, CacheExpirationActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheExpirationActionParametersARM runs a test to see if a specific instance of CacheExpirationActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheExpirationActionParametersARM(subject CacheExpirationActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheExpirationActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheExpirationActionParametersARM instances for property testing - lazily instantiated by
// CacheExpirationActionParametersARMGenerator()
var cacheExpirationActionParametersARMGenerator gopter.Gen

// CacheExpirationActionParametersARMGenerator returns a generator of CacheExpirationActionParametersARM instances for property testing.
func CacheExpirationActionParametersARMGenerator() gopter.Gen {
	if cacheExpirationActionParametersARMGenerator != nil {
		return cacheExpirationActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheExpirationActionParametersARM(generators)
	cacheExpirationActionParametersARMGenerator = gen.Struct(reflect.TypeOf(CacheExpirationActionParametersARM{}), generators)

	return cacheExpirationActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForCacheExpirationActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheExpirationActionParametersARM(gens map[string]gopter.Gen) {
	gens["CacheBehavior"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParameters_CacheBehavior_BypassCache, CacheExpirationActionParameters_CacheBehavior_Override, CacheExpirationActionParameters_CacheBehavior_SetIfMissing))
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["CacheType"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParameters_CacheType_All))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParameters_TypeName_DeliveryRuleCacheExpirationActionParameters))
}

func Test_CacheKeyQueryStringActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheKeyQueryStringActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheKeyQueryStringActionParametersARM, CacheKeyQueryStringActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheKeyQueryStringActionParametersARM runs a test to see if a specific instance of CacheKeyQueryStringActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheKeyQueryStringActionParametersARM(subject CacheKeyQueryStringActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheKeyQueryStringActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheKeyQueryStringActionParametersARM instances for property testing - lazily instantiated by
// CacheKeyQueryStringActionParametersARMGenerator()
var cacheKeyQueryStringActionParametersARMGenerator gopter.Gen

// CacheKeyQueryStringActionParametersARMGenerator returns a generator of CacheKeyQueryStringActionParametersARM instances for property testing.
func CacheKeyQueryStringActionParametersARMGenerator() gopter.Gen {
	if cacheKeyQueryStringActionParametersARMGenerator != nil {
		return cacheKeyQueryStringActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParametersARM(generators)
	cacheKeyQueryStringActionParametersARMGenerator = gen.Struct(reflect.TypeOf(CacheKeyQueryStringActionParametersARM{}), generators)

	return cacheKeyQueryStringActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParametersARM(gens map[string]gopter.Gen) {
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringBehavior"] = gen.PtrOf(gen.OneConstOf(
		CacheKeyQueryStringActionParameters_QueryStringBehavior_Exclude,
		CacheKeyQueryStringActionParameters_QueryStringBehavior_ExcludeAll,
		CacheKeyQueryStringActionParameters_QueryStringBehavior_Include,
		CacheKeyQueryStringActionParameters_QueryStringBehavior_IncludeAll))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CacheKeyQueryStringActionParameters_TypeName_DeliveryRuleCacheKeyQueryStringBehaviorActionParameters))
}

func Test_ClientPortMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClientPortMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClientPortMatchConditionParametersARM, ClientPortMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClientPortMatchConditionParametersARM runs a test to see if a specific instance of ClientPortMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForClientPortMatchConditionParametersARM(subject ClientPortMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClientPortMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClientPortMatchConditionParametersARM instances for property testing - lazily instantiated by
// ClientPortMatchConditionParametersARMGenerator()
var clientPortMatchConditionParametersARMGenerator gopter.Gen

// ClientPortMatchConditionParametersARMGenerator returns a generator of ClientPortMatchConditionParametersARM instances for property testing.
func ClientPortMatchConditionParametersARMGenerator() gopter.Gen {
	if clientPortMatchConditionParametersARMGenerator != nil {
		return clientPortMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClientPortMatchConditionParametersARM(generators)
	clientPortMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(ClientPortMatchConditionParametersARM{}), generators)

	return clientPortMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForClientPortMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClientPortMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		ClientPortMatchConditionParameters_Operator_Any,
		ClientPortMatchConditionParameters_Operator_BeginsWith,
		ClientPortMatchConditionParameters_Operator_Contains,
		ClientPortMatchConditionParameters_Operator_EndsWith,
		ClientPortMatchConditionParameters_Operator_Equal,
		ClientPortMatchConditionParameters_Operator_GreaterThan,
		ClientPortMatchConditionParameters_Operator_GreaterThanOrEqual,
		ClientPortMatchConditionParameters_Operator_LessThan,
		ClientPortMatchConditionParameters_Operator_LessThanOrEqual,
		ClientPortMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		ClientPortMatchConditionParameters_Transforms_Lowercase,
		ClientPortMatchConditionParameters_Transforms_RemoveNulls,
		ClientPortMatchConditionParameters_Transforms_Trim,
		ClientPortMatchConditionParameters_Transforms_Uppercase,
		ClientPortMatchConditionParameters_Transforms_UrlDecode,
		ClientPortMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(ClientPortMatchConditionParameters_TypeName_DeliveryRuleClientPortConditionParameters))
}

func Test_CookiesMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CookiesMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCookiesMatchConditionParametersARM, CookiesMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCookiesMatchConditionParametersARM runs a test to see if a specific instance of CookiesMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCookiesMatchConditionParametersARM(subject CookiesMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CookiesMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CookiesMatchConditionParametersARM instances for property testing - lazily instantiated by
// CookiesMatchConditionParametersARMGenerator()
var cookiesMatchConditionParametersARMGenerator gopter.Gen

// CookiesMatchConditionParametersARMGenerator returns a generator of CookiesMatchConditionParametersARM instances for property testing.
func CookiesMatchConditionParametersARMGenerator() gopter.Gen {
	if cookiesMatchConditionParametersARMGenerator != nil {
		return cookiesMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCookiesMatchConditionParametersARM(generators)
	cookiesMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(CookiesMatchConditionParametersARM{}), generators)

	return cookiesMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForCookiesMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCookiesMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		CookiesMatchConditionParameters_Operator_Any,
		CookiesMatchConditionParameters_Operator_BeginsWith,
		CookiesMatchConditionParameters_Operator_Contains,
		CookiesMatchConditionParameters_Operator_EndsWith,
		CookiesMatchConditionParameters_Operator_Equal,
		CookiesMatchConditionParameters_Operator_GreaterThan,
		CookiesMatchConditionParameters_Operator_GreaterThanOrEqual,
		CookiesMatchConditionParameters_Operator_LessThan,
		CookiesMatchConditionParameters_Operator_LessThanOrEqual,
		CookiesMatchConditionParameters_Operator_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		CookiesMatchConditionParameters_Transforms_Lowercase,
		CookiesMatchConditionParameters_Transforms_RemoveNulls,
		CookiesMatchConditionParameters_Transforms_Trim,
		CookiesMatchConditionParameters_Transforms_Uppercase,
		CookiesMatchConditionParameters_Transforms_UrlDecode,
		CookiesMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CookiesMatchConditionParameters_TypeName_DeliveryRuleCookiesConditionParameters))
}

func Test_HeaderActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderActionParametersARM, HeaderActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderActionParametersARM runs a test to see if a specific instance of HeaderActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderActionParametersARM(subject HeaderActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderActionParametersARM instances for property testing - lazily instantiated by
// HeaderActionParametersARMGenerator()
var headerActionParametersARMGenerator gopter.Gen

// HeaderActionParametersARMGenerator returns a generator of HeaderActionParametersARM instances for property testing.
func HeaderActionParametersARMGenerator() gopter.Gen {
	if headerActionParametersARMGenerator != nil {
		return headerActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderActionParametersARM(generators)
	headerActionParametersARMGenerator = gen.Struct(reflect.TypeOf(HeaderActionParametersARM{}), generators)

	return headerActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForHeaderActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderActionParametersARM(gens map[string]gopter.Gen) {
	gens["HeaderAction"] = gen.PtrOf(gen.OneConstOf(HeaderActionParameters_HeaderAction_Append, HeaderActionParameters_HeaderAction_Delete, HeaderActionParameters_HeaderAction_Overwrite))
	gens["HeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HeaderActionParameters_TypeName_DeliveryRuleHeaderActionParameters))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_HostNameMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostNameMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostNameMatchConditionParametersARM, HostNameMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostNameMatchConditionParametersARM runs a test to see if a specific instance of HostNameMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHostNameMatchConditionParametersARM(subject HostNameMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostNameMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostNameMatchConditionParametersARM instances for property testing - lazily instantiated by
// HostNameMatchConditionParametersARMGenerator()
var hostNameMatchConditionParametersARMGenerator gopter.Gen

// HostNameMatchConditionParametersARMGenerator returns a generator of HostNameMatchConditionParametersARM instances for property testing.
func HostNameMatchConditionParametersARMGenerator() gopter.Gen {
	if hostNameMatchConditionParametersARMGenerator != nil {
		return hostNameMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostNameMatchConditionParametersARM(generators)
	hostNameMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(HostNameMatchConditionParametersARM{}), generators)

	return hostNameMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForHostNameMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostNameMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		HostNameMatchConditionParameters_Operator_Any,
		HostNameMatchConditionParameters_Operator_BeginsWith,
		HostNameMatchConditionParameters_Operator_Contains,
		HostNameMatchConditionParameters_Operator_EndsWith,
		HostNameMatchConditionParameters_Operator_Equal,
		HostNameMatchConditionParameters_Operator_GreaterThan,
		HostNameMatchConditionParameters_Operator_GreaterThanOrEqual,
		HostNameMatchConditionParameters_Operator_LessThan,
		HostNameMatchConditionParameters_Operator_LessThanOrEqual,
		HostNameMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		HostNameMatchConditionParameters_Transforms_Lowercase,
		HostNameMatchConditionParameters_Transforms_RemoveNulls,
		HostNameMatchConditionParameters_Transforms_Trim,
		HostNameMatchConditionParameters_Transforms_Uppercase,
		HostNameMatchConditionParameters_Transforms_UrlDecode,
		HostNameMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HostNameMatchConditionParameters_TypeName_DeliveryRuleHostNameConditionParameters))
}

func Test_HttpVersionMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpVersionMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpVersionMatchConditionParametersARM, HttpVersionMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpVersionMatchConditionParametersARM runs a test to see if a specific instance of HttpVersionMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpVersionMatchConditionParametersARM(subject HttpVersionMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpVersionMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpVersionMatchConditionParametersARM instances for property testing - lazily instantiated by
// HttpVersionMatchConditionParametersARMGenerator()
var httpVersionMatchConditionParametersARMGenerator gopter.Gen

// HttpVersionMatchConditionParametersARMGenerator returns a generator of HttpVersionMatchConditionParametersARM instances for property testing.
func HttpVersionMatchConditionParametersARMGenerator() gopter.Gen {
	if httpVersionMatchConditionParametersARMGenerator != nil {
		return httpVersionMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParametersARM(generators)
	httpVersionMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(HttpVersionMatchConditionParametersARM{}), generators)

	return httpVersionMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(HttpVersionMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		HttpVersionMatchConditionParameters_Transforms_Lowercase,
		HttpVersionMatchConditionParameters_Transforms_RemoveNulls,
		HttpVersionMatchConditionParameters_Transforms_Trim,
		HttpVersionMatchConditionParameters_Transforms_Uppercase,
		HttpVersionMatchConditionParameters_Transforms_UrlDecode,
		HttpVersionMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HttpVersionMatchConditionParameters_TypeName_DeliveryRuleHttpVersionConditionParameters))
}

func Test_IsDeviceMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IsDeviceMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIsDeviceMatchConditionParametersARM, IsDeviceMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIsDeviceMatchConditionParametersARM runs a test to see if a specific instance of IsDeviceMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIsDeviceMatchConditionParametersARM(subject IsDeviceMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IsDeviceMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IsDeviceMatchConditionParametersARM instances for property testing - lazily instantiated by
// IsDeviceMatchConditionParametersARMGenerator()
var isDeviceMatchConditionParametersARMGenerator gopter.Gen

// IsDeviceMatchConditionParametersARMGenerator returns a generator of IsDeviceMatchConditionParametersARM instances for property testing.
func IsDeviceMatchConditionParametersARMGenerator() gopter.Gen {
	if isDeviceMatchConditionParametersARMGenerator != nil {
		return isDeviceMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParametersARM(generators)
	isDeviceMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(IsDeviceMatchConditionParametersARM{}), generators)

	return isDeviceMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(IsDeviceMatchConditionParameters_MatchValues_Desktop, IsDeviceMatchConditionParameters_MatchValues_Mobile))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(IsDeviceMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		IsDeviceMatchConditionParameters_Transforms_Lowercase,
		IsDeviceMatchConditionParameters_Transforms_RemoveNulls,
		IsDeviceMatchConditionParameters_Transforms_Trim,
		IsDeviceMatchConditionParameters_Transforms_Uppercase,
		IsDeviceMatchConditionParameters_Transforms_UrlDecode,
		IsDeviceMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(IsDeviceMatchConditionParameters_TypeName_DeliveryRuleIsDeviceConditionParameters))
}

func Test_OriginGroupOverrideActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverrideActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverrideActionParametersARM, OriginGroupOverrideActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverrideActionParametersARM runs a test to see if a specific instance of OriginGroupOverrideActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverrideActionParametersARM(subject OriginGroupOverrideActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverrideActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverrideActionParametersARM instances for property testing - lazily instantiated by
// OriginGroupOverrideActionParametersARMGenerator()
var originGroupOverrideActionParametersARMGenerator gopter.Gen

// OriginGroupOverrideActionParametersARMGenerator returns a generator of OriginGroupOverrideActionParametersARM instances for property testing.
// We first initialize originGroupOverrideActionParametersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideActionParametersARMGenerator() gopter.Gen {
	if originGroupOverrideActionParametersARMGenerator != nil {
		return originGroupOverrideActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParametersARM(generators)
	originGroupOverrideActionParametersARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionParametersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParametersARM(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParametersARM(generators)
	originGroupOverrideActionParametersARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionParametersARM{}), generators)

	return originGroupOverrideActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParametersARM(gens map[string]gopter.Gen) {
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(OriginGroupOverrideActionParameters_TypeName_DeliveryRuleOriginGroupOverrideActionParameters))
}

// AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParametersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParametersARM(gens map[string]gopter.Gen) {
	gens["OriginGroup"] = gen.PtrOf(ResourceReferenceARMGenerator())
}

func Test_PostArgsMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PostArgsMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPostArgsMatchConditionParametersARM, PostArgsMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPostArgsMatchConditionParametersARM runs a test to see if a specific instance of PostArgsMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPostArgsMatchConditionParametersARM(subject PostArgsMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PostArgsMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PostArgsMatchConditionParametersARM instances for property testing - lazily instantiated by
// PostArgsMatchConditionParametersARMGenerator()
var postArgsMatchConditionParametersARMGenerator gopter.Gen

// PostArgsMatchConditionParametersARMGenerator returns a generator of PostArgsMatchConditionParametersARM instances for property testing.
func PostArgsMatchConditionParametersARMGenerator() gopter.Gen {
	if postArgsMatchConditionParametersARMGenerator != nil {
		return postArgsMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPostArgsMatchConditionParametersARM(generators)
	postArgsMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(PostArgsMatchConditionParametersARM{}), generators)

	return postArgsMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForPostArgsMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPostArgsMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		PostArgsMatchConditionParameters_Operator_Any,
		PostArgsMatchConditionParameters_Operator_BeginsWith,
		PostArgsMatchConditionParameters_Operator_Contains,
		PostArgsMatchConditionParameters_Operator_EndsWith,
		PostArgsMatchConditionParameters_Operator_Equal,
		PostArgsMatchConditionParameters_Operator_GreaterThan,
		PostArgsMatchConditionParameters_Operator_GreaterThanOrEqual,
		PostArgsMatchConditionParameters_Operator_LessThan,
		PostArgsMatchConditionParameters_Operator_LessThanOrEqual,
		PostArgsMatchConditionParameters_Operator_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		PostArgsMatchConditionParameters_Transforms_Lowercase,
		PostArgsMatchConditionParameters_Transforms_RemoveNulls,
		PostArgsMatchConditionParameters_Transforms_Trim,
		PostArgsMatchConditionParameters_Transforms_Uppercase,
		PostArgsMatchConditionParameters_Transforms_UrlDecode,
		PostArgsMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(PostArgsMatchConditionParameters_TypeName_DeliveryRulePostArgsConditionParameters))
}

func Test_QueryStringMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QueryStringMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForQueryStringMatchConditionParametersARM, QueryStringMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQueryStringMatchConditionParametersARM runs a test to see if a specific instance of QueryStringMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForQueryStringMatchConditionParametersARM(subject QueryStringMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QueryStringMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QueryStringMatchConditionParametersARM instances for property testing - lazily instantiated by
// QueryStringMatchConditionParametersARMGenerator()
var queryStringMatchConditionParametersARMGenerator gopter.Gen

// QueryStringMatchConditionParametersARMGenerator returns a generator of QueryStringMatchConditionParametersARM instances for property testing.
func QueryStringMatchConditionParametersARMGenerator() gopter.Gen {
	if queryStringMatchConditionParametersARMGenerator != nil {
		return queryStringMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQueryStringMatchConditionParametersARM(generators)
	queryStringMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(QueryStringMatchConditionParametersARM{}), generators)

	return queryStringMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForQueryStringMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQueryStringMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		QueryStringMatchConditionParameters_Operator_Any,
		QueryStringMatchConditionParameters_Operator_BeginsWith,
		QueryStringMatchConditionParameters_Operator_Contains,
		QueryStringMatchConditionParameters_Operator_EndsWith,
		QueryStringMatchConditionParameters_Operator_Equal,
		QueryStringMatchConditionParameters_Operator_GreaterThan,
		QueryStringMatchConditionParameters_Operator_GreaterThanOrEqual,
		QueryStringMatchConditionParameters_Operator_LessThan,
		QueryStringMatchConditionParameters_Operator_LessThanOrEqual,
		QueryStringMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		QueryStringMatchConditionParameters_Transforms_Lowercase,
		QueryStringMatchConditionParameters_Transforms_RemoveNulls,
		QueryStringMatchConditionParameters_Transforms_Trim,
		QueryStringMatchConditionParameters_Transforms_Uppercase,
		QueryStringMatchConditionParameters_Transforms_UrlDecode,
		QueryStringMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(QueryStringMatchConditionParameters_TypeName_DeliveryRuleQueryStringConditionParameters))
}

func Test_RemoteAddressMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RemoteAddressMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRemoteAddressMatchConditionParametersARM, RemoteAddressMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRemoteAddressMatchConditionParametersARM runs a test to see if a specific instance of RemoteAddressMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRemoteAddressMatchConditionParametersARM(subject RemoteAddressMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RemoteAddressMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RemoteAddressMatchConditionParametersARM instances for property testing - lazily instantiated by
// RemoteAddressMatchConditionParametersARMGenerator()
var remoteAddressMatchConditionParametersARMGenerator gopter.Gen

// RemoteAddressMatchConditionParametersARMGenerator returns a generator of RemoteAddressMatchConditionParametersARM instances for property testing.
func RemoteAddressMatchConditionParametersARMGenerator() gopter.Gen {
	if remoteAddressMatchConditionParametersARMGenerator != nil {
		return remoteAddressMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParametersARM(generators)
	remoteAddressMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(RemoteAddressMatchConditionParametersARM{}), generators)

	return remoteAddressMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RemoteAddressMatchConditionParameters_Operator_Any, RemoteAddressMatchConditionParameters_Operator_GeoMatch, RemoteAddressMatchConditionParameters_Operator_IPMatch))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RemoteAddressMatchConditionParameters_Transforms_Lowercase,
		RemoteAddressMatchConditionParameters_Transforms_RemoveNulls,
		RemoteAddressMatchConditionParameters_Transforms_Trim,
		RemoteAddressMatchConditionParameters_Transforms_Uppercase,
		RemoteAddressMatchConditionParameters_Transforms_UrlDecode,
		RemoteAddressMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RemoteAddressMatchConditionParameters_TypeName_DeliveryRuleRemoteAddressConditionParameters))
}

func Test_RequestBodyMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestBodyMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestBodyMatchConditionParametersARM, RequestBodyMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestBodyMatchConditionParametersARM runs a test to see if a specific instance of RequestBodyMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestBodyMatchConditionParametersARM(subject RequestBodyMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestBodyMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestBodyMatchConditionParametersARM instances for property testing - lazily instantiated by
// RequestBodyMatchConditionParametersARMGenerator()
var requestBodyMatchConditionParametersARMGenerator gopter.Gen

// RequestBodyMatchConditionParametersARMGenerator returns a generator of RequestBodyMatchConditionParametersARM instances for property testing.
func RequestBodyMatchConditionParametersARMGenerator() gopter.Gen {
	if requestBodyMatchConditionParametersARMGenerator != nil {
		return requestBodyMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParametersARM(generators)
	requestBodyMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(RequestBodyMatchConditionParametersARM{}), generators)

	return requestBodyMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestBodyMatchConditionParameters_Operator_Any,
		RequestBodyMatchConditionParameters_Operator_BeginsWith,
		RequestBodyMatchConditionParameters_Operator_Contains,
		RequestBodyMatchConditionParameters_Operator_EndsWith,
		RequestBodyMatchConditionParameters_Operator_Equal,
		RequestBodyMatchConditionParameters_Operator_GreaterThan,
		RequestBodyMatchConditionParameters_Operator_GreaterThanOrEqual,
		RequestBodyMatchConditionParameters_Operator_LessThan,
		RequestBodyMatchConditionParameters_Operator_LessThanOrEqual,
		RequestBodyMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestBodyMatchConditionParameters_Transforms_Lowercase,
		RequestBodyMatchConditionParameters_Transforms_RemoveNulls,
		RequestBodyMatchConditionParameters_Transforms_Trim,
		RequestBodyMatchConditionParameters_Transforms_Uppercase,
		RequestBodyMatchConditionParameters_Transforms_UrlDecode,
		RequestBodyMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestBodyMatchConditionParameters_TypeName_DeliveryRuleRequestBodyConditionParameters))
}

func Test_RequestHeaderMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestHeaderMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestHeaderMatchConditionParametersARM, RequestHeaderMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestHeaderMatchConditionParametersARM runs a test to see if a specific instance of RequestHeaderMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestHeaderMatchConditionParametersARM(subject RequestHeaderMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestHeaderMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestHeaderMatchConditionParametersARM instances for property testing - lazily instantiated by
// RequestHeaderMatchConditionParametersARMGenerator()
var requestHeaderMatchConditionParametersARMGenerator gopter.Gen

// RequestHeaderMatchConditionParametersARMGenerator returns a generator of RequestHeaderMatchConditionParametersARM instances for property testing.
func RequestHeaderMatchConditionParametersARMGenerator() gopter.Gen {
	if requestHeaderMatchConditionParametersARMGenerator != nil {
		return requestHeaderMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParametersARM(generators)
	requestHeaderMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(RequestHeaderMatchConditionParametersARM{}), generators)

	return requestHeaderMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestHeaderMatchConditionParameters_Operator_Any,
		RequestHeaderMatchConditionParameters_Operator_BeginsWith,
		RequestHeaderMatchConditionParameters_Operator_Contains,
		RequestHeaderMatchConditionParameters_Operator_EndsWith,
		RequestHeaderMatchConditionParameters_Operator_Equal,
		RequestHeaderMatchConditionParameters_Operator_GreaterThan,
		RequestHeaderMatchConditionParameters_Operator_GreaterThanOrEqual,
		RequestHeaderMatchConditionParameters_Operator_LessThan,
		RequestHeaderMatchConditionParameters_Operator_LessThanOrEqual,
		RequestHeaderMatchConditionParameters_Operator_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestHeaderMatchConditionParameters_Transforms_Lowercase,
		RequestHeaderMatchConditionParameters_Transforms_RemoveNulls,
		RequestHeaderMatchConditionParameters_Transforms_Trim,
		RequestHeaderMatchConditionParameters_Transforms_Uppercase,
		RequestHeaderMatchConditionParameters_Transforms_UrlDecode,
		RequestHeaderMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestHeaderMatchConditionParameters_TypeName_DeliveryRuleRequestHeaderConditionParameters))
}

func Test_RequestMethodMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestMethodMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestMethodMatchConditionParametersARM, RequestMethodMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestMethodMatchConditionParametersARM runs a test to see if a specific instance of RequestMethodMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestMethodMatchConditionParametersARM(subject RequestMethodMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestMethodMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestMethodMatchConditionParametersARM instances for property testing - lazily instantiated by
// RequestMethodMatchConditionParametersARMGenerator()
var requestMethodMatchConditionParametersARMGenerator gopter.Gen

// RequestMethodMatchConditionParametersARMGenerator returns a generator of RequestMethodMatchConditionParametersARM instances for property testing.
func RequestMethodMatchConditionParametersARMGenerator() gopter.Gen {
	if requestMethodMatchConditionParametersARMGenerator != nil {
		return requestMethodMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParametersARM(generators)
	requestMethodMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(RequestMethodMatchConditionParametersARM{}), generators)

	return requestMethodMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(
		RequestMethodMatchConditionParameters_MatchValues_DELETE,
		RequestMethodMatchConditionParameters_MatchValues_GET,
		RequestMethodMatchConditionParameters_MatchValues_HEAD,
		RequestMethodMatchConditionParameters_MatchValues_OPTIONS,
		RequestMethodMatchConditionParameters_MatchValues_POST,
		RequestMethodMatchConditionParameters_MatchValues_PUT,
		RequestMethodMatchConditionParameters_MatchValues_TRACE))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RequestMethodMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestMethodMatchConditionParameters_Transforms_Lowercase,
		RequestMethodMatchConditionParameters_Transforms_RemoveNulls,
		RequestMethodMatchConditionParameters_Transforms_Trim,
		RequestMethodMatchConditionParameters_Transforms_Uppercase,
		RequestMethodMatchConditionParameters_Transforms_UrlDecode,
		RequestMethodMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestMethodMatchConditionParameters_TypeName_DeliveryRuleRequestMethodConditionParameters))
}

func Test_RequestSchemeMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestSchemeMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestSchemeMatchConditionParametersARM, RequestSchemeMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestSchemeMatchConditionParametersARM runs a test to see if a specific instance of RequestSchemeMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestSchemeMatchConditionParametersARM(subject RequestSchemeMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestSchemeMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestSchemeMatchConditionParametersARM instances for property testing - lazily instantiated by
// RequestSchemeMatchConditionParametersARMGenerator()
var requestSchemeMatchConditionParametersARMGenerator gopter.Gen

// RequestSchemeMatchConditionParametersARMGenerator returns a generator of RequestSchemeMatchConditionParametersARM instances for property testing.
func RequestSchemeMatchConditionParametersARMGenerator() gopter.Gen {
	if requestSchemeMatchConditionParametersARMGenerator != nil {
		return requestSchemeMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParametersARM(generators)
	requestSchemeMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(RequestSchemeMatchConditionParametersARM{}), generators)

	return requestSchemeMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(RequestSchemeMatchConditionParameters_MatchValues_HTTP, RequestSchemeMatchConditionParameters_MatchValues_HTTPS))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RequestSchemeMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestSchemeMatchConditionParameters_Transforms_Lowercase,
		RequestSchemeMatchConditionParameters_Transforms_RemoveNulls,
		RequestSchemeMatchConditionParameters_Transforms_Trim,
		RequestSchemeMatchConditionParameters_Transforms_Uppercase,
		RequestSchemeMatchConditionParameters_Transforms_UrlDecode,
		RequestSchemeMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestSchemeMatchConditionParameters_TypeName_DeliveryRuleRequestSchemeConditionParameters))
}

func Test_RequestUriMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestUriMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestUriMatchConditionParametersARM, RequestUriMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestUriMatchConditionParametersARM runs a test to see if a specific instance of RequestUriMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestUriMatchConditionParametersARM(subject RequestUriMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestUriMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestUriMatchConditionParametersARM instances for property testing - lazily instantiated by
// RequestUriMatchConditionParametersARMGenerator()
var requestUriMatchConditionParametersARMGenerator gopter.Gen

// RequestUriMatchConditionParametersARMGenerator returns a generator of RequestUriMatchConditionParametersARM instances for property testing.
func RequestUriMatchConditionParametersARMGenerator() gopter.Gen {
	if requestUriMatchConditionParametersARMGenerator != nil {
		return requestUriMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestUriMatchConditionParametersARM(generators)
	requestUriMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(RequestUriMatchConditionParametersARM{}), generators)

	return requestUriMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestUriMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestUriMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestUriMatchConditionParameters_Operator_Any,
		RequestUriMatchConditionParameters_Operator_BeginsWith,
		RequestUriMatchConditionParameters_Operator_Contains,
		RequestUriMatchConditionParameters_Operator_EndsWith,
		RequestUriMatchConditionParameters_Operator_Equal,
		RequestUriMatchConditionParameters_Operator_GreaterThan,
		RequestUriMatchConditionParameters_Operator_GreaterThanOrEqual,
		RequestUriMatchConditionParameters_Operator_LessThan,
		RequestUriMatchConditionParameters_Operator_LessThanOrEqual,
		RequestUriMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestUriMatchConditionParameters_Transforms_Lowercase,
		RequestUriMatchConditionParameters_Transforms_RemoveNulls,
		RequestUriMatchConditionParameters_Transforms_Trim,
		RequestUriMatchConditionParameters_Transforms_Uppercase,
		RequestUriMatchConditionParameters_Transforms_UrlDecode,
		RequestUriMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestUriMatchConditionParameters_TypeName_DeliveryRuleRequestUriConditionParameters))
}

func Test_RouteConfigurationOverrideActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteConfigurationOverrideActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteConfigurationOverrideActionParametersARM, RouteConfigurationOverrideActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteConfigurationOverrideActionParametersARM runs a test to see if a specific instance of RouteConfigurationOverrideActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteConfigurationOverrideActionParametersARM(subject RouteConfigurationOverrideActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteConfigurationOverrideActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteConfigurationOverrideActionParametersARM instances for property testing - lazily instantiated by
// RouteConfigurationOverrideActionParametersARMGenerator()
var routeConfigurationOverrideActionParametersARMGenerator gopter.Gen

// RouteConfigurationOverrideActionParametersARMGenerator returns a generator of RouteConfigurationOverrideActionParametersARM instances for property testing.
// We first initialize routeConfigurationOverrideActionParametersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RouteConfigurationOverrideActionParametersARMGenerator() gopter.Gen {
	if routeConfigurationOverrideActionParametersARMGenerator != nil {
		return routeConfigurationOverrideActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParametersARM(generators)
	routeConfigurationOverrideActionParametersARMGenerator = gen.Struct(reflect.TypeOf(RouteConfigurationOverrideActionParametersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParametersARM(generators)
	AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParametersARM(generators)
	routeConfigurationOverrideActionParametersARMGenerator = gen.Struct(reflect.TypeOf(RouteConfigurationOverrideActionParametersARM{}), generators)

	return routeConfigurationOverrideActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParametersARM(gens map[string]gopter.Gen) {
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RouteConfigurationOverrideActionParameters_TypeName_DeliveryRuleRouteConfigurationOverrideActionParameters))
}

// AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParametersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParametersARM(gens map[string]gopter.Gen) {
	gens["CacheConfiguration"] = gen.PtrOf(CacheConfigurationARMGenerator())
	gens["OriginGroupOverride"] = gen.PtrOf(OriginGroupOverrideARMGenerator())
}

func Test_ServerPortMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerPortMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerPortMatchConditionParametersARM, ServerPortMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerPortMatchConditionParametersARM runs a test to see if a specific instance of ServerPortMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServerPortMatchConditionParametersARM(subject ServerPortMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerPortMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerPortMatchConditionParametersARM instances for property testing - lazily instantiated by
// ServerPortMatchConditionParametersARMGenerator()
var serverPortMatchConditionParametersARMGenerator gopter.Gen

// ServerPortMatchConditionParametersARMGenerator returns a generator of ServerPortMatchConditionParametersARM instances for property testing.
func ServerPortMatchConditionParametersARMGenerator() gopter.Gen {
	if serverPortMatchConditionParametersARMGenerator != nil {
		return serverPortMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerPortMatchConditionParametersARM(generators)
	serverPortMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(ServerPortMatchConditionParametersARM{}), generators)

	return serverPortMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForServerPortMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerPortMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		ServerPortMatchConditionParameters_Operator_Any,
		ServerPortMatchConditionParameters_Operator_BeginsWith,
		ServerPortMatchConditionParameters_Operator_Contains,
		ServerPortMatchConditionParameters_Operator_EndsWith,
		ServerPortMatchConditionParameters_Operator_Equal,
		ServerPortMatchConditionParameters_Operator_GreaterThan,
		ServerPortMatchConditionParameters_Operator_GreaterThanOrEqual,
		ServerPortMatchConditionParameters_Operator_LessThan,
		ServerPortMatchConditionParameters_Operator_LessThanOrEqual,
		ServerPortMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		ServerPortMatchConditionParameters_Transforms_Lowercase,
		ServerPortMatchConditionParameters_Transforms_RemoveNulls,
		ServerPortMatchConditionParameters_Transforms_Trim,
		ServerPortMatchConditionParameters_Transforms_Uppercase,
		ServerPortMatchConditionParameters_Transforms_UrlDecode,
		ServerPortMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(ServerPortMatchConditionParameters_TypeName_DeliveryRuleServerPortConditionParameters))
}

func Test_SocketAddrMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SocketAddrMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSocketAddrMatchConditionParametersARM, SocketAddrMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSocketAddrMatchConditionParametersARM runs a test to see if a specific instance of SocketAddrMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSocketAddrMatchConditionParametersARM(subject SocketAddrMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SocketAddrMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SocketAddrMatchConditionParametersARM instances for property testing - lazily instantiated by
// SocketAddrMatchConditionParametersARMGenerator()
var socketAddrMatchConditionParametersARMGenerator gopter.Gen

// SocketAddrMatchConditionParametersARMGenerator returns a generator of SocketAddrMatchConditionParametersARM instances for property testing.
func SocketAddrMatchConditionParametersARMGenerator() gopter.Gen {
	if socketAddrMatchConditionParametersARMGenerator != nil {
		return socketAddrMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParametersARM(generators)
	socketAddrMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(SocketAddrMatchConditionParametersARM{}), generators)

	return socketAddrMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(SocketAddrMatchConditionParameters_Operator_Any, SocketAddrMatchConditionParameters_Operator_IPMatch))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		SocketAddrMatchConditionParameters_Transforms_Lowercase,
		SocketAddrMatchConditionParameters_Transforms_RemoveNulls,
		SocketAddrMatchConditionParameters_Transforms_Trim,
		SocketAddrMatchConditionParameters_Transforms_Uppercase,
		SocketAddrMatchConditionParameters_Transforms_UrlDecode,
		SocketAddrMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(SocketAddrMatchConditionParameters_TypeName_DeliveryRuleSocketAddrConditionParameters))
}

func Test_SslProtocolMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SslProtocolMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSslProtocolMatchConditionParametersARM, SslProtocolMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSslProtocolMatchConditionParametersARM runs a test to see if a specific instance of SslProtocolMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSslProtocolMatchConditionParametersARM(subject SslProtocolMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SslProtocolMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SslProtocolMatchConditionParametersARM instances for property testing - lazily instantiated by
// SslProtocolMatchConditionParametersARMGenerator()
var sslProtocolMatchConditionParametersARMGenerator gopter.Gen

// SslProtocolMatchConditionParametersARMGenerator returns a generator of SslProtocolMatchConditionParametersARM instances for property testing.
func SslProtocolMatchConditionParametersARMGenerator() gopter.Gen {
	if sslProtocolMatchConditionParametersARMGenerator != nil {
		return sslProtocolMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParametersARM(generators)
	sslProtocolMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(SslProtocolMatchConditionParametersARM{}), generators)

	return sslProtocolMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(SslProtocolMatchConditionParameters_MatchValues_TLSv1, SslProtocolMatchConditionParameters_MatchValues_TLSv11, SslProtocolMatchConditionParameters_MatchValues_TLSv12))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(SslProtocolMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		SslProtocolMatchConditionParameters_Transforms_Lowercase,
		SslProtocolMatchConditionParameters_Transforms_RemoveNulls,
		SslProtocolMatchConditionParameters_Transforms_Trim,
		SslProtocolMatchConditionParameters_Transforms_Uppercase,
		SslProtocolMatchConditionParameters_Transforms_UrlDecode,
		SslProtocolMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(SslProtocolMatchConditionParameters_TypeName_DeliveryRuleSslProtocolConditionParameters))
}

func Test_UrlFileExtensionMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlFileExtensionMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlFileExtensionMatchConditionParametersARM, UrlFileExtensionMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlFileExtensionMatchConditionParametersARM runs a test to see if a specific instance of UrlFileExtensionMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlFileExtensionMatchConditionParametersARM(subject UrlFileExtensionMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlFileExtensionMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlFileExtensionMatchConditionParametersARM instances for property testing - lazily instantiated by
// UrlFileExtensionMatchConditionParametersARMGenerator()
var urlFileExtensionMatchConditionParametersARMGenerator gopter.Gen

// UrlFileExtensionMatchConditionParametersARMGenerator returns a generator of UrlFileExtensionMatchConditionParametersARM instances for property testing.
func UrlFileExtensionMatchConditionParametersARMGenerator() gopter.Gen {
	if urlFileExtensionMatchConditionParametersARMGenerator != nil {
		return urlFileExtensionMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParametersARM(generators)
	urlFileExtensionMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(UrlFileExtensionMatchConditionParametersARM{}), generators)

	return urlFileExtensionMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlFileExtensionMatchConditionParameters_Operator_Any,
		UrlFileExtensionMatchConditionParameters_Operator_BeginsWith,
		UrlFileExtensionMatchConditionParameters_Operator_Contains,
		UrlFileExtensionMatchConditionParameters_Operator_EndsWith,
		UrlFileExtensionMatchConditionParameters_Operator_Equal,
		UrlFileExtensionMatchConditionParameters_Operator_GreaterThan,
		UrlFileExtensionMatchConditionParameters_Operator_GreaterThanOrEqual,
		UrlFileExtensionMatchConditionParameters_Operator_LessThan,
		UrlFileExtensionMatchConditionParameters_Operator_LessThanOrEqual,
		UrlFileExtensionMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		UrlFileExtensionMatchConditionParameters_Transforms_Lowercase,
		UrlFileExtensionMatchConditionParameters_Transforms_RemoveNulls,
		UrlFileExtensionMatchConditionParameters_Transforms_Trim,
		UrlFileExtensionMatchConditionParameters_Transforms_Uppercase,
		UrlFileExtensionMatchConditionParameters_Transforms_UrlDecode,
		UrlFileExtensionMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlFileExtensionMatchConditionParameters_TypeName_DeliveryRuleUrlFileExtensionMatchConditionParameters))
}

func Test_UrlFileNameMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlFileNameMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlFileNameMatchConditionParametersARM, UrlFileNameMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlFileNameMatchConditionParametersARM runs a test to see if a specific instance of UrlFileNameMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlFileNameMatchConditionParametersARM(subject UrlFileNameMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlFileNameMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlFileNameMatchConditionParametersARM instances for property testing - lazily instantiated by
// UrlFileNameMatchConditionParametersARMGenerator()
var urlFileNameMatchConditionParametersARMGenerator gopter.Gen

// UrlFileNameMatchConditionParametersARMGenerator returns a generator of UrlFileNameMatchConditionParametersARM instances for property testing.
func UrlFileNameMatchConditionParametersARMGenerator() gopter.Gen {
	if urlFileNameMatchConditionParametersARMGenerator != nil {
		return urlFileNameMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParametersARM(generators)
	urlFileNameMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(UrlFileNameMatchConditionParametersARM{}), generators)

	return urlFileNameMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlFileNameMatchConditionParameters_Operator_Any,
		UrlFileNameMatchConditionParameters_Operator_BeginsWith,
		UrlFileNameMatchConditionParameters_Operator_Contains,
		UrlFileNameMatchConditionParameters_Operator_EndsWith,
		UrlFileNameMatchConditionParameters_Operator_Equal,
		UrlFileNameMatchConditionParameters_Operator_GreaterThan,
		UrlFileNameMatchConditionParameters_Operator_GreaterThanOrEqual,
		UrlFileNameMatchConditionParameters_Operator_LessThan,
		UrlFileNameMatchConditionParameters_Operator_LessThanOrEqual,
		UrlFileNameMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		UrlFileNameMatchConditionParameters_Transforms_Lowercase,
		UrlFileNameMatchConditionParameters_Transforms_RemoveNulls,
		UrlFileNameMatchConditionParameters_Transforms_Trim,
		UrlFileNameMatchConditionParameters_Transforms_Uppercase,
		UrlFileNameMatchConditionParameters_Transforms_UrlDecode,
		UrlFileNameMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlFileNameMatchConditionParameters_TypeName_DeliveryRuleUrlFilenameConditionParameters))
}

func Test_UrlPathMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlPathMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlPathMatchConditionParametersARM, UrlPathMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlPathMatchConditionParametersARM runs a test to see if a specific instance of UrlPathMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlPathMatchConditionParametersARM(subject UrlPathMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlPathMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlPathMatchConditionParametersARM instances for property testing - lazily instantiated by
// UrlPathMatchConditionParametersARMGenerator()
var urlPathMatchConditionParametersARMGenerator gopter.Gen

// UrlPathMatchConditionParametersARMGenerator returns a generator of UrlPathMatchConditionParametersARM instances for property testing.
func UrlPathMatchConditionParametersARMGenerator() gopter.Gen {
	if urlPathMatchConditionParametersARMGenerator != nil {
		return urlPathMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlPathMatchConditionParametersARM(generators)
	urlPathMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(UrlPathMatchConditionParametersARM{}), generators)

	return urlPathMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlPathMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlPathMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlPathMatchConditionParameters_Operator_Any,
		UrlPathMatchConditionParameters_Operator_BeginsWith,
		UrlPathMatchConditionParameters_Operator_Contains,
		UrlPathMatchConditionParameters_Operator_EndsWith,
		UrlPathMatchConditionParameters_Operator_Equal,
		UrlPathMatchConditionParameters_Operator_GreaterThan,
		UrlPathMatchConditionParameters_Operator_GreaterThanOrEqual,
		UrlPathMatchConditionParameters_Operator_LessThan,
		UrlPathMatchConditionParameters_Operator_LessThanOrEqual,
		UrlPathMatchConditionParameters_Operator_RegEx,
		UrlPathMatchConditionParameters_Operator_Wildcard))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		UrlPathMatchConditionParameters_Transforms_Lowercase,
		UrlPathMatchConditionParameters_Transforms_RemoveNulls,
		UrlPathMatchConditionParameters_Transforms_Trim,
		UrlPathMatchConditionParameters_Transforms_Uppercase,
		UrlPathMatchConditionParameters_Transforms_UrlDecode,
		UrlPathMatchConditionParameters_Transforms_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlPathMatchConditionParameters_TypeName_DeliveryRuleUrlPathMatchConditionParameters))
}

func Test_UrlRedirectActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRedirectActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRedirectActionParametersARM, UrlRedirectActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRedirectActionParametersARM runs a test to see if a specific instance of UrlRedirectActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRedirectActionParametersARM(subject UrlRedirectActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRedirectActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRedirectActionParametersARM instances for property testing - lazily instantiated by
// UrlRedirectActionParametersARMGenerator()
var urlRedirectActionParametersARMGenerator gopter.Gen

// UrlRedirectActionParametersARMGenerator returns a generator of UrlRedirectActionParametersARM instances for property testing.
func UrlRedirectActionParametersARMGenerator() gopter.Gen {
	if urlRedirectActionParametersARMGenerator != nil {
		return urlRedirectActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectActionParametersARM(generators)
	urlRedirectActionParametersARMGenerator = gen.Struct(reflect.TypeOf(UrlRedirectActionParametersARM{}), generators)

	return urlRedirectActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlRedirectActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRedirectActionParametersARM(gens map[string]gopter.Gen) {
	gens["CustomFragment"] = gen.PtrOf(gen.AlphaString())
	gens["CustomHostname"] = gen.PtrOf(gen.AlphaString())
	gens["CustomPath"] = gen.PtrOf(gen.AlphaString())
	gens["CustomQueryString"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationProtocol"] = gen.PtrOf(gen.OneConstOf(UrlRedirectActionParameters_DestinationProtocol_Http, UrlRedirectActionParameters_DestinationProtocol_Https, UrlRedirectActionParameters_DestinationProtocol_MatchRequest))
	gens["RedirectType"] = gen.PtrOf(gen.OneConstOf(
		UrlRedirectActionParameters_RedirectType_Found,
		UrlRedirectActionParameters_RedirectType_Moved,
		UrlRedirectActionParameters_RedirectType_PermanentRedirect,
		UrlRedirectActionParameters_RedirectType_TemporaryRedirect))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlRedirectActionParameters_TypeName_DeliveryRuleUrlRedirectActionParameters))
}

func Test_UrlRewriteActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRewriteActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRewriteActionParametersARM, UrlRewriteActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRewriteActionParametersARM runs a test to see if a specific instance of UrlRewriteActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRewriteActionParametersARM(subject UrlRewriteActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRewriteActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRewriteActionParametersARM instances for property testing - lazily instantiated by
// UrlRewriteActionParametersARMGenerator()
var urlRewriteActionParametersARMGenerator gopter.Gen

// UrlRewriteActionParametersARMGenerator returns a generator of UrlRewriteActionParametersARM instances for property testing.
func UrlRewriteActionParametersARMGenerator() gopter.Gen {
	if urlRewriteActionParametersARMGenerator != nil {
		return urlRewriteActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteActionParametersARM(generators)
	urlRewriteActionParametersARMGenerator = gen.Struct(reflect.TypeOf(UrlRewriteActionParametersARM{}), generators)

	return urlRewriteActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlRewriteActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRewriteActionParametersARM(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(gen.AlphaString())
	gens["PreserveUnmatchedPath"] = gen.PtrOf(gen.Bool())
	gens["SourcePattern"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlRewriteActionParameters_TypeName_DeliveryRuleUrlRewriteActionParameters))
}

func Test_UrlSigningActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningActionParametersARM, UrlSigningActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningActionParametersARM runs a test to see if a specific instance of UrlSigningActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningActionParametersARM(subject UrlSigningActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningActionParametersARM instances for property testing - lazily instantiated by
// UrlSigningActionParametersARMGenerator()
var urlSigningActionParametersARMGenerator gopter.Gen

// UrlSigningActionParametersARMGenerator returns a generator of UrlSigningActionParametersARM instances for property testing.
// We first initialize urlSigningActionParametersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningActionParametersARMGenerator() gopter.Gen {
	if urlSigningActionParametersARMGenerator != nil {
		return urlSigningActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionParametersARM(generators)
	urlSigningActionParametersARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionParametersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionParametersARM(generators)
	AddRelatedPropertyGeneratorsForUrlSigningActionParametersARM(generators)
	urlSigningActionParametersARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionParametersARM{}), generators)

	return urlSigningActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningActionParametersARM(gens map[string]gopter.Gen) {
	gens["Algorithm"] = gen.PtrOf(gen.OneConstOf(UrlSigningActionParameters_Algorithm_SHA256))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlSigningActionParameters_TypeName_DeliveryRuleUrlSigningActionParameters))
}

// AddRelatedPropertyGeneratorsForUrlSigningActionParametersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningActionParametersARM(gens map[string]gopter.Gen) {
	gens["ParameterNameOverride"] = gen.SliceOf(UrlSigningParamIdentifierARMGenerator())
}

func Test_CacheConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheConfigurationARM, CacheConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheConfigurationARM runs a test to see if a specific instance of CacheConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheConfigurationARM(subject CacheConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheConfigurationARM instances for property testing - lazily instantiated by
// CacheConfigurationARMGenerator()
var cacheConfigurationARMGenerator gopter.Gen

// CacheConfigurationARMGenerator returns a generator of CacheConfigurationARM instances for property testing.
func CacheConfigurationARMGenerator() gopter.Gen {
	if cacheConfigurationARMGenerator != nil {
		return cacheConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheConfigurationARM(generators)
	cacheConfigurationARMGenerator = gen.Struct(reflect.TypeOf(CacheConfigurationARM{}), generators)

	return cacheConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForCacheConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheConfigurationARM(gens map[string]gopter.Gen) {
	gens["CacheBehavior"] = gen.PtrOf(gen.OneConstOf(CacheConfiguration_CacheBehavior_HonorOrigin, CacheConfiguration_CacheBehavior_OverrideAlways, CacheConfiguration_CacheBehavior_OverrideIfOriginMissing))
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.OneConstOf(CacheConfiguration_IsCompressionEnabled_Disabled, CacheConfiguration_IsCompressionEnabled_Enabled))
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		CacheConfiguration_QueryStringCachingBehavior_IgnoreQueryString,
		CacheConfiguration_QueryStringCachingBehavior_IgnoreSpecifiedQueryStrings,
		CacheConfiguration_QueryStringCachingBehavior_IncludeSpecifiedQueryStrings,
		CacheConfiguration_QueryStringCachingBehavior_UseQueryString))
}

func Test_OriginGroupOverrideARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverrideARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverrideARM, OriginGroupOverrideARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverrideARM runs a test to see if a specific instance of OriginGroupOverrideARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverrideARM(subject OriginGroupOverrideARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverrideARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverrideARM instances for property testing - lazily instantiated by
// OriginGroupOverrideARMGenerator()
var originGroupOverrideARMGenerator gopter.Gen

// OriginGroupOverrideARMGenerator returns a generator of OriginGroupOverrideARM instances for property testing.
// We first initialize originGroupOverrideARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideARMGenerator() gopter.Gen {
	if originGroupOverrideARMGenerator != nil {
		return originGroupOverrideARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideARM(generators)
	originGroupOverrideARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideARM(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverrideARM(generators)
	originGroupOverrideARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideARM{}), generators)

	return originGroupOverrideARMGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverrideARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverrideARM(gens map[string]gopter.Gen) {
	gens["ForwardingProtocol"] = gen.PtrOf(gen.OneConstOf(OriginGroupOverride_ForwardingProtocol_HttpOnly, OriginGroupOverride_ForwardingProtocol_HttpsOnly, OriginGroupOverride_ForwardingProtocol_MatchRequest))
}

// AddRelatedPropertyGeneratorsForOriginGroupOverrideARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverrideARM(gens map[string]gopter.Gen) {
	gens["OriginGroup"] = gen.PtrOf(ResourceReferenceARMGenerator())
}

func Test_UrlSigningParamIdentifierARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningParamIdentifierARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningParamIdentifierARM, UrlSigningParamIdentifierARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningParamIdentifierARM runs a test to see if a specific instance of UrlSigningParamIdentifierARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningParamIdentifierARM(subject UrlSigningParamIdentifierARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningParamIdentifierARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningParamIdentifierARM instances for property testing - lazily instantiated by
// UrlSigningParamIdentifierARMGenerator()
var urlSigningParamIdentifierARMGenerator gopter.Gen

// UrlSigningParamIdentifierARMGenerator returns a generator of UrlSigningParamIdentifierARM instances for property testing.
func UrlSigningParamIdentifierARMGenerator() gopter.Gen {
	if urlSigningParamIdentifierARMGenerator != nil {
		return urlSigningParamIdentifierARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningParamIdentifierARM(generators)
	urlSigningParamIdentifierARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningParamIdentifierARM{}), generators)

	return urlSigningParamIdentifierARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningParamIdentifierARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningParamIdentifierARM(gens map[string]gopter.Gen) {
	gens["ParamIndicator"] = gen.PtrOf(gen.OneConstOf(UrlSigningParamIdentifier_ParamIndicator_Expires, UrlSigningParamIdentifier_ParamIndicator_KeyId, UrlSigningParamIdentifier_ParamIndicator_Signature))
	gens["ParamName"] = gen.PtrOf(gen.AlphaString())
}
