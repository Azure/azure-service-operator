// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210601

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ProfilesEndpoints_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProfilesEndpoints_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfilesEndpointsSpecARM, ProfilesEndpointsSpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfilesEndpointsSpecARM runs a test to see if a specific instance of ProfilesEndpoints_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProfilesEndpointsSpecARM(subject ProfilesEndpoints_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProfilesEndpoints_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProfilesEndpoints_SpecARM instances for property testing - lazily instantiated by
// ProfilesEndpointsSpecARMGenerator()
var profilesEndpointsSpecARMGenerator gopter.Gen

// ProfilesEndpointsSpecARMGenerator returns a generator of ProfilesEndpoints_SpecARM instances for property testing.
// We first initialize profilesEndpointsSpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProfilesEndpointsSpecARMGenerator() gopter.Gen {
	if profilesEndpointsSpecARMGenerator != nil {
		return profilesEndpointsSpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpointsSpecARM(generators)
	profilesEndpointsSpecARMGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoints_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpointsSpecARM(generators)
	AddRelatedPropertyGeneratorsForProfilesEndpointsSpecARM(generators)
	profilesEndpointsSpecARMGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoints_SpecARM{}), generators)

	return profilesEndpointsSpecARMGenerator
}

// AddIndependentPropertyGeneratorsForProfilesEndpointsSpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfilesEndpointsSpecARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProfilesEndpointsSpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfilesEndpointsSpecARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(ProfilesEndpointsSpecPropertiesARMGenerator())
}

func Test_ProfilesEndpoints_Spec_PropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProfilesEndpoints_Spec_PropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfilesEndpointsSpecPropertiesARM, ProfilesEndpointsSpecPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfilesEndpointsSpecPropertiesARM runs a test to see if a specific instance of ProfilesEndpoints_Spec_PropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProfilesEndpointsSpecPropertiesARM(subject ProfilesEndpoints_Spec_PropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProfilesEndpoints_Spec_PropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProfilesEndpoints_Spec_PropertiesARM instances for property testing - lazily instantiated by
// ProfilesEndpointsSpecPropertiesARMGenerator()
var profilesEndpointsSpecPropertiesARMGenerator gopter.Gen

// ProfilesEndpointsSpecPropertiesARMGenerator returns a generator of ProfilesEndpoints_Spec_PropertiesARM instances for property testing.
// We first initialize profilesEndpointsSpecPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProfilesEndpointsSpecPropertiesARMGenerator() gopter.Gen {
	if profilesEndpointsSpecPropertiesARMGenerator != nil {
		return profilesEndpointsSpecPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesARM(generators)
	profilesEndpointsSpecPropertiesARMGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoints_Spec_PropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForProfilesEndpointsSpecPropertiesARM(generators)
	profilesEndpointsSpecPropertiesARMGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoints_Spec_PropertiesARM{}), generators)

	return profilesEndpointsSpecPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesARM(gens map[string]gopter.Gen) {
	gens["ContentTypesToCompress"] = gen.SliceOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsHttpAllowed"] = gen.PtrOf(gen.Bool())
	gens["IsHttpsAllowed"] = gen.PtrOf(gen.Bool())
	gens["OptimizationType"] = gen.PtrOf(gen.OneConstOf(
		ProfilesEndpointsSpecPropertiesOptimizationTypeDynamicSiteAcceleration,
		ProfilesEndpointsSpecPropertiesOptimizationTypeGeneralMediaStreaming,
		ProfilesEndpointsSpecPropertiesOptimizationTypeGeneralWebDelivery,
		ProfilesEndpointsSpecPropertiesOptimizationTypeLargeFileDownload,
		ProfilesEndpointsSpecPropertiesOptimizationTypeVideoOnDemandMediaStreaming))
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["OriginPath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		ProfilesEndpointsSpecPropertiesQueryStringCachingBehaviorBypassCaching,
		ProfilesEndpointsSpecPropertiesQueryStringCachingBehaviorIgnoreQueryString,
		ProfilesEndpointsSpecPropertiesQueryStringCachingBehaviorNotSet,
		ProfilesEndpointsSpecPropertiesQueryStringCachingBehaviorUseQueryString))
}

// AddRelatedPropertyGeneratorsForProfilesEndpointsSpecPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfilesEndpointsSpecPropertiesARM(gens map[string]gopter.Gen) {
	gens["DefaultOriginGroup"] = gen.PtrOf(ResourceReferenceARMGenerator())
	gens["DeliveryPolicy"] = gen.PtrOf(EndpointPropertiesUpdateParametersDeliveryPolicyARMGenerator())
	gens["GeoFilters"] = gen.SliceOf(GeoFilterARMGenerator())
	gens["OriginGroups"] = gen.SliceOf(ProfilesEndpointsSpecPropertiesOriginGroupsARMGenerator())
	gens["Origins"] = gen.SliceOf(ProfilesEndpointsSpecPropertiesOriginsARMGenerator())
	gens["UrlSigningKeys"] = gen.SliceOf(UrlSigningKeyARMGenerator())
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator())
}

func Test_EndpointPropertiesUpdateParametersDeliveryPolicyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointPropertiesUpdateParametersDeliveryPolicyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointPropertiesUpdateParametersDeliveryPolicyARM, EndpointPropertiesUpdateParametersDeliveryPolicyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointPropertiesUpdateParametersDeliveryPolicyARM runs a test to see if a specific instance of EndpointPropertiesUpdateParametersDeliveryPolicyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointPropertiesUpdateParametersDeliveryPolicyARM(subject EndpointPropertiesUpdateParametersDeliveryPolicyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointPropertiesUpdateParametersDeliveryPolicyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointPropertiesUpdateParametersDeliveryPolicyARM instances for property testing - lazily instantiated
// by EndpointPropertiesUpdateParametersDeliveryPolicyARMGenerator()
var endpointPropertiesUpdateParametersDeliveryPolicyARMGenerator gopter.Gen

// EndpointPropertiesUpdateParametersDeliveryPolicyARMGenerator returns a generator of EndpointPropertiesUpdateParametersDeliveryPolicyARM instances for property testing.
// We first initialize endpointPropertiesUpdateParametersDeliveryPolicyARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EndpointPropertiesUpdateParametersDeliveryPolicyARMGenerator() gopter.Gen {
	if endpointPropertiesUpdateParametersDeliveryPolicyARMGenerator != nil {
		return endpointPropertiesUpdateParametersDeliveryPolicyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicyARM(generators)
	endpointPropertiesUpdateParametersDeliveryPolicyARMGenerator = gen.Struct(reflect.TypeOf(EndpointPropertiesUpdateParametersDeliveryPolicyARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicyARM(generators)
	AddRelatedPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicyARM(generators)
	endpointPropertiesUpdateParametersDeliveryPolicyARMGenerator = gen.Struct(reflect.TypeOf(EndpointPropertiesUpdateParametersDeliveryPolicyARM{}), generators)

	return endpointPropertiesUpdateParametersDeliveryPolicyARMGenerator
}

// AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicyARM(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicyARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpointPropertiesUpdateParametersDeliveryPolicyARM(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(DeliveryRuleARMGenerator())
}

func Test_EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM, EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM runs a test to see if a specific instance of EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM(subject EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM instances for property testing -
// lazily instantiated by EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator()
var endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator gopter.Gen

// EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator returns a generator of EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM instances for property testing.
func EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator() gopter.Gen {
	if endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator != nil {
		return endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM(generators)
	endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator = gen.Struct(reflect.TypeOf(EndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM{}), generators)

	return endpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARMGenerator
}

// AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointPropertiesUpdateParametersWebApplicationFirewallPolicyLinkARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_GeoFilterARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GeoFilterARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGeoFilterARM, GeoFilterARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGeoFilterARM runs a test to see if a specific instance of GeoFilterARM round trips to JSON and back losslessly
func RunJSONSerializationTestForGeoFilterARM(subject GeoFilterARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GeoFilterARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GeoFilterARM instances for property testing - lazily instantiated by GeoFilterARMGenerator()
var geoFilterARMGenerator gopter.Gen

// GeoFilterARMGenerator returns a generator of GeoFilterARM instances for property testing.
func GeoFilterARMGenerator() gopter.Gen {
	if geoFilterARMGenerator != nil {
		return geoFilterARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGeoFilterARM(generators)
	geoFilterARMGenerator = gen.Struct(reflect.TypeOf(GeoFilterARM{}), generators)

	return geoFilterARMGenerator
}

// AddIndependentPropertyGeneratorsForGeoFilterARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGeoFilterARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(GeoFilterActionAllow, GeoFilterActionBlock))
	gens["CountryCodes"] = gen.SliceOf(gen.AlphaString())
	gens["RelativePath"] = gen.PtrOf(gen.AlphaString())
}

func Test_ProfilesEndpoints_Spec_Properties_OriginGroupsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProfilesEndpoints_Spec_Properties_OriginGroupsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfilesEndpointsSpecPropertiesOriginGroupsARM, ProfilesEndpointsSpecPropertiesOriginGroupsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfilesEndpointsSpecPropertiesOriginGroupsARM runs a test to see if a specific instance of ProfilesEndpoints_Spec_Properties_OriginGroupsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProfilesEndpointsSpecPropertiesOriginGroupsARM(subject ProfilesEndpoints_Spec_Properties_OriginGroupsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProfilesEndpoints_Spec_Properties_OriginGroupsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProfilesEndpoints_Spec_Properties_OriginGroupsARM instances for property testing - lazily instantiated
// by ProfilesEndpointsSpecPropertiesOriginGroupsARMGenerator()
var profilesEndpointsSpecPropertiesOriginGroupsARMGenerator gopter.Gen

// ProfilesEndpointsSpecPropertiesOriginGroupsARMGenerator returns a generator of ProfilesEndpoints_Spec_Properties_OriginGroupsARM instances for property testing.
// We first initialize profilesEndpointsSpecPropertiesOriginGroupsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProfilesEndpointsSpecPropertiesOriginGroupsARMGenerator() gopter.Gen {
	if profilesEndpointsSpecPropertiesOriginGroupsARMGenerator != nil {
		return profilesEndpointsSpecPropertiesOriginGroupsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginGroupsARM(generators)
	profilesEndpointsSpecPropertiesOriginGroupsARMGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoints_Spec_Properties_OriginGroupsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginGroupsARM(generators)
	AddRelatedPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginGroupsARM(generators)
	profilesEndpointsSpecPropertiesOriginGroupsARMGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoints_Spec_Properties_OriginGroupsARM{}), generators)

	return profilesEndpointsSpecPropertiesOriginGroupsARMGenerator
}

// AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginGroupsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginGroupsARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginGroupsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginGroupsARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(DeepCreatedOriginGroupPropertiesARMGenerator())
}

func Test_ProfilesEndpoints_Spec_Properties_OriginsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ProfilesEndpoints_Spec_Properties_OriginsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfilesEndpointsSpecPropertiesOriginsARM, ProfilesEndpointsSpecPropertiesOriginsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfilesEndpointsSpecPropertiesOriginsARM runs a test to see if a specific instance of ProfilesEndpoints_Spec_Properties_OriginsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProfilesEndpointsSpecPropertiesOriginsARM(subject ProfilesEndpoints_Spec_Properties_OriginsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ProfilesEndpoints_Spec_Properties_OriginsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ProfilesEndpoints_Spec_Properties_OriginsARM instances for property testing - lazily instantiated by
// ProfilesEndpointsSpecPropertiesOriginsARMGenerator()
var profilesEndpointsSpecPropertiesOriginsARMGenerator gopter.Gen

// ProfilesEndpointsSpecPropertiesOriginsARMGenerator returns a generator of ProfilesEndpoints_Spec_Properties_OriginsARM instances for property testing.
// We first initialize profilesEndpointsSpecPropertiesOriginsARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ProfilesEndpointsSpecPropertiesOriginsARMGenerator() gopter.Gen {
	if profilesEndpointsSpecPropertiesOriginsARMGenerator != nil {
		return profilesEndpointsSpecPropertiesOriginsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginsARM(generators)
	profilesEndpointsSpecPropertiesOriginsARMGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoints_Spec_Properties_OriginsARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginsARM(generators)
	AddRelatedPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginsARM(generators)
	profilesEndpointsSpecPropertiesOriginsARMGenerator = gen.Struct(reflect.TypeOf(ProfilesEndpoints_Spec_Properties_OriginsARM{}), generators)

	return profilesEndpointsSpecPropertiesOriginsARMGenerator
}

// AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginsARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfilesEndpointsSpecPropertiesOriginsARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(DeepCreatedOriginPropertiesARMGenerator())
}

func Test_ResourceReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceReferenceARM, ResourceReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceReferenceARM runs a test to see if a specific instance of ResourceReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceReferenceARM(subject ResourceReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceReferenceARM instances for property testing - lazily instantiated by
// ResourceReferenceARMGenerator()
var resourceReferenceARMGenerator gopter.Gen

// ResourceReferenceARMGenerator returns a generator of ResourceReferenceARM instances for property testing.
func ResourceReferenceARMGenerator() gopter.Gen {
	if resourceReferenceARMGenerator != nil {
		return resourceReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceReferenceARM(generators)
	resourceReferenceARMGenerator = gen.Struct(reflect.TypeOf(ResourceReferenceARM{}), generators)

	return resourceReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceReferenceARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_UrlSigningKeyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningKeyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningKeyARM, UrlSigningKeyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningKeyARM runs a test to see if a specific instance of UrlSigningKeyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningKeyARM(subject UrlSigningKeyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningKeyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningKeyARM instances for property testing - lazily instantiated by UrlSigningKeyARMGenerator()
var urlSigningKeyARMGenerator gopter.Gen

// UrlSigningKeyARMGenerator returns a generator of UrlSigningKeyARM instances for property testing.
// We first initialize urlSigningKeyARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningKeyARMGenerator() gopter.Gen {
	if urlSigningKeyARMGenerator != nil {
		return urlSigningKeyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKeyARM(generators)
	urlSigningKeyARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningKeyARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKeyARM(generators)
	AddRelatedPropertyGeneratorsForUrlSigningKeyARM(generators)
	urlSigningKeyARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningKeyARM{}), generators)

	return urlSigningKeyARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningKeyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningKeyARM(gens map[string]gopter.Gen) {
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUrlSigningKeyARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningKeyARM(gens map[string]gopter.Gen) {
	gens["KeySourceParameters"] = gen.PtrOf(KeyVaultSigningKeyParametersARMGenerator())
}

func Test_DeepCreatedOriginGroupPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOriginGroupPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOriginGroupPropertiesARM, DeepCreatedOriginGroupPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOriginGroupPropertiesARM runs a test to see if a specific instance of DeepCreatedOriginGroupPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOriginGroupPropertiesARM(subject DeepCreatedOriginGroupPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOriginGroupPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOriginGroupPropertiesARM instances for property testing - lazily instantiated by
// DeepCreatedOriginGroupPropertiesARMGenerator()
var deepCreatedOriginGroupPropertiesARMGenerator gopter.Gen

// DeepCreatedOriginGroupPropertiesARMGenerator returns a generator of DeepCreatedOriginGroupPropertiesARM instances for property testing.
// We first initialize deepCreatedOriginGroupPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeepCreatedOriginGroupPropertiesARMGenerator() gopter.Gen {
	if deepCreatedOriginGroupPropertiesARMGenerator != nil {
		return deepCreatedOriginGroupPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupPropertiesARM(generators)
	deepCreatedOriginGroupPropertiesARMGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroupPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForDeepCreatedOriginGroupPropertiesARM(generators)
	deepCreatedOriginGroupPropertiesARMGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroupPropertiesARM{}), generators)

	return deepCreatedOriginGroupPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupPropertiesARM(gens map[string]gopter.Gen) {
	gens["TrafficRestorationTimeToHealedOrNewEndpointsInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeepCreatedOriginGroupPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeepCreatedOriginGroupPropertiesARM(gens map[string]gopter.Gen) {
	gens["HealthProbeSettings"] = gen.PtrOf(HealthProbeParametersARMGenerator())
	gens["Origins"] = gen.SliceOf(ResourceReferenceARMGenerator())
	gens["ResponseBasedOriginErrorDetectionSettings"] = gen.PtrOf(ResponseBasedOriginErrorDetectionParametersARMGenerator())
}

func Test_DeepCreatedOriginPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOriginPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOriginPropertiesARM, DeepCreatedOriginPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOriginPropertiesARM runs a test to see if a specific instance of DeepCreatedOriginPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOriginPropertiesARM(subject DeepCreatedOriginPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOriginPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOriginPropertiesARM instances for property testing - lazily instantiated by
// DeepCreatedOriginPropertiesARMGenerator()
var deepCreatedOriginPropertiesARMGenerator gopter.Gen

// DeepCreatedOriginPropertiesARMGenerator returns a generator of DeepCreatedOriginPropertiesARM instances for property testing.
func DeepCreatedOriginPropertiesARMGenerator() gopter.Gen {
	if deepCreatedOriginPropertiesARMGenerator != nil {
		return deepCreatedOriginPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginPropertiesARM(generators)
	deepCreatedOriginPropertiesARMGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginPropertiesARM{}), generators)

	return deepCreatedOriginPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOriginPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOriginPropertiesARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["PrivateLinkAlias"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkApprovalMessage"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkLocation"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_DeliveryRuleARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleARM, DeliveryRuleARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleARM runs a test to see if a specific instance of DeliveryRuleARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleARM(subject DeliveryRuleARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleARM instances for property testing - lazily instantiated by DeliveryRuleARMGenerator()
var deliveryRuleARMGenerator gopter.Gen

// DeliveryRuleARMGenerator returns a generator of DeliveryRuleARM instances for property testing.
// We first initialize deliveryRuleARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleARMGenerator() gopter.Gen {
	if deliveryRuleARMGenerator != nil {
		return deliveryRuleARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleARM(generators)
	deliveryRuleARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleARM(generators)
	deliveryRuleARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleARM{}), generators)

	return deliveryRuleARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Order"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeliveryRuleARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleARM(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.SliceOf(DeliveryRuleAction1ARMGenerator())
	gens["Conditions"] = gen.SliceOf(DeliveryRuleConditionARMGenerator())
}

func Test_KeyVaultSigningKeyParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSigningKeyParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSigningKeyParametersARM, KeyVaultSigningKeyParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSigningKeyParametersARM runs a test to see if a specific instance of KeyVaultSigningKeyParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSigningKeyParametersARM(subject KeyVaultSigningKeyParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSigningKeyParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSigningKeyParametersARM instances for property testing - lazily instantiated by
// KeyVaultSigningKeyParametersARMGenerator()
var keyVaultSigningKeyParametersARMGenerator gopter.Gen

// KeyVaultSigningKeyParametersARMGenerator returns a generator of KeyVaultSigningKeyParametersARM instances for property testing.
func KeyVaultSigningKeyParametersARMGenerator() gopter.Gen {
	if keyVaultSigningKeyParametersARMGenerator != nil {
		return keyVaultSigningKeyParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParametersARM(generators)
	keyVaultSigningKeyParametersARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSigningKeyParametersARM{}), generators)

	return keyVaultSigningKeyParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParametersARM(gens map[string]gopter.Gen) {
	gens["ResourceGroupName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(KeyVaultSigningKeyParametersTypeNameKeyVaultSigningKeyParameters))
	gens["VaultName"] = gen.PtrOf(gen.AlphaString())
}

func Test_DeliveryRuleAction1ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleAction1ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleAction1ARM, DeliveryRuleAction1ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleAction1ARM runs a test to see if a specific instance of DeliveryRuleAction1ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleAction1ARM(subject DeliveryRuleAction1ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleAction1ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleAction1ARM instances for property testing - lazily instantiated by
// DeliveryRuleAction1ARMGenerator()
var deliveryRuleAction1ARMGenerator gopter.Gen

// DeliveryRuleAction1ARMGenerator returns a generator of DeliveryRuleAction1ARM instances for property testing.
func DeliveryRuleAction1ARMGenerator() gopter.Gen {
	if deliveryRuleAction1ARMGenerator != nil {
		return deliveryRuleAction1ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeliveryRuleAction1ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeliveryRuleAction1ARM{}), map[string]gopter.Gen{
			propName: propGen,
		}))
	}
	deliveryRuleAction1ARMGenerator = gen.OneGenOf(gens...)

	return deliveryRuleAction1ARMGenerator
}

// AddRelatedPropertyGeneratorsForDeliveryRuleAction1ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleAction1ARM(gens map[string]gopter.Gen) {
	gens["DeliveryRuleCacheExpiration"] = DeliveryRuleCacheExpirationActionARMGenerator().Map(func(it DeliveryRuleCacheExpirationActionARM) *DeliveryRuleCacheExpirationActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleCacheKeyQueryString"] = DeliveryRuleCacheKeyQueryStringActionARMGenerator().Map(func(it DeliveryRuleCacheKeyQueryStringActionARM) *DeliveryRuleCacheKeyQueryStringActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestHeader"] = DeliveryRuleRequestHeaderActionARMGenerator().Map(func(it DeliveryRuleRequestHeaderActionARM) *DeliveryRuleRequestHeaderActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleResponseHeader"] = DeliveryRuleResponseHeaderActionARMGenerator().Map(func(it DeliveryRuleResponseHeaderActionARM) *DeliveryRuleResponseHeaderActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRouteConfigurationOverride"] = DeliveryRuleRouteConfigurationOverrideActionARMGenerator().Map(func(it DeliveryRuleRouteConfigurationOverrideActionARM) *DeliveryRuleRouteConfigurationOverrideActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["OriginGroupOverride"] = OriginGroupOverrideActionARMGenerator().Map(func(it OriginGroupOverrideActionARM) *OriginGroupOverrideActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["UrlRedirect"] = UrlRedirectActionARMGenerator().Map(func(it UrlRedirectActionARM) *UrlRedirectActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["UrlRewrite"] = UrlRewriteActionARMGenerator().Map(func(it UrlRewriteActionARM) *UrlRewriteActionARM {
		return &it
	}) // generate one case for OneOf type
	gens["UrlSigning"] = UrlSigningActionARMGenerator().Map(func(it UrlSigningActionARM) *UrlSigningActionARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_DeliveryRuleConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleConditionARM, DeliveryRuleConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleConditionARM runs a test to see if a specific instance of DeliveryRuleConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleConditionARM(subject DeliveryRuleConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleConditionARMGenerator()
var deliveryRuleConditionARMGenerator gopter.Gen

// DeliveryRuleConditionARMGenerator returns a generator of DeliveryRuleConditionARM instances for property testing.
func DeliveryRuleConditionARMGenerator() gopter.Gen {
	if deliveryRuleConditionARMGenerator != nil {
		return deliveryRuleConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeliveryRuleConditionARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeliveryRuleConditionARM{}), map[string]gopter.Gen{
			propName: propGen,
		}))
	}
	deliveryRuleConditionARMGenerator = gen.OneGenOf(gens...)

	return deliveryRuleConditionARMGenerator
}

// AddRelatedPropertyGeneratorsForDeliveryRuleConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleConditionARM(gens map[string]gopter.Gen) {
	gens["DeliveryRuleClientPort"] = DeliveryRuleClientPortConditionARMGenerator().Map(func(it DeliveryRuleClientPortConditionARM) *DeliveryRuleClientPortConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleCookies"] = DeliveryRuleCookiesConditionARMGenerator().Map(func(it DeliveryRuleCookiesConditionARM) *DeliveryRuleCookiesConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleHostName"] = DeliveryRuleHostNameConditionARMGenerator().Map(func(it DeliveryRuleHostNameConditionARM) *DeliveryRuleHostNameConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleHttpVersion"] = DeliveryRuleHttpVersionConditionARMGenerator().Map(func(it DeliveryRuleHttpVersionConditionARM) *DeliveryRuleHttpVersionConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleIsDevice"] = DeliveryRuleIsDeviceConditionARMGenerator().Map(func(it DeliveryRuleIsDeviceConditionARM) *DeliveryRuleIsDeviceConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRulePostArgs"] = DeliveryRulePostArgsConditionARMGenerator().Map(func(it DeliveryRulePostArgsConditionARM) *DeliveryRulePostArgsConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleQueryString"] = DeliveryRuleQueryStringConditionARMGenerator().Map(func(it DeliveryRuleQueryStringConditionARM) *DeliveryRuleQueryStringConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRemoteAddress"] = DeliveryRuleRemoteAddressConditionARMGenerator().Map(func(it DeliveryRuleRemoteAddressConditionARM) *DeliveryRuleRemoteAddressConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestBody"] = DeliveryRuleRequestBodyConditionARMGenerator().Map(func(it DeliveryRuleRequestBodyConditionARM) *DeliveryRuleRequestBodyConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestHeader"] = DeliveryRuleRequestHeaderConditionARMGenerator().Map(func(it DeliveryRuleRequestHeaderConditionARM) *DeliveryRuleRequestHeaderConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestMethod"] = DeliveryRuleRequestMethodConditionARMGenerator().Map(func(it DeliveryRuleRequestMethodConditionARM) *DeliveryRuleRequestMethodConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestScheme"] = DeliveryRuleRequestSchemeConditionARMGenerator().Map(func(it DeliveryRuleRequestSchemeConditionARM) *DeliveryRuleRequestSchemeConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleRequestUri"] = DeliveryRuleRequestUriConditionARMGenerator().Map(func(it DeliveryRuleRequestUriConditionARM) *DeliveryRuleRequestUriConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleServerPort"] = DeliveryRuleServerPortConditionARMGenerator().Map(func(it DeliveryRuleServerPortConditionARM) *DeliveryRuleServerPortConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleSocketAddr"] = DeliveryRuleSocketAddrConditionARMGenerator().Map(func(it DeliveryRuleSocketAddrConditionARM) *DeliveryRuleSocketAddrConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleSslProtocol"] = DeliveryRuleSslProtocolConditionARMGenerator().Map(func(it DeliveryRuleSslProtocolConditionARM) *DeliveryRuleSslProtocolConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlFileExtension"] = DeliveryRuleUrlFileExtensionConditionARMGenerator().Map(func(it DeliveryRuleUrlFileExtensionConditionARM) *DeliveryRuleUrlFileExtensionConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlFileName"] = DeliveryRuleUrlFileNameConditionARMGenerator().Map(func(it DeliveryRuleUrlFileNameConditionARM) *DeliveryRuleUrlFileNameConditionARM {
		return &it
	}) // generate one case for OneOf type
	gens["DeliveryRuleUrlPath"] = DeliveryRuleUrlPathConditionARMGenerator().Map(func(it DeliveryRuleUrlPathConditionARM) *DeliveryRuleUrlPathConditionARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_HealthProbeParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeParametersARM, HealthProbeParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeParametersARM runs a test to see if a specific instance of HealthProbeParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeParametersARM(subject HealthProbeParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeParametersARM instances for property testing - lazily instantiated by
// HealthProbeParametersARMGenerator()
var healthProbeParametersARMGenerator gopter.Gen

// HealthProbeParametersARMGenerator returns a generator of HealthProbeParametersARM instances for property testing.
func HealthProbeParametersARMGenerator() gopter.Gen {
	if healthProbeParametersARMGenerator != nil {
		return healthProbeParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeParametersARM(generators)
	healthProbeParametersARMGenerator = gen.Struct(reflect.TypeOf(HealthProbeParametersARM{}), generators)

	return healthProbeParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeParametersARM(gens map[string]gopter.Gen) {
	gens["ProbeIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbeProtocol"] = gen.PtrOf(gen.OneConstOf(HealthProbeParametersProbeProtocolHttp, HealthProbeParametersProbeProtocolHttps, HealthProbeParametersProbeProtocolNotSet))
	gens["ProbeRequestType"] = gen.PtrOf(gen.OneConstOf(HealthProbeParametersProbeRequestTypeGET, HealthProbeParametersProbeRequestTypeHEAD, HealthProbeParametersProbeRequestTypeNotSet))
}

func Test_ResponseBasedOriginErrorDetectionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResponseBasedOriginErrorDetectionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResponseBasedOriginErrorDetectionParametersARM, ResponseBasedOriginErrorDetectionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResponseBasedOriginErrorDetectionParametersARM runs a test to see if a specific instance of ResponseBasedOriginErrorDetectionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResponseBasedOriginErrorDetectionParametersARM(subject ResponseBasedOriginErrorDetectionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResponseBasedOriginErrorDetectionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResponseBasedOriginErrorDetectionParametersARM instances for property testing - lazily instantiated by
// ResponseBasedOriginErrorDetectionParametersARMGenerator()
var responseBasedOriginErrorDetectionParametersARMGenerator gopter.Gen

// ResponseBasedOriginErrorDetectionParametersARMGenerator returns a generator of ResponseBasedOriginErrorDetectionParametersARM instances for property testing.
// We first initialize responseBasedOriginErrorDetectionParametersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResponseBasedOriginErrorDetectionParametersARMGenerator() gopter.Gen {
	if responseBasedOriginErrorDetectionParametersARMGenerator != nil {
		return responseBasedOriginErrorDetectionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersARM(generators)
	responseBasedOriginErrorDetectionParametersARMGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParametersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersARM(generators)
	AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersARM(generators)
	responseBasedOriginErrorDetectionParametersARMGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParametersARM{}), generators)

	return responseBasedOriginErrorDetectionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersARM(gens map[string]gopter.Gen) {
	gens["ResponseBasedDetectedErrorTypes"] = gen.PtrOf(gen.OneConstOf(ResponseBasedOriginErrorDetectionParametersResponseBasedDetectedErrorTypesNone, ResponseBasedOriginErrorDetectionParametersResponseBasedDetectedErrorTypesTcpAndHttpErrors, ResponseBasedOriginErrorDetectionParametersResponseBasedDetectedErrorTypesTcpErrorsOnly))
	gens["ResponseBasedFailoverThresholdPercentage"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParametersARM(gens map[string]gopter.Gen) {
	gens["HttpErrorRanges"] = gen.SliceOf(HttpErrorRangeParametersARMGenerator())
}

func Test_DeliveryRuleCacheExpirationActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCacheExpirationActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCacheExpirationActionARM, DeliveryRuleCacheExpirationActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCacheExpirationActionARM runs a test to see if a specific instance of DeliveryRuleCacheExpirationActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCacheExpirationActionARM(subject DeliveryRuleCacheExpirationActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCacheExpirationActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCacheExpirationActionARM instances for property testing - lazily instantiated by
// DeliveryRuleCacheExpirationActionARMGenerator()
var deliveryRuleCacheExpirationActionARMGenerator gopter.Gen

// DeliveryRuleCacheExpirationActionARMGenerator returns a generator of DeliveryRuleCacheExpirationActionARM instances for property testing.
// We first initialize deliveryRuleCacheExpirationActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCacheExpirationActionARMGenerator() gopter.Gen {
	if deliveryRuleCacheExpirationActionARMGenerator != nil {
		return deliveryRuleCacheExpirationActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationActionARM(generators)
	deliveryRuleCacheExpirationActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheExpirationActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationActionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationActionARM(generators)
	deliveryRuleCacheExpirationActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheExpirationActionARM{}), generators)

	return deliveryRuleCacheExpirationActionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCacheExpirationActionNameCacheExpiration)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CacheExpirationActionParametersARMGenerator())
}

func Test_DeliveryRuleCacheKeyQueryStringActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCacheKeyQueryStringActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringActionARM, DeliveryRuleCacheKeyQueryStringActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringActionARM runs a test to see if a specific instance of DeliveryRuleCacheKeyQueryStringActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringActionARM(subject DeliveryRuleCacheKeyQueryStringActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCacheKeyQueryStringActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCacheKeyQueryStringActionARM instances for property testing - lazily instantiated by
// DeliveryRuleCacheKeyQueryStringActionARMGenerator()
var deliveryRuleCacheKeyQueryStringActionARMGenerator gopter.Gen

// DeliveryRuleCacheKeyQueryStringActionARMGenerator returns a generator of DeliveryRuleCacheKeyQueryStringActionARM instances for property testing.
// We first initialize deliveryRuleCacheKeyQueryStringActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCacheKeyQueryStringActionARMGenerator() gopter.Gen {
	if deliveryRuleCacheKeyQueryStringActionARMGenerator != nil {
		return deliveryRuleCacheKeyQueryStringActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringActionARM(generators)
	deliveryRuleCacheKeyQueryStringActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheKeyQueryStringActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringActionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringActionARM(generators)
	deliveryRuleCacheKeyQueryStringActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheKeyQueryStringActionARM{}), generators)

	return deliveryRuleCacheKeyQueryStringActionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCacheKeyQueryStringActionNameCacheKeyQueryString)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CacheKeyQueryStringActionParametersARMGenerator())
}

func Test_DeliveryRuleClientPortConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleClientPortConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleClientPortConditionARM, DeliveryRuleClientPortConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleClientPortConditionARM runs a test to see if a specific instance of DeliveryRuleClientPortConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleClientPortConditionARM(subject DeliveryRuleClientPortConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleClientPortConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleClientPortConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleClientPortConditionARMGenerator()
var deliveryRuleClientPortConditionARMGenerator gopter.Gen

// DeliveryRuleClientPortConditionARMGenerator returns a generator of DeliveryRuleClientPortConditionARM instances for property testing.
// We first initialize deliveryRuleClientPortConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleClientPortConditionARMGenerator() gopter.Gen {
	if deliveryRuleClientPortConditionARMGenerator != nil {
		return deliveryRuleClientPortConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleClientPortConditionARM(generators)
	deliveryRuleClientPortConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleClientPortConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleClientPortConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleClientPortConditionARM(generators)
	deliveryRuleClientPortConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleClientPortConditionARM{}), generators)

	return deliveryRuleClientPortConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleClientPortConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleClientPortConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleClientPortConditionNameClientPort)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleClientPortConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleClientPortConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(ClientPortMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleCookiesConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCookiesConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCookiesConditionARM, DeliveryRuleCookiesConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCookiesConditionARM runs a test to see if a specific instance of DeliveryRuleCookiesConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCookiesConditionARM(subject DeliveryRuleCookiesConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCookiesConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCookiesConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleCookiesConditionARMGenerator()
var deliveryRuleCookiesConditionARMGenerator gopter.Gen

// DeliveryRuleCookiesConditionARMGenerator returns a generator of DeliveryRuleCookiesConditionARM instances for property testing.
// We first initialize deliveryRuleCookiesConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCookiesConditionARMGenerator() gopter.Gen {
	if deliveryRuleCookiesConditionARMGenerator != nil {
		return deliveryRuleCookiesConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCookiesConditionARM(generators)
	deliveryRuleCookiesConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCookiesConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCookiesConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCookiesConditionARM(generators)
	deliveryRuleCookiesConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCookiesConditionARM{}), generators)

	return deliveryRuleCookiesConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCookiesConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCookiesConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCookiesConditionNameCookies)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCookiesConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCookiesConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CookiesMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleHostNameConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleHostNameConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleHostNameConditionARM, DeliveryRuleHostNameConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleHostNameConditionARM runs a test to see if a specific instance of DeliveryRuleHostNameConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleHostNameConditionARM(subject DeliveryRuleHostNameConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleHostNameConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleHostNameConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleHostNameConditionARMGenerator()
var deliveryRuleHostNameConditionARMGenerator gopter.Gen

// DeliveryRuleHostNameConditionARMGenerator returns a generator of DeliveryRuleHostNameConditionARM instances for property testing.
// We first initialize deliveryRuleHostNameConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleHostNameConditionARMGenerator() gopter.Gen {
	if deliveryRuleHostNameConditionARMGenerator != nil {
		return deliveryRuleHostNameConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHostNameConditionARM(generators)
	deliveryRuleHostNameConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHostNameConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHostNameConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleHostNameConditionARM(generators)
	deliveryRuleHostNameConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHostNameConditionARM{}), generators)

	return deliveryRuleHostNameConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleHostNameConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleHostNameConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleHostNameConditionNameHostName)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleHostNameConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleHostNameConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HostNameMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleHttpVersionConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleHttpVersionConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleHttpVersionConditionARM, DeliveryRuleHttpVersionConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleHttpVersionConditionARM runs a test to see if a specific instance of DeliveryRuleHttpVersionConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleHttpVersionConditionARM(subject DeliveryRuleHttpVersionConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleHttpVersionConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleHttpVersionConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleHttpVersionConditionARMGenerator()
var deliveryRuleHttpVersionConditionARMGenerator gopter.Gen

// DeliveryRuleHttpVersionConditionARMGenerator returns a generator of DeliveryRuleHttpVersionConditionARM instances for property testing.
// We first initialize deliveryRuleHttpVersionConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleHttpVersionConditionARMGenerator() gopter.Gen {
	if deliveryRuleHttpVersionConditionARMGenerator != nil {
		return deliveryRuleHttpVersionConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionConditionARM(generators)
	deliveryRuleHttpVersionConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHttpVersionConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionConditionARM(generators)
	deliveryRuleHttpVersionConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHttpVersionConditionARM{}), generators)

	return deliveryRuleHttpVersionConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleHttpVersionConditionNameHttpVersion)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HttpVersionMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleIsDeviceConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleIsDeviceConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleIsDeviceConditionARM, DeliveryRuleIsDeviceConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleIsDeviceConditionARM runs a test to see if a specific instance of DeliveryRuleIsDeviceConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleIsDeviceConditionARM(subject DeliveryRuleIsDeviceConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleIsDeviceConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleIsDeviceConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleIsDeviceConditionARMGenerator()
var deliveryRuleIsDeviceConditionARMGenerator gopter.Gen

// DeliveryRuleIsDeviceConditionARMGenerator returns a generator of DeliveryRuleIsDeviceConditionARM instances for property testing.
// We first initialize deliveryRuleIsDeviceConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleIsDeviceConditionARMGenerator() gopter.Gen {
	if deliveryRuleIsDeviceConditionARMGenerator != nil {
		return deliveryRuleIsDeviceConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceConditionARM(generators)
	deliveryRuleIsDeviceConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleIsDeviceConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceConditionARM(generators)
	deliveryRuleIsDeviceConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleIsDeviceConditionARM{}), generators)

	return deliveryRuleIsDeviceConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleIsDeviceConditionNameIsDevice)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(IsDeviceMatchConditionParametersARMGenerator())
}

func Test_DeliveryRulePostArgsConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRulePostArgsConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRulePostArgsConditionARM, DeliveryRulePostArgsConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRulePostArgsConditionARM runs a test to see if a specific instance of DeliveryRulePostArgsConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRulePostArgsConditionARM(subject DeliveryRulePostArgsConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRulePostArgsConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRulePostArgsConditionARM instances for property testing - lazily instantiated by
// DeliveryRulePostArgsConditionARMGenerator()
var deliveryRulePostArgsConditionARMGenerator gopter.Gen

// DeliveryRulePostArgsConditionARMGenerator returns a generator of DeliveryRulePostArgsConditionARM instances for property testing.
// We first initialize deliveryRulePostArgsConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRulePostArgsConditionARMGenerator() gopter.Gen {
	if deliveryRulePostArgsConditionARMGenerator != nil {
		return deliveryRulePostArgsConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRulePostArgsConditionARM(generators)
	deliveryRulePostArgsConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRulePostArgsConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRulePostArgsConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRulePostArgsConditionARM(generators)
	deliveryRulePostArgsConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRulePostArgsConditionARM{}), generators)

	return deliveryRulePostArgsConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRulePostArgsConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRulePostArgsConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRulePostArgsConditionNamePostArgs)
}

// AddRelatedPropertyGeneratorsForDeliveryRulePostArgsConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRulePostArgsConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(PostArgsMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleQueryStringConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleQueryStringConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleQueryStringConditionARM, DeliveryRuleQueryStringConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleQueryStringConditionARM runs a test to see if a specific instance of DeliveryRuleQueryStringConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleQueryStringConditionARM(subject DeliveryRuleQueryStringConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleQueryStringConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleQueryStringConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleQueryStringConditionARMGenerator()
var deliveryRuleQueryStringConditionARMGenerator gopter.Gen

// DeliveryRuleQueryStringConditionARMGenerator returns a generator of DeliveryRuleQueryStringConditionARM instances for property testing.
// We first initialize deliveryRuleQueryStringConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleQueryStringConditionARMGenerator() gopter.Gen {
	if deliveryRuleQueryStringConditionARMGenerator != nil {
		return deliveryRuleQueryStringConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringConditionARM(generators)
	deliveryRuleQueryStringConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleQueryStringConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringConditionARM(generators)
	deliveryRuleQueryStringConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleQueryStringConditionARM{}), generators)

	return deliveryRuleQueryStringConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleQueryStringConditionNameQueryString)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(QueryStringMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleRemoteAddressConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRemoteAddressConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRemoteAddressConditionARM, DeliveryRuleRemoteAddressConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRemoteAddressConditionARM runs a test to see if a specific instance of DeliveryRuleRemoteAddressConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRemoteAddressConditionARM(subject DeliveryRuleRemoteAddressConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRemoteAddressConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRemoteAddressConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleRemoteAddressConditionARMGenerator()
var deliveryRuleRemoteAddressConditionARMGenerator gopter.Gen

// DeliveryRuleRemoteAddressConditionARMGenerator returns a generator of DeliveryRuleRemoteAddressConditionARM instances for property testing.
// We first initialize deliveryRuleRemoteAddressConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRemoteAddressConditionARMGenerator() gopter.Gen {
	if deliveryRuleRemoteAddressConditionARMGenerator != nil {
		return deliveryRuleRemoteAddressConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressConditionARM(generators)
	deliveryRuleRemoteAddressConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRemoteAddressConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressConditionARM(generators)
	deliveryRuleRemoteAddressConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRemoteAddressConditionARM{}), generators)

	return deliveryRuleRemoteAddressConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRemoteAddressConditionNameRemoteAddress)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RemoteAddressMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleRequestBodyConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestBodyConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestBodyConditionARM, DeliveryRuleRequestBodyConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestBodyConditionARM runs a test to see if a specific instance of DeliveryRuleRequestBodyConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestBodyConditionARM(subject DeliveryRuleRequestBodyConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestBodyConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestBodyConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestBodyConditionARMGenerator()
var deliveryRuleRequestBodyConditionARMGenerator gopter.Gen

// DeliveryRuleRequestBodyConditionARMGenerator returns a generator of DeliveryRuleRequestBodyConditionARM instances for property testing.
// We first initialize deliveryRuleRequestBodyConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestBodyConditionARMGenerator() gopter.Gen {
	if deliveryRuleRequestBodyConditionARMGenerator != nil {
		return deliveryRuleRequestBodyConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyConditionARM(generators)
	deliveryRuleRequestBodyConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestBodyConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyConditionARM(generators)
	deliveryRuleRequestBodyConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestBodyConditionARM{}), generators)

	return deliveryRuleRequestBodyConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestBodyConditionNameRequestBody)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestBodyMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleRequestHeaderActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestHeaderActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestHeaderActionARM, DeliveryRuleRequestHeaderActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestHeaderActionARM runs a test to see if a specific instance of DeliveryRuleRequestHeaderActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestHeaderActionARM(subject DeliveryRuleRequestHeaderActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestHeaderActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestHeaderActionARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestHeaderActionARMGenerator()
var deliveryRuleRequestHeaderActionARMGenerator gopter.Gen

// DeliveryRuleRequestHeaderActionARMGenerator returns a generator of DeliveryRuleRequestHeaderActionARM instances for property testing.
// We first initialize deliveryRuleRequestHeaderActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestHeaderActionARMGenerator() gopter.Gen {
	if deliveryRuleRequestHeaderActionARMGenerator != nil {
		return deliveryRuleRequestHeaderActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderActionARM(generators)
	deliveryRuleRequestHeaderActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderActionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderActionARM(generators)
	deliveryRuleRequestHeaderActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderActionARM{}), generators)

	return deliveryRuleRequestHeaderActionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestHeaderActionNameModifyRequestHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HeaderActionParametersARMGenerator())
}

func Test_DeliveryRuleRequestHeaderConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestHeaderConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestHeaderConditionARM, DeliveryRuleRequestHeaderConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestHeaderConditionARM runs a test to see if a specific instance of DeliveryRuleRequestHeaderConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestHeaderConditionARM(subject DeliveryRuleRequestHeaderConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestHeaderConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestHeaderConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestHeaderConditionARMGenerator()
var deliveryRuleRequestHeaderConditionARMGenerator gopter.Gen

// DeliveryRuleRequestHeaderConditionARMGenerator returns a generator of DeliveryRuleRequestHeaderConditionARM instances for property testing.
// We first initialize deliveryRuleRequestHeaderConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestHeaderConditionARMGenerator() gopter.Gen {
	if deliveryRuleRequestHeaderConditionARMGenerator != nil {
		return deliveryRuleRequestHeaderConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderConditionARM(generators)
	deliveryRuleRequestHeaderConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderConditionARM(generators)
	deliveryRuleRequestHeaderConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderConditionARM{}), generators)

	return deliveryRuleRequestHeaderConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestHeaderConditionNameRequestHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestHeaderMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleRequestMethodConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestMethodConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestMethodConditionARM, DeliveryRuleRequestMethodConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestMethodConditionARM runs a test to see if a specific instance of DeliveryRuleRequestMethodConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestMethodConditionARM(subject DeliveryRuleRequestMethodConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestMethodConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestMethodConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestMethodConditionARMGenerator()
var deliveryRuleRequestMethodConditionARMGenerator gopter.Gen

// DeliveryRuleRequestMethodConditionARMGenerator returns a generator of DeliveryRuleRequestMethodConditionARM instances for property testing.
// We first initialize deliveryRuleRequestMethodConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestMethodConditionARMGenerator() gopter.Gen {
	if deliveryRuleRequestMethodConditionARMGenerator != nil {
		return deliveryRuleRequestMethodConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodConditionARM(generators)
	deliveryRuleRequestMethodConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestMethodConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodConditionARM(generators)
	deliveryRuleRequestMethodConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestMethodConditionARM{}), generators)

	return deliveryRuleRequestMethodConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestMethodConditionNameRequestMethod)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestMethodMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleRequestSchemeConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestSchemeConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestSchemeConditionARM, DeliveryRuleRequestSchemeConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestSchemeConditionARM runs a test to see if a specific instance of DeliveryRuleRequestSchemeConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestSchemeConditionARM(subject DeliveryRuleRequestSchemeConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestSchemeConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestSchemeConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestSchemeConditionARMGenerator()
var deliveryRuleRequestSchemeConditionARMGenerator gopter.Gen

// DeliveryRuleRequestSchemeConditionARMGenerator returns a generator of DeliveryRuleRequestSchemeConditionARM instances for property testing.
// We first initialize deliveryRuleRequestSchemeConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestSchemeConditionARMGenerator() gopter.Gen {
	if deliveryRuleRequestSchemeConditionARMGenerator != nil {
		return deliveryRuleRequestSchemeConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeConditionARM(generators)
	deliveryRuleRequestSchemeConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestSchemeConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeConditionARM(generators)
	deliveryRuleRequestSchemeConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestSchemeConditionARM{}), generators)

	return deliveryRuleRequestSchemeConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestSchemeConditionNameRequestScheme)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestSchemeMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleRequestUriConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestUriConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestUriConditionARM, DeliveryRuleRequestUriConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestUriConditionARM runs a test to see if a specific instance of DeliveryRuleRequestUriConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestUriConditionARM(subject DeliveryRuleRequestUriConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestUriConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestUriConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestUriConditionARMGenerator()
var deliveryRuleRequestUriConditionARMGenerator gopter.Gen

// DeliveryRuleRequestUriConditionARMGenerator returns a generator of DeliveryRuleRequestUriConditionARM instances for property testing.
// We first initialize deliveryRuleRequestUriConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestUriConditionARMGenerator() gopter.Gen {
	if deliveryRuleRequestUriConditionARMGenerator != nil {
		return deliveryRuleRequestUriConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriConditionARM(generators)
	deliveryRuleRequestUriConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestUriConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriConditionARM(generators)
	deliveryRuleRequestUriConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestUriConditionARM{}), generators)

	return deliveryRuleRequestUriConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestUriConditionNameRequestUri)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestUriMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleResponseHeaderActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleResponseHeaderActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleResponseHeaderActionARM, DeliveryRuleResponseHeaderActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleResponseHeaderActionARM runs a test to see if a specific instance of DeliveryRuleResponseHeaderActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleResponseHeaderActionARM(subject DeliveryRuleResponseHeaderActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleResponseHeaderActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleResponseHeaderActionARM instances for property testing - lazily instantiated by
// DeliveryRuleResponseHeaderActionARMGenerator()
var deliveryRuleResponseHeaderActionARMGenerator gopter.Gen

// DeliveryRuleResponseHeaderActionARMGenerator returns a generator of DeliveryRuleResponseHeaderActionARM instances for property testing.
// We first initialize deliveryRuleResponseHeaderActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleResponseHeaderActionARMGenerator() gopter.Gen {
	if deliveryRuleResponseHeaderActionARMGenerator != nil {
		return deliveryRuleResponseHeaderActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderActionARM(generators)
	deliveryRuleResponseHeaderActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleResponseHeaderActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderActionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderActionARM(generators)
	deliveryRuleResponseHeaderActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleResponseHeaderActionARM{}), generators)

	return deliveryRuleResponseHeaderActionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleResponseHeaderActionNameModifyResponseHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HeaderActionParametersARMGenerator())
}

func Test_DeliveryRuleRouteConfigurationOverrideActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRouteConfigurationOverrideActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideActionARM, DeliveryRuleRouteConfigurationOverrideActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideActionARM runs a test to see if a specific instance of DeliveryRuleRouteConfigurationOverrideActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideActionARM(subject DeliveryRuleRouteConfigurationOverrideActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRouteConfigurationOverrideActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRouteConfigurationOverrideActionARM instances for property testing - lazily instantiated by
// DeliveryRuleRouteConfigurationOverrideActionARMGenerator()
var deliveryRuleRouteConfigurationOverrideActionARMGenerator gopter.Gen

// DeliveryRuleRouteConfigurationOverrideActionARMGenerator returns a generator of DeliveryRuleRouteConfigurationOverrideActionARM instances for property testing.
// We first initialize deliveryRuleRouteConfigurationOverrideActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRouteConfigurationOverrideActionARMGenerator() gopter.Gen {
	if deliveryRuleRouteConfigurationOverrideActionARMGenerator != nil {
		return deliveryRuleRouteConfigurationOverrideActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideActionARM(generators)
	deliveryRuleRouteConfigurationOverrideActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRouteConfigurationOverrideActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideActionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideActionARM(generators)
	deliveryRuleRouteConfigurationOverrideActionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRouteConfigurationOverrideActionARM{}), generators)

	return deliveryRuleRouteConfigurationOverrideActionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRouteConfigurationOverrideActionNameRouteConfigurationOverride)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RouteConfigurationOverrideActionParametersARMGenerator())
}

func Test_DeliveryRuleServerPortConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleServerPortConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleServerPortConditionARM, DeliveryRuleServerPortConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleServerPortConditionARM runs a test to see if a specific instance of DeliveryRuleServerPortConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleServerPortConditionARM(subject DeliveryRuleServerPortConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleServerPortConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleServerPortConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleServerPortConditionARMGenerator()
var deliveryRuleServerPortConditionARMGenerator gopter.Gen

// DeliveryRuleServerPortConditionARMGenerator returns a generator of DeliveryRuleServerPortConditionARM instances for property testing.
// We first initialize deliveryRuleServerPortConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleServerPortConditionARMGenerator() gopter.Gen {
	if deliveryRuleServerPortConditionARMGenerator != nil {
		return deliveryRuleServerPortConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleServerPortConditionARM(generators)
	deliveryRuleServerPortConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleServerPortConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleServerPortConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleServerPortConditionARM(generators)
	deliveryRuleServerPortConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleServerPortConditionARM{}), generators)

	return deliveryRuleServerPortConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleServerPortConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleServerPortConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleServerPortConditionNameServerPort)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleServerPortConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleServerPortConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(ServerPortMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleSocketAddrConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleSocketAddrConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleSocketAddrConditionARM, DeliveryRuleSocketAddrConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleSocketAddrConditionARM runs a test to see if a specific instance of DeliveryRuleSocketAddrConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleSocketAddrConditionARM(subject DeliveryRuleSocketAddrConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleSocketAddrConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleSocketAddrConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleSocketAddrConditionARMGenerator()
var deliveryRuleSocketAddrConditionARMGenerator gopter.Gen

// DeliveryRuleSocketAddrConditionARMGenerator returns a generator of DeliveryRuleSocketAddrConditionARM instances for property testing.
// We first initialize deliveryRuleSocketAddrConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleSocketAddrConditionARMGenerator() gopter.Gen {
	if deliveryRuleSocketAddrConditionARMGenerator != nil {
		return deliveryRuleSocketAddrConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrConditionARM(generators)
	deliveryRuleSocketAddrConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSocketAddrConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrConditionARM(generators)
	deliveryRuleSocketAddrConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSocketAddrConditionARM{}), generators)

	return deliveryRuleSocketAddrConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleSocketAddrConditionNameSocketAddr)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(SocketAddrMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleSslProtocolConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleSslProtocolConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleSslProtocolConditionARM, DeliveryRuleSslProtocolConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleSslProtocolConditionARM runs a test to see if a specific instance of DeliveryRuleSslProtocolConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleSslProtocolConditionARM(subject DeliveryRuleSslProtocolConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleSslProtocolConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleSslProtocolConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleSslProtocolConditionARMGenerator()
var deliveryRuleSslProtocolConditionARMGenerator gopter.Gen

// DeliveryRuleSslProtocolConditionARMGenerator returns a generator of DeliveryRuleSslProtocolConditionARM instances for property testing.
// We first initialize deliveryRuleSslProtocolConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleSslProtocolConditionARMGenerator() gopter.Gen {
	if deliveryRuleSslProtocolConditionARMGenerator != nil {
		return deliveryRuleSslProtocolConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolConditionARM(generators)
	deliveryRuleSslProtocolConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSslProtocolConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolConditionARM(generators)
	deliveryRuleSslProtocolConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSslProtocolConditionARM{}), generators)

	return deliveryRuleSslProtocolConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleSslProtocolConditionNameSslProtocol)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(SslProtocolMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleUrlFileExtensionConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlFileExtensionConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlFileExtensionConditionARM, DeliveryRuleUrlFileExtensionConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlFileExtensionConditionARM runs a test to see if a specific instance of DeliveryRuleUrlFileExtensionConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlFileExtensionConditionARM(subject DeliveryRuleUrlFileExtensionConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlFileExtensionConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlFileExtensionConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleUrlFileExtensionConditionARMGenerator()
var deliveryRuleUrlFileExtensionConditionARMGenerator gopter.Gen

// DeliveryRuleUrlFileExtensionConditionARMGenerator returns a generator of DeliveryRuleUrlFileExtensionConditionARM instances for property testing.
// We first initialize deliveryRuleUrlFileExtensionConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlFileExtensionConditionARMGenerator() gopter.Gen {
	if deliveryRuleUrlFileExtensionConditionARMGenerator != nil {
		return deliveryRuleUrlFileExtensionConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionConditionARM(generators)
	deliveryRuleUrlFileExtensionConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileExtensionConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionConditionARM(generators)
	deliveryRuleUrlFileExtensionConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileExtensionConditionARM{}), generators)

	return deliveryRuleUrlFileExtensionConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlFileExtensionConditionNameUrlFileExtension)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlFileExtensionMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleUrlFileNameConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlFileNameConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlFileNameConditionARM, DeliveryRuleUrlFileNameConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlFileNameConditionARM runs a test to see if a specific instance of DeliveryRuleUrlFileNameConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlFileNameConditionARM(subject DeliveryRuleUrlFileNameConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlFileNameConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlFileNameConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleUrlFileNameConditionARMGenerator()
var deliveryRuleUrlFileNameConditionARMGenerator gopter.Gen

// DeliveryRuleUrlFileNameConditionARMGenerator returns a generator of DeliveryRuleUrlFileNameConditionARM instances for property testing.
// We first initialize deliveryRuleUrlFileNameConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlFileNameConditionARMGenerator() gopter.Gen {
	if deliveryRuleUrlFileNameConditionARMGenerator != nil {
		return deliveryRuleUrlFileNameConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameConditionARM(generators)
	deliveryRuleUrlFileNameConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileNameConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameConditionARM(generators)
	deliveryRuleUrlFileNameConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileNameConditionARM{}), generators)

	return deliveryRuleUrlFileNameConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlFileNameConditionNameUrlFileName)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlFileNameMatchConditionParametersARMGenerator())
}

func Test_DeliveryRuleUrlPathConditionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlPathConditionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlPathConditionARM, DeliveryRuleUrlPathConditionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlPathConditionARM runs a test to see if a specific instance of DeliveryRuleUrlPathConditionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlPathConditionARM(subject DeliveryRuleUrlPathConditionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlPathConditionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlPathConditionARM instances for property testing - lazily instantiated by
// DeliveryRuleUrlPathConditionARMGenerator()
var deliveryRuleUrlPathConditionARMGenerator gopter.Gen

// DeliveryRuleUrlPathConditionARMGenerator returns a generator of DeliveryRuleUrlPathConditionARM instances for property testing.
// We first initialize deliveryRuleUrlPathConditionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlPathConditionARMGenerator() gopter.Gen {
	if deliveryRuleUrlPathConditionARMGenerator != nil {
		return deliveryRuleUrlPathConditionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathConditionARM(generators)
	deliveryRuleUrlPathConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlPathConditionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathConditionARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathConditionARM(generators)
	deliveryRuleUrlPathConditionARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlPathConditionARM{}), generators)

	return deliveryRuleUrlPathConditionARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathConditionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathConditionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlPathConditionNameUrlPath)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathConditionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathConditionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlPathMatchConditionParametersARMGenerator())
}

func Test_HttpErrorRangeParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpErrorRangeParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpErrorRangeParametersARM, HttpErrorRangeParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpErrorRangeParametersARM runs a test to see if a specific instance of HttpErrorRangeParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpErrorRangeParametersARM(subject HttpErrorRangeParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpErrorRangeParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpErrorRangeParametersARM instances for property testing - lazily instantiated by
// HttpErrorRangeParametersARMGenerator()
var httpErrorRangeParametersARMGenerator gopter.Gen

// HttpErrorRangeParametersARMGenerator returns a generator of HttpErrorRangeParametersARM instances for property testing.
func HttpErrorRangeParametersARMGenerator() gopter.Gen {
	if httpErrorRangeParametersARMGenerator != nil {
		return httpErrorRangeParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpErrorRangeParametersARM(generators)
	httpErrorRangeParametersARMGenerator = gen.Struct(reflect.TypeOf(HttpErrorRangeParametersARM{}), generators)

	return httpErrorRangeParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForHttpErrorRangeParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpErrorRangeParametersARM(gens map[string]gopter.Gen) {
	gens["Begin"] = gen.PtrOf(gen.Int())
	gens["End"] = gen.PtrOf(gen.Int())
}

func Test_OriginGroupOverrideActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverrideActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverrideActionARM, OriginGroupOverrideActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverrideActionARM runs a test to see if a specific instance of OriginGroupOverrideActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverrideActionARM(subject OriginGroupOverrideActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverrideActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverrideActionARM instances for property testing - lazily instantiated by
// OriginGroupOverrideActionARMGenerator()
var originGroupOverrideActionARMGenerator gopter.Gen

// OriginGroupOverrideActionARMGenerator returns a generator of OriginGroupOverrideActionARM instances for property testing.
// We first initialize originGroupOverrideActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideActionARMGenerator() gopter.Gen {
	if originGroupOverrideActionARMGenerator != nil {
		return originGroupOverrideActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionARM(generators)
	originGroupOverrideActionARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionARM(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverrideActionARM(generators)
	originGroupOverrideActionARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionARM{}), generators)

	return originGroupOverrideActionARMGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverrideActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverrideActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(OriginGroupOverrideActionNameOriginGroupOverride)
}

// AddRelatedPropertyGeneratorsForOriginGroupOverrideActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverrideActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(OriginGroupOverrideActionParametersARMGenerator())
}

func Test_UrlRedirectActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRedirectActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRedirectActionARM, UrlRedirectActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRedirectActionARM runs a test to see if a specific instance of UrlRedirectActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRedirectActionARM(subject UrlRedirectActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRedirectActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRedirectActionARM instances for property testing - lazily instantiated by
// UrlRedirectActionARMGenerator()
var urlRedirectActionARMGenerator gopter.Gen

// UrlRedirectActionARMGenerator returns a generator of UrlRedirectActionARM instances for property testing.
// We first initialize urlRedirectActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlRedirectActionARMGenerator() gopter.Gen {
	if urlRedirectActionARMGenerator != nil {
		return urlRedirectActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectActionARM(generators)
	urlRedirectActionARMGenerator = gen.Struct(reflect.TypeOf(UrlRedirectActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectActionARM(generators)
	AddRelatedPropertyGeneratorsForUrlRedirectActionARM(generators)
	urlRedirectActionARMGenerator = gen.Struct(reflect.TypeOf(UrlRedirectActionARM{}), generators)

	return urlRedirectActionARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlRedirectActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRedirectActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlRedirectActionNameUrlRedirect)
}

// AddRelatedPropertyGeneratorsForUrlRedirectActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlRedirectActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlRedirectActionParametersARMGenerator())
}

func Test_UrlRewriteActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRewriteActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRewriteActionARM, UrlRewriteActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRewriteActionARM runs a test to see if a specific instance of UrlRewriteActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRewriteActionARM(subject UrlRewriteActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRewriteActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRewriteActionARM instances for property testing - lazily instantiated by
// UrlRewriteActionARMGenerator()
var urlRewriteActionARMGenerator gopter.Gen

// UrlRewriteActionARMGenerator returns a generator of UrlRewriteActionARM instances for property testing.
// We first initialize urlRewriteActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlRewriteActionARMGenerator() gopter.Gen {
	if urlRewriteActionARMGenerator != nil {
		return urlRewriteActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteActionARM(generators)
	urlRewriteActionARMGenerator = gen.Struct(reflect.TypeOf(UrlRewriteActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteActionARM(generators)
	AddRelatedPropertyGeneratorsForUrlRewriteActionARM(generators)
	urlRewriteActionARMGenerator = gen.Struct(reflect.TypeOf(UrlRewriteActionARM{}), generators)

	return urlRewriteActionARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlRewriteActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRewriteActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlRewriteActionNameUrlRewrite)
}

// AddRelatedPropertyGeneratorsForUrlRewriteActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlRewriteActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlRewriteActionParametersARMGenerator())
}

func Test_UrlSigningActionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningActionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningActionARM, UrlSigningActionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningActionARM runs a test to see if a specific instance of UrlSigningActionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningActionARM(subject UrlSigningActionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningActionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningActionARM instances for property testing - lazily instantiated by
// UrlSigningActionARMGenerator()
var urlSigningActionARMGenerator gopter.Gen

// UrlSigningActionARMGenerator returns a generator of UrlSigningActionARM instances for property testing.
// We first initialize urlSigningActionARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningActionARMGenerator() gopter.Gen {
	if urlSigningActionARMGenerator != nil {
		return urlSigningActionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionARM(generators)
	urlSigningActionARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionARM(generators)
	AddRelatedPropertyGeneratorsForUrlSigningActionARM(generators)
	urlSigningActionARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionARM{}), generators)

	return urlSigningActionARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningActionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningActionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlSigningActionNameUrlSigning)
}

// AddRelatedPropertyGeneratorsForUrlSigningActionARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningActionARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlSigningActionParametersARMGenerator())
}

func Test_CacheExpirationActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheExpirationActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheExpirationActionParametersARM, CacheExpirationActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheExpirationActionParametersARM runs a test to see if a specific instance of CacheExpirationActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheExpirationActionParametersARM(subject CacheExpirationActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheExpirationActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheExpirationActionParametersARM instances for property testing - lazily instantiated by
// CacheExpirationActionParametersARMGenerator()
var cacheExpirationActionParametersARMGenerator gopter.Gen

// CacheExpirationActionParametersARMGenerator returns a generator of CacheExpirationActionParametersARM instances for property testing.
func CacheExpirationActionParametersARMGenerator() gopter.Gen {
	if cacheExpirationActionParametersARMGenerator != nil {
		return cacheExpirationActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheExpirationActionParametersARM(generators)
	cacheExpirationActionParametersARMGenerator = gen.Struct(reflect.TypeOf(CacheExpirationActionParametersARM{}), generators)

	return cacheExpirationActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForCacheExpirationActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheExpirationActionParametersARM(gens map[string]gopter.Gen) {
	gens["CacheBehavior"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParametersCacheBehaviorBypassCache, CacheExpirationActionParametersCacheBehaviorOverride, CacheExpirationActionParametersCacheBehaviorSetIfMissing))
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["CacheType"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParametersCacheTypeAll))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParametersTypeNameDeliveryRuleCacheExpirationActionParameters))
}

func Test_CacheKeyQueryStringActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheKeyQueryStringActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheKeyQueryStringActionParametersARM, CacheKeyQueryStringActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheKeyQueryStringActionParametersARM runs a test to see if a specific instance of CacheKeyQueryStringActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheKeyQueryStringActionParametersARM(subject CacheKeyQueryStringActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheKeyQueryStringActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheKeyQueryStringActionParametersARM instances for property testing - lazily instantiated by
// CacheKeyQueryStringActionParametersARMGenerator()
var cacheKeyQueryStringActionParametersARMGenerator gopter.Gen

// CacheKeyQueryStringActionParametersARMGenerator returns a generator of CacheKeyQueryStringActionParametersARM instances for property testing.
func CacheKeyQueryStringActionParametersARMGenerator() gopter.Gen {
	if cacheKeyQueryStringActionParametersARMGenerator != nil {
		return cacheKeyQueryStringActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParametersARM(generators)
	cacheKeyQueryStringActionParametersARMGenerator = gen.Struct(reflect.TypeOf(CacheKeyQueryStringActionParametersARM{}), generators)

	return cacheKeyQueryStringActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParametersARM(gens map[string]gopter.Gen) {
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringBehavior"] = gen.PtrOf(gen.OneConstOf(
		CacheKeyQueryStringActionParametersQueryStringBehaviorExclude,
		CacheKeyQueryStringActionParametersQueryStringBehaviorExcludeAll,
		CacheKeyQueryStringActionParametersQueryStringBehaviorInclude,
		CacheKeyQueryStringActionParametersQueryStringBehaviorIncludeAll))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CacheKeyQueryStringActionParametersTypeNameDeliveryRuleCacheKeyQueryStringBehaviorActionParameters))
}

func Test_ClientPortMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClientPortMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClientPortMatchConditionParametersARM, ClientPortMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClientPortMatchConditionParametersARM runs a test to see if a specific instance of ClientPortMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForClientPortMatchConditionParametersARM(subject ClientPortMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClientPortMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClientPortMatchConditionParametersARM instances for property testing - lazily instantiated by
// ClientPortMatchConditionParametersARMGenerator()
var clientPortMatchConditionParametersARMGenerator gopter.Gen

// ClientPortMatchConditionParametersARMGenerator returns a generator of ClientPortMatchConditionParametersARM instances for property testing.
func ClientPortMatchConditionParametersARMGenerator() gopter.Gen {
	if clientPortMatchConditionParametersARMGenerator != nil {
		return clientPortMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClientPortMatchConditionParametersARM(generators)
	clientPortMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(ClientPortMatchConditionParametersARM{}), generators)

	return clientPortMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForClientPortMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClientPortMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		ClientPortMatchConditionParametersOperatorAny,
		ClientPortMatchConditionParametersOperatorBeginsWith,
		ClientPortMatchConditionParametersOperatorContains,
		ClientPortMatchConditionParametersOperatorEndsWith,
		ClientPortMatchConditionParametersOperatorEqual,
		ClientPortMatchConditionParametersOperatorGreaterThan,
		ClientPortMatchConditionParametersOperatorGreaterThanOrEqual,
		ClientPortMatchConditionParametersOperatorLessThan,
		ClientPortMatchConditionParametersOperatorLessThanOrEqual,
		ClientPortMatchConditionParametersOperatorRegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		ClientPortMatchConditionParametersTransformsLowercase,
		ClientPortMatchConditionParametersTransformsRemoveNulls,
		ClientPortMatchConditionParametersTransformsTrim,
		ClientPortMatchConditionParametersTransformsUppercase,
		ClientPortMatchConditionParametersTransformsUrlDecode,
		ClientPortMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(ClientPortMatchConditionParametersTypeNameDeliveryRuleClientPortConditionParameters))
}

func Test_CookiesMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CookiesMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCookiesMatchConditionParametersARM, CookiesMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCookiesMatchConditionParametersARM runs a test to see if a specific instance of CookiesMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCookiesMatchConditionParametersARM(subject CookiesMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CookiesMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CookiesMatchConditionParametersARM instances for property testing - lazily instantiated by
// CookiesMatchConditionParametersARMGenerator()
var cookiesMatchConditionParametersARMGenerator gopter.Gen

// CookiesMatchConditionParametersARMGenerator returns a generator of CookiesMatchConditionParametersARM instances for property testing.
func CookiesMatchConditionParametersARMGenerator() gopter.Gen {
	if cookiesMatchConditionParametersARMGenerator != nil {
		return cookiesMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCookiesMatchConditionParametersARM(generators)
	cookiesMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(CookiesMatchConditionParametersARM{}), generators)

	return cookiesMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForCookiesMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCookiesMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		CookiesMatchConditionParametersOperatorAny,
		CookiesMatchConditionParametersOperatorBeginsWith,
		CookiesMatchConditionParametersOperatorContains,
		CookiesMatchConditionParametersOperatorEndsWith,
		CookiesMatchConditionParametersOperatorEqual,
		CookiesMatchConditionParametersOperatorGreaterThan,
		CookiesMatchConditionParametersOperatorGreaterThanOrEqual,
		CookiesMatchConditionParametersOperatorLessThan,
		CookiesMatchConditionParametersOperatorLessThanOrEqual,
		CookiesMatchConditionParametersOperatorRegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		CookiesMatchConditionParametersTransformsLowercase,
		CookiesMatchConditionParametersTransformsRemoveNulls,
		CookiesMatchConditionParametersTransformsTrim,
		CookiesMatchConditionParametersTransformsUppercase,
		CookiesMatchConditionParametersTransformsUrlDecode,
		CookiesMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CookiesMatchConditionParametersTypeNameDeliveryRuleCookiesConditionParameters))
}

func Test_HeaderActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderActionParametersARM, HeaderActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderActionParametersARM runs a test to see if a specific instance of HeaderActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderActionParametersARM(subject HeaderActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderActionParametersARM instances for property testing - lazily instantiated by
// HeaderActionParametersARMGenerator()
var headerActionParametersARMGenerator gopter.Gen

// HeaderActionParametersARMGenerator returns a generator of HeaderActionParametersARM instances for property testing.
func HeaderActionParametersARMGenerator() gopter.Gen {
	if headerActionParametersARMGenerator != nil {
		return headerActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderActionParametersARM(generators)
	headerActionParametersARMGenerator = gen.Struct(reflect.TypeOf(HeaderActionParametersARM{}), generators)

	return headerActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForHeaderActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderActionParametersARM(gens map[string]gopter.Gen) {
	gens["HeaderAction"] = gen.PtrOf(gen.OneConstOf(HeaderActionParametersHeaderActionAppend, HeaderActionParametersHeaderActionDelete, HeaderActionParametersHeaderActionOverwrite))
	gens["HeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HeaderActionParametersTypeNameDeliveryRuleHeaderActionParameters))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_HostNameMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostNameMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostNameMatchConditionParametersARM, HostNameMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostNameMatchConditionParametersARM runs a test to see if a specific instance of HostNameMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHostNameMatchConditionParametersARM(subject HostNameMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostNameMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostNameMatchConditionParametersARM instances for property testing - lazily instantiated by
// HostNameMatchConditionParametersARMGenerator()
var hostNameMatchConditionParametersARMGenerator gopter.Gen

// HostNameMatchConditionParametersARMGenerator returns a generator of HostNameMatchConditionParametersARM instances for property testing.
func HostNameMatchConditionParametersARMGenerator() gopter.Gen {
	if hostNameMatchConditionParametersARMGenerator != nil {
		return hostNameMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostNameMatchConditionParametersARM(generators)
	hostNameMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(HostNameMatchConditionParametersARM{}), generators)

	return hostNameMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForHostNameMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostNameMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		HostNameMatchConditionParametersOperatorAny,
		HostNameMatchConditionParametersOperatorBeginsWith,
		HostNameMatchConditionParametersOperatorContains,
		HostNameMatchConditionParametersOperatorEndsWith,
		HostNameMatchConditionParametersOperatorEqual,
		HostNameMatchConditionParametersOperatorGreaterThan,
		HostNameMatchConditionParametersOperatorGreaterThanOrEqual,
		HostNameMatchConditionParametersOperatorLessThan,
		HostNameMatchConditionParametersOperatorLessThanOrEqual,
		HostNameMatchConditionParametersOperatorRegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		HostNameMatchConditionParametersTransformsLowercase,
		HostNameMatchConditionParametersTransformsRemoveNulls,
		HostNameMatchConditionParametersTransformsTrim,
		HostNameMatchConditionParametersTransformsUppercase,
		HostNameMatchConditionParametersTransformsUrlDecode,
		HostNameMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HostNameMatchConditionParametersTypeNameDeliveryRuleHostNameConditionParameters))
}

func Test_HttpVersionMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpVersionMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpVersionMatchConditionParametersARM, HttpVersionMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpVersionMatchConditionParametersARM runs a test to see if a specific instance of HttpVersionMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpVersionMatchConditionParametersARM(subject HttpVersionMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpVersionMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpVersionMatchConditionParametersARM instances for property testing - lazily instantiated by
// HttpVersionMatchConditionParametersARMGenerator()
var httpVersionMatchConditionParametersARMGenerator gopter.Gen

// HttpVersionMatchConditionParametersARMGenerator returns a generator of HttpVersionMatchConditionParametersARM instances for property testing.
func HttpVersionMatchConditionParametersARMGenerator() gopter.Gen {
	if httpVersionMatchConditionParametersARMGenerator != nil {
		return httpVersionMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParametersARM(generators)
	httpVersionMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(HttpVersionMatchConditionParametersARM{}), generators)

	return httpVersionMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(HttpVersionMatchConditionParametersOperatorEqual))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		HttpVersionMatchConditionParametersTransformsLowercase,
		HttpVersionMatchConditionParametersTransformsRemoveNulls,
		HttpVersionMatchConditionParametersTransformsTrim,
		HttpVersionMatchConditionParametersTransformsUppercase,
		HttpVersionMatchConditionParametersTransformsUrlDecode,
		HttpVersionMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HttpVersionMatchConditionParametersTypeNameDeliveryRuleHttpVersionConditionParameters))
}

func Test_IsDeviceMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IsDeviceMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIsDeviceMatchConditionParametersARM, IsDeviceMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIsDeviceMatchConditionParametersARM runs a test to see if a specific instance of IsDeviceMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIsDeviceMatchConditionParametersARM(subject IsDeviceMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IsDeviceMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IsDeviceMatchConditionParametersARM instances for property testing - lazily instantiated by
// IsDeviceMatchConditionParametersARMGenerator()
var isDeviceMatchConditionParametersARMGenerator gopter.Gen

// IsDeviceMatchConditionParametersARMGenerator returns a generator of IsDeviceMatchConditionParametersARM instances for property testing.
func IsDeviceMatchConditionParametersARMGenerator() gopter.Gen {
	if isDeviceMatchConditionParametersARMGenerator != nil {
		return isDeviceMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParametersARM(generators)
	isDeviceMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(IsDeviceMatchConditionParametersARM{}), generators)

	return isDeviceMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(IsDeviceMatchConditionParametersMatchValuesDesktop, IsDeviceMatchConditionParametersMatchValuesMobile))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(IsDeviceMatchConditionParametersOperatorEqual))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		IsDeviceMatchConditionParametersTransformsLowercase,
		IsDeviceMatchConditionParametersTransformsRemoveNulls,
		IsDeviceMatchConditionParametersTransformsTrim,
		IsDeviceMatchConditionParametersTransformsUppercase,
		IsDeviceMatchConditionParametersTransformsUrlDecode,
		IsDeviceMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(IsDeviceMatchConditionParametersTypeNameDeliveryRuleIsDeviceConditionParameters))
}

func Test_OriginGroupOverrideActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverrideActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverrideActionParametersARM, OriginGroupOverrideActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverrideActionParametersARM runs a test to see if a specific instance of OriginGroupOverrideActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverrideActionParametersARM(subject OriginGroupOverrideActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverrideActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverrideActionParametersARM instances for property testing - lazily instantiated by
// OriginGroupOverrideActionParametersARMGenerator()
var originGroupOverrideActionParametersARMGenerator gopter.Gen

// OriginGroupOverrideActionParametersARMGenerator returns a generator of OriginGroupOverrideActionParametersARM instances for property testing.
// We first initialize originGroupOverrideActionParametersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideActionParametersARMGenerator() gopter.Gen {
	if originGroupOverrideActionParametersARMGenerator != nil {
		return originGroupOverrideActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParametersARM(generators)
	originGroupOverrideActionParametersARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionParametersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParametersARM(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParametersARM(generators)
	originGroupOverrideActionParametersARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionParametersARM{}), generators)

	return originGroupOverrideActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParametersARM(gens map[string]gopter.Gen) {
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(OriginGroupOverrideActionParametersTypeNameDeliveryRuleOriginGroupOverrideActionParameters))
}

// AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParametersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParametersARM(gens map[string]gopter.Gen) {
	gens["OriginGroup"] = gen.PtrOf(ResourceReferenceARMGenerator())
}

func Test_PostArgsMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PostArgsMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPostArgsMatchConditionParametersARM, PostArgsMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPostArgsMatchConditionParametersARM runs a test to see if a specific instance of PostArgsMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPostArgsMatchConditionParametersARM(subject PostArgsMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PostArgsMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PostArgsMatchConditionParametersARM instances for property testing - lazily instantiated by
// PostArgsMatchConditionParametersARMGenerator()
var postArgsMatchConditionParametersARMGenerator gopter.Gen

// PostArgsMatchConditionParametersARMGenerator returns a generator of PostArgsMatchConditionParametersARM instances for property testing.
func PostArgsMatchConditionParametersARMGenerator() gopter.Gen {
	if postArgsMatchConditionParametersARMGenerator != nil {
		return postArgsMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPostArgsMatchConditionParametersARM(generators)
	postArgsMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(PostArgsMatchConditionParametersARM{}), generators)

	return postArgsMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForPostArgsMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPostArgsMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		PostArgsMatchConditionParametersOperatorAny,
		PostArgsMatchConditionParametersOperatorBeginsWith,
		PostArgsMatchConditionParametersOperatorContains,
		PostArgsMatchConditionParametersOperatorEndsWith,
		PostArgsMatchConditionParametersOperatorEqual,
		PostArgsMatchConditionParametersOperatorGreaterThan,
		PostArgsMatchConditionParametersOperatorGreaterThanOrEqual,
		PostArgsMatchConditionParametersOperatorLessThan,
		PostArgsMatchConditionParametersOperatorLessThanOrEqual,
		PostArgsMatchConditionParametersOperatorRegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		PostArgsMatchConditionParametersTransformsLowercase,
		PostArgsMatchConditionParametersTransformsRemoveNulls,
		PostArgsMatchConditionParametersTransformsTrim,
		PostArgsMatchConditionParametersTransformsUppercase,
		PostArgsMatchConditionParametersTransformsUrlDecode,
		PostArgsMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(PostArgsMatchConditionParametersTypeNameDeliveryRulePostArgsConditionParameters))
}

func Test_QueryStringMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QueryStringMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForQueryStringMatchConditionParametersARM, QueryStringMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQueryStringMatchConditionParametersARM runs a test to see if a specific instance of QueryStringMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForQueryStringMatchConditionParametersARM(subject QueryStringMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QueryStringMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QueryStringMatchConditionParametersARM instances for property testing - lazily instantiated by
// QueryStringMatchConditionParametersARMGenerator()
var queryStringMatchConditionParametersARMGenerator gopter.Gen

// QueryStringMatchConditionParametersARMGenerator returns a generator of QueryStringMatchConditionParametersARM instances for property testing.
func QueryStringMatchConditionParametersARMGenerator() gopter.Gen {
	if queryStringMatchConditionParametersARMGenerator != nil {
		return queryStringMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQueryStringMatchConditionParametersARM(generators)
	queryStringMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(QueryStringMatchConditionParametersARM{}), generators)

	return queryStringMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForQueryStringMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQueryStringMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		QueryStringMatchConditionParametersOperatorAny,
		QueryStringMatchConditionParametersOperatorBeginsWith,
		QueryStringMatchConditionParametersOperatorContains,
		QueryStringMatchConditionParametersOperatorEndsWith,
		QueryStringMatchConditionParametersOperatorEqual,
		QueryStringMatchConditionParametersOperatorGreaterThan,
		QueryStringMatchConditionParametersOperatorGreaterThanOrEqual,
		QueryStringMatchConditionParametersOperatorLessThan,
		QueryStringMatchConditionParametersOperatorLessThanOrEqual,
		QueryStringMatchConditionParametersOperatorRegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		QueryStringMatchConditionParametersTransformsLowercase,
		QueryStringMatchConditionParametersTransformsRemoveNulls,
		QueryStringMatchConditionParametersTransformsTrim,
		QueryStringMatchConditionParametersTransformsUppercase,
		QueryStringMatchConditionParametersTransformsUrlDecode,
		QueryStringMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(QueryStringMatchConditionParametersTypeNameDeliveryRuleQueryStringConditionParameters))
}

func Test_RemoteAddressMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RemoteAddressMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRemoteAddressMatchConditionParametersARM, RemoteAddressMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRemoteAddressMatchConditionParametersARM runs a test to see if a specific instance of RemoteAddressMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRemoteAddressMatchConditionParametersARM(subject RemoteAddressMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RemoteAddressMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RemoteAddressMatchConditionParametersARM instances for property testing - lazily instantiated by
// RemoteAddressMatchConditionParametersARMGenerator()
var remoteAddressMatchConditionParametersARMGenerator gopter.Gen

// RemoteAddressMatchConditionParametersARMGenerator returns a generator of RemoteAddressMatchConditionParametersARM instances for property testing.
func RemoteAddressMatchConditionParametersARMGenerator() gopter.Gen {
	if remoteAddressMatchConditionParametersARMGenerator != nil {
		return remoteAddressMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParametersARM(generators)
	remoteAddressMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(RemoteAddressMatchConditionParametersARM{}), generators)

	return remoteAddressMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RemoteAddressMatchConditionParametersOperatorAny, RemoteAddressMatchConditionParametersOperatorGeoMatch, RemoteAddressMatchConditionParametersOperatorIPMatch))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RemoteAddressMatchConditionParametersTransformsLowercase,
		RemoteAddressMatchConditionParametersTransformsRemoveNulls,
		RemoteAddressMatchConditionParametersTransformsTrim,
		RemoteAddressMatchConditionParametersTransformsUppercase,
		RemoteAddressMatchConditionParametersTransformsUrlDecode,
		RemoteAddressMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RemoteAddressMatchConditionParametersTypeNameDeliveryRuleRemoteAddressConditionParameters))
}

func Test_RequestBodyMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestBodyMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestBodyMatchConditionParametersARM, RequestBodyMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestBodyMatchConditionParametersARM runs a test to see if a specific instance of RequestBodyMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestBodyMatchConditionParametersARM(subject RequestBodyMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestBodyMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestBodyMatchConditionParametersARM instances for property testing - lazily instantiated by
// RequestBodyMatchConditionParametersARMGenerator()
var requestBodyMatchConditionParametersARMGenerator gopter.Gen

// RequestBodyMatchConditionParametersARMGenerator returns a generator of RequestBodyMatchConditionParametersARM instances for property testing.
func RequestBodyMatchConditionParametersARMGenerator() gopter.Gen {
	if requestBodyMatchConditionParametersARMGenerator != nil {
		return requestBodyMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParametersARM(generators)
	requestBodyMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(RequestBodyMatchConditionParametersARM{}), generators)

	return requestBodyMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestBodyMatchConditionParametersOperatorAny,
		RequestBodyMatchConditionParametersOperatorBeginsWith,
		RequestBodyMatchConditionParametersOperatorContains,
		RequestBodyMatchConditionParametersOperatorEndsWith,
		RequestBodyMatchConditionParametersOperatorEqual,
		RequestBodyMatchConditionParametersOperatorGreaterThan,
		RequestBodyMatchConditionParametersOperatorGreaterThanOrEqual,
		RequestBodyMatchConditionParametersOperatorLessThan,
		RequestBodyMatchConditionParametersOperatorLessThanOrEqual,
		RequestBodyMatchConditionParametersOperatorRegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestBodyMatchConditionParametersTransformsLowercase,
		RequestBodyMatchConditionParametersTransformsRemoveNulls,
		RequestBodyMatchConditionParametersTransformsTrim,
		RequestBodyMatchConditionParametersTransformsUppercase,
		RequestBodyMatchConditionParametersTransformsUrlDecode,
		RequestBodyMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestBodyMatchConditionParametersTypeNameDeliveryRuleRequestBodyConditionParameters))
}

func Test_RequestHeaderMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestHeaderMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestHeaderMatchConditionParametersARM, RequestHeaderMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestHeaderMatchConditionParametersARM runs a test to see if a specific instance of RequestHeaderMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestHeaderMatchConditionParametersARM(subject RequestHeaderMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestHeaderMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestHeaderMatchConditionParametersARM instances for property testing - lazily instantiated by
// RequestHeaderMatchConditionParametersARMGenerator()
var requestHeaderMatchConditionParametersARMGenerator gopter.Gen

// RequestHeaderMatchConditionParametersARMGenerator returns a generator of RequestHeaderMatchConditionParametersARM instances for property testing.
func RequestHeaderMatchConditionParametersARMGenerator() gopter.Gen {
	if requestHeaderMatchConditionParametersARMGenerator != nil {
		return requestHeaderMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParametersARM(generators)
	requestHeaderMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(RequestHeaderMatchConditionParametersARM{}), generators)

	return requestHeaderMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestHeaderMatchConditionParametersOperatorAny,
		RequestHeaderMatchConditionParametersOperatorBeginsWith,
		RequestHeaderMatchConditionParametersOperatorContains,
		RequestHeaderMatchConditionParametersOperatorEndsWith,
		RequestHeaderMatchConditionParametersOperatorEqual,
		RequestHeaderMatchConditionParametersOperatorGreaterThan,
		RequestHeaderMatchConditionParametersOperatorGreaterThanOrEqual,
		RequestHeaderMatchConditionParametersOperatorLessThan,
		RequestHeaderMatchConditionParametersOperatorLessThanOrEqual,
		RequestHeaderMatchConditionParametersOperatorRegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestHeaderMatchConditionParametersTransformsLowercase,
		RequestHeaderMatchConditionParametersTransformsRemoveNulls,
		RequestHeaderMatchConditionParametersTransformsTrim,
		RequestHeaderMatchConditionParametersTransformsUppercase,
		RequestHeaderMatchConditionParametersTransformsUrlDecode,
		RequestHeaderMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestHeaderMatchConditionParametersTypeNameDeliveryRuleRequestHeaderConditionParameters))
}

func Test_RequestMethodMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestMethodMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestMethodMatchConditionParametersARM, RequestMethodMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestMethodMatchConditionParametersARM runs a test to see if a specific instance of RequestMethodMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestMethodMatchConditionParametersARM(subject RequestMethodMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestMethodMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestMethodMatchConditionParametersARM instances for property testing - lazily instantiated by
// RequestMethodMatchConditionParametersARMGenerator()
var requestMethodMatchConditionParametersARMGenerator gopter.Gen

// RequestMethodMatchConditionParametersARMGenerator returns a generator of RequestMethodMatchConditionParametersARM instances for property testing.
func RequestMethodMatchConditionParametersARMGenerator() gopter.Gen {
	if requestMethodMatchConditionParametersARMGenerator != nil {
		return requestMethodMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParametersARM(generators)
	requestMethodMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(RequestMethodMatchConditionParametersARM{}), generators)

	return requestMethodMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(
		RequestMethodMatchConditionParametersMatchValuesDELETE,
		RequestMethodMatchConditionParametersMatchValuesGET,
		RequestMethodMatchConditionParametersMatchValuesHEAD,
		RequestMethodMatchConditionParametersMatchValuesOPTIONS,
		RequestMethodMatchConditionParametersMatchValuesPOST,
		RequestMethodMatchConditionParametersMatchValuesPUT,
		RequestMethodMatchConditionParametersMatchValuesTRACE))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RequestMethodMatchConditionParametersOperatorEqual))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestMethodMatchConditionParametersTransformsLowercase,
		RequestMethodMatchConditionParametersTransformsRemoveNulls,
		RequestMethodMatchConditionParametersTransformsTrim,
		RequestMethodMatchConditionParametersTransformsUppercase,
		RequestMethodMatchConditionParametersTransformsUrlDecode,
		RequestMethodMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestMethodMatchConditionParametersTypeNameDeliveryRuleRequestMethodConditionParameters))
}

func Test_RequestSchemeMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestSchemeMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestSchemeMatchConditionParametersARM, RequestSchemeMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestSchemeMatchConditionParametersARM runs a test to see if a specific instance of RequestSchemeMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestSchemeMatchConditionParametersARM(subject RequestSchemeMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestSchemeMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestSchemeMatchConditionParametersARM instances for property testing - lazily instantiated by
// RequestSchemeMatchConditionParametersARMGenerator()
var requestSchemeMatchConditionParametersARMGenerator gopter.Gen

// RequestSchemeMatchConditionParametersARMGenerator returns a generator of RequestSchemeMatchConditionParametersARM instances for property testing.
func RequestSchemeMatchConditionParametersARMGenerator() gopter.Gen {
	if requestSchemeMatchConditionParametersARMGenerator != nil {
		return requestSchemeMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParametersARM(generators)
	requestSchemeMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(RequestSchemeMatchConditionParametersARM{}), generators)

	return requestSchemeMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(RequestSchemeMatchConditionParametersMatchValuesHTTP, RequestSchemeMatchConditionParametersMatchValuesHTTPS))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RequestSchemeMatchConditionParametersOperatorEqual))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestSchemeMatchConditionParametersTransformsLowercase,
		RequestSchemeMatchConditionParametersTransformsRemoveNulls,
		RequestSchemeMatchConditionParametersTransformsTrim,
		RequestSchemeMatchConditionParametersTransformsUppercase,
		RequestSchemeMatchConditionParametersTransformsUrlDecode,
		RequestSchemeMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestSchemeMatchConditionParametersTypeNameDeliveryRuleRequestSchemeConditionParameters))
}

func Test_RequestUriMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestUriMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestUriMatchConditionParametersARM, RequestUriMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestUriMatchConditionParametersARM runs a test to see if a specific instance of RequestUriMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestUriMatchConditionParametersARM(subject RequestUriMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestUriMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestUriMatchConditionParametersARM instances for property testing - lazily instantiated by
// RequestUriMatchConditionParametersARMGenerator()
var requestUriMatchConditionParametersARMGenerator gopter.Gen

// RequestUriMatchConditionParametersARMGenerator returns a generator of RequestUriMatchConditionParametersARM instances for property testing.
func RequestUriMatchConditionParametersARMGenerator() gopter.Gen {
	if requestUriMatchConditionParametersARMGenerator != nil {
		return requestUriMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestUriMatchConditionParametersARM(generators)
	requestUriMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(RequestUriMatchConditionParametersARM{}), generators)

	return requestUriMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestUriMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestUriMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestUriMatchConditionParametersOperatorAny,
		RequestUriMatchConditionParametersOperatorBeginsWith,
		RequestUriMatchConditionParametersOperatorContains,
		RequestUriMatchConditionParametersOperatorEndsWith,
		RequestUriMatchConditionParametersOperatorEqual,
		RequestUriMatchConditionParametersOperatorGreaterThan,
		RequestUriMatchConditionParametersOperatorGreaterThanOrEqual,
		RequestUriMatchConditionParametersOperatorLessThan,
		RequestUriMatchConditionParametersOperatorLessThanOrEqual,
		RequestUriMatchConditionParametersOperatorRegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		RequestUriMatchConditionParametersTransformsLowercase,
		RequestUriMatchConditionParametersTransformsRemoveNulls,
		RequestUriMatchConditionParametersTransformsTrim,
		RequestUriMatchConditionParametersTransformsUppercase,
		RequestUriMatchConditionParametersTransformsUrlDecode,
		RequestUriMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestUriMatchConditionParametersTypeNameDeliveryRuleRequestUriConditionParameters))
}

func Test_RouteConfigurationOverrideActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteConfigurationOverrideActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteConfigurationOverrideActionParametersARM, RouteConfigurationOverrideActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteConfigurationOverrideActionParametersARM runs a test to see if a specific instance of RouteConfigurationOverrideActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteConfigurationOverrideActionParametersARM(subject RouteConfigurationOverrideActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteConfigurationOverrideActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteConfigurationOverrideActionParametersARM instances for property testing - lazily instantiated by
// RouteConfigurationOverrideActionParametersARMGenerator()
var routeConfigurationOverrideActionParametersARMGenerator gopter.Gen

// RouteConfigurationOverrideActionParametersARMGenerator returns a generator of RouteConfigurationOverrideActionParametersARM instances for property testing.
// We first initialize routeConfigurationOverrideActionParametersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RouteConfigurationOverrideActionParametersARMGenerator() gopter.Gen {
	if routeConfigurationOverrideActionParametersARMGenerator != nil {
		return routeConfigurationOverrideActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParametersARM(generators)
	routeConfigurationOverrideActionParametersARMGenerator = gen.Struct(reflect.TypeOf(RouteConfigurationOverrideActionParametersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParametersARM(generators)
	AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParametersARM(generators)
	routeConfigurationOverrideActionParametersARMGenerator = gen.Struct(reflect.TypeOf(RouteConfigurationOverrideActionParametersARM{}), generators)

	return routeConfigurationOverrideActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParametersARM(gens map[string]gopter.Gen) {
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RouteConfigurationOverrideActionParametersTypeNameDeliveryRuleRouteConfigurationOverrideActionParameters))
}

// AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParametersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParametersARM(gens map[string]gopter.Gen) {
	gens["CacheConfiguration"] = gen.PtrOf(CacheConfigurationARMGenerator())
	gens["OriginGroupOverride"] = gen.PtrOf(OriginGroupOverrideARMGenerator())
}

func Test_ServerPortMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerPortMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerPortMatchConditionParametersARM, ServerPortMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerPortMatchConditionParametersARM runs a test to see if a specific instance of ServerPortMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServerPortMatchConditionParametersARM(subject ServerPortMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerPortMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerPortMatchConditionParametersARM instances for property testing - lazily instantiated by
// ServerPortMatchConditionParametersARMGenerator()
var serverPortMatchConditionParametersARMGenerator gopter.Gen

// ServerPortMatchConditionParametersARMGenerator returns a generator of ServerPortMatchConditionParametersARM instances for property testing.
func ServerPortMatchConditionParametersARMGenerator() gopter.Gen {
	if serverPortMatchConditionParametersARMGenerator != nil {
		return serverPortMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerPortMatchConditionParametersARM(generators)
	serverPortMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(ServerPortMatchConditionParametersARM{}), generators)

	return serverPortMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForServerPortMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerPortMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		ServerPortMatchConditionParametersOperatorAny,
		ServerPortMatchConditionParametersOperatorBeginsWith,
		ServerPortMatchConditionParametersOperatorContains,
		ServerPortMatchConditionParametersOperatorEndsWith,
		ServerPortMatchConditionParametersOperatorEqual,
		ServerPortMatchConditionParametersOperatorGreaterThan,
		ServerPortMatchConditionParametersOperatorGreaterThanOrEqual,
		ServerPortMatchConditionParametersOperatorLessThan,
		ServerPortMatchConditionParametersOperatorLessThanOrEqual,
		ServerPortMatchConditionParametersOperatorRegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		ServerPortMatchConditionParametersTransformsLowercase,
		ServerPortMatchConditionParametersTransformsRemoveNulls,
		ServerPortMatchConditionParametersTransformsTrim,
		ServerPortMatchConditionParametersTransformsUppercase,
		ServerPortMatchConditionParametersTransformsUrlDecode,
		ServerPortMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(ServerPortMatchConditionParametersTypeNameDeliveryRuleServerPortConditionParameters))
}

func Test_SocketAddrMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SocketAddrMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSocketAddrMatchConditionParametersARM, SocketAddrMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSocketAddrMatchConditionParametersARM runs a test to see if a specific instance of SocketAddrMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSocketAddrMatchConditionParametersARM(subject SocketAddrMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SocketAddrMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SocketAddrMatchConditionParametersARM instances for property testing - lazily instantiated by
// SocketAddrMatchConditionParametersARMGenerator()
var socketAddrMatchConditionParametersARMGenerator gopter.Gen

// SocketAddrMatchConditionParametersARMGenerator returns a generator of SocketAddrMatchConditionParametersARM instances for property testing.
func SocketAddrMatchConditionParametersARMGenerator() gopter.Gen {
	if socketAddrMatchConditionParametersARMGenerator != nil {
		return socketAddrMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParametersARM(generators)
	socketAddrMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(SocketAddrMatchConditionParametersARM{}), generators)

	return socketAddrMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(SocketAddrMatchConditionParametersOperatorAny, SocketAddrMatchConditionParametersOperatorIPMatch))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		SocketAddrMatchConditionParametersTransformsLowercase,
		SocketAddrMatchConditionParametersTransformsRemoveNulls,
		SocketAddrMatchConditionParametersTransformsTrim,
		SocketAddrMatchConditionParametersTransformsUppercase,
		SocketAddrMatchConditionParametersTransformsUrlDecode,
		SocketAddrMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(SocketAddrMatchConditionParametersTypeNameDeliveryRuleSocketAddrConditionParameters))
}

func Test_SslProtocolMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SslProtocolMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSslProtocolMatchConditionParametersARM, SslProtocolMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSslProtocolMatchConditionParametersARM runs a test to see if a specific instance of SslProtocolMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSslProtocolMatchConditionParametersARM(subject SslProtocolMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SslProtocolMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SslProtocolMatchConditionParametersARM instances for property testing - lazily instantiated by
// SslProtocolMatchConditionParametersARMGenerator()
var sslProtocolMatchConditionParametersARMGenerator gopter.Gen

// SslProtocolMatchConditionParametersARMGenerator returns a generator of SslProtocolMatchConditionParametersARM instances for property testing.
func SslProtocolMatchConditionParametersARMGenerator() gopter.Gen {
	if sslProtocolMatchConditionParametersARMGenerator != nil {
		return sslProtocolMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParametersARM(generators)
	sslProtocolMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(SslProtocolMatchConditionParametersARM{}), generators)

	return sslProtocolMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(SslProtocolMatchConditionParametersMatchValuesTLSv1, SslProtocolMatchConditionParametersMatchValuesTLSv11, SslProtocolMatchConditionParametersMatchValuesTLSv12))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(SslProtocolMatchConditionParametersOperatorEqual))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		SslProtocolMatchConditionParametersTransformsLowercase,
		SslProtocolMatchConditionParametersTransformsRemoveNulls,
		SslProtocolMatchConditionParametersTransformsTrim,
		SslProtocolMatchConditionParametersTransformsUppercase,
		SslProtocolMatchConditionParametersTransformsUrlDecode,
		SslProtocolMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(SslProtocolMatchConditionParametersTypeNameDeliveryRuleSslProtocolConditionParameters))
}

func Test_UrlFileExtensionMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlFileExtensionMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlFileExtensionMatchConditionParametersARM, UrlFileExtensionMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlFileExtensionMatchConditionParametersARM runs a test to see if a specific instance of UrlFileExtensionMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlFileExtensionMatchConditionParametersARM(subject UrlFileExtensionMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlFileExtensionMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlFileExtensionMatchConditionParametersARM instances for property testing - lazily instantiated by
// UrlFileExtensionMatchConditionParametersARMGenerator()
var urlFileExtensionMatchConditionParametersARMGenerator gopter.Gen

// UrlFileExtensionMatchConditionParametersARMGenerator returns a generator of UrlFileExtensionMatchConditionParametersARM instances for property testing.
func UrlFileExtensionMatchConditionParametersARMGenerator() gopter.Gen {
	if urlFileExtensionMatchConditionParametersARMGenerator != nil {
		return urlFileExtensionMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParametersARM(generators)
	urlFileExtensionMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(UrlFileExtensionMatchConditionParametersARM{}), generators)

	return urlFileExtensionMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlFileExtensionMatchConditionParametersOperatorAny,
		UrlFileExtensionMatchConditionParametersOperatorBeginsWith,
		UrlFileExtensionMatchConditionParametersOperatorContains,
		UrlFileExtensionMatchConditionParametersOperatorEndsWith,
		UrlFileExtensionMatchConditionParametersOperatorEqual,
		UrlFileExtensionMatchConditionParametersOperatorGreaterThan,
		UrlFileExtensionMatchConditionParametersOperatorGreaterThanOrEqual,
		UrlFileExtensionMatchConditionParametersOperatorLessThan,
		UrlFileExtensionMatchConditionParametersOperatorLessThanOrEqual,
		UrlFileExtensionMatchConditionParametersOperatorRegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		UrlFileExtensionMatchConditionParametersTransformsLowercase,
		UrlFileExtensionMatchConditionParametersTransformsRemoveNulls,
		UrlFileExtensionMatchConditionParametersTransformsTrim,
		UrlFileExtensionMatchConditionParametersTransformsUppercase,
		UrlFileExtensionMatchConditionParametersTransformsUrlDecode,
		UrlFileExtensionMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlFileExtensionMatchConditionParametersTypeNameDeliveryRuleUrlFileExtensionMatchConditionParameters))
}

func Test_UrlFileNameMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlFileNameMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlFileNameMatchConditionParametersARM, UrlFileNameMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlFileNameMatchConditionParametersARM runs a test to see if a specific instance of UrlFileNameMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlFileNameMatchConditionParametersARM(subject UrlFileNameMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlFileNameMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlFileNameMatchConditionParametersARM instances for property testing - lazily instantiated by
// UrlFileNameMatchConditionParametersARMGenerator()
var urlFileNameMatchConditionParametersARMGenerator gopter.Gen

// UrlFileNameMatchConditionParametersARMGenerator returns a generator of UrlFileNameMatchConditionParametersARM instances for property testing.
func UrlFileNameMatchConditionParametersARMGenerator() gopter.Gen {
	if urlFileNameMatchConditionParametersARMGenerator != nil {
		return urlFileNameMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParametersARM(generators)
	urlFileNameMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(UrlFileNameMatchConditionParametersARM{}), generators)

	return urlFileNameMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlFileNameMatchConditionParametersOperatorAny,
		UrlFileNameMatchConditionParametersOperatorBeginsWith,
		UrlFileNameMatchConditionParametersOperatorContains,
		UrlFileNameMatchConditionParametersOperatorEndsWith,
		UrlFileNameMatchConditionParametersOperatorEqual,
		UrlFileNameMatchConditionParametersOperatorGreaterThan,
		UrlFileNameMatchConditionParametersOperatorGreaterThanOrEqual,
		UrlFileNameMatchConditionParametersOperatorLessThan,
		UrlFileNameMatchConditionParametersOperatorLessThanOrEqual,
		UrlFileNameMatchConditionParametersOperatorRegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		UrlFileNameMatchConditionParametersTransformsLowercase,
		UrlFileNameMatchConditionParametersTransformsRemoveNulls,
		UrlFileNameMatchConditionParametersTransformsTrim,
		UrlFileNameMatchConditionParametersTransformsUppercase,
		UrlFileNameMatchConditionParametersTransformsUrlDecode,
		UrlFileNameMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlFileNameMatchConditionParametersTypeNameDeliveryRuleUrlFilenameConditionParameters))
}

func Test_UrlPathMatchConditionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlPathMatchConditionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlPathMatchConditionParametersARM, UrlPathMatchConditionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlPathMatchConditionParametersARM runs a test to see if a specific instance of UrlPathMatchConditionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlPathMatchConditionParametersARM(subject UrlPathMatchConditionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlPathMatchConditionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlPathMatchConditionParametersARM instances for property testing - lazily instantiated by
// UrlPathMatchConditionParametersARMGenerator()
var urlPathMatchConditionParametersARMGenerator gopter.Gen

// UrlPathMatchConditionParametersARMGenerator returns a generator of UrlPathMatchConditionParametersARM instances for property testing.
func UrlPathMatchConditionParametersARMGenerator() gopter.Gen {
	if urlPathMatchConditionParametersARMGenerator != nil {
		return urlPathMatchConditionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlPathMatchConditionParametersARM(generators)
	urlPathMatchConditionParametersARMGenerator = gen.Struct(reflect.TypeOf(UrlPathMatchConditionParametersARM{}), generators)

	return urlPathMatchConditionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlPathMatchConditionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlPathMatchConditionParametersARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlPathMatchConditionParametersOperatorAny,
		UrlPathMatchConditionParametersOperatorBeginsWith,
		UrlPathMatchConditionParametersOperatorContains,
		UrlPathMatchConditionParametersOperatorEndsWith,
		UrlPathMatchConditionParametersOperatorEqual,
		UrlPathMatchConditionParametersOperatorGreaterThan,
		UrlPathMatchConditionParametersOperatorGreaterThanOrEqual,
		UrlPathMatchConditionParametersOperatorLessThan,
		UrlPathMatchConditionParametersOperatorLessThanOrEqual,
		UrlPathMatchConditionParametersOperatorRegEx,
		UrlPathMatchConditionParametersOperatorWildcard))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		UrlPathMatchConditionParametersTransformsLowercase,
		UrlPathMatchConditionParametersTransformsRemoveNulls,
		UrlPathMatchConditionParametersTransformsTrim,
		UrlPathMatchConditionParametersTransformsUppercase,
		UrlPathMatchConditionParametersTransformsUrlDecode,
		UrlPathMatchConditionParametersTransformsUrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlPathMatchConditionParametersTypeNameDeliveryRuleUrlPathMatchConditionParameters))
}

func Test_UrlRedirectActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRedirectActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRedirectActionParametersARM, UrlRedirectActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRedirectActionParametersARM runs a test to see if a specific instance of UrlRedirectActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRedirectActionParametersARM(subject UrlRedirectActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRedirectActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRedirectActionParametersARM instances for property testing - lazily instantiated by
// UrlRedirectActionParametersARMGenerator()
var urlRedirectActionParametersARMGenerator gopter.Gen

// UrlRedirectActionParametersARMGenerator returns a generator of UrlRedirectActionParametersARM instances for property testing.
func UrlRedirectActionParametersARMGenerator() gopter.Gen {
	if urlRedirectActionParametersARMGenerator != nil {
		return urlRedirectActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectActionParametersARM(generators)
	urlRedirectActionParametersARMGenerator = gen.Struct(reflect.TypeOf(UrlRedirectActionParametersARM{}), generators)

	return urlRedirectActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlRedirectActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRedirectActionParametersARM(gens map[string]gopter.Gen) {
	gens["CustomFragment"] = gen.PtrOf(gen.AlphaString())
	gens["CustomHostname"] = gen.PtrOf(gen.AlphaString())
	gens["CustomPath"] = gen.PtrOf(gen.AlphaString())
	gens["CustomQueryString"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationProtocol"] = gen.PtrOf(gen.OneConstOf(UrlRedirectActionParametersDestinationProtocolHttp, UrlRedirectActionParametersDestinationProtocolHttps, UrlRedirectActionParametersDestinationProtocolMatchRequest))
	gens["RedirectType"] = gen.PtrOf(gen.OneConstOf(
		UrlRedirectActionParametersRedirectTypeFound,
		UrlRedirectActionParametersRedirectTypeMoved,
		UrlRedirectActionParametersRedirectTypePermanentRedirect,
		UrlRedirectActionParametersRedirectTypeTemporaryRedirect))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlRedirectActionParametersTypeNameDeliveryRuleUrlRedirectActionParameters))
}

func Test_UrlRewriteActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRewriteActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRewriteActionParametersARM, UrlRewriteActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRewriteActionParametersARM runs a test to see if a specific instance of UrlRewriteActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRewriteActionParametersARM(subject UrlRewriteActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRewriteActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRewriteActionParametersARM instances for property testing - lazily instantiated by
// UrlRewriteActionParametersARMGenerator()
var urlRewriteActionParametersARMGenerator gopter.Gen

// UrlRewriteActionParametersARMGenerator returns a generator of UrlRewriteActionParametersARM instances for property testing.
func UrlRewriteActionParametersARMGenerator() gopter.Gen {
	if urlRewriteActionParametersARMGenerator != nil {
		return urlRewriteActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteActionParametersARM(generators)
	urlRewriteActionParametersARMGenerator = gen.Struct(reflect.TypeOf(UrlRewriteActionParametersARM{}), generators)

	return urlRewriteActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlRewriteActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRewriteActionParametersARM(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(gen.AlphaString())
	gens["PreserveUnmatchedPath"] = gen.PtrOf(gen.Bool())
	gens["SourcePattern"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlRewriteActionParametersTypeNameDeliveryRuleUrlRewriteActionParameters))
}

func Test_UrlSigningActionParametersARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningActionParametersARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningActionParametersARM, UrlSigningActionParametersARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningActionParametersARM runs a test to see if a specific instance of UrlSigningActionParametersARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningActionParametersARM(subject UrlSigningActionParametersARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningActionParametersARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningActionParametersARM instances for property testing - lazily instantiated by
// UrlSigningActionParametersARMGenerator()
var urlSigningActionParametersARMGenerator gopter.Gen

// UrlSigningActionParametersARMGenerator returns a generator of UrlSigningActionParametersARM instances for property testing.
// We first initialize urlSigningActionParametersARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningActionParametersARMGenerator() gopter.Gen {
	if urlSigningActionParametersARMGenerator != nil {
		return urlSigningActionParametersARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionParametersARM(generators)
	urlSigningActionParametersARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionParametersARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionParametersARM(generators)
	AddRelatedPropertyGeneratorsForUrlSigningActionParametersARM(generators)
	urlSigningActionParametersARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionParametersARM{}), generators)

	return urlSigningActionParametersARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningActionParametersARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningActionParametersARM(gens map[string]gopter.Gen) {
	gens["Algorithm"] = gen.PtrOf(gen.OneConstOf(UrlSigningActionParametersAlgorithmSHA256))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlSigningActionParametersTypeNameDeliveryRuleUrlSigningActionParameters))
}

// AddRelatedPropertyGeneratorsForUrlSigningActionParametersARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningActionParametersARM(gens map[string]gopter.Gen) {
	gens["ParameterNameOverride"] = gen.SliceOf(UrlSigningParamIdentifierARMGenerator())
}

func Test_CacheConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheConfigurationARM, CacheConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheConfigurationARM runs a test to see if a specific instance of CacheConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheConfigurationARM(subject CacheConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheConfigurationARM instances for property testing - lazily instantiated by
// CacheConfigurationARMGenerator()
var cacheConfigurationARMGenerator gopter.Gen

// CacheConfigurationARMGenerator returns a generator of CacheConfigurationARM instances for property testing.
func CacheConfigurationARMGenerator() gopter.Gen {
	if cacheConfigurationARMGenerator != nil {
		return cacheConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheConfigurationARM(generators)
	cacheConfigurationARMGenerator = gen.Struct(reflect.TypeOf(CacheConfigurationARM{}), generators)

	return cacheConfigurationARMGenerator
}

// AddIndependentPropertyGeneratorsForCacheConfigurationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheConfigurationARM(gens map[string]gopter.Gen) {
	gens["CacheBehavior"] = gen.PtrOf(gen.OneConstOf(CacheConfigurationCacheBehaviorHonorOrigin, CacheConfigurationCacheBehaviorOverrideAlways, CacheConfigurationCacheBehaviorOverrideIfOriginMissing))
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.OneConstOf(CacheConfigurationIsCompressionEnabledDisabled, CacheConfigurationIsCompressionEnabledEnabled))
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		CacheConfigurationQueryStringCachingBehaviorIgnoreQueryString,
		CacheConfigurationQueryStringCachingBehaviorIgnoreSpecifiedQueryStrings,
		CacheConfigurationQueryStringCachingBehaviorIncludeSpecifiedQueryStrings,
		CacheConfigurationQueryStringCachingBehaviorUseQueryString))
}

func Test_OriginGroupOverrideARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverrideARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverrideARM, OriginGroupOverrideARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverrideARM runs a test to see if a specific instance of OriginGroupOverrideARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverrideARM(subject OriginGroupOverrideARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverrideARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverrideARM instances for property testing - lazily instantiated by
// OriginGroupOverrideARMGenerator()
var originGroupOverrideARMGenerator gopter.Gen

// OriginGroupOverrideARMGenerator returns a generator of OriginGroupOverrideARM instances for property testing.
// We first initialize originGroupOverrideARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideARMGenerator() gopter.Gen {
	if originGroupOverrideARMGenerator != nil {
		return originGroupOverrideARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideARM(generators)
	originGroupOverrideARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideARM(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverrideARM(generators)
	originGroupOverrideARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideARM{}), generators)

	return originGroupOverrideARMGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverrideARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverrideARM(gens map[string]gopter.Gen) {
	gens["ForwardingProtocol"] = gen.PtrOf(gen.OneConstOf(OriginGroupOverrideForwardingProtocolHttpOnly, OriginGroupOverrideForwardingProtocolHttpsOnly, OriginGroupOverrideForwardingProtocolMatchRequest))
}

// AddRelatedPropertyGeneratorsForOriginGroupOverrideARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverrideARM(gens map[string]gopter.Gen) {
	gens["OriginGroup"] = gen.PtrOf(ResourceReferenceARMGenerator())
}

func Test_UrlSigningParamIdentifierARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningParamIdentifierARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningParamIdentifierARM, UrlSigningParamIdentifierARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningParamIdentifierARM runs a test to see if a specific instance of UrlSigningParamIdentifierARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningParamIdentifierARM(subject UrlSigningParamIdentifierARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningParamIdentifierARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningParamIdentifierARM instances for property testing - lazily instantiated by
// UrlSigningParamIdentifierARMGenerator()
var urlSigningParamIdentifierARMGenerator gopter.Gen

// UrlSigningParamIdentifierARMGenerator returns a generator of UrlSigningParamIdentifierARM instances for property testing.
func UrlSigningParamIdentifierARMGenerator() gopter.Gen {
	if urlSigningParamIdentifierARMGenerator != nil {
		return urlSigningParamIdentifierARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningParamIdentifierARM(generators)
	urlSigningParamIdentifierARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningParamIdentifierARM{}), generators)

	return urlSigningParamIdentifierARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningParamIdentifierARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningParamIdentifierARM(gens map[string]gopter.Gen) {
	gens["ParamIndicator"] = gen.PtrOf(gen.OneConstOf(UrlSigningParamIdentifierParamIndicatorExpires, UrlSigningParamIdentifierParamIndicatorKeyId, UrlSigningParamIdentifierParamIndicatorSignature))
	gens["ParamName"] = gen.PtrOf(gen.AlphaString())
}
