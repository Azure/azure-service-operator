// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1api20210601

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_CacheConfiguration_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheConfiguration_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheConfiguration_ARM, CacheConfiguration_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheConfiguration_ARM runs a test to see if a specific instance of CacheConfiguration_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheConfiguration_ARM(subject CacheConfiguration_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheConfiguration_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheConfiguration_ARM instances for property testing - lazily instantiated by
// CacheConfiguration_ARMGenerator()
var cacheConfiguration_ARMGenerator gopter.Gen

// CacheConfiguration_ARMGenerator returns a generator of CacheConfiguration_ARM instances for property testing.
func CacheConfiguration_ARMGenerator() gopter.Gen {
	if cacheConfiguration_ARMGenerator != nil {
		return cacheConfiguration_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheConfiguration_ARM(generators)
	cacheConfiguration_ARMGenerator = gen.Struct(reflect.TypeOf(CacheConfiguration_ARM{}), generators)

	return cacheConfiguration_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCacheConfiguration_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheConfiguration_ARM(gens map[string]gopter.Gen) {
	gens["CacheBehavior"] = gen.PtrOf(gen.OneConstOf(CacheConfiguration_CacheBehavior_HonorOrigin, CacheConfiguration_CacheBehavior_OverrideAlways, CacheConfiguration_CacheBehavior_OverrideIfOriginMissing))
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.OneConstOf(CacheConfiguration_IsCompressionEnabled_Disabled, CacheConfiguration_IsCompressionEnabled_Enabled))
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		CacheConfiguration_QueryStringCachingBehavior_IgnoreQueryString,
		CacheConfiguration_QueryStringCachingBehavior_IgnoreSpecifiedQueryStrings,
		CacheConfiguration_QueryStringCachingBehavior_IncludeSpecifiedQueryStrings,
		CacheConfiguration_QueryStringCachingBehavior_UseQueryString))
}

func Test_CacheExpirationActionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheExpirationActionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheExpirationActionParameters_ARM, CacheExpirationActionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheExpirationActionParameters_ARM runs a test to see if a specific instance of CacheExpirationActionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheExpirationActionParameters_ARM(subject CacheExpirationActionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheExpirationActionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheExpirationActionParameters_ARM instances for property testing - lazily instantiated by
// CacheExpirationActionParameters_ARMGenerator()
var cacheExpirationActionParameters_ARMGenerator gopter.Gen

// CacheExpirationActionParameters_ARMGenerator returns a generator of CacheExpirationActionParameters_ARM instances for property testing.
func CacheExpirationActionParameters_ARMGenerator() gopter.Gen {
	if cacheExpirationActionParameters_ARMGenerator != nil {
		return cacheExpirationActionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheExpirationActionParameters_ARM(generators)
	cacheExpirationActionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(CacheExpirationActionParameters_ARM{}), generators)

	return cacheExpirationActionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCacheExpirationActionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheExpirationActionParameters_ARM(gens map[string]gopter.Gen) {
	gens["CacheBehavior"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParameters_CacheBehavior_BypassCache, CacheExpirationActionParameters_CacheBehavior_Override, CacheExpirationActionParameters_CacheBehavior_SetIfMissing))
	gens["CacheDuration"] = gen.PtrOf(gen.AlphaString())
	gens["CacheType"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParameters_CacheType_All))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CacheExpirationActionParameters_TypeName_DeliveryRuleCacheExpirationActionParameters))
}

func Test_CacheKeyQueryStringActionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CacheKeyQueryStringActionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCacheKeyQueryStringActionParameters_ARM, CacheKeyQueryStringActionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCacheKeyQueryStringActionParameters_ARM runs a test to see if a specific instance of CacheKeyQueryStringActionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCacheKeyQueryStringActionParameters_ARM(subject CacheKeyQueryStringActionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CacheKeyQueryStringActionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CacheKeyQueryStringActionParameters_ARM instances for property testing - lazily instantiated by
// CacheKeyQueryStringActionParameters_ARMGenerator()
var cacheKeyQueryStringActionParameters_ARMGenerator gopter.Gen

// CacheKeyQueryStringActionParameters_ARMGenerator returns a generator of CacheKeyQueryStringActionParameters_ARM instances for property testing.
func CacheKeyQueryStringActionParameters_ARMGenerator() gopter.Gen {
	if cacheKeyQueryStringActionParameters_ARMGenerator != nil {
		return cacheKeyQueryStringActionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParameters_ARM(generators)
	cacheKeyQueryStringActionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(CacheKeyQueryStringActionParameters_ARM{}), generators)

	return cacheKeyQueryStringActionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCacheKeyQueryStringActionParameters_ARM(gens map[string]gopter.Gen) {
	gens["QueryParameters"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringBehavior"] = gen.PtrOf(gen.OneConstOf(
		CacheKeyQueryStringActionParameters_QueryStringBehavior_Exclude,
		CacheKeyQueryStringActionParameters_QueryStringBehavior_ExcludeAll,
		CacheKeyQueryStringActionParameters_QueryStringBehavior_Include,
		CacheKeyQueryStringActionParameters_QueryStringBehavior_IncludeAll))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CacheKeyQueryStringActionParameters_TypeName_DeliveryRuleCacheKeyQueryStringBehaviorActionParameters))
}

func Test_ClientPortMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ClientPortMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForClientPortMatchConditionParameters_ARM, ClientPortMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForClientPortMatchConditionParameters_ARM runs a test to see if a specific instance of ClientPortMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForClientPortMatchConditionParameters_ARM(subject ClientPortMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ClientPortMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ClientPortMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// ClientPortMatchConditionParameters_ARMGenerator()
var clientPortMatchConditionParameters_ARMGenerator gopter.Gen

// ClientPortMatchConditionParameters_ARMGenerator returns a generator of ClientPortMatchConditionParameters_ARM instances for property testing.
func ClientPortMatchConditionParameters_ARMGenerator() gopter.Gen {
	if clientPortMatchConditionParameters_ARMGenerator != nil {
		return clientPortMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForClientPortMatchConditionParameters_ARM(generators)
	clientPortMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(ClientPortMatchConditionParameters_ARM{}), generators)

	return clientPortMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForClientPortMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForClientPortMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		ClientPortMatchConditionParameters_Operator_Any,
		ClientPortMatchConditionParameters_Operator_BeginsWith,
		ClientPortMatchConditionParameters_Operator_Contains,
		ClientPortMatchConditionParameters_Operator_EndsWith,
		ClientPortMatchConditionParameters_Operator_Equal,
		ClientPortMatchConditionParameters_Operator_GreaterThan,
		ClientPortMatchConditionParameters_Operator_GreaterThanOrEqual,
		ClientPortMatchConditionParameters_Operator_LessThan,
		ClientPortMatchConditionParameters_Operator_LessThanOrEqual,
		ClientPortMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(ClientPortMatchConditionParameters_TypeName_DeliveryRuleClientPortConditionParameters))
}

func Test_CookiesMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of CookiesMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForCookiesMatchConditionParameters_ARM, CookiesMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForCookiesMatchConditionParameters_ARM runs a test to see if a specific instance of CookiesMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForCookiesMatchConditionParameters_ARM(subject CookiesMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual CookiesMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of CookiesMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// CookiesMatchConditionParameters_ARMGenerator()
var cookiesMatchConditionParameters_ARMGenerator gopter.Gen

// CookiesMatchConditionParameters_ARMGenerator returns a generator of CookiesMatchConditionParameters_ARM instances for property testing.
func CookiesMatchConditionParameters_ARMGenerator() gopter.Gen {
	if cookiesMatchConditionParameters_ARMGenerator != nil {
		return cookiesMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForCookiesMatchConditionParameters_ARM(generators)
	cookiesMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(CookiesMatchConditionParameters_ARM{}), generators)

	return cookiesMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForCookiesMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForCookiesMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		CookiesMatchConditionParameters_Operator_Any,
		CookiesMatchConditionParameters_Operator_BeginsWith,
		CookiesMatchConditionParameters_Operator_Contains,
		CookiesMatchConditionParameters_Operator_EndsWith,
		CookiesMatchConditionParameters_Operator_Equal,
		CookiesMatchConditionParameters_Operator_GreaterThan,
		CookiesMatchConditionParameters_Operator_GreaterThanOrEqual,
		CookiesMatchConditionParameters_Operator_LessThan,
		CookiesMatchConditionParameters_Operator_LessThanOrEqual,
		CookiesMatchConditionParameters_Operator_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(CookiesMatchConditionParameters_TypeName_DeliveryRuleCookiesConditionParameters))
}

func Test_DeepCreatedOriginGroupProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOriginGroupProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOriginGroupProperties_ARM, DeepCreatedOriginGroupProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOriginGroupProperties_ARM runs a test to see if a specific instance of DeepCreatedOriginGroupProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOriginGroupProperties_ARM(subject DeepCreatedOriginGroupProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOriginGroupProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOriginGroupProperties_ARM instances for property testing - lazily instantiated by
// DeepCreatedOriginGroupProperties_ARMGenerator()
var deepCreatedOriginGroupProperties_ARMGenerator gopter.Gen

// DeepCreatedOriginGroupProperties_ARMGenerator returns a generator of DeepCreatedOriginGroupProperties_ARM instances for property testing.
// We first initialize deepCreatedOriginGroupProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeepCreatedOriginGroupProperties_ARMGenerator() gopter.Gen {
	if deepCreatedOriginGroupProperties_ARMGenerator != nil {
		return deepCreatedOriginGroupProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupProperties_ARM(generators)
	deepCreatedOriginGroupProperties_ARMGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroupProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForDeepCreatedOriginGroupProperties_ARM(generators)
	deepCreatedOriginGroupProperties_ARMGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroupProperties_ARM{}), generators)

	return deepCreatedOriginGroupProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOriginGroupProperties_ARM(gens map[string]gopter.Gen) {
	gens["TrafficRestorationTimeToHealedOrNewEndpointsInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeepCreatedOriginGroupProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeepCreatedOriginGroupProperties_ARM(gens map[string]gopter.Gen) {
	gens["HealthProbeSettings"] = gen.PtrOf(HealthProbeParameters_ARMGenerator())
	gens["Origins"] = gen.SliceOf(ResourceReference_ARMGenerator())
	gens["ResponseBasedOriginErrorDetectionSettings"] = gen.PtrOf(ResponseBasedOriginErrorDetectionParameters_ARMGenerator())
}

func Test_DeepCreatedOriginGroup_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOriginGroup_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOriginGroup_ARM, DeepCreatedOriginGroup_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOriginGroup_ARM runs a test to see if a specific instance of DeepCreatedOriginGroup_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOriginGroup_ARM(subject DeepCreatedOriginGroup_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOriginGroup_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOriginGroup_ARM instances for property testing - lazily instantiated by
// DeepCreatedOriginGroup_ARMGenerator()
var deepCreatedOriginGroup_ARMGenerator gopter.Gen

// DeepCreatedOriginGroup_ARMGenerator returns a generator of DeepCreatedOriginGroup_ARM instances for property testing.
// We first initialize deepCreatedOriginGroup_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeepCreatedOriginGroup_ARMGenerator() gopter.Gen {
	if deepCreatedOriginGroup_ARMGenerator != nil {
		return deepCreatedOriginGroup_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup_ARM(generators)
	deepCreatedOriginGroup_ARMGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroup_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup_ARM(generators)
	AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup_ARM(generators)
	deepCreatedOriginGroup_ARMGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginGroup_ARM{}), generators)

	return deepCreatedOriginGroup_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOriginGroup_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeepCreatedOriginGroup_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(DeepCreatedOriginGroupProperties_ARMGenerator())
}

func Test_DeepCreatedOriginProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOriginProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOriginProperties_ARM, DeepCreatedOriginProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOriginProperties_ARM runs a test to see if a specific instance of DeepCreatedOriginProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOriginProperties_ARM(subject DeepCreatedOriginProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOriginProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOriginProperties_ARM instances for property testing - lazily instantiated by
// DeepCreatedOriginProperties_ARMGenerator()
var deepCreatedOriginProperties_ARMGenerator gopter.Gen

// DeepCreatedOriginProperties_ARMGenerator returns a generator of DeepCreatedOriginProperties_ARM instances for property testing.
func DeepCreatedOriginProperties_ARMGenerator() gopter.Gen {
	if deepCreatedOriginProperties_ARMGenerator != nil {
		return deepCreatedOriginProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOriginProperties_ARM(generators)
	deepCreatedOriginProperties_ARMGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOriginProperties_ARM{}), generators)

	return deepCreatedOriginProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOriginProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOriginProperties_ARM(gens map[string]gopter.Gen) {
	gens["Enabled"] = gen.PtrOf(gen.Bool())
	gens["HostName"] = gen.PtrOf(gen.AlphaString())
	gens["HttpPort"] = gen.PtrOf(gen.Int())
	gens["HttpsPort"] = gen.PtrOf(gen.Int())
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["Priority"] = gen.PtrOf(gen.Int())
	gens["PrivateLinkAlias"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkApprovalMessage"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkLocation"] = gen.PtrOf(gen.AlphaString())
	gens["PrivateLinkResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Weight"] = gen.PtrOf(gen.Int())
}

func Test_DeepCreatedOrigin_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeepCreatedOrigin_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeepCreatedOrigin_ARM, DeepCreatedOrigin_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeepCreatedOrigin_ARM runs a test to see if a specific instance of DeepCreatedOrigin_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeepCreatedOrigin_ARM(subject DeepCreatedOrigin_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeepCreatedOrigin_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeepCreatedOrigin_ARM instances for property testing - lazily instantiated by
// DeepCreatedOrigin_ARMGenerator()
var deepCreatedOrigin_ARMGenerator gopter.Gen

// DeepCreatedOrigin_ARMGenerator returns a generator of DeepCreatedOrigin_ARM instances for property testing.
// We first initialize deepCreatedOrigin_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeepCreatedOrigin_ARMGenerator() gopter.Gen {
	if deepCreatedOrigin_ARMGenerator != nil {
		return deepCreatedOrigin_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOrigin_ARM(generators)
	deepCreatedOrigin_ARMGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOrigin_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeepCreatedOrigin_ARM(generators)
	AddRelatedPropertyGeneratorsForDeepCreatedOrigin_ARM(generators)
	deepCreatedOrigin_ARMGenerator = gen.Struct(reflect.TypeOf(DeepCreatedOrigin_ARM{}), generators)

	return deepCreatedOrigin_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeepCreatedOrigin_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeepCreatedOrigin_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForDeepCreatedOrigin_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeepCreatedOrigin_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(DeepCreatedOriginProperties_ARMGenerator())
}

func Test_DeliveryRuleAction_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleAction_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleAction_ARM, DeliveryRuleAction_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleAction_ARM runs a test to see if a specific instance of DeliveryRuleAction_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleAction_ARM(subject DeliveryRuleAction_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleAction_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleAction_ARM instances for property testing - lazily instantiated by
// DeliveryRuleAction_ARMGenerator()
var deliveryRuleAction_ARMGenerator gopter.Gen

// DeliveryRuleAction_ARMGenerator returns a generator of DeliveryRuleAction_ARM instances for property testing.
func DeliveryRuleAction_ARMGenerator() gopter.Gen {
	if deliveryRuleAction_ARMGenerator != nil {
		return deliveryRuleAction_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeliveryRuleAction_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeliveryRuleAction_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	deliveryRuleAction_ARMGenerator = gen.OneGenOf(gens...)

	return deliveryRuleAction_ARMGenerator
}

// AddRelatedPropertyGeneratorsForDeliveryRuleAction_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleAction_ARM(gens map[string]gopter.Gen) {
	gens["CacheExpiration"] = DeliveryRuleCacheExpirationAction_ARMGenerator().Map(func(it DeliveryRuleCacheExpirationAction_ARM) *DeliveryRuleCacheExpirationAction_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["CacheKeyQueryString"] = DeliveryRuleCacheKeyQueryStringAction_ARMGenerator().Map(func(it DeliveryRuleCacheKeyQueryStringAction_ARM) *DeliveryRuleCacheKeyQueryStringAction_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["ModifyRequestHeader"] = DeliveryRuleRequestHeaderAction_ARMGenerator().Map(func(it DeliveryRuleRequestHeaderAction_ARM) *DeliveryRuleRequestHeaderAction_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["ModifyResponseHeader"] = DeliveryRuleResponseHeaderAction_ARMGenerator().Map(func(it DeliveryRuleResponseHeaderAction_ARM) *DeliveryRuleResponseHeaderAction_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["OriginGroupOverride"] = OriginGroupOverrideAction_ARMGenerator().Map(func(it OriginGroupOverrideAction_ARM) *OriginGroupOverrideAction_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["RouteConfigurationOverride"] = DeliveryRuleRouteConfigurationOverrideAction_ARMGenerator().Map(func(it DeliveryRuleRouteConfigurationOverrideAction_ARM) *DeliveryRuleRouteConfigurationOverrideAction_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["UrlRedirect"] = UrlRedirectAction_ARMGenerator().Map(func(it UrlRedirectAction_ARM) *UrlRedirectAction_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["UrlRewrite"] = UrlRewriteAction_ARMGenerator().Map(func(it UrlRewriteAction_ARM) *UrlRewriteAction_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["UrlSigning"] = UrlSigningAction_ARMGenerator().Map(func(it UrlSigningAction_ARM) *UrlSigningAction_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_DeliveryRuleCacheExpirationAction_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCacheExpirationAction_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCacheExpirationAction_ARM, DeliveryRuleCacheExpirationAction_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCacheExpirationAction_ARM runs a test to see if a specific instance of DeliveryRuleCacheExpirationAction_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCacheExpirationAction_ARM(subject DeliveryRuleCacheExpirationAction_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCacheExpirationAction_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCacheExpirationAction_ARM instances for property testing - lazily instantiated by
// DeliveryRuleCacheExpirationAction_ARMGenerator()
var deliveryRuleCacheExpirationAction_ARMGenerator gopter.Gen

// DeliveryRuleCacheExpirationAction_ARMGenerator returns a generator of DeliveryRuleCacheExpirationAction_ARM instances for property testing.
// We first initialize deliveryRuleCacheExpirationAction_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCacheExpirationAction_ARMGenerator() gopter.Gen {
	if deliveryRuleCacheExpirationAction_ARMGenerator != nil {
		return deliveryRuleCacheExpirationAction_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction_ARM(generators)
	deliveryRuleCacheExpirationAction_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheExpirationAction_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationAction_ARM(generators)
	deliveryRuleCacheExpirationAction_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheExpirationAction_ARM{}), generators)

	return deliveryRuleCacheExpirationAction_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCacheExpirationAction_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCacheExpirationAction_Name_CacheExpiration)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationAction_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCacheExpirationAction_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CacheExpirationActionParameters_ARMGenerator())
}

func Test_DeliveryRuleCacheKeyQueryStringAction_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCacheKeyQueryStringAction_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringAction_ARM, DeliveryRuleCacheKeyQueryStringAction_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringAction_ARM runs a test to see if a specific instance of DeliveryRuleCacheKeyQueryStringAction_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCacheKeyQueryStringAction_ARM(subject DeliveryRuleCacheKeyQueryStringAction_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCacheKeyQueryStringAction_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCacheKeyQueryStringAction_ARM instances for property testing - lazily instantiated by
// DeliveryRuleCacheKeyQueryStringAction_ARMGenerator()
var deliveryRuleCacheKeyQueryStringAction_ARMGenerator gopter.Gen

// DeliveryRuleCacheKeyQueryStringAction_ARMGenerator returns a generator of DeliveryRuleCacheKeyQueryStringAction_ARM instances for property testing.
// We first initialize deliveryRuleCacheKeyQueryStringAction_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCacheKeyQueryStringAction_ARMGenerator() gopter.Gen {
	if deliveryRuleCacheKeyQueryStringAction_ARMGenerator != nil {
		return deliveryRuleCacheKeyQueryStringAction_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction_ARM(generators)
	deliveryRuleCacheKeyQueryStringAction_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheKeyQueryStringAction_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction_ARM(generators)
	deliveryRuleCacheKeyQueryStringAction_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCacheKeyQueryStringAction_ARM{}), generators)

	return deliveryRuleCacheKeyQueryStringAction_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCacheKeyQueryStringAction_Name_CacheKeyQueryString)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCacheKeyQueryStringAction_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CacheKeyQueryStringActionParameters_ARMGenerator())
}

func Test_DeliveryRuleClientPortCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleClientPortCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleClientPortCondition_ARM, DeliveryRuleClientPortCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleClientPortCondition_ARM runs a test to see if a specific instance of DeliveryRuleClientPortCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleClientPortCondition_ARM(subject DeliveryRuleClientPortCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleClientPortCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleClientPortCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleClientPortCondition_ARMGenerator()
var deliveryRuleClientPortCondition_ARMGenerator gopter.Gen

// DeliveryRuleClientPortCondition_ARMGenerator returns a generator of DeliveryRuleClientPortCondition_ARM instances for property testing.
// We first initialize deliveryRuleClientPortCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleClientPortCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleClientPortCondition_ARMGenerator != nil {
		return deliveryRuleClientPortCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition_ARM(generators)
	deliveryRuleClientPortCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleClientPortCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleClientPortCondition_ARM(generators)
	deliveryRuleClientPortCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleClientPortCondition_ARM{}), generators)

	return deliveryRuleClientPortCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleClientPortCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleClientPortCondition_Name_ClientPort)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleClientPortCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleClientPortCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(ClientPortMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCondition_ARM, DeliveryRuleCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCondition_ARM runs a test to see if a specific instance of DeliveryRuleCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCondition_ARM(subject DeliveryRuleCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleCondition_ARMGenerator()
var deliveryRuleCondition_ARMGenerator gopter.Gen

// DeliveryRuleCondition_ARMGenerator returns a generator of DeliveryRuleCondition_ARM instances for property testing.
func DeliveryRuleCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleCondition_ARMGenerator != nil {
		return deliveryRuleCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForDeliveryRuleCondition_ARM(generators)

	// handle OneOf by choosing only one field to instantiate
	var gens []gopter.Gen
	for propName, propGen := range generators {
		gens = append(gens, gen.Struct(reflect.TypeOf(DeliveryRuleCondition_ARM{}), map[string]gopter.Gen{propName: propGen}))
	}
	deliveryRuleCondition_ARMGenerator = gen.OneGenOf(gens...)

	return deliveryRuleCondition_ARMGenerator
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCondition_ARM(gens map[string]gopter.Gen) {
	gens["ClientPort"] = DeliveryRuleClientPortCondition_ARMGenerator().Map(func(it DeliveryRuleClientPortCondition_ARM) *DeliveryRuleClientPortCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["Cookies"] = DeliveryRuleCookiesCondition_ARMGenerator().Map(func(it DeliveryRuleCookiesCondition_ARM) *DeliveryRuleCookiesCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["HostName"] = DeliveryRuleHostNameCondition_ARMGenerator().Map(func(it DeliveryRuleHostNameCondition_ARM) *DeliveryRuleHostNameCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["HttpVersion"] = DeliveryRuleHttpVersionCondition_ARMGenerator().Map(func(it DeliveryRuleHttpVersionCondition_ARM) *DeliveryRuleHttpVersionCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["IsDevice"] = DeliveryRuleIsDeviceCondition_ARMGenerator().Map(func(it DeliveryRuleIsDeviceCondition_ARM) *DeliveryRuleIsDeviceCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["PostArgs"] = DeliveryRulePostArgsCondition_ARMGenerator().Map(func(it DeliveryRulePostArgsCondition_ARM) *DeliveryRulePostArgsCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["QueryString"] = DeliveryRuleQueryStringCondition_ARMGenerator().Map(func(it DeliveryRuleQueryStringCondition_ARM) *DeliveryRuleQueryStringCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["RemoteAddress"] = DeliveryRuleRemoteAddressCondition_ARMGenerator().Map(func(it DeliveryRuleRemoteAddressCondition_ARM) *DeliveryRuleRemoteAddressCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["RequestBody"] = DeliveryRuleRequestBodyCondition_ARMGenerator().Map(func(it DeliveryRuleRequestBodyCondition_ARM) *DeliveryRuleRequestBodyCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["RequestHeader"] = DeliveryRuleRequestHeaderCondition_ARMGenerator().Map(func(it DeliveryRuleRequestHeaderCondition_ARM) *DeliveryRuleRequestHeaderCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["RequestMethod"] = DeliveryRuleRequestMethodCondition_ARMGenerator().Map(func(it DeliveryRuleRequestMethodCondition_ARM) *DeliveryRuleRequestMethodCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["RequestScheme"] = DeliveryRuleRequestSchemeCondition_ARMGenerator().Map(func(it DeliveryRuleRequestSchemeCondition_ARM) *DeliveryRuleRequestSchemeCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["RequestUri"] = DeliveryRuleRequestUriCondition_ARMGenerator().Map(func(it DeliveryRuleRequestUriCondition_ARM) *DeliveryRuleRequestUriCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["ServerPort"] = DeliveryRuleServerPortCondition_ARMGenerator().Map(func(it DeliveryRuleServerPortCondition_ARM) *DeliveryRuleServerPortCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["SocketAddr"] = DeliveryRuleSocketAddrCondition_ARMGenerator().Map(func(it DeliveryRuleSocketAddrCondition_ARM) *DeliveryRuleSocketAddrCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["SslProtocol"] = DeliveryRuleSslProtocolCondition_ARMGenerator().Map(func(it DeliveryRuleSslProtocolCondition_ARM) *DeliveryRuleSslProtocolCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["UrlFileExtension"] = DeliveryRuleUrlFileExtensionCondition_ARMGenerator().Map(func(it DeliveryRuleUrlFileExtensionCondition_ARM) *DeliveryRuleUrlFileExtensionCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["UrlFileName"] = DeliveryRuleUrlFileNameCondition_ARMGenerator().Map(func(it DeliveryRuleUrlFileNameCondition_ARM) *DeliveryRuleUrlFileNameCondition_ARM {
		return &it
	}) // generate one case for OneOf type
	gens["UrlPath"] = DeliveryRuleUrlPathCondition_ARMGenerator().Map(func(it DeliveryRuleUrlPathCondition_ARM) *DeliveryRuleUrlPathCondition_ARM {
		return &it
	}) // generate one case for OneOf type
}

func Test_DeliveryRuleCookiesCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleCookiesCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleCookiesCondition_ARM, DeliveryRuleCookiesCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleCookiesCondition_ARM runs a test to see if a specific instance of DeliveryRuleCookiesCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleCookiesCondition_ARM(subject DeliveryRuleCookiesCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleCookiesCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleCookiesCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleCookiesCondition_ARMGenerator()
var deliveryRuleCookiesCondition_ARMGenerator gopter.Gen

// DeliveryRuleCookiesCondition_ARMGenerator returns a generator of DeliveryRuleCookiesCondition_ARM instances for property testing.
// We first initialize deliveryRuleCookiesCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleCookiesCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleCookiesCondition_ARMGenerator != nil {
		return deliveryRuleCookiesCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition_ARM(generators)
	deliveryRuleCookiesCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCookiesCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleCookiesCondition_ARM(generators)
	deliveryRuleCookiesCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleCookiesCondition_ARM{}), generators)

	return deliveryRuleCookiesCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleCookiesCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleCookiesCondition_Name_Cookies)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleCookiesCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleCookiesCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(CookiesMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleHostNameCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleHostNameCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleHostNameCondition_ARM, DeliveryRuleHostNameCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleHostNameCondition_ARM runs a test to see if a specific instance of DeliveryRuleHostNameCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleHostNameCondition_ARM(subject DeliveryRuleHostNameCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleHostNameCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleHostNameCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleHostNameCondition_ARMGenerator()
var deliveryRuleHostNameCondition_ARMGenerator gopter.Gen

// DeliveryRuleHostNameCondition_ARMGenerator returns a generator of DeliveryRuleHostNameCondition_ARM instances for property testing.
// We first initialize deliveryRuleHostNameCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleHostNameCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleHostNameCondition_ARMGenerator != nil {
		return deliveryRuleHostNameCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition_ARM(generators)
	deliveryRuleHostNameCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHostNameCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleHostNameCondition_ARM(generators)
	deliveryRuleHostNameCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHostNameCondition_ARM{}), generators)

	return deliveryRuleHostNameCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleHostNameCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleHostNameCondition_Name_HostName)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleHostNameCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleHostNameCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HostNameMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleHttpVersionCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleHttpVersionCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleHttpVersionCondition_ARM, DeliveryRuleHttpVersionCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleHttpVersionCondition_ARM runs a test to see if a specific instance of DeliveryRuleHttpVersionCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleHttpVersionCondition_ARM(subject DeliveryRuleHttpVersionCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleHttpVersionCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleHttpVersionCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleHttpVersionCondition_ARMGenerator()
var deliveryRuleHttpVersionCondition_ARMGenerator gopter.Gen

// DeliveryRuleHttpVersionCondition_ARMGenerator returns a generator of DeliveryRuleHttpVersionCondition_ARM instances for property testing.
// We first initialize deliveryRuleHttpVersionCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleHttpVersionCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleHttpVersionCondition_ARMGenerator != nil {
		return deliveryRuleHttpVersionCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition_ARM(generators)
	deliveryRuleHttpVersionCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHttpVersionCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionCondition_ARM(generators)
	deliveryRuleHttpVersionCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleHttpVersionCondition_ARM{}), generators)

	return deliveryRuleHttpVersionCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleHttpVersionCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleHttpVersionCondition_Name_HttpVersion)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleHttpVersionCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HttpVersionMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleIsDeviceCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleIsDeviceCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleIsDeviceCondition_ARM, DeliveryRuleIsDeviceCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleIsDeviceCondition_ARM runs a test to see if a specific instance of DeliveryRuleIsDeviceCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleIsDeviceCondition_ARM(subject DeliveryRuleIsDeviceCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleIsDeviceCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleIsDeviceCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleIsDeviceCondition_ARMGenerator()
var deliveryRuleIsDeviceCondition_ARMGenerator gopter.Gen

// DeliveryRuleIsDeviceCondition_ARMGenerator returns a generator of DeliveryRuleIsDeviceCondition_ARM instances for property testing.
// We first initialize deliveryRuleIsDeviceCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleIsDeviceCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleIsDeviceCondition_ARMGenerator != nil {
		return deliveryRuleIsDeviceCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition_ARM(generators)
	deliveryRuleIsDeviceCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleIsDeviceCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceCondition_ARM(generators)
	deliveryRuleIsDeviceCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleIsDeviceCondition_ARM{}), generators)

	return deliveryRuleIsDeviceCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleIsDeviceCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleIsDeviceCondition_Name_IsDevice)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleIsDeviceCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(IsDeviceMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRulePostArgsCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRulePostArgsCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRulePostArgsCondition_ARM, DeliveryRulePostArgsCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRulePostArgsCondition_ARM runs a test to see if a specific instance of DeliveryRulePostArgsCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRulePostArgsCondition_ARM(subject DeliveryRulePostArgsCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRulePostArgsCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRulePostArgsCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRulePostArgsCondition_ARMGenerator()
var deliveryRulePostArgsCondition_ARMGenerator gopter.Gen

// DeliveryRulePostArgsCondition_ARMGenerator returns a generator of DeliveryRulePostArgsCondition_ARM instances for property testing.
// We first initialize deliveryRulePostArgsCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRulePostArgsCondition_ARMGenerator() gopter.Gen {
	if deliveryRulePostArgsCondition_ARMGenerator != nil {
		return deliveryRulePostArgsCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition_ARM(generators)
	deliveryRulePostArgsCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRulePostArgsCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRulePostArgsCondition_ARM(generators)
	deliveryRulePostArgsCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRulePostArgsCondition_ARM{}), generators)

	return deliveryRulePostArgsCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRulePostArgsCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRulePostArgsCondition_Name_PostArgs)
}

// AddRelatedPropertyGeneratorsForDeliveryRulePostArgsCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRulePostArgsCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(PostArgsMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleQueryStringCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleQueryStringCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleQueryStringCondition_ARM, DeliveryRuleQueryStringCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleQueryStringCondition_ARM runs a test to see if a specific instance of DeliveryRuleQueryStringCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleQueryStringCondition_ARM(subject DeliveryRuleQueryStringCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleQueryStringCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleQueryStringCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleQueryStringCondition_ARMGenerator()
var deliveryRuleQueryStringCondition_ARMGenerator gopter.Gen

// DeliveryRuleQueryStringCondition_ARMGenerator returns a generator of DeliveryRuleQueryStringCondition_ARM instances for property testing.
// We first initialize deliveryRuleQueryStringCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleQueryStringCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleQueryStringCondition_ARMGenerator != nil {
		return deliveryRuleQueryStringCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition_ARM(generators)
	deliveryRuleQueryStringCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleQueryStringCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringCondition_ARM(generators)
	deliveryRuleQueryStringCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleQueryStringCondition_ARM{}), generators)

	return deliveryRuleQueryStringCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleQueryStringCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleQueryStringCondition_Name_QueryString)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleQueryStringCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(QueryStringMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleRemoteAddressCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRemoteAddressCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRemoteAddressCondition_ARM, DeliveryRuleRemoteAddressCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRemoteAddressCondition_ARM runs a test to see if a specific instance of DeliveryRuleRemoteAddressCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRemoteAddressCondition_ARM(subject DeliveryRuleRemoteAddressCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRemoteAddressCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRemoteAddressCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleRemoteAddressCondition_ARMGenerator()
var deliveryRuleRemoteAddressCondition_ARMGenerator gopter.Gen

// DeliveryRuleRemoteAddressCondition_ARMGenerator returns a generator of DeliveryRuleRemoteAddressCondition_ARM instances for property testing.
// We first initialize deliveryRuleRemoteAddressCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRemoteAddressCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleRemoteAddressCondition_ARMGenerator != nil {
		return deliveryRuleRemoteAddressCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition_ARM(generators)
	deliveryRuleRemoteAddressCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRemoteAddressCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressCondition_ARM(generators)
	deliveryRuleRemoteAddressCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRemoteAddressCondition_ARM{}), generators)

	return deliveryRuleRemoteAddressCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRemoteAddressCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRemoteAddressCondition_Name_RemoteAddress)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRemoteAddressCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RemoteAddressMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleRequestBodyCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestBodyCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestBodyCondition_ARM, DeliveryRuleRequestBodyCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestBodyCondition_ARM runs a test to see if a specific instance of DeliveryRuleRequestBodyCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestBodyCondition_ARM(subject DeliveryRuleRequestBodyCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestBodyCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestBodyCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestBodyCondition_ARMGenerator()
var deliveryRuleRequestBodyCondition_ARMGenerator gopter.Gen

// DeliveryRuleRequestBodyCondition_ARMGenerator returns a generator of DeliveryRuleRequestBodyCondition_ARM instances for property testing.
// We first initialize deliveryRuleRequestBodyCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestBodyCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleRequestBodyCondition_ARMGenerator != nil {
		return deliveryRuleRequestBodyCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition_ARM(generators)
	deliveryRuleRequestBodyCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestBodyCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyCondition_ARM(generators)
	deliveryRuleRequestBodyCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestBodyCondition_ARM{}), generators)

	return deliveryRuleRequestBodyCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestBodyCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestBodyCondition_Name_RequestBody)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestBodyCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestBodyMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleRequestHeaderAction_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestHeaderAction_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestHeaderAction_ARM, DeliveryRuleRequestHeaderAction_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestHeaderAction_ARM runs a test to see if a specific instance of DeliveryRuleRequestHeaderAction_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestHeaderAction_ARM(subject DeliveryRuleRequestHeaderAction_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestHeaderAction_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestHeaderAction_ARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestHeaderAction_ARMGenerator()
var deliveryRuleRequestHeaderAction_ARMGenerator gopter.Gen

// DeliveryRuleRequestHeaderAction_ARMGenerator returns a generator of DeliveryRuleRequestHeaderAction_ARM instances for property testing.
// We first initialize deliveryRuleRequestHeaderAction_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestHeaderAction_ARMGenerator() gopter.Gen {
	if deliveryRuleRequestHeaderAction_ARMGenerator != nil {
		return deliveryRuleRequestHeaderAction_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction_ARM(generators)
	deliveryRuleRequestHeaderAction_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderAction_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderAction_ARM(generators)
	deliveryRuleRequestHeaderAction_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderAction_ARM{}), generators)

	return deliveryRuleRequestHeaderAction_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderAction_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestHeaderAction_Name_ModifyRequestHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderAction_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderAction_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HeaderActionParameters_ARMGenerator())
}

func Test_DeliveryRuleRequestHeaderCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestHeaderCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestHeaderCondition_ARM, DeliveryRuleRequestHeaderCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestHeaderCondition_ARM runs a test to see if a specific instance of DeliveryRuleRequestHeaderCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestHeaderCondition_ARM(subject DeliveryRuleRequestHeaderCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestHeaderCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestHeaderCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestHeaderCondition_ARMGenerator()
var deliveryRuleRequestHeaderCondition_ARMGenerator gopter.Gen

// DeliveryRuleRequestHeaderCondition_ARMGenerator returns a generator of DeliveryRuleRequestHeaderCondition_ARM instances for property testing.
// We first initialize deliveryRuleRequestHeaderCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestHeaderCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleRequestHeaderCondition_ARMGenerator != nil {
		return deliveryRuleRequestHeaderCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition_ARM(generators)
	deliveryRuleRequestHeaderCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderCondition_ARM(generators)
	deliveryRuleRequestHeaderCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestHeaderCondition_ARM{}), generators)

	return deliveryRuleRequestHeaderCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestHeaderCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestHeaderCondition_Name_RequestHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestHeaderCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestHeaderMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleRequestMethodCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestMethodCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestMethodCondition_ARM, DeliveryRuleRequestMethodCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestMethodCondition_ARM runs a test to see if a specific instance of DeliveryRuleRequestMethodCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestMethodCondition_ARM(subject DeliveryRuleRequestMethodCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestMethodCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestMethodCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestMethodCondition_ARMGenerator()
var deliveryRuleRequestMethodCondition_ARMGenerator gopter.Gen

// DeliveryRuleRequestMethodCondition_ARMGenerator returns a generator of DeliveryRuleRequestMethodCondition_ARM instances for property testing.
// We first initialize deliveryRuleRequestMethodCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestMethodCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleRequestMethodCondition_ARMGenerator != nil {
		return deliveryRuleRequestMethodCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition_ARM(generators)
	deliveryRuleRequestMethodCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestMethodCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodCondition_ARM(generators)
	deliveryRuleRequestMethodCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestMethodCondition_ARM{}), generators)

	return deliveryRuleRequestMethodCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestMethodCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestMethodCondition_Name_RequestMethod)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestMethodCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestMethodMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleRequestSchemeCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestSchemeCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestSchemeCondition_ARM, DeliveryRuleRequestSchemeCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestSchemeCondition_ARM runs a test to see if a specific instance of DeliveryRuleRequestSchemeCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestSchemeCondition_ARM(subject DeliveryRuleRequestSchemeCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestSchemeCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestSchemeCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestSchemeCondition_ARMGenerator()
var deliveryRuleRequestSchemeCondition_ARMGenerator gopter.Gen

// DeliveryRuleRequestSchemeCondition_ARMGenerator returns a generator of DeliveryRuleRequestSchemeCondition_ARM instances for property testing.
// We first initialize deliveryRuleRequestSchemeCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestSchemeCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleRequestSchemeCondition_ARMGenerator != nil {
		return deliveryRuleRequestSchemeCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition_ARM(generators)
	deliveryRuleRequestSchemeCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestSchemeCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeCondition_ARM(generators)
	deliveryRuleRequestSchemeCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestSchemeCondition_ARM{}), generators)

	return deliveryRuleRequestSchemeCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestSchemeCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestSchemeCondition_Name_RequestScheme)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestSchemeCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestSchemeMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleRequestUriCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRequestUriCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRequestUriCondition_ARM, DeliveryRuleRequestUriCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRequestUriCondition_ARM runs a test to see if a specific instance of DeliveryRuleRequestUriCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRequestUriCondition_ARM(subject DeliveryRuleRequestUriCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRequestUriCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRequestUriCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleRequestUriCondition_ARMGenerator()
var deliveryRuleRequestUriCondition_ARMGenerator gopter.Gen

// DeliveryRuleRequestUriCondition_ARMGenerator returns a generator of DeliveryRuleRequestUriCondition_ARM instances for property testing.
// We first initialize deliveryRuleRequestUriCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRequestUriCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleRequestUriCondition_ARMGenerator != nil {
		return deliveryRuleRequestUriCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition_ARM(generators)
	deliveryRuleRequestUriCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestUriCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriCondition_ARM(generators)
	deliveryRuleRequestUriCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRequestUriCondition_ARM{}), generators)

	return deliveryRuleRequestUriCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRequestUriCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRequestUriCondition_Name_RequestUri)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRequestUriCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RequestUriMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleResponseHeaderAction_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleResponseHeaderAction_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleResponseHeaderAction_ARM, DeliveryRuleResponseHeaderAction_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleResponseHeaderAction_ARM runs a test to see if a specific instance of DeliveryRuleResponseHeaderAction_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleResponseHeaderAction_ARM(subject DeliveryRuleResponseHeaderAction_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleResponseHeaderAction_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleResponseHeaderAction_ARM instances for property testing - lazily instantiated by
// DeliveryRuleResponseHeaderAction_ARMGenerator()
var deliveryRuleResponseHeaderAction_ARMGenerator gopter.Gen

// DeliveryRuleResponseHeaderAction_ARMGenerator returns a generator of DeliveryRuleResponseHeaderAction_ARM instances for property testing.
// We first initialize deliveryRuleResponseHeaderAction_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleResponseHeaderAction_ARMGenerator() gopter.Gen {
	if deliveryRuleResponseHeaderAction_ARMGenerator != nil {
		return deliveryRuleResponseHeaderAction_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction_ARM(generators)
	deliveryRuleResponseHeaderAction_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleResponseHeaderAction_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderAction_ARM(generators)
	deliveryRuleResponseHeaderAction_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleResponseHeaderAction_ARM{}), generators)

	return deliveryRuleResponseHeaderAction_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleResponseHeaderAction_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleResponseHeaderAction_Name_ModifyResponseHeader)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderAction_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleResponseHeaderAction_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(HeaderActionParameters_ARMGenerator())
}

func Test_DeliveryRuleRouteConfigurationOverrideAction_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleRouteConfigurationOverrideAction_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideAction_ARM, DeliveryRuleRouteConfigurationOverrideAction_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideAction_ARM runs a test to see if a specific instance of DeliveryRuleRouteConfigurationOverrideAction_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleRouteConfigurationOverrideAction_ARM(subject DeliveryRuleRouteConfigurationOverrideAction_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleRouteConfigurationOverrideAction_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleRouteConfigurationOverrideAction_ARM instances for property testing - lazily instantiated by
// DeliveryRuleRouteConfigurationOverrideAction_ARMGenerator()
var deliveryRuleRouteConfigurationOverrideAction_ARMGenerator gopter.Gen

// DeliveryRuleRouteConfigurationOverrideAction_ARMGenerator returns a generator of DeliveryRuleRouteConfigurationOverrideAction_ARM instances for property testing.
// We first initialize deliveryRuleRouteConfigurationOverrideAction_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleRouteConfigurationOverrideAction_ARMGenerator() gopter.Gen {
	if deliveryRuleRouteConfigurationOverrideAction_ARMGenerator != nil {
		return deliveryRuleRouteConfigurationOverrideAction_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction_ARM(generators)
	deliveryRuleRouteConfigurationOverrideAction_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRouteConfigurationOverrideAction_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction_ARM(generators)
	deliveryRuleRouteConfigurationOverrideAction_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleRouteConfigurationOverrideAction_ARM{}), generators)

	return deliveryRuleRouteConfigurationOverrideAction_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleRouteConfigurationOverrideAction_Name_RouteConfigurationOverride)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleRouteConfigurationOverrideAction_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(RouteConfigurationOverrideActionParameters_ARMGenerator())
}

func Test_DeliveryRuleServerPortCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleServerPortCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleServerPortCondition_ARM, DeliveryRuleServerPortCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleServerPortCondition_ARM runs a test to see if a specific instance of DeliveryRuleServerPortCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleServerPortCondition_ARM(subject DeliveryRuleServerPortCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleServerPortCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleServerPortCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleServerPortCondition_ARMGenerator()
var deliveryRuleServerPortCondition_ARMGenerator gopter.Gen

// DeliveryRuleServerPortCondition_ARMGenerator returns a generator of DeliveryRuleServerPortCondition_ARM instances for property testing.
// We first initialize deliveryRuleServerPortCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleServerPortCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleServerPortCondition_ARMGenerator != nil {
		return deliveryRuleServerPortCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition_ARM(generators)
	deliveryRuleServerPortCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleServerPortCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleServerPortCondition_ARM(generators)
	deliveryRuleServerPortCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleServerPortCondition_ARM{}), generators)

	return deliveryRuleServerPortCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleServerPortCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleServerPortCondition_Name_ServerPort)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleServerPortCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleServerPortCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(ServerPortMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleSocketAddrCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleSocketAddrCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleSocketAddrCondition_ARM, DeliveryRuleSocketAddrCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleSocketAddrCondition_ARM runs a test to see if a specific instance of DeliveryRuleSocketAddrCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleSocketAddrCondition_ARM(subject DeliveryRuleSocketAddrCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleSocketAddrCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleSocketAddrCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleSocketAddrCondition_ARMGenerator()
var deliveryRuleSocketAddrCondition_ARMGenerator gopter.Gen

// DeliveryRuleSocketAddrCondition_ARMGenerator returns a generator of DeliveryRuleSocketAddrCondition_ARM instances for property testing.
// We first initialize deliveryRuleSocketAddrCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleSocketAddrCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleSocketAddrCondition_ARMGenerator != nil {
		return deliveryRuleSocketAddrCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition_ARM(generators)
	deliveryRuleSocketAddrCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSocketAddrCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrCondition_ARM(generators)
	deliveryRuleSocketAddrCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSocketAddrCondition_ARM{}), generators)

	return deliveryRuleSocketAddrCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleSocketAddrCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleSocketAddrCondition_Name_SocketAddr)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleSocketAddrCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(SocketAddrMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleSslProtocolCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleSslProtocolCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleSslProtocolCondition_ARM, DeliveryRuleSslProtocolCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleSslProtocolCondition_ARM runs a test to see if a specific instance of DeliveryRuleSslProtocolCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleSslProtocolCondition_ARM(subject DeliveryRuleSslProtocolCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleSslProtocolCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleSslProtocolCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleSslProtocolCondition_ARMGenerator()
var deliveryRuleSslProtocolCondition_ARMGenerator gopter.Gen

// DeliveryRuleSslProtocolCondition_ARMGenerator returns a generator of DeliveryRuleSslProtocolCondition_ARM instances for property testing.
// We first initialize deliveryRuleSslProtocolCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleSslProtocolCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleSslProtocolCondition_ARMGenerator != nil {
		return deliveryRuleSslProtocolCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition_ARM(generators)
	deliveryRuleSslProtocolCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSslProtocolCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolCondition_ARM(generators)
	deliveryRuleSslProtocolCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleSslProtocolCondition_ARM{}), generators)

	return deliveryRuleSslProtocolCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleSslProtocolCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleSslProtocolCondition_Name_SslProtocol)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleSslProtocolCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(SslProtocolMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleUrlFileExtensionCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlFileExtensionCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlFileExtensionCondition_ARM, DeliveryRuleUrlFileExtensionCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlFileExtensionCondition_ARM runs a test to see if a specific instance of DeliveryRuleUrlFileExtensionCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlFileExtensionCondition_ARM(subject DeliveryRuleUrlFileExtensionCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlFileExtensionCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlFileExtensionCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleUrlFileExtensionCondition_ARMGenerator()
var deliveryRuleUrlFileExtensionCondition_ARMGenerator gopter.Gen

// DeliveryRuleUrlFileExtensionCondition_ARMGenerator returns a generator of DeliveryRuleUrlFileExtensionCondition_ARM instances for property testing.
// We first initialize deliveryRuleUrlFileExtensionCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlFileExtensionCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleUrlFileExtensionCondition_ARMGenerator != nil {
		return deliveryRuleUrlFileExtensionCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition_ARM(generators)
	deliveryRuleUrlFileExtensionCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileExtensionCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition_ARM(generators)
	deliveryRuleUrlFileExtensionCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileExtensionCondition_ARM{}), generators)

	return deliveryRuleUrlFileExtensionCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlFileExtensionCondition_Name_UrlFileExtension)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileExtensionCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlFileExtensionMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleUrlFileNameCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlFileNameCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlFileNameCondition_ARM, DeliveryRuleUrlFileNameCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlFileNameCondition_ARM runs a test to see if a specific instance of DeliveryRuleUrlFileNameCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlFileNameCondition_ARM(subject DeliveryRuleUrlFileNameCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlFileNameCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlFileNameCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleUrlFileNameCondition_ARMGenerator()
var deliveryRuleUrlFileNameCondition_ARMGenerator gopter.Gen

// DeliveryRuleUrlFileNameCondition_ARMGenerator returns a generator of DeliveryRuleUrlFileNameCondition_ARM instances for property testing.
// We first initialize deliveryRuleUrlFileNameCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlFileNameCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleUrlFileNameCondition_ARMGenerator != nil {
		return deliveryRuleUrlFileNameCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition_ARM(generators)
	deliveryRuleUrlFileNameCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileNameCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameCondition_ARM(generators)
	deliveryRuleUrlFileNameCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlFileNameCondition_ARM{}), generators)

	return deliveryRuleUrlFileNameCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlFileNameCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlFileNameCondition_Name_UrlFileName)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlFileNameCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlFileNameMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRuleUrlPathCondition_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRuleUrlPathCondition_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRuleUrlPathCondition_ARM, DeliveryRuleUrlPathCondition_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRuleUrlPathCondition_ARM runs a test to see if a specific instance of DeliveryRuleUrlPathCondition_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRuleUrlPathCondition_ARM(subject DeliveryRuleUrlPathCondition_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRuleUrlPathCondition_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRuleUrlPathCondition_ARM instances for property testing - lazily instantiated by
// DeliveryRuleUrlPathCondition_ARMGenerator()
var deliveryRuleUrlPathCondition_ARMGenerator gopter.Gen

// DeliveryRuleUrlPathCondition_ARMGenerator returns a generator of DeliveryRuleUrlPathCondition_ARM instances for property testing.
// We first initialize deliveryRuleUrlPathCondition_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRuleUrlPathCondition_ARMGenerator() gopter.Gen {
	if deliveryRuleUrlPathCondition_ARMGenerator != nil {
		return deliveryRuleUrlPathCondition_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition_ARM(generators)
	deliveryRuleUrlPathCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlPathCondition_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathCondition_ARM(generators)
	deliveryRuleUrlPathCondition_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRuleUrlPathCondition_ARM{}), generators)

	return deliveryRuleUrlPathCondition_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRuleUrlPathCondition_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(DeliveryRuleUrlPathCondition_Name_UrlPath)
}

// AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathCondition_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRuleUrlPathCondition_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlPathMatchConditionParameters_ARMGenerator())
}

func Test_DeliveryRule_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of DeliveryRule_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForDeliveryRule_ARM, DeliveryRule_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForDeliveryRule_ARM runs a test to see if a specific instance of DeliveryRule_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForDeliveryRule_ARM(subject DeliveryRule_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual DeliveryRule_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of DeliveryRule_ARM instances for property testing - lazily instantiated by DeliveryRule_ARMGenerator()
var deliveryRule_ARMGenerator gopter.Gen

// DeliveryRule_ARMGenerator returns a generator of DeliveryRule_ARM instances for property testing.
// We first initialize deliveryRule_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func DeliveryRule_ARMGenerator() gopter.Gen {
	if deliveryRule_ARMGenerator != nil {
		return deliveryRule_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRule_ARM(generators)
	deliveryRule_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRule_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForDeliveryRule_ARM(generators)
	AddRelatedPropertyGeneratorsForDeliveryRule_ARM(generators)
	deliveryRule_ARMGenerator = gen.Struct(reflect.TypeOf(DeliveryRule_ARM{}), generators)

	return deliveryRule_ARMGenerator
}

// AddIndependentPropertyGeneratorsForDeliveryRule_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForDeliveryRule_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Order"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForDeliveryRule_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForDeliveryRule_ARM(gens map[string]gopter.Gen) {
	gens["Actions"] = gen.SliceOf(DeliveryRuleAction_ARMGenerator())
	gens["Conditions"] = gen.SliceOf(DeliveryRuleCondition_ARMGenerator())
}

func Test_EndpointProperties_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointProperties_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointProperties_ARM, EndpointProperties_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointProperties_ARM runs a test to see if a specific instance of EndpointProperties_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointProperties_ARM(subject EndpointProperties_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointProperties_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointProperties_ARM instances for property testing - lazily instantiated by
// EndpointProperties_ARMGenerator()
var endpointProperties_ARMGenerator gopter.Gen

// EndpointProperties_ARMGenerator returns a generator of EndpointProperties_ARM instances for property testing.
// We first initialize endpointProperties_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EndpointProperties_ARMGenerator() gopter.Gen {
	if endpointProperties_ARMGenerator != nil {
		return endpointProperties_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_ARM(generators)
	endpointProperties_ARMGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_ARM(generators)
	AddRelatedPropertyGeneratorsForEndpointProperties_ARM(generators)
	endpointProperties_ARMGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_ARM{}), generators)

	return endpointProperties_ARMGenerator
}

// AddIndependentPropertyGeneratorsForEndpointProperties_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointProperties_ARM(gens map[string]gopter.Gen) {
	gens["ContentTypesToCompress"] = gen.SliceOf(gen.AlphaString())
	gens["IsCompressionEnabled"] = gen.PtrOf(gen.Bool())
	gens["IsHttpAllowed"] = gen.PtrOf(gen.Bool())
	gens["IsHttpsAllowed"] = gen.PtrOf(gen.Bool())
	gens["OptimizationType"] = gen.PtrOf(gen.OneConstOf(
		OptimizationType_DynamicSiteAcceleration,
		OptimizationType_GeneralMediaStreaming,
		OptimizationType_GeneralWebDelivery,
		OptimizationType_LargeFileDownload,
		OptimizationType_VideoOnDemandMediaStreaming))
	gens["OriginHostHeader"] = gen.PtrOf(gen.AlphaString())
	gens["OriginPath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["QueryStringCachingBehavior"] = gen.PtrOf(gen.OneConstOf(
		QueryStringCachingBehavior_BypassCaching,
		QueryStringCachingBehavior_IgnoreQueryString,
		QueryStringCachingBehavior_NotSet,
		QueryStringCachingBehavior_UseQueryString))
}

// AddRelatedPropertyGeneratorsForEndpointProperties_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpointProperties_ARM(gens map[string]gopter.Gen) {
	gens["DefaultOriginGroup"] = gen.PtrOf(ResourceReference_ARMGenerator())
	gens["DeliveryPolicy"] = gen.PtrOf(EndpointProperties_DeliveryPolicy_ARMGenerator())
	gens["GeoFilters"] = gen.SliceOf(GeoFilter_ARMGenerator())
	gens["OriginGroups"] = gen.SliceOf(DeepCreatedOriginGroup_ARMGenerator())
	gens["Origins"] = gen.SliceOf(DeepCreatedOrigin_ARMGenerator())
	gens["UrlSigningKeys"] = gen.SliceOf(UrlSigningKey_ARMGenerator())
	gens["WebApplicationFirewallPolicyLink"] = gen.PtrOf(EndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator())
}

func Test_EndpointProperties_DeliveryPolicy_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointProperties_DeliveryPolicy_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointProperties_DeliveryPolicy_ARM, EndpointProperties_DeliveryPolicy_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointProperties_DeliveryPolicy_ARM runs a test to see if a specific instance of EndpointProperties_DeliveryPolicy_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointProperties_DeliveryPolicy_ARM(subject EndpointProperties_DeliveryPolicy_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointProperties_DeliveryPolicy_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointProperties_DeliveryPolicy_ARM instances for property testing - lazily instantiated by
// EndpointProperties_DeliveryPolicy_ARMGenerator()
var endpointProperties_DeliveryPolicy_ARMGenerator gopter.Gen

// EndpointProperties_DeliveryPolicy_ARMGenerator returns a generator of EndpointProperties_DeliveryPolicy_ARM instances for property testing.
// We first initialize endpointProperties_DeliveryPolicy_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func EndpointProperties_DeliveryPolicy_ARMGenerator() gopter.Gen {
	if endpointProperties_DeliveryPolicy_ARMGenerator != nil {
		return endpointProperties_DeliveryPolicy_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy_ARM(generators)
	endpointProperties_DeliveryPolicy_ARMGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_DeliveryPolicy_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy_ARM(generators)
	AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy_ARM(generators)
	endpointProperties_DeliveryPolicy_ARMGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_DeliveryPolicy_ARM{}), generators)

	return endpointProperties_DeliveryPolicy_ARMGenerator
}

// AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointProperties_DeliveryPolicy_ARM(gens map[string]gopter.Gen) {
	gens["Description"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForEndpointProperties_DeliveryPolicy_ARM(gens map[string]gopter.Gen) {
	gens["Rules"] = gen.SliceOf(DeliveryRule_ARMGenerator())
}

func Test_EndpointProperties_WebApplicationFirewallPolicyLink_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of EndpointProperties_WebApplicationFirewallPolicyLink_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink_ARM, EndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink_ARM runs a test to see if a specific instance of EndpointProperties_WebApplicationFirewallPolicyLink_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForEndpointProperties_WebApplicationFirewallPolicyLink_ARM(subject EndpointProperties_WebApplicationFirewallPolicyLink_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual EndpointProperties_WebApplicationFirewallPolicyLink_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of EndpointProperties_WebApplicationFirewallPolicyLink_ARM instances for property testing - lazily
// instantiated by EndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator()
var endpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator gopter.Gen

// EndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator returns a generator of EndpointProperties_WebApplicationFirewallPolicyLink_ARM instances for property testing.
func EndpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator() gopter.Gen {
	if endpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator != nil {
		return endpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForEndpointProperties_WebApplicationFirewallPolicyLink_ARM(generators)
	endpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator = gen.Struct(reflect.TypeOf(EndpointProperties_WebApplicationFirewallPolicyLink_ARM{}), generators)

	return endpointProperties_WebApplicationFirewallPolicyLink_ARMGenerator
}

// AddIndependentPropertyGeneratorsForEndpointProperties_WebApplicationFirewallPolicyLink_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForEndpointProperties_WebApplicationFirewallPolicyLink_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_GeoFilter_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of GeoFilter_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForGeoFilter_ARM, GeoFilter_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForGeoFilter_ARM runs a test to see if a specific instance of GeoFilter_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForGeoFilter_ARM(subject GeoFilter_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual GeoFilter_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of GeoFilter_ARM instances for property testing - lazily instantiated by GeoFilter_ARMGenerator()
var geoFilter_ARMGenerator gopter.Gen

// GeoFilter_ARMGenerator returns a generator of GeoFilter_ARM instances for property testing.
func GeoFilter_ARMGenerator() gopter.Gen {
	if geoFilter_ARMGenerator != nil {
		return geoFilter_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForGeoFilter_ARM(generators)
	geoFilter_ARMGenerator = gen.Struct(reflect.TypeOf(GeoFilter_ARM{}), generators)

	return geoFilter_ARMGenerator
}

// AddIndependentPropertyGeneratorsForGeoFilter_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForGeoFilter_ARM(gens map[string]gopter.Gen) {
	gens["Action"] = gen.PtrOf(gen.OneConstOf(GeoFilter_Action_Allow, GeoFilter_Action_Block))
	gens["CountryCodes"] = gen.SliceOf(gen.AlphaString())
	gens["RelativePath"] = gen.PtrOf(gen.AlphaString())
}

func Test_HeaderActionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HeaderActionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHeaderActionParameters_ARM, HeaderActionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHeaderActionParameters_ARM runs a test to see if a specific instance of HeaderActionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHeaderActionParameters_ARM(subject HeaderActionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HeaderActionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HeaderActionParameters_ARM instances for property testing - lazily instantiated by
// HeaderActionParameters_ARMGenerator()
var headerActionParameters_ARMGenerator gopter.Gen

// HeaderActionParameters_ARMGenerator returns a generator of HeaderActionParameters_ARM instances for property testing.
func HeaderActionParameters_ARMGenerator() gopter.Gen {
	if headerActionParameters_ARMGenerator != nil {
		return headerActionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHeaderActionParameters_ARM(generators)
	headerActionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(HeaderActionParameters_ARM{}), generators)

	return headerActionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHeaderActionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHeaderActionParameters_ARM(gens map[string]gopter.Gen) {
	gens["HeaderAction"] = gen.PtrOf(gen.OneConstOf(HeaderActionParameters_HeaderAction_Append, HeaderActionParameters_HeaderAction_Delete, HeaderActionParameters_HeaderAction_Overwrite))
	gens["HeaderName"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HeaderActionParameters_TypeName_DeliveryRuleHeaderActionParameters))
	gens["Value"] = gen.PtrOf(gen.AlphaString())
}

func Test_HealthProbeParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HealthProbeParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHealthProbeParameters_ARM, HealthProbeParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHealthProbeParameters_ARM runs a test to see if a specific instance of HealthProbeParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHealthProbeParameters_ARM(subject HealthProbeParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HealthProbeParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HealthProbeParameters_ARM instances for property testing - lazily instantiated by
// HealthProbeParameters_ARMGenerator()
var healthProbeParameters_ARMGenerator gopter.Gen

// HealthProbeParameters_ARMGenerator returns a generator of HealthProbeParameters_ARM instances for property testing.
func HealthProbeParameters_ARMGenerator() gopter.Gen {
	if healthProbeParameters_ARMGenerator != nil {
		return healthProbeParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHealthProbeParameters_ARM(generators)
	healthProbeParameters_ARMGenerator = gen.Struct(reflect.TypeOf(HealthProbeParameters_ARM{}), generators)

	return healthProbeParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHealthProbeParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHealthProbeParameters_ARM(gens map[string]gopter.Gen) {
	gens["ProbeIntervalInSeconds"] = gen.PtrOf(gen.Int())
	gens["ProbePath"] = gen.PtrOf(gen.AlphaString())
	gens["ProbeProtocol"] = gen.PtrOf(gen.OneConstOf(HealthProbeParameters_ProbeProtocol_Http, HealthProbeParameters_ProbeProtocol_Https, HealthProbeParameters_ProbeProtocol_NotSet))
	gens["ProbeRequestType"] = gen.PtrOf(gen.OneConstOf(HealthProbeParameters_ProbeRequestType_GET, HealthProbeParameters_ProbeRequestType_HEAD, HealthProbeParameters_ProbeRequestType_NotSet))
}

func Test_HostNameMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HostNameMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHostNameMatchConditionParameters_ARM, HostNameMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHostNameMatchConditionParameters_ARM runs a test to see if a specific instance of HostNameMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHostNameMatchConditionParameters_ARM(subject HostNameMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HostNameMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HostNameMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// HostNameMatchConditionParameters_ARMGenerator()
var hostNameMatchConditionParameters_ARMGenerator gopter.Gen

// HostNameMatchConditionParameters_ARMGenerator returns a generator of HostNameMatchConditionParameters_ARM instances for property testing.
func HostNameMatchConditionParameters_ARMGenerator() gopter.Gen {
	if hostNameMatchConditionParameters_ARMGenerator != nil {
		return hostNameMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHostNameMatchConditionParameters_ARM(generators)
	hostNameMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(HostNameMatchConditionParameters_ARM{}), generators)

	return hostNameMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHostNameMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHostNameMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		HostNameMatchConditionParameters_Operator_Any,
		HostNameMatchConditionParameters_Operator_BeginsWith,
		HostNameMatchConditionParameters_Operator_Contains,
		HostNameMatchConditionParameters_Operator_EndsWith,
		HostNameMatchConditionParameters_Operator_Equal,
		HostNameMatchConditionParameters_Operator_GreaterThan,
		HostNameMatchConditionParameters_Operator_GreaterThanOrEqual,
		HostNameMatchConditionParameters_Operator_LessThan,
		HostNameMatchConditionParameters_Operator_LessThanOrEqual,
		HostNameMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HostNameMatchConditionParameters_TypeName_DeliveryRuleHostNameConditionParameters))
}

func Test_HttpErrorRangeParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpErrorRangeParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpErrorRangeParameters_ARM, HttpErrorRangeParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpErrorRangeParameters_ARM runs a test to see if a specific instance of HttpErrorRangeParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpErrorRangeParameters_ARM(subject HttpErrorRangeParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpErrorRangeParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpErrorRangeParameters_ARM instances for property testing - lazily instantiated by
// HttpErrorRangeParameters_ARMGenerator()
var httpErrorRangeParameters_ARMGenerator gopter.Gen

// HttpErrorRangeParameters_ARMGenerator returns a generator of HttpErrorRangeParameters_ARM instances for property testing.
func HttpErrorRangeParameters_ARMGenerator() gopter.Gen {
	if httpErrorRangeParameters_ARMGenerator != nil {
		return httpErrorRangeParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpErrorRangeParameters_ARM(generators)
	httpErrorRangeParameters_ARMGenerator = gen.Struct(reflect.TypeOf(HttpErrorRangeParameters_ARM{}), generators)

	return httpErrorRangeParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHttpErrorRangeParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpErrorRangeParameters_ARM(gens map[string]gopter.Gen) {
	gens["Begin"] = gen.PtrOf(gen.Int())
	gens["End"] = gen.PtrOf(gen.Int())
}

func Test_HttpVersionMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of HttpVersionMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForHttpVersionMatchConditionParameters_ARM, HttpVersionMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForHttpVersionMatchConditionParameters_ARM runs a test to see if a specific instance of HttpVersionMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForHttpVersionMatchConditionParameters_ARM(subject HttpVersionMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual HttpVersionMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of HttpVersionMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// HttpVersionMatchConditionParameters_ARMGenerator()
var httpVersionMatchConditionParameters_ARMGenerator gopter.Gen

// HttpVersionMatchConditionParameters_ARMGenerator returns a generator of HttpVersionMatchConditionParameters_ARM instances for property testing.
func HttpVersionMatchConditionParameters_ARMGenerator() gopter.Gen {
	if httpVersionMatchConditionParameters_ARMGenerator != nil {
		return httpVersionMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParameters_ARM(generators)
	httpVersionMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(HttpVersionMatchConditionParameters_ARM{}), generators)

	return httpVersionMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForHttpVersionMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(HttpVersionMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(HttpVersionMatchConditionParameters_TypeName_DeliveryRuleHttpVersionConditionParameters))
}

func Test_IsDeviceMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of IsDeviceMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForIsDeviceMatchConditionParameters_ARM, IsDeviceMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForIsDeviceMatchConditionParameters_ARM runs a test to see if a specific instance of IsDeviceMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForIsDeviceMatchConditionParameters_ARM(subject IsDeviceMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual IsDeviceMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of IsDeviceMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// IsDeviceMatchConditionParameters_ARMGenerator()
var isDeviceMatchConditionParameters_ARMGenerator gopter.Gen

// IsDeviceMatchConditionParameters_ARMGenerator returns a generator of IsDeviceMatchConditionParameters_ARM instances for property testing.
func IsDeviceMatchConditionParameters_ARMGenerator() gopter.Gen {
	if isDeviceMatchConditionParameters_ARMGenerator != nil {
		return isDeviceMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParameters_ARM(generators)
	isDeviceMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(IsDeviceMatchConditionParameters_ARM{}), generators)

	return isDeviceMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForIsDeviceMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(IsDeviceMatchConditionParameters_MatchValues_Desktop, IsDeviceMatchConditionParameters_MatchValues_Mobile))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(IsDeviceMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(IsDeviceMatchConditionParameters_TypeName_DeliveryRuleIsDeviceConditionParameters))
}

func Test_KeyVaultSigningKeyParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KeyVaultSigningKeyParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKeyVaultSigningKeyParameters_ARM, KeyVaultSigningKeyParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKeyVaultSigningKeyParameters_ARM runs a test to see if a specific instance of KeyVaultSigningKeyParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForKeyVaultSigningKeyParameters_ARM(subject KeyVaultSigningKeyParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KeyVaultSigningKeyParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KeyVaultSigningKeyParameters_ARM instances for property testing - lazily instantiated by
// KeyVaultSigningKeyParameters_ARMGenerator()
var keyVaultSigningKeyParameters_ARMGenerator gopter.Gen

// KeyVaultSigningKeyParameters_ARMGenerator returns a generator of KeyVaultSigningKeyParameters_ARM instances for property testing.
func KeyVaultSigningKeyParameters_ARMGenerator() gopter.Gen {
	if keyVaultSigningKeyParameters_ARMGenerator != nil {
		return keyVaultSigningKeyParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters_ARM(generators)
	keyVaultSigningKeyParameters_ARMGenerator = gen.Struct(reflect.TypeOf(KeyVaultSigningKeyParameters_ARM{}), generators)

	return keyVaultSigningKeyParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKeyVaultSigningKeyParameters_ARM(gens map[string]gopter.Gen) {
	gens["ResourceGroupName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretName"] = gen.PtrOf(gen.AlphaString())
	gens["SecretVersion"] = gen.PtrOf(gen.AlphaString())
	gens["SubscriptionId"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(KeyVaultSigningKeyParameters_TypeName_KeyVaultSigningKeyParameters))
	gens["VaultName"] = gen.PtrOf(gen.AlphaString())
}

func Test_OriginGroupOverrideActionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverrideActionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverrideActionParameters_ARM, OriginGroupOverrideActionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverrideActionParameters_ARM runs a test to see if a specific instance of OriginGroupOverrideActionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverrideActionParameters_ARM(subject OriginGroupOverrideActionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverrideActionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverrideActionParameters_ARM instances for property testing - lazily instantiated by
// OriginGroupOverrideActionParameters_ARMGenerator()
var originGroupOverrideActionParameters_ARMGenerator gopter.Gen

// OriginGroupOverrideActionParameters_ARMGenerator returns a generator of OriginGroupOverrideActionParameters_ARM instances for property testing.
// We first initialize originGroupOverrideActionParameters_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideActionParameters_ARMGenerator() gopter.Gen {
	if originGroupOverrideActionParameters_ARMGenerator != nil {
		return originGroupOverrideActionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters_ARM(generators)
	originGroupOverrideActionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionParameters_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters_ARM(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParameters_ARM(generators)
	originGroupOverrideActionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideActionParameters_ARM{}), generators)

	return originGroupOverrideActionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverrideActionParameters_ARM(gens map[string]gopter.Gen) {
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(OriginGroupOverrideActionParameters_TypeName_DeliveryRuleOriginGroupOverrideActionParameters))
}

// AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParameters_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverrideActionParameters_ARM(gens map[string]gopter.Gen) {
	gens["OriginGroup"] = gen.PtrOf(ResourceReference_ARMGenerator())
}

func Test_OriginGroupOverrideAction_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverrideAction_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverrideAction_ARM, OriginGroupOverrideAction_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverrideAction_ARM runs a test to see if a specific instance of OriginGroupOverrideAction_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverrideAction_ARM(subject OriginGroupOverrideAction_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverrideAction_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverrideAction_ARM instances for property testing - lazily instantiated by
// OriginGroupOverrideAction_ARMGenerator()
var originGroupOverrideAction_ARMGenerator gopter.Gen

// OriginGroupOverrideAction_ARMGenerator returns a generator of OriginGroupOverrideAction_ARM instances for property testing.
// We first initialize originGroupOverrideAction_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverrideAction_ARMGenerator() gopter.Gen {
	if originGroupOverrideAction_ARMGenerator != nil {
		return originGroupOverrideAction_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideAction_ARM(generators)
	originGroupOverrideAction_ARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideAction_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverrideAction_ARM(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverrideAction_ARM(generators)
	originGroupOverrideAction_ARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverrideAction_ARM{}), generators)

	return originGroupOverrideAction_ARMGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverrideAction_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverrideAction_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(OriginGroupOverrideAction_Name_OriginGroupOverride)
}

// AddRelatedPropertyGeneratorsForOriginGroupOverrideAction_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverrideAction_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(OriginGroupOverrideActionParameters_ARMGenerator())
}

func Test_OriginGroupOverride_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of OriginGroupOverride_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForOriginGroupOverride_ARM, OriginGroupOverride_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForOriginGroupOverride_ARM runs a test to see if a specific instance of OriginGroupOverride_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForOriginGroupOverride_ARM(subject OriginGroupOverride_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual OriginGroupOverride_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of OriginGroupOverride_ARM instances for property testing - lazily instantiated by
// OriginGroupOverride_ARMGenerator()
var originGroupOverride_ARMGenerator gopter.Gen

// OriginGroupOverride_ARMGenerator returns a generator of OriginGroupOverride_ARM instances for property testing.
// We first initialize originGroupOverride_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func OriginGroupOverride_ARMGenerator() gopter.Gen {
	if originGroupOverride_ARMGenerator != nil {
		return originGroupOverride_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverride_ARM(generators)
	originGroupOverride_ARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverride_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForOriginGroupOverride_ARM(generators)
	AddRelatedPropertyGeneratorsForOriginGroupOverride_ARM(generators)
	originGroupOverride_ARMGenerator = gen.Struct(reflect.TypeOf(OriginGroupOverride_ARM{}), generators)

	return originGroupOverride_ARMGenerator
}

// AddIndependentPropertyGeneratorsForOriginGroupOverride_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForOriginGroupOverride_ARM(gens map[string]gopter.Gen) {
	gens["ForwardingProtocol"] = gen.PtrOf(gen.OneConstOf(OriginGroupOverride_ForwardingProtocol_HttpOnly, OriginGroupOverride_ForwardingProtocol_HttpsOnly, OriginGroupOverride_ForwardingProtocol_MatchRequest))
}

// AddRelatedPropertyGeneratorsForOriginGroupOverride_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForOriginGroupOverride_ARM(gens map[string]gopter.Gen) {
	gens["OriginGroup"] = gen.PtrOf(ResourceReference_ARMGenerator())
}

func Test_PostArgsMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PostArgsMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPostArgsMatchConditionParameters_ARM, PostArgsMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPostArgsMatchConditionParameters_ARM runs a test to see if a specific instance of PostArgsMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPostArgsMatchConditionParameters_ARM(subject PostArgsMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PostArgsMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PostArgsMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// PostArgsMatchConditionParameters_ARMGenerator()
var postArgsMatchConditionParameters_ARMGenerator gopter.Gen

// PostArgsMatchConditionParameters_ARMGenerator returns a generator of PostArgsMatchConditionParameters_ARM instances for property testing.
func PostArgsMatchConditionParameters_ARMGenerator() gopter.Gen {
	if postArgsMatchConditionParameters_ARMGenerator != nil {
		return postArgsMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPostArgsMatchConditionParameters_ARM(generators)
	postArgsMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(PostArgsMatchConditionParameters_ARM{}), generators)

	return postArgsMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForPostArgsMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPostArgsMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		PostArgsMatchConditionParameters_Operator_Any,
		PostArgsMatchConditionParameters_Operator_BeginsWith,
		PostArgsMatchConditionParameters_Operator_Contains,
		PostArgsMatchConditionParameters_Operator_EndsWith,
		PostArgsMatchConditionParameters_Operator_Equal,
		PostArgsMatchConditionParameters_Operator_GreaterThan,
		PostArgsMatchConditionParameters_Operator_GreaterThanOrEqual,
		PostArgsMatchConditionParameters_Operator_LessThan,
		PostArgsMatchConditionParameters_Operator_LessThanOrEqual,
		PostArgsMatchConditionParameters_Operator_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(PostArgsMatchConditionParameters_TypeName_DeliveryRulePostArgsConditionParameters))
}

func Test_Profiles_Endpoint_Spec_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Profiles_Endpoint_Spec_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForProfiles_Endpoint_Spec_ARM, Profiles_Endpoint_Spec_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForProfiles_Endpoint_Spec_ARM runs a test to see if a specific instance of Profiles_Endpoint_Spec_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForProfiles_Endpoint_Spec_ARM(subject Profiles_Endpoint_Spec_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Profiles_Endpoint_Spec_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Profiles_Endpoint_Spec_ARM instances for property testing - lazily instantiated by
// Profiles_Endpoint_Spec_ARMGenerator()
var profiles_Endpoint_Spec_ARMGenerator gopter.Gen

// Profiles_Endpoint_Spec_ARMGenerator returns a generator of Profiles_Endpoint_Spec_ARM instances for property testing.
// We first initialize profiles_Endpoint_Spec_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func Profiles_Endpoint_Spec_ARMGenerator() gopter.Gen {
	if profiles_Endpoint_Spec_ARMGenerator != nil {
		return profiles_Endpoint_Spec_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_ARM(generators)
	profiles_Endpoint_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Profiles_Endpoint_Spec_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_ARM(generators)
	AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec_ARM(generators)
	profiles_Endpoint_Spec_ARMGenerator = gen.Struct(reflect.TypeOf(Profiles_Endpoint_Spec_ARM{}), generators)

	return profiles_Endpoint_Spec_ARMGenerator
}

// AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForProfiles_Endpoint_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(
		gen.AlphaString(),
		gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForProfiles_Endpoint_Spec_ARM(gens map[string]gopter.Gen) {
	gens["Properties"] = gen.PtrOf(EndpointProperties_ARMGenerator())
}

func Test_QueryStringMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of QueryStringMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForQueryStringMatchConditionParameters_ARM, QueryStringMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForQueryStringMatchConditionParameters_ARM runs a test to see if a specific instance of QueryStringMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForQueryStringMatchConditionParameters_ARM(subject QueryStringMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual QueryStringMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of QueryStringMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// QueryStringMatchConditionParameters_ARMGenerator()
var queryStringMatchConditionParameters_ARMGenerator gopter.Gen

// QueryStringMatchConditionParameters_ARMGenerator returns a generator of QueryStringMatchConditionParameters_ARM instances for property testing.
func QueryStringMatchConditionParameters_ARMGenerator() gopter.Gen {
	if queryStringMatchConditionParameters_ARMGenerator != nil {
		return queryStringMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForQueryStringMatchConditionParameters_ARM(generators)
	queryStringMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(QueryStringMatchConditionParameters_ARM{}), generators)

	return queryStringMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForQueryStringMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForQueryStringMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		QueryStringMatchConditionParameters_Operator_Any,
		QueryStringMatchConditionParameters_Operator_BeginsWith,
		QueryStringMatchConditionParameters_Operator_Contains,
		QueryStringMatchConditionParameters_Operator_EndsWith,
		QueryStringMatchConditionParameters_Operator_Equal,
		QueryStringMatchConditionParameters_Operator_GreaterThan,
		QueryStringMatchConditionParameters_Operator_GreaterThanOrEqual,
		QueryStringMatchConditionParameters_Operator_LessThan,
		QueryStringMatchConditionParameters_Operator_LessThanOrEqual,
		QueryStringMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(QueryStringMatchConditionParameters_TypeName_DeliveryRuleQueryStringConditionParameters))
}

func Test_RemoteAddressMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RemoteAddressMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRemoteAddressMatchConditionParameters_ARM, RemoteAddressMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRemoteAddressMatchConditionParameters_ARM runs a test to see if a specific instance of RemoteAddressMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRemoteAddressMatchConditionParameters_ARM(subject RemoteAddressMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RemoteAddressMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RemoteAddressMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// RemoteAddressMatchConditionParameters_ARMGenerator()
var remoteAddressMatchConditionParameters_ARMGenerator gopter.Gen

// RemoteAddressMatchConditionParameters_ARMGenerator returns a generator of RemoteAddressMatchConditionParameters_ARM instances for property testing.
func RemoteAddressMatchConditionParameters_ARMGenerator() gopter.Gen {
	if remoteAddressMatchConditionParameters_ARMGenerator != nil {
		return remoteAddressMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParameters_ARM(generators)
	remoteAddressMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(RemoteAddressMatchConditionParameters_ARM{}), generators)

	return remoteAddressMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRemoteAddressMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RemoteAddressMatchConditionParameters_Operator_Any, RemoteAddressMatchConditionParameters_Operator_GeoMatch, RemoteAddressMatchConditionParameters_Operator_IPMatch))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RemoteAddressMatchConditionParameters_TypeName_DeliveryRuleRemoteAddressConditionParameters))
}

func Test_RequestBodyMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestBodyMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestBodyMatchConditionParameters_ARM, RequestBodyMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestBodyMatchConditionParameters_ARM runs a test to see if a specific instance of RequestBodyMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestBodyMatchConditionParameters_ARM(subject RequestBodyMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestBodyMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestBodyMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// RequestBodyMatchConditionParameters_ARMGenerator()
var requestBodyMatchConditionParameters_ARMGenerator gopter.Gen

// RequestBodyMatchConditionParameters_ARMGenerator returns a generator of RequestBodyMatchConditionParameters_ARM instances for property testing.
func RequestBodyMatchConditionParameters_ARMGenerator() gopter.Gen {
	if requestBodyMatchConditionParameters_ARMGenerator != nil {
		return requestBodyMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParameters_ARM(generators)
	requestBodyMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(RequestBodyMatchConditionParameters_ARM{}), generators)

	return requestBodyMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestBodyMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestBodyMatchConditionParameters_Operator_Any,
		RequestBodyMatchConditionParameters_Operator_BeginsWith,
		RequestBodyMatchConditionParameters_Operator_Contains,
		RequestBodyMatchConditionParameters_Operator_EndsWith,
		RequestBodyMatchConditionParameters_Operator_Equal,
		RequestBodyMatchConditionParameters_Operator_GreaterThan,
		RequestBodyMatchConditionParameters_Operator_GreaterThanOrEqual,
		RequestBodyMatchConditionParameters_Operator_LessThan,
		RequestBodyMatchConditionParameters_Operator_LessThanOrEqual,
		RequestBodyMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestBodyMatchConditionParameters_TypeName_DeliveryRuleRequestBodyConditionParameters))
}

func Test_RequestHeaderMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestHeaderMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestHeaderMatchConditionParameters_ARM, RequestHeaderMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestHeaderMatchConditionParameters_ARM runs a test to see if a specific instance of RequestHeaderMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestHeaderMatchConditionParameters_ARM(subject RequestHeaderMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestHeaderMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestHeaderMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// RequestHeaderMatchConditionParameters_ARMGenerator()
var requestHeaderMatchConditionParameters_ARMGenerator gopter.Gen

// RequestHeaderMatchConditionParameters_ARMGenerator returns a generator of RequestHeaderMatchConditionParameters_ARM instances for property testing.
func RequestHeaderMatchConditionParameters_ARMGenerator() gopter.Gen {
	if requestHeaderMatchConditionParameters_ARMGenerator != nil {
		return requestHeaderMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParameters_ARM(generators)
	requestHeaderMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(RequestHeaderMatchConditionParameters_ARM{}), generators)

	return requestHeaderMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestHeaderMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestHeaderMatchConditionParameters_Operator_Any,
		RequestHeaderMatchConditionParameters_Operator_BeginsWith,
		RequestHeaderMatchConditionParameters_Operator_Contains,
		RequestHeaderMatchConditionParameters_Operator_EndsWith,
		RequestHeaderMatchConditionParameters_Operator_Equal,
		RequestHeaderMatchConditionParameters_Operator_GreaterThan,
		RequestHeaderMatchConditionParameters_Operator_GreaterThanOrEqual,
		RequestHeaderMatchConditionParameters_Operator_LessThan,
		RequestHeaderMatchConditionParameters_Operator_LessThanOrEqual,
		RequestHeaderMatchConditionParameters_Operator_RegEx))
	gens["Selector"] = gen.PtrOf(gen.AlphaString())
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestHeaderMatchConditionParameters_TypeName_DeliveryRuleRequestHeaderConditionParameters))
}

func Test_RequestMethodMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestMethodMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestMethodMatchConditionParameters_ARM, RequestMethodMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestMethodMatchConditionParameters_ARM runs a test to see if a specific instance of RequestMethodMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestMethodMatchConditionParameters_ARM(subject RequestMethodMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestMethodMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestMethodMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// RequestMethodMatchConditionParameters_ARMGenerator()
var requestMethodMatchConditionParameters_ARMGenerator gopter.Gen

// RequestMethodMatchConditionParameters_ARMGenerator returns a generator of RequestMethodMatchConditionParameters_ARM instances for property testing.
func RequestMethodMatchConditionParameters_ARMGenerator() gopter.Gen {
	if requestMethodMatchConditionParameters_ARMGenerator != nil {
		return requestMethodMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParameters_ARM(generators)
	requestMethodMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(RequestMethodMatchConditionParameters_ARM{}), generators)

	return requestMethodMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestMethodMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(
		RequestMethodMatchConditionParameters_MatchValues_DELETE,
		RequestMethodMatchConditionParameters_MatchValues_GET,
		RequestMethodMatchConditionParameters_MatchValues_HEAD,
		RequestMethodMatchConditionParameters_MatchValues_OPTIONS,
		RequestMethodMatchConditionParameters_MatchValues_POST,
		RequestMethodMatchConditionParameters_MatchValues_PUT,
		RequestMethodMatchConditionParameters_MatchValues_TRACE))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RequestMethodMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestMethodMatchConditionParameters_TypeName_DeliveryRuleRequestMethodConditionParameters))
}

func Test_RequestSchemeMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestSchemeMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestSchemeMatchConditionParameters_ARM, RequestSchemeMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestSchemeMatchConditionParameters_ARM runs a test to see if a specific instance of RequestSchemeMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestSchemeMatchConditionParameters_ARM(subject RequestSchemeMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestSchemeMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestSchemeMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// RequestSchemeMatchConditionParameters_ARMGenerator()
var requestSchemeMatchConditionParameters_ARMGenerator gopter.Gen

// RequestSchemeMatchConditionParameters_ARMGenerator returns a generator of RequestSchemeMatchConditionParameters_ARM instances for property testing.
func RequestSchemeMatchConditionParameters_ARMGenerator() gopter.Gen {
	if requestSchemeMatchConditionParameters_ARMGenerator != nil {
		return requestSchemeMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParameters_ARM(generators)
	requestSchemeMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(RequestSchemeMatchConditionParameters_ARM{}), generators)

	return requestSchemeMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestSchemeMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(RequestSchemeMatchConditionParameters_MatchValues_HTTP, RequestSchemeMatchConditionParameters_MatchValues_HTTPS))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(RequestSchemeMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestSchemeMatchConditionParameters_TypeName_DeliveryRuleRequestSchemeConditionParameters))
}

func Test_RequestUriMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RequestUriMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRequestUriMatchConditionParameters_ARM, RequestUriMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRequestUriMatchConditionParameters_ARM runs a test to see if a specific instance of RequestUriMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRequestUriMatchConditionParameters_ARM(subject RequestUriMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RequestUriMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RequestUriMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// RequestUriMatchConditionParameters_ARMGenerator()
var requestUriMatchConditionParameters_ARMGenerator gopter.Gen

// RequestUriMatchConditionParameters_ARMGenerator returns a generator of RequestUriMatchConditionParameters_ARM instances for property testing.
func RequestUriMatchConditionParameters_ARMGenerator() gopter.Gen {
	if requestUriMatchConditionParameters_ARMGenerator != nil {
		return requestUriMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRequestUriMatchConditionParameters_ARM(generators)
	requestUriMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(RequestUriMatchConditionParameters_ARM{}), generators)

	return requestUriMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRequestUriMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRequestUriMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		RequestUriMatchConditionParameters_Operator_Any,
		RequestUriMatchConditionParameters_Operator_BeginsWith,
		RequestUriMatchConditionParameters_Operator_Contains,
		RequestUriMatchConditionParameters_Operator_EndsWith,
		RequestUriMatchConditionParameters_Operator_Equal,
		RequestUriMatchConditionParameters_Operator_GreaterThan,
		RequestUriMatchConditionParameters_Operator_GreaterThanOrEqual,
		RequestUriMatchConditionParameters_Operator_LessThan,
		RequestUriMatchConditionParameters_Operator_LessThanOrEqual,
		RequestUriMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RequestUriMatchConditionParameters_TypeName_DeliveryRuleRequestUriConditionParameters))
}

func Test_ResourceReference_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceReference_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceReference_ARM, ResourceReference_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceReference_ARM runs a test to see if a specific instance of ResourceReference_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceReference_ARM(subject ResourceReference_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceReference_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceReference_ARM instances for property testing - lazily instantiated by
// ResourceReference_ARMGenerator()
var resourceReference_ARMGenerator gopter.Gen

// ResourceReference_ARMGenerator returns a generator of ResourceReference_ARM instances for property testing.
func ResourceReference_ARMGenerator() gopter.Gen {
	if resourceReference_ARMGenerator != nil {
		return resourceReference_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceReference_ARM(generators)
	resourceReference_ARMGenerator = gen.Struct(reflect.TypeOf(ResourceReference_ARM{}), generators)

	return resourceReference_ARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceReference_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceReference_ARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_ResponseBasedOriginErrorDetectionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResponseBasedOriginErrorDetectionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters_ARM, ResponseBasedOriginErrorDetectionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters_ARM runs a test to see if a specific instance of ResponseBasedOriginErrorDetectionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResponseBasedOriginErrorDetectionParameters_ARM(subject ResponseBasedOriginErrorDetectionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResponseBasedOriginErrorDetectionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResponseBasedOriginErrorDetectionParameters_ARM instances for property testing - lazily instantiated by
// ResponseBasedOriginErrorDetectionParameters_ARMGenerator()
var responseBasedOriginErrorDetectionParameters_ARMGenerator gopter.Gen

// ResponseBasedOriginErrorDetectionParameters_ARMGenerator returns a generator of ResponseBasedOriginErrorDetectionParameters_ARM instances for property testing.
// We first initialize responseBasedOriginErrorDetectionParameters_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ResponseBasedOriginErrorDetectionParameters_ARMGenerator() gopter.Gen {
	if responseBasedOriginErrorDetectionParameters_ARMGenerator != nil {
		return responseBasedOriginErrorDetectionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_ARM(generators)
	responseBasedOriginErrorDetectionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParameters_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_ARM(generators)
	AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_ARM(generators)
	responseBasedOriginErrorDetectionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(ResponseBasedOriginErrorDetectionParameters_ARM{}), generators)

	return responseBasedOriginErrorDetectionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_ARM(gens map[string]gopter.Gen) {
	gens["ResponseBasedDetectedErrorTypes"] = gen.PtrOf(gen.OneConstOf(ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_None, ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_TcpAndHttpErrors, ResponseBasedOriginErrorDetectionParameters_ResponseBasedDetectedErrorTypes_TcpErrorsOnly))
	gens["ResponseBasedFailoverThresholdPercentage"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForResponseBasedOriginErrorDetectionParameters_ARM(gens map[string]gopter.Gen) {
	gens["HttpErrorRanges"] = gen.SliceOf(HttpErrorRangeParameters_ARMGenerator())
}

func Test_RouteConfigurationOverrideActionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of RouteConfigurationOverrideActionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForRouteConfigurationOverrideActionParameters_ARM, RouteConfigurationOverrideActionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForRouteConfigurationOverrideActionParameters_ARM runs a test to see if a specific instance of RouteConfigurationOverrideActionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForRouteConfigurationOverrideActionParameters_ARM(subject RouteConfigurationOverrideActionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual RouteConfigurationOverrideActionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of RouteConfigurationOverrideActionParameters_ARM instances for property testing - lazily instantiated by
// RouteConfigurationOverrideActionParameters_ARMGenerator()
var routeConfigurationOverrideActionParameters_ARMGenerator gopter.Gen

// RouteConfigurationOverrideActionParameters_ARMGenerator returns a generator of RouteConfigurationOverrideActionParameters_ARM instances for property testing.
// We first initialize routeConfigurationOverrideActionParameters_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func RouteConfigurationOverrideActionParameters_ARMGenerator() gopter.Gen {
	if routeConfigurationOverrideActionParameters_ARMGenerator != nil {
		return routeConfigurationOverrideActionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters_ARM(generators)
	routeConfigurationOverrideActionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(RouteConfigurationOverrideActionParameters_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters_ARM(generators)
	AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParameters_ARM(generators)
	routeConfigurationOverrideActionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(RouteConfigurationOverrideActionParameters_ARM{}), generators)

	return routeConfigurationOverrideActionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForRouteConfigurationOverrideActionParameters_ARM(gens map[string]gopter.Gen) {
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(RouteConfigurationOverrideActionParameters_TypeName_DeliveryRuleRouteConfigurationOverrideActionParameters))
}

// AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParameters_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForRouteConfigurationOverrideActionParameters_ARM(gens map[string]gopter.Gen) {
	gens["CacheConfiguration"] = gen.PtrOf(CacheConfiguration_ARMGenerator())
	gens["OriginGroupOverride"] = gen.PtrOf(OriginGroupOverride_ARMGenerator())
}

func Test_ServerPortMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ServerPortMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForServerPortMatchConditionParameters_ARM, ServerPortMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForServerPortMatchConditionParameters_ARM runs a test to see if a specific instance of ServerPortMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForServerPortMatchConditionParameters_ARM(subject ServerPortMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ServerPortMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ServerPortMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// ServerPortMatchConditionParameters_ARMGenerator()
var serverPortMatchConditionParameters_ARMGenerator gopter.Gen

// ServerPortMatchConditionParameters_ARMGenerator returns a generator of ServerPortMatchConditionParameters_ARM instances for property testing.
func ServerPortMatchConditionParameters_ARMGenerator() gopter.Gen {
	if serverPortMatchConditionParameters_ARMGenerator != nil {
		return serverPortMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForServerPortMatchConditionParameters_ARM(generators)
	serverPortMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(ServerPortMatchConditionParameters_ARM{}), generators)

	return serverPortMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForServerPortMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForServerPortMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		ServerPortMatchConditionParameters_Operator_Any,
		ServerPortMatchConditionParameters_Operator_BeginsWith,
		ServerPortMatchConditionParameters_Operator_Contains,
		ServerPortMatchConditionParameters_Operator_EndsWith,
		ServerPortMatchConditionParameters_Operator_Equal,
		ServerPortMatchConditionParameters_Operator_GreaterThan,
		ServerPortMatchConditionParameters_Operator_GreaterThanOrEqual,
		ServerPortMatchConditionParameters_Operator_LessThan,
		ServerPortMatchConditionParameters_Operator_LessThanOrEqual,
		ServerPortMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(ServerPortMatchConditionParameters_TypeName_DeliveryRuleServerPortConditionParameters))
}

func Test_SocketAddrMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SocketAddrMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSocketAddrMatchConditionParameters_ARM, SocketAddrMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSocketAddrMatchConditionParameters_ARM runs a test to see if a specific instance of SocketAddrMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSocketAddrMatchConditionParameters_ARM(subject SocketAddrMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SocketAddrMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SocketAddrMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// SocketAddrMatchConditionParameters_ARMGenerator()
var socketAddrMatchConditionParameters_ARMGenerator gopter.Gen

// SocketAddrMatchConditionParameters_ARMGenerator returns a generator of SocketAddrMatchConditionParameters_ARM instances for property testing.
func SocketAddrMatchConditionParameters_ARMGenerator() gopter.Gen {
	if socketAddrMatchConditionParameters_ARMGenerator != nil {
		return socketAddrMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParameters_ARM(generators)
	socketAddrMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(SocketAddrMatchConditionParameters_ARM{}), generators)

	return socketAddrMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSocketAddrMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(SocketAddrMatchConditionParameters_Operator_Any, SocketAddrMatchConditionParameters_Operator_IPMatch))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(SocketAddrMatchConditionParameters_TypeName_DeliveryRuleSocketAddrConditionParameters))
}

func Test_SslProtocolMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SslProtocolMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSslProtocolMatchConditionParameters_ARM, SslProtocolMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSslProtocolMatchConditionParameters_ARM runs a test to see if a specific instance of SslProtocolMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForSslProtocolMatchConditionParameters_ARM(subject SslProtocolMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SslProtocolMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SslProtocolMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// SslProtocolMatchConditionParameters_ARMGenerator()
var sslProtocolMatchConditionParameters_ARMGenerator gopter.Gen

// SslProtocolMatchConditionParameters_ARMGenerator returns a generator of SslProtocolMatchConditionParameters_ARM instances for property testing.
func SslProtocolMatchConditionParameters_ARMGenerator() gopter.Gen {
	if sslProtocolMatchConditionParameters_ARMGenerator != nil {
		return sslProtocolMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParameters_ARM(generators)
	sslProtocolMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(SslProtocolMatchConditionParameters_ARM{}), generators)

	return sslProtocolMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSslProtocolMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.OneConstOf(SslProtocol_TLSv1, SslProtocol_TLSv11, SslProtocol_TLSv12))
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(SslProtocolMatchConditionParameters_Operator_Equal))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(SslProtocolMatchConditionParameters_TypeName_DeliveryRuleSslProtocolConditionParameters))
}

func Test_UrlFileExtensionMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlFileExtensionMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlFileExtensionMatchConditionParameters_ARM, UrlFileExtensionMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlFileExtensionMatchConditionParameters_ARM runs a test to see if a specific instance of UrlFileExtensionMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlFileExtensionMatchConditionParameters_ARM(subject UrlFileExtensionMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlFileExtensionMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlFileExtensionMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// UrlFileExtensionMatchConditionParameters_ARMGenerator()
var urlFileExtensionMatchConditionParameters_ARMGenerator gopter.Gen

// UrlFileExtensionMatchConditionParameters_ARMGenerator returns a generator of UrlFileExtensionMatchConditionParameters_ARM instances for property testing.
func UrlFileExtensionMatchConditionParameters_ARMGenerator() gopter.Gen {
	if urlFileExtensionMatchConditionParameters_ARMGenerator != nil {
		return urlFileExtensionMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParameters_ARM(generators)
	urlFileExtensionMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(UrlFileExtensionMatchConditionParameters_ARM{}), generators)

	return urlFileExtensionMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlFileExtensionMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlFileExtensionMatchConditionParameters_Operator_Any,
		UrlFileExtensionMatchConditionParameters_Operator_BeginsWith,
		UrlFileExtensionMatchConditionParameters_Operator_Contains,
		UrlFileExtensionMatchConditionParameters_Operator_EndsWith,
		UrlFileExtensionMatchConditionParameters_Operator_Equal,
		UrlFileExtensionMatchConditionParameters_Operator_GreaterThan,
		UrlFileExtensionMatchConditionParameters_Operator_GreaterThanOrEqual,
		UrlFileExtensionMatchConditionParameters_Operator_LessThan,
		UrlFileExtensionMatchConditionParameters_Operator_LessThanOrEqual,
		UrlFileExtensionMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlFileExtensionMatchConditionParameters_TypeName_DeliveryRuleUrlFileExtensionMatchConditionParameters))
}

func Test_UrlFileNameMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlFileNameMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlFileNameMatchConditionParameters_ARM, UrlFileNameMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlFileNameMatchConditionParameters_ARM runs a test to see if a specific instance of UrlFileNameMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlFileNameMatchConditionParameters_ARM(subject UrlFileNameMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlFileNameMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlFileNameMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// UrlFileNameMatchConditionParameters_ARMGenerator()
var urlFileNameMatchConditionParameters_ARMGenerator gopter.Gen

// UrlFileNameMatchConditionParameters_ARMGenerator returns a generator of UrlFileNameMatchConditionParameters_ARM instances for property testing.
func UrlFileNameMatchConditionParameters_ARMGenerator() gopter.Gen {
	if urlFileNameMatchConditionParameters_ARMGenerator != nil {
		return urlFileNameMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParameters_ARM(generators)
	urlFileNameMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(UrlFileNameMatchConditionParameters_ARM{}), generators)

	return urlFileNameMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlFileNameMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlFileNameMatchConditionParameters_Operator_Any,
		UrlFileNameMatchConditionParameters_Operator_BeginsWith,
		UrlFileNameMatchConditionParameters_Operator_Contains,
		UrlFileNameMatchConditionParameters_Operator_EndsWith,
		UrlFileNameMatchConditionParameters_Operator_Equal,
		UrlFileNameMatchConditionParameters_Operator_GreaterThan,
		UrlFileNameMatchConditionParameters_Operator_GreaterThanOrEqual,
		UrlFileNameMatchConditionParameters_Operator_LessThan,
		UrlFileNameMatchConditionParameters_Operator_LessThanOrEqual,
		UrlFileNameMatchConditionParameters_Operator_RegEx))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlFileNameMatchConditionParameters_TypeName_DeliveryRuleUrlFilenameConditionParameters))
}

func Test_UrlPathMatchConditionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlPathMatchConditionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlPathMatchConditionParameters_ARM, UrlPathMatchConditionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlPathMatchConditionParameters_ARM runs a test to see if a specific instance of UrlPathMatchConditionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlPathMatchConditionParameters_ARM(subject UrlPathMatchConditionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlPathMatchConditionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlPathMatchConditionParameters_ARM instances for property testing - lazily instantiated by
// UrlPathMatchConditionParameters_ARMGenerator()
var urlPathMatchConditionParameters_ARMGenerator gopter.Gen

// UrlPathMatchConditionParameters_ARMGenerator returns a generator of UrlPathMatchConditionParameters_ARM instances for property testing.
func UrlPathMatchConditionParameters_ARMGenerator() gopter.Gen {
	if urlPathMatchConditionParameters_ARMGenerator != nil {
		return urlPathMatchConditionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlPathMatchConditionParameters_ARM(generators)
	urlPathMatchConditionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(UrlPathMatchConditionParameters_ARM{}), generators)

	return urlPathMatchConditionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlPathMatchConditionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlPathMatchConditionParameters_ARM(gens map[string]gopter.Gen) {
	gens["MatchValues"] = gen.SliceOf(gen.AlphaString())
	gens["NegateCondition"] = gen.PtrOf(gen.Bool())
	gens["Operator"] = gen.PtrOf(gen.OneConstOf(
		UrlPathMatchConditionParameters_Operator_Any,
		UrlPathMatchConditionParameters_Operator_BeginsWith,
		UrlPathMatchConditionParameters_Operator_Contains,
		UrlPathMatchConditionParameters_Operator_EndsWith,
		UrlPathMatchConditionParameters_Operator_Equal,
		UrlPathMatchConditionParameters_Operator_GreaterThan,
		UrlPathMatchConditionParameters_Operator_GreaterThanOrEqual,
		UrlPathMatchConditionParameters_Operator_LessThan,
		UrlPathMatchConditionParameters_Operator_LessThanOrEqual,
		UrlPathMatchConditionParameters_Operator_RegEx,
		UrlPathMatchConditionParameters_Operator_Wildcard))
	gens["Transforms"] = gen.SliceOf(gen.OneConstOf(
		Transform_Lowercase,
		Transform_RemoveNulls,
		Transform_Trim,
		Transform_Uppercase,
		Transform_UrlDecode,
		Transform_UrlEncode))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlPathMatchConditionParameters_TypeName_DeliveryRuleUrlPathMatchConditionParameters))
}

func Test_UrlRedirectActionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRedirectActionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRedirectActionParameters_ARM, UrlRedirectActionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRedirectActionParameters_ARM runs a test to see if a specific instance of UrlRedirectActionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRedirectActionParameters_ARM(subject UrlRedirectActionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRedirectActionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRedirectActionParameters_ARM instances for property testing - lazily instantiated by
// UrlRedirectActionParameters_ARMGenerator()
var urlRedirectActionParameters_ARMGenerator gopter.Gen

// UrlRedirectActionParameters_ARMGenerator returns a generator of UrlRedirectActionParameters_ARM instances for property testing.
func UrlRedirectActionParameters_ARMGenerator() gopter.Gen {
	if urlRedirectActionParameters_ARMGenerator != nil {
		return urlRedirectActionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectActionParameters_ARM(generators)
	urlRedirectActionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(UrlRedirectActionParameters_ARM{}), generators)

	return urlRedirectActionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlRedirectActionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRedirectActionParameters_ARM(gens map[string]gopter.Gen) {
	gens["CustomFragment"] = gen.PtrOf(gen.AlphaString())
	gens["CustomHostname"] = gen.PtrOf(gen.AlphaString())
	gens["CustomPath"] = gen.PtrOf(gen.AlphaString())
	gens["CustomQueryString"] = gen.PtrOf(gen.AlphaString())
	gens["DestinationProtocol"] = gen.PtrOf(gen.OneConstOf(UrlRedirectActionParameters_DestinationProtocol_Http, UrlRedirectActionParameters_DestinationProtocol_Https, UrlRedirectActionParameters_DestinationProtocol_MatchRequest))
	gens["RedirectType"] = gen.PtrOf(gen.OneConstOf(
		UrlRedirectActionParameters_RedirectType_Found,
		UrlRedirectActionParameters_RedirectType_Moved,
		UrlRedirectActionParameters_RedirectType_PermanentRedirect,
		UrlRedirectActionParameters_RedirectType_TemporaryRedirect))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlRedirectActionParameters_TypeName_DeliveryRuleUrlRedirectActionParameters))
}

func Test_UrlRedirectAction_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRedirectAction_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRedirectAction_ARM, UrlRedirectAction_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRedirectAction_ARM runs a test to see if a specific instance of UrlRedirectAction_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRedirectAction_ARM(subject UrlRedirectAction_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRedirectAction_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRedirectAction_ARM instances for property testing - lazily instantiated by
// UrlRedirectAction_ARMGenerator()
var urlRedirectAction_ARMGenerator gopter.Gen

// UrlRedirectAction_ARMGenerator returns a generator of UrlRedirectAction_ARM instances for property testing.
// We first initialize urlRedirectAction_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlRedirectAction_ARMGenerator() gopter.Gen {
	if urlRedirectAction_ARMGenerator != nil {
		return urlRedirectAction_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectAction_ARM(generators)
	urlRedirectAction_ARMGenerator = gen.Struct(reflect.TypeOf(UrlRedirectAction_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRedirectAction_ARM(generators)
	AddRelatedPropertyGeneratorsForUrlRedirectAction_ARM(generators)
	urlRedirectAction_ARMGenerator = gen.Struct(reflect.TypeOf(UrlRedirectAction_ARM{}), generators)

	return urlRedirectAction_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlRedirectAction_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRedirectAction_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlRedirectAction_Name_UrlRedirect)
}

// AddRelatedPropertyGeneratorsForUrlRedirectAction_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlRedirectAction_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlRedirectActionParameters_ARMGenerator())
}

func Test_UrlRewriteActionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRewriteActionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRewriteActionParameters_ARM, UrlRewriteActionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRewriteActionParameters_ARM runs a test to see if a specific instance of UrlRewriteActionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRewriteActionParameters_ARM(subject UrlRewriteActionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRewriteActionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRewriteActionParameters_ARM instances for property testing - lazily instantiated by
// UrlRewriteActionParameters_ARMGenerator()
var urlRewriteActionParameters_ARMGenerator gopter.Gen

// UrlRewriteActionParameters_ARMGenerator returns a generator of UrlRewriteActionParameters_ARM instances for property testing.
func UrlRewriteActionParameters_ARMGenerator() gopter.Gen {
	if urlRewriteActionParameters_ARMGenerator != nil {
		return urlRewriteActionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteActionParameters_ARM(generators)
	urlRewriteActionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(UrlRewriteActionParameters_ARM{}), generators)

	return urlRewriteActionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlRewriteActionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRewriteActionParameters_ARM(gens map[string]gopter.Gen) {
	gens["Destination"] = gen.PtrOf(gen.AlphaString())
	gens["PreserveUnmatchedPath"] = gen.PtrOf(gen.Bool())
	gens["SourcePattern"] = gen.PtrOf(gen.AlphaString())
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlRewriteActionParameters_TypeName_DeliveryRuleUrlRewriteActionParameters))
}

func Test_UrlRewriteAction_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlRewriteAction_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlRewriteAction_ARM, UrlRewriteAction_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlRewriteAction_ARM runs a test to see if a specific instance of UrlRewriteAction_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlRewriteAction_ARM(subject UrlRewriteAction_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlRewriteAction_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlRewriteAction_ARM instances for property testing - lazily instantiated by
// UrlRewriteAction_ARMGenerator()
var urlRewriteAction_ARMGenerator gopter.Gen

// UrlRewriteAction_ARMGenerator returns a generator of UrlRewriteAction_ARM instances for property testing.
// We first initialize urlRewriteAction_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlRewriteAction_ARMGenerator() gopter.Gen {
	if urlRewriteAction_ARMGenerator != nil {
		return urlRewriteAction_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteAction_ARM(generators)
	urlRewriteAction_ARMGenerator = gen.Struct(reflect.TypeOf(UrlRewriteAction_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlRewriteAction_ARM(generators)
	AddRelatedPropertyGeneratorsForUrlRewriteAction_ARM(generators)
	urlRewriteAction_ARMGenerator = gen.Struct(reflect.TypeOf(UrlRewriteAction_ARM{}), generators)

	return urlRewriteAction_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlRewriteAction_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlRewriteAction_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlRewriteAction_Name_UrlRewrite)
}

// AddRelatedPropertyGeneratorsForUrlRewriteAction_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlRewriteAction_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlRewriteActionParameters_ARMGenerator())
}

func Test_UrlSigningActionParameters_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningActionParameters_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningActionParameters_ARM, UrlSigningActionParameters_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningActionParameters_ARM runs a test to see if a specific instance of UrlSigningActionParameters_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningActionParameters_ARM(subject UrlSigningActionParameters_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningActionParameters_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningActionParameters_ARM instances for property testing - lazily instantiated by
// UrlSigningActionParameters_ARMGenerator()
var urlSigningActionParameters_ARMGenerator gopter.Gen

// UrlSigningActionParameters_ARMGenerator returns a generator of UrlSigningActionParameters_ARM instances for property testing.
// We first initialize urlSigningActionParameters_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningActionParameters_ARMGenerator() gopter.Gen {
	if urlSigningActionParameters_ARMGenerator != nil {
		return urlSigningActionParameters_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionParameters_ARM(generators)
	urlSigningActionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionParameters_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningActionParameters_ARM(generators)
	AddRelatedPropertyGeneratorsForUrlSigningActionParameters_ARM(generators)
	urlSigningActionParameters_ARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningActionParameters_ARM{}), generators)

	return urlSigningActionParameters_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningActionParameters_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningActionParameters_ARM(gens map[string]gopter.Gen) {
	gens["Algorithm"] = gen.PtrOf(gen.OneConstOf(UrlSigningActionParameters_Algorithm_SHA256))
	gens["TypeName"] = gen.PtrOf(gen.OneConstOf(UrlSigningActionParameters_TypeName_DeliveryRuleUrlSigningActionParameters))
}

// AddRelatedPropertyGeneratorsForUrlSigningActionParameters_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningActionParameters_ARM(gens map[string]gopter.Gen) {
	gens["ParameterNameOverride"] = gen.SliceOf(UrlSigningParamIdentifier_ARMGenerator())
}

func Test_UrlSigningAction_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningAction_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningAction_ARM, UrlSigningAction_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningAction_ARM runs a test to see if a specific instance of UrlSigningAction_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningAction_ARM(subject UrlSigningAction_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningAction_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningAction_ARM instances for property testing - lazily instantiated by
// UrlSigningAction_ARMGenerator()
var urlSigningAction_ARMGenerator gopter.Gen

// UrlSigningAction_ARMGenerator returns a generator of UrlSigningAction_ARM instances for property testing.
// We first initialize urlSigningAction_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningAction_ARMGenerator() gopter.Gen {
	if urlSigningAction_ARMGenerator != nil {
		return urlSigningAction_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningAction_ARM(generators)
	urlSigningAction_ARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningAction_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningAction_ARM(generators)
	AddRelatedPropertyGeneratorsForUrlSigningAction_ARM(generators)
	urlSigningAction_ARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningAction_ARM{}), generators)

	return urlSigningAction_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningAction_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningAction_ARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.OneConstOf(UrlSigningAction_Name_UrlSigning)
}

// AddRelatedPropertyGeneratorsForUrlSigningAction_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningAction_ARM(gens map[string]gopter.Gen) {
	gens["Parameters"] = gen.PtrOf(UrlSigningActionParameters_ARMGenerator())
}

func Test_UrlSigningKey_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningKey_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningKey_ARM, UrlSigningKey_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningKey_ARM runs a test to see if a specific instance of UrlSigningKey_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningKey_ARM(subject UrlSigningKey_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningKey_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningKey_ARM instances for property testing - lazily instantiated by UrlSigningKey_ARMGenerator()
var urlSigningKey_ARMGenerator gopter.Gen

// UrlSigningKey_ARMGenerator returns a generator of UrlSigningKey_ARM instances for property testing.
// We first initialize urlSigningKey_ARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UrlSigningKey_ARMGenerator() gopter.Gen {
	if urlSigningKey_ARMGenerator != nil {
		return urlSigningKey_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKey_ARM(generators)
	urlSigningKey_ARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningKey_ARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningKey_ARM(generators)
	AddRelatedPropertyGeneratorsForUrlSigningKey_ARM(generators)
	urlSigningKey_ARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningKey_ARM{}), generators)

	return urlSigningKey_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningKey_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningKey_ARM(gens map[string]gopter.Gen) {
	gens["KeyId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUrlSigningKey_ARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUrlSigningKey_ARM(gens map[string]gopter.Gen) {
	gens["KeySourceParameters"] = gen.PtrOf(KeyVaultSigningKeyParameters_ARMGenerator())
}

func Test_UrlSigningParamIdentifier_ARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UrlSigningParamIdentifier_ARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUrlSigningParamIdentifier_ARM, UrlSigningParamIdentifier_ARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUrlSigningParamIdentifier_ARM runs a test to see if a specific instance of UrlSigningParamIdentifier_ARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUrlSigningParamIdentifier_ARM(subject UrlSigningParamIdentifier_ARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UrlSigningParamIdentifier_ARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UrlSigningParamIdentifier_ARM instances for property testing - lazily instantiated by
// UrlSigningParamIdentifier_ARMGenerator()
var urlSigningParamIdentifier_ARMGenerator gopter.Gen

// UrlSigningParamIdentifier_ARMGenerator returns a generator of UrlSigningParamIdentifier_ARM instances for property testing.
func UrlSigningParamIdentifier_ARMGenerator() gopter.Gen {
	if urlSigningParamIdentifier_ARMGenerator != nil {
		return urlSigningParamIdentifier_ARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUrlSigningParamIdentifier_ARM(generators)
	urlSigningParamIdentifier_ARMGenerator = gen.Struct(reflect.TypeOf(UrlSigningParamIdentifier_ARM{}), generators)

	return urlSigningParamIdentifier_ARMGenerator
}

// AddIndependentPropertyGeneratorsForUrlSigningParamIdentifier_ARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUrlSigningParamIdentifier_ARM(gens map[string]gopter.Gen) {
	gens["ParamIndicator"] = gen.PtrOf(gen.OneConstOf(UrlSigningParamIdentifier_ParamIndicator_Expires, UrlSigningParamIdentifier_ParamIndicator_KeyId, UrlSigningParamIdentifier_ParamIndicator_Signature))
	gens["ParamName"] = gen.PtrOf(gen.AlphaString())
}
