// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20180601

import (
	"fmt"
	v20180601s "github.com/Azure/azure-service-operator/v2/api/dbformariadb/v1beta20180601storage"
	"github.com/Azure/azure-service-operator/v2/internal/reflecthelpers"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	kerrors "k8s.io/apimachinery/pkg/util/errors"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
	"sigs.k8s.io/controller-runtime/pkg/webhook/admission"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Generator information:
// - Generated from: /mariadb/resource-manager/Microsoft.DBforMariaDB/stable/2018-06-01/mariadb.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DBforMariaDB/servers/{serverName}
type Server struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              Server_Spec   `json:"spec,omitempty"`
	Status            Server_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &Server{}

// GetConditions returns the conditions of the resource
func (server *Server) GetConditions() conditions.Conditions {
	return server.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (server *Server) SetConditions(conditions conditions.Conditions) {
	server.Status.Conditions = conditions
}

var _ conversion.Convertible = &Server{}

// ConvertFrom populates our Server from the provided hub Server
func (server *Server) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20180601s.Server)
	if !ok {
		return fmt.Errorf("expected dbformariadb/v1beta20180601storage/Server but received %T instead", hub)
	}

	return server.AssignPropertiesFromServer(source)
}

// ConvertTo populates the provided hub Server from our Server
func (server *Server) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20180601s.Server)
	if !ok {
		return fmt.Errorf("expected dbformariadb/v1beta20180601storage/Server but received %T instead", hub)
	}

	return server.AssignPropertiesToServer(destination)
}

// +kubebuilder:webhook:path=/mutate-dbformariadb-azure-com-v1beta20180601-server,mutating=true,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=dbformariadb.azure.com,resources=servers,verbs=create;update,versions=v1beta20180601,name=default.v1beta20180601.servers.dbformariadb.azure.com,admissionReviewVersions=v1beta1

var _ admission.Defaulter = &Server{}

// Default applies defaults to the Server resource
func (server *Server) Default() {
	server.defaultImpl()
	var temp interface{} = server
	if runtimeDefaulter, ok := temp.(genruntime.Defaulter); ok {
		runtimeDefaulter.CustomDefault()
	}
}

// defaultAzureName defaults the Azure name of the resource to the Kubernetes name
func (server *Server) defaultAzureName() {
	if server.Spec.AzureName == "" {
		server.Spec.AzureName = server.Name
	}
}

// defaultImpl applies the code generated defaults to the Server resource
func (server *Server) defaultImpl() { server.defaultAzureName() }

var _ genruntime.KubernetesResource = &Server{}

// AzureName returns the Azure name of the resource
func (server *Server) AzureName() string {
	return server.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2018-06-01"
func (server Server) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceKind returns the kind of the resource
func (server *Server) GetResourceKind() genruntime.ResourceKind {
	return genruntime.ResourceKindNormal
}

// GetSpec returns the specification of this resource
func (server *Server) GetSpec() genruntime.ConvertibleSpec {
	return &server.Spec
}

// GetStatus returns the status of this resource
func (server *Server) GetStatus() genruntime.ConvertibleStatus {
	return &server.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.DBforMariaDB/servers"
func (server *Server) GetType() string {
	return "Microsoft.DBforMariaDB/servers"
}

// NewEmptyStatus returns a new empty (blank) status
func (server *Server) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &Server_STATUS{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (server *Server) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(server.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  server.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (server *Server) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*Server_STATUS); ok {
		server.Status = *st
		return nil
	}

	// Convert status to required version
	var st Server_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	server.Status = st
	return nil
}

// +kubebuilder:webhook:path=/validate-dbformariadb-azure-com-v1beta20180601-server,mutating=false,sideEffects=None,matchPolicy=Exact,failurePolicy=fail,groups=dbformariadb.azure.com,resources=servers,verbs=create;update,versions=v1beta20180601,name=validate.v1beta20180601.servers.dbformariadb.azure.com,admissionReviewVersions=v1beta1

var _ admission.Validator = &Server{}

// ValidateCreate validates the creation of the resource
func (server *Server) ValidateCreate() error {
	validations := server.createValidations()
	var temp interface{} = server
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.CreateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateDelete validates the deletion of the resource
func (server *Server) ValidateDelete() error {
	validations := server.deleteValidations()
	var temp interface{} = server
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.DeleteValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation()
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// ValidateUpdate validates an update of the resource
func (server *Server) ValidateUpdate(old runtime.Object) error {
	validations := server.updateValidations()
	var temp interface{} = server
	if runtimeValidator, ok := temp.(genruntime.Validator); ok {
		validations = append(validations, runtimeValidator.UpdateValidations()...)
	}
	var errs []error
	for _, validation := range validations {
		err := validation(old)
		if err != nil {
			errs = append(errs, err)
		}
	}
	return kerrors.NewAggregate(errs)
}

// createValidations validates the creation of the resource
func (server *Server) createValidations() []func() error {
	return []func() error{server.validateResourceReferences, server.validateSecretDestinations}
}

// deleteValidations validates the deletion of the resource
func (server *Server) deleteValidations() []func() error {
	return nil
}

// updateValidations validates the update of the resource
func (server *Server) updateValidations() []func(old runtime.Object) error {
	return []func(old runtime.Object) error{
		func(old runtime.Object) error {
			return server.validateResourceReferences()
		},
		server.validateWriteOnceProperties,
		func(old runtime.Object) error {
			return server.validateSecretDestinations()
		},
	}
}

// validateResourceReferences validates all resource references
func (server *Server) validateResourceReferences() error {
	refs, err := reflecthelpers.FindResourceReferences(&server.Spec)
	if err != nil {
		return err
	}
	return genruntime.ValidateResourceReferences(refs)
}

// validateSecretDestinations validates there are no colliding genruntime.SecretDestination's
func (server *Server) validateSecretDestinations() error {
	if server.Spec.OperatorSpec == nil {
		return nil
	}
	if server.Spec.OperatorSpec.Secrets == nil {
		return nil
	}
	secrets := []*genruntime.SecretDestination{
		server.Spec.OperatorSpec.Secrets.FullyQualifiedDomainName,
	}
	return genruntime.ValidateSecretDestinations(secrets)
}

// validateWriteOnceProperties validates all WriteOnce properties
func (server *Server) validateWriteOnceProperties(old runtime.Object) error {
	oldObj, ok := old.(*Server)
	if !ok {
		return nil
	}

	return genruntime.ValidateWriteOnceProperties(oldObj, server)
}

// AssignPropertiesFromServer populates our Server from the provided source Server
func (server *Server) AssignPropertiesFromServer(source *v20180601s.Server) error {

	// ObjectMeta
	server.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
	var spec Server_Spec
	err := spec.AssignPropertiesFromServer_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromServer_Spec() to populate field Spec")
	}
	server.Spec = spec

	// Status
	var status Server_STATUS
	err = status.AssignPropertiesFromServer_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromServer_STATUS() to populate field Status")
	}
	server.Status = status

	// No error
	return nil
}

// AssignPropertiesToServer populates the provided destination Server from our Server
func (server *Server) AssignPropertiesToServer(destination *v20180601s.Server) error {

	// ObjectMeta
	destination.ObjectMeta = *server.ObjectMeta.DeepCopy()

	// Spec
	var spec v20180601s.Server_Spec
	err := server.Spec.AssignPropertiesToServer_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToServer_Spec() to populate field Spec")
	}
	destination.Spec = spec

	// Status
	var status v20180601s.Server_STATUS
	err = server.Status.AssignPropertiesToServer_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToServer_STATUS() to populate field Status")
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (server *Server) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: server.Spec.OriginalVersion(),
		Kind:    "Server",
	}
}

// +kubebuilder:object:root=true
// Generator information:
// - Generated from: /mariadb/resource-manager/Microsoft.DBforMariaDB/stable/2018-06-01/mariadb.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DBforMariaDB/servers/{serverName}
type ServerList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []Server `json:"items"`
}

type Server_STATUS struct {
	// AdministratorLogin: The administrator's login name of a server. Can only be specified when the server is being created
	// (and is required for creation).
	AdministratorLogin *string `json:"administratorLogin,omitempty"`

	// Conditions: The observed state of the resource
	Conditions []conditions.Condition `json:"conditions,omitempty"`

	// EarliestRestoreDate: Earliest restore point creation time (ISO8601 format)
	EarliestRestoreDate *string `json:"earliestRestoreDate,omitempty"`

	// FullyQualifiedDomainName: The fully qualified domain name of a server.
	FullyQualifiedDomainName *string `json:"fullyQualifiedDomainName,omitempty"`

	// Id: Fully qualified resource ID for the resource. Ex -
	// /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	Id *string `json:"id,omitempty"`

	// Location: The geo-location where the resource lives
	Location *string `json:"location,omitempty"`

	// MasterServerId: The master server id of a replica server.
	MasterServerId *string `json:"masterServerId,omitempty"`

	// MinimalTlsVersion: Enforce a minimal Tls version for the server.
	MinimalTlsVersion *MinimalTlsVersion_STATUS `json:"minimalTlsVersion,omitempty"`

	// Name: The name of the resource
	Name *string `json:"name,omitempty"`

	// PrivateEndpointConnections: List of private endpoint connections on a server
	PrivateEndpointConnections []ServerPrivateEndpointConnection_STATUS `json:"privateEndpointConnections,omitempty"`

	// PublicNetworkAccess: Whether or not public network access is allowed for this server. Value is optional but if passed
	// in, must be 'Enabled' or 'Disabled'
	PublicNetworkAccess *PublicNetworkAccess_STATUS `json:"publicNetworkAccess,omitempty"`

	// ReplicaCapacity: The maximum number of replicas that a master server can have.
	ReplicaCapacity *int `json:"replicaCapacity,omitempty"`

	// ReplicationRole: The replication role of the server.
	ReplicationRole *string `json:"replicationRole,omitempty"`

	// Sku: The SKU (pricing tier) of the server.
	Sku *Sku_STATUS `json:"sku,omitempty"`

	// SslEnforcement: Enable ssl enforcement or not when connect to server.
	SslEnforcement *SslEnforcement_STATUS `json:"sslEnforcement,omitempty"`

	// StorageProfile: Storage profile of a server.
	StorageProfile *StorageProfile_STATUS `json:"storageProfile,omitempty"`

	// Tags: Resource tags.
	Tags map[string]string `json:"tags,omitempty"`

	// Type: The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`

	// UserVisibleState: A state of a server that is visible to user.
	UserVisibleState *ServerProperties_UserVisibleState_STATUS `json:"userVisibleState,omitempty"`

	// Version: Server version.
	Version *ServerVersion_STATUS `json:"version,omitempty"`
}

var _ genruntime.ConvertibleStatus = &Server_STATUS{}

// ConvertStatusFrom populates our Server_STATUS from the provided source
func (server *Server_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20180601s.Server_STATUS)
	if ok {
		// Populate our instance from source
		return server.AssignPropertiesFromServer_STATUS(src)
	}

	// Convert to an intermediate form
	src = &v20180601s.Server_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
	err = server.AssignPropertiesFromServer_STATUS(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our Server_STATUS
func (server *Server_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20180601s.Server_STATUS)
	if ok {
		// Populate destination from our instance
		return server.AssignPropertiesToServer_STATUS(dst)
	}

	// Convert to an intermediate form
	dst = &v20180601s.Server_STATUS{}
	err := server.AssignPropertiesToServer_STATUS(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

var _ genruntime.FromARMConverter = &Server_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (server *Server_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Server_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (server *Server_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Server_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Server_STATUSARM, got %T", armInput)
	}

	// Set property ‘AdministratorLogin’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.AdministratorLogin != nil {
			administratorLogin := *typedInput.Properties.AdministratorLogin
			server.AdministratorLogin = &administratorLogin
		}
	}

	// no assignment for property ‘Conditions’

	// Set property ‘EarliestRestoreDate’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.EarliestRestoreDate != nil {
			earliestRestoreDate := *typedInput.Properties.EarliestRestoreDate
			server.EarliestRestoreDate = &earliestRestoreDate
		}
	}

	// Set property ‘FullyQualifiedDomainName’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.FullyQualifiedDomainName != nil {
			fullyQualifiedDomainName := *typedInput.Properties.FullyQualifiedDomainName
			server.FullyQualifiedDomainName = &fullyQualifiedDomainName
		}
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		server.Id = &id
	}

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		server.Location = &location
	}

	// Set property ‘MasterServerId’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MasterServerId != nil {
			masterServerId := *typedInput.Properties.MasterServerId
			server.MasterServerId = &masterServerId
		}
	}

	// Set property ‘MinimalTlsVersion’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.MinimalTlsVersion != nil {
			minimalTlsVersion := *typedInput.Properties.MinimalTlsVersion
			server.MinimalTlsVersion = &minimalTlsVersion
		}
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		server.Name = &name
	}

	// Set property ‘PrivateEndpointConnections’:
	// copying flattened property:
	if typedInput.Properties != nil {
		for _, item := range typedInput.Properties.PrivateEndpointConnections {
			var item1 ServerPrivateEndpointConnection_STATUS
			err := item1.PopulateFromARM(owner, item)
			if err != nil {
				return err
			}
			server.PrivateEndpointConnections = append(server.PrivateEndpointConnections, item1)
		}
	}

	// Set property ‘PublicNetworkAccess’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.PublicNetworkAccess != nil {
			publicNetworkAccess := *typedInput.Properties.PublicNetworkAccess
			server.PublicNetworkAccess = &publicNetworkAccess
		}
	}

	// Set property ‘ReplicaCapacity’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReplicaCapacity != nil {
			replicaCapacity := *typedInput.Properties.ReplicaCapacity
			server.ReplicaCapacity = &replicaCapacity
		}
	}

	// Set property ‘ReplicationRole’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.ReplicationRole != nil {
			replicationRole := *typedInput.Properties.ReplicationRole
			server.ReplicationRole = &replicationRole
		}
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku_STATUS
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		server.Sku = &sku
	}

	// Set property ‘SslEnforcement’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.SslEnforcement != nil {
			sslEnforcement := *typedInput.Properties.SslEnforcement
			server.SslEnforcement = &sslEnforcement
		}
	}

	// Set property ‘StorageProfile’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.StorageProfile != nil {
			var storageProfile1 StorageProfile_STATUS
			err := storageProfile1.PopulateFromARM(owner, *typedInput.Properties.StorageProfile)
			if err != nil {
				return err
			}
			storageProfile := storageProfile1
			server.StorageProfile = &storageProfile
		}
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		server.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			server.Tags[key] = value
		}
	}

	// Set property ‘Type’:
	if typedInput.Type != nil {
		typeVar := *typedInput.Type
		server.Type = &typeVar
	}

	// Set property ‘UserVisibleState’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.UserVisibleState != nil {
			userVisibleState := *typedInput.Properties.UserVisibleState
			server.UserVisibleState = &userVisibleState
		}
	}

	// Set property ‘Version’:
	// copying flattened property:
	if typedInput.Properties != nil {
		if typedInput.Properties.Version != nil {
			version := *typedInput.Properties.Version
			server.Version = &version
		}
	}

	// No error
	return nil
}

// AssignPropertiesFromServer_STATUS populates our Server_STATUS from the provided source Server_STATUS
func (server *Server_STATUS) AssignPropertiesFromServer_STATUS(source *v20180601s.Server_STATUS) error {

	// AdministratorLogin
	server.AdministratorLogin = genruntime.ClonePointerToString(source.AdministratorLogin)

	// Conditions
	server.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// EarliestRestoreDate
	server.EarliestRestoreDate = genruntime.ClonePointerToString(source.EarliestRestoreDate)

	// FullyQualifiedDomainName
	server.FullyQualifiedDomainName = genruntime.ClonePointerToString(source.FullyQualifiedDomainName)

	// Id
	server.Id = genruntime.ClonePointerToString(source.Id)

	// Location
	server.Location = genruntime.ClonePointerToString(source.Location)

	// MasterServerId
	server.MasterServerId = genruntime.ClonePointerToString(source.MasterServerId)

	// MinimalTlsVersion
	if source.MinimalTlsVersion != nil {
		minimalTlsVersion := MinimalTlsVersion_STATUS(*source.MinimalTlsVersion)
		server.MinimalTlsVersion = &minimalTlsVersion
	} else {
		server.MinimalTlsVersion = nil
	}

	// Name
	server.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateEndpointConnections
	if source.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]ServerPrivateEndpointConnection_STATUS, len(source.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range source.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection ServerPrivateEndpointConnection_STATUS
			err := privateEndpointConnection.AssignPropertiesFromServerPrivateEndpointConnection_STATUS(&privateEndpointConnectionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromServerPrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		server.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		server.PrivateEndpointConnections = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := PublicNetworkAccess_STATUS(*source.PublicNetworkAccess)
		server.PublicNetworkAccess = &publicNetworkAccess
	} else {
		server.PublicNetworkAccess = nil
	}

	// ReplicaCapacity
	server.ReplicaCapacity = genruntime.ClonePointerToInt(source.ReplicaCapacity)

	// ReplicationRole
	server.ReplicationRole = genruntime.ClonePointerToString(source.ReplicationRole)

	// Sku
	if source.Sku != nil {
		var sku Sku_STATUS
		err := sku.AssignPropertiesFromSku_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSku_STATUS() to populate field Sku")
		}
		server.Sku = &sku
	} else {
		server.Sku = nil
	}

	// SslEnforcement
	if source.SslEnforcement != nil {
		sslEnforcement := SslEnforcement_STATUS(*source.SslEnforcement)
		server.SslEnforcement = &sslEnforcement
	} else {
		server.SslEnforcement = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile_STATUS
		err := storageProfile.AssignPropertiesFromStorageProfile_STATUS(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromStorageProfile_STATUS() to populate field StorageProfile")
		}
		server.StorageProfile = &storageProfile
	} else {
		server.StorageProfile = nil
	}

	// Tags
	server.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	server.Type = genruntime.ClonePointerToString(source.Type)

	// UserVisibleState
	if source.UserVisibleState != nil {
		userVisibleState := ServerProperties_UserVisibleState_STATUS(*source.UserVisibleState)
		server.UserVisibleState = &userVisibleState
	} else {
		server.UserVisibleState = nil
	}

	// Version
	if source.Version != nil {
		version := ServerVersion_STATUS(*source.Version)
		server.Version = &version
	} else {
		server.Version = nil
	}

	// No error
	return nil
}

// AssignPropertiesToServer_STATUS populates the provided destination Server_STATUS from our Server_STATUS
func (server *Server_STATUS) AssignPropertiesToServer_STATUS(destination *v20180601s.Server_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AdministratorLogin
	destination.AdministratorLogin = genruntime.ClonePointerToString(server.AdministratorLogin)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(server.Conditions)

	// EarliestRestoreDate
	destination.EarliestRestoreDate = genruntime.ClonePointerToString(server.EarliestRestoreDate)

	// FullyQualifiedDomainName
	destination.FullyQualifiedDomainName = genruntime.ClonePointerToString(server.FullyQualifiedDomainName)

	// Id
	destination.Id = genruntime.ClonePointerToString(server.Id)

	// Location
	destination.Location = genruntime.ClonePointerToString(server.Location)

	// MasterServerId
	destination.MasterServerId = genruntime.ClonePointerToString(server.MasterServerId)

	// MinimalTlsVersion
	if server.MinimalTlsVersion != nil {
		minimalTlsVersion := string(*server.MinimalTlsVersion)
		destination.MinimalTlsVersion = &minimalTlsVersion
	} else {
		destination.MinimalTlsVersion = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(server.Name)

	// PrivateEndpointConnections
	if server.PrivateEndpointConnections != nil {
		privateEndpointConnectionList := make([]v20180601s.ServerPrivateEndpointConnection_STATUS, len(server.PrivateEndpointConnections))
		for privateEndpointConnectionIndex, privateEndpointConnectionItem := range server.PrivateEndpointConnections {
			// Shadow the loop variable to avoid aliasing
			privateEndpointConnectionItem := privateEndpointConnectionItem
			var privateEndpointConnection v20180601s.ServerPrivateEndpointConnection_STATUS
			err := privateEndpointConnectionItem.AssignPropertiesToServerPrivateEndpointConnection_STATUS(&privateEndpointConnection)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToServerPrivateEndpointConnection_STATUS() to populate field PrivateEndpointConnections")
			}
			privateEndpointConnectionList[privateEndpointConnectionIndex] = privateEndpointConnection
		}
		destination.PrivateEndpointConnections = privateEndpointConnectionList
	} else {
		destination.PrivateEndpointConnections = nil
	}

	// PublicNetworkAccess
	if server.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*server.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// ReplicaCapacity
	destination.ReplicaCapacity = genruntime.ClonePointerToInt(server.ReplicaCapacity)

	// ReplicationRole
	destination.ReplicationRole = genruntime.ClonePointerToString(server.ReplicationRole)

	// Sku
	if server.Sku != nil {
		var sku v20180601s.Sku_STATUS
		err := server.Sku.AssignPropertiesToSku_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSku_STATUS() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// SslEnforcement
	if server.SslEnforcement != nil {
		sslEnforcement := string(*server.SslEnforcement)
		destination.SslEnforcement = &sslEnforcement
	} else {
		destination.SslEnforcement = nil
	}

	// StorageProfile
	if server.StorageProfile != nil {
		var storageProfile v20180601s.StorageProfile_STATUS
		err := server.StorageProfile.AssignPropertiesToStorageProfile_STATUS(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToStorageProfile_STATUS() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(server.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(server.Type)

	// UserVisibleState
	if server.UserVisibleState != nil {
		userVisibleState := string(*server.UserVisibleState)
		destination.UserVisibleState = &userVisibleState
	} else {
		destination.UserVisibleState = nil
	}

	// Version
	if server.Version != nil {
		version := string(*server.Version)
		destination.Version = &version
	} else {
		destination.Version = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Server_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName string `json:"azureName,omitempty"`

	// +kubebuilder:validation:Required
	// Location: The location the resource resides in.
	Location *string `json:"location,omitempty"`

	// OperatorSpec: The specification for configuring operator behavior. This field is interpreted by the operator and not
	// passed directly to Azure
	OperatorSpec *ServerOperatorSpec `json:"operatorSpec,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner *genruntime.KnownResourceReference `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`

	// +kubebuilder:validation:Required
	// Properties: Properties of the server.
	Properties *ServerPropertiesForCreate `json:"properties,omitempty"`

	// Sku: The SKU (pricing tier) of the server.
	Sku *Sku `json:"sku,omitempty"`

	// Tags: Application-specific metadata in the form of key-value pairs.
	Tags map[string]string `json:"tags,omitempty"`
}

var _ genruntime.ARMTransformer = &Server_Spec{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (server *Server_Spec) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if server == nil {
		return nil, nil
	}
	result := &Server_SpecARM{}

	// Set property ‘AzureName’:
	result.AzureName = server.AzureName

	// Set property ‘Location’:
	if server.Location != nil {
		location := *server.Location
		result.Location = &location
	}

	// Set property ‘Name’:
	result.Name = resolved.Name

	// Set property ‘Properties’:
	if server.Properties != nil {
		propertiesARM, err := (*server.Properties).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		properties := *propertiesARM.(*ServerPropertiesForCreateARM)
		result.Properties = &properties
	}

	// Set property ‘Sku’:
	if server.Sku != nil {
		skuARM, err := (*server.Sku).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		sku := *skuARM.(*SkuARM)
		result.Sku = &sku
	}

	// Set property ‘Tags’:
	if server.Tags != nil {
		result.Tags = make(map[string]string)
		for key, value := range server.Tags {
			result.Tags[key] = value
		}
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (server *Server_Spec) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Server_SpecARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (server *Server_Spec) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Server_SpecARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Server_SpecARM, got %T", armInput)
	}

	// Set property ‘AzureName’:
	server.SetAzureName(genruntime.ExtractKubernetesResourceNameFromARMName(typedInput.Name))

	// Set property ‘Location’:
	if typedInput.Location != nil {
		location := *typedInput.Location
		server.Location = &location
	}

	// no assignment for property ‘OperatorSpec’

	// Set property ‘Owner’:
	server.Owner = &genruntime.KnownResourceReference{
		Name: owner.Name,
	}

	// Set property ‘Properties’:
	if typedInput.Properties != nil {
		var properties1 ServerPropertiesForCreate
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		server.Properties = &properties
	}

	// Set property ‘Sku’:
	if typedInput.Sku != nil {
		var sku1 Sku
		err := sku1.PopulateFromARM(owner, *typedInput.Sku)
		if err != nil {
			return err
		}
		sku := sku1
		server.Sku = &sku
	}

	// Set property ‘Tags’:
	if typedInput.Tags != nil {
		server.Tags = make(map[string]string)
		for key, value := range typedInput.Tags {
			server.Tags[key] = value
		}
	}

	// No error
	return nil
}

var _ genruntime.ConvertibleSpec = &Server_Spec{}

// ConvertSpecFrom populates our Server_Spec from the provided source
func (server *Server_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20180601s.Server_Spec)
	if ok {
		// Populate our instance from source
		return server.AssignPropertiesFromServer_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20180601s.Server_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = server.AssignPropertiesFromServer_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our Server_Spec
func (server *Server_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20180601s.Server_Spec)
	if ok {
		// Populate destination from our instance
		return server.AssignPropertiesToServer_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20180601s.Server_Spec{}
	err := server.AssignPropertiesToServer_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromServer_Spec populates our Server_Spec from the provided source Server_Spec
func (server *Server_Spec) AssignPropertiesFromServer_Spec(source *v20180601s.Server_Spec) error {

	// AzureName
	server.AzureName = source.AzureName

	// Location
	server.Location = genruntime.ClonePointerToString(source.Location)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec ServerOperatorSpec
		err := operatorSpec.AssignPropertiesFromServerOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromServerOperatorSpec() to populate field OperatorSpec")
		}
		server.OperatorSpec = &operatorSpec
	} else {
		server.OperatorSpec = nil
	}

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		server.Owner = &owner
	} else {
		server.Owner = nil
	}

	// Properties
	if source.Properties != nil {
		var property ServerPropertiesForCreate
		err := property.AssignPropertiesFromServerPropertiesForCreate(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromServerPropertiesForCreate() to populate field Properties")
		}
		server.Properties = &property
	} else {
		server.Properties = nil
	}

	// Sku
	if source.Sku != nil {
		var sku Sku
		err := sku.AssignPropertiesFromSku(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromSku() to populate field Sku")
		}
		server.Sku = &sku
	} else {
		server.Sku = nil
	}

	// Tags
	server.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// No error
	return nil
}

// AssignPropertiesToServer_Spec populates the provided destination Server_Spec from our Server_Spec
func (server *Server_Spec) AssignPropertiesToServer_Spec(destination *v20180601s.Server_Spec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// AzureName
	destination.AzureName = server.AzureName

	// Location
	destination.Location = genruntime.ClonePointerToString(server.Location)

	// OperatorSpec
	if server.OperatorSpec != nil {
		var operatorSpec v20180601s.ServerOperatorSpec
		err := server.OperatorSpec.AssignPropertiesToServerOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToServerOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = server.OriginalVersion()

	// Owner
	if server.Owner != nil {
		owner := server.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// Properties
	if server.Properties != nil {
		var property v20180601s.ServerPropertiesForCreate
		err := server.Properties.AssignPropertiesToServerPropertiesForCreate(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToServerPropertiesForCreate() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Sku
	if server.Sku != nil {
		var sku v20180601s.Sku
		err := server.Sku.AssignPropertiesToSku(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToSku() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(server.Tags)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// OriginalVersion returns the original API version used to create the resource.
func (server *Server_Spec) OriginalVersion() string {
	return GroupVersion.Version
}

// SetAzureName sets the Azure name of the resource
func (server *Server_Spec) SetAzureName(azureName string) { server.AzureName = azureName }

type MinimalTlsVersion_STATUS string

const (
	MinimalTlsVersion_TLS1_0_STATUS                 = MinimalTlsVersion_STATUS("TLS1_0")
	MinimalTlsVersion_TLS1_1_STATUS                 = MinimalTlsVersion_STATUS("TLS1_1")
	MinimalTlsVersion_TLS1_2_STATUS                 = MinimalTlsVersion_STATUS("TLS1_2")
	MinimalTlsVersion_TLSEnforcementDisabled_STATUS = MinimalTlsVersion_STATUS("TLSEnforcementDisabled")
)

type PublicNetworkAccess_STATUS string

const (
	PublicNetworkAccess_Disabled_STATUS = PublicNetworkAccess_STATUS("Disabled")
	PublicNetworkAccess_Enabled_STATUS  = PublicNetworkAccess_STATUS("Enabled")
)

// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type ServerOperatorSpec struct {
	// Secrets: configures where to place Azure generated secrets.
	Secrets *ServerOperatorSecrets `json:"secrets,omitempty"`
}

// AssignPropertiesFromServerOperatorSpec populates our ServerOperatorSpec from the provided source ServerOperatorSpec
func (operator *ServerOperatorSpec) AssignPropertiesFromServerOperatorSpec(source *v20180601s.ServerOperatorSpec) error {

	// Secrets
	if source.Secrets != nil {
		var secret ServerOperatorSecrets
		err := secret.AssignPropertiesFromServerOperatorSecrets(source.Secrets)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromServerOperatorSecrets() to populate field Secrets")
		}
		operator.Secrets = &secret
	} else {
		operator.Secrets = nil
	}

	// No error
	return nil
}

// AssignPropertiesToServerOperatorSpec populates the provided destination ServerOperatorSpec from our ServerOperatorSpec
func (operator *ServerOperatorSpec) AssignPropertiesToServerOperatorSpec(destination *v20180601s.ServerOperatorSpec) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Secrets
	if operator.Secrets != nil {
		var secret v20180601s.ServerOperatorSecrets
		err := operator.Secrets.AssignPropertiesToServerOperatorSecrets(&secret)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToServerOperatorSecrets() to populate field Secrets")
		}
		destination.Secrets = &secret
	} else {
		destination.Secrets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerPrivateEndpointConnection_STATUS struct {
	// Id: Resource Id of the private endpoint connection.
	Id *string `json:"id,omitempty"`

	// Properties: Private endpoint connection properties
	Properties *ServerPrivateEndpointConnectionProperties_STATUS `json:"properties,omitempty"`
}

var _ genruntime.FromARMConverter = &ServerPrivateEndpointConnection_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (connection *ServerPrivateEndpointConnection_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServerPrivateEndpointConnection_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (connection *ServerPrivateEndpointConnection_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServerPrivateEndpointConnection_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServerPrivateEndpointConnection_STATUSARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		connection.Id = &id
	}

	// Set property ‘Properties’:
	if typedInput.Properties != nil {
		var properties1 ServerPrivateEndpointConnectionProperties_STATUS
		err := properties1.PopulateFromARM(owner, *typedInput.Properties)
		if err != nil {
			return err
		}
		properties := properties1
		connection.Properties = &properties
	}

	// No error
	return nil
}

// AssignPropertiesFromServerPrivateEndpointConnection_STATUS populates our ServerPrivateEndpointConnection_STATUS from the provided source ServerPrivateEndpointConnection_STATUS
func (connection *ServerPrivateEndpointConnection_STATUS) AssignPropertiesFromServerPrivateEndpointConnection_STATUS(source *v20180601s.ServerPrivateEndpointConnection_STATUS) error {

	// Id
	connection.Id = genruntime.ClonePointerToString(source.Id)

	// Properties
	if source.Properties != nil {
		var property ServerPrivateEndpointConnectionProperties_STATUS
		err := property.AssignPropertiesFromServerPrivateEndpointConnectionProperties_STATUS(source.Properties)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromServerPrivateEndpointConnectionProperties_STATUS() to populate field Properties")
		}
		connection.Properties = &property
	} else {
		connection.Properties = nil
	}

	// No error
	return nil
}

// AssignPropertiesToServerPrivateEndpointConnection_STATUS populates the provided destination ServerPrivateEndpointConnection_STATUS from our ServerPrivateEndpointConnection_STATUS
func (connection *ServerPrivateEndpointConnection_STATUS) AssignPropertiesToServerPrivateEndpointConnection_STATUS(destination *v20180601s.ServerPrivateEndpointConnection_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(connection.Id)

	// Properties
	if connection.Properties != nil {
		var property v20180601s.ServerPrivateEndpointConnectionProperties_STATUS
		err := connection.Properties.AssignPropertiesToServerPrivateEndpointConnectionProperties_STATUS(&property)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToServerPrivateEndpointConnectionProperties_STATUS() to populate field Properties")
		}
		destination.Properties = &property
	} else {
		destination.Properties = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerPropertiesForCreate struct {
	// +kubebuilder:validation:Required
	// CreateMode: The mode to create a new server.
	CreateMode *ServerPropertiesForCreate_CreateMode `json:"createMode,omitempty"`

	// MinimalTlsVersion: Enforce a minimal Tls version for the server.
	MinimalTlsVersion *MinimalTlsVersion `json:"minimalTlsVersion,omitempty"`

	// PublicNetworkAccess: Whether or not public network access is allowed for this server. Value is optional but if passed
	// in, must be 'Enabled' or 'Disabled'
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// SslEnforcement: Enable ssl enforcement or not when connect to server.
	SslEnforcement *SslEnforcement `json:"sslEnforcement,omitempty"`

	// StorageProfile: Storage profile of a server.
	StorageProfile *StorageProfile `json:"storageProfile,omitempty"`

	// Version: Server version.
	Version *ServerVersion `json:"version,omitempty"`
}

var _ genruntime.ARMTransformer = &ServerPropertiesForCreate{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (create *ServerPropertiesForCreate) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if create == nil {
		return nil, nil
	}
	result := &ServerPropertiesForCreateARM{}

	// Set property ‘CreateMode’:
	if create.CreateMode != nil {
		createMode := *create.CreateMode
		result.CreateMode = &createMode
	}

	// Set property ‘MinimalTlsVersion’:
	if create.MinimalTlsVersion != nil {
		minimalTlsVersion := *create.MinimalTlsVersion
		result.MinimalTlsVersion = &minimalTlsVersion
	}

	// Set property ‘PublicNetworkAccess’:
	if create.PublicNetworkAccess != nil {
		publicNetworkAccess := *create.PublicNetworkAccess
		result.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property ‘SslEnforcement’:
	if create.SslEnforcement != nil {
		sslEnforcement := *create.SslEnforcement
		result.SslEnforcement = &sslEnforcement
	}

	// Set property ‘StorageProfile’:
	if create.StorageProfile != nil {
		storageProfileARM, err := (*create.StorageProfile).ConvertToARM(resolved)
		if err != nil {
			return nil, err
		}
		storageProfile := *storageProfileARM.(*StorageProfileARM)
		result.StorageProfile = &storageProfile
	}

	// Set property ‘Version’:
	if create.Version != nil {
		version := *create.Version
		result.Version = &version
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (create *ServerPropertiesForCreate) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServerPropertiesForCreateARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (create *ServerPropertiesForCreate) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServerPropertiesForCreateARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServerPropertiesForCreateARM, got %T", armInput)
	}

	// Set property ‘CreateMode’:
	if typedInput.CreateMode != nil {
		createMode := *typedInput.CreateMode
		create.CreateMode = &createMode
	}

	// Set property ‘MinimalTlsVersion’:
	if typedInput.MinimalTlsVersion != nil {
		minimalTlsVersion := *typedInput.MinimalTlsVersion
		create.MinimalTlsVersion = &minimalTlsVersion
	}

	// Set property ‘PublicNetworkAccess’:
	if typedInput.PublicNetworkAccess != nil {
		publicNetworkAccess := *typedInput.PublicNetworkAccess
		create.PublicNetworkAccess = &publicNetworkAccess
	}

	// Set property ‘SslEnforcement’:
	if typedInput.SslEnforcement != nil {
		sslEnforcement := *typedInput.SslEnforcement
		create.SslEnforcement = &sslEnforcement
	}

	// Set property ‘StorageProfile’:
	if typedInput.StorageProfile != nil {
		var storageProfile1 StorageProfile
		err := storageProfile1.PopulateFromARM(owner, *typedInput.StorageProfile)
		if err != nil {
			return err
		}
		storageProfile := storageProfile1
		create.StorageProfile = &storageProfile
	}

	// Set property ‘Version’:
	if typedInput.Version != nil {
		version := *typedInput.Version
		create.Version = &version
	}

	// No error
	return nil
}

// AssignPropertiesFromServerPropertiesForCreate populates our ServerPropertiesForCreate from the provided source ServerPropertiesForCreate
func (create *ServerPropertiesForCreate) AssignPropertiesFromServerPropertiesForCreate(source *v20180601s.ServerPropertiesForCreate) error {

	// CreateMode
	if source.CreateMode != nil {
		createMode := ServerPropertiesForCreate_CreateMode(*source.CreateMode)
		create.CreateMode = &createMode
	} else {
		create.CreateMode = nil
	}

	// MinimalTlsVersion
	if source.MinimalTlsVersion != nil {
		minimalTlsVersion := MinimalTlsVersion(*source.MinimalTlsVersion)
		create.MinimalTlsVersion = &minimalTlsVersion
	} else {
		create.MinimalTlsVersion = nil
	}

	// PublicNetworkAccess
	if source.PublicNetworkAccess != nil {
		publicNetworkAccess := PublicNetworkAccess(*source.PublicNetworkAccess)
		create.PublicNetworkAccess = &publicNetworkAccess
	} else {
		create.PublicNetworkAccess = nil
	}

	// SslEnforcement
	if source.SslEnforcement != nil {
		sslEnforcement := SslEnforcement(*source.SslEnforcement)
		create.SslEnforcement = &sslEnforcement
	} else {
		create.SslEnforcement = nil
	}

	// StorageProfile
	if source.StorageProfile != nil {
		var storageProfile StorageProfile
		err := storageProfile.AssignPropertiesFromStorageProfile(source.StorageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromStorageProfile() to populate field StorageProfile")
		}
		create.StorageProfile = &storageProfile
	} else {
		create.StorageProfile = nil
	}

	// Version
	if source.Version != nil {
		version := ServerVersion(*source.Version)
		create.Version = &version
	} else {
		create.Version = nil
	}

	// No error
	return nil
}

// AssignPropertiesToServerPropertiesForCreate populates the provided destination ServerPropertiesForCreate from our ServerPropertiesForCreate
func (create *ServerPropertiesForCreate) AssignPropertiesToServerPropertiesForCreate(destination *v20180601s.ServerPropertiesForCreate) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// CreateMode
	if create.CreateMode != nil {
		createMode := string(*create.CreateMode)
		destination.CreateMode = &createMode
	} else {
		destination.CreateMode = nil
	}

	// MinimalTlsVersion
	if create.MinimalTlsVersion != nil {
		minimalTlsVersion := string(*create.MinimalTlsVersion)
		destination.MinimalTlsVersion = &minimalTlsVersion
	} else {
		destination.MinimalTlsVersion = nil
	}

	// PublicNetworkAccess
	if create.PublicNetworkAccess != nil {
		publicNetworkAccess := string(*create.PublicNetworkAccess)
		destination.PublicNetworkAccess = &publicNetworkAccess
	} else {
		destination.PublicNetworkAccess = nil
	}

	// SslEnforcement
	if create.SslEnforcement != nil {
		sslEnforcement := string(*create.SslEnforcement)
		destination.SslEnforcement = &sslEnforcement
	} else {
		destination.SslEnforcement = nil
	}

	// StorageProfile
	if create.StorageProfile != nil {
		var storageProfile v20180601s.StorageProfile
		err := create.StorageProfile.AssignPropertiesToStorageProfile(&storageProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToStorageProfile() to populate field StorageProfile")
		}
		destination.StorageProfile = &storageProfile
	} else {
		destination.StorageProfile = nil
	}

	// Version
	if create.Version != nil {
		version := string(*create.Version)
		destination.Version = &version
	} else {
		destination.Version = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerProperties_UserVisibleState_STATUS string

const (
	ServerProperties_UserVisibleState_Disabled_STATUS = ServerProperties_UserVisibleState_STATUS("Disabled")
	ServerProperties_UserVisibleState_Dropping_STATUS = ServerProperties_UserVisibleState_STATUS("Dropping")
	ServerProperties_UserVisibleState_Ready_STATUS    = ServerProperties_UserVisibleState_STATUS("Ready")
)

type ServerVersion_STATUS string

const (
	ServerVersion_102_STATUS = ServerVersion_STATUS("10.2")
	ServerVersion_103_STATUS = ServerVersion_STATUS("10.3")
)

type Sku struct {
	// +kubebuilder:validation:Minimum=0
	// Capacity: The scale up/out capacity, representing server's compute units.
	Capacity *int `json:"capacity,omitempty"`

	// Family: The family of hardware.
	Family *string `json:"family,omitempty"`

	// +kubebuilder:validation:Required
	// Name: The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
	Name *string `json:"name,omitempty"`

	// Size: The size code, to be interpreted by resource as appropriate.
	Size *string `json:"size,omitempty"`

	// Tier: The tier of the particular SKU, e.g. Basic.
	Tier *Sku_Tier `json:"tier,omitempty"`
}

var _ genruntime.ARMTransformer = &Sku{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (sku *Sku) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if sku == nil {
		return nil, nil
	}
	result := &SkuARM{}

	// Set property ‘Capacity’:
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		result.Capacity = &capacity
	}

	// Set property ‘Family’:
	if sku.Family != nil {
		family := *sku.Family
		result.Family = &family
	}

	// Set property ‘Name’:
	if sku.Name != nil {
		name := *sku.Name
		result.Name = &name
	}

	// Set property ‘Size’:
	if sku.Size != nil {
		size := *sku.Size
		result.Size = &size
	}

	// Set property ‘Tier’:
	if sku.Tier != nil {
		tier := *sku.Tier
		result.Tier = &tier
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &SkuARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(SkuARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected SkuARM, got %T", armInput)
	}

	// Set property ‘Capacity’:
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property ‘Family’:
	if typedInput.Family != nil {
		family := *typedInput.Family
		sku.Family = &family
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property ‘Size’:
	if typedInput.Size != nil {
		size := *typedInput.Size
		sku.Size = &size
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromSku populates our Sku from the provided source Sku
func (sku *Sku) AssignPropertiesFromSku(source *v20180601s.Sku) error {

	// Capacity
	if source.Capacity != nil {
		capacity := *source.Capacity
		sku.Capacity = &capacity
	} else {
		sku.Capacity = nil
	}

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	if source.Tier != nil {
		tier := Sku_Tier(*source.Tier)
		sku.Tier = &tier
	} else {
		sku.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSku populates the provided destination Sku from our Sku
func (sku *Sku) AssignPropertiesToSku(destination *v20180601s.Sku) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	if sku.Capacity != nil {
		capacity := *sku.Capacity
		destination.Capacity = &capacity
	} else {
		destination.Capacity = nil
	}

	// Family
	destination.Family = genruntime.ClonePointerToString(sku.Family)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Size
	destination.Size = genruntime.ClonePointerToString(sku.Size)

	// Tier
	if sku.Tier != nil {
		tier := string(*sku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type Sku_STATUS struct {
	// Capacity: The scale up/out capacity, representing server's compute units.
	Capacity *int `json:"capacity,omitempty"`

	// Family: The family of hardware.
	Family *string `json:"family,omitempty"`

	// Name: The name of the sku, typically, tier + family + cores, e.g. B_Gen4_1, GP_Gen5_8.
	Name *string `json:"name,omitempty"`

	// Size: The size code, to be interpreted by resource as appropriate.
	Size *string `json:"size,omitempty"`

	// Tier: The tier of the particular SKU, e.g. Basic.
	Tier *Sku_Tier_STATUS `json:"tier,omitempty"`
}

var _ genruntime.FromARMConverter = &Sku_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (sku *Sku_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &Sku_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (sku *Sku_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(Sku_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected Sku_STATUSARM, got %T", armInput)
	}

	// Set property ‘Capacity’:
	if typedInput.Capacity != nil {
		capacity := *typedInput.Capacity
		sku.Capacity = &capacity
	}

	// Set property ‘Family’:
	if typedInput.Family != nil {
		family := *typedInput.Family
		sku.Family = &family
	}

	// Set property ‘Name’:
	if typedInput.Name != nil {
		name := *typedInput.Name
		sku.Name = &name
	}

	// Set property ‘Size’:
	if typedInput.Size != nil {
		size := *typedInput.Size
		sku.Size = &size
	}

	// Set property ‘Tier’:
	if typedInput.Tier != nil {
		tier := *typedInput.Tier
		sku.Tier = &tier
	}

	// No error
	return nil
}

// AssignPropertiesFromSku_STATUS populates our Sku_STATUS from the provided source Sku_STATUS
func (sku *Sku_STATUS) AssignPropertiesFromSku_STATUS(source *v20180601s.Sku_STATUS) error {

	// Capacity
	sku.Capacity = genruntime.ClonePointerToInt(source.Capacity)

	// Family
	sku.Family = genruntime.ClonePointerToString(source.Family)

	// Name
	sku.Name = genruntime.ClonePointerToString(source.Name)

	// Size
	sku.Size = genruntime.ClonePointerToString(source.Size)

	// Tier
	if source.Tier != nil {
		tier := Sku_Tier_STATUS(*source.Tier)
		sku.Tier = &tier
	} else {
		sku.Tier = nil
	}

	// No error
	return nil
}

// AssignPropertiesToSku_STATUS populates the provided destination Sku_STATUS from our Sku_STATUS
func (sku *Sku_STATUS) AssignPropertiesToSku_STATUS(destination *v20180601s.Sku_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Capacity
	destination.Capacity = genruntime.ClonePointerToInt(sku.Capacity)

	// Family
	destination.Family = genruntime.ClonePointerToString(sku.Family)

	// Name
	destination.Name = genruntime.ClonePointerToString(sku.Name)

	// Size
	destination.Size = genruntime.ClonePointerToString(sku.Size)

	// Tier
	if sku.Tier != nil {
		tier := string(*sku.Tier)
		destination.Tier = &tier
	} else {
		destination.Tier = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type SslEnforcement_STATUS string

const (
	SslEnforcement_Disabled_STATUS = SslEnforcement_STATUS("Disabled")
	SslEnforcement_Enabled_STATUS  = SslEnforcement_STATUS("Enabled")
)

type StorageProfile_STATUS struct {
	// BackupRetentionDays: Backup retention days for the server.
	BackupRetentionDays *int `json:"backupRetentionDays,omitempty"`

	// GeoRedundantBackup: Enable Geo-redundant or not for server backup.
	GeoRedundantBackup *StorageProfile_GeoRedundantBackup_STATUS `json:"geoRedundantBackup,omitempty"`

	// StorageAutogrow: Enable Storage Auto Grow.
	StorageAutogrow *StorageProfile_StorageAutogrow_STATUS `json:"storageAutogrow,omitempty"`

	// StorageMB: Max storage allowed for a server.
	StorageMB *int `json:"storageMB,omitempty"`
}

var _ genruntime.FromARMConverter = &StorageProfile_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *StorageProfile_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StorageProfile_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *StorageProfile_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StorageProfile_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StorageProfile_STATUSARM, got %T", armInput)
	}

	// Set property ‘BackupRetentionDays’:
	if typedInput.BackupRetentionDays != nil {
		backupRetentionDays := *typedInput.BackupRetentionDays
		profile.BackupRetentionDays = &backupRetentionDays
	}

	// Set property ‘GeoRedundantBackup’:
	if typedInput.GeoRedundantBackup != nil {
		geoRedundantBackup := *typedInput.GeoRedundantBackup
		profile.GeoRedundantBackup = &geoRedundantBackup
	}

	// Set property ‘StorageAutogrow’:
	if typedInput.StorageAutogrow != nil {
		storageAutogrow := *typedInput.StorageAutogrow
		profile.StorageAutogrow = &storageAutogrow
	}

	// Set property ‘StorageMB’:
	if typedInput.StorageMB != nil {
		storageMB := *typedInput.StorageMB
		profile.StorageMB = &storageMB
	}

	// No error
	return nil
}

// AssignPropertiesFromStorageProfile_STATUS populates our StorageProfile_STATUS from the provided source StorageProfile_STATUS
func (profile *StorageProfile_STATUS) AssignPropertiesFromStorageProfile_STATUS(source *v20180601s.StorageProfile_STATUS) error {

	// BackupRetentionDays
	profile.BackupRetentionDays = genruntime.ClonePointerToInt(source.BackupRetentionDays)

	// GeoRedundantBackup
	if source.GeoRedundantBackup != nil {
		geoRedundantBackup := StorageProfile_GeoRedundantBackup_STATUS(*source.GeoRedundantBackup)
		profile.GeoRedundantBackup = &geoRedundantBackup
	} else {
		profile.GeoRedundantBackup = nil
	}

	// StorageAutogrow
	if source.StorageAutogrow != nil {
		storageAutogrow := StorageProfile_StorageAutogrow_STATUS(*source.StorageAutogrow)
		profile.StorageAutogrow = &storageAutogrow
	} else {
		profile.StorageAutogrow = nil
	}

	// StorageMB
	profile.StorageMB = genruntime.ClonePointerToInt(source.StorageMB)

	// No error
	return nil
}

// AssignPropertiesToStorageProfile_STATUS populates the provided destination StorageProfile_STATUS from our StorageProfile_STATUS
func (profile *StorageProfile_STATUS) AssignPropertiesToStorageProfile_STATUS(destination *v20180601s.StorageProfile_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupRetentionDays
	destination.BackupRetentionDays = genruntime.ClonePointerToInt(profile.BackupRetentionDays)

	// GeoRedundantBackup
	if profile.GeoRedundantBackup != nil {
		geoRedundantBackup := string(*profile.GeoRedundantBackup)
		destination.GeoRedundantBackup = &geoRedundantBackup
	} else {
		destination.GeoRedundantBackup = nil
	}

	// StorageAutogrow
	if profile.StorageAutogrow != nil {
		storageAutogrow := string(*profile.StorageAutogrow)
		destination.StorageAutogrow = &storageAutogrow
	} else {
		destination.StorageAutogrow = nil
	}

	// StorageMB
	destination.StorageMB = genruntime.ClonePointerToInt(profile.StorageMB)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerOperatorSecrets struct {
	// FullyQualifiedDomainName: indicates where the FullyQualifiedDomainName secret should be placed. If omitted, the secret
	// will not be retrieved from Azure.
	FullyQualifiedDomainName *genruntime.SecretDestination `json:"fullyQualifiedDomainName,omitempty"`
}

// AssignPropertiesFromServerOperatorSecrets populates our ServerOperatorSecrets from the provided source ServerOperatorSecrets
func (secrets *ServerOperatorSecrets) AssignPropertiesFromServerOperatorSecrets(source *v20180601s.ServerOperatorSecrets) error {

	// FullyQualifiedDomainName
	if source.FullyQualifiedDomainName != nil {
		fullyQualifiedDomainName := source.FullyQualifiedDomainName.Copy()
		secrets.FullyQualifiedDomainName = &fullyQualifiedDomainName
	} else {
		secrets.FullyQualifiedDomainName = nil
	}

	// No error
	return nil
}

// AssignPropertiesToServerOperatorSecrets populates the provided destination ServerOperatorSecrets from our ServerOperatorSecrets
func (secrets *ServerOperatorSecrets) AssignPropertiesToServerOperatorSecrets(destination *v20180601s.ServerOperatorSecrets) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// FullyQualifiedDomainName
	if secrets.FullyQualifiedDomainName != nil {
		fullyQualifiedDomainName := secrets.FullyQualifiedDomainName.Copy()
		destination.FullyQualifiedDomainName = &fullyQualifiedDomainName
	} else {
		destination.FullyQualifiedDomainName = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerPrivateEndpointConnectionProperties_STATUS struct {
	// PrivateEndpoint: Private endpoint which the connection belongs to.
	PrivateEndpoint *PrivateEndpointProperty_STATUS `json:"privateEndpoint,omitempty"`

	// PrivateLinkServiceConnectionState: Connection state of the private endpoint connection.
	PrivateLinkServiceConnectionState *ServerPrivateLinkServiceConnectionStateProperty_STATUS `json:"privateLinkServiceConnectionState,omitempty"`

	// ProvisioningState: State of the private endpoint connection.
	ProvisioningState *ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS `json:"provisioningState,omitempty"`
}

var _ genruntime.FromARMConverter = &ServerPrivateEndpointConnectionProperties_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (properties *ServerPrivateEndpointConnectionProperties_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServerPrivateEndpointConnectionProperties_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (properties *ServerPrivateEndpointConnectionProperties_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServerPrivateEndpointConnectionProperties_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServerPrivateEndpointConnectionProperties_STATUSARM, got %T", armInput)
	}

	// Set property ‘PrivateEndpoint’:
	if typedInput.PrivateEndpoint != nil {
		var privateEndpoint1 PrivateEndpointProperty_STATUS
		err := privateEndpoint1.PopulateFromARM(owner, *typedInput.PrivateEndpoint)
		if err != nil {
			return err
		}
		privateEndpoint := privateEndpoint1
		properties.PrivateEndpoint = &privateEndpoint
	}

	// Set property ‘PrivateLinkServiceConnectionState’:
	if typedInput.PrivateLinkServiceConnectionState != nil {
		var privateLinkServiceConnectionState1 ServerPrivateLinkServiceConnectionStateProperty_STATUS
		err := privateLinkServiceConnectionState1.PopulateFromARM(owner, *typedInput.PrivateLinkServiceConnectionState)
		if err != nil {
			return err
		}
		privateLinkServiceConnectionState := privateLinkServiceConnectionState1
		properties.PrivateLinkServiceConnectionState = &privateLinkServiceConnectionState
	}

	// Set property ‘ProvisioningState’:
	if typedInput.ProvisioningState != nil {
		provisioningState := *typedInput.ProvisioningState
		properties.ProvisioningState = &provisioningState
	}

	// No error
	return nil
}

// AssignPropertiesFromServerPrivateEndpointConnectionProperties_STATUS populates our ServerPrivateEndpointConnectionProperties_STATUS from the provided source ServerPrivateEndpointConnectionProperties_STATUS
func (properties *ServerPrivateEndpointConnectionProperties_STATUS) AssignPropertiesFromServerPrivateEndpointConnectionProperties_STATUS(source *v20180601s.ServerPrivateEndpointConnectionProperties_STATUS) error {

	// PrivateEndpoint
	if source.PrivateEndpoint != nil {
		var privateEndpoint PrivateEndpointProperty_STATUS
		err := privateEndpoint.AssignPropertiesFromPrivateEndpointProperty_STATUS(source.PrivateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPrivateEndpointProperty_STATUS() to populate field PrivateEndpoint")
		}
		properties.PrivateEndpoint = &privateEndpoint
	} else {
		properties.PrivateEndpoint = nil
	}

	// PrivateLinkServiceConnectionState
	if source.PrivateLinkServiceConnectionState != nil {
		var privateLinkServiceConnectionState ServerPrivateLinkServiceConnectionStateProperty_STATUS
		err := privateLinkServiceConnectionState.AssignPropertiesFromServerPrivateLinkServiceConnectionStateProperty_STATUS(source.PrivateLinkServiceConnectionState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromServerPrivateLinkServiceConnectionStateProperty_STATUS() to populate field PrivateLinkServiceConnectionState")
		}
		properties.PrivateLinkServiceConnectionState = &privateLinkServiceConnectionState
	} else {
		properties.PrivateLinkServiceConnectionState = nil
	}

	// ProvisioningState
	if source.ProvisioningState != nil {
		provisioningState := ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS(*source.ProvisioningState)
		properties.ProvisioningState = &provisioningState
	} else {
		properties.ProvisioningState = nil
	}

	// No error
	return nil
}

// AssignPropertiesToServerPrivateEndpointConnectionProperties_STATUS populates the provided destination ServerPrivateEndpointConnectionProperties_STATUS from our ServerPrivateEndpointConnectionProperties_STATUS
func (properties *ServerPrivateEndpointConnectionProperties_STATUS) AssignPropertiesToServerPrivateEndpointConnectionProperties_STATUS(destination *v20180601s.ServerPrivateEndpointConnectionProperties_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// PrivateEndpoint
	if properties.PrivateEndpoint != nil {
		var privateEndpoint v20180601s.PrivateEndpointProperty_STATUS
		err := properties.PrivateEndpoint.AssignPropertiesToPrivateEndpointProperty_STATUS(&privateEndpoint)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPrivateEndpointProperty_STATUS() to populate field PrivateEndpoint")
		}
		destination.PrivateEndpoint = &privateEndpoint
	} else {
		destination.PrivateEndpoint = nil
	}

	// PrivateLinkServiceConnectionState
	if properties.PrivateLinkServiceConnectionState != nil {
		var privateLinkServiceConnectionState v20180601s.ServerPrivateLinkServiceConnectionStateProperty_STATUS
		err := properties.PrivateLinkServiceConnectionState.AssignPropertiesToServerPrivateLinkServiceConnectionStateProperty_STATUS(&privateLinkServiceConnectionState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToServerPrivateLinkServiceConnectionStateProperty_STATUS() to populate field PrivateLinkServiceConnectionState")
		}
		destination.PrivateLinkServiceConnectionState = &privateLinkServiceConnectionState
	} else {
		destination.PrivateLinkServiceConnectionState = nil
	}

	// ProvisioningState
	if properties.ProvisioningState != nil {
		provisioningState := string(*properties.ProvisioningState)
		destination.ProvisioningState = &provisioningState
	} else {
		destination.ProvisioningState = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type StorageProfile struct {
	// BackupRetentionDays: Backup retention days for the server.
	BackupRetentionDays *int `json:"backupRetentionDays,omitempty"`

	// GeoRedundantBackup: Enable Geo-redundant or not for server backup.
	GeoRedundantBackup *StorageProfile_GeoRedundantBackup `json:"geoRedundantBackup,omitempty"`

	// StorageAutogrow: Enable Storage Auto Grow.
	StorageAutogrow *StorageProfile_StorageAutogrow `json:"storageAutogrow,omitempty"`

	// StorageMB: Max storage allowed for a server.
	StorageMB *int `json:"storageMB,omitempty"`
}

var _ genruntime.ARMTransformer = &StorageProfile{}

// ConvertToARM converts from a Kubernetes CRD object to an ARM object
func (profile *StorageProfile) ConvertToARM(resolved genruntime.ConvertToARMResolvedDetails) (interface{}, error) {
	if profile == nil {
		return nil, nil
	}
	result := &StorageProfileARM{}

	// Set property ‘BackupRetentionDays’:
	if profile.BackupRetentionDays != nil {
		backupRetentionDays := *profile.BackupRetentionDays
		result.BackupRetentionDays = &backupRetentionDays
	}

	// Set property ‘GeoRedundantBackup’:
	if profile.GeoRedundantBackup != nil {
		geoRedundantBackup := *profile.GeoRedundantBackup
		result.GeoRedundantBackup = &geoRedundantBackup
	}

	// Set property ‘StorageAutogrow’:
	if profile.StorageAutogrow != nil {
		storageAutogrow := *profile.StorageAutogrow
		result.StorageAutogrow = &storageAutogrow
	}

	// Set property ‘StorageMB’:
	if profile.StorageMB != nil {
		storageMB := *profile.StorageMB
		result.StorageMB = &storageMB
	}
	return result, nil
}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (profile *StorageProfile) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &StorageProfileARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (profile *StorageProfile) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(StorageProfileARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected StorageProfileARM, got %T", armInput)
	}

	// Set property ‘BackupRetentionDays’:
	if typedInput.BackupRetentionDays != nil {
		backupRetentionDays := *typedInput.BackupRetentionDays
		profile.BackupRetentionDays = &backupRetentionDays
	}

	// Set property ‘GeoRedundantBackup’:
	if typedInput.GeoRedundantBackup != nil {
		geoRedundantBackup := *typedInput.GeoRedundantBackup
		profile.GeoRedundantBackup = &geoRedundantBackup
	}

	// Set property ‘StorageAutogrow’:
	if typedInput.StorageAutogrow != nil {
		storageAutogrow := *typedInput.StorageAutogrow
		profile.StorageAutogrow = &storageAutogrow
	}

	// Set property ‘StorageMB’:
	if typedInput.StorageMB != nil {
		storageMB := *typedInput.StorageMB
		profile.StorageMB = &storageMB
	}

	// No error
	return nil
}

// AssignPropertiesFromStorageProfile populates our StorageProfile from the provided source StorageProfile
func (profile *StorageProfile) AssignPropertiesFromStorageProfile(source *v20180601s.StorageProfile) error {

	// BackupRetentionDays
	profile.BackupRetentionDays = genruntime.ClonePointerToInt(source.BackupRetentionDays)

	// GeoRedundantBackup
	if source.GeoRedundantBackup != nil {
		geoRedundantBackup := StorageProfile_GeoRedundantBackup(*source.GeoRedundantBackup)
		profile.GeoRedundantBackup = &geoRedundantBackup
	} else {
		profile.GeoRedundantBackup = nil
	}

	// StorageAutogrow
	if source.StorageAutogrow != nil {
		storageAutogrow := StorageProfile_StorageAutogrow(*source.StorageAutogrow)
		profile.StorageAutogrow = &storageAutogrow
	} else {
		profile.StorageAutogrow = nil
	}

	// StorageMB
	profile.StorageMB = genruntime.ClonePointerToInt(source.StorageMB)

	// No error
	return nil
}

// AssignPropertiesToStorageProfile populates the provided destination StorageProfile from our StorageProfile
func (profile *StorageProfile) AssignPropertiesToStorageProfile(destination *v20180601s.StorageProfile) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// BackupRetentionDays
	destination.BackupRetentionDays = genruntime.ClonePointerToInt(profile.BackupRetentionDays)

	// GeoRedundantBackup
	if profile.GeoRedundantBackup != nil {
		geoRedundantBackup := string(*profile.GeoRedundantBackup)
		destination.GeoRedundantBackup = &geoRedundantBackup
	} else {
		destination.GeoRedundantBackup = nil
	}

	// StorageAutogrow
	if profile.StorageAutogrow != nil {
		storageAutogrow := string(*profile.StorageAutogrow)
		destination.StorageAutogrow = &storageAutogrow
	} else {
		destination.StorageAutogrow = nil
	}

	// StorageMB
	destination.StorageMB = genruntime.ClonePointerToInt(profile.StorageMB)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type StorageProfile_GeoRedundantBackup_STATUS string

const (
	StorageProfile_GeoRedundantBackup_Disabled_STATUS = StorageProfile_GeoRedundantBackup_STATUS("Disabled")
	StorageProfile_GeoRedundantBackup_Enabled_STATUS  = StorageProfile_GeoRedundantBackup_STATUS("Enabled")
)

type StorageProfile_StorageAutogrow_STATUS string

const (
	StorageProfile_StorageAutogrow_Disabled_STATUS = StorageProfile_StorageAutogrow_STATUS("Disabled")
	StorageProfile_StorageAutogrow_Enabled_STATUS  = StorageProfile_StorageAutogrow_STATUS("Enabled")
)

type PrivateEndpointProperty_STATUS struct {
	// Id: Resource id of the private endpoint.
	Id *string `json:"id,omitempty"`
}

var _ genruntime.FromARMConverter = &PrivateEndpointProperty_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (property *PrivateEndpointProperty_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &PrivateEndpointProperty_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (property *PrivateEndpointProperty_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(PrivateEndpointProperty_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected PrivateEndpointProperty_STATUSARM, got %T", armInput)
	}

	// Set property ‘Id’:
	if typedInput.Id != nil {
		id := *typedInput.Id
		property.Id = &id
	}

	// No error
	return nil
}

// AssignPropertiesFromPrivateEndpointProperty_STATUS populates our PrivateEndpointProperty_STATUS from the provided source PrivateEndpointProperty_STATUS
func (property *PrivateEndpointProperty_STATUS) AssignPropertiesFromPrivateEndpointProperty_STATUS(source *v20180601s.PrivateEndpointProperty_STATUS) error {

	// Id
	property.Id = genruntime.ClonePointerToString(source.Id)

	// No error
	return nil
}

// AssignPropertiesToPrivateEndpointProperty_STATUS populates the provided destination PrivateEndpointProperty_STATUS from our PrivateEndpointProperty_STATUS
func (property *PrivateEndpointProperty_STATUS) AssignPropertiesToPrivateEndpointProperty_STATUS(destination *v20180601s.PrivateEndpointProperty_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// Id
	destination.Id = genruntime.ClonePointerToString(property.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS string

const (
	ServerPrivateEndpointConnectionProperties_ProvisioningState_Approving_STATUS = ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS("Approving")
	ServerPrivateEndpointConnectionProperties_ProvisioningState_Dropping_STATUS  = ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS("Dropping")
	ServerPrivateEndpointConnectionProperties_ProvisioningState_Failed_STATUS    = ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS("Failed")
	ServerPrivateEndpointConnectionProperties_ProvisioningState_Ready_STATUS     = ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS("Ready")
	ServerPrivateEndpointConnectionProperties_ProvisioningState_Rejecting_STATUS = ServerPrivateEndpointConnectionProperties_ProvisioningState_STATUS("Rejecting")
)

type ServerPrivateLinkServiceConnectionStateProperty_STATUS struct {
	// ActionsRequired: The actions required for private link service connection.
	ActionsRequired *ServerPrivateLinkServiceConnectionStateProperty_ActionsRequired_STATUS `json:"actionsRequired,omitempty"`

	// Description: The private link service connection description.
	Description *string `json:"description,omitempty"`

	// Status: The private link service connection status.
	Status *ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS `json:"status,omitempty"`
}

var _ genruntime.FromARMConverter = &ServerPrivateLinkServiceConnectionStateProperty_STATUS{}

// NewEmptyARMValue returns an empty ARM value suitable for deserializing into
func (property *ServerPrivateLinkServiceConnectionStateProperty_STATUS) NewEmptyARMValue() genruntime.ARMResourceStatus {
	return &ServerPrivateLinkServiceConnectionStateProperty_STATUSARM{}
}

// PopulateFromARM populates a Kubernetes CRD object from an Azure ARM object
func (property *ServerPrivateLinkServiceConnectionStateProperty_STATUS) PopulateFromARM(owner genruntime.ArbitraryOwnerReference, armInput interface{}) error {
	typedInput, ok := armInput.(ServerPrivateLinkServiceConnectionStateProperty_STATUSARM)
	if !ok {
		return fmt.Errorf("unexpected type supplied for PopulateFromARM() function. Expected ServerPrivateLinkServiceConnectionStateProperty_STATUSARM, got %T", armInput)
	}

	// Set property ‘ActionsRequired’:
	if typedInput.ActionsRequired != nil {
		actionsRequired := *typedInput.ActionsRequired
		property.ActionsRequired = &actionsRequired
	}

	// Set property ‘Description’:
	if typedInput.Description != nil {
		description := *typedInput.Description
		property.Description = &description
	}

	// Set property ‘Status’:
	if typedInput.Status != nil {
		status := *typedInput.Status
		property.Status = &status
	}

	// No error
	return nil
}

// AssignPropertiesFromServerPrivateLinkServiceConnectionStateProperty_STATUS populates our ServerPrivateLinkServiceConnectionStateProperty_STATUS from the provided source ServerPrivateLinkServiceConnectionStateProperty_STATUS
func (property *ServerPrivateLinkServiceConnectionStateProperty_STATUS) AssignPropertiesFromServerPrivateLinkServiceConnectionStateProperty_STATUS(source *v20180601s.ServerPrivateLinkServiceConnectionStateProperty_STATUS) error {

	// ActionsRequired
	if source.ActionsRequired != nil {
		actionsRequired := ServerPrivateLinkServiceConnectionStateProperty_ActionsRequired_STATUS(*source.ActionsRequired)
		property.ActionsRequired = &actionsRequired
	} else {
		property.ActionsRequired = nil
	}

	// Description
	property.Description = genruntime.ClonePointerToString(source.Description)

	// Status
	if source.Status != nil {
		status := ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS(*source.Status)
		property.Status = &status
	} else {
		property.Status = nil
	}

	// No error
	return nil
}

// AssignPropertiesToServerPrivateLinkServiceConnectionStateProperty_STATUS populates the provided destination ServerPrivateLinkServiceConnectionStateProperty_STATUS from our ServerPrivateLinkServiceConnectionStateProperty_STATUS
func (property *ServerPrivateLinkServiceConnectionStateProperty_STATUS) AssignPropertiesToServerPrivateLinkServiceConnectionStateProperty_STATUS(destination *v20180601s.ServerPrivateLinkServiceConnectionStateProperty_STATUS) error {
	// Create a new property bag
	propertyBag := genruntime.NewPropertyBag()

	// ActionsRequired
	if property.ActionsRequired != nil {
		actionsRequired := string(*property.ActionsRequired)
		destination.ActionsRequired = &actionsRequired
	} else {
		destination.ActionsRequired = nil
	}

	// Description
	destination.Description = genruntime.ClonePointerToString(property.Description)

	// Status
	if property.Status != nil {
		status := string(*property.Status)
		destination.Status = &status
	} else {
		destination.Status = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

type ServerPrivateLinkServiceConnectionStateProperty_ActionsRequired_STATUS string

const ServerPrivateLinkServiceConnectionStateProperty_ActionsRequired_None_STATUS = ServerPrivateLinkServiceConnectionStateProperty_ActionsRequired_STATUS("None")

type ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS string

const (
	ServerPrivateLinkServiceConnectionStateProperty_Status_Approved_STATUS     = ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS("Approved")
	ServerPrivateLinkServiceConnectionStateProperty_Status_Disconnected_STATUS = ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS("Disconnected")
	ServerPrivateLinkServiceConnectionStateProperty_Status_Pending_STATUS      = ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS("Pending")
	ServerPrivateLinkServiceConnectionStateProperty_Status_Rejected_STATUS     = ServerPrivateLinkServiceConnectionStateProperty_Status_STATUS("Rejected")
)

func init() {
	SchemeBuilder.Register(&Server{}, &ServerList{})
}
