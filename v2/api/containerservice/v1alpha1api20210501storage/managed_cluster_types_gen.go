// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210501storage

import (
	"fmt"
	v20210501s "github.com/Azure/azure-service-operator/v2/api/containerservice/v1beta20210501storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/pkg/errors"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"sigs.k8s.io/controller-runtime/pkg/conversion"
)

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1alpha1api20210501.ManagedCluster
// Deprecated version of ManagedCluster. Use v1beta20210501.ManagedCluster instead
type ManagedCluster struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ManagedCluster_Spec   `json:"spec,omitempty"`
	Status            ManagedCluster_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &ManagedCluster{}

// GetConditions returns the conditions of the resource
func (cluster *ManagedCluster) GetConditions() conditions.Conditions {
	return cluster.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (cluster *ManagedCluster) SetConditions(conditions conditions.Conditions) {
	cluster.Status.Conditions = conditions
}

var _ conversion.Convertible = &ManagedCluster{}

// ConvertFrom populates our ManagedCluster from the provided hub ManagedCluster
func (cluster *ManagedCluster) ConvertFrom(hub conversion.Hub) error {
	source, ok := hub.(*v20210501s.ManagedCluster)
	if !ok {
		return fmt.Errorf("expected containerservice/v1beta20210501storage/ManagedCluster but received %T instead", hub)
	}

	return cluster.AssignProperties_From_ManagedCluster(source)
}

// ConvertTo populates the provided hub ManagedCluster from our ManagedCluster
func (cluster *ManagedCluster) ConvertTo(hub conversion.Hub) error {
	destination, ok := hub.(*v20210501s.ManagedCluster)
	if !ok {
		return fmt.Errorf("expected containerservice/v1beta20210501storage/ManagedCluster but received %T instead", hub)
	}

	return cluster.AssignProperties_To_ManagedCluster(destination)
}

var _ genruntime.KubernetesResource = &ManagedCluster{}

// AzureName returns the Azure name of the resource
func (cluster *ManagedCluster) AzureName() string {
	return cluster.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2021-05-01"
func (cluster ManagedCluster) GetAPIVersion() string {
	return string(APIVersion_Value)
}

// GetResourceScope returns the scope of the resource
func (cluster *ManagedCluster) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (cluster *ManagedCluster) GetSpec() genruntime.ConvertibleSpec {
	return &cluster.Spec
}

// GetStatus returns the status of this resource
func (cluster *ManagedCluster) GetStatus() genruntime.ConvertibleStatus {
	return &cluster.Status
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.ContainerService/managedClusters"
func (cluster *ManagedCluster) GetType() string {
	return "Microsoft.ContainerService/managedClusters"
}

// NewEmptyStatus returns a new empty (blank) status
func (cluster *ManagedCluster) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &ManagedCluster_STATUS{}
}

// Owner returns the ResourceReference of the owner, or nil if there is no owner
func (cluster *ManagedCluster) Owner() *genruntime.ResourceReference {
	group, kind := genruntime.LookupOwnerGroupKind(cluster.Spec)
	return &genruntime.ResourceReference{
		Group: group,
		Kind:  kind,
		Name:  cluster.Spec.Owner.Name,
	}
}

// SetStatus sets the status of this resource
func (cluster *ManagedCluster) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*ManagedCluster_STATUS); ok {
		cluster.Status = *st
		return nil
	}

	// Convert status to required version
	var st ManagedCluster_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return errors.Wrap(err, "failed to convert status")
	}

	cluster.Status = st
	return nil
}

// AssignProperties_From_ManagedCluster populates our ManagedCluster from the provided source ManagedCluster
func (cluster *ManagedCluster) AssignProperties_From_ManagedCluster(source *v20210501s.ManagedCluster) error {

	// ObjectMeta
	cluster.ObjectMeta = *source.ObjectMeta.DeepCopy()

	// Spec
<<<<<<< HEAD
	var spec ManagedCluster_Spec
	err := spec.AssignPropertiesFromManagedCluster_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromManagedCluster_Spec() to populate field Spec")
=======
	var spec ManagedClusters_Spec
	err := spec.AssignProperties_From_ManagedClusters_Spec(&source.Spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ManagedClusters_Spec() to populate field Spec")
>>>>>>> main
	}
	cluster.Spec = spec

	// Status
	var status ManagedCluster_STATUS
<<<<<<< HEAD
	err = status.AssignPropertiesFromManagedCluster_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesFromManagedCluster_STATUS() to populate field Status")
=======
	err = status.AssignProperties_From_ManagedCluster_STATUS(&source.Status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_From_ManagedCluster_STATUS() to populate field Status")
>>>>>>> main
	}
	cluster.Status = status

	// No error
	return nil
}

// AssignProperties_To_ManagedCluster populates the provided destination ManagedCluster from our ManagedCluster
func (cluster *ManagedCluster) AssignProperties_To_ManagedCluster(destination *v20210501s.ManagedCluster) error {

	// ObjectMeta
	destination.ObjectMeta = *cluster.ObjectMeta.DeepCopy()

	// Spec
<<<<<<< HEAD
	var spec v20210501s.ManagedCluster_Spec
	err := cluster.Spec.AssignPropertiesToManagedCluster_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToManagedCluster_Spec() to populate field Spec")
=======
	var spec v20210501s.ManagedClusters_Spec
	err := cluster.Spec.AssignProperties_To_ManagedClusters_Spec(&spec)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ManagedClusters_Spec() to populate field Spec")
>>>>>>> main
	}
	destination.Spec = spec

	// Status
	var status v20210501s.ManagedCluster_STATUS
<<<<<<< HEAD
	err = cluster.Status.AssignPropertiesToManagedCluster_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignPropertiesToManagedCluster_STATUS() to populate field Status")
=======
	err = cluster.Status.AssignProperties_To_ManagedCluster_STATUS(&status)
	if err != nil {
		return errors.Wrap(err, "calling AssignProperties_To_ManagedCluster_STATUS() to populate field Status")
>>>>>>> main
	}
	destination.Status = status

	// No error
	return nil
}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (cluster *ManagedCluster) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: cluster.Spec.OriginalVersion,
		Kind:    "ManagedCluster",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1alpha1api20210501.ManagedCluster
// Deprecated version of ManagedCluster. Use v1beta20210501.ManagedCluster instead
type ManagedClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []ManagedCluster `json:"items"`
}

// Storage version of v1alpha1api20210501.APIVersion
// Deprecated version of APIVersion. Use v1beta20210501.APIVersion instead
// +kubebuilder:validation:Enum={"2021-05-01"}
type APIVersion string

const APIVersion_Value = APIVersion("2021-05-01")

// Storage version of v1alpha1api20210501.ManagedCluster_Spec
type ManagedCluster_Spec struct {
	AadProfile             *ManagedClusterAADProfile                   `json:"aadProfile,omitempty"`
	AddonProfiles          *v1.JSON                                    `json:"addonProfiles,omitempty"`
	AgentPoolProfiles      []ManagedClusterAgentPoolProfile            `json:"agentPoolProfiles,omitempty"`
	ApiServerAccessProfile *ManagedClusterAPIServerAccessProfile       `json:"apiServerAccessProfile,omitempty"`
	AutoScalerProfile      *ManagedClusterProperties_AutoScalerProfile `json:"autoScalerProfile,omitempty"`
	AutoUpgradeProfile     *ManagedClusterAutoUpgradeProfile           `json:"autoUpgradeProfile,omitempty"`

	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName                    string                          `json:"azureName,omitempty"`
	DisableLocalAccounts         *bool                           `json:"disableLocalAccounts,omitempty"`
	DiskEncryptionSetIDReference *genruntime.ResourceReference   `armReference:"DiskEncryptionSetID" json:"diskEncryptionSetIDReference,omitempty"`
	DnsPrefix                    *string                         `json:"dnsPrefix,omitempty"`
	EnablePodSecurityPolicy      *bool                           `json:"enablePodSecurityPolicy,omitempty"`
	EnableRBAC                   *bool                           `json:"enableRBAC,omitempty"`
	ExtendedLocation             *ExtendedLocation               `json:"extendedLocation,omitempty"`
	FqdnSubdomain                *string                         `json:"fqdnSubdomain,omitempty"`
	HttpProxyConfig              *ManagedClusterHTTPProxyConfig  `json:"httpProxyConfig,omitempty"`
	Identity                     *ManagedClusterIdentity         `json:"identity,omitempty"`
	IdentityProfile              *v1.JSON                        `json:"identityProfile,omitempty"`
	KubernetesVersion            *string                         `json:"kubernetesVersion,omitempty"`
	LinuxProfile                 *ContainerServiceLinuxProfile   `json:"linuxProfile,omitempty"`
	Location                     *string                         `json:"location,omitempty"`
	NetworkProfile               *ContainerServiceNetworkProfile `json:"networkProfile,omitempty"`
	NodeResourceGroup            *string                         `json:"nodeResourceGroup,omitempty"`
	OperatorSpec                 *ManagedClusterOperatorSpec     `json:"operatorSpec,omitempty"`
	OriginalVersion              string                          `json:"originalVersion,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner                   *genruntime.KnownResourceReference     `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	PodIdentityProfile      *ManagedClusterPodIdentityProfile      `json:"podIdentityProfile,omitempty"`
	PrivateLinkResources    []PrivateLinkResource                  `json:"privateLinkResources,omitempty"`
	PropertyBag             genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	ServicePrincipalProfile *ManagedClusterServicePrincipalProfile `json:"servicePrincipalProfile,omitempty"`
	Sku                     *ManagedClusterSKU                     `json:"sku,omitempty"`
	Tags                    map[string]string                      `json:"tags,omitempty"`
	WindowsProfile          *ManagedClusterWindowsProfile          `json:"windowsProfile,omitempty"`
}

var _ genruntime.ConvertibleSpec = &ManagedCluster_Spec{}

// ConvertSpecFrom populates our ManagedCluster_Spec from the provided source
func (cluster *ManagedCluster_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20210501s.ManagedCluster_Spec)
	if ok {
		// Populate our instance from source
		return cluster.AssignPropertiesFromManagedCluster_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20210501s.ManagedCluster_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = cluster.AssignPropertiesFromManagedCluster_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ManagedCluster_Spec
func (cluster *ManagedCluster_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20210501s.ManagedCluster_Spec)
	if ok {
		// Populate destination from our instance
		return cluster.AssignPropertiesToManagedCluster_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20210501s.ManagedCluster_Spec{}
	err := cluster.AssignPropertiesToManagedCluster_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignPropertiesFromManagedCluster_Spec populates our ManagedCluster_Spec from the provided source ManagedCluster_Spec
func (cluster *ManagedCluster_Spec) AssignPropertiesFromManagedCluster_Spec(source *v20210501s.ManagedCluster_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AadProfile
	if source.AadProfile != nil {
		var aadProfile ManagedClusterAADProfile
		err := aadProfile.AssignPropertiesFromManagedClusterAADProfile(source.AadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAADProfile() to populate field AadProfile")
		}
		cluster.AadProfile = &aadProfile
	} else {
		cluster.AadProfile = nil
	}

	// AddonProfiles
	if source.AddonProfiles != nil {
		addonProfile := *source.AddonProfiles.DeepCopy()
		cluster.AddonProfiles = &addonProfile
	} else {
		cluster.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if source.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]ManagedClusterAgentPoolProfile, len(source.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range source.AgentPoolProfiles {
			// Shadow the loop variable to avoid aliasing
			agentPoolProfileItem := agentPoolProfileItem
			var agentPoolProfile ManagedClusterAgentPoolProfile
			err := agentPoolProfile.AssignPropertiesFromManagedClusterAgentPoolProfile(&agentPoolProfileItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAgentPoolProfile() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		cluster.AgentPoolProfiles = agentPoolProfileList
	} else {
		cluster.AgentPoolProfiles = nil
	}

	// ApiServerAccessProfile
	if source.ApiServerAccessProfile != nil {
		var apiServerAccessProfile ManagedClusterAPIServerAccessProfile
		err := apiServerAccessProfile.AssignPropertiesFromManagedClusterAPIServerAccessProfile(source.ApiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAPIServerAccessProfile() to populate field ApiServerAccessProfile")
		}
		cluster.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		cluster.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if source.AutoScalerProfile != nil {
		var autoScalerProfile ManagedClusterProperties_AutoScalerProfile
		err := autoScalerProfile.AssignPropertiesFromManagedClusterProperties_AutoScalerProfile(source.AutoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterProperties_AutoScalerProfile() to populate field AutoScalerProfile")
		}
		cluster.AutoScalerProfile = &autoScalerProfile
	} else {
		cluster.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if source.AutoUpgradeProfile != nil {
		var autoUpgradeProfile ManagedClusterAutoUpgradeProfile
		err := autoUpgradeProfile.AssignPropertiesFromManagedClusterAutoUpgradeProfile(source.AutoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAutoUpgradeProfile() to populate field AutoUpgradeProfile")
		}
		cluster.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		cluster.AutoUpgradeProfile = nil
	}

	// AzureName
	cluster.AzureName = source.AzureName

	// DisableLocalAccounts
	if source.DisableLocalAccounts != nil {
		disableLocalAccount := *source.DisableLocalAccounts
		cluster.DisableLocalAccounts = &disableLocalAccount
	} else {
		cluster.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetIDReference
	if source.DiskEncryptionSetIDReference != nil {
		diskEncryptionSetIDReference := source.DiskEncryptionSetIDReference.Copy()
		cluster.DiskEncryptionSetIDReference = &diskEncryptionSetIDReference
	} else {
		cluster.DiskEncryptionSetIDReference = nil
	}

	// DnsPrefix
	cluster.DnsPrefix = genruntime.ClonePointerToString(source.DnsPrefix)

	// EnablePodSecurityPolicy
	if source.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *source.EnablePodSecurityPolicy
		cluster.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		cluster.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if source.EnableRBAC != nil {
		enableRBAC := *source.EnableRBAC
		cluster.EnableRBAC = &enableRBAC
	} else {
		cluster.EnableRBAC = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignPropertiesFromExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation() to populate field ExtendedLocation")
		}
		cluster.ExtendedLocation = &extendedLocation
	} else {
		cluster.ExtendedLocation = nil
	}

	// FqdnSubdomain
	cluster.FqdnSubdomain = genruntime.ClonePointerToString(source.FqdnSubdomain)

	// HttpProxyConfig
	if source.HttpProxyConfig != nil {
		var httpProxyConfig ManagedClusterHTTPProxyConfig
		err := httpProxyConfig.AssignPropertiesFromManagedClusterHTTPProxyConfig(source.HttpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterHTTPProxyConfig() to populate field HttpProxyConfig")
		}
		cluster.HttpProxyConfig = &httpProxyConfig
	} else {
		cluster.HttpProxyConfig = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedClusterIdentity
		err := identity.AssignPropertiesFromManagedClusterIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterIdentity() to populate field Identity")
		}
		cluster.Identity = &identity
	} else {
		cluster.Identity = nil
	}

	// IdentityProfile
	if source.IdentityProfile != nil {
		identityProfile := *source.IdentityProfile.DeepCopy()
		cluster.IdentityProfile = &identityProfile
	} else {
		cluster.IdentityProfile = nil
	}

	// KubernetesVersion
	cluster.KubernetesVersion = genruntime.ClonePointerToString(source.KubernetesVersion)

	// LinuxProfile
	if source.LinuxProfile != nil {
		var linuxProfile ContainerServiceLinuxProfile
		err := linuxProfile.AssignPropertiesFromContainerServiceLinuxProfile(source.LinuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerServiceLinuxProfile() to populate field LinuxProfile")
		}
		cluster.LinuxProfile = &linuxProfile
	} else {
		cluster.LinuxProfile = nil
	}

	// Location
	cluster.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile ContainerServiceNetworkProfile
		err := networkProfile.AssignPropertiesFromContainerServiceNetworkProfile(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerServiceNetworkProfile() to populate field NetworkProfile")
		}
		cluster.NetworkProfile = &networkProfile
	} else {
		cluster.NetworkProfile = nil
	}

	// NodeResourceGroup
	cluster.NodeResourceGroup = genruntime.ClonePointerToString(source.NodeResourceGroup)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec ManagedClusterOperatorSpec
		err := operatorSpec.AssignPropertiesFromManagedClusterOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterOperatorSpec() to populate field OperatorSpec")
		}
		cluster.OperatorSpec = &operatorSpec
	} else {
		cluster.OperatorSpec = nil
	}

	// OriginalVersion
	cluster.OriginalVersion = source.OriginalVersion

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		cluster.Owner = &owner
	} else {
		cluster.Owner = nil
	}

	// PodIdentityProfile
	if source.PodIdentityProfile != nil {
		var podIdentityProfile ManagedClusterPodIdentityProfile
		err := podIdentityProfile.AssignPropertiesFromManagedClusterPodIdentityProfile(source.PodIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentityProfile() to populate field PodIdentityProfile")
		}
		cluster.PodIdentityProfile = &podIdentityProfile
	} else {
		cluster.PodIdentityProfile = nil
	}

	// PrivateLinkResources
	if source.PrivateLinkResources != nil {
		privateLinkResourceList := make([]PrivateLinkResource, len(source.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range source.PrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			privateLinkResourceItem := privateLinkResourceItem
			var privateLinkResource PrivateLinkResource
			err := privateLinkResource.AssignPropertiesFromPrivateLinkResource(&privateLinkResourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromPrivateLinkResource() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		cluster.PrivateLinkResources = privateLinkResourceList
	} else {
		cluster.PrivateLinkResources = nil
	}

	// ServicePrincipalProfile
	if source.ServicePrincipalProfile != nil {
		var servicePrincipalProfile ManagedClusterServicePrincipalProfile
		err := servicePrincipalProfile.AssignPropertiesFromManagedClusterServicePrincipalProfile(source.ServicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterServicePrincipalProfile() to populate field ServicePrincipalProfile")
		}
		cluster.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		cluster.ServicePrincipalProfile = nil
	}

	// Sku
	if source.Sku != nil {
		var sku ManagedClusterSKU
		err := sku.AssignPropertiesFromManagedClusterSKU(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterSKU() to populate field Sku")
		}
		cluster.Sku = &sku
	} else {
		cluster.Sku = nil
	}

	// Tags
	cluster.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// WindowsProfile
	if source.WindowsProfile != nil {
		var windowsProfile ManagedClusterWindowsProfile
		err := windowsProfile.AssignPropertiesFromManagedClusterWindowsProfile(source.WindowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterWindowsProfile() to populate field WindowsProfile")
		}
		cluster.WindowsProfile = &windowsProfile
	} else {
		cluster.WindowsProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		cluster.PropertyBag = propertyBag
	} else {
		cluster.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedCluster_Spec populates the provided destination ManagedCluster_Spec from our ManagedCluster_Spec
func (cluster *ManagedCluster_Spec) AssignPropertiesToManagedCluster_Spec(destination *v20210501s.ManagedCluster_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(cluster.PropertyBag)

	// AadProfile
	if cluster.AadProfile != nil {
		var aadProfile v20210501s.ManagedClusterAADProfile
		err := cluster.AadProfile.AssignPropertiesToManagedClusterAADProfile(&aadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAADProfile() to populate field AadProfile")
		}
		destination.AadProfile = &aadProfile
	} else {
		destination.AadProfile = nil
	}

	// AddonProfiles
	if cluster.AddonProfiles != nil {
		addonProfile := *cluster.AddonProfiles.DeepCopy()
		destination.AddonProfiles = &addonProfile
	} else {
		destination.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if cluster.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]v20210501s.ManagedClusterAgentPoolProfile, len(cluster.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range cluster.AgentPoolProfiles {
			// Shadow the loop variable to avoid aliasing
			agentPoolProfileItem := agentPoolProfileItem
			var agentPoolProfile v20210501s.ManagedClusterAgentPoolProfile
			err := agentPoolProfileItem.AssignPropertiesToManagedClusterAgentPoolProfile(&agentPoolProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAgentPoolProfile() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		destination.AgentPoolProfiles = agentPoolProfileList
	} else {
		destination.AgentPoolProfiles = nil
	}

	// ApiServerAccessProfile
	if cluster.ApiServerAccessProfile != nil {
		var apiServerAccessProfile v20210501s.ManagedClusterAPIServerAccessProfile
		err := cluster.ApiServerAccessProfile.AssignPropertiesToManagedClusterAPIServerAccessProfile(&apiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAPIServerAccessProfile() to populate field ApiServerAccessProfile")
		}
		destination.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		destination.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if cluster.AutoScalerProfile != nil {
		var autoScalerProfile v20210501s.ManagedClusterProperties_AutoScalerProfile
		err := cluster.AutoScalerProfile.AssignPropertiesToManagedClusterProperties_AutoScalerProfile(&autoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterProperties_AutoScalerProfile() to populate field AutoScalerProfile")
		}
		destination.AutoScalerProfile = &autoScalerProfile
	} else {
		destination.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if cluster.AutoUpgradeProfile != nil {
		var autoUpgradeProfile v20210501s.ManagedClusterAutoUpgradeProfile
		err := cluster.AutoUpgradeProfile.AssignPropertiesToManagedClusterAutoUpgradeProfile(&autoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAutoUpgradeProfile() to populate field AutoUpgradeProfile")
		}
		destination.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		destination.AutoUpgradeProfile = nil
	}

	// AzureName
	destination.AzureName = cluster.AzureName

	// DisableLocalAccounts
	if cluster.DisableLocalAccounts != nil {
		disableLocalAccount := *cluster.DisableLocalAccounts
		destination.DisableLocalAccounts = &disableLocalAccount
	} else {
		destination.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetIDReference
	if cluster.DiskEncryptionSetIDReference != nil {
		diskEncryptionSetIDReference := cluster.DiskEncryptionSetIDReference.Copy()
		destination.DiskEncryptionSetIDReference = &diskEncryptionSetIDReference
	} else {
		destination.DiskEncryptionSetIDReference = nil
	}

	// DnsPrefix
	destination.DnsPrefix = genruntime.ClonePointerToString(cluster.DnsPrefix)

	// EnablePodSecurityPolicy
	if cluster.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *cluster.EnablePodSecurityPolicy
		destination.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		destination.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if cluster.EnableRBAC != nil {
		enableRBAC := *cluster.EnableRBAC
		destination.EnableRBAC = &enableRBAC
	} else {
		destination.EnableRBAC = nil
	}

	// ExtendedLocation
	if cluster.ExtendedLocation != nil {
		var extendedLocation v20210501s.ExtendedLocation
		err := cluster.ExtendedLocation.AssignPropertiesToExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FqdnSubdomain
	destination.FqdnSubdomain = genruntime.ClonePointerToString(cluster.FqdnSubdomain)

	// HttpProxyConfig
	if cluster.HttpProxyConfig != nil {
		var httpProxyConfig v20210501s.ManagedClusterHTTPProxyConfig
		err := cluster.HttpProxyConfig.AssignPropertiesToManagedClusterHTTPProxyConfig(&httpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterHTTPProxyConfig() to populate field HttpProxyConfig")
		}
		destination.HttpProxyConfig = &httpProxyConfig
	} else {
		destination.HttpProxyConfig = nil
	}

	// Identity
	if cluster.Identity != nil {
		var identity v20210501s.ManagedClusterIdentity
		err := cluster.Identity.AssignPropertiesToManagedClusterIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IdentityProfile
	if cluster.IdentityProfile != nil {
		identityProfile := *cluster.IdentityProfile.DeepCopy()
		destination.IdentityProfile = &identityProfile
	} else {
		destination.IdentityProfile = nil
	}

	// KubernetesVersion
	destination.KubernetesVersion = genruntime.ClonePointerToString(cluster.KubernetesVersion)

	// LinuxProfile
	if cluster.LinuxProfile != nil {
		var linuxProfile v20210501s.ContainerServiceLinuxProfile
		err := cluster.LinuxProfile.AssignPropertiesToContainerServiceLinuxProfile(&linuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerServiceLinuxProfile() to populate field LinuxProfile")
		}
		destination.LinuxProfile = &linuxProfile
	} else {
		destination.LinuxProfile = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(cluster.Location)

	// NetworkProfile
	if cluster.NetworkProfile != nil {
		var networkProfile v20210501s.ContainerServiceNetworkProfile
		err := cluster.NetworkProfile.AssignPropertiesToContainerServiceNetworkProfile(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerServiceNetworkProfile() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// NodeResourceGroup
	destination.NodeResourceGroup = genruntime.ClonePointerToString(cluster.NodeResourceGroup)

	// OperatorSpec
	if cluster.OperatorSpec != nil {
		var operatorSpec v20210501s.ManagedClusterOperatorSpec
		err := cluster.OperatorSpec.AssignPropertiesToManagedClusterOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = cluster.OriginalVersion

	// Owner
	if cluster.Owner != nil {
		owner := cluster.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PodIdentityProfile
	if cluster.PodIdentityProfile != nil {
		var podIdentityProfile v20210501s.ManagedClusterPodIdentityProfile
		err := cluster.PodIdentityProfile.AssignPropertiesToManagedClusterPodIdentityProfile(&podIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentityProfile() to populate field PodIdentityProfile")
		}
		destination.PodIdentityProfile = &podIdentityProfile
	} else {
		destination.PodIdentityProfile = nil
	}

	// PrivateLinkResources
	if cluster.PrivateLinkResources != nil {
		privateLinkResourceList := make([]v20210501s.PrivateLinkResource, len(cluster.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range cluster.PrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			privateLinkResourceItem := privateLinkResourceItem
			var privateLinkResource v20210501s.PrivateLinkResource
			err := privateLinkResourceItem.AssignPropertiesToPrivateLinkResource(&privateLinkResource)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToPrivateLinkResource() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		destination.PrivateLinkResources = privateLinkResourceList
	} else {
		destination.PrivateLinkResources = nil
	}

	// ServicePrincipalProfile
	if cluster.ServicePrincipalProfile != nil {
		var servicePrincipalProfile v20210501s.ManagedClusterServicePrincipalProfile
		err := cluster.ServicePrincipalProfile.AssignPropertiesToManagedClusterServicePrincipalProfile(&servicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterServicePrincipalProfile() to populate field ServicePrincipalProfile")
		}
		destination.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		destination.ServicePrincipalProfile = nil
	}

	// Sku
	if cluster.Sku != nil {
		var sku v20210501s.ManagedClusterSKU
		err := cluster.Sku.AssignPropertiesToManagedClusterSKU(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterSKU() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(cluster.Tags)

	// WindowsProfile
	if cluster.WindowsProfile != nil {
		var windowsProfile v20210501s.ManagedClusterWindowsProfile
		err := cluster.WindowsProfile.AssignPropertiesToManagedClusterWindowsProfile(&windowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterWindowsProfile() to populate field WindowsProfile")
		}
		destination.WindowsProfile = &windowsProfile
	} else {
		destination.WindowsProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedCluster_STATUS
// Deprecated version of ManagedCluster_STATUS. Use v1beta20210501.ManagedCluster_STATUS instead
type ManagedCluster_STATUS struct {
	AadProfile              *ManagedClusterAADProfile_STATUS                   `json:"aadProfile,omitempty"`
	AddonProfiles           *v1.JSON                                           `json:"addonProfiles,omitempty"`
	AgentPoolProfiles       []ManagedClusterAgentPoolProfile_STATUS            `json:"agentPoolProfiles,omitempty"`
	ApiServerAccessProfile  *ManagedClusterAPIServerAccessProfile_STATUS       `json:"apiServerAccessProfile,omitempty"`
	AutoScalerProfile       *ManagedClusterProperties_AutoScalerProfile_STATUS `json:"autoScalerProfile,omitempty"`
	AutoUpgradeProfile      *ManagedClusterAutoUpgradeProfile_STATUS           `json:"autoUpgradeProfile,omitempty"`
	AzurePortalFQDN         *string                                            `json:"azurePortalFQDN,omitempty"`
	Conditions              []conditions.Condition                             `json:"conditions,omitempty"`
	DisableLocalAccounts    *bool                                              `json:"disableLocalAccounts,omitempty"`
	DiskEncryptionSetID     *string                                            `json:"diskEncryptionSetID,omitempty"`
	DnsPrefix               *string                                            `json:"dnsPrefix,omitempty"`
	EnablePodSecurityPolicy *bool                                              `json:"enablePodSecurityPolicy,omitempty"`
	EnableRBAC              *bool                                              `json:"enableRBAC,omitempty"`
	ExtendedLocation        *ExtendedLocation_STATUS                           `json:"extendedLocation,omitempty"`
	Fqdn                    *string                                            `json:"fqdn,omitempty"`
	FqdnSubdomain           *string                                            `json:"fqdnSubdomain,omitempty"`
	HttpProxyConfig         *ManagedClusterHTTPProxyConfig_STATUS              `json:"httpProxyConfig,omitempty"`
	Id                      *string                                            `json:"id,omitempty"`
	Identity                *ManagedClusterIdentity_STATUS                     `json:"identity,omitempty"`
	IdentityProfile         *v1.JSON                                           `json:"identityProfile,omitempty"`
	KubernetesVersion       *string                                            `json:"kubernetesVersion,omitempty"`
	LinuxProfile            *ContainerServiceLinuxProfile_STATUS               `json:"linuxProfile,omitempty"`
	Location                *string                                            `json:"location,omitempty"`
	MaxAgentPools           *int                                               `json:"maxAgentPools,omitempty"`
	Name                    *string                                            `json:"name,omitempty"`
	NetworkProfile          *ContainerServiceNetworkProfile_STATUS             `json:"networkProfile,omitempty"`
	NodeResourceGroup       *string                                            `json:"nodeResourceGroup,omitempty"`
	PodIdentityProfile      *ManagedClusterPodIdentityProfile_STATUS           `json:"podIdentityProfile,omitempty"`
	PowerState              *PowerState_STATUS                                 `json:"powerState,omitempty"`
	PrivateFQDN             *string                                            `json:"privateFQDN,omitempty"`
	PrivateLinkResources    []PrivateLinkResource_STATUS                       `json:"privateLinkResources,omitempty"`
	PropertyBag             genruntime.PropertyBag                             `json:"$propertyBag,omitempty"`
	ProvisioningState       *string                                            `json:"provisioningState,omitempty"`
	ServicePrincipalProfile *ManagedClusterServicePrincipalProfile_STATUS      `json:"servicePrincipalProfile,omitempty"`
	Sku                     *ManagedClusterSKU_STATUS                          `json:"sku,omitempty"`
	Tags                    map[string]string                                  `json:"tags,omitempty"`
	Type                    *string                                            `json:"type,omitempty"`
	WindowsProfile          *ManagedClusterWindowsProfile_STATUS               `json:"windowsProfile,omitempty"`
}

var _ genruntime.ConvertibleStatus = &ManagedCluster_STATUS{}

// ConvertStatusFrom populates our ManagedCluster_STATUS from the provided source
func (cluster *ManagedCluster_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	src, ok := source.(*v20210501s.ManagedCluster_STATUS)
	if ok {
		// Populate our instance from source
<<<<<<< HEAD
		return cluster.AssignPropertiesFromManagedCluster_STATUS(src)
=======
		return cluster.AssignProperties_From_ManagedCluster_STATUS(src)
>>>>>>> main
	}

	// Convert to an intermediate form
	src = &v20210501s.ManagedCluster_STATUS{}
	err := src.ConvertStatusFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusFrom()")
	}

	// Update our instance from src
<<<<<<< HEAD
	err = cluster.AssignPropertiesFromManagedCluster_STATUS(src)
=======
	err = cluster.AssignProperties_From_ManagedCluster_STATUS(src)
>>>>>>> main
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusFrom()")
	}

	return nil
}

// ConvertStatusTo populates the provided destination from our ManagedCluster_STATUS
func (cluster *ManagedCluster_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	dst, ok := destination.(*v20210501s.ManagedCluster_STATUS)
	if ok {
		// Populate destination from our instance
<<<<<<< HEAD
		return cluster.AssignPropertiesToManagedCluster_STATUS(dst)
=======
		return cluster.AssignProperties_To_ManagedCluster_STATUS(dst)
>>>>>>> main
	}

	// Convert to an intermediate form
	dst = &v20210501s.ManagedCluster_STATUS{}
<<<<<<< HEAD
	err := cluster.AssignPropertiesToManagedCluster_STATUS(dst)
=======
	err := cluster.AssignProperties_To_ManagedCluster_STATUS(dst)
>>>>>>> main
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertStatusTo()")
	}

	// Update dst from our instance
	err = dst.ConvertStatusTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertStatusTo()")
	}

	return nil
}

<<<<<<< HEAD
// AssignPropertiesFromManagedCluster_STATUS populates our ManagedCluster_STATUS from the provided source ManagedCluster_STATUS
func (cluster *ManagedCluster_STATUS) AssignPropertiesFromManagedCluster_STATUS(source *v20210501s.ManagedCluster_STATUS) error {
=======
// AssignProperties_From_ManagedCluster_STATUS populates our ManagedCluster_STATUS from the provided source ManagedCluster_STATUS
func (cluster *ManagedCluster_STATUS) AssignProperties_From_ManagedCluster_STATUS(source *v20210501s.ManagedCluster_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AadProfile
	if source.AadProfile != nil {
		var aadProfile ManagedClusterAADProfile_STATUS
<<<<<<< HEAD
		err := aadProfile.AssignPropertiesFromManagedClusterAADProfile_STATUS(source.AadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAADProfile_STATUS() to populate field AadProfile")
=======
		err := aadProfile.AssignProperties_From_ManagedClusterAADProfile_STATUS(source.AadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAADProfile_STATUS() to populate field AadProfile")
>>>>>>> main
		}
		cluster.AadProfile = &aadProfile
	} else {
		cluster.AadProfile = nil
	}

	// AddonProfiles
	if source.AddonProfiles != nil {
		addonProfile := *source.AddonProfiles.DeepCopy()
		cluster.AddonProfiles = &addonProfile
	} else {
		cluster.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if source.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]ManagedClusterAgentPoolProfile_STATUS, len(source.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range source.AgentPoolProfiles {
			// Shadow the loop variable to avoid aliasing
			agentPoolProfileItem := agentPoolProfileItem
			var agentPoolProfile ManagedClusterAgentPoolProfile_STATUS
<<<<<<< HEAD
			err := agentPoolProfile.AssignPropertiesFromManagedClusterAgentPoolProfile_STATUS(&agentPoolProfileItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAgentPoolProfile_STATUS() to populate field AgentPoolProfiles")
=======
			err := agentPoolProfile.AssignProperties_From_ManagedClusterAgentPoolProfile_STATUS(&agentPoolProfileItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAgentPoolProfile_STATUS() to populate field AgentPoolProfiles")
>>>>>>> main
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		cluster.AgentPoolProfiles = agentPoolProfileList
	} else {
		cluster.AgentPoolProfiles = nil
	}

	// ApiServerAccessProfile
	if source.ApiServerAccessProfile != nil {
		var apiServerAccessProfile ManagedClusterAPIServerAccessProfile_STATUS
<<<<<<< HEAD
		err := apiServerAccessProfile.AssignPropertiesFromManagedClusterAPIServerAccessProfile_STATUS(source.ApiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAPIServerAccessProfile_STATUS() to populate field ApiServerAccessProfile")
=======
		err := apiServerAccessProfile.AssignProperties_From_ManagedClusterAPIServerAccessProfile_STATUS(source.ApiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAPIServerAccessProfile_STATUS() to populate field ApiServerAccessProfile")
>>>>>>> main
		}
		cluster.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		cluster.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if source.AutoScalerProfile != nil {
<<<<<<< HEAD
		var autoScalerProfile ManagedClusterProperties_AutoScalerProfile_STATUS
		err := autoScalerProfile.AssignPropertiesFromManagedClusterProperties_AutoScalerProfile_STATUS(source.AutoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterProperties_AutoScalerProfile_STATUS() to populate field AutoScalerProfile")
=======
		var autoScalerProfile ManagedClusterProperties_STATUS_AutoScalerProfile
		err := autoScalerProfile.AssignProperties_From_ManagedClusterProperties_STATUS_AutoScalerProfile(source.AutoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterProperties_STATUS_AutoScalerProfile() to populate field AutoScalerProfile")
>>>>>>> main
		}
		cluster.AutoScalerProfile = &autoScalerProfile
	} else {
		cluster.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if source.AutoUpgradeProfile != nil {
		var autoUpgradeProfile ManagedClusterAutoUpgradeProfile_STATUS
<<<<<<< HEAD
		err := autoUpgradeProfile.AssignPropertiesFromManagedClusterAutoUpgradeProfile_STATUS(source.AutoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterAutoUpgradeProfile_STATUS() to populate field AutoUpgradeProfile")
=======
		err := autoUpgradeProfile.AssignProperties_From_ManagedClusterAutoUpgradeProfile_STATUS(source.AutoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAutoUpgradeProfile_STATUS() to populate field AutoUpgradeProfile")
>>>>>>> main
		}
		cluster.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		cluster.AutoUpgradeProfile = nil
	}

	// AzurePortalFQDN
	cluster.AzurePortalFQDN = genruntime.ClonePointerToString(source.AzurePortalFQDN)

	// Conditions
	cluster.Conditions = genruntime.CloneSliceOfCondition(source.Conditions)

	// DisableLocalAccounts
	if source.DisableLocalAccounts != nil {
		disableLocalAccount := *source.DisableLocalAccounts
		cluster.DisableLocalAccounts = &disableLocalAccount
	} else {
		cluster.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetID
	cluster.DiskEncryptionSetID = genruntime.ClonePointerToString(source.DiskEncryptionSetID)

	// DnsPrefix
	cluster.DnsPrefix = genruntime.ClonePointerToString(source.DnsPrefix)

	// EnablePodSecurityPolicy
	if source.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *source.EnablePodSecurityPolicy
		cluster.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		cluster.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if source.EnableRBAC != nil {
		enableRBAC := *source.EnableRBAC
		cluster.EnableRBAC = &enableRBAC
	} else {
		cluster.EnableRBAC = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation_STATUS
<<<<<<< HEAD
		err := extendedLocation.AssignPropertiesFromExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromExtendedLocation_STATUS() to populate field ExtendedLocation")
=======
		err := extendedLocation.AssignProperties_From_ExtendedLocation_STATUS(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation_STATUS() to populate field ExtendedLocation")
>>>>>>> main
		}
		cluster.ExtendedLocation = &extendedLocation
	} else {
		cluster.ExtendedLocation = nil
	}

	// Fqdn
	cluster.Fqdn = genruntime.ClonePointerToString(source.Fqdn)

	// FqdnSubdomain
	cluster.FqdnSubdomain = genruntime.ClonePointerToString(source.FqdnSubdomain)

	// HttpProxyConfig
	if source.HttpProxyConfig != nil {
		var httpProxyConfig ManagedClusterHTTPProxyConfig_STATUS
<<<<<<< HEAD
		err := httpProxyConfig.AssignPropertiesFromManagedClusterHTTPProxyConfig_STATUS(source.HttpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterHTTPProxyConfig_STATUS() to populate field HttpProxyConfig")
=======
		err := httpProxyConfig.AssignProperties_From_ManagedClusterHTTPProxyConfig_STATUS(source.HttpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterHTTPProxyConfig_STATUS() to populate field HttpProxyConfig")
>>>>>>> main
		}
		cluster.HttpProxyConfig = &httpProxyConfig
	} else {
		cluster.HttpProxyConfig = nil
	}

	// Id
	cluster.Id = genruntime.ClonePointerToString(source.Id)

	// Identity
	if source.Identity != nil {
		var identity ManagedClusterIdentity_STATUS
<<<<<<< HEAD
		err := identity.AssignPropertiesFromManagedClusterIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterIdentity_STATUS() to populate field Identity")
=======
		err := identity.AssignProperties_From_ManagedClusterIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterIdentity_STATUS() to populate field Identity")
>>>>>>> main
		}
		cluster.Identity = &identity
	} else {
		cluster.Identity = nil
	}

	// IdentityProfile
	if source.IdentityProfile != nil {
		identityProfile := *source.IdentityProfile.DeepCopy()
		cluster.IdentityProfile = &identityProfile
	} else {
		cluster.IdentityProfile = nil
	}

	// KubernetesVersion
	cluster.KubernetesVersion = genruntime.ClonePointerToString(source.KubernetesVersion)

	// LinuxProfile
	if source.LinuxProfile != nil {
		var linuxProfile ContainerServiceLinuxProfile_STATUS
<<<<<<< HEAD
		err := linuxProfile.AssignPropertiesFromContainerServiceLinuxProfile_STATUS(source.LinuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerServiceLinuxProfile_STATUS() to populate field LinuxProfile")
=======
		err := linuxProfile.AssignProperties_From_ContainerServiceLinuxProfile_STATUS(source.LinuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceLinuxProfile_STATUS() to populate field LinuxProfile")
>>>>>>> main
		}
		cluster.LinuxProfile = &linuxProfile
	} else {
		cluster.LinuxProfile = nil
	}

	// Location
	cluster.Location = genruntime.ClonePointerToString(source.Location)

	// MaxAgentPools
	cluster.MaxAgentPools = genruntime.ClonePointerToInt(source.MaxAgentPools)

	// Name
	cluster.Name = genruntime.ClonePointerToString(source.Name)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile ContainerServiceNetworkProfile_STATUS
<<<<<<< HEAD
		err := networkProfile.AssignPropertiesFromContainerServiceNetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerServiceNetworkProfile_STATUS() to populate field NetworkProfile")
=======
		err := networkProfile.AssignProperties_From_ContainerServiceNetworkProfile_STATUS(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceNetworkProfile_STATUS() to populate field NetworkProfile")
>>>>>>> main
		}
		cluster.NetworkProfile = &networkProfile
	} else {
		cluster.NetworkProfile = nil
	}

	// NodeResourceGroup
	cluster.NodeResourceGroup = genruntime.ClonePointerToString(source.NodeResourceGroup)

	// PodIdentityProfile
	if source.PodIdentityProfile != nil {
		var podIdentityProfile ManagedClusterPodIdentityProfile_STATUS
<<<<<<< HEAD
		err := podIdentityProfile.AssignPropertiesFromManagedClusterPodIdentityProfile_STATUS(source.PodIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentityProfile_STATUS() to populate field PodIdentityProfile")
=======
		err := podIdentityProfile.AssignProperties_From_ManagedClusterPodIdentityProfile_STATUS(source.PodIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProfile_STATUS() to populate field PodIdentityProfile")
>>>>>>> main
		}
		cluster.PodIdentityProfile = &podIdentityProfile
	} else {
		cluster.PodIdentityProfile = nil
	}

	// PowerState
	if source.PowerState != nil {
		var powerState PowerState_STATUS
<<<<<<< HEAD
		err := powerState.AssignPropertiesFromPowerState_STATUS(source.PowerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPowerState_STATUS() to populate field PowerState")
=======
		err := powerState.AssignProperties_From_PowerState_STATUS(source.PowerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PowerState_STATUS() to populate field PowerState")
>>>>>>> main
		}
		cluster.PowerState = &powerState
	} else {
		cluster.PowerState = nil
	}

	// PrivateFQDN
	cluster.PrivateFQDN = genruntime.ClonePointerToString(source.PrivateFQDN)

	// PrivateLinkResources
	if source.PrivateLinkResources != nil {
		privateLinkResourceList := make([]PrivateLinkResource_STATUS, len(source.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range source.PrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			privateLinkResourceItem := privateLinkResourceItem
			var privateLinkResource PrivateLinkResource_STATUS
<<<<<<< HEAD
			err := privateLinkResource.AssignPropertiesFromPrivateLinkResource_STATUS(&privateLinkResourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromPrivateLinkResource_STATUS() to populate field PrivateLinkResources")
=======
			err := privateLinkResource.AssignProperties_From_PrivateLinkResource_STATUS(&privateLinkResourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_PrivateLinkResource_STATUS() to populate field PrivateLinkResources")
>>>>>>> main
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		cluster.PrivateLinkResources = privateLinkResourceList
	} else {
		cluster.PrivateLinkResources = nil
	}

	// ProvisioningState
	cluster.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ServicePrincipalProfile
	if source.ServicePrincipalProfile != nil {
		var servicePrincipalProfile ManagedClusterServicePrincipalProfile_STATUS
<<<<<<< HEAD
		err := servicePrincipalProfile.AssignPropertiesFromManagedClusterServicePrincipalProfile_STATUS(source.ServicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterServicePrincipalProfile_STATUS() to populate field ServicePrincipalProfile")
=======
		err := servicePrincipalProfile.AssignProperties_From_ManagedClusterServicePrincipalProfile_STATUS(source.ServicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterServicePrincipalProfile_STATUS() to populate field ServicePrincipalProfile")
>>>>>>> main
		}
		cluster.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		cluster.ServicePrincipalProfile = nil
	}

	// Sku
	if source.Sku != nil {
		var sku ManagedClusterSKU_STATUS
<<<<<<< HEAD
		err := sku.AssignPropertiesFromManagedClusterSKU_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterSKU_STATUS() to populate field Sku")
=======
		err := sku.AssignProperties_From_ManagedClusterSKU_STATUS(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterSKU_STATUS() to populate field Sku")
>>>>>>> main
		}
		cluster.Sku = &sku
	} else {
		cluster.Sku = nil
	}

	// Tags
	cluster.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	cluster.Type = genruntime.ClonePointerToString(source.Type)

	// WindowsProfile
	if source.WindowsProfile != nil {
		var windowsProfile ManagedClusterWindowsProfile_STATUS
<<<<<<< HEAD
		err := windowsProfile.AssignPropertiesFromManagedClusterWindowsProfile_STATUS(source.WindowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterWindowsProfile_STATUS() to populate field WindowsProfile")
=======
		err := windowsProfile.AssignProperties_From_ManagedClusterWindowsProfile_STATUS(source.WindowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterWindowsProfile_STATUS() to populate field WindowsProfile")
>>>>>>> main
		}
		cluster.WindowsProfile = &windowsProfile
	} else {
		cluster.WindowsProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		cluster.PropertyBag = propertyBag
	} else {
		cluster.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedCluster_STATUS populates the provided destination ManagedCluster_STATUS from our ManagedCluster_STATUS
func (cluster *ManagedCluster_STATUS) AssignPropertiesToManagedCluster_STATUS(destination *v20210501s.ManagedCluster_STATUS) error {
=======
// AssignProperties_To_ManagedCluster_STATUS populates the provided destination ManagedCluster_STATUS from our ManagedCluster_STATUS
func (cluster *ManagedCluster_STATUS) AssignProperties_To_ManagedCluster_STATUS(destination *v20210501s.ManagedCluster_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(cluster.PropertyBag)

	// AadProfile
	if cluster.AadProfile != nil {
		var aadProfile v20210501s.ManagedClusterAADProfile_STATUS
<<<<<<< HEAD
		err := cluster.AadProfile.AssignPropertiesToManagedClusterAADProfile_STATUS(&aadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAADProfile_STATUS() to populate field AadProfile")
=======
		err := cluster.AadProfile.AssignProperties_To_ManagedClusterAADProfile_STATUS(&aadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAADProfile_STATUS() to populate field AadProfile")
>>>>>>> main
		}
		destination.AadProfile = &aadProfile
	} else {
		destination.AadProfile = nil
	}

	// AddonProfiles
	if cluster.AddonProfiles != nil {
		addonProfile := *cluster.AddonProfiles.DeepCopy()
		destination.AddonProfiles = &addonProfile
	} else {
		destination.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if cluster.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]v20210501s.ManagedClusterAgentPoolProfile_STATUS, len(cluster.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range cluster.AgentPoolProfiles {
			// Shadow the loop variable to avoid aliasing
			agentPoolProfileItem := agentPoolProfileItem
			var agentPoolProfile v20210501s.ManagedClusterAgentPoolProfile_STATUS
<<<<<<< HEAD
			err := agentPoolProfileItem.AssignPropertiesToManagedClusterAgentPoolProfile_STATUS(&agentPoolProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAgentPoolProfile_STATUS() to populate field AgentPoolProfiles")
=======
			err := agentPoolProfileItem.AssignProperties_To_ManagedClusterAgentPoolProfile_STATUS(&agentPoolProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAgentPoolProfile_STATUS() to populate field AgentPoolProfiles")
>>>>>>> main
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		destination.AgentPoolProfiles = agentPoolProfileList
	} else {
		destination.AgentPoolProfiles = nil
	}

	// ApiServerAccessProfile
	if cluster.ApiServerAccessProfile != nil {
		var apiServerAccessProfile v20210501s.ManagedClusterAPIServerAccessProfile_STATUS
<<<<<<< HEAD
		err := cluster.ApiServerAccessProfile.AssignPropertiesToManagedClusterAPIServerAccessProfile_STATUS(&apiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAPIServerAccessProfile_STATUS() to populate field ApiServerAccessProfile")
=======
		err := cluster.ApiServerAccessProfile.AssignProperties_To_ManagedClusterAPIServerAccessProfile_STATUS(&apiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAPIServerAccessProfile_STATUS() to populate field ApiServerAccessProfile")
>>>>>>> main
		}
		destination.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		destination.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if cluster.AutoScalerProfile != nil {
<<<<<<< HEAD
		var autoScalerProfile v20210501s.ManagedClusterProperties_AutoScalerProfile_STATUS
		err := cluster.AutoScalerProfile.AssignPropertiesToManagedClusterProperties_AutoScalerProfile_STATUS(&autoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterProperties_AutoScalerProfile_STATUS() to populate field AutoScalerProfile")
=======
		var autoScalerProfile v20210501s.ManagedClusterProperties_STATUS_AutoScalerProfile
		err := cluster.AutoScalerProfile.AssignProperties_To_ManagedClusterProperties_STATUS_AutoScalerProfile(&autoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterProperties_STATUS_AutoScalerProfile() to populate field AutoScalerProfile")
>>>>>>> main
		}
		destination.AutoScalerProfile = &autoScalerProfile
	} else {
		destination.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if cluster.AutoUpgradeProfile != nil {
		var autoUpgradeProfile v20210501s.ManagedClusterAutoUpgradeProfile_STATUS
<<<<<<< HEAD
		err := cluster.AutoUpgradeProfile.AssignPropertiesToManagedClusterAutoUpgradeProfile_STATUS(&autoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterAutoUpgradeProfile_STATUS() to populate field AutoUpgradeProfile")
=======
		err := cluster.AutoUpgradeProfile.AssignProperties_To_ManagedClusterAutoUpgradeProfile_STATUS(&autoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAutoUpgradeProfile_STATUS() to populate field AutoUpgradeProfile")
>>>>>>> main
		}
		destination.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		destination.AutoUpgradeProfile = nil
	}

	// AzurePortalFQDN
	destination.AzurePortalFQDN = genruntime.ClonePointerToString(cluster.AzurePortalFQDN)

	// Conditions
	destination.Conditions = genruntime.CloneSliceOfCondition(cluster.Conditions)

	// DisableLocalAccounts
	if cluster.DisableLocalAccounts != nil {
		disableLocalAccount := *cluster.DisableLocalAccounts
		destination.DisableLocalAccounts = &disableLocalAccount
	} else {
		destination.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetID
	destination.DiskEncryptionSetID = genruntime.ClonePointerToString(cluster.DiskEncryptionSetID)

	// DnsPrefix
	destination.DnsPrefix = genruntime.ClonePointerToString(cluster.DnsPrefix)

	// EnablePodSecurityPolicy
	if cluster.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *cluster.EnablePodSecurityPolicy
		destination.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		destination.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if cluster.EnableRBAC != nil {
		enableRBAC := *cluster.EnableRBAC
		destination.EnableRBAC = &enableRBAC
	} else {
		destination.EnableRBAC = nil
	}

	// ExtendedLocation
	if cluster.ExtendedLocation != nil {
		var extendedLocation v20210501s.ExtendedLocation_STATUS
<<<<<<< HEAD
		err := cluster.ExtendedLocation.AssignPropertiesToExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToExtendedLocation_STATUS() to populate field ExtendedLocation")
=======
		err := cluster.ExtendedLocation.AssignProperties_To_ExtendedLocation_STATUS(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation_STATUS() to populate field ExtendedLocation")
>>>>>>> main
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// Fqdn
	destination.Fqdn = genruntime.ClonePointerToString(cluster.Fqdn)

	// FqdnSubdomain
	destination.FqdnSubdomain = genruntime.ClonePointerToString(cluster.FqdnSubdomain)

	// HttpProxyConfig
	if cluster.HttpProxyConfig != nil {
		var httpProxyConfig v20210501s.ManagedClusterHTTPProxyConfig_STATUS
<<<<<<< HEAD
		err := cluster.HttpProxyConfig.AssignPropertiesToManagedClusterHTTPProxyConfig_STATUS(&httpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterHTTPProxyConfig_STATUS() to populate field HttpProxyConfig")
=======
		err := cluster.HttpProxyConfig.AssignProperties_To_ManagedClusterHTTPProxyConfig_STATUS(&httpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterHTTPProxyConfig_STATUS() to populate field HttpProxyConfig")
>>>>>>> main
		}
		destination.HttpProxyConfig = &httpProxyConfig
	} else {
		destination.HttpProxyConfig = nil
	}

	// Id
	destination.Id = genruntime.ClonePointerToString(cluster.Id)

	// Identity
	if cluster.Identity != nil {
		var identity v20210501s.ManagedClusterIdentity_STATUS
<<<<<<< HEAD
		err := cluster.Identity.AssignPropertiesToManagedClusterIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterIdentity_STATUS() to populate field Identity")
=======
		err := cluster.Identity.AssignProperties_To_ManagedClusterIdentity_STATUS(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterIdentity_STATUS() to populate field Identity")
>>>>>>> main
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IdentityProfile
	if cluster.IdentityProfile != nil {
		identityProfile := *cluster.IdentityProfile.DeepCopy()
		destination.IdentityProfile = &identityProfile
	} else {
		destination.IdentityProfile = nil
	}

	// KubernetesVersion
	destination.KubernetesVersion = genruntime.ClonePointerToString(cluster.KubernetesVersion)

	// LinuxProfile
	if cluster.LinuxProfile != nil {
		var linuxProfile v20210501s.ContainerServiceLinuxProfile_STATUS
<<<<<<< HEAD
		err := cluster.LinuxProfile.AssignPropertiesToContainerServiceLinuxProfile_STATUS(&linuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerServiceLinuxProfile_STATUS() to populate field LinuxProfile")
=======
		err := cluster.LinuxProfile.AssignProperties_To_ContainerServiceLinuxProfile_STATUS(&linuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceLinuxProfile_STATUS() to populate field LinuxProfile")
>>>>>>> main
		}
		destination.LinuxProfile = &linuxProfile
	} else {
		destination.LinuxProfile = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(cluster.Location)

	// MaxAgentPools
	destination.MaxAgentPools = genruntime.ClonePointerToInt(cluster.MaxAgentPools)

	// Name
	destination.Name = genruntime.ClonePointerToString(cluster.Name)

	// NetworkProfile
	if cluster.NetworkProfile != nil {
		var networkProfile v20210501s.ContainerServiceNetworkProfile_STATUS
<<<<<<< HEAD
		err := cluster.NetworkProfile.AssignPropertiesToContainerServiceNetworkProfile_STATUS(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerServiceNetworkProfile_STATUS() to populate field NetworkProfile")
=======
		err := cluster.NetworkProfile.AssignProperties_To_ContainerServiceNetworkProfile_STATUS(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceNetworkProfile_STATUS() to populate field NetworkProfile")
>>>>>>> main
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// NodeResourceGroup
	destination.NodeResourceGroup = genruntime.ClonePointerToString(cluster.NodeResourceGroup)

	// PodIdentityProfile
	if cluster.PodIdentityProfile != nil {
		var podIdentityProfile v20210501s.ManagedClusterPodIdentityProfile_STATUS
<<<<<<< HEAD
		err := cluster.PodIdentityProfile.AssignPropertiesToManagedClusterPodIdentityProfile_STATUS(&podIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentityProfile_STATUS() to populate field PodIdentityProfile")
=======
		err := cluster.PodIdentityProfile.AssignProperties_To_ManagedClusterPodIdentityProfile_STATUS(&podIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProfile_STATUS() to populate field PodIdentityProfile")
>>>>>>> main
		}
		destination.PodIdentityProfile = &podIdentityProfile
	} else {
		destination.PodIdentityProfile = nil
	}

	// PowerState
	if cluster.PowerState != nil {
		var powerState v20210501s.PowerState_STATUS
<<<<<<< HEAD
		err := cluster.PowerState.AssignPropertiesToPowerState_STATUS(&powerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPowerState_STATUS() to populate field PowerState")
=======
		err := cluster.PowerState.AssignProperties_To_PowerState_STATUS(&powerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PowerState_STATUS() to populate field PowerState")
>>>>>>> main
		}
		destination.PowerState = &powerState
	} else {
		destination.PowerState = nil
	}

	// PrivateFQDN
	destination.PrivateFQDN = genruntime.ClonePointerToString(cluster.PrivateFQDN)

	// PrivateLinkResources
	if cluster.PrivateLinkResources != nil {
		privateLinkResourceList := make([]v20210501s.PrivateLinkResource_STATUS, len(cluster.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range cluster.PrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			privateLinkResourceItem := privateLinkResourceItem
			var privateLinkResource v20210501s.PrivateLinkResource_STATUS
<<<<<<< HEAD
			err := privateLinkResourceItem.AssignPropertiesToPrivateLinkResource_STATUS(&privateLinkResource)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToPrivateLinkResource_STATUS() to populate field PrivateLinkResources")
=======
			err := privateLinkResourceItem.AssignProperties_To_PrivateLinkResource_STATUS(&privateLinkResource)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_PrivateLinkResource_STATUS() to populate field PrivateLinkResources")
>>>>>>> main
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		destination.PrivateLinkResources = privateLinkResourceList
	} else {
		destination.PrivateLinkResources = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(cluster.ProvisioningState)

	// ServicePrincipalProfile
	if cluster.ServicePrincipalProfile != nil {
		var servicePrincipalProfile v20210501s.ManagedClusterServicePrincipalProfile_STATUS
<<<<<<< HEAD
		err := cluster.ServicePrincipalProfile.AssignPropertiesToManagedClusterServicePrincipalProfile_STATUS(&servicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterServicePrincipalProfile_STATUS() to populate field ServicePrincipalProfile")
=======
		err := cluster.ServicePrincipalProfile.AssignProperties_To_ManagedClusterServicePrincipalProfile_STATUS(&servicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterServicePrincipalProfile_STATUS() to populate field ServicePrincipalProfile")
>>>>>>> main
		}
		destination.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		destination.ServicePrincipalProfile = nil
	}

	// Sku
	if cluster.Sku != nil {
		var sku v20210501s.ManagedClusterSKU_STATUS
<<<<<<< HEAD
		err := cluster.Sku.AssignPropertiesToManagedClusterSKU_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterSKU_STATUS() to populate field Sku")
=======
		err := cluster.Sku.AssignProperties_To_ManagedClusterSKU_STATUS(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterSKU_STATUS() to populate field Sku")
>>>>>>> main
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(cluster.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(cluster.Type)

	// WindowsProfile
	if cluster.WindowsProfile != nil {
		var windowsProfile v20210501s.ManagedClusterWindowsProfile_STATUS
<<<<<<< HEAD
		err := cluster.WindowsProfile.AssignPropertiesToManagedClusterWindowsProfile_STATUS(&windowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterWindowsProfile_STATUS() to populate field WindowsProfile")
=======
		err := cluster.WindowsProfile.AssignProperties_To_ManagedClusterWindowsProfile_STATUS(&windowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterWindowsProfile_STATUS() to populate field WindowsProfile")
>>>>>>> main
		}
		destination.WindowsProfile = &windowsProfile
	} else {
		destination.WindowsProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
=======
// Storage version of v1alpha1api20210501.ManagedClusters_Spec
type ManagedClusters_Spec struct {
	AadProfile             *ManagedClusterAADProfile                  `json:"aadProfile,omitempty"`
	AddonProfiles          map[string]ManagedClusterAddonProfile      `json:"addonProfiles,omitempty"`
	AgentPoolProfiles      []ManagedClusterAgentPoolProfile           `json:"agentPoolProfiles,omitempty"`
	ApiServerAccessProfile *ManagedClusterAPIServerAccessProfile      `json:"apiServerAccessProfile,omitempty"`
	AutoScalerProfile      *ManagedClusterPropertiesAutoScalerProfile `json:"autoScalerProfile,omitempty"`
	AutoUpgradeProfile     *ManagedClusterAutoUpgradeProfile          `json:"autoUpgradeProfile,omitempty"`

	// +kubebuilder:validation:MaxLength=63
	// +kubebuilder:validation:MinLength=1
	// +kubebuilder:validation:Pattern="^[a-zA-Z0-9]$|^[a-zA-Z0-9][-_a-zA-Z0-9]{0,61}[a-zA-Z0-9]$"
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName                    string                                                                                                  `json:"azureName,omitempty"`
	DisableLocalAccounts         *bool                                                                                                   `json:"disableLocalAccounts,omitempty"`
	DiskEncryptionSetIDReference *genruntime.ResourceReference                                                                           `armReference:"DiskEncryptionSetID" json:"diskEncryptionSetIDReference,omitempty"`
	DnsPrefix                    *string                                                                                                 `json:"dnsPrefix,omitempty"`
	EnablePodSecurityPolicy      *bool                                                                                                   `json:"enablePodSecurityPolicy,omitempty"`
	EnableRBAC                   *bool                                                                                                   `json:"enableRBAC,omitempty"`
	ExtendedLocation             *ExtendedLocation                                                                                       `json:"extendedLocation,omitempty"`
	FqdnSubdomain                *string                                                                                                 `json:"fqdnSubdomain,omitempty"`
	HttpProxyConfig              *ManagedClusterHTTPProxyConfig                                                                          `json:"httpProxyConfig,omitempty"`
	Identity                     *ManagedClusterIdentity                                                                                 `json:"identity,omitempty"`
	IdentityProfile              map[string]Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties `json:"identityProfile,omitempty"`
	KubernetesVersion            *string                                                                                                 `json:"kubernetesVersion,omitempty"`
	LinuxProfile                 *ContainerServiceLinuxProfile                                                                           `json:"linuxProfile,omitempty"`
	Location                     *string                                                                                                 `json:"location,omitempty"`
	NetworkProfile               *ContainerServiceNetworkProfile                                                                         `json:"networkProfile,omitempty"`
	NodeResourceGroup            *string                                                                                                 `json:"nodeResourceGroup,omitempty"`
	OperatorSpec                 *ManagedClusterOperatorSpec                                                                             `json:"operatorSpec,omitempty"`
	OriginalVersion              string                                                                                                  `json:"originalVersion,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a resources.azure.com/ResourceGroup resource
	Owner                   *genruntime.KnownResourceReference     `group:"resources.azure.com" json:"owner,omitempty" kind:"ResourceGroup"`
	PodIdentityProfile      *ManagedClusterPodIdentityProfile      `json:"podIdentityProfile,omitempty"`
	PrivateLinkResources    []PrivateLinkResource                  `json:"privateLinkResources,omitempty"`
	PropertyBag             genruntime.PropertyBag                 `json:"$propertyBag,omitempty"`
	ServicePrincipalProfile *ManagedClusterServicePrincipalProfile `json:"servicePrincipalProfile,omitempty"`
	Sku                     *ManagedClusterSKU                     `json:"sku,omitempty"`
	Tags                    map[string]string                      `json:"tags,omitempty"`
	WindowsProfile          *ManagedClusterWindowsProfile          `json:"windowsProfile,omitempty"`
}

var _ genruntime.ConvertibleSpec = &ManagedClusters_Spec{}

// ConvertSpecFrom populates our ManagedClusters_Spec from the provided source
func (clusters *ManagedClusters_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	src, ok := source.(*v20210501s.ManagedClusters_Spec)
	if ok {
		// Populate our instance from source
		return clusters.AssignProperties_From_ManagedClusters_Spec(src)
	}

	// Convert to an intermediate form
	src = &v20210501s.ManagedClusters_Spec{}
	err := src.ConvertSpecFrom(source)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecFrom()")
	}

	// Update our instance from src
	err = clusters.AssignProperties_From_ManagedClusters_Spec(src)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecFrom()")
	}

	return nil
}

// ConvertSpecTo populates the provided destination from our ManagedClusters_Spec
func (clusters *ManagedClusters_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	dst, ok := destination.(*v20210501s.ManagedClusters_Spec)
	if ok {
		// Populate destination from our instance
		return clusters.AssignProperties_To_ManagedClusters_Spec(dst)
	}

	// Convert to an intermediate form
	dst = &v20210501s.ManagedClusters_Spec{}
	err := clusters.AssignProperties_To_ManagedClusters_Spec(dst)
	if err != nil {
		return errors.Wrap(err, "initial step of conversion in ConvertSpecTo()")
	}

	// Update dst from our instance
	err = dst.ConvertSpecTo(destination)
	if err != nil {
		return errors.Wrap(err, "final step of conversion in ConvertSpecTo()")
	}

	return nil
}

// AssignProperties_From_ManagedClusters_Spec populates our ManagedClusters_Spec from the provided source ManagedClusters_Spec
func (clusters *ManagedClusters_Spec) AssignProperties_From_ManagedClusters_Spec(source *v20210501s.ManagedClusters_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AadProfile
	if source.AadProfile != nil {
		var aadProfile ManagedClusterAADProfile
		err := aadProfile.AssignProperties_From_ManagedClusterAADProfile(source.AadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAADProfile() to populate field AadProfile")
		}
		clusters.AadProfile = &aadProfile
	} else {
		clusters.AadProfile = nil
	}

	// AddonProfiles
	if source.AddonProfiles != nil {
		addonProfileMap := make(map[string]ManagedClusterAddonProfile, len(source.AddonProfiles))
		for addonProfileKey, addonProfileValue := range source.AddonProfiles {
			// Shadow the loop variable to avoid aliasing
			addonProfileValue := addonProfileValue
			var addonProfile ManagedClusterAddonProfile
			err := addonProfile.AssignProperties_From_ManagedClusterAddonProfile(&addonProfileValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAddonProfile() to populate field AddonProfiles")
			}
			addonProfileMap[addonProfileKey] = addonProfile
		}
		clusters.AddonProfiles = addonProfileMap
	} else {
		clusters.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if source.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]ManagedClusterAgentPoolProfile, len(source.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range source.AgentPoolProfiles {
			// Shadow the loop variable to avoid aliasing
			agentPoolProfileItem := agentPoolProfileItem
			var agentPoolProfile ManagedClusterAgentPoolProfile
			err := agentPoolProfile.AssignProperties_From_ManagedClusterAgentPoolProfile(&agentPoolProfileItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAgentPoolProfile() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		clusters.AgentPoolProfiles = agentPoolProfileList
	} else {
		clusters.AgentPoolProfiles = nil
	}

	// ApiServerAccessProfile
	if source.ApiServerAccessProfile != nil {
		var apiServerAccessProfile ManagedClusterAPIServerAccessProfile
		err := apiServerAccessProfile.AssignProperties_From_ManagedClusterAPIServerAccessProfile(source.ApiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAPIServerAccessProfile() to populate field ApiServerAccessProfile")
		}
		clusters.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		clusters.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if source.AutoScalerProfile != nil {
		var autoScalerProfile ManagedClusterPropertiesAutoScalerProfile
		err := autoScalerProfile.AssignProperties_From_ManagedClusterPropertiesAutoScalerProfile(source.AutoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPropertiesAutoScalerProfile() to populate field AutoScalerProfile")
		}
		clusters.AutoScalerProfile = &autoScalerProfile
	} else {
		clusters.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if source.AutoUpgradeProfile != nil {
		var autoUpgradeProfile ManagedClusterAutoUpgradeProfile
		err := autoUpgradeProfile.AssignProperties_From_ManagedClusterAutoUpgradeProfile(source.AutoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterAutoUpgradeProfile() to populate field AutoUpgradeProfile")
		}
		clusters.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		clusters.AutoUpgradeProfile = nil
	}

	// AzureName
	clusters.AzureName = source.AzureName

	// DisableLocalAccounts
	if source.DisableLocalAccounts != nil {
		disableLocalAccount := *source.DisableLocalAccounts
		clusters.DisableLocalAccounts = &disableLocalAccount
	} else {
		clusters.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetIDReference
	if source.DiskEncryptionSetIDReference != nil {
		diskEncryptionSetIDReference := source.DiskEncryptionSetIDReference.Copy()
		clusters.DiskEncryptionSetIDReference = &diskEncryptionSetIDReference
	} else {
		clusters.DiskEncryptionSetIDReference = nil
	}

	// DnsPrefix
	clusters.DnsPrefix = genruntime.ClonePointerToString(source.DnsPrefix)

	// EnablePodSecurityPolicy
	if source.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *source.EnablePodSecurityPolicy
		clusters.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		clusters.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if source.EnableRBAC != nil {
		enableRBAC := *source.EnableRBAC
		clusters.EnableRBAC = &enableRBAC
	} else {
		clusters.EnableRBAC = nil
	}

	// ExtendedLocation
	if source.ExtendedLocation != nil {
		var extendedLocation ExtendedLocation
		err := extendedLocation.AssignProperties_From_ExtendedLocation(source.ExtendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ExtendedLocation() to populate field ExtendedLocation")
		}
		clusters.ExtendedLocation = &extendedLocation
	} else {
		clusters.ExtendedLocation = nil
	}

	// FqdnSubdomain
	clusters.FqdnSubdomain = genruntime.ClonePointerToString(source.FqdnSubdomain)

	// HttpProxyConfig
	if source.HttpProxyConfig != nil {
		var httpProxyConfig ManagedClusterHTTPProxyConfig
		err := httpProxyConfig.AssignProperties_From_ManagedClusterHTTPProxyConfig(source.HttpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterHTTPProxyConfig() to populate field HttpProxyConfig")
		}
		clusters.HttpProxyConfig = &httpProxyConfig
	} else {
		clusters.HttpProxyConfig = nil
	}

	// Identity
	if source.Identity != nil {
		var identity ManagedClusterIdentity
		err := identity.AssignProperties_From_ManagedClusterIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterIdentity() to populate field Identity")
		}
		clusters.Identity = &identity
	} else {
		clusters.Identity = nil
	}

	// IdentityProfile
	if source.IdentityProfile != nil {
		identityProfileMap := make(map[string]Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties, len(source.IdentityProfile))
		for identityProfileKey, identityProfileValue := range source.IdentityProfile {
			// Shadow the loop variable to avoid aliasing
			identityProfileValue := identityProfileValue
			var identityProfile Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties
			err := identityProfile.AssignProperties_From_Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties(&identityProfileValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties() to populate field IdentityProfile")
			}
			identityProfileMap[identityProfileKey] = identityProfile
		}
		clusters.IdentityProfile = identityProfileMap
	} else {
		clusters.IdentityProfile = nil
	}

	// KubernetesVersion
	clusters.KubernetesVersion = genruntime.ClonePointerToString(source.KubernetesVersion)

	// LinuxProfile
	if source.LinuxProfile != nil {
		var linuxProfile ContainerServiceLinuxProfile
		err := linuxProfile.AssignProperties_From_ContainerServiceLinuxProfile(source.LinuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceLinuxProfile() to populate field LinuxProfile")
		}
		clusters.LinuxProfile = &linuxProfile
	} else {
		clusters.LinuxProfile = nil
	}

	// Location
	clusters.Location = genruntime.ClonePointerToString(source.Location)

	// NetworkProfile
	if source.NetworkProfile != nil {
		var networkProfile ContainerServiceNetworkProfile
		err := networkProfile.AssignProperties_From_ContainerServiceNetworkProfile(source.NetworkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceNetworkProfile() to populate field NetworkProfile")
		}
		clusters.NetworkProfile = &networkProfile
	} else {
		clusters.NetworkProfile = nil
	}

	// NodeResourceGroup
	clusters.NodeResourceGroup = genruntime.ClonePointerToString(source.NodeResourceGroup)

	// OperatorSpec
	if source.OperatorSpec != nil {
		var operatorSpec ManagedClusterOperatorSpec
		err := operatorSpec.AssignProperties_From_ManagedClusterOperatorSpec(source.OperatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterOperatorSpec() to populate field OperatorSpec")
		}
		clusters.OperatorSpec = &operatorSpec
	} else {
		clusters.OperatorSpec = nil
	}

	// OriginalVersion
	clusters.OriginalVersion = source.OriginalVersion

	// Owner
	if source.Owner != nil {
		owner := source.Owner.Copy()
		clusters.Owner = &owner
	} else {
		clusters.Owner = nil
	}

	// PodIdentityProfile
	if source.PodIdentityProfile != nil {
		var podIdentityProfile ManagedClusterPodIdentityProfile
		err := podIdentityProfile.AssignProperties_From_ManagedClusterPodIdentityProfile(source.PodIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProfile() to populate field PodIdentityProfile")
		}
		clusters.PodIdentityProfile = &podIdentityProfile
	} else {
		clusters.PodIdentityProfile = nil
	}

	// PrivateLinkResources
	if source.PrivateLinkResources != nil {
		privateLinkResourceList := make([]PrivateLinkResource, len(source.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range source.PrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			privateLinkResourceItem := privateLinkResourceItem
			var privateLinkResource PrivateLinkResource
			err := privateLinkResource.AssignProperties_From_PrivateLinkResource(&privateLinkResourceItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_PrivateLinkResource() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		clusters.PrivateLinkResources = privateLinkResourceList
	} else {
		clusters.PrivateLinkResources = nil
	}

	// ServicePrincipalProfile
	if source.ServicePrincipalProfile != nil {
		var servicePrincipalProfile ManagedClusterServicePrincipalProfile
		err := servicePrincipalProfile.AssignProperties_From_ManagedClusterServicePrincipalProfile(source.ServicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterServicePrincipalProfile() to populate field ServicePrincipalProfile")
		}
		clusters.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		clusters.ServicePrincipalProfile = nil
	}

	// Sku
	if source.Sku != nil {
		var sku ManagedClusterSKU
		err := sku.AssignProperties_From_ManagedClusterSKU(source.Sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterSKU() to populate field Sku")
		}
		clusters.Sku = &sku
	} else {
		clusters.Sku = nil
	}

	// Tags
	clusters.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// WindowsProfile
	if source.WindowsProfile != nil {
		var windowsProfile ManagedClusterWindowsProfile
		err := windowsProfile.AssignProperties_From_ManagedClusterWindowsProfile(source.WindowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterWindowsProfile() to populate field WindowsProfile")
		}
		clusters.WindowsProfile = &windowsProfile
	} else {
		clusters.WindowsProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		clusters.PropertyBag = propertyBag
	} else {
		clusters.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusters_Spec populates the provided destination ManagedClusters_Spec from our ManagedClusters_Spec
func (clusters *ManagedClusters_Spec) AssignProperties_To_ManagedClusters_Spec(destination *v20210501s.ManagedClusters_Spec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(clusters.PropertyBag)

	// AadProfile
	if clusters.AadProfile != nil {
		var aadProfile v20210501s.ManagedClusterAADProfile
		err := clusters.AadProfile.AssignProperties_To_ManagedClusterAADProfile(&aadProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAADProfile() to populate field AadProfile")
		}
		destination.AadProfile = &aadProfile
	} else {
		destination.AadProfile = nil
	}

	// AddonProfiles
	if clusters.AddonProfiles != nil {
		addonProfileMap := make(map[string]v20210501s.ManagedClusterAddonProfile, len(clusters.AddonProfiles))
		for addonProfileKey, addonProfileValue := range clusters.AddonProfiles {
			// Shadow the loop variable to avoid aliasing
			addonProfileValue := addonProfileValue
			var addonProfile v20210501s.ManagedClusterAddonProfile
			err := addonProfileValue.AssignProperties_To_ManagedClusterAddonProfile(&addonProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAddonProfile() to populate field AddonProfiles")
			}
			addonProfileMap[addonProfileKey] = addonProfile
		}
		destination.AddonProfiles = addonProfileMap
	} else {
		destination.AddonProfiles = nil
	}

	// AgentPoolProfiles
	if clusters.AgentPoolProfiles != nil {
		agentPoolProfileList := make([]v20210501s.ManagedClusterAgentPoolProfile, len(clusters.AgentPoolProfiles))
		for agentPoolProfileIndex, agentPoolProfileItem := range clusters.AgentPoolProfiles {
			// Shadow the loop variable to avoid aliasing
			agentPoolProfileItem := agentPoolProfileItem
			var agentPoolProfile v20210501s.ManagedClusterAgentPoolProfile
			err := agentPoolProfileItem.AssignProperties_To_ManagedClusterAgentPoolProfile(&agentPoolProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAgentPoolProfile() to populate field AgentPoolProfiles")
			}
			agentPoolProfileList[agentPoolProfileIndex] = agentPoolProfile
		}
		destination.AgentPoolProfiles = agentPoolProfileList
	} else {
		destination.AgentPoolProfiles = nil
	}

	// ApiServerAccessProfile
	if clusters.ApiServerAccessProfile != nil {
		var apiServerAccessProfile v20210501s.ManagedClusterAPIServerAccessProfile
		err := clusters.ApiServerAccessProfile.AssignProperties_To_ManagedClusterAPIServerAccessProfile(&apiServerAccessProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAPIServerAccessProfile() to populate field ApiServerAccessProfile")
		}
		destination.ApiServerAccessProfile = &apiServerAccessProfile
	} else {
		destination.ApiServerAccessProfile = nil
	}

	// AutoScalerProfile
	if clusters.AutoScalerProfile != nil {
		var autoScalerProfile v20210501s.ManagedClusterPropertiesAutoScalerProfile
		err := clusters.AutoScalerProfile.AssignProperties_To_ManagedClusterPropertiesAutoScalerProfile(&autoScalerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPropertiesAutoScalerProfile() to populate field AutoScalerProfile")
		}
		destination.AutoScalerProfile = &autoScalerProfile
	} else {
		destination.AutoScalerProfile = nil
	}

	// AutoUpgradeProfile
	if clusters.AutoUpgradeProfile != nil {
		var autoUpgradeProfile v20210501s.ManagedClusterAutoUpgradeProfile
		err := clusters.AutoUpgradeProfile.AssignProperties_To_ManagedClusterAutoUpgradeProfile(&autoUpgradeProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterAutoUpgradeProfile() to populate field AutoUpgradeProfile")
		}
		destination.AutoUpgradeProfile = &autoUpgradeProfile
	} else {
		destination.AutoUpgradeProfile = nil
	}

	// AzureName
	destination.AzureName = clusters.AzureName

	// DisableLocalAccounts
	if clusters.DisableLocalAccounts != nil {
		disableLocalAccount := *clusters.DisableLocalAccounts
		destination.DisableLocalAccounts = &disableLocalAccount
	} else {
		destination.DisableLocalAccounts = nil
	}

	// DiskEncryptionSetIDReference
	if clusters.DiskEncryptionSetIDReference != nil {
		diskEncryptionSetIDReference := clusters.DiskEncryptionSetIDReference.Copy()
		destination.DiskEncryptionSetIDReference = &diskEncryptionSetIDReference
	} else {
		destination.DiskEncryptionSetIDReference = nil
	}

	// DnsPrefix
	destination.DnsPrefix = genruntime.ClonePointerToString(clusters.DnsPrefix)

	// EnablePodSecurityPolicy
	if clusters.EnablePodSecurityPolicy != nil {
		enablePodSecurityPolicy := *clusters.EnablePodSecurityPolicy
		destination.EnablePodSecurityPolicy = &enablePodSecurityPolicy
	} else {
		destination.EnablePodSecurityPolicy = nil
	}

	// EnableRBAC
	if clusters.EnableRBAC != nil {
		enableRBAC := *clusters.EnableRBAC
		destination.EnableRBAC = &enableRBAC
	} else {
		destination.EnableRBAC = nil
	}

	// ExtendedLocation
	if clusters.ExtendedLocation != nil {
		var extendedLocation v20210501s.ExtendedLocation
		err := clusters.ExtendedLocation.AssignProperties_To_ExtendedLocation(&extendedLocation)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ExtendedLocation() to populate field ExtendedLocation")
		}
		destination.ExtendedLocation = &extendedLocation
	} else {
		destination.ExtendedLocation = nil
	}

	// FqdnSubdomain
	destination.FqdnSubdomain = genruntime.ClonePointerToString(clusters.FqdnSubdomain)

	// HttpProxyConfig
	if clusters.HttpProxyConfig != nil {
		var httpProxyConfig v20210501s.ManagedClusterHTTPProxyConfig
		err := clusters.HttpProxyConfig.AssignProperties_To_ManagedClusterHTTPProxyConfig(&httpProxyConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterHTTPProxyConfig() to populate field HttpProxyConfig")
		}
		destination.HttpProxyConfig = &httpProxyConfig
	} else {
		destination.HttpProxyConfig = nil
	}

	// Identity
	if clusters.Identity != nil {
		var identity v20210501s.ManagedClusterIdentity
		err := clusters.Identity.AssignProperties_To_ManagedClusterIdentity(&identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterIdentity() to populate field Identity")
		}
		destination.Identity = &identity
	} else {
		destination.Identity = nil
	}

	// IdentityProfile
	if clusters.IdentityProfile != nil {
		identityProfileMap := make(map[string]v20210501s.Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties, len(clusters.IdentityProfile))
		for identityProfileKey, identityProfileValue := range clusters.IdentityProfile {
			// Shadow the loop variable to avoid aliasing
			identityProfileValue := identityProfileValue
			var identityProfile v20210501s.Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties
			err := identityProfileValue.AssignProperties_To_Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties(&identityProfile)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties() to populate field IdentityProfile")
			}
			identityProfileMap[identityProfileKey] = identityProfile
		}
		destination.IdentityProfile = identityProfileMap
	} else {
		destination.IdentityProfile = nil
	}

	// KubernetesVersion
	destination.KubernetesVersion = genruntime.ClonePointerToString(clusters.KubernetesVersion)

	// LinuxProfile
	if clusters.LinuxProfile != nil {
		var linuxProfile v20210501s.ContainerServiceLinuxProfile
		err := clusters.LinuxProfile.AssignProperties_To_ContainerServiceLinuxProfile(&linuxProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceLinuxProfile() to populate field LinuxProfile")
		}
		destination.LinuxProfile = &linuxProfile
	} else {
		destination.LinuxProfile = nil
	}

	// Location
	destination.Location = genruntime.ClonePointerToString(clusters.Location)

	// NetworkProfile
	if clusters.NetworkProfile != nil {
		var networkProfile v20210501s.ContainerServiceNetworkProfile
		err := clusters.NetworkProfile.AssignProperties_To_ContainerServiceNetworkProfile(&networkProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceNetworkProfile() to populate field NetworkProfile")
		}
		destination.NetworkProfile = &networkProfile
	} else {
		destination.NetworkProfile = nil
	}

	// NodeResourceGroup
	destination.NodeResourceGroup = genruntime.ClonePointerToString(clusters.NodeResourceGroup)

	// OperatorSpec
	if clusters.OperatorSpec != nil {
		var operatorSpec v20210501s.ManagedClusterOperatorSpec
		err := clusters.OperatorSpec.AssignProperties_To_ManagedClusterOperatorSpec(&operatorSpec)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterOperatorSpec() to populate field OperatorSpec")
		}
		destination.OperatorSpec = &operatorSpec
	} else {
		destination.OperatorSpec = nil
	}

	// OriginalVersion
	destination.OriginalVersion = clusters.OriginalVersion

	// Owner
	if clusters.Owner != nil {
		owner := clusters.Owner.Copy()
		destination.Owner = &owner
	} else {
		destination.Owner = nil
	}

	// PodIdentityProfile
	if clusters.PodIdentityProfile != nil {
		var podIdentityProfile v20210501s.ManagedClusterPodIdentityProfile
		err := clusters.PodIdentityProfile.AssignProperties_To_ManagedClusterPodIdentityProfile(&podIdentityProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProfile() to populate field PodIdentityProfile")
		}
		destination.PodIdentityProfile = &podIdentityProfile
	} else {
		destination.PodIdentityProfile = nil
	}

	// PrivateLinkResources
	if clusters.PrivateLinkResources != nil {
		privateLinkResourceList := make([]v20210501s.PrivateLinkResource, len(clusters.PrivateLinkResources))
		for privateLinkResourceIndex, privateLinkResourceItem := range clusters.PrivateLinkResources {
			// Shadow the loop variable to avoid aliasing
			privateLinkResourceItem := privateLinkResourceItem
			var privateLinkResource v20210501s.PrivateLinkResource
			err := privateLinkResourceItem.AssignProperties_To_PrivateLinkResource(&privateLinkResource)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_PrivateLinkResource() to populate field PrivateLinkResources")
			}
			privateLinkResourceList[privateLinkResourceIndex] = privateLinkResource
		}
		destination.PrivateLinkResources = privateLinkResourceList
	} else {
		destination.PrivateLinkResources = nil
	}

	// ServicePrincipalProfile
	if clusters.ServicePrincipalProfile != nil {
		var servicePrincipalProfile v20210501s.ManagedClusterServicePrincipalProfile
		err := clusters.ServicePrincipalProfile.AssignProperties_To_ManagedClusterServicePrincipalProfile(&servicePrincipalProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterServicePrincipalProfile() to populate field ServicePrincipalProfile")
		}
		destination.ServicePrincipalProfile = &servicePrincipalProfile
	} else {
		destination.ServicePrincipalProfile = nil
	}

	// Sku
	if clusters.Sku != nil {
		var sku v20210501s.ManagedClusterSKU
		err := clusters.Sku.AssignProperties_To_ManagedClusterSKU(&sku)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterSKU() to populate field Sku")
		}
		destination.Sku = &sku
	} else {
		destination.Sku = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(clusters.Tags)

	// WindowsProfile
	if clusters.WindowsProfile != nil {
		var windowsProfile v20210501s.ManagedClusterWindowsProfile
		err := clusters.WindowsProfile.AssignProperties_To_ManagedClusterWindowsProfile(&windowsProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterWindowsProfile() to populate field WindowsProfile")
		}
		destination.WindowsProfile = &windowsProfile
	} else {
		destination.WindowsProfile = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties
// Deprecated version of Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties. Use v1beta20210501.Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties instead
type Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties struct {
	ClientId          *string                       `json:"clientId,omitempty"`
	ObjectId          *string                       `json:"objectId,omitempty"`
	PropertyBag       genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

// AssignProperties_From_Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties populates our Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties from the provided source Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties
func (etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties *Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties) AssignProperties_From_Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties(source *v20210501s.Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ObjectId
	etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ResourceReference = &resourceReference
	} else {
		etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.PropertyBag = propertyBag
	} else {
		etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties populates the provided destination Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties from our Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties
func (etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties *Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties) AssignProperties_To_Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties(destination *v20210501s.Componentsqit0Etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ClientId)

	// ObjectId
	destination.ObjectId = genruntime.ClonePointerToString(etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ObjectId)

	// ResourceReference
	if etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ResourceReference != nil {
		resourceReference := etschemasmanagedclusterpropertiespropertiesidentityprofileadditionalproperties.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

>>>>>>> main
// Storage version of v1alpha1api20210501.ContainerServiceLinuxProfile
// Deprecated version of ContainerServiceLinuxProfile. Use v1beta20210501.ContainerServiceLinuxProfile instead
type ContainerServiceLinuxProfile struct {
	AdminUsername *string                           `json:"adminUsername,omitempty"`
	PropertyBag   genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
	Ssh           *ContainerServiceSshConfiguration `json:"ssh,omitempty"`
}

// AssignProperties_From_ContainerServiceLinuxProfile populates our ContainerServiceLinuxProfile from the provided source ContainerServiceLinuxProfile
func (profile *ContainerServiceLinuxProfile) AssignProperties_From_ContainerServiceLinuxProfile(source *v20210501s.ContainerServiceLinuxProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// Ssh
	if source.Ssh != nil {
		var ssh ContainerServiceSshConfiguration
		err := ssh.AssignProperties_From_ContainerServiceSshConfiguration(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceSshConfiguration() to populate field Ssh")
		}
		profile.Ssh = &ssh
	} else {
		profile.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceLinuxProfile populates the provided destination ContainerServiceLinuxProfile from our ContainerServiceLinuxProfile
func (profile *ContainerServiceLinuxProfile) AssignProperties_To_ContainerServiceLinuxProfile(destination *v20210501s.ContainerServiceLinuxProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// Ssh
	if profile.Ssh != nil {
		var ssh v20210501s.ContainerServiceSshConfiguration
		err := profile.Ssh.AssignProperties_To_ContainerServiceSshConfiguration(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceSshConfiguration() to populate field Ssh")
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ContainerServiceLinuxProfile_STATUS
// Deprecated version of ContainerServiceLinuxProfile_STATUS. Use v1beta20210501.ContainerServiceLinuxProfile_STATUS instead
type ContainerServiceLinuxProfile_STATUS struct {
	AdminUsername *string                                  `json:"adminUsername,omitempty"`
	PropertyBag   genruntime.PropertyBag                   `json:"$propertyBag,omitempty"`
	Ssh           *ContainerServiceSshConfiguration_STATUS `json:"ssh,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromContainerServiceLinuxProfile_STATUS populates our ContainerServiceLinuxProfile_STATUS from the provided source ContainerServiceLinuxProfile_STATUS
func (profile *ContainerServiceLinuxProfile_STATUS) AssignPropertiesFromContainerServiceLinuxProfile_STATUS(source *v20210501s.ContainerServiceLinuxProfile_STATUS) error {
=======
// AssignProperties_From_ContainerServiceLinuxProfile_STATUS populates our ContainerServiceLinuxProfile_STATUS from the provided source ContainerServiceLinuxProfile_STATUS
func (profile *ContainerServiceLinuxProfile_STATUS) AssignProperties_From_ContainerServiceLinuxProfile_STATUS(source *v20210501s.ContainerServiceLinuxProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// Ssh
	if source.Ssh != nil {
		var ssh ContainerServiceSshConfiguration_STATUS
<<<<<<< HEAD
		err := ssh.AssignPropertiesFromContainerServiceSshConfiguration_STATUS(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromContainerServiceSshConfiguration_STATUS() to populate field Ssh")
=======
		err := ssh.AssignProperties_From_ContainerServiceSshConfiguration_STATUS(source.Ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceSshConfiguration_STATUS() to populate field Ssh")
>>>>>>> main
		}
		profile.Ssh = &ssh
	} else {
		profile.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToContainerServiceLinuxProfile_STATUS populates the provided destination ContainerServiceLinuxProfile_STATUS from our ContainerServiceLinuxProfile_STATUS
func (profile *ContainerServiceLinuxProfile_STATUS) AssignPropertiesToContainerServiceLinuxProfile_STATUS(destination *v20210501s.ContainerServiceLinuxProfile_STATUS) error {
=======
// AssignProperties_To_ContainerServiceLinuxProfile_STATUS populates the provided destination ContainerServiceLinuxProfile_STATUS from our ContainerServiceLinuxProfile_STATUS
func (profile *ContainerServiceLinuxProfile_STATUS) AssignProperties_To_ContainerServiceLinuxProfile_STATUS(destination *v20210501s.ContainerServiceLinuxProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// Ssh
	if profile.Ssh != nil {
		var ssh v20210501s.ContainerServiceSshConfiguration_STATUS
<<<<<<< HEAD
		err := profile.Ssh.AssignPropertiesToContainerServiceSshConfiguration_STATUS(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToContainerServiceSshConfiguration_STATUS() to populate field Ssh")
=======
		err := profile.Ssh.AssignProperties_To_ContainerServiceSshConfiguration_STATUS(&ssh)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceSshConfiguration_STATUS() to populate field Ssh")
>>>>>>> main
		}
		destination.Ssh = &ssh
	} else {
		destination.Ssh = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ContainerServiceNetworkProfile
// Deprecated version of ContainerServiceNetworkProfile. Use v1beta20210501.ContainerServiceNetworkProfile instead
type ContainerServiceNetworkProfile struct {
	DnsServiceIP        *string                            `json:"dnsServiceIP,omitempty"`
	DockerBridgeCidr    *string                            `json:"dockerBridgeCidr,omitempty"`
	LoadBalancerProfile *ManagedClusterLoadBalancerProfile `json:"loadBalancerProfile,omitempty"`
	LoadBalancerSku     *string                            `json:"loadBalancerSku,omitempty"`
	NetworkMode         *string                            `json:"networkMode,omitempty"`
	NetworkPlugin       *string                            `json:"networkPlugin,omitempty"`
	NetworkPolicy       *string                            `json:"networkPolicy,omitempty"`
	OutboundType        *string                            `json:"outboundType,omitempty"`
	PodCidr             *string                            `json:"podCidr,omitempty"`
	PropertyBag         genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	ServiceCidr         *string                            `json:"serviceCidr,omitempty"`
}

// AssignProperties_From_ContainerServiceNetworkProfile populates our ContainerServiceNetworkProfile from the provided source ContainerServiceNetworkProfile
func (profile *ContainerServiceNetworkProfile) AssignProperties_From_ContainerServiceNetworkProfile(source *v20210501s.ContainerServiceNetworkProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DnsServiceIP
	profile.DnsServiceIP = genruntime.ClonePointerToString(source.DnsServiceIP)

	// DockerBridgeCidr
	profile.DockerBridgeCidr = genruntime.ClonePointerToString(source.DockerBridgeCidr)

	// LoadBalancerProfile
	if source.LoadBalancerProfile != nil {
		var loadBalancerProfile ManagedClusterLoadBalancerProfile
		err := loadBalancerProfile.AssignProperties_From_ManagedClusterLoadBalancerProfile(source.LoadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile() to populate field LoadBalancerProfile")
		}
		profile.LoadBalancerProfile = &loadBalancerProfile
	} else {
		profile.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	profile.LoadBalancerSku = genruntime.ClonePointerToString(source.LoadBalancerSku)

	// NetworkMode
	profile.NetworkMode = genruntime.ClonePointerToString(source.NetworkMode)

	// NetworkPlugin
	profile.NetworkPlugin = genruntime.ClonePointerToString(source.NetworkPlugin)

	// NetworkPolicy
	profile.NetworkPolicy = genruntime.ClonePointerToString(source.NetworkPolicy)

	// OutboundType
	profile.OutboundType = genruntime.ClonePointerToString(source.OutboundType)

	// PodCidr
	profile.PodCidr = genruntime.ClonePointerToString(source.PodCidr)

	// ServiceCidr
	profile.ServiceCidr = genruntime.ClonePointerToString(source.ServiceCidr)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceNetworkProfile populates the provided destination ContainerServiceNetworkProfile from our ContainerServiceNetworkProfile
func (profile *ContainerServiceNetworkProfile) AssignProperties_To_ContainerServiceNetworkProfile(destination *v20210501s.ContainerServiceNetworkProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// DnsServiceIP
	destination.DnsServiceIP = genruntime.ClonePointerToString(profile.DnsServiceIP)

	// DockerBridgeCidr
	destination.DockerBridgeCidr = genruntime.ClonePointerToString(profile.DockerBridgeCidr)

	// LoadBalancerProfile
	if profile.LoadBalancerProfile != nil {
		var loadBalancerProfile v20210501s.ManagedClusterLoadBalancerProfile
		err := profile.LoadBalancerProfile.AssignProperties_To_ManagedClusterLoadBalancerProfile(&loadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile() to populate field LoadBalancerProfile")
		}
		destination.LoadBalancerProfile = &loadBalancerProfile
	} else {
		destination.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	destination.LoadBalancerSku = genruntime.ClonePointerToString(profile.LoadBalancerSku)

	// NetworkMode
	destination.NetworkMode = genruntime.ClonePointerToString(profile.NetworkMode)

	// NetworkPlugin
	destination.NetworkPlugin = genruntime.ClonePointerToString(profile.NetworkPlugin)

	// NetworkPolicy
	destination.NetworkPolicy = genruntime.ClonePointerToString(profile.NetworkPolicy)

	// OutboundType
	destination.OutboundType = genruntime.ClonePointerToString(profile.OutboundType)

	// PodCidr
	destination.PodCidr = genruntime.ClonePointerToString(profile.PodCidr)

	// ServiceCidr
	destination.ServiceCidr = genruntime.ClonePointerToString(profile.ServiceCidr)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ContainerServiceNetworkProfile_STATUS
// Deprecated version of ContainerServiceNetworkProfile_STATUS. Use v1beta20210501.ContainerServiceNetworkProfile_STATUS instead
type ContainerServiceNetworkProfile_STATUS struct {
	DnsServiceIP        *string                                   `json:"dnsServiceIP,omitempty"`
	DockerBridgeCidr    *string                                   `json:"dockerBridgeCidr,omitempty"`
	LoadBalancerProfile *ManagedClusterLoadBalancerProfile_STATUS `json:"loadBalancerProfile,omitempty"`
	LoadBalancerSku     *string                                   `json:"loadBalancerSku,omitempty"`
	NetworkMode         *string                                   `json:"networkMode,omitempty"`
	NetworkPlugin       *string                                   `json:"networkPlugin,omitempty"`
	NetworkPolicy       *string                                   `json:"networkPolicy,omitempty"`
	OutboundType        *string                                   `json:"outboundType,omitempty"`
	PodCidr             *string                                   `json:"podCidr,omitempty"`
	PropertyBag         genruntime.PropertyBag                    `json:"$propertyBag,omitempty"`
	ServiceCidr         *string                                   `json:"serviceCidr,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromContainerServiceNetworkProfile_STATUS populates our ContainerServiceNetworkProfile_STATUS from the provided source ContainerServiceNetworkProfile_STATUS
func (profile *ContainerServiceNetworkProfile_STATUS) AssignPropertiesFromContainerServiceNetworkProfile_STATUS(source *v20210501s.ContainerServiceNetworkProfile_STATUS) error {
=======
// AssignProperties_From_ContainerServiceNetworkProfile_STATUS populates our ContainerServiceNetworkProfile_STATUS from the provided source ContainerServiceNetworkProfile_STATUS
func (profile *ContainerServiceNetworkProfile_STATUS) AssignProperties_From_ContainerServiceNetworkProfile_STATUS(source *v20210501s.ContainerServiceNetworkProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// DnsServiceIP
	profile.DnsServiceIP = genruntime.ClonePointerToString(source.DnsServiceIP)

	// DockerBridgeCidr
	profile.DockerBridgeCidr = genruntime.ClonePointerToString(source.DockerBridgeCidr)

	// LoadBalancerProfile
	if source.LoadBalancerProfile != nil {
		var loadBalancerProfile ManagedClusterLoadBalancerProfile_STATUS
<<<<<<< HEAD
		err := loadBalancerProfile.AssignPropertiesFromManagedClusterLoadBalancerProfile_STATUS(source.LoadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_STATUS() to populate field LoadBalancerProfile")
=======
		err := loadBalancerProfile.AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS(source.LoadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS() to populate field LoadBalancerProfile")
>>>>>>> main
		}
		profile.LoadBalancerProfile = &loadBalancerProfile
	} else {
		profile.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	profile.LoadBalancerSku = genruntime.ClonePointerToString(source.LoadBalancerSku)

	// NetworkMode
	profile.NetworkMode = genruntime.ClonePointerToString(source.NetworkMode)

	// NetworkPlugin
	profile.NetworkPlugin = genruntime.ClonePointerToString(source.NetworkPlugin)

	// NetworkPolicy
	profile.NetworkPolicy = genruntime.ClonePointerToString(source.NetworkPolicy)

	// OutboundType
	profile.OutboundType = genruntime.ClonePointerToString(source.OutboundType)

	// PodCidr
	profile.PodCidr = genruntime.ClonePointerToString(source.PodCidr)

	// ServiceCidr
	profile.ServiceCidr = genruntime.ClonePointerToString(source.ServiceCidr)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToContainerServiceNetworkProfile_STATUS populates the provided destination ContainerServiceNetworkProfile_STATUS from our ContainerServiceNetworkProfile_STATUS
func (profile *ContainerServiceNetworkProfile_STATUS) AssignPropertiesToContainerServiceNetworkProfile_STATUS(destination *v20210501s.ContainerServiceNetworkProfile_STATUS) error {
=======
// AssignProperties_To_ContainerServiceNetworkProfile_STATUS populates the provided destination ContainerServiceNetworkProfile_STATUS from our ContainerServiceNetworkProfile_STATUS
func (profile *ContainerServiceNetworkProfile_STATUS) AssignProperties_To_ContainerServiceNetworkProfile_STATUS(destination *v20210501s.ContainerServiceNetworkProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// DnsServiceIP
	destination.DnsServiceIP = genruntime.ClonePointerToString(profile.DnsServiceIP)

	// DockerBridgeCidr
	destination.DockerBridgeCidr = genruntime.ClonePointerToString(profile.DockerBridgeCidr)

	// LoadBalancerProfile
	if profile.LoadBalancerProfile != nil {
		var loadBalancerProfile v20210501s.ManagedClusterLoadBalancerProfile_STATUS
<<<<<<< HEAD
		err := profile.LoadBalancerProfile.AssignPropertiesToManagedClusterLoadBalancerProfile_STATUS(&loadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_STATUS() to populate field LoadBalancerProfile")
=======
		err := profile.LoadBalancerProfile.AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS(&loadBalancerProfile)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS() to populate field LoadBalancerProfile")
>>>>>>> main
		}
		destination.LoadBalancerProfile = &loadBalancerProfile
	} else {
		destination.LoadBalancerProfile = nil
	}

	// LoadBalancerSku
	destination.LoadBalancerSku = genruntime.ClonePointerToString(profile.LoadBalancerSku)

	// NetworkMode
	destination.NetworkMode = genruntime.ClonePointerToString(profile.NetworkMode)

	// NetworkPlugin
	destination.NetworkPlugin = genruntime.ClonePointerToString(profile.NetworkPlugin)

	// NetworkPolicy
	destination.NetworkPolicy = genruntime.ClonePointerToString(profile.NetworkPolicy)

	// OutboundType
	destination.OutboundType = genruntime.ClonePointerToString(profile.OutboundType)

	// PodCidr
	destination.PodCidr = genruntime.ClonePointerToString(profile.PodCidr)

	// ServiceCidr
	destination.ServiceCidr = genruntime.ClonePointerToString(profile.ServiceCidr)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ExtendedLocation
// Deprecated version of ExtendedLocation. Use v1beta20210501.ExtendedLocation instead
type ExtendedLocation struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_ExtendedLocation populates our ExtendedLocation from the provided source ExtendedLocation
func (location *ExtendedLocation) AssignProperties_From_ExtendedLocation(source *v20210501s.ExtendedLocation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	location.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		location.PropertyBag = propertyBag
	} else {
		location.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ExtendedLocation populates the provided destination ExtendedLocation from our ExtendedLocation
func (location *ExtendedLocation) AssignProperties_To_ExtendedLocation(destination *v20210501s.ExtendedLocation) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(location.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(location.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ExtendedLocation_STATUS
// Deprecated version of ExtendedLocation_STATUS. Use v1beta20210501.ExtendedLocation_STATUS instead
type ExtendedLocation_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromExtendedLocation_STATUS populates our ExtendedLocation_STATUS from the provided source ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignPropertiesFromExtendedLocation_STATUS(source *v20210501s.ExtendedLocation_STATUS) error {
=======
// AssignProperties_From_ExtendedLocation_STATUS populates our ExtendedLocation_STATUS from the provided source ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_From_ExtendedLocation_STATUS(source *v20210501s.ExtendedLocation_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	location.Name = genruntime.ClonePointerToString(source.Name)

	// Type
	location.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		location.PropertyBag = propertyBag
	} else {
		location.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToExtendedLocation_STATUS populates the provided destination ExtendedLocation_STATUS from our ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignPropertiesToExtendedLocation_STATUS(destination *v20210501s.ExtendedLocation_STATUS) error {
=======
// AssignProperties_To_ExtendedLocation_STATUS populates the provided destination ExtendedLocation_STATUS from our ExtendedLocation_STATUS
func (location *ExtendedLocation_STATUS) AssignProperties_To_ExtendedLocation_STATUS(destination *v20210501s.ExtendedLocation_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(location.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(location.Name)

	// Type
	destination.Type = genruntime.ClonePointerToString(location.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterAADProfile
// Deprecated version of ManagedClusterAADProfile. Use v1beta20210501.ManagedClusterAADProfile instead
type ManagedClusterAADProfile struct {
	AdminGroupObjectIDs []string               `json:"adminGroupObjectIDs,omitempty"`
	ClientAppID         *string                `json:"clientAppID,omitempty"`
	EnableAzureRBAC     *bool                  `json:"enableAzureRBAC,omitempty"`
	Managed             *bool                  `json:"managed,omitempty"`
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ServerAppID         *string                `json:"serverAppID,omitempty"`
	ServerAppSecret     *string                `json:"serverAppSecret,omitempty"`
	TenantID            *string                `json:"tenantID,omitempty"`
}

// AssignProperties_From_ManagedClusterAADProfile populates our ManagedClusterAADProfile from the provided source ManagedClusterAADProfile
func (profile *ManagedClusterAADProfile) AssignProperties_From_ManagedClusterAADProfile(source *v20210501s.ManagedClusterAADProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminGroupObjectIDs
	profile.AdminGroupObjectIDs = genruntime.CloneSliceOfString(source.AdminGroupObjectIDs)

	// ClientAppID
	profile.ClientAppID = genruntime.ClonePointerToString(source.ClientAppID)

	// EnableAzureRBAC
	if source.EnableAzureRBAC != nil {
		enableAzureRBAC := *source.EnableAzureRBAC
		profile.EnableAzureRBAC = &enableAzureRBAC
	} else {
		profile.EnableAzureRBAC = nil
	}

	// Managed
	if source.Managed != nil {
		managed := *source.Managed
		profile.Managed = &managed
	} else {
		profile.Managed = nil
	}

	// ServerAppID
	profile.ServerAppID = genruntime.ClonePointerToString(source.ServerAppID)

	// ServerAppSecret
	profile.ServerAppSecret = genruntime.ClonePointerToString(source.ServerAppSecret)

	// TenantID
	profile.TenantID = genruntime.ClonePointerToString(source.TenantID)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAADProfile populates the provided destination ManagedClusterAADProfile from our ManagedClusterAADProfile
func (profile *ManagedClusterAADProfile) AssignProperties_To_ManagedClusterAADProfile(destination *v20210501s.ManagedClusterAADProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AdminGroupObjectIDs
	destination.AdminGroupObjectIDs = genruntime.CloneSliceOfString(profile.AdminGroupObjectIDs)

	// ClientAppID
	destination.ClientAppID = genruntime.ClonePointerToString(profile.ClientAppID)

	// EnableAzureRBAC
	if profile.EnableAzureRBAC != nil {
		enableAzureRBAC := *profile.EnableAzureRBAC
		destination.EnableAzureRBAC = &enableAzureRBAC
	} else {
		destination.EnableAzureRBAC = nil
	}

	// Managed
	if profile.Managed != nil {
		managed := *profile.Managed
		destination.Managed = &managed
	} else {
		destination.Managed = nil
	}

	// ServerAppID
	destination.ServerAppID = genruntime.ClonePointerToString(profile.ServerAppID)

	// ServerAppSecret
	destination.ServerAppSecret = genruntime.ClonePointerToString(profile.ServerAppSecret)

	// TenantID
	destination.TenantID = genruntime.ClonePointerToString(profile.TenantID)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterAADProfile_STATUS
// Deprecated version of ManagedClusterAADProfile_STATUS. Use v1beta20210501.ManagedClusterAADProfile_STATUS instead
type ManagedClusterAADProfile_STATUS struct {
	AdminGroupObjectIDs []string               `json:"adminGroupObjectIDs,omitempty"`
	ClientAppID         *string                `json:"clientAppID,omitempty"`
	EnableAzureRBAC     *bool                  `json:"enableAzureRBAC,omitempty"`
	Managed             *bool                  `json:"managed,omitempty"`
	PropertyBag         genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ServerAppID         *string                `json:"serverAppID,omitempty"`
	ServerAppSecret     *string                `json:"serverAppSecret,omitempty"`
	TenantID            *string                `json:"tenantID,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterAADProfile_STATUS populates our ManagedClusterAADProfile_STATUS from the provided source ManagedClusterAADProfile_STATUS
func (profile *ManagedClusterAADProfile_STATUS) AssignPropertiesFromManagedClusterAADProfile_STATUS(source *v20210501s.ManagedClusterAADProfile_STATUS) error {
=======
// AssignProperties_From_ManagedClusterAADProfile_STATUS populates our ManagedClusterAADProfile_STATUS from the provided source ManagedClusterAADProfile_STATUS
func (profile *ManagedClusterAADProfile_STATUS) AssignProperties_From_ManagedClusterAADProfile_STATUS(source *v20210501s.ManagedClusterAADProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminGroupObjectIDs
	profile.AdminGroupObjectIDs = genruntime.CloneSliceOfString(source.AdminGroupObjectIDs)

	// ClientAppID
	profile.ClientAppID = genruntime.ClonePointerToString(source.ClientAppID)

	// EnableAzureRBAC
	if source.EnableAzureRBAC != nil {
		enableAzureRBAC := *source.EnableAzureRBAC
		profile.EnableAzureRBAC = &enableAzureRBAC
	} else {
		profile.EnableAzureRBAC = nil
	}

	// Managed
	if source.Managed != nil {
		managed := *source.Managed
		profile.Managed = &managed
	} else {
		profile.Managed = nil
	}

	// ServerAppID
	profile.ServerAppID = genruntime.ClonePointerToString(source.ServerAppID)

	// ServerAppSecret
	profile.ServerAppSecret = genruntime.ClonePointerToString(source.ServerAppSecret)

	// TenantID
	profile.TenantID = genruntime.ClonePointerToString(source.TenantID)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterAADProfile_STATUS populates the provided destination ManagedClusterAADProfile_STATUS from our ManagedClusterAADProfile_STATUS
func (profile *ManagedClusterAADProfile_STATUS) AssignPropertiesToManagedClusterAADProfile_STATUS(destination *v20210501s.ManagedClusterAADProfile_STATUS) error {
=======
// AssignProperties_To_ManagedClusterAADProfile_STATUS populates the provided destination ManagedClusterAADProfile_STATUS from our ManagedClusterAADProfile_STATUS
func (profile *ManagedClusterAADProfile_STATUS) AssignProperties_To_ManagedClusterAADProfile_STATUS(destination *v20210501s.ManagedClusterAADProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AdminGroupObjectIDs
	destination.AdminGroupObjectIDs = genruntime.CloneSliceOfString(profile.AdminGroupObjectIDs)

	// ClientAppID
	destination.ClientAppID = genruntime.ClonePointerToString(profile.ClientAppID)

	// EnableAzureRBAC
	if profile.EnableAzureRBAC != nil {
		enableAzureRBAC := *profile.EnableAzureRBAC
		destination.EnableAzureRBAC = &enableAzureRBAC
	} else {
		destination.EnableAzureRBAC = nil
	}

	// Managed
	if profile.Managed != nil {
		managed := *profile.Managed
		destination.Managed = &managed
	} else {
		destination.Managed = nil
	}

	// ServerAppID
	destination.ServerAppID = genruntime.ClonePointerToString(profile.ServerAppID)

	// ServerAppSecret
	destination.ServerAppSecret = genruntime.ClonePointerToString(profile.ServerAppSecret)

	// TenantID
	destination.TenantID = genruntime.ClonePointerToString(profile.TenantID)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
=======
// Storage version of v1alpha1api20210501.ManagedClusterAddonProfile
// Deprecated version of ManagedClusterAddonProfile. Use v1beta20210501.ManagedClusterAddonProfile instead
type ManagedClusterAddonProfile struct {
	Config      map[string]string      `json:"config,omitempty"`
	Enabled     *bool                  `json:"enabled,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ManagedClusterAddonProfile populates our ManagedClusterAddonProfile from the provided source ManagedClusterAddonProfile
func (profile *ManagedClusterAddonProfile) AssignProperties_From_ManagedClusterAddonProfile(source *v20210501s.ManagedClusterAddonProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Config
	profile.Config = genruntime.CloneMapOfStringToString(source.Config)

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAddonProfile populates the provided destination ManagedClusterAddonProfile from our ManagedClusterAddonProfile
func (profile *ManagedClusterAddonProfile) AssignProperties_To_ManagedClusterAddonProfile(destination *v20210501s.ManagedClusterAddonProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// Config
	destination.Config = genruntime.CloneMapOfStringToString(profile.Config)

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

>>>>>>> main
// Storage version of v1alpha1api20210501.ManagedClusterAgentPoolProfile
// Deprecated version of ManagedClusterAgentPoolProfile. Use v1beta20210501.ManagedClusterAgentPoolProfile instead
type ManagedClusterAgentPoolProfile struct {
	AvailabilityZones             []string                      `json:"availabilityZones,omitempty"`
	Count                         *int                          `json:"count,omitempty"`
	EnableAutoScaling             *bool                         `json:"enableAutoScaling,omitempty"`
	EnableEncryptionAtHost        *bool                         `json:"enableEncryptionAtHost,omitempty"`
	EnableFIPS                    *bool                         `json:"enableFIPS,omitempty"`
	EnableNodePublicIP            *bool                         `json:"enableNodePublicIP,omitempty"`
	EnableUltraSSD                *bool                         `json:"enableUltraSSD,omitempty"`
	GpuInstanceProfile            *string                       `json:"gpuInstanceProfile,omitempty"`
	KubeletConfig                 *KubeletConfig                `json:"kubeletConfig,omitempty"`
	KubeletDiskType               *string                       `json:"kubeletDiskType,omitempty"`
	LinuxOSConfig                 *LinuxOSConfig                `json:"linuxOSConfig,omitempty"`
	MaxCount                      *int                          `json:"maxCount,omitempty"`
	MaxPods                       *int                          `json:"maxPods,omitempty"`
	MinCount                      *int                          `json:"minCount,omitempty"`
	Mode                          *string                       `json:"mode,omitempty"`
	Name                          *string                       `json:"name,omitempty"`
	NodeLabels                    map[string]string             `json:"nodeLabels,omitempty"`
	NodePublicIPPrefixIDReference *genruntime.ResourceReference `armReference:"NodePublicIPPrefixID" json:"nodePublicIPPrefixIDReference,omitempty"`
	NodeTaints                    []string                      `json:"nodeTaints,omitempty"`
	OrchestratorVersion           *string                       `json:"orchestratorVersion,omitempty"`
	OsDiskSizeGB                  *int                          `json:"osDiskSizeGB,omitempty"`
	OsDiskType                    *string                       `json:"osDiskType,omitempty"`
	OsSKU                         *string                       `json:"osSKU,omitempty"`
	OsType                        *string                       `json:"osType,omitempty"`
	PodSubnetIDReference          *genruntime.ResourceReference `armReference:"PodSubnetID" json:"podSubnetIDReference,omitempty"`
	PropertyBag                   genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	ProximityPlacementGroupID     *string                       `json:"proximityPlacementGroupID,omitempty"`
	ScaleSetEvictionPolicy        *string                       `json:"scaleSetEvictionPolicy,omitempty"`
	ScaleSetPriority              *string                       `json:"scaleSetPriority,omitempty"`
	SpotMaxPrice                  *float64                      `json:"spotMaxPrice,omitempty"`
	Tags                          map[string]string             `json:"tags,omitempty"`
	Type                          *string                       `json:"type,omitempty"`
	UpgradeSettings               *AgentPoolUpgradeSettings     `json:"upgradeSettings,omitempty"`
	VmSize                        *string                       `json:"vmSize,omitempty"`
	VnetSubnetIDReference         *genruntime.ResourceReference `armReference:"VnetSubnetID" json:"vnetSubnetIDReference,omitempty"`
}

// AssignProperties_From_ManagedClusterAgentPoolProfile populates our ManagedClusterAgentPoolProfile from the provided source ManagedClusterAgentPoolProfile
func (profile *ManagedClusterAgentPoolProfile) AssignProperties_From_ManagedClusterAgentPoolProfile(source *v20210501s.ManagedClusterAgentPoolProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AvailabilityZones
	profile.AvailabilityZones = genruntime.CloneSliceOfString(source.AvailabilityZones)

	// Count
	profile.Count = genruntime.ClonePointerToInt(source.Count)

	// EnableAutoScaling
	if source.EnableAutoScaling != nil {
		enableAutoScaling := *source.EnableAutoScaling
		profile.EnableAutoScaling = &enableAutoScaling
	} else {
		profile.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if source.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *source.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		profile.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if source.EnableFIPS != nil {
		enableFIPS := *source.EnableFIPS
		profile.EnableFIPS = &enableFIPS
	} else {
		profile.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if source.EnableNodePublicIP != nil {
		enableNodePublicIP := *source.EnableNodePublicIP
		profile.EnableNodePublicIP = &enableNodePublicIP
	} else {
		profile.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if source.EnableUltraSSD != nil {
		enableUltraSSD := *source.EnableUltraSSD
		profile.EnableUltraSSD = &enableUltraSSD
	} else {
		profile.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	profile.GpuInstanceProfile = genruntime.ClonePointerToString(source.GpuInstanceProfile)

	// KubeletConfig
	if source.KubeletConfig != nil {
		var kubeletConfig KubeletConfig
		err := kubeletConfig.AssignProperties_From_KubeletConfig(source.KubeletConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KubeletConfig() to populate field KubeletConfig")
		}
		profile.KubeletConfig = &kubeletConfig
	} else {
		profile.KubeletConfig = nil
	}

	// KubeletDiskType
	profile.KubeletDiskType = genruntime.ClonePointerToString(source.KubeletDiskType)

	// LinuxOSConfig
	if source.LinuxOSConfig != nil {
		var linuxOSConfig LinuxOSConfig
		err := linuxOSConfig.AssignProperties_From_LinuxOSConfig(source.LinuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxOSConfig() to populate field LinuxOSConfig")
		}
		profile.LinuxOSConfig = &linuxOSConfig
	} else {
		profile.LinuxOSConfig = nil
	}

	// MaxCount
	profile.MaxCount = genruntime.ClonePointerToInt(source.MaxCount)

	// MaxPods
	profile.MaxPods = genruntime.ClonePointerToInt(source.MaxPods)

	// MinCount
	profile.MinCount = genruntime.ClonePointerToInt(source.MinCount)

	// Mode
	profile.Mode = genruntime.ClonePointerToString(source.Mode)

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// NodeLabels
	profile.NodeLabels = genruntime.CloneMapOfStringToString(source.NodeLabels)

	// NodePublicIPPrefixIDReference
	if source.NodePublicIPPrefixIDReference != nil {
		nodePublicIPPrefixIDReference := source.NodePublicIPPrefixIDReference.Copy()
		profile.NodePublicIPPrefixIDReference = &nodePublicIPPrefixIDReference
	} else {
		profile.NodePublicIPPrefixIDReference = nil
	}

	// NodeTaints
	profile.NodeTaints = genruntime.CloneSliceOfString(source.NodeTaints)

	// OrchestratorVersion
	profile.OrchestratorVersion = genruntime.ClonePointerToString(source.OrchestratorVersion)

	// OsDiskSizeGB
	profile.OsDiskSizeGB = genruntime.ClonePointerToInt(source.OsDiskSizeGB)

	// OsDiskType
	profile.OsDiskType = genruntime.ClonePointerToString(source.OsDiskType)

	// OsSKU
	profile.OsSKU = genruntime.ClonePointerToString(source.OsSKU)

	// OsType
	profile.OsType = genruntime.ClonePointerToString(source.OsType)

	// PodSubnetIDReference
	if source.PodSubnetIDReference != nil {
		podSubnetIDReference := source.PodSubnetIDReference.Copy()
		profile.PodSubnetIDReference = &podSubnetIDReference
	} else {
		profile.PodSubnetIDReference = nil
	}

	// ProximityPlacementGroupID
	profile.ProximityPlacementGroupID = genruntime.ClonePointerToString(source.ProximityPlacementGroupID)

	// ScaleSetEvictionPolicy
	profile.ScaleSetEvictionPolicy = genruntime.ClonePointerToString(source.ScaleSetEvictionPolicy)

	// ScaleSetPriority
	profile.ScaleSetPriority = genruntime.ClonePointerToString(source.ScaleSetPriority)

	// SpotMaxPrice
	if source.SpotMaxPrice != nil {
		spotMaxPrice := *source.SpotMaxPrice
		profile.SpotMaxPrice = &spotMaxPrice
	} else {
		profile.SpotMaxPrice = nil
	}

	// Tags
	profile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	profile.Type = genruntime.ClonePointerToString(source.Type)

	// UpgradeSettings
	if source.UpgradeSettings != nil {
		var upgradeSetting AgentPoolUpgradeSettings
		err := upgradeSetting.AssignProperties_From_AgentPoolUpgradeSettings(source.UpgradeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AgentPoolUpgradeSettings() to populate field UpgradeSettings")
		}
		profile.UpgradeSettings = &upgradeSetting
	} else {
		profile.UpgradeSettings = nil
	}

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VnetSubnetIDReference
	if source.VnetSubnetIDReference != nil {
		vnetSubnetIDReference := source.VnetSubnetIDReference.Copy()
		profile.VnetSubnetIDReference = &vnetSubnetIDReference
	} else {
		profile.VnetSubnetIDReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAgentPoolProfile populates the provided destination ManagedClusterAgentPoolProfile from our ManagedClusterAgentPoolProfile
func (profile *ManagedClusterAgentPoolProfile) AssignProperties_To_ManagedClusterAgentPoolProfile(destination *v20210501s.ManagedClusterAgentPoolProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AvailabilityZones
	destination.AvailabilityZones = genruntime.CloneSliceOfString(profile.AvailabilityZones)

	// Count
	destination.Count = genruntime.ClonePointerToInt(profile.Count)

	// EnableAutoScaling
	if profile.EnableAutoScaling != nil {
		enableAutoScaling := *profile.EnableAutoScaling
		destination.EnableAutoScaling = &enableAutoScaling
	} else {
		destination.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if profile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *profile.EnableEncryptionAtHost
		destination.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		destination.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if profile.EnableFIPS != nil {
		enableFIPS := *profile.EnableFIPS
		destination.EnableFIPS = &enableFIPS
	} else {
		destination.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if profile.EnableNodePublicIP != nil {
		enableNodePublicIP := *profile.EnableNodePublicIP
		destination.EnableNodePublicIP = &enableNodePublicIP
	} else {
		destination.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if profile.EnableUltraSSD != nil {
		enableUltraSSD := *profile.EnableUltraSSD
		destination.EnableUltraSSD = &enableUltraSSD
	} else {
		destination.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	destination.GpuInstanceProfile = genruntime.ClonePointerToString(profile.GpuInstanceProfile)

	// KubeletConfig
	if profile.KubeletConfig != nil {
		var kubeletConfig v20210501s.KubeletConfig
		err := profile.KubeletConfig.AssignProperties_To_KubeletConfig(&kubeletConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KubeletConfig() to populate field KubeletConfig")
		}
		destination.KubeletConfig = &kubeletConfig
	} else {
		destination.KubeletConfig = nil
	}

	// KubeletDiskType
	destination.KubeletDiskType = genruntime.ClonePointerToString(profile.KubeletDiskType)

	// LinuxOSConfig
	if profile.LinuxOSConfig != nil {
		var linuxOSConfig v20210501s.LinuxOSConfig
		err := profile.LinuxOSConfig.AssignProperties_To_LinuxOSConfig(&linuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxOSConfig() to populate field LinuxOSConfig")
		}
		destination.LinuxOSConfig = &linuxOSConfig
	} else {
		destination.LinuxOSConfig = nil
	}

	// MaxCount
	destination.MaxCount = genruntime.ClonePointerToInt(profile.MaxCount)

	// MaxPods
	destination.MaxPods = genruntime.ClonePointerToInt(profile.MaxPods)

	// MinCount
	destination.MinCount = genruntime.ClonePointerToInt(profile.MinCount)

	// Mode
	destination.Mode = genruntime.ClonePointerToString(profile.Mode)

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// NodeLabels
	destination.NodeLabels = genruntime.CloneMapOfStringToString(profile.NodeLabels)

	// NodePublicIPPrefixIDReference
	if profile.NodePublicIPPrefixIDReference != nil {
		nodePublicIPPrefixIDReference := profile.NodePublicIPPrefixIDReference.Copy()
		destination.NodePublicIPPrefixIDReference = &nodePublicIPPrefixIDReference
	} else {
		destination.NodePublicIPPrefixIDReference = nil
	}

	// NodeTaints
	destination.NodeTaints = genruntime.CloneSliceOfString(profile.NodeTaints)

	// OrchestratorVersion
	destination.OrchestratorVersion = genruntime.ClonePointerToString(profile.OrchestratorVersion)

	// OsDiskSizeGB
	destination.OsDiskSizeGB = genruntime.ClonePointerToInt(profile.OsDiskSizeGB)

	// OsDiskType
	destination.OsDiskType = genruntime.ClonePointerToString(profile.OsDiskType)

	// OsSKU
	destination.OsSKU = genruntime.ClonePointerToString(profile.OsSKU)

	// OsType
	destination.OsType = genruntime.ClonePointerToString(profile.OsType)

	// PodSubnetIDReference
	if profile.PodSubnetIDReference != nil {
		podSubnetIDReference := profile.PodSubnetIDReference.Copy()
		destination.PodSubnetIDReference = &podSubnetIDReference
	} else {
		destination.PodSubnetIDReference = nil
	}

	// ProximityPlacementGroupID
	destination.ProximityPlacementGroupID = genruntime.ClonePointerToString(profile.ProximityPlacementGroupID)

	// ScaleSetEvictionPolicy
	destination.ScaleSetEvictionPolicy = genruntime.ClonePointerToString(profile.ScaleSetEvictionPolicy)

	// ScaleSetPriority
	destination.ScaleSetPriority = genruntime.ClonePointerToString(profile.ScaleSetPriority)

	// SpotMaxPrice
	if profile.SpotMaxPrice != nil {
		spotMaxPrice := *profile.SpotMaxPrice
		destination.SpotMaxPrice = &spotMaxPrice
	} else {
		destination.SpotMaxPrice = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(profile.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(profile.Type)

	// UpgradeSettings
	if profile.UpgradeSettings != nil {
		var upgradeSetting v20210501s.AgentPoolUpgradeSettings
		err := profile.UpgradeSettings.AssignProperties_To_AgentPoolUpgradeSettings(&upgradeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AgentPoolUpgradeSettings() to populate field UpgradeSettings")
		}
		destination.UpgradeSettings = &upgradeSetting
	} else {
		destination.UpgradeSettings = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VnetSubnetIDReference
	if profile.VnetSubnetIDReference != nil {
		vnetSubnetIDReference := profile.VnetSubnetIDReference.Copy()
		destination.VnetSubnetIDReference = &vnetSubnetIDReference
	} else {
		destination.VnetSubnetIDReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterAgentPoolProfile_STATUS
// Deprecated version of ManagedClusterAgentPoolProfile_STATUS. Use v1beta20210501.ManagedClusterAgentPoolProfile_STATUS instead
type ManagedClusterAgentPoolProfile_STATUS struct {
	AvailabilityZones         []string                         `json:"availabilityZones,omitempty"`
	Count                     *int                             `json:"count,omitempty"`
	EnableAutoScaling         *bool                            `json:"enableAutoScaling,omitempty"`
	EnableEncryptionAtHost    *bool                            `json:"enableEncryptionAtHost,omitempty"`
	EnableFIPS                *bool                            `json:"enableFIPS,omitempty"`
	EnableNodePublicIP        *bool                            `json:"enableNodePublicIP,omitempty"`
	EnableUltraSSD            *bool                            `json:"enableUltraSSD,omitempty"`
	GpuInstanceProfile        *string                          `json:"gpuInstanceProfile,omitempty"`
	KubeletConfig             *KubeletConfig_STATUS            `json:"kubeletConfig,omitempty"`
	KubeletDiskType           *string                          `json:"kubeletDiskType,omitempty"`
	LinuxOSConfig             *LinuxOSConfig_STATUS            `json:"linuxOSConfig,omitempty"`
	MaxCount                  *int                             `json:"maxCount,omitempty"`
	MaxPods                   *int                             `json:"maxPods,omitempty"`
	MinCount                  *int                             `json:"minCount,omitempty"`
	Mode                      *string                          `json:"mode,omitempty"`
	Name                      *string                          `json:"name,omitempty"`
	NodeImageVersion          *string                          `json:"nodeImageVersion,omitempty"`
	NodeLabels                map[string]string                `json:"nodeLabels,omitempty"`
	NodePublicIPPrefixID      *string                          `json:"nodePublicIPPrefixID,omitempty"`
	NodeTaints                []string                         `json:"nodeTaints,omitempty"`
	OrchestratorVersion       *string                          `json:"orchestratorVersion,omitempty"`
	OsDiskSizeGB              *int                             `json:"osDiskSizeGB,omitempty"`
	OsDiskType                *string                          `json:"osDiskType,omitempty"`
	OsSKU                     *string                          `json:"osSKU,omitempty"`
	OsType                    *string                          `json:"osType,omitempty"`
	PodSubnetID               *string                          `json:"podSubnetID,omitempty"`
	PowerState                *PowerState_STATUS               `json:"powerState,omitempty"`
	PropertyBag               genruntime.PropertyBag           `json:"$propertyBag,omitempty"`
	ProvisioningState         *string                          `json:"provisioningState,omitempty"`
	ProximityPlacementGroupID *string                          `json:"proximityPlacementGroupID,omitempty"`
	ScaleSetEvictionPolicy    *string                          `json:"scaleSetEvictionPolicy,omitempty"`
	ScaleSetPriority          *string                          `json:"scaleSetPriority,omitempty"`
	SpotMaxPrice              *float64                         `json:"spotMaxPrice,omitempty"`
	Tags                      map[string]string                `json:"tags,omitempty"`
	Type                      *string                          `json:"type,omitempty"`
	UpgradeSettings           *AgentPoolUpgradeSettings_STATUS `json:"upgradeSettings,omitempty"`
	VmSize                    *string                          `json:"vmSize,omitempty"`
	VnetSubnetID              *string                          `json:"vnetSubnetID,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterAgentPoolProfile_STATUS populates our ManagedClusterAgentPoolProfile_STATUS from the provided source ManagedClusterAgentPoolProfile_STATUS
func (profile *ManagedClusterAgentPoolProfile_STATUS) AssignPropertiesFromManagedClusterAgentPoolProfile_STATUS(source *v20210501s.ManagedClusterAgentPoolProfile_STATUS) error {
=======
// AssignProperties_From_ManagedClusterAgentPoolProfile_STATUS populates our ManagedClusterAgentPoolProfile_STATUS from the provided source ManagedClusterAgentPoolProfile_STATUS
func (profile *ManagedClusterAgentPoolProfile_STATUS) AssignProperties_From_ManagedClusterAgentPoolProfile_STATUS(source *v20210501s.ManagedClusterAgentPoolProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AvailabilityZones
	profile.AvailabilityZones = genruntime.CloneSliceOfString(source.AvailabilityZones)

	// Count
	profile.Count = genruntime.ClonePointerToInt(source.Count)

	// EnableAutoScaling
	if source.EnableAutoScaling != nil {
		enableAutoScaling := *source.EnableAutoScaling
		profile.EnableAutoScaling = &enableAutoScaling
	} else {
		profile.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if source.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *source.EnableEncryptionAtHost
		profile.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		profile.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if source.EnableFIPS != nil {
		enableFIPS := *source.EnableFIPS
		profile.EnableFIPS = &enableFIPS
	} else {
		profile.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if source.EnableNodePublicIP != nil {
		enableNodePublicIP := *source.EnableNodePublicIP
		profile.EnableNodePublicIP = &enableNodePublicIP
	} else {
		profile.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if source.EnableUltraSSD != nil {
		enableUltraSSD := *source.EnableUltraSSD
		profile.EnableUltraSSD = &enableUltraSSD
	} else {
		profile.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	profile.GpuInstanceProfile = genruntime.ClonePointerToString(source.GpuInstanceProfile)

	// KubeletConfig
	if source.KubeletConfig != nil {
		var kubeletConfig KubeletConfig_STATUS
<<<<<<< HEAD
		err := kubeletConfig.AssignPropertiesFromKubeletConfig_STATUS(source.KubeletConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromKubeletConfig_STATUS() to populate field KubeletConfig")
=======
		err := kubeletConfig.AssignProperties_From_KubeletConfig_STATUS(source.KubeletConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_KubeletConfig_STATUS() to populate field KubeletConfig")
>>>>>>> main
		}
		profile.KubeletConfig = &kubeletConfig
	} else {
		profile.KubeletConfig = nil
	}

	// KubeletDiskType
	profile.KubeletDiskType = genruntime.ClonePointerToString(source.KubeletDiskType)

	// LinuxOSConfig
	if source.LinuxOSConfig != nil {
		var linuxOSConfig LinuxOSConfig_STATUS
<<<<<<< HEAD
		err := linuxOSConfig.AssignPropertiesFromLinuxOSConfig_STATUS(source.LinuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromLinuxOSConfig_STATUS() to populate field LinuxOSConfig")
=======
		err := linuxOSConfig.AssignProperties_From_LinuxOSConfig_STATUS(source.LinuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_LinuxOSConfig_STATUS() to populate field LinuxOSConfig")
>>>>>>> main
		}
		profile.LinuxOSConfig = &linuxOSConfig
	} else {
		profile.LinuxOSConfig = nil
	}

	// MaxCount
	profile.MaxCount = genruntime.ClonePointerToInt(source.MaxCount)

	// MaxPods
	profile.MaxPods = genruntime.ClonePointerToInt(source.MaxPods)

	// MinCount
	profile.MinCount = genruntime.ClonePointerToInt(source.MinCount)

	// Mode
	profile.Mode = genruntime.ClonePointerToString(source.Mode)

	// Name
	profile.Name = genruntime.ClonePointerToString(source.Name)

	// NodeImageVersion
	profile.NodeImageVersion = genruntime.ClonePointerToString(source.NodeImageVersion)

	// NodeLabels
	profile.NodeLabels = genruntime.CloneMapOfStringToString(source.NodeLabels)

	// NodePublicIPPrefixID
	profile.NodePublicIPPrefixID = genruntime.ClonePointerToString(source.NodePublicIPPrefixID)

	// NodeTaints
	profile.NodeTaints = genruntime.CloneSliceOfString(source.NodeTaints)

	// OrchestratorVersion
	profile.OrchestratorVersion = genruntime.ClonePointerToString(source.OrchestratorVersion)

	// OsDiskSizeGB
	profile.OsDiskSizeGB = genruntime.ClonePointerToInt(source.OsDiskSizeGB)

	// OsDiskType
	profile.OsDiskType = genruntime.ClonePointerToString(source.OsDiskType)

	// OsSKU
	profile.OsSKU = genruntime.ClonePointerToString(source.OsSKU)

	// OsType
	profile.OsType = genruntime.ClonePointerToString(source.OsType)

	// PodSubnetID
	profile.PodSubnetID = genruntime.ClonePointerToString(source.PodSubnetID)

	// PowerState
	if source.PowerState != nil {
		var powerState PowerState_STATUS
<<<<<<< HEAD
		err := powerState.AssignPropertiesFromPowerState_STATUS(source.PowerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromPowerState_STATUS() to populate field PowerState")
=======
		err := powerState.AssignProperties_From_PowerState_STATUS(source.PowerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_PowerState_STATUS() to populate field PowerState")
>>>>>>> main
		}
		profile.PowerState = &powerState
	} else {
		profile.PowerState = nil
	}

	// ProvisioningState
	profile.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// ProximityPlacementGroupID
	profile.ProximityPlacementGroupID = genruntime.ClonePointerToString(source.ProximityPlacementGroupID)

	// ScaleSetEvictionPolicy
	profile.ScaleSetEvictionPolicy = genruntime.ClonePointerToString(source.ScaleSetEvictionPolicy)

	// ScaleSetPriority
	profile.ScaleSetPriority = genruntime.ClonePointerToString(source.ScaleSetPriority)

	// SpotMaxPrice
	if source.SpotMaxPrice != nil {
		spotMaxPrice := *source.SpotMaxPrice
		profile.SpotMaxPrice = &spotMaxPrice
	} else {
		profile.SpotMaxPrice = nil
	}

	// Tags
	profile.Tags = genruntime.CloneMapOfStringToString(source.Tags)

	// Type
	profile.Type = genruntime.ClonePointerToString(source.Type)

	// UpgradeSettings
	if source.UpgradeSettings != nil {
		var upgradeSetting AgentPoolUpgradeSettings_STATUS
<<<<<<< HEAD
		err := upgradeSetting.AssignPropertiesFromAgentPoolUpgradeSettings_STATUS(source.UpgradeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromAgentPoolUpgradeSettings_STATUS() to populate field UpgradeSettings")
=======
		err := upgradeSetting.AssignProperties_From_AgentPoolUpgradeSettings_STATUS(source.UpgradeSettings)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_AgentPoolUpgradeSettings_STATUS() to populate field UpgradeSettings")
>>>>>>> main
		}
		profile.UpgradeSettings = &upgradeSetting
	} else {
		profile.UpgradeSettings = nil
	}

	// VmSize
	profile.VmSize = genruntime.ClonePointerToString(source.VmSize)

	// VnetSubnetID
	profile.VnetSubnetID = genruntime.ClonePointerToString(source.VnetSubnetID)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterAgentPoolProfile_STATUS populates the provided destination ManagedClusterAgentPoolProfile_STATUS from our ManagedClusterAgentPoolProfile_STATUS
func (profile *ManagedClusterAgentPoolProfile_STATUS) AssignPropertiesToManagedClusterAgentPoolProfile_STATUS(destination *v20210501s.ManagedClusterAgentPoolProfile_STATUS) error {
=======
// AssignProperties_To_ManagedClusterAgentPoolProfile_STATUS populates the provided destination ManagedClusterAgentPoolProfile_STATUS from our ManagedClusterAgentPoolProfile_STATUS
func (profile *ManagedClusterAgentPoolProfile_STATUS) AssignProperties_To_ManagedClusterAgentPoolProfile_STATUS(destination *v20210501s.ManagedClusterAgentPoolProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AvailabilityZones
	destination.AvailabilityZones = genruntime.CloneSliceOfString(profile.AvailabilityZones)

	// Count
	destination.Count = genruntime.ClonePointerToInt(profile.Count)

	// EnableAutoScaling
	if profile.EnableAutoScaling != nil {
		enableAutoScaling := *profile.EnableAutoScaling
		destination.EnableAutoScaling = &enableAutoScaling
	} else {
		destination.EnableAutoScaling = nil
	}

	// EnableEncryptionAtHost
	if profile.EnableEncryptionAtHost != nil {
		enableEncryptionAtHost := *profile.EnableEncryptionAtHost
		destination.EnableEncryptionAtHost = &enableEncryptionAtHost
	} else {
		destination.EnableEncryptionAtHost = nil
	}

	// EnableFIPS
	if profile.EnableFIPS != nil {
		enableFIPS := *profile.EnableFIPS
		destination.EnableFIPS = &enableFIPS
	} else {
		destination.EnableFIPS = nil
	}

	// EnableNodePublicIP
	if profile.EnableNodePublicIP != nil {
		enableNodePublicIP := *profile.EnableNodePublicIP
		destination.EnableNodePublicIP = &enableNodePublicIP
	} else {
		destination.EnableNodePublicIP = nil
	}

	// EnableUltraSSD
	if profile.EnableUltraSSD != nil {
		enableUltraSSD := *profile.EnableUltraSSD
		destination.EnableUltraSSD = &enableUltraSSD
	} else {
		destination.EnableUltraSSD = nil
	}

	// GpuInstanceProfile
	destination.GpuInstanceProfile = genruntime.ClonePointerToString(profile.GpuInstanceProfile)

	// KubeletConfig
	if profile.KubeletConfig != nil {
		var kubeletConfig v20210501s.KubeletConfig_STATUS
<<<<<<< HEAD
		err := profile.KubeletConfig.AssignPropertiesToKubeletConfig_STATUS(&kubeletConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToKubeletConfig_STATUS() to populate field KubeletConfig")
=======
		err := profile.KubeletConfig.AssignProperties_To_KubeletConfig_STATUS(&kubeletConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_KubeletConfig_STATUS() to populate field KubeletConfig")
>>>>>>> main
		}
		destination.KubeletConfig = &kubeletConfig
	} else {
		destination.KubeletConfig = nil
	}

	// KubeletDiskType
	destination.KubeletDiskType = genruntime.ClonePointerToString(profile.KubeletDiskType)

	// LinuxOSConfig
	if profile.LinuxOSConfig != nil {
		var linuxOSConfig v20210501s.LinuxOSConfig_STATUS
<<<<<<< HEAD
		err := profile.LinuxOSConfig.AssignPropertiesToLinuxOSConfig_STATUS(&linuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToLinuxOSConfig_STATUS() to populate field LinuxOSConfig")
=======
		err := profile.LinuxOSConfig.AssignProperties_To_LinuxOSConfig_STATUS(&linuxOSConfig)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_LinuxOSConfig_STATUS() to populate field LinuxOSConfig")
>>>>>>> main
		}
		destination.LinuxOSConfig = &linuxOSConfig
	} else {
		destination.LinuxOSConfig = nil
	}

	// MaxCount
	destination.MaxCount = genruntime.ClonePointerToInt(profile.MaxCount)

	// MaxPods
	destination.MaxPods = genruntime.ClonePointerToInt(profile.MaxPods)

	// MinCount
	destination.MinCount = genruntime.ClonePointerToInt(profile.MinCount)

	// Mode
	destination.Mode = genruntime.ClonePointerToString(profile.Mode)

	// Name
	destination.Name = genruntime.ClonePointerToString(profile.Name)

	// NodeImageVersion
	destination.NodeImageVersion = genruntime.ClonePointerToString(profile.NodeImageVersion)

	// NodeLabels
	destination.NodeLabels = genruntime.CloneMapOfStringToString(profile.NodeLabels)

	// NodePublicIPPrefixID
	destination.NodePublicIPPrefixID = genruntime.ClonePointerToString(profile.NodePublicIPPrefixID)

	// NodeTaints
	destination.NodeTaints = genruntime.CloneSliceOfString(profile.NodeTaints)

	// OrchestratorVersion
	destination.OrchestratorVersion = genruntime.ClonePointerToString(profile.OrchestratorVersion)

	// OsDiskSizeGB
	destination.OsDiskSizeGB = genruntime.ClonePointerToInt(profile.OsDiskSizeGB)

	// OsDiskType
	destination.OsDiskType = genruntime.ClonePointerToString(profile.OsDiskType)

	// OsSKU
	destination.OsSKU = genruntime.ClonePointerToString(profile.OsSKU)

	// OsType
	destination.OsType = genruntime.ClonePointerToString(profile.OsType)

	// PodSubnetID
	destination.PodSubnetID = genruntime.ClonePointerToString(profile.PodSubnetID)

	// PowerState
	if profile.PowerState != nil {
		var powerState v20210501s.PowerState_STATUS
<<<<<<< HEAD
		err := profile.PowerState.AssignPropertiesToPowerState_STATUS(&powerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToPowerState_STATUS() to populate field PowerState")
=======
		err := profile.PowerState.AssignProperties_To_PowerState_STATUS(&powerState)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_PowerState_STATUS() to populate field PowerState")
>>>>>>> main
		}
		destination.PowerState = &powerState
	} else {
		destination.PowerState = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(profile.ProvisioningState)

	// ProximityPlacementGroupID
	destination.ProximityPlacementGroupID = genruntime.ClonePointerToString(profile.ProximityPlacementGroupID)

	// ScaleSetEvictionPolicy
	destination.ScaleSetEvictionPolicy = genruntime.ClonePointerToString(profile.ScaleSetEvictionPolicy)

	// ScaleSetPriority
	destination.ScaleSetPriority = genruntime.ClonePointerToString(profile.ScaleSetPriority)

	// SpotMaxPrice
	if profile.SpotMaxPrice != nil {
		spotMaxPrice := *profile.SpotMaxPrice
		destination.SpotMaxPrice = &spotMaxPrice
	} else {
		destination.SpotMaxPrice = nil
	}

	// Tags
	destination.Tags = genruntime.CloneMapOfStringToString(profile.Tags)

	// Type
	destination.Type = genruntime.ClonePointerToString(profile.Type)

	// UpgradeSettings
	if profile.UpgradeSettings != nil {
		var upgradeSetting v20210501s.AgentPoolUpgradeSettings_STATUS
<<<<<<< HEAD
		err := profile.UpgradeSettings.AssignPropertiesToAgentPoolUpgradeSettings_STATUS(&upgradeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToAgentPoolUpgradeSettings_STATUS() to populate field UpgradeSettings")
=======
		err := profile.UpgradeSettings.AssignProperties_To_AgentPoolUpgradeSettings_STATUS(&upgradeSetting)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_AgentPoolUpgradeSettings_STATUS() to populate field UpgradeSettings")
>>>>>>> main
		}
		destination.UpgradeSettings = &upgradeSetting
	} else {
		destination.UpgradeSettings = nil
	}

	// VmSize
	destination.VmSize = genruntime.ClonePointerToString(profile.VmSize)

	// VnetSubnetID
	destination.VnetSubnetID = genruntime.ClonePointerToString(profile.VnetSubnetID)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterAPIServerAccessProfile
// Deprecated version of ManagedClusterAPIServerAccessProfile. Use v1beta20210501.ManagedClusterAPIServerAccessProfile instead
type ManagedClusterAPIServerAccessProfile struct {
	AuthorizedIPRanges             []string               `json:"authorizedIPRanges,omitempty"`
	EnablePrivateCluster           *bool                  `json:"enablePrivateCluster,omitempty"`
	EnablePrivateClusterPublicFQDN *bool                  `json:"enablePrivateClusterPublicFQDN,omitempty"`
	PrivateDNSZone                 *string                `json:"privateDNSZone,omitempty"`
	PropertyBag                    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ManagedClusterAPIServerAccessProfile populates our ManagedClusterAPIServerAccessProfile from the provided source ManagedClusterAPIServerAccessProfile
func (profile *ManagedClusterAPIServerAccessProfile) AssignProperties_From_ManagedClusterAPIServerAccessProfile(source *v20210501s.ManagedClusterAPIServerAccessProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AuthorizedIPRanges
	profile.AuthorizedIPRanges = genruntime.CloneSliceOfString(source.AuthorizedIPRanges)

	// EnablePrivateCluster
	if source.EnablePrivateCluster != nil {
		enablePrivateCluster := *source.EnablePrivateCluster
		profile.EnablePrivateCluster = &enablePrivateCluster
	} else {
		profile.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if source.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *source.EnablePrivateClusterPublicFQDN
		profile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		profile.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	profile.PrivateDNSZone = genruntime.ClonePointerToString(source.PrivateDNSZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAPIServerAccessProfile populates the provided destination ManagedClusterAPIServerAccessProfile from our ManagedClusterAPIServerAccessProfile
func (profile *ManagedClusterAPIServerAccessProfile) AssignProperties_To_ManagedClusterAPIServerAccessProfile(destination *v20210501s.ManagedClusterAPIServerAccessProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AuthorizedIPRanges
	destination.AuthorizedIPRanges = genruntime.CloneSliceOfString(profile.AuthorizedIPRanges)

	// EnablePrivateCluster
	if profile.EnablePrivateCluster != nil {
		enablePrivateCluster := *profile.EnablePrivateCluster
		destination.EnablePrivateCluster = &enablePrivateCluster
	} else {
		destination.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if profile.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *profile.EnablePrivateClusterPublicFQDN
		destination.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		destination.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	destination.PrivateDNSZone = genruntime.ClonePointerToString(profile.PrivateDNSZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterAPIServerAccessProfile_STATUS
// Deprecated version of ManagedClusterAPIServerAccessProfile_STATUS. Use v1beta20210501.ManagedClusterAPIServerAccessProfile_STATUS instead
type ManagedClusterAPIServerAccessProfile_STATUS struct {
	AuthorizedIPRanges             []string               `json:"authorizedIPRanges,omitempty"`
	EnablePrivateCluster           *bool                  `json:"enablePrivateCluster,omitempty"`
	EnablePrivateClusterPublicFQDN *bool                  `json:"enablePrivateClusterPublicFQDN,omitempty"`
	PrivateDNSZone                 *string                `json:"privateDNSZone,omitempty"`
	PropertyBag                    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterAPIServerAccessProfile_STATUS populates our ManagedClusterAPIServerAccessProfile_STATUS from the provided source ManagedClusterAPIServerAccessProfile_STATUS
func (profile *ManagedClusterAPIServerAccessProfile_STATUS) AssignPropertiesFromManagedClusterAPIServerAccessProfile_STATUS(source *v20210501s.ManagedClusterAPIServerAccessProfile_STATUS) error {
=======
// AssignProperties_From_ManagedClusterAPIServerAccessProfile_STATUS populates our ManagedClusterAPIServerAccessProfile_STATUS from the provided source ManagedClusterAPIServerAccessProfile_STATUS
func (profile *ManagedClusterAPIServerAccessProfile_STATUS) AssignProperties_From_ManagedClusterAPIServerAccessProfile_STATUS(source *v20210501s.ManagedClusterAPIServerAccessProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AuthorizedIPRanges
	profile.AuthorizedIPRanges = genruntime.CloneSliceOfString(source.AuthorizedIPRanges)

	// EnablePrivateCluster
	if source.EnablePrivateCluster != nil {
		enablePrivateCluster := *source.EnablePrivateCluster
		profile.EnablePrivateCluster = &enablePrivateCluster
	} else {
		profile.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if source.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *source.EnablePrivateClusterPublicFQDN
		profile.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		profile.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	profile.PrivateDNSZone = genruntime.ClonePointerToString(source.PrivateDNSZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterAPIServerAccessProfile_STATUS populates the provided destination ManagedClusterAPIServerAccessProfile_STATUS from our ManagedClusterAPIServerAccessProfile_STATUS
func (profile *ManagedClusterAPIServerAccessProfile_STATUS) AssignPropertiesToManagedClusterAPIServerAccessProfile_STATUS(destination *v20210501s.ManagedClusterAPIServerAccessProfile_STATUS) error {
=======
// AssignProperties_To_ManagedClusterAPIServerAccessProfile_STATUS populates the provided destination ManagedClusterAPIServerAccessProfile_STATUS from our ManagedClusterAPIServerAccessProfile_STATUS
func (profile *ManagedClusterAPIServerAccessProfile_STATUS) AssignProperties_To_ManagedClusterAPIServerAccessProfile_STATUS(destination *v20210501s.ManagedClusterAPIServerAccessProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AuthorizedIPRanges
	destination.AuthorizedIPRanges = genruntime.CloneSliceOfString(profile.AuthorizedIPRanges)

	// EnablePrivateCluster
	if profile.EnablePrivateCluster != nil {
		enablePrivateCluster := *profile.EnablePrivateCluster
		destination.EnablePrivateCluster = &enablePrivateCluster
	} else {
		destination.EnablePrivateCluster = nil
	}

	// EnablePrivateClusterPublicFQDN
	if profile.EnablePrivateClusterPublicFQDN != nil {
		enablePrivateClusterPublicFQDN := *profile.EnablePrivateClusterPublicFQDN
		destination.EnablePrivateClusterPublicFQDN = &enablePrivateClusterPublicFQDN
	} else {
		destination.EnablePrivateClusterPublicFQDN = nil
	}

	// PrivateDNSZone
	destination.PrivateDNSZone = genruntime.ClonePointerToString(profile.PrivateDNSZone)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterAutoUpgradeProfile
// Deprecated version of ManagedClusterAutoUpgradeProfile. Use v1beta20210501.ManagedClusterAutoUpgradeProfile instead
type ManagedClusterAutoUpgradeProfile struct {
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	UpgradeChannel *string                `json:"upgradeChannel,omitempty"`
}

// AssignProperties_From_ManagedClusterAutoUpgradeProfile populates our ManagedClusterAutoUpgradeProfile from the provided source ManagedClusterAutoUpgradeProfile
func (profile *ManagedClusterAutoUpgradeProfile) AssignProperties_From_ManagedClusterAutoUpgradeProfile(source *v20210501s.ManagedClusterAutoUpgradeProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// UpgradeChannel
	profile.UpgradeChannel = genruntime.ClonePointerToString(source.UpgradeChannel)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterAutoUpgradeProfile populates the provided destination ManagedClusterAutoUpgradeProfile from our ManagedClusterAutoUpgradeProfile
func (profile *ManagedClusterAutoUpgradeProfile) AssignProperties_To_ManagedClusterAutoUpgradeProfile(destination *v20210501s.ManagedClusterAutoUpgradeProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// UpgradeChannel
	destination.UpgradeChannel = genruntime.ClonePointerToString(profile.UpgradeChannel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterAutoUpgradeProfile_STATUS
// Deprecated version of ManagedClusterAutoUpgradeProfile_STATUS. Use v1beta20210501.ManagedClusterAutoUpgradeProfile_STATUS instead
type ManagedClusterAutoUpgradeProfile_STATUS struct {
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	UpgradeChannel *string                `json:"upgradeChannel,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterAutoUpgradeProfile_STATUS populates our ManagedClusterAutoUpgradeProfile_STATUS from the provided source ManagedClusterAutoUpgradeProfile_STATUS
func (profile *ManagedClusterAutoUpgradeProfile_STATUS) AssignPropertiesFromManagedClusterAutoUpgradeProfile_STATUS(source *v20210501s.ManagedClusterAutoUpgradeProfile_STATUS) error {
=======
// AssignProperties_From_ManagedClusterAutoUpgradeProfile_STATUS populates our ManagedClusterAutoUpgradeProfile_STATUS from the provided source ManagedClusterAutoUpgradeProfile_STATUS
func (profile *ManagedClusterAutoUpgradeProfile_STATUS) AssignProperties_From_ManagedClusterAutoUpgradeProfile_STATUS(source *v20210501s.ManagedClusterAutoUpgradeProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// UpgradeChannel
	profile.UpgradeChannel = genruntime.ClonePointerToString(source.UpgradeChannel)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterAutoUpgradeProfile_STATUS populates the provided destination ManagedClusterAutoUpgradeProfile_STATUS from our ManagedClusterAutoUpgradeProfile_STATUS
func (profile *ManagedClusterAutoUpgradeProfile_STATUS) AssignPropertiesToManagedClusterAutoUpgradeProfile_STATUS(destination *v20210501s.ManagedClusterAutoUpgradeProfile_STATUS) error {
=======
// AssignProperties_To_ManagedClusterAutoUpgradeProfile_STATUS populates the provided destination ManagedClusterAutoUpgradeProfile_STATUS from our ManagedClusterAutoUpgradeProfile_STATUS
func (profile *ManagedClusterAutoUpgradeProfile_STATUS) AssignProperties_To_ManagedClusterAutoUpgradeProfile_STATUS(destination *v20210501s.ManagedClusterAutoUpgradeProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// UpgradeChannel
	destination.UpgradeChannel = genruntime.ClonePointerToString(profile.UpgradeChannel)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterHTTPProxyConfig
// Deprecated version of ManagedClusterHTTPProxyConfig. Use v1beta20210501.ManagedClusterHTTPProxyConfig instead
type ManagedClusterHTTPProxyConfig struct {
	HttpProxy   *string                `json:"httpProxy,omitempty"`
	HttpsProxy  *string                `json:"httpsProxy,omitempty"`
	NoProxy     []string               `json:"noProxy,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TrustedCa   *string                `json:"trustedCa,omitempty"`
}

// AssignProperties_From_ManagedClusterHTTPProxyConfig populates our ManagedClusterHTTPProxyConfig from the provided source ManagedClusterHTTPProxyConfig
func (config *ManagedClusterHTTPProxyConfig) AssignProperties_From_ManagedClusterHTTPProxyConfig(source *v20210501s.ManagedClusterHTTPProxyConfig) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HttpProxy
	config.HttpProxy = genruntime.ClonePointerToString(source.HttpProxy)

	// HttpsProxy
	config.HttpsProxy = genruntime.ClonePointerToString(source.HttpsProxy)

	// NoProxy
	config.NoProxy = genruntime.CloneSliceOfString(source.NoProxy)

	// TrustedCa
	config.TrustedCa = genruntime.ClonePointerToString(source.TrustedCa)

	// Update the property bag
	if len(propertyBag) > 0 {
		config.PropertyBag = propertyBag
	} else {
		config.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterHTTPProxyConfig populates the provided destination ManagedClusterHTTPProxyConfig from our ManagedClusterHTTPProxyConfig
func (config *ManagedClusterHTTPProxyConfig) AssignProperties_To_ManagedClusterHTTPProxyConfig(destination *v20210501s.ManagedClusterHTTPProxyConfig) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(config.PropertyBag)

	// HttpProxy
	destination.HttpProxy = genruntime.ClonePointerToString(config.HttpProxy)

	// HttpsProxy
	destination.HttpsProxy = genruntime.ClonePointerToString(config.HttpsProxy)

	// NoProxy
	destination.NoProxy = genruntime.CloneSliceOfString(config.NoProxy)

	// TrustedCa
	destination.TrustedCa = genruntime.ClonePointerToString(config.TrustedCa)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterHTTPProxyConfig_STATUS
// Deprecated version of ManagedClusterHTTPProxyConfig_STATUS. Use v1beta20210501.ManagedClusterHTTPProxyConfig_STATUS instead
type ManagedClusterHTTPProxyConfig_STATUS struct {
	HttpProxy   *string                `json:"httpProxy,omitempty"`
	HttpsProxy  *string                `json:"httpsProxy,omitempty"`
	NoProxy     []string               `json:"noProxy,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	TrustedCa   *string                `json:"trustedCa,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterHTTPProxyConfig_STATUS populates our ManagedClusterHTTPProxyConfig_STATUS from the provided source ManagedClusterHTTPProxyConfig_STATUS
func (config *ManagedClusterHTTPProxyConfig_STATUS) AssignPropertiesFromManagedClusterHTTPProxyConfig_STATUS(source *v20210501s.ManagedClusterHTTPProxyConfig_STATUS) error {
=======
// AssignProperties_From_ManagedClusterHTTPProxyConfig_STATUS populates our ManagedClusterHTTPProxyConfig_STATUS from the provided source ManagedClusterHTTPProxyConfig_STATUS
func (config *ManagedClusterHTTPProxyConfig_STATUS) AssignProperties_From_ManagedClusterHTTPProxyConfig_STATUS(source *v20210501s.ManagedClusterHTTPProxyConfig_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// HttpProxy
	config.HttpProxy = genruntime.ClonePointerToString(source.HttpProxy)

	// HttpsProxy
	config.HttpsProxy = genruntime.ClonePointerToString(source.HttpsProxy)

	// NoProxy
	config.NoProxy = genruntime.CloneSliceOfString(source.NoProxy)

	// TrustedCa
	config.TrustedCa = genruntime.ClonePointerToString(source.TrustedCa)

	// Update the property bag
	if len(propertyBag) > 0 {
		config.PropertyBag = propertyBag
	} else {
		config.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterHTTPProxyConfig_STATUS populates the provided destination ManagedClusterHTTPProxyConfig_STATUS from our ManagedClusterHTTPProxyConfig_STATUS
func (config *ManagedClusterHTTPProxyConfig_STATUS) AssignPropertiesToManagedClusterHTTPProxyConfig_STATUS(destination *v20210501s.ManagedClusterHTTPProxyConfig_STATUS) error {
=======
// AssignProperties_To_ManagedClusterHTTPProxyConfig_STATUS populates the provided destination ManagedClusterHTTPProxyConfig_STATUS from our ManagedClusterHTTPProxyConfig_STATUS
func (config *ManagedClusterHTTPProxyConfig_STATUS) AssignProperties_To_ManagedClusterHTTPProxyConfig_STATUS(destination *v20210501s.ManagedClusterHTTPProxyConfig_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(config.PropertyBag)

	// HttpProxy
	destination.HttpProxy = genruntime.ClonePointerToString(config.HttpProxy)

	// HttpsProxy
	destination.HttpsProxy = genruntime.ClonePointerToString(config.HttpsProxy)

	// NoProxy
	destination.NoProxy = genruntime.CloneSliceOfString(config.NoProxy)

	// TrustedCa
	destination.TrustedCa = genruntime.ClonePointerToString(config.TrustedCa)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterIdentity
// Deprecated version of ManagedClusterIdentity. Use v1beta20210501.ManagedClusterIdentity instead
type ManagedClusterIdentity struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_ManagedClusterIdentity populates our ManagedClusterIdentity from the provided source ManagedClusterIdentity
func (identity *ManagedClusterIdentity) AssignProperties_From_ManagedClusterIdentity(source *v20210501s.ManagedClusterIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Type
	identity.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterIdentity populates the provided destination ManagedClusterIdentity from our ManagedClusterIdentity
func (identity *ManagedClusterIdentity) AssignProperties_To_ManagedClusterIdentity(destination *v20210501s.ManagedClusterIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// Type
	destination.Type = genruntime.ClonePointerToString(identity.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterIdentity_STATUS
// Deprecated version of ManagedClusterIdentity_STATUS. Use v1beta20210501.ManagedClusterIdentity_STATUS instead
type ManagedClusterIdentity_STATUS struct {
	PrincipalId            *string                                                         `json:"principalId,omitempty"`
	PropertyBag            genruntime.PropertyBag                                          `json:"$propertyBag,omitempty"`
	TenantId               *string                                                         `json:"tenantId,omitempty"`
	Type                   *string                                                         `json:"type,omitempty"`
	UserAssignedIdentities map[string]ManagedClusterIdentity_UserAssignedIdentities_STATUS `json:"userAssignedIdentities,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterIdentity_STATUS populates our ManagedClusterIdentity_STATUS from the provided source ManagedClusterIdentity_STATUS
func (identity *ManagedClusterIdentity_STATUS) AssignPropertiesFromManagedClusterIdentity_STATUS(source *v20210501s.ManagedClusterIdentity_STATUS) error {
=======
// AssignProperties_From_ManagedClusterIdentity_STATUS populates our ManagedClusterIdentity_STATUS from the provided source ManagedClusterIdentity_STATUS
func (identity *ManagedClusterIdentity_STATUS) AssignProperties_From_ManagedClusterIdentity_STATUS(source *v20210501s.ManagedClusterIdentity_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PrincipalId
	identity.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// TenantId
	identity.TenantId = genruntime.ClonePointerToString(source.TenantId)

	// Type
	identity.Type = genruntime.ClonePointerToString(source.Type)

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]ManagedClusterIdentity_UserAssignedIdentities_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
<<<<<<< HEAD
			var userAssignedIdentity ManagedClusterIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentity.AssignPropertiesFromManagedClusterIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
=======
			var userAssignedIdentity ManagedClusterIdentity_STATUS_UserAssignedIdentities
			err := userAssignedIdentity.AssignProperties_From_ManagedClusterIdentity_STATUS_UserAssignedIdentities(&userAssignedIdentityValue)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterIdentity_STATUS_UserAssignedIdentities() to populate field UserAssignedIdentities")
>>>>>>> main
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		identity.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		identity.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterIdentity_STATUS populates the provided destination ManagedClusterIdentity_STATUS from our ManagedClusterIdentity_STATUS
func (identity *ManagedClusterIdentity_STATUS) AssignPropertiesToManagedClusterIdentity_STATUS(destination *v20210501s.ManagedClusterIdentity_STATUS) error {
=======
// AssignProperties_To_ManagedClusterIdentity_STATUS populates the provided destination ManagedClusterIdentity_STATUS from our ManagedClusterIdentity_STATUS
func (identity *ManagedClusterIdentity_STATUS) AssignProperties_To_ManagedClusterIdentity_STATUS(destination *v20210501s.ManagedClusterIdentity_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identity.PrincipalId)

	// TenantId
	destination.TenantId = genruntime.ClonePointerToString(identity.TenantId)

	// Type
	destination.Type = genruntime.ClonePointerToString(identity.Type)

	// UserAssignedIdentities
	if identity.UserAssignedIdentities != nil {
		userAssignedIdentityMap := make(map[string]v20210501s.ManagedClusterIdentity_UserAssignedIdentities_STATUS, len(identity.UserAssignedIdentities))
		for userAssignedIdentityKey, userAssignedIdentityValue := range identity.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityValue := userAssignedIdentityValue
<<<<<<< HEAD
			var userAssignedIdentity v20210501s.ManagedClusterIdentity_UserAssignedIdentities_STATUS
			err := userAssignedIdentityValue.AssignPropertiesToManagedClusterIdentity_UserAssignedIdentities_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToManagedClusterIdentity_UserAssignedIdentities_STATUS() to populate field UserAssignedIdentities")
=======
			var userAssignedIdentity v20210501s.ManagedClusterIdentity_STATUS_UserAssignedIdentities
			err := userAssignedIdentityValue.AssignProperties_To_ManagedClusterIdentity_STATUS_UserAssignedIdentities(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterIdentity_STATUS_UserAssignedIdentities() to populate field UserAssignedIdentities")
>>>>>>> main
			}
			userAssignedIdentityMap[userAssignedIdentityKey] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityMap
	} else {
		destination.UserAssignedIdentities = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterOperatorSpec
// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type ManagedClusterOperatorSpec struct {
	PropertyBag genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
	Secrets     *ManagedClusterOperatorSecrets `json:"secrets,omitempty"`
}

// AssignProperties_From_ManagedClusterOperatorSpec populates our ManagedClusterOperatorSpec from the provided source ManagedClusterOperatorSpec
func (operator *ManagedClusterOperatorSpec) AssignProperties_From_ManagedClusterOperatorSpec(source *v20210501s.ManagedClusterOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Secrets
	if source.Secrets != nil {
		var secret ManagedClusterOperatorSecrets
		err := secret.AssignProperties_From_ManagedClusterOperatorSecrets(source.Secrets)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterOperatorSecrets() to populate field Secrets")
		}
		operator.Secrets = &secret
	} else {
		operator.Secrets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		operator.PropertyBag = propertyBag
	} else {
		operator.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterOperatorSpec populates the provided destination ManagedClusterOperatorSpec from our ManagedClusterOperatorSpec
func (operator *ManagedClusterOperatorSpec) AssignProperties_To_ManagedClusterOperatorSpec(destination *v20210501s.ManagedClusterOperatorSpec) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(operator.PropertyBag)

	// Secrets
	if operator.Secrets != nil {
		var secret v20210501s.ManagedClusterOperatorSecrets
		err := operator.Secrets.AssignProperties_To_ManagedClusterOperatorSecrets(&secret)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterOperatorSecrets() to populate field Secrets")
		}
		destination.Secrets = &secret
	} else {
		destination.Secrets = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterPodIdentityProfile
// Deprecated version of ManagedClusterPodIdentityProfile. Use v1beta20210501.ManagedClusterPodIdentityProfile instead
type ManagedClusterPodIdentityProfile struct {
	AllowNetworkPluginKubenet      *bool                                `json:"allowNetworkPluginKubenet,omitempty"`
	Enabled                        *bool                                `json:"enabled,omitempty"`
	PropertyBag                    genruntime.PropertyBag               `json:"$propertyBag,omitempty"`
	UserAssignedIdentities         []ManagedClusterPodIdentity          `json:"userAssignedIdentities,omitempty"`
	UserAssignedIdentityExceptions []ManagedClusterPodIdentityException `json:"userAssignedIdentityExceptions,omitempty"`
}

// AssignProperties_From_ManagedClusterPodIdentityProfile populates our ManagedClusterPodIdentityProfile from the provided source ManagedClusterPodIdentityProfile
func (profile *ManagedClusterPodIdentityProfile) AssignProperties_From_ManagedClusterPodIdentityProfile(source *v20210501s.ManagedClusterPodIdentityProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllowNetworkPluginKubenet
	if source.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *source.AllowNetworkPluginKubenet
		profile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		profile.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]ManagedClusterPodIdentity, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity ManagedClusterPodIdentity
			err := userAssignedIdentity.AssignProperties_From_ManagedClusterPodIdentity(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentity() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		profile.UserAssignedIdentities = userAssignedIdentityList
	} else {
		profile.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if source.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]ManagedClusterPodIdentityException, len(source.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range source.UserAssignedIdentityExceptions {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
			var userAssignedIdentityException ManagedClusterPodIdentityException
			err := userAssignedIdentityException.AssignProperties_From_ManagedClusterPodIdentityException(&userAssignedIdentityExceptionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityException() to populate field UserAssignedIdentityExceptions")
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		profile.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		profile.UserAssignedIdentityExceptions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityProfile populates the provided destination ManagedClusterPodIdentityProfile from our ManagedClusterPodIdentityProfile
func (profile *ManagedClusterPodIdentityProfile) AssignProperties_To_ManagedClusterPodIdentityProfile(destination *v20210501s.ManagedClusterPodIdentityProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AllowNetworkPluginKubenet
	if profile.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *profile.AllowNetworkPluginKubenet
		destination.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		destination.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// UserAssignedIdentities
	if profile.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]v20210501s.ManagedClusterPodIdentity, len(profile.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range profile.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity v20210501s.ManagedClusterPodIdentity
			err := userAssignedIdentityItem.AssignProperties_To_ManagedClusterPodIdentity(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentity() to populate field UserAssignedIdentities")
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if profile.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]v20210501s.ManagedClusterPodIdentityException, len(profile.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range profile.UserAssignedIdentityExceptions {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
			var userAssignedIdentityException v20210501s.ManagedClusterPodIdentityException
			err := userAssignedIdentityExceptionItem.AssignProperties_To_ManagedClusterPodIdentityException(&userAssignedIdentityException)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityException() to populate field UserAssignedIdentityExceptions")
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		destination.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		destination.UserAssignedIdentityExceptions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterPodIdentityProfile_STATUS
// Deprecated version of ManagedClusterPodIdentityProfile_STATUS. Use v1beta20210501.ManagedClusterPodIdentityProfile_STATUS instead
type ManagedClusterPodIdentityProfile_STATUS struct {
	AllowNetworkPluginKubenet      *bool                                       `json:"allowNetworkPluginKubenet,omitempty"`
	Enabled                        *bool                                       `json:"enabled,omitempty"`
	PropertyBag                    genruntime.PropertyBag                      `json:"$propertyBag,omitempty"`
	UserAssignedIdentities         []ManagedClusterPodIdentity_STATUS          `json:"userAssignedIdentities,omitempty"`
	UserAssignedIdentityExceptions []ManagedClusterPodIdentityException_STATUS `json:"userAssignedIdentityExceptions,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterPodIdentityProfile_STATUS populates our ManagedClusterPodIdentityProfile_STATUS from the provided source ManagedClusterPodIdentityProfile_STATUS
func (profile *ManagedClusterPodIdentityProfile_STATUS) AssignPropertiesFromManagedClusterPodIdentityProfile_STATUS(source *v20210501s.ManagedClusterPodIdentityProfile_STATUS) error {
=======
// AssignProperties_From_ManagedClusterPodIdentityProfile_STATUS populates our ManagedClusterPodIdentityProfile_STATUS from the provided source ManagedClusterPodIdentityProfile_STATUS
func (profile *ManagedClusterPodIdentityProfile_STATUS) AssignProperties_From_ManagedClusterPodIdentityProfile_STATUS(source *v20210501s.ManagedClusterPodIdentityProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllowNetworkPluginKubenet
	if source.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *source.AllowNetworkPluginKubenet
		profile.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		profile.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if source.Enabled != nil {
		enabled := *source.Enabled
		profile.Enabled = &enabled
	} else {
		profile.Enabled = nil
	}

	// UserAssignedIdentities
	if source.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]ManagedClusterPodIdentity_STATUS, len(source.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range source.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity ManagedClusterPodIdentity_STATUS
<<<<<<< HEAD
			err := userAssignedIdentity.AssignPropertiesFromManagedClusterPodIdentity_STATUS(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentity_STATUS() to populate field UserAssignedIdentities")
=======
			err := userAssignedIdentity.AssignProperties_From_ManagedClusterPodIdentity_STATUS(&userAssignedIdentityItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentity_STATUS() to populate field UserAssignedIdentities")
>>>>>>> main
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		profile.UserAssignedIdentities = userAssignedIdentityList
	} else {
		profile.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if source.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]ManagedClusterPodIdentityException_STATUS, len(source.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range source.UserAssignedIdentityExceptions {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
			var userAssignedIdentityException ManagedClusterPodIdentityException_STATUS
<<<<<<< HEAD
			err := userAssignedIdentityException.AssignPropertiesFromManagedClusterPodIdentityException_STATUS(&userAssignedIdentityExceptionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentityException_STATUS() to populate field UserAssignedIdentityExceptions")
=======
			err := userAssignedIdentityException.AssignProperties_From_ManagedClusterPodIdentityException_STATUS(&userAssignedIdentityExceptionItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityException_STATUS() to populate field UserAssignedIdentityExceptions")
>>>>>>> main
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		profile.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		profile.UserAssignedIdentityExceptions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterPodIdentityProfile_STATUS populates the provided destination ManagedClusterPodIdentityProfile_STATUS from our ManagedClusterPodIdentityProfile_STATUS
func (profile *ManagedClusterPodIdentityProfile_STATUS) AssignPropertiesToManagedClusterPodIdentityProfile_STATUS(destination *v20210501s.ManagedClusterPodIdentityProfile_STATUS) error {
=======
// AssignProperties_To_ManagedClusterPodIdentityProfile_STATUS populates the provided destination ManagedClusterPodIdentityProfile_STATUS from our ManagedClusterPodIdentityProfile_STATUS
func (profile *ManagedClusterPodIdentityProfile_STATUS) AssignProperties_To_ManagedClusterPodIdentityProfile_STATUS(destination *v20210501s.ManagedClusterPodIdentityProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AllowNetworkPluginKubenet
	if profile.AllowNetworkPluginKubenet != nil {
		allowNetworkPluginKubenet := *profile.AllowNetworkPluginKubenet
		destination.AllowNetworkPluginKubenet = &allowNetworkPluginKubenet
	} else {
		destination.AllowNetworkPluginKubenet = nil
	}

	// Enabled
	if profile.Enabled != nil {
		enabled := *profile.Enabled
		destination.Enabled = &enabled
	} else {
		destination.Enabled = nil
	}

	// UserAssignedIdentities
	if profile.UserAssignedIdentities != nil {
		userAssignedIdentityList := make([]v20210501s.ManagedClusterPodIdentity_STATUS, len(profile.UserAssignedIdentities))
		for userAssignedIdentityIndex, userAssignedIdentityItem := range profile.UserAssignedIdentities {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityItem := userAssignedIdentityItem
			var userAssignedIdentity v20210501s.ManagedClusterPodIdentity_STATUS
<<<<<<< HEAD
			err := userAssignedIdentityItem.AssignPropertiesToManagedClusterPodIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentity_STATUS() to populate field UserAssignedIdentities")
=======
			err := userAssignedIdentityItem.AssignProperties_To_ManagedClusterPodIdentity_STATUS(&userAssignedIdentity)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentity_STATUS() to populate field UserAssignedIdentities")
>>>>>>> main
			}
			userAssignedIdentityList[userAssignedIdentityIndex] = userAssignedIdentity
		}
		destination.UserAssignedIdentities = userAssignedIdentityList
	} else {
		destination.UserAssignedIdentities = nil
	}

	// UserAssignedIdentityExceptions
	if profile.UserAssignedIdentityExceptions != nil {
		userAssignedIdentityExceptionList := make([]v20210501s.ManagedClusterPodIdentityException_STATUS, len(profile.UserAssignedIdentityExceptions))
		for userAssignedIdentityExceptionIndex, userAssignedIdentityExceptionItem := range profile.UserAssignedIdentityExceptions {
			// Shadow the loop variable to avoid aliasing
			userAssignedIdentityExceptionItem := userAssignedIdentityExceptionItem
			var userAssignedIdentityException v20210501s.ManagedClusterPodIdentityException_STATUS
<<<<<<< HEAD
			err := userAssignedIdentityExceptionItem.AssignPropertiesToManagedClusterPodIdentityException_STATUS(&userAssignedIdentityException)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentityException_STATUS() to populate field UserAssignedIdentityExceptions")
=======
			err := userAssignedIdentityExceptionItem.AssignProperties_To_ManagedClusterPodIdentityException_STATUS(&userAssignedIdentityException)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityException_STATUS() to populate field UserAssignedIdentityExceptions")
>>>>>>> main
			}
			userAssignedIdentityExceptionList[userAssignedIdentityExceptionIndex] = userAssignedIdentityException
		}
		destination.UserAssignedIdentityExceptions = userAssignedIdentityExceptionList
	} else {
		destination.UserAssignedIdentityExceptions = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterProperties_AutoScalerProfile
// Deprecated version of ManagedClusterProperties_AutoScalerProfile. Use v1beta20210501.ManagedClusterProperties_AutoScalerProfile instead
type ManagedClusterProperties_AutoScalerProfile struct {
	BalanceSimilarNodeGroups      *string                `json:"balance-similar-node-groups,omitempty"`
	Expander                      *string                `json:"expander,omitempty"`
	MaxEmptyBulkDelete            *string                `json:"max-empty-bulk-delete,omitempty"`
	MaxGracefulTerminationSec     *string                `json:"max-graceful-termination-sec,omitempty"`
	MaxNodeProvisionTime          *string                `json:"max-node-provision-time,omitempty"`
	MaxTotalUnreadyPercentage     *string                `json:"max-total-unready-percentage,omitempty"`
	NewPodScaleUpDelay            *string                `json:"new-pod-scale-up-delay,omitempty"`
	OkTotalUnreadyCount           *string                `json:"ok-total-unready-count,omitempty"`
	PropertyBag                   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ScaleDownDelayAfterAdd        *string                `json:"scale-down-delay-after-add,omitempty"`
	ScaleDownDelayAfterDelete     *string                `json:"scale-down-delay-after-delete,omitempty"`
	ScaleDownDelayAfterFailure    *string                `json:"scale-down-delay-after-failure,omitempty"`
	ScaleDownUnneededTime         *string                `json:"scale-down-unneeded-time,omitempty"`
	ScaleDownUnreadyTime          *string                `json:"scale-down-unready-time,omitempty"`
	ScaleDownUtilizationThreshold *string                `json:"scale-down-utilization-threshold,omitempty"`
	ScanInterval                  *string                `json:"scan-interval,omitempty"`
	SkipNodesWithLocalStorage     *string                `json:"skip-nodes-with-local-storage,omitempty"`
	SkipNodesWithSystemPods       *string                `json:"skip-nodes-with-system-pods,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterProperties_AutoScalerProfile populates our ManagedClusterProperties_AutoScalerProfile from the provided source ManagedClusterProperties_AutoScalerProfile
func (profile *ManagedClusterProperties_AutoScalerProfile) AssignPropertiesFromManagedClusterProperties_AutoScalerProfile(source *v20210501s.ManagedClusterProperties_AutoScalerProfile) error {
=======
// AssignProperties_From_ManagedClusterProperties_STATUS_AutoScalerProfile populates our ManagedClusterProperties_STATUS_AutoScalerProfile from the provided source ManagedClusterProperties_STATUS_AutoScalerProfile
func (profile *ManagedClusterProperties_STATUS_AutoScalerProfile) AssignProperties_From_ManagedClusterProperties_STATUS_AutoScalerProfile(source *v20210501s.ManagedClusterProperties_STATUS_AutoScalerProfile) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BalanceSimilarNodeGroups
	profile.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(source.BalanceSimilarNodeGroups)

	// Expander
	profile.Expander = genruntime.ClonePointerToString(source.Expander)

	// MaxEmptyBulkDelete
	profile.MaxEmptyBulkDelete = genruntime.ClonePointerToString(source.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	profile.MaxGracefulTerminationSec = genruntime.ClonePointerToString(source.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	profile.MaxNodeProvisionTime = genruntime.ClonePointerToString(source.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	profile.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(source.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	profile.NewPodScaleUpDelay = genruntime.ClonePointerToString(source.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	profile.OkTotalUnreadyCount = genruntime.ClonePointerToString(source.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	profile.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(source.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	profile.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(source.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	profile.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(source.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	profile.ScaleDownUnneededTime = genruntime.ClonePointerToString(source.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	profile.ScaleDownUnreadyTime = genruntime.ClonePointerToString(source.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	profile.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(source.ScaleDownUtilizationThreshold)

	// ScanInterval
	profile.ScanInterval = genruntime.ClonePointerToString(source.ScanInterval)

	// SkipNodesWithLocalStorage
	profile.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(source.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	profile.SkipNodesWithSystemPods = genruntime.ClonePointerToString(source.SkipNodesWithSystemPods)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterProperties_AutoScalerProfile populates the provided destination ManagedClusterProperties_AutoScalerProfile from our ManagedClusterProperties_AutoScalerProfile
func (profile *ManagedClusterProperties_AutoScalerProfile) AssignPropertiesToManagedClusterProperties_AutoScalerProfile(destination *v20210501s.ManagedClusterProperties_AutoScalerProfile) error {
=======
// AssignProperties_To_ManagedClusterProperties_STATUS_AutoScalerProfile populates the provided destination ManagedClusterProperties_STATUS_AutoScalerProfile from our ManagedClusterProperties_STATUS_AutoScalerProfile
func (profile *ManagedClusterProperties_STATUS_AutoScalerProfile) AssignProperties_To_ManagedClusterProperties_STATUS_AutoScalerProfile(destination *v20210501s.ManagedClusterProperties_STATUS_AutoScalerProfile) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// BalanceSimilarNodeGroups
	destination.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(profile.BalanceSimilarNodeGroups)

	// Expander
	destination.Expander = genruntime.ClonePointerToString(profile.Expander)

	// MaxEmptyBulkDelete
	destination.MaxEmptyBulkDelete = genruntime.ClonePointerToString(profile.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	destination.MaxGracefulTerminationSec = genruntime.ClonePointerToString(profile.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	destination.MaxNodeProvisionTime = genruntime.ClonePointerToString(profile.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	destination.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(profile.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	destination.NewPodScaleUpDelay = genruntime.ClonePointerToString(profile.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	destination.OkTotalUnreadyCount = genruntime.ClonePointerToString(profile.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	destination.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	destination.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	destination.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	destination.ScaleDownUnneededTime = genruntime.ClonePointerToString(profile.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	destination.ScaleDownUnreadyTime = genruntime.ClonePointerToString(profile.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	destination.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(profile.ScaleDownUtilizationThreshold)

	// ScanInterval
	destination.ScanInterval = genruntime.ClonePointerToString(profile.ScanInterval)

	// SkipNodesWithLocalStorage
	destination.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(profile.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	destination.SkipNodesWithSystemPods = genruntime.ClonePointerToString(profile.SkipNodesWithSystemPods)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterProperties_AutoScalerProfile_STATUS
// Deprecated version of ManagedClusterProperties_AutoScalerProfile_STATUS. Use v1beta20210501.ManagedClusterProperties_AutoScalerProfile_STATUS instead
type ManagedClusterProperties_AutoScalerProfile_STATUS struct {
	BalanceSimilarNodeGroups      *string                `json:"balance-similar-node-groups,omitempty"`
	Expander                      *string                `json:"expander,omitempty"`
	MaxEmptyBulkDelete            *string                `json:"max-empty-bulk-delete,omitempty"`
	MaxGracefulTerminationSec     *string                `json:"max-graceful-termination-sec,omitempty"`
	MaxNodeProvisionTime          *string                `json:"max-node-provision-time,omitempty"`
	MaxTotalUnreadyPercentage     *string                `json:"max-total-unready-percentage,omitempty"`
	NewPodScaleUpDelay            *string                `json:"new-pod-scale-up-delay,omitempty"`
	OkTotalUnreadyCount           *string                `json:"ok-total-unready-count,omitempty"`
	PropertyBag                   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ScaleDownDelayAfterAdd        *string                `json:"scale-down-delay-after-add,omitempty"`
	ScaleDownDelayAfterDelete     *string                `json:"scale-down-delay-after-delete,omitempty"`
	ScaleDownDelayAfterFailure    *string                `json:"scale-down-delay-after-failure,omitempty"`
	ScaleDownUnneededTime         *string                `json:"scale-down-unneeded-time,omitempty"`
	ScaleDownUnreadyTime          *string                `json:"scale-down-unready-time,omitempty"`
	ScaleDownUtilizationThreshold *string                `json:"scale-down-utilization-threshold,omitempty"`
	ScanInterval                  *string                `json:"scan-interval,omitempty"`
	SkipNodesWithLocalStorage     *string                `json:"skip-nodes-with-local-storage,omitempty"`
	SkipNodesWithSystemPods       *string                `json:"skip-nodes-with-system-pods,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterProperties_AutoScalerProfile_STATUS populates our ManagedClusterProperties_AutoScalerProfile_STATUS from the provided source ManagedClusterProperties_AutoScalerProfile_STATUS
func (profile *ManagedClusterProperties_AutoScalerProfile_STATUS) AssignPropertiesFromManagedClusterProperties_AutoScalerProfile_STATUS(source *v20210501s.ManagedClusterProperties_AutoScalerProfile_STATUS) error {
=======
// AssignProperties_From_ManagedClusterPropertiesAutoScalerProfile populates our ManagedClusterPropertiesAutoScalerProfile from the provided source ManagedClusterPropertiesAutoScalerProfile
func (profile *ManagedClusterPropertiesAutoScalerProfile) AssignProperties_From_ManagedClusterPropertiesAutoScalerProfile(source *v20210501s.ManagedClusterPropertiesAutoScalerProfile) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BalanceSimilarNodeGroups
	profile.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(source.BalanceSimilarNodeGroups)

	// Expander
	profile.Expander = genruntime.ClonePointerToString(source.Expander)

	// MaxEmptyBulkDelete
	profile.MaxEmptyBulkDelete = genruntime.ClonePointerToString(source.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	profile.MaxGracefulTerminationSec = genruntime.ClonePointerToString(source.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	profile.MaxNodeProvisionTime = genruntime.ClonePointerToString(source.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	profile.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(source.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	profile.NewPodScaleUpDelay = genruntime.ClonePointerToString(source.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	profile.OkTotalUnreadyCount = genruntime.ClonePointerToString(source.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	profile.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(source.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	profile.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(source.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	profile.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(source.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	profile.ScaleDownUnneededTime = genruntime.ClonePointerToString(source.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	profile.ScaleDownUnreadyTime = genruntime.ClonePointerToString(source.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	profile.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(source.ScaleDownUtilizationThreshold)

	// ScanInterval
	profile.ScanInterval = genruntime.ClonePointerToString(source.ScanInterval)

	// SkipNodesWithLocalStorage
	profile.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(source.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	profile.SkipNodesWithSystemPods = genruntime.ClonePointerToString(source.SkipNodesWithSystemPods)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterProperties_AutoScalerProfile_STATUS populates the provided destination ManagedClusterProperties_AutoScalerProfile_STATUS from our ManagedClusterProperties_AutoScalerProfile_STATUS
func (profile *ManagedClusterProperties_AutoScalerProfile_STATUS) AssignPropertiesToManagedClusterProperties_AutoScalerProfile_STATUS(destination *v20210501s.ManagedClusterProperties_AutoScalerProfile_STATUS) error {
=======
// AssignProperties_To_ManagedClusterPropertiesAutoScalerProfile populates the provided destination ManagedClusterPropertiesAutoScalerProfile from our ManagedClusterPropertiesAutoScalerProfile
func (profile *ManagedClusterPropertiesAutoScalerProfile) AssignProperties_To_ManagedClusterPropertiesAutoScalerProfile(destination *v20210501s.ManagedClusterPropertiesAutoScalerProfile) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// BalanceSimilarNodeGroups
	destination.BalanceSimilarNodeGroups = genruntime.ClonePointerToString(profile.BalanceSimilarNodeGroups)

	// Expander
	destination.Expander = genruntime.ClonePointerToString(profile.Expander)

	// MaxEmptyBulkDelete
	destination.MaxEmptyBulkDelete = genruntime.ClonePointerToString(profile.MaxEmptyBulkDelete)

	// MaxGracefulTerminationSec
	destination.MaxGracefulTerminationSec = genruntime.ClonePointerToString(profile.MaxGracefulTerminationSec)

	// MaxNodeProvisionTime
	destination.MaxNodeProvisionTime = genruntime.ClonePointerToString(profile.MaxNodeProvisionTime)

	// MaxTotalUnreadyPercentage
	destination.MaxTotalUnreadyPercentage = genruntime.ClonePointerToString(profile.MaxTotalUnreadyPercentage)

	// NewPodScaleUpDelay
	destination.NewPodScaleUpDelay = genruntime.ClonePointerToString(profile.NewPodScaleUpDelay)

	// OkTotalUnreadyCount
	destination.OkTotalUnreadyCount = genruntime.ClonePointerToString(profile.OkTotalUnreadyCount)

	// ScaleDownDelayAfterAdd
	destination.ScaleDownDelayAfterAdd = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterAdd)

	// ScaleDownDelayAfterDelete
	destination.ScaleDownDelayAfterDelete = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterDelete)

	// ScaleDownDelayAfterFailure
	destination.ScaleDownDelayAfterFailure = genruntime.ClonePointerToString(profile.ScaleDownDelayAfterFailure)

	// ScaleDownUnneededTime
	destination.ScaleDownUnneededTime = genruntime.ClonePointerToString(profile.ScaleDownUnneededTime)

	// ScaleDownUnreadyTime
	destination.ScaleDownUnreadyTime = genruntime.ClonePointerToString(profile.ScaleDownUnreadyTime)

	// ScaleDownUtilizationThreshold
	destination.ScaleDownUtilizationThreshold = genruntime.ClonePointerToString(profile.ScaleDownUtilizationThreshold)

	// ScanInterval
	destination.ScanInterval = genruntime.ClonePointerToString(profile.ScanInterval)

	// SkipNodesWithLocalStorage
	destination.SkipNodesWithLocalStorage = genruntime.ClonePointerToString(profile.SkipNodesWithLocalStorage)

	// SkipNodesWithSystemPods
	destination.SkipNodesWithSystemPods = genruntime.ClonePointerToString(profile.SkipNodesWithSystemPods)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterServicePrincipalProfile
// Deprecated version of ManagedClusterServicePrincipalProfile. Use v1beta20210501.ManagedClusterServicePrincipalProfile instead
type ManagedClusterServicePrincipalProfile struct {
	ClientId    *string                `json:"clientId,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Secret      *string                `json:"secret,omitempty"`
}

// AssignProperties_From_ManagedClusterServicePrincipalProfile populates our ManagedClusterServicePrincipalProfile from the provided source ManagedClusterServicePrincipalProfile
func (profile *ManagedClusterServicePrincipalProfile) AssignProperties_From_ManagedClusterServicePrincipalProfile(source *v20210501s.ManagedClusterServicePrincipalProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	profile.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// Secret
	profile.Secret = genruntime.ClonePointerToString(source.Secret)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterServicePrincipalProfile populates the provided destination ManagedClusterServicePrincipalProfile from our ManagedClusterServicePrincipalProfile
func (profile *ManagedClusterServicePrincipalProfile) AssignProperties_To_ManagedClusterServicePrincipalProfile(destination *v20210501s.ManagedClusterServicePrincipalProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(profile.ClientId)

	// Secret
	destination.Secret = genruntime.ClonePointerToString(profile.Secret)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterServicePrincipalProfile_STATUS
// Deprecated version of ManagedClusterServicePrincipalProfile_STATUS. Use v1beta20210501.ManagedClusterServicePrincipalProfile_STATUS instead
type ManagedClusterServicePrincipalProfile_STATUS struct {
	ClientId    *string                `json:"clientId,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Secret      *string                `json:"secret,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterServicePrincipalProfile_STATUS populates our ManagedClusterServicePrincipalProfile_STATUS from the provided source ManagedClusterServicePrincipalProfile_STATUS
func (profile *ManagedClusterServicePrincipalProfile_STATUS) AssignPropertiesFromManagedClusterServicePrincipalProfile_STATUS(source *v20210501s.ManagedClusterServicePrincipalProfile_STATUS) error {
=======
// AssignProperties_From_ManagedClusterServicePrincipalProfile_STATUS populates our ManagedClusterServicePrincipalProfile_STATUS from the provided source ManagedClusterServicePrincipalProfile_STATUS
func (profile *ManagedClusterServicePrincipalProfile_STATUS) AssignProperties_From_ManagedClusterServicePrincipalProfile_STATUS(source *v20210501s.ManagedClusterServicePrincipalProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	profile.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// Secret
	profile.Secret = genruntime.ClonePointerToString(source.Secret)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterServicePrincipalProfile_STATUS populates the provided destination ManagedClusterServicePrincipalProfile_STATUS from our ManagedClusterServicePrincipalProfile_STATUS
func (profile *ManagedClusterServicePrincipalProfile_STATUS) AssignPropertiesToManagedClusterServicePrincipalProfile_STATUS(destination *v20210501s.ManagedClusterServicePrincipalProfile_STATUS) error {
=======
// AssignProperties_To_ManagedClusterServicePrincipalProfile_STATUS populates the provided destination ManagedClusterServicePrincipalProfile_STATUS from our ManagedClusterServicePrincipalProfile_STATUS
func (profile *ManagedClusterServicePrincipalProfile_STATUS) AssignProperties_To_ManagedClusterServicePrincipalProfile_STATUS(destination *v20210501s.ManagedClusterServicePrincipalProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(profile.ClientId)

	// Secret
	destination.Secret = genruntime.ClonePointerToString(profile.Secret)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterSKU
// Deprecated version of ManagedClusterSKU. Use v1beta20210501.ManagedClusterSKU instead
type ManagedClusterSKU struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tier        *string                `json:"tier,omitempty"`
}

// AssignProperties_From_ManagedClusterSKU populates our ManagedClusterSKU from the provided source ManagedClusterSKU
func (clusterSKU *ManagedClusterSKU) AssignProperties_From_ManagedClusterSKU(source *v20210501s.ManagedClusterSKU) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	clusterSKU.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	clusterSKU.Tier = genruntime.ClonePointerToString(source.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		clusterSKU.PropertyBag = propertyBag
	} else {
		clusterSKU.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterSKU populates the provided destination ManagedClusterSKU from our ManagedClusterSKU
func (clusterSKU *ManagedClusterSKU) AssignProperties_To_ManagedClusterSKU(destination *v20210501s.ManagedClusterSKU) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(clusterSKU.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(clusterSKU.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(clusterSKU.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterSKU_STATUS
// Deprecated version of ManagedClusterSKU_STATUS. Use v1beta20210501.ManagedClusterSKU_STATUS instead
type ManagedClusterSKU_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Tier        *string                `json:"tier,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterSKU_STATUS populates our ManagedClusterSKU_STATUS from the provided source ManagedClusterSKU_STATUS
func (clusterSKU *ManagedClusterSKU_STATUS) AssignPropertiesFromManagedClusterSKU_STATUS(source *v20210501s.ManagedClusterSKU_STATUS) error {
=======
// AssignProperties_From_ManagedClusterSKU_STATUS populates our ManagedClusterSKU_STATUS from the provided source ManagedClusterSKU_STATUS
func (clusterSKU *ManagedClusterSKU_STATUS) AssignProperties_From_ManagedClusterSKU_STATUS(source *v20210501s.ManagedClusterSKU_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	clusterSKU.Name = genruntime.ClonePointerToString(source.Name)

	// Tier
	clusterSKU.Tier = genruntime.ClonePointerToString(source.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		clusterSKU.PropertyBag = propertyBag
	} else {
		clusterSKU.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterSKU_STATUS populates the provided destination ManagedClusterSKU_STATUS from our ManagedClusterSKU_STATUS
func (clusterSKU *ManagedClusterSKU_STATUS) AssignPropertiesToManagedClusterSKU_STATUS(destination *v20210501s.ManagedClusterSKU_STATUS) error {
=======
// AssignProperties_To_ManagedClusterSKU_STATUS populates the provided destination ManagedClusterSKU_STATUS from our ManagedClusterSKU_STATUS
func (clusterSKU *ManagedClusterSKU_STATUS) AssignProperties_To_ManagedClusterSKU_STATUS(destination *v20210501s.ManagedClusterSKU_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(clusterSKU.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(clusterSKU.Name)

	// Tier
	destination.Tier = genruntime.ClonePointerToString(clusterSKU.Tier)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterWindowsProfile
// Deprecated version of ManagedClusterWindowsProfile. Use v1beta20210501.ManagedClusterWindowsProfile instead
type ManagedClusterWindowsProfile struct {
	AdminPassword  *string                `json:"adminPassword,omitempty"`
	AdminUsername  *string                `json:"adminUsername,omitempty"`
	EnableCSIProxy *bool                  `json:"enableCSIProxy,omitempty"`
	LicenseType    *string                `json:"licenseType,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ManagedClusterWindowsProfile populates our ManagedClusterWindowsProfile from the provided source ManagedClusterWindowsProfile
func (profile *ManagedClusterWindowsProfile) AssignProperties_From_ManagedClusterWindowsProfile(source *v20210501s.ManagedClusterWindowsProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminPassword
	profile.AdminPassword = genruntime.ClonePointerToString(source.AdminPassword)

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// EnableCSIProxy
	if source.EnableCSIProxy != nil {
		enableCSIProxy := *source.EnableCSIProxy
		profile.EnableCSIProxy = &enableCSIProxy
	} else {
		profile.EnableCSIProxy = nil
	}

	// LicenseType
	profile.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterWindowsProfile populates the provided destination ManagedClusterWindowsProfile from our ManagedClusterWindowsProfile
func (profile *ManagedClusterWindowsProfile) AssignProperties_To_ManagedClusterWindowsProfile(destination *v20210501s.ManagedClusterWindowsProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AdminPassword
	destination.AdminPassword = genruntime.ClonePointerToString(profile.AdminPassword)

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// EnableCSIProxy
	if profile.EnableCSIProxy != nil {
		enableCSIProxy := *profile.EnableCSIProxy
		destination.EnableCSIProxy = &enableCSIProxy
	} else {
		destination.EnableCSIProxy = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(profile.LicenseType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterWindowsProfile_STATUS
// Deprecated version of ManagedClusterWindowsProfile_STATUS. Use v1beta20210501.ManagedClusterWindowsProfile_STATUS instead
type ManagedClusterWindowsProfile_STATUS struct {
	AdminPassword  *string                `json:"adminPassword,omitempty"`
	AdminUsername  *string                `json:"adminUsername,omitempty"`
	EnableCSIProxy *bool                  `json:"enableCSIProxy,omitempty"`
	LicenseType    *string                `json:"licenseType,omitempty"`
	PropertyBag    genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterWindowsProfile_STATUS populates our ManagedClusterWindowsProfile_STATUS from the provided source ManagedClusterWindowsProfile_STATUS
func (profile *ManagedClusterWindowsProfile_STATUS) AssignPropertiesFromManagedClusterWindowsProfile_STATUS(source *v20210501s.ManagedClusterWindowsProfile_STATUS) error {
=======
// AssignProperties_From_ManagedClusterWindowsProfile_STATUS populates our ManagedClusterWindowsProfile_STATUS from the provided source ManagedClusterWindowsProfile_STATUS
func (profile *ManagedClusterWindowsProfile_STATUS) AssignProperties_From_ManagedClusterWindowsProfile_STATUS(source *v20210501s.ManagedClusterWindowsProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminPassword
	profile.AdminPassword = genruntime.ClonePointerToString(source.AdminPassword)

	// AdminUsername
	profile.AdminUsername = genruntime.ClonePointerToString(source.AdminUsername)

	// EnableCSIProxy
	if source.EnableCSIProxy != nil {
		enableCSIProxy := *source.EnableCSIProxy
		profile.EnableCSIProxy = &enableCSIProxy
	} else {
		profile.EnableCSIProxy = nil
	}

	// LicenseType
	profile.LicenseType = genruntime.ClonePointerToString(source.LicenseType)

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterWindowsProfile_STATUS populates the provided destination ManagedClusterWindowsProfile_STATUS from our ManagedClusterWindowsProfile_STATUS
func (profile *ManagedClusterWindowsProfile_STATUS) AssignPropertiesToManagedClusterWindowsProfile_STATUS(destination *v20210501s.ManagedClusterWindowsProfile_STATUS) error {
=======
// AssignProperties_To_ManagedClusterWindowsProfile_STATUS populates the provided destination ManagedClusterWindowsProfile_STATUS from our ManagedClusterWindowsProfile_STATUS
func (profile *ManagedClusterWindowsProfile_STATUS) AssignProperties_To_ManagedClusterWindowsProfile_STATUS(destination *v20210501s.ManagedClusterWindowsProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AdminPassword
	destination.AdminPassword = genruntime.ClonePointerToString(profile.AdminPassword)

	// AdminUsername
	destination.AdminUsername = genruntime.ClonePointerToString(profile.AdminUsername)

	// EnableCSIProxy
	if profile.EnableCSIProxy != nil {
		enableCSIProxy := *profile.EnableCSIProxy
		destination.EnableCSIProxy = &enableCSIProxy
	} else {
		destination.EnableCSIProxy = nil
	}

	// LicenseType
	destination.LicenseType = genruntime.ClonePointerToString(profile.LicenseType)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.PowerState_STATUS
// Deprecated version of PowerState_STATUS. Use v1beta20210501.PowerState_STATUS instead
type PowerState_STATUS struct {
	Code        *string                `json:"code,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromPowerState_STATUS populates our PowerState_STATUS from the provided source PowerState_STATUS
func (state *PowerState_STATUS) AssignPropertiesFromPowerState_STATUS(source *v20210501s.PowerState_STATUS) error {
=======
// AssignProperties_From_PowerState_STATUS populates our PowerState_STATUS from the provided source PowerState_STATUS
func (state *PowerState_STATUS) AssignProperties_From_PowerState_STATUS(source *v20210501s.PowerState_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Code
	state.Code = genruntime.ClonePointerToString(source.Code)

	// Update the property bag
	if len(propertyBag) > 0 {
		state.PropertyBag = propertyBag
	} else {
		state.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToPowerState_STATUS populates the provided destination PowerState_STATUS from our PowerState_STATUS
func (state *PowerState_STATUS) AssignPropertiesToPowerState_STATUS(destination *v20210501s.PowerState_STATUS) error {
=======
// AssignProperties_To_PowerState_STATUS populates the provided destination PowerState_STATUS from our PowerState_STATUS
func (state *PowerState_STATUS) AssignProperties_To_PowerState_STATUS(destination *v20210501s.PowerState_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(state.PropertyBag)

	// Code
	destination.Code = genruntime.ClonePointerToString(state.Code)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.PrivateLinkResource
// Deprecated version of PrivateLinkResource. Use v1beta20210501.PrivateLinkResource instead
type PrivateLinkResource struct {
	GroupId         *string                       `json:"groupId,omitempty"`
	Name            *string                       `json:"name,omitempty"`
	PropertyBag     genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Reference       *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
	RequiredMembers []string                      `json:"requiredMembers,omitempty"`
	Type            *string                       `json:"type,omitempty"`
}

// AssignProperties_From_PrivateLinkResource populates our PrivateLinkResource from the provided source PrivateLinkResource
func (resource *PrivateLinkResource) AssignProperties_From_PrivateLinkResource(source *v20210501s.PrivateLinkResource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// GroupId
	resource.GroupId = genruntime.ClonePointerToString(source.GroupId)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// Reference
	if source.Reference != nil {
		reference := source.Reference.Copy()
		resource.Reference = &reference
	} else {
		resource.Reference = nil
	}

	// RequiredMembers
	resource.RequiredMembers = genruntime.CloneSliceOfString(source.RequiredMembers)

	// Type
	resource.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		resource.PropertyBag = propertyBag
	} else {
		resource.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_PrivateLinkResource populates the provided destination PrivateLinkResource from our PrivateLinkResource
func (resource *PrivateLinkResource) AssignProperties_To_PrivateLinkResource(destination *v20210501s.PrivateLinkResource) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(resource.PropertyBag)

	// GroupId
	destination.GroupId = genruntime.ClonePointerToString(resource.GroupId)

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// Reference
	if resource.Reference != nil {
		reference := resource.Reference.Copy()
		destination.Reference = &reference
	} else {
		destination.Reference = nil
	}

	// RequiredMembers
	destination.RequiredMembers = genruntime.CloneSliceOfString(resource.RequiredMembers)

	// Type
	destination.Type = genruntime.ClonePointerToString(resource.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.PrivateLinkResource_STATUS
// Deprecated version of PrivateLinkResource_STATUS. Use v1beta20210501.PrivateLinkResource_STATUS instead
type PrivateLinkResource_STATUS struct {
	GroupId              *string                `json:"groupId,omitempty"`
	Id                   *string                `json:"id,omitempty"`
	Name                 *string                `json:"name,omitempty"`
	PrivateLinkServiceID *string                `json:"privateLinkServiceID,omitempty"`
	PropertyBag          genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	RequiredMembers      []string               `json:"requiredMembers,omitempty"`
	Type                 *string                `json:"type,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromPrivateLinkResource_STATUS populates our PrivateLinkResource_STATUS from the provided source PrivateLinkResource_STATUS
func (resource *PrivateLinkResource_STATUS) AssignPropertiesFromPrivateLinkResource_STATUS(source *v20210501s.PrivateLinkResource_STATUS) error {
=======
// AssignProperties_From_PrivateLinkResource_STATUS populates our PrivateLinkResource_STATUS from the provided source PrivateLinkResource_STATUS
func (resource *PrivateLinkResource_STATUS) AssignProperties_From_PrivateLinkResource_STATUS(source *v20210501s.PrivateLinkResource_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// GroupId
	resource.GroupId = genruntime.ClonePointerToString(source.GroupId)

	// Id
	resource.Id = genruntime.ClonePointerToString(source.Id)

	// Name
	resource.Name = genruntime.ClonePointerToString(source.Name)

	// PrivateLinkServiceID
	resource.PrivateLinkServiceID = genruntime.ClonePointerToString(source.PrivateLinkServiceID)

	// RequiredMembers
	resource.RequiredMembers = genruntime.CloneSliceOfString(source.RequiredMembers)

	// Type
	resource.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		resource.PropertyBag = propertyBag
	} else {
		resource.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToPrivateLinkResource_STATUS populates the provided destination PrivateLinkResource_STATUS from our PrivateLinkResource_STATUS
func (resource *PrivateLinkResource_STATUS) AssignPropertiesToPrivateLinkResource_STATUS(destination *v20210501s.PrivateLinkResource_STATUS) error {
=======
// AssignProperties_To_PrivateLinkResource_STATUS populates the provided destination PrivateLinkResource_STATUS from our PrivateLinkResource_STATUS
func (resource *PrivateLinkResource_STATUS) AssignProperties_To_PrivateLinkResource_STATUS(destination *v20210501s.PrivateLinkResource_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(resource.PropertyBag)

	// GroupId
	destination.GroupId = genruntime.ClonePointerToString(resource.GroupId)

	// Id
	destination.Id = genruntime.ClonePointerToString(resource.Id)

	// Name
	destination.Name = genruntime.ClonePointerToString(resource.Name)

	// PrivateLinkServiceID
	destination.PrivateLinkServiceID = genruntime.ClonePointerToString(resource.PrivateLinkServiceID)

	// RequiredMembers
	destination.RequiredMembers = genruntime.CloneSliceOfString(resource.RequiredMembers)

	// Type
	destination.Type = genruntime.ClonePointerToString(resource.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ContainerServiceSshConfiguration
// Deprecated version of ContainerServiceSshConfiguration. Use v1beta20210501.ContainerServiceSshConfiguration instead
type ContainerServiceSshConfiguration struct {
	PropertyBag genruntime.PropertyBag         `json:"$propertyBag,omitempty"`
	PublicKeys  []ContainerServiceSshPublicKey `json:"publicKeys,omitempty"`
}

// AssignProperties_From_ContainerServiceSshConfiguration populates our ContainerServiceSshConfiguration from the provided source ContainerServiceSshConfiguration
func (configuration *ContainerServiceSshConfiguration) AssignProperties_From_ContainerServiceSshConfiguration(source *v20210501s.ContainerServiceSshConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]ContainerServiceSshPublicKey, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey ContainerServiceSshPublicKey
			err := publicKey.AssignProperties_From_ContainerServiceSshPublicKey(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceSshPublicKey() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceSshConfiguration populates the provided destination ContainerServiceSshConfiguration from our ContainerServiceSshConfiguration
func (configuration *ContainerServiceSshConfiguration) AssignProperties_To_ContainerServiceSshConfiguration(destination *v20210501s.ContainerServiceSshConfiguration) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]v20210501s.ContainerServiceSshPublicKey, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey v20210501s.ContainerServiceSshPublicKey
			err := publicKeyItem.AssignProperties_To_ContainerServiceSshPublicKey(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceSshPublicKey() to populate field PublicKeys")
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ContainerServiceSshConfiguration_STATUS
// Deprecated version of ContainerServiceSshConfiguration_STATUS. Use v1beta20210501.ContainerServiceSshConfiguration_STATUS instead
type ContainerServiceSshConfiguration_STATUS struct {
	PropertyBag genruntime.PropertyBag                `json:"$propertyBag,omitempty"`
	PublicKeys  []ContainerServiceSshPublicKey_STATUS `json:"publicKeys,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromContainerServiceSshConfiguration_STATUS populates our ContainerServiceSshConfiguration_STATUS from the provided source ContainerServiceSshConfiguration_STATUS
func (configuration *ContainerServiceSshConfiguration_STATUS) AssignPropertiesFromContainerServiceSshConfiguration_STATUS(source *v20210501s.ContainerServiceSshConfiguration_STATUS) error {
=======
// AssignProperties_From_ContainerServiceSshConfiguration_STATUS populates our ContainerServiceSshConfiguration_STATUS from the provided source ContainerServiceSshConfiguration_STATUS
func (configuration *ContainerServiceSshConfiguration_STATUS) AssignProperties_From_ContainerServiceSshConfiguration_STATUS(source *v20210501s.ContainerServiceSshConfiguration_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PublicKeys
	if source.PublicKeys != nil {
		publicKeyList := make([]ContainerServiceSshPublicKey_STATUS, len(source.PublicKeys))
		for publicKeyIndex, publicKeyItem := range source.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey ContainerServiceSshPublicKey_STATUS
<<<<<<< HEAD
			err := publicKey.AssignPropertiesFromContainerServiceSshPublicKey_STATUS(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromContainerServiceSshPublicKey_STATUS() to populate field PublicKeys")
=======
			err := publicKey.AssignProperties_From_ContainerServiceSshPublicKey_STATUS(&publicKeyItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ContainerServiceSshPublicKey_STATUS() to populate field PublicKeys")
>>>>>>> main
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		configuration.PublicKeys = publicKeyList
	} else {
		configuration.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		configuration.PropertyBag = propertyBag
	} else {
		configuration.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToContainerServiceSshConfiguration_STATUS populates the provided destination ContainerServiceSshConfiguration_STATUS from our ContainerServiceSshConfiguration_STATUS
func (configuration *ContainerServiceSshConfiguration_STATUS) AssignPropertiesToContainerServiceSshConfiguration_STATUS(destination *v20210501s.ContainerServiceSshConfiguration_STATUS) error {
=======
// AssignProperties_To_ContainerServiceSshConfiguration_STATUS populates the provided destination ContainerServiceSshConfiguration_STATUS from our ContainerServiceSshConfiguration_STATUS
func (configuration *ContainerServiceSshConfiguration_STATUS) AssignProperties_To_ContainerServiceSshConfiguration_STATUS(destination *v20210501s.ContainerServiceSshConfiguration_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(configuration.PropertyBag)

	// PublicKeys
	if configuration.PublicKeys != nil {
		publicKeyList := make([]v20210501s.ContainerServiceSshPublicKey_STATUS, len(configuration.PublicKeys))
		for publicKeyIndex, publicKeyItem := range configuration.PublicKeys {
			// Shadow the loop variable to avoid aliasing
			publicKeyItem := publicKeyItem
			var publicKey v20210501s.ContainerServiceSshPublicKey_STATUS
<<<<<<< HEAD
			err := publicKeyItem.AssignPropertiesToContainerServiceSshPublicKey_STATUS(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToContainerServiceSshPublicKey_STATUS() to populate field PublicKeys")
=======
			err := publicKeyItem.AssignProperties_To_ContainerServiceSshPublicKey_STATUS(&publicKey)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ContainerServiceSshPublicKey_STATUS() to populate field PublicKeys")
>>>>>>> main
			}
			publicKeyList[publicKeyIndex] = publicKey
		}
		destination.PublicKeys = publicKeyList
	} else {
		destination.PublicKeys = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterIdentity_UserAssignedIdentities_STATUS
// Deprecated version of ManagedClusterIdentity_UserAssignedIdentities_STATUS. Use v1beta20210501.ManagedClusterIdentity_UserAssignedIdentities_STATUS instead
type ManagedClusterIdentity_UserAssignedIdentities_STATUS struct {
	ClientId    *string                `json:"clientId,omitempty"`
	PrincipalId *string                `json:"principalId,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterIdentity_UserAssignedIdentities_STATUS populates our ManagedClusterIdentity_UserAssignedIdentities_STATUS from the provided source ManagedClusterIdentity_UserAssignedIdentities_STATUS
func (identities *ManagedClusterIdentity_UserAssignedIdentities_STATUS) AssignPropertiesFromManagedClusterIdentity_UserAssignedIdentities_STATUS(source *v20210501s.ManagedClusterIdentity_UserAssignedIdentities_STATUS) error {
=======
// AssignProperties_From_ManagedClusterIdentity_STATUS_UserAssignedIdentities populates our ManagedClusterIdentity_STATUS_UserAssignedIdentities from the provided source ManagedClusterIdentity_STATUS_UserAssignedIdentities
func (identities *ManagedClusterIdentity_STATUS_UserAssignedIdentities) AssignProperties_From_ManagedClusterIdentity_STATUS_UserAssignedIdentities(source *v20210501s.ManagedClusterIdentity_STATUS_UserAssignedIdentities) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	identities.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// PrincipalId
	identities.PrincipalId = genruntime.ClonePointerToString(source.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		identities.PropertyBag = propertyBag
	} else {
		identities.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterIdentity_UserAssignedIdentities_STATUS populates the provided destination ManagedClusterIdentity_UserAssignedIdentities_STATUS from our ManagedClusterIdentity_UserAssignedIdentities_STATUS
func (identities *ManagedClusterIdentity_UserAssignedIdentities_STATUS) AssignPropertiesToManagedClusterIdentity_UserAssignedIdentities_STATUS(destination *v20210501s.ManagedClusterIdentity_UserAssignedIdentities_STATUS) error {
=======
// AssignProperties_To_ManagedClusterIdentity_STATUS_UserAssignedIdentities populates the provided destination ManagedClusterIdentity_STATUS_UserAssignedIdentities from our ManagedClusterIdentity_STATUS_UserAssignedIdentities
func (identities *ManagedClusterIdentity_STATUS_UserAssignedIdentities) AssignProperties_To_ManagedClusterIdentity_STATUS_UserAssignedIdentities(destination *v20210501s.ManagedClusterIdentity_STATUS_UserAssignedIdentities) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identities.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identities.ClientId)

	// PrincipalId
	destination.PrincipalId = genruntime.ClonePointerToString(identities.PrincipalId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterLoadBalancerProfile
// Deprecated version of ManagedClusterLoadBalancerProfile. Use v1beta20210501.ManagedClusterLoadBalancerProfile instead
type ManagedClusterLoadBalancerProfile struct {
	AllocatedOutboundPorts *int                                                  `json:"allocatedOutboundPorts,omitempty"`
	EffectiveOutboundIPs   []ResourceReference                                   `json:"effectiveOutboundIPs,omitempty"`
	IdleTimeoutInMinutes   *int                                                  `json:"idleTimeoutInMinutes,omitempty"`
	ManagedOutboundIPs     *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs `json:"managedOutboundIPs,omitempty"`
	OutboundIPPrefixes     *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes `json:"outboundIPPrefixes,omitempty"`
	OutboundIPs            *ManagedClusterLoadBalancerProfile_OutboundIPs        `json:"outboundIPs,omitempty"`
	PropertyBag            genruntime.PropertyBag                                `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ManagedClusterLoadBalancerProfile populates our ManagedClusterLoadBalancerProfile from the provided source ManagedClusterLoadBalancerProfile
func (profile *ManagedClusterLoadBalancerProfile) AssignProperties_From_ManagedClusterLoadBalancerProfile(source *v20210501s.ManagedClusterLoadBalancerProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllocatedOutboundPorts
	profile.AllocatedOutboundPorts = genruntime.ClonePointerToInt(source.AllocatedOutboundPorts)

	// EffectiveOutboundIPs
	if source.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]ResourceReference, len(source.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range source.EffectiveOutboundIPs {
			// Shadow the loop variable to avoid aliasing
			effectiveOutboundIPItem := effectiveOutboundIPItem
			var effectiveOutboundIP ResourceReference
			err := effectiveOutboundIP.AssignProperties_From_ResourceReference(&effectiveOutboundIPItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field EffectiveOutboundIPs")
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		profile.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		profile.EffectiveOutboundIPs = nil
	}

	// IdleTimeoutInMinutes
	profile.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// ManagedOutboundIPs
	if source.ManagedOutboundIPs != nil {
<<<<<<< HEAD
		var managedOutboundIP ManagedClusterLoadBalancerProfile_ManagedOutboundIPs
		err := managedOutboundIP.AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs(source.ManagedOutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs() to populate field ManagedOutboundIPs")
=======
		var managedOutboundIP ManagedClusterLoadBalancerProfileManagedOutboundIPs
		err := managedOutboundIP.AssignProperties_From_ManagedClusterLoadBalancerProfileManagedOutboundIPs(source.ManagedOutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfileManagedOutboundIPs() to populate field ManagedOutboundIPs")
>>>>>>> main
		}
		profile.ManagedOutboundIPs = &managedOutboundIP
	} else {
		profile.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if source.OutboundIPPrefixes != nil {
<<<<<<< HEAD
		var outboundIPPrefix ManagedClusterLoadBalancerProfile_OutboundIPPrefixes
		err := outboundIPPrefix.AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes(source.OutboundIPPrefixes)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes() to populate field OutboundIPPrefixes")
=======
		var outboundIPPrefix ManagedClusterLoadBalancerProfileOutboundIPPrefixes
		err := outboundIPPrefix.AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPPrefixes(source.OutboundIPPrefixes)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPPrefixes() to populate field OutboundIPPrefixes")
>>>>>>> main
		}
		profile.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		profile.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if source.OutboundIPs != nil {
<<<<<<< HEAD
		var outboundIP ManagedClusterLoadBalancerProfile_OutboundIPs
		err := outboundIP.AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs(source.OutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs() to populate field OutboundIPs")
=======
		var outboundIP ManagedClusterLoadBalancerProfileOutboundIPs
		err := outboundIP.AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPs(source.OutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPs() to populate field OutboundIPs")
>>>>>>> main
		}
		profile.OutboundIPs = &outboundIP
	} else {
		profile.OutboundIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfile populates the provided destination ManagedClusterLoadBalancerProfile from our ManagedClusterLoadBalancerProfile
func (profile *ManagedClusterLoadBalancerProfile) AssignProperties_To_ManagedClusterLoadBalancerProfile(destination *v20210501s.ManagedClusterLoadBalancerProfile) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AllocatedOutboundPorts
	destination.AllocatedOutboundPorts = genruntime.ClonePointerToInt(profile.AllocatedOutboundPorts)

	// EffectiveOutboundIPs
	if profile.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]v20210501s.ResourceReference, len(profile.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range profile.EffectiveOutboundIPs {
			// Shadow the loop variable to avoid aliasing
			effectiveOutboundIPItem := effectiveOutboundIPItem
			var effectiveOutboundIP v20210501s.ResourceReference
			err := effectiveOutboundIPItem.AssignProperties_To_ResourceReference(&effectiveOutboundIP)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field EffectiveOutboundIPs")
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		destination.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		destination.EffectiveOutboundIPs = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(profile.IdleTimeoutInMinutes)

	// ManagedOutboundIPs
	if profile.ManagedOutboundIPs != nil {
<<<<<<< HEAD
		var managedOutboundIP v20210501s.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs
		err := profile.ManagedOutboundIPs.AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs(&managedOutboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs() to populate field ManagedOutboundIPs")
=======
		var managedOutboundIP v20210501s.ManagedClusterLoadBalancerProfileManagedOutboundIPs
		err := profile.ManagedOutboundIPs.AssignProperties_To_ManagedClusterLoadBalancerProfileManagedOutboundIPs(&managedOutboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfileManagedOutboundIPs() to populate field ManagedOutboundIPs")
>>>>>>> main
		}
		destination.ManagedOutboundIPs = &managedOutboundIP
	} else {
		destination.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if profile.OutboundIPPrefixes != nil {
<<<<<<< HEAD
		var outboundIPPrefix v20210501s.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes
		err := profile.OutboundIPPrefixes.AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes(&outboundIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes() to populate field OutboundIPPrefixes")
=======
		var outboundIPPrefix v20210501s.ManagedClusterLoadBalancerProfileOutboundIPPrefixes
		err := profile.OutboundIPPrefixes.AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPPrefixes(&outboundIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPPrefixes() to populate field OutboundIPPrefixes")
>>>>>>> main
		}
		destination.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		destination.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if profile.OutboundIPs != nil {
<<<<<<< HEAD
		var outboundIP v20210501s.ManagedClusterLoadBalancerProfile_OutboundIPs
		err := profile.OutboundIPs.AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs(&outboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs() to populate field OutboundIPs")
=======
		var outboundIP v20210501s.ManagedClusterLoadBalancerProfileOutboundIPs
		err := profile.OutboundIPs.AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPs(&outboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPs() to populate field OutboundIPs")
>>>>>>> main
		}
		destination.OutboundIPs = &outboundIP
	} else {
		destination.OutboundIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterLoadBalancerProfile_STATUS
// Deprecated version of ManagedClusterLoadBalancerProfile_STATUS. Use v1beta20210501.ManagedClusterLoadBalancerProfile_STATUS instead
type ManagedClusterLoadBalancerProfile_STATUS struct {
	AllocatedOutboundPorts *int                                                         `json:"allocatedOutboundPorts,omitempty"`
	EffectiveOutboundIPs   []ResourceReference_STATUS                                   `json:"effectiveOutboundIPs,omitempty"`
	IdleTimeoutInMinutes   *int                                                         `json:"idleTimeoutInMinutes,omitempty"`
	ManagedOutboundIPs     *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS `json:"managedOutboundIPs,omitempty"`
	OutboundIPPrefixes     *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS `json:"outboundIPPrefixes,omitempty"`
	OutboundIPs            *ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS        `json:"outboundIPs,omitempty"`
	PropertyBag            genruntime.PropertyBag                                       `json:"$propertyBag,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterLoadBalancerProfile_STATUS populates our ManagedClusterLoadBalancerProfile_STATUS from the provided source ManagedClusterLoadBalancerProfile_STATUS
func (profile *ManagedClusterLoadBalancerProfile_STATUS) AssignPropertiesFromManagedClusterLoadBalancerProfile_STATUS(source *v20210501s.ManagedClusterLoadBalancerProfile_STATUS) error {
=======
// AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS populates our ManagedClusterLoadBalancerProfile_STATUS from the provided source ManagedClusterLoadBalancerProfile_STATUS
func (profile *ManagedClusterLoadBalancerProfile_STATUS) AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS(source *v20210501s.ManagedClusterLoadBalancerProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AllocatedOutboundPorts
	profile.AllocatedOutboundPorts = genruntime.ClonePointerToInt(source.AllocatedOutboundPorts)

	// EffectiveOutboundIPs
	if source.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]ResourceReference_STATUS, len(source.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range source.EffectiveOutboundIPs {
			// Shadow the loop variable to avoid aliasing
			effectiveOutboundIPItem := effectiveOutboundIPItem
			var effectiveOutboundIP ResourceReference_STATUS
<<<<<<< HEAD
			err := effectiveOutboundIP.AssignPropertiesFromResourceReference_STATUS(&effectiveOutboundIPItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromResourceReference_STATUS() to populate field EffectiveOutboundIPs")
=======
			err := effectiveOutboundIP.AssignProperties_From_ResourceReference_STATUS(&effectiveOutboundIPItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field EffectiveOutboundIPs")
>>>>>>> main
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		profile.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		profile.EffectiveOutboundIPs = nil
	}

	// IdleTimeoutInMinutes
	profile.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(source.IdleTimeoutInMinutes)

	// ManagedOutboundIPs
	if source.ManagedOutboundIPs != nil {
<<<<<<< HEAD
		var managedOutboundIP ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS
		err := managedOutboundIP.AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS(source.ManagedOutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS() to populate field ManagedOutboundIPs")
=======
		var managedOutboundIP ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs
		err := managedOutboundIP.AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs(source.ManagedOutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs() to populate field ManagedOutboundIPs")
>>>>>>> main
		}
		profile.ManagedOutboundIPs = &managedOutboundIP
	} else {
		profile.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if source.OutboundIPPrefixes != nil {
<<<<<<< HEAD
		var outboundIPPrefix ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS
		err := outboundIPPrefix.AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS(source.OutboundIPPrefixes)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS() to populate field OutboundIPPrefixes")
=======
		var outboundIPPrefix ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes
		err := outboundIPPrefix.AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes(source.OutboundIPPrefixes)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes() to populate field OutboundIPPrefixes")
>>>>>>> main
		}
		profile.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		profile.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if source.OutboundIPs != nil {
<<<<<<< HEAD
		var outboundIP ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS
		err := outboundIP.AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs_STATUS(source.OutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs_STATUS() to populate field OutboundIPs")
=======
		var outboundIP ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs
		err := outboundIP.AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs(source.OutboundIPs)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs() to populate field OutboundIPs")
>>>>>>> main
		}
		profile.OutboundIPs = &outboundIP
	} else {
		profile.OutboundIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		profile.PropertyBag = propertyBag
	} else {
		profile.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterLoadBalancerProfile_STATUS populates the provided destination ManagedClusterLoadBalancerProfile_STATUS from our ManagedClusterLoadBalancerProfile_STATUS
func (profile *ManagedClusterLoadBalancerProfile_STATUS) AssignPropertiesToManagedClusterLoadBalancerProfile_STATUS(destination *v20210501s.ManagedClusterLoadBalancerProfile_STATUS) error {
=======
// AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS populates the provided destination ManagedClusterLoadBalancerProfile_STATUS from our ManagedClusterLoadBalancerProfile_STATUS
func (profile *ManagedClusterLoadBalancerProfile_STATUS) AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS(destination *v20210501s.ManagedClusterLoadBalancerProfile_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(profile.PropertyBag)

	// AllocatedOutboundPorts
	destination.AllocatedOutboundPorts = genruntime.ClonePointerToInt(profile.AllocatedOutboundPorts)

	// EffectiveOutboundIPs
	if profile.EffectiveOutboundIPs != nil {
		effectiveOutboundIPList := make([]v20210501s.ResourceReference_STATUS, len(profile.EffectiveOutboundIPs))
		for effectiveOutboundIPIndex, effectiveOutboundIPItem := range profile.EffectiveOutboundIPs {
			// Shadow the loop variable to avoid aliasing
			effectiveOutboundIPItem := effectiveOutboundIPItem
			var effectiveOutboundIP v20210501s.ResourceReference_STATUS
<<<<<<< HEAD
			err := effectiveOutboundIPItem.AssignPropertiesToResourceReference_STATUS(&effectiveOutboundIP)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToResourceReference_STATUS() to populate field EffectiveOutboundIPs")
=======
			err := effectiveOutboundIPItem.AssignProperties_To_ResourceReference_STATUS(&effectiveOutboundIP)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field EffectiveOutboundIPs")
>>>>>>> main
			}
			effectiveOutboundIPList[effectiveOutboundIPIndex] = effectiveOutboundIP
		}
		destination.EffectiveOutboundIPs = effectiveOutboundIPList
	} else {
		destination.EffectiveOutboundIPs = nil
	}

	// IdleTimeoutInMinutes
	destination.IdleTimeoutInMinutes = genruntime.ClonePointerToInt(profile.IdleTimeoutInMinutes)

	// ManagedOutboundIPs
	if profile.ManagedOutboundIPs != nil {
<<<<<<< HEAD
		var managedOutboundIP v20210501s.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS
		err := profile.ManagedOutboundIPs.AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS(&managedOutboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS() to populate field ManagedOutboundIPs")
=======
		var managedOutboundIP v20210501s.ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs
		err := profile.ManagedOutboundIPs.AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs(&managedOutboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs() to populate field ManagedOutboundIPs")
>>>>>>> main
		}
		destination.ManagedOutboundIPs = &managedOutboundIP
	} else {
		destination.ManagedOutboundIPs = nil
	}

	// OutboundIPPrefixes
	if profile.OutboundIPPrefixes != nil {
<<<<<<< HEAD
		var outboundIPPrefix v20210501s.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS
		err := profile.OutboundIPPrefixes.AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS(&outboundIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS() to populate field OutboundIPPrefixes")
=======
		var outboundIPPrefix v20210501s.ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes
		err := profile.OutboundIPPrefixes.AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes(&outboundIPPrefix)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes() to populate field OutboundIPPrefixes")
>>>>>>> main
		}
		destination.OutboundIPPrefixes = &outboundIPPrefix
	} else {
		destination.OutboundIPPrefixes = nil
	}

	// OutboundIPs
	if profile.OutboundIPs != nil {
<<<<<<< HEAD
		var outboundIP v20210501s.ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS
		err := profile.OutboundIPs.AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs_STATUS(&outboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs_STATUS() to populate field OutboundIPs")
=======
		var outboundIP v20210501s.ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs
		err := profile.OutboundIPs.AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs(&outboundIP)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs() to populate field OutboundIPs")
>>>>>>> main
		}
		destination.OutboundIPs = &outboundIP
	} else {
		destination.OutboundIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterOperatorSecrets
type ManagedClusterOperatorSecrets struct {
	AdminCredentials *genruntime.SecretDestination `json:"adminCredentials,omitempty"`
	PropertyBag      genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	UserCredentials  *genruntime.SecretDestination `json:"userCredentials,omitempty"`
}

// AssignProperties_From_ManagedClusterOperatorSecrets populates our ManagedClusterOperatorSecrets from the provided source ManagedClusterOperatorSecrets
func (secrets *ManagedClusterOperatorSecrets) AssignProperties_From_ManagedClusterOperatorSecrets(source *v20210501s.ManagedClusterOperatorSecrets) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdminCredentials
	if source.AdminCredentials != nil {
		adminCredential := source.AdminCredentials.Copy()
		secrets.AdminCredentials = &adminCredential
	} else {
		secrets.AdminCredentials = nil
	}

	// UserCredentials
	if source.UserCredentials != nil {
		userCredential := source.UserCredentials.Copy()
		secrets.UserCredentials = &userCredential
	} else {
		secrets.UserCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		secrets.PropertyBag = propertyBag
	} else {
		secrets.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterOperatorSecrets populates the provided destination ManagedClusterOperatorSecrets from our ManagedClusterOperatorSecrets
func (secrets *ManagedClusterOperatorSecrets) AssignProperties_To_ManagedClusterOperatorSecrets(destination *v20210501s.ManagedClusterOperatorSecrets) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(secrets.PropertyBag)

	// AdminCredentials
	if secrets.AdminCredentials != nil {
		adminCredential := secrets.AdminCredentials.Copy()
		destination.AdminCredentials = &adminCredential
	} else {
		destination.AdminCredentials = nil
	}

	// UserCredentials
	if secrets.UserCredentials != nil {
		userCredential := secrets.UserCredentials.Copy()
		destination.UserCredentials = &userCredential
	} else {
		destination.UserCredentials = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterPodIdentity
// Deprecated version of ManagedClusterPodIdentity. Use v1beta20210501.ManagedClusterPodIdentity instead
type ManagedClusterPodIdentity struct {
	BindingSelector *string                `json:"bindingSelector,omitempty"`
	Identity        *UserAssignedIdentity  `json:"identity,omitempty"`
	Name            *string                `json:"name,omitempty"`
	Namespace       *string                `json:"namespace,omitempty"`
	PropertyBag     genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ManagedClusterPodIdentity populates our ManagedClusterPodIdentity from the provided source ManagedClusterPodIdentity
func (identity *ManagedClusterPodIdentity) AssignProperties_From_ManagedClusterPodIdentity(source *v20210501s.ManagedClusterPodIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BindingSelector
	identity.BindingSelector = genruntime.ClonePointerToString(source.BindingSelector)

	// Identity
	if source.Identity != nil {
		var identityLocal UserAssignedIdentity
		err := identityLocal.AssignProperties_From_UserAssignedIdentity(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity() to populate field Identity")
		}
		identity.Identity = &identityLocal
	} else {
		identity.Identity = nil
	}

	// Name
	identity.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	identity.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentity populates the provided destination ManagedClusterPodIdentity from our ManagedClusterPodIdentity
func (identity *ManagedClusterPodIdentity) AssignProperties_To_ManagedClusterPodIdentity(destination *v20210501s.ManagedClusterPodIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// BindingSelector
	destination.BindingSelector = genruntime.ClonePointerToString(identity.BindingSelector)

	// Identity
	if identity.Identity != nil {
		var identityLocal v20210501s.UserAssignedIdentity
		err := identity.Identity.AssignProperties_To_UserAssignedIdentity(&identityLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity() to populate field Identity")
		}
		destination.Identity = &identityLocal
	} else {
		destination.Identity = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(identity.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(identity.Namespace)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterPodIdentity_STATUS
// Deprecated version of ManagedClusterPodIdentity_STATUS. Use v1beta20210501.ManagedClusterPodIdentity_STATUS instead
type ManagedClusterPodIdentity_STATUS struct {
	BindingSelector   *string                                            `json:"bindingSelector,omitempty"`
	Identity          *UserAssignedIdentity_STATUS                       `json:"identity,omitempty"`
	Name              *string                                            `json:"name,omitempty"`
	Namespace         *string                                            `json:"namespace,omitempty"`
	PropertyBag       genruntime.PropertyBag                             `json:"$propertyBag,omitempty"`
	ProvisioningInfo  *ManagedClusterPodIdentity_ProvisioningInfo_STATUS `json:"provisioningInfo,omitempty"`
	ProvisioningState *string                                            `json:"provisioningState,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterPodIdentity_STATUS populates our ManagedClusterPodIdentity_STATUS from the provided source ManagedClusterPodIdentity_STATUS
func (identity *ManagedClusterPodIdentity_STATUS) AssignPropertiesFromManagedClusterPodIdentity_STATUS(source *v20210501s.ManagedClusterPodIdentity_STATUS) error {
=======
// AssignProperties_From_ManagedClusterPodIdentity_STATUS populates our ManagedClusterPodIdentity_STATUS from the provided source ManagedClusterPodIdentity_STATUS
func (identity *ManagedClusterPodIdentity_STATUS) AssignProperties_From_ManagedClusterPodIdentity_STATUS(source *v20210501s.ManagedClusterPodIdentity_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// BindingSelector
	identity.BindingSelector = genruntime.ClonePointerToString(source.BindingSelector)

	// Identity
	if source.Identity != nil {
		var identityLocal UserAssignedIdentity_STATUS
<<<<<<< HEAD
		err := identityLocal.AssignPropertiesFromUserAssignedIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromUserAssignedIdentity_STATUS() to populate field Identity")
=======
		err := identityLocal.AssignProperties_From_UserAssignedIdentity_STATUS(source.Identity)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_UserAssignedIdentity_STATUS() to populate field Identity")
>>>>>>> main
		}
		identity.Identity = &identityLocal
	} else {
		identity.Identity = nil
	}

	// Name
	identity.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	identity.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// ProvisioningInfo
	if source.ProvisioningInfo != nil {
<<<<<<< HEAD
		var provisioningInfo ManagedClusterPodIdentity_ProvisioningInfo_STATUS
		err := provisioningInfo.AssignPropertiesFromManagedClusterPodIdentity_ProvisioningInfo_STATUS(source.ProvisioningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentity_ProvisioningInfo_STATUS() to populate field ProvisioningInfo")
=======
		var provisioningInfo ManagedClusterPodIdentity_STATUS_ProvisioningInfo
		err := provisioningInfo.AssignProperties_From_ManagedClusterPodIdentity_STATUS_ProvisioningInfo(source.ProvisioningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentity_STATUS_ProvisioningInfo() to populate field ProvisioningInfo")
>>>>>>> main
		}
		identity.ProvisioningInfo = &provisioningInfo
	} else {
		identity.ProvisioningInfo = nil
	}

	// ProvisioningState
	identity.ProvisioningState = genruntime.ClonePointerToString(source.ProvisioningState)

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterPodIdentity_STATUS populates the provided destination ManagedClusterPodIdentity_STATUS from our ManagedClusterPodIdentity_STATUS
func (identity *ManagedClusterPodIdentity_STATUS) AssignPropertiesToManagedClusterPodIdentity_STATUS(destination *v20210501s.ManagedClusterPodIdentity_STATUS) error {
=======
// AssignProperties_To_ManagedClusterPodIdentity_STATUS populates the provided destination ManagedClusterPodIdentity_STATUS from our ManagedClusterPodIdentity_STATUS
func (identity *ManagedClusterPodIdentity_STATUS) AssignProperties_To_ManagedClusterPodIdentity_STATUS(destination *v20210501s.ManagedClusterPodIdentity_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// BindingSelector
	destination.BindingSelector = genruntime.ClonePointerToString(identity.BindingSelector)

	// Identity
	if identity.Identity != nil {
		var identityLocal v20210501s.UserAssignedIdentity_STATUS
<<<<<<< HEAD
		err := identity.Identity.AssignPropertiesToUserAssignedIdentity_STATUS(&identityLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToUserAssignedIdentity_STATUS() to populate field Identity")
=======
		err := identity.Identity.AssignProperties_To_UserAssignedIdentity_STATUS(&identityLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_UserAssignedIdentity_STATUS() to populate field Identity")
>>>>>>> main
		}
		destination.Identity = &identityLocal
	} else {
		destination.Identity = nil
	}

	// Name
	destination.Name = genruntime.ClonePointerToString(identity.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(identity.Namespace)

	// ProvisioningInfo
	if identity.ProvisioningInfo != nil {
<<<<<<< HEAD
		var provisioningInfo v20210501s.ManagedClusterPodIdentity_ProvisioningInfo_STATUS
		err := identity.ProvisioningInfo.AssignPropertiesToManagedClusterPodIdentity_ProvisioningInfo_STATUS(&provisioningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentity_ProvisioningInfo_STATUS() to populate field ProvisioningInfo")
=======
		var provisioningInfo v20210501s.ManagedClusterPodIdentity_STATUS_ProvisioningInfo
		err := identity.ProvisioningInfo.AssignProperties_To_ManagedClusterPodIdentity_STATUS_ProvisioningInfo(&provisioningInfo)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentity_STATUS_ProvisioningInfo() to populate field ProvisioningInfo")
>>>>>>> main
		}
		destination.ProvisioningInfo = &provisioningInfo
	} else {
		destination.ProvisioningInfo = nil
	}

	// ProvisioningState
	destination.ProvisioningState = genruntime.ClonePointerToString(identity.ProvisioningState)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterPodIdentityException
// Deprecated version of ManagedClusterPodIdentityException. Use v1beta20210501.ManagedClusterPodIdentityException instead
type ManagedClusterPodIdentityException struct {
	Name        *string                `json:"name,omitempty"`
	Namespace   *string                `json:"namespace,omitempty"`
	PodLabels   map[string]string      `json:"podLabels,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ManagedClusterPodIdentityException populates our ManagedClusterPodIdentityException from the provided source ManagedClusterPodIdentityException
func (exception *ManagedClusterPodIdentityException) AssignProperties_From_ManagedClusterPodIdentityException(source *v20210501s.ManagedClusterPodIdentityException) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	exception.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	exception.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// PodLabels
	exception.PodLabels = genruntime.CloneMapOfStringToString(source.PodLabels)

	// Update the property bag
	if len(propertyBag) > 0 {
		exception.PropertyBag = propertyBag
	} else {
		exception.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterPodIdentityException populates the provided destination ManagedClusterPodIdentityException from our ManagedClusterPodIdentityException
func (exception *ManagedClusterPodIdentityException) AssignProperties_To_ManagedClusterPodIdentityException(destination *v20210501s.ManagedClusterPodIdentityException) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(exception.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(exception.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(exception.Namespace)

	// PodLabels
	destination.PodLabels = genruntime.CloneMapOfStringToString(exception.PodLabels)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterPodIdentityException_STATUS
// Deprecated version of ManagedClusterPodIdentityException_STATUS. Use v1beta20210501.ManagedClusterPodIdentityException_STATUS instead
type ManagedClusterPodIdentityException_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	Namespace   *string                `json:"namespace,omitempty"`
	PodLabels   map[string]string      `json:"podLabels,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterPodIdentityException_STATUS populates our ManagedClusterPodIdentityException_STATUS from the provided source ManagedClusterPodIdentityException_STATUS
func (exception *ManagedClusterPodIdentityException_STATUS) AssignPropertiesFromManagedClusterPodIdentityException_STATUS(source *v20210501s.ManagedClusterPodIdentityException_STATUS) error {
=======
// AssignProperties_From_ManagedClusterPodIdentityException_STATUS populates our ManagedClusterPodIdentityException_STATUS from the provided source ManagedClusterPodIdentityException_STATUS
func (exception *ManagedClusterPodIdentityException_STATUS) AssignProperties_From_ManagedClusterPodIdentityException_STATUS(source *v20210501s.ManagedClusterPodIdentityException_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Name
	exception.Name = genruntime.ClonePointerToString(source.Name)

	// Namespace
	exception.Namespace = genruntime.ClonePointerToString(source.Namespace)

	// PodLabels
	exception.PodLabels = genruntime.CloneMapOfStringToString(source.PodLabels)

	// Update the property bag
	if len(propertyBag) > 0 {
		exception.PropertyBag = propertyBag
	} else {
		exception.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterPodIdentityException_STATUS populates the provided destination ManagedClusterPodIdentityException_STATUS from our ManagedClusterPodIdentityException_STATUS
func (exception *ManagedClusterPodIdentityException_STATUS) AssignPropertiesToManagedClusterPodIdentityException_STATUS(destination *v20210501s.ManagedClusterPodIdentityException_STATUS) error {
=======
// AssignProperties_To_ManagedClusterPodIdentityException_STATUS populates the provided destination ManagedClusterPodIdentityException_STATUS from our ManagedClusterPodIdentityException_STATUS
func (exception *ManagedClusterPodIdentityException_STATUS) AssignProperties_To_ManagedClusterPodIdentityException_STATUS(destination *v20210501s.ManagedClusterPodIdentityException_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(exception.PropertyBag)

	// Name
	destination.Name = genruntime.ClonePointerToString(exception.Name)

	// Namespace
	destination.Namespace = genruntime.ClonePointerToString(exception.Namespace)

	// PodLabels
	destination.PodLabels = genruntime.CloneMapOfStringToString(exception.PodLabels)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ContainerServiceSshPublicKey
// Deprecated version of ContainerServiceSshPublicKey. Use v1beta20210501.ContainerServiceSshPublicKey instead
type ContainerServiceSshPublicKey struct {
	KeyData     *string                `json:"keyData,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// AssignProperties_From_ContainerServiceSshPublicKey populates our ContainerServiceSshPublicKey from the provided source ContainerServiceSshPublicKey
func (publicKey *ContainerServiceSshPublicKey) AssignProperties_From_ContainerServiceSshPublicKey(source *v20210501s.ContainerServiceSshPublicKey) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Update the property bag
	if len(propertyBag) > 0 {
		publicKey.PropertyBag = propertyBag
	} else {
		publicKey.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ContainerServiceSshPublicKey populates the provided destination ContainerServiceSshPublicKey from our ContainerServiceSshPublicKey
func (publicKey *ContainerServiceSshPublicKey) AssignProperties_To_ContainerServiceSshPublicKey(destination *v20210501s.ContainerServiceSshPublicKey) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(publicKey.PropertyBag)

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ContainerServiceSshPublicKey_STATUS
// Deprecated version of ContainerServiceSshPublicKey_STATUS. Use v1beta20210501.ContainerServiceSshPublicKey_STATUS instead
type ContainerServiceSshPublicKey_STATUS struct {
	KeyData     *string                `json:"keyData,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromContainerServiceSshPublicKey_STATUS populates our ContainerServiceSshPublicKey_STATUS from the provided source ContainerServiceSshPublicKey_STATUS
func (publicKey *ContainerServiceSshPublicKey_STATUS) AssignPropertiesFromContainerServiceSshPublicKey_STATUS(source *v20210501s.ContainerServiceSshPublicKey_STATUS) error {
=======
// AssignProperties_From_ContainerServiceSshPublicKey_STATUS populates our ContainerServiceSshPublicKey_STATUS from the provided source ContainerServiceSshPublicKey_STATUS
func (publicKey *ContainerServiceSshPublicKey_STATUS) AssignProperties_From_ContainerServiceSshPublicKey_STATUS(source *v20210501s.ContainerServiceSshPublicKey_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// KeyData
	publicKey.KeyData = genruntime.ClonePointerToString(source.KeyData)

	// Update the property bag
	if len(propertyBag) > 0 {
		publicKey.PropertyBag = propertyBag
	} else {
		publicKey.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToContainerServiceSshPublicKey_STATUS populates the provided destination ContainerServiceSshPublicKey_STATUS from our ContainerServiceSshPublicKey_STATUS
func (publicKey *ContainerServiceSshPublicKey_STATUS) AssignPropertiesToContainerServiceSshPublicKey_STATUS(destination *v20210501s.ContainerServiceSshPublicKey_STATUS) error {
=======
// AssignProperties_To_ContainerServiceSshPublicKey_STATUS populates the provided destination ContainerServiceSshPublicKey_STATUS from our ContainerServiceSshPublicKey_STATUS
func (publicKey *ContainerServiceSshPublicKey_STATUS) AssignProperties_To_ContainerServiceSshPublicKey_STATUS(destination *v20210501s.ContainerServiceSshPublicKey_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(publicKey.PropertyBag)

	// KeyData
	destination.KeyData = genruntime.ClonePointerToString(publicKey.KeyData)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs
// Deprecated version of ManagedClusterLoadBalancerProfile_ManagedOutboundIPs. Use v1beta20210501.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs instead
type ManagedClusterLoadBalancerProfile_ManagedOutboundIPs struct {
	Count       *int                   `json:"count,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs populates our ManagedClusterLoadBalancerProfile_ManagedOutboundIPs from the provided source ManagedClusterLoadBalancerProfile_ManagedOutboundIPs
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs) AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs(source *v20210501s.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs) error {
=======
// AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs populates our ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs from the provided source ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs
func (iPs *ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs) AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs(source *v20210501s.ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Count
	iPs.Count = genruntime.ClonePointerToInt(source.Count)

	// Update the property bag
	if len(propertyBag) > 0 {
		iPs.PropertyBag = propertyBag
	} else {
		iPs.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs populates the provided destination ManagedClusterLoadBalancerProfile_ManagedOutboundIPs from our ManagedClusterLoadBalancerProfile_ManagedOutboundIPs
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs) AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs(destination *v20210501s.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs) error {
=======
// AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs populates the provided destination ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs from our ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs
func (iPs *ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs) AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs(destination *v20210501s.ManagedClusterLoadBalancerProfile_STATUS_ManagedOutboundIPs) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(iPs.PropertyBag)

	// Count
	destination.Count = genruntime.ClonePointerToInt(iPs.Count)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// Storage version of v1alpha1api20210501.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS
// Deprecated version of ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS. Use v1beta20210501.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS instead
type ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS struct {
=======
// Storage version of v1alpha1api20210501.ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes
// Deprecated version of ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes. Use v1beta20210501.ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes instead
type ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes struct {
	PropertyBag      genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	PublicIPPrefixes []ResourceReference_STATUS `json:"publicIPPrefixes,omitempty"`
}

// AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes populates our ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes from the provided source ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes
func (prefixes *ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes) AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes(source *v20210501s.ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PublicIPPrefixes
	if source.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]ResourceReference_STATUS, len(source.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range source.PublicIPPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIPPrefixItem := publicIPPrefixItem
			var publicIPPrefix ResourceReference_STATUS
			err := publicIPPrefix.AssignProperties_From_ResourceReference_STATUS(&publicIPPrefixItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		prefixes.PublicIPPrefixes = publicIPPrefixList
	} else {
		prefixes.PublicIPPrefixes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		prefixes.PropertyBag = propertyBag
	} else {
		prefixes.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes populates the provided destination ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes from our ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes
func (prefixes *ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes) AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes(destination *v20210501s.ManagedClusterLoadBalancerProfile_STATUS_OutboundIPPrefixes) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(prefixes.PropertyBag)

	// PublicIPPrefixes
	if prefixes.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]v20210501s.ResourceReference_STATUS, len(prefixes.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range prefixes.PublicIPPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIPPrefixItem := publicIPPrefixItem
			var publicIPPrefix v20210501s.ResourceReference_STATUS
			err := publicIPPrefixItem.AssignProperties_To_ResourceReference_STATUS(&publicIPPrefix)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		destination.PublicIPPrefixes = publicIPPrefixList
	} else {
		destination.PublicIPPrefixes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs
// Deprecated version of ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs. Use v1beta20210501.ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs instead
type ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs struct {
	PropertyBag genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	PublicIPs   []ResourceReference_STATUS `json:"publicIPs,omitempty"`
}

// AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs populates our ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs from the provided source ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs
func (iPs *ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs) AssignProperties_From_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs(source *v20210501s.ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PublicIPs
	if source.PublicIPs != nil {
		publicIPList := make([]ResourceReference_STATUS, len(source.PublicIPs))
		for publicIPIndex, publicIPItem := range source.PublicIPs {
			// Shadow the loop variable to avoid aliasing
			publicIPItem := publicIPItem
			var publicIP ResourceReference_STATUS
			err := publicIP.AssignProperties_From_ResourceReference_STATUS(&publicIPItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference_STATUS() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		iPs.PublicIPs = publicIPList
	} else {
		iPs.PublicIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		iPs.PropertyBag = propertyBag
	} else {
		iPs.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs populates the provided destination ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs from our ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs
func (iPs *ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs) AssignProperties_To_ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs(destination *v20210501s.ManagedClusterLoadBalancerProfile_STATUS_OutboundIPs) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(iPs.PropertyBag)

	// PublicIPs
	if iPs.PublicIPs != nil {
		publicIPList := make([]v20210501s.ResourceReference_STATUS, len(iPs.PublicIPs))
		for publicIPIndex, publicIPItem := range iPs.PublicIPs {
			// Shadow the loop variable to avoid aliasing
			publicIPItem := publicIPItem
			var publicIP v20210501s.ResourceReference_STATUS
			err := publicIPItem.AssignProperties_To_ResourceReference_STATUS(&publicIP)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference_STATUS() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		destination.PublicIPs = publicIPList
	} else {
		destination.PublicIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterLoadBalancerProfileManagedOutboundIPs
// Deprecated version of ManagedClusterLoadBalancerProfileManagedOutboundIPs. Use v1beta20210501.ManagedClusterLoadBalancerProfileManagedOutboundIPs instead
type ManagedClusterLoadBalancerProfileManagedOutboundIPs struct {
>>>>>>> main
	Count       *int                   `json:"count,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS populates our ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS from the provided source ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS) AssignPropertiesFromManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS(source *v20210501s.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS) error {
=======
// AssignProperties_From_ManagedClusterLoadBalancerProfileManagedOutboundIPs populates our ManagedClusterLoadBalancerProfileManagedOutboundIPs from the provided source ManagedClusterLoadBalancerProfileManagedOutboundIPs
func (iPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs) AssignProperties_From_ManagedClusterLoadBalancerProfileManagedOutboundIPs(source *v20210501s.ManagedClusterLoadBalancerProfileManagedOutboundIPs) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Count
	iPs.Count = genruntime.ClonePointerToInt(source.Count)

	// Update the property bag
	if len(propertyBag) > 0 {
		iPs.PropertyBag = propertyBag
	} else {
		iPs.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS populates the provided destination ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS from our ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS
func (iPs *ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS) AssignPropertiesToManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS(destination *v20210501s.ManagedClusterLoadBalancerProfile_ManagedOutboundIPs_STATUS) error {
=======
// AssignProperties_To_ManagedClusterLoadBalancerProfileManagedOutboundIPs populates the provided destination ManagedClusterLoadBalancerProfileManagedOutboundIPs from our ManagedClusterLoadBalancerProfileManagedOutboundIPs
func (iPs *ManagedClusterLoadBalancerProfileManagedOutboundIPs) AssignProperties_To_ManagedClusterLoadBalancerProfileManagedOutboundIPs(destination *v20210501s.ManagedClusterLoadBalancerProfileManagedOutboundIPs) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(iPs.PropertyBag)

	// Count
	destination.Count = genruntime.ClonePointerToInt(iPs.Count)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes
// Deprecated version of ManagedClusterLoadBalancerProfile_OutboundIPPrefixes. Use v1beta20210501.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes instead
type ManagedClusterLoadBalancerProfile_OutboundIPPrefixes struct {
	PropertyBag      genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	PublicIPPrefixes []ResourceReference    `json:"publicIPPrefixes,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes populates our ManagedClusterLoadBalancerProfile_OutboundIPPrefixes from the provided source ManagedClusterLoadBalancerProfile_OutboundIPPrefixes
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes) AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes(source *v20210501s.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes) error {
=======
// AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPPrefixes populates our ManagedClusterLoadBalancerProfileOutboundIPPrefixes from the provided source ManagedClusterLoadBalancerProfileOutboundIPPrefixes
func (prefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes) AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPPrefixes(source *v20210501s.ManagedClusterLoadBalancerProfileOutboundIPPrefixes) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PublicIPPrefixes
	if source.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]ResourceReference, len(source.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range source.PublicIPPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIPPrefixItem := publicIPPrefixItem
			var publicIPPrefix ResourceReference
			err := publicIPPrefix.AssignProperties_From_ResourceReference(&publicIPPrefixItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		prefixes.PublicIPPrefixes = publicIPPrefixList
	} else {
		prefixes.PublicIPPrefixes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		prefixes.PropertyBag = propertyBag
	} else {
		prefixes.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes populates the provided destination ManagedClusterLoadBalancerProfile_OutboundIPPrefixes from our ManagedClusterLoadBalancerProfile_OutboundIPPrefixes
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes) AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes(destination *v20210501s.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes) error {
=======
// AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPPrefixes populates the provided destination ManagedClusterLoadBalancerProfileOutboundIPPrefixes from our ManagedClusterLoadBalancerProfileOutboundIPPrefixes
func (prefixes *ManagedClusterLoadBalancerProfileOutboundIPPrefixes) AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPPrefixes(destination *v20210501s.ManagedClusterLoadBalancerProfileOutboundIPPrefixes) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(prefixes.PropertyBag)

	// PublicIPPrefixes
	if prefixes.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]v20210501s.ResourceReference, len(prefixes.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range prefixes.PublicIPPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIPPrefixItem := publicIPPrefixItem
			var publicIPPrefix v20210501s.ResourceReference
			err := publicIPPrefixItem.AssignProperties_To_ResourceReference(&publicIPPrefix)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		destination.PublicIPPrefixes = publicIPPrefixList
	} else {
		destination.PublicIPPrefixes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS
// Deprecated version of ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS. Use v1beta20210501.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS instead
type ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS struct {
	PropertyBag      genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	PublicIPPrefixes []ResourceReference_STATUS `json:"publicIPPrefixes,omitempty"`
}

// AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS populates our ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS from the provided source ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS) AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS(source *v20210501s.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PublicIPPrefixes
	if source.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]ResourceReference_STATUS, len(source.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range source.PublicIPPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIPPrefixItem := publicIPPrefixItem
			var publicIPPrefix ResourceReference_STATUS
			err := publicIPPrefix.AssignPropertiesFromResourceReference_STATUS(&publicIPPrefixItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromResourceReference_STATUS() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		prefixes.PublicIPPrefixes = publicIPPrefixList
	} else {
		prefixes.PublicIPPrefixes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		prefixes.PropertyBag = propertyBag
	} else {
		prefixes.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS populates the provided destination ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS from our ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS
func (prefixes *ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS) AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS(destination *v20210501s.ManagedClusterLoadBalancerProfile_OutboundIPPrefixes_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(prefixes.PropertyBag)

	// PublicIPPrefixes
	if prefixes.PublicIPPrefixes != nil {
		publicIPPrefixList := make([]v20210501s.ResourceReference_STATUS, len(prefixes.PublicIPPrefixes))
		for publicIPPrefixIndex, publicIPPrefixItem := range prefixes.PublicIPPrefixes {
			// Shadow the loop variable to avoid aliasing
			publicIPPrefixItem := publicIPPrefixItem
			var publicIPPrefix v20210501s.ResourceReference_STATUS
			err := publicIPPrefixItem.AssignPropertiesToResourceReference_STATUS(&publicIPPrefix)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToResourceReference_STATUS() to populate field PublicIPPrefixes")
			}
			publicIPPrefixList[publicIPPrefixIndex] = publicIPPrefix
		}
		destination.PublicIPPrefixes = publicIPPrefixList
	} else {
		destination.PublicIPPrefixes = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterLoadBalancerProfile_OutboundIPs
// Deprecated version of ManagedClusterLoadBalancerProfile_OutboundIPs. Use v1beta20210501.ManagedClusterLoadBalancerProfile_OutboundIPs instead
type ManagedClusterLoadBalancerProfile_OutboundIPs struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	PublicIPs   []ResourceReference    `json:"publicIPs,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs populates our ManagedClusterLoadBalancerProfile_OutboundIPs from the provided source ManagedClusterLoadBalancerProfile_OutboundIPs
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs) AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs(source *v20210501s.ManagedClusterLoadBalancerProfile_OutboundIPs) error {
=======
// AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPs populates our ManagedClusterLoadBalancerProfileOutboundIPs from the provided source ManagedClusterLoadBalancerProfileOutboundIPs
func (iPs *ManagedClusterLoadBalancerProfileOutboundIPs) AssignProperties_From_ManagedClusterLoadBalancerProfileOutboundIPs(source *v20210501s.ManagedClusterLoadBalancerProfileOutboundIPs) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PublicIPs
	if source.PublicIPs != nil {
		publicIPList := make([]ResourceReference, len(source.PublicIPs))
		for publicIPIndex, publicIPItem := range source.PublicIPs {
			// Shadow the loop variable to avoid aliasing
			publicIPItem := publicIPItem
			var publicIP ResourceReference
			err := publicIP.AssignProperties_From_ResourceReference(&publicIPItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ResourceReference() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		iPs.PublicIPs = publicIPList
	} else {
		iPs.PublicIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		iPs.PropertyBag = propertyBag
	} else {
		iPs.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs populates the provided destination ManagedClusterLoadBalancerProfile_OutboundIPs from our ManagedClusterLoadBalancerProfile_OutboundIPs
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs) AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs(destination *v20210501s.ManagedClusterLoadBalancerProfile_OutboundIPs) error {
=======
// AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPs populates the provided destination ManagedClusterLoadBalancerProfileOutboundIPs from our ManagedClusterLoadBalancerProfileOutboundIPs
func (iPs *ManagedClusterLoadBalancerProfileOutboundIPs) AssignProperties_To_ManagedClusterLoadBalancerProfileOutboundIPs(destination *v20210501s.ManagedClusterLoadBalancerProfileOutboundIPs) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(iPs.PropertyBag)

	// PublicIPs
	if iPs.PublicIPs != nil {
		publicIPList := make([]v20210501s.ResourceReference, len(iPs.PublicIPs))
		for publicIPIndex, publicIPItem := range iPs.PublicIPs {
			// Shadow the loop variable to avoid aliasing
			publicIPItem := publicIPItem
			var publicIP v20210501s.ResourceReference
			err := publicIPItem.AssignProperties_To_ResourceReference(&publicIP)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ResourceReference() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		destination.PublicIPs = publicIPList
	} else {
		destination.PublicIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS
// Deprecated version of ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS. Use v1beta20210501.ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS instead
type ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS struct {
	PropertyBag genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	PublicIPs   []ResourceReference_STATUS `json:"publicIPs,omitempty"`
}

// AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs_STATUS populates our ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS from the provided source ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS) AssignPropertiesFromManagedClusterLoadBalancerProfile_OutboundIPs_STATUS(source *v20210501s.ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// PublicIPs
	if source.PublicIPs != nil {
		publicIPList := make([]ResourceReference_STATUS, len(source.PublicIPs))
		for publicIPIndex, publicIPItem := range source.PublicIPs {
			// Shadow the loop variable to avoid aliasing
			publicIPItem := publicIPItem
			var publicIP ResourceReference_STATUS
			err := publicIP.AssignPropertiesFromResourceReference_STATUS(&publicIPItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromResourceReference_STATUS() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		iPs.PublicIPs = publicIPList
	} else {
		iPs.PublicIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		iPs.PropertyBag = propertyBag
	} else {
		iPs.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs_STATUS populates the provided destination ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS from our ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS
func (iPs *ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS) AssignPropertiesToManagedClusterLoadBalancerProfile_OutboundIPs_STATUS(destination *v20210501s.ManagedClusterLoadBalancerProfile_OutboundIPs_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(iPs.PropertyBag)

	// PublicIPs
	if iPs.PublicIPs != nil {
		publicIPList := make([]v20210501s.ResourceReference_STATUS, len(iPs.PublicIPs))
		for publicIPIndex, publicIPItem := range iPs.PublicIPs {
			// Shadow the loop variable to avoid aliasing
			publicIPItem := publicIPItem
			var publicIP v20210501s.ResourceReference_STATUS
			err := publicIPItem.AssignPropertiesToResourceReference_STATUS(&publicIP)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToResourceReference_STATUS() to populate field PublicIPs")
			}
			publicIPList[publicIPIndex] = publicIP
		}
		destination.PublicIPs = publicIPList
	} else {
		destination.PublicIPs = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterPodIdentity_ProvisioningInfo_STATUS
// Deprecated version of ManagedClusterPodIdentity_ProvisioningInfo_STATUS. Use v1beta20210501.ManagedClusterPodIdentity_ProvisioningInfo_STATUS instead
type ManagedClusterPodIdentity_ProvisioningInfo_STATUS struct {
	Error       *ManagedClusterPodIdentityProvisioningError_STATUS `json:"error,omitempty"`
	PropertyBag genruntime.PropertyBag                             `json:"$propertyBag,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterPodIdentity_ProvisioningInfo_STATUS populates our ManagedClusterPodIdentity_ProvisioningInfo_STATUS from the provided source ManagedClusterPodIdentity_ProvisioningInfo_STATUS
func (info *ManagedClusterPodIdentity_ProvisioningInfo_STATUS) AssignPropertiesFromManagedClusterPodIdentity_ProvisioningInfo_STATUS(source *v20210501s.ManagedClusterPodIdentity_ProvisioningInfo_STATUS) error {
=======
// AssignProperties_From_ManagedClusterPodIdentity_STATUS_ProvisioningInfo populates our ManagedClusterPodIdentity_STATUS_ProvisioningInfo from the provided source ManagedClusterPodIdentity_STATUS_ProvisioningInfo
func (info *ManagedClusterPodIdentity_STATUS_ProvisioningInfo) AssignProperties_From_ManagedClusterPodIdentity_STATUS_ProvisioningInfo(source *v20210501s.ManagedClusterPodIdentity_STATUS_ProvisioningInfo) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Error
	if source.Error != nil {
		var error ManagedClusterPodIdentityProvisioningError_STATUS
<<<<<<< HEAD
		err := error.AssignPropertiesFromManagedClusterPodIdentityProvisioningError_STATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentityProvisioningError_STATUS() to populate field Error")
=======
		err := error.AssignProperties_From_ManagedClusterPodIdentityProvisioningError_STATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProvisioningError_STATUS() to populate field Error")
>>>>>>> main
		}
		info.Error = &error
	} else {
		info.Error = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		info.PropertyBag = propertyBag
	} else {
		info.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterPodIdentity_ProvisioningInfo_STATUS populates the provided destination ManagedClusterPodIdentity_ProvisioningInfo_STATUS from our ManagedClusterPodIdentity_ProvisioningInfo_STATUS
func (info *ManagedClusterPodIdentity_ProvisioningInfo_STATUS) AssignPropertiesToManagedClusterPodIdentity_ProvisioningInfo_STATUS(destination *v20210501s.ManagedClusterPodIdentity_ProvisioningInfo_STATUS) error {
=======
// AssignProperties_To_ManagedClusterPodIdentity_STATUS_ProvisioningInfo populates the provided destination ManagedClusterPodIdentity_STATUS_ProvisioningInfo from our ManagedClusterPodIdentity_STATUS_ProvisioningInfo
func (info *ManagedClusterPodIdentity_STATUS_ProvisioningInfo) AssignProperties_To_ManagedClusterPodIdentity_STATUS_ProvisioningInfo(destination *v20210501s.ManagedClusterPodIdentity_STATUS_ProvisioningInfo) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(info.PropertyBag)

	// Error
	if info.Error != nil {
		var error v20210501s.ManagedClusterPodIdentityProvisioningError_STATUS
<<<<<<< HEAD
		err := info.Error.AssignPropertiesToManagedClusterPodIdentityProvisioningError_STATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentityProvisioningError_STATUS() to populate field Error")
=======
		err := info.Error.AssignProperties_To_ManagedClusterPodIdentityProvisioningError_STATUS(&error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProvisioningError_STATUS() to populate field Error")
>>>>>>> main
		}
		destination.Error = &error
	} else {
		destination.Error = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ResourceReference
// Deprecated version of ResourceReference. Use v1beta20210501.ResourceReference instead
type ResourceReference struct {
	PropertyBag genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Reference   *genruntime.ResourceReference `armReference:"Id" json:"reference,omitempty"`
}

// AssignProperties_From_ResourceReference populates our ResourceReference from the provided source ResourceReference
func (reference *ResourceReference) AssignProperties_From_ResourceReference(source *v20210501s.ResourceReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Reference
	if source.Reference != nil {
		referenceTemp := source.Reference.Copy()
		reference.Reference = &referenceTemp
	} else {
		reference.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_ResourceReference populates the provided destination ResourceReference from our ResourceReference
func (reference *ResourceReference) AssignProperties_To_ResourceReference(destination *v20210501s.ResourceReference) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// Reference
	if reference.Reference != nil {
		referenceTemp := reference.Reference.Copy()
		destination.Reference = &referenceTemp
	} else {
		destination.Reference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ResourceReference_STATUS
// Deprecated version of ResourceReference_STATUS. Use v1beta20210501.ResourceReference_STATUS instead
type ResourceReference_STATUS struct {
	Id          *string                `json:"id,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromResourceReference_STATUS populates our ResourceReference_STATUS from the provided source ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignPropertiesFromResourceReference_STATUS(source *v20210501s.ResourceReference_STATUS) error {
=======
// AssignProperties_From_ResourceReference_STATUS populates our ResourceReference_STATUS from the provided source ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignProperties_From_ResourceReference_STATUS(source *v20210501s.ResourceReference_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Id
	reference.Id = genruntime.ClonePointerToString(source.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		reference.PropertyBag = propertyBag
	} else {
		reference.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToResourceReference_STATUS populates the provided destination ResourceReference_STATUS from our ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignPropertiesToResourceReference_STATUS(destination *v20210501s.ResourceReference_STATUS) error {
=======
// AssignProperties_To_ResourceReference_STATUS populates the provided destination ResourceReference_STATUS from our ResourceReference_STATUS
func (reference *ResourceReference_STATUS) AssignProperties_To_ResourceReference_STATUS(destination *v20210501s.ResourceReference_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(reference.PropertyBag)

	// Id
	destination.Id = genruntime.ClonePointerToString(reference.Id)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.UserAssignedIdentity
// Deprecated version of UserAssignedIdentity. Use v1beta20210501.UserAssignedIdentity instead
type UserAssignedIdentity struct {
	ClientId          *string                       `json:"clientId,omitempty"`
	ObjectId          *string                       `json:"objectId,omitempty"`
	PropertyBag       genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	ResourceReference *genruntime.ResourceReference `armReference:"ResourceId" json:"resourceReference,omitempty"`
}

// AssignProperties_From_UserAssignedIdentity populates our UserAssignedIdentity from the provided source UserAssignedIdentity
func (identity *UserAssignedIdentity) AssignProperties_From_UserAssignedIdentity(source *v20210501s.UserAssignedIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ObjectId
	identity.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// ResourceReference
	if source.ResourceReference != nil {
		resourceReference := source.ResourceReference.Copy()
		identity.ResourceReference = &resourceReference
	} else {
		identity.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// No error
	return nil
}

// AssignProperties_To_UserAssignedIdentity populates the provided destination UserAssignedIdentity from our UserAssignedIdentity
func (identity *UserAssignedIdentity) AssignProperties_To_UserAssignedIdentity(destination *v20210501s.UserAssignedIdentity) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// ObjectId
	destination.ObjectId = genruntime.ClonePointerToString(identity.ObjectId)

	// ResourceReference
	if identity.ResourceReference != nil {
		resourceReference := identity.ResourceReference.Copy()
		destination.ResourceReference = &resourceReference
	} else {
		destination.ResourceReference = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.UserAssignedIdentity_STATUS
// Deprecated version of UserAssignedIdentity_STATUS. Use v1beta20210501.UserAssignedIdentity_STATUS instead
type UserAssignedIdentity_STATUS struct {
	ClientId    *string                `json:"clientId,omitempty"`
	ObjectId    *string                `json:"objectId,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	ResourceId  *string                `json:"resourceId,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromUserAssignedIdentity_STATUS populates our UserAssignedIdentity_STATUS from the provided source UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignPropertiesFromUserAssignedIdentity_STATUS(source *v20210501s.UserAssignedIdentity_STATUS) error {
=======
// AssignProperties_From_UserAssignedIdentity_STATUS populates our UserAssignedIdentity_STATUS from the provided source UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_From_UserAssignedIdentity_STATUS(source *v20210501s.UserAssignedIdentity_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// ClientId
	identity.ClientId = genruntime.ClonePointerToString(source.ClientId)

	// ObjectId
	identity.ObjectId = genruntime.ClonePointerToString(source.ObjectId)

	// ResourceId
	identity.ResourceId = genruntime.ClonePointerToString(source.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		identity.PropertyBag = propertyBag
	} else {
		identity.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToUserAssignedIdentity_STATUS populates the provided destination UserAssignedIdentity_STATUS from our UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignPropertiesToUserAssignedIdentity_STATUS(destination *v20210501s.UserAssignedIdentity_STATUS) error {
=======
// AssignProperties_To_UserAssignedIdentity_STATUS populates the provided destination UserAssignedIdentity_STATUS from our UserAssignedIdentity_STATUS
func (identity *UserAssignedIdentity_STATUS) AssignProperties_To_UserAssignedIdentity_STATUS(destination *v20210501s.UserAssignedIdentity_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(identity.PropertyBag)

	// ClientId
	destination.ClientId = genruntime.ClonePointerToString(identity.ClientId)

	// ObjectId
	destination.ObjectId = genruntime.ClonePointerToString(identity.ObjectId)

	// ResourceId
	destination.ResourceId = genruntime.ClonePointerToString(identity.ResourceId)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterPodIdentityProvisioningError_STATUS
// Deprecated version of ManagedClusterPodIdentityProvisioningError_STATUS. Use v1beta20210501.ManagedClusterPodIdentityProvisioningError_STATUS instead
type ManagedClusterPodIdentityProvisioningError_STATUS struct {
	Error       *ManagedClusterPodIdentityProvisioningErrorBody_STATUS `json:"error,omitempty"`
	PropertyBag genruntime.PropertyBag                                 `json:"$propertyBag,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterPodIdentityProvisioningError_STATUS populates our ManagedClusterPodIdentityProvisioningError_STATUS from the provided source ManagedClusterPodIdentityProvisioningError_STATUS
func (error *ManagedClusterPodIdentityProvisioningError_STATUS) AssignPropertiesFromManagedClusterPodIdentityProvisioningError_STATUS(source *v20210501s.ManagedClusterPodIdentityProvisioningError_STATUS) error {
=======
// AssignProperties_From_ManagedClusterPodIdentityProvisioningError_STATUS populates our ManagedClusterPodIdentityProvisioningError_STATUS from the provided source ManagedClusterPodIdentityProvisioningError_STATUS
func (error *ManagedClusterPodIdentityProvisioningError_STATUS) AssignProperties_From_ManagedClusterPodIdentityProvisioningError_STATUS(source *v20210501s.ManagedClusterPodIdentityProvisioningError_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Error
	if source.Error != nil {
		var errorLocal ManagedClusterPodIdentityProvisioningErrorBody_STATUS
<<<<<<< HEAD
		err := errorLocal.AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_STATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_STATUS() to populate field Error")
=======
		err := errorLocal.AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS(source.Error)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS() to populate field Error")
>>>>>>> main
		}
		error.Error = &errorLocal
	} else {
		error.Error = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		error.PropertyBag = propertyBag
	} else {
		error.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterPodIdentityProvisioningError_STATUS populates the provided destination ManagedClusterPodIdentityProvisioningError_STATUS from our ManagedClusterPodIdentityProvisioningError_STATUS
func (error *ManagedClusterPodIdentityProvisioningError_STATUS) AssignPropertiesToManagedClusterPodIdentityProvisioningError_STATUS(destination *v20210501s.ManagedClusterPodIdentityProvisioningError_STATUS) error {
=======
// AssignProperties_To_ManagedClusterPodIdentityProvisioningError_STATUS populates the provided destination ManagedClusterPodIdentityProvisioningError_STATUS from our ManagedClusterPodIdentityProvisioningError_STATUS
func (error *ManagedClusterPodIdentityProvisioningError_STATUS) AssignProperties_To_ManagedClusterPodIdentityProvisioningError_STATUS(destination *v20210501s.ManagedClusterPodIdentityProvisioningError_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(error.PropertyBag)

	// Error
	if error.Error != nil {
		var errorLocal v20210501s.ManagedClusterPodIdentityProvisioningErrorBody_STATUS
<<<<<<< HEAD
		err := error.Error.AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_STATUS(&errorLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_STATUS() to populate field Error")
=======
		err := error.Error.AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS(&errorLocal)
		if err != nil {
			return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS() to populate field Error")
>>>>>>> main
		}
		destination.Error = &errorLocal
	} else {
		destination.Error = nil
	}

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterPodIdentityProvisioningErrorBody_STATUS
// Deprecated version of ManagedClusterPodIdentityProvisioningErrorBody_STATUS. Use v1beta20210501.ManagedClusterPodIdentityProvisioningErrorBody_STATUS instead
type ManagedClusterPodIdentityProvisioningErrorBody_STATUS struct {
	Code        *string                                                          `json:"code,omitempty"`
	Details     []ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled `json:"details,omitempty"`
	Message     *string                                                          `json:"message,omitempty"`
	PropertyBag genruntime.PropertyBag                                           `json:"$propertyBag,omitempty"`
	Target      *string                                                          `json:"target,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_STATUS populates our ManagedClusterPodIdentityProvisioningErrorBody_STATUS from the provided source ManagedClusterPodIdentityProvisioningErrorBody_STATUS
func (body *ManagedClusterPodIdentityProvisioningErrorBody_STATUS) AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_STATUS(source *v20210501s.ManagedClusterPodIdentityProvisioningErrorBody_STATUS) error {
=======
// AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS populates our ManagedClusterPodIdentityProvisioningErrorBody_STATUS from the provided source ManagedClusterPodIdentityProvisioningErrorBody_STATUS
func (body *ManagedClusterPodIdentityProvisioningErrorBody_STATUS) AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS(source *v20210501s.ManagedClusterPodIdentityProvisioningErrorBody_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Code
	body.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
<<<<<<< HEAD
			err := detail.AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled() to populate field Details")
=======
			err := detail.AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(&detailItem)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled() to populate field Details")
>>>>>>> main
			}
			detailList[detailIndex] = detail
		}
		body.Details = detailList
	} else {
		body.Details = nil
	}

	// Message
	body.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	body.Target = genruntime.ClonePointerToString(source.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		body.PropertyBag = propertyBag
	} else {
		body.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_STATUS populates the provided destination ManagedClusterPodIdentityProvisioningErrorBody_STATUS from our ManagedClusterPodIdentityProvisioningErrorBody_STATUS
func (body *ManagedClusterPodIdentityProvisioningErrorBody_STATUS) AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_STATUS(destination *v20210501s.ManagedClusterPodIdentityProvisioningErrorBody_STATUS) error {
=======
// AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS populates the provided destination ManagedClusterPodIdentityProvisioningErrorBody_STATUS from our ManagedClusterPodIdentityProvisioningErrorBody_STATUS
func (body *ManagedClusterPodIdentityProvisioningErrorBody_STATUS) AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS(destination *v20210501s.ManagedClusterPodIdentityProvisioningErrorBody_STATUS) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(body.PropertyBag)

	// Code
	destination.Code = genruntime.ClonePointerToString(body.Code)

	// Details
	if body.Details != nil {
		detailList := make([]v20210501s.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled, len(body.Details))
		for detailIndex, detailItem := range body.Details {
			// Shadow the loop variable to avoid aliasing
			detailItem := detailItem
			var detail v20210501s.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
<<<<<<< HEAD
			err := detailItem.AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(&detail)
			if err != nil {
				return errors.Wrap(err, "calling AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled() to populate field Details")
=======
			err := detailItem.AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(&detail)
			if err != nil {
				return errors.Wrap(err, "calling AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled() to populate field Details")
>>>>>>> main
			}
			detailList[detailIndex] = detail
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(body.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(body.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

// Storage version of v1alpha1api20210501.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
// Deprecated version of ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled. Use v1beta20210501.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled instead
type ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled struct {
	Code        *string                `json:"code,omitempty"`
	Message     *string                `json:"message,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Target      *string                `json:"target,omitempty"`
}

<<<<<<< HEAD
// AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled populates our ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled from the provided source ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) AssignPropertiesFromManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(source *v20210501s.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) error {
=======
// AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled populates our ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled from the provided source ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) AssignProperties_From_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(source *v20210501s.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Code
	unrolled.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	unrolled.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	unrolled.Target = genruntime.ClonePointerToString(source.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		unrolled.PropertyBag = propertyBag
	} else {
		unrolled.PropertyBag = nil
	}

	// No error
	return nil
}

<<<<<<< HEAD
// AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled populates the provided destination ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled from our ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) AssignPropertiesToManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(destination *v20210501s.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) error {
=======
// AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled populates the provided destination ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled from our ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled
func (unrolled *ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) AssignProperties_To_ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled(destination *v20210501s.ManagedClusterPodIdentityProvisioningErrorBody_STATUS_Unrolled) error {
>>>>>>> main
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(unrolled.PropertyBag)

	// Code
	destination.Code = genruntime.ClonePointerToString(unrolled.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(unrolled.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(unrolled.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// No error
	return nil
}

func init() {
	SchemeBuilder.Register(&ManagedCluster{}, &ManagedClusterList{})
}
