// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1alpha1api20210501storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ManagedClustersAgentPool_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClustersAgentPool via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClustersAgentPool, ManagedClustersAgentPoolGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClustersAgentPool runs a test to see if a specific instance of ManagedClustersAgentPool round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClustersAgentPool(subject ManagedClustersAgentPool) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClustersAgentPool
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClustersAgentPool instances for property testing - lazily instantiated by
//ManagedClustersAgentPoolGenerator()
var managedClustersAgentPoolGenerator gopter.Gen

// ManagedClustersAgentPoolGenerator returns a generator of ManagedClustersAgentPool instances for property testing.
func ManagedClustersAgentPoolGenerator() gopter.Gen {
	if managedClustersAgentPoolGenerator != nil {
		return managedClustersAgentPoolGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedClustersAgentPool(generators)
	managedClustersAgentPoolGenerator = gen.Struct(reflect.TypeOf(ManagedClustersAgentPool{}), generators)

	return managedClustersAgentPoolGenerator
}

// AddRelatedPropertyGeneratorsForManagedClustersAgentPool is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClustersAgentPool(gens map[string]gopter.Gen) {
	gens["Spec"] = ManagedClustersAgentPoolsSPECGenerator()
	gens["Status"] = AgentPoolStatusGenerator()
}

func Test_AgentPool_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPool_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolStatus, AgentPoolStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolStatus runs a test to see if a specific instance of AgentPool_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolStatus(subject AgentPool_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPool_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPool_Status instances for property testing - lazily instantiated by AgentPoolStatusGenerator()
var agentPoolStatusGenerator gopter.Gen

// AgentPoolStatusGenerator returns a generator of AgentPool_Status instances for property testing.
// We first initialize agentPoolStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func AgentPoolStatusGenerator() gopter.Gen {
	if agentPoolStatusGenerator != nil {
		return agentPoolStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolStatus(generators)
	agentPoolStatusGenerator = gen.Struct(reflect.TypeOf(AgentPool_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolStatus(generators)
	AddRelatedPropertyGeneratorsForAgentPoolStatus(generators)
	agentPoolStatusGenerator = gen.Struct(reflect.TypeOf(AgentPool_Status{}), generators)

	return agentPoolStatusGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolStatus(gens map[string]gopter.Gen) {
	gens["AvailabilityZones"] = gen.SliceOf(gen.AlphaString())
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["EnableAutoScaling"] = gen.PtrOf(gen.Bool())
	gens["EnableEncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["EnableFIPS"] = gen.PtrOf(gen.Bool())
	gens["EnableNodePublicIP"] = gen.PtrOf(gen.Bool())
	gens["EnableUltraSSD"] = gen.PtrOf(gen.Bool())
	gens["GpuInstanceProfile"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["KubeletDiskType"] = gen.PtrOf(gen.AlphaString())
	gens["MaxCount"] = gen.PtrOf(gen.Int())
	gens["MaxPods"] = gen.PtrOf(gen.Int())
	gens["MinCount"] = gen.PtrOf(gen.Int())
	gens["Mode"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NodeImageVersion"] = gen.PtrOf(gen.AlphaString())
	gens["NodeLabels"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["NodePublicIPPrefixID"] = gen.PtrOf(gen.AlphaString())
	gens["NodeTaints"] = gen.SliceOf(gen.AlphaString())
	gens["OrchestratorVersion"] = gen.PtrOf(gen.AlphaString())
	gens["OsDiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["OsDiskType"] = gen.PtrOf(gen.AlphaString())
	gens["OsSKU"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["PodSubnetID"] = gen.PtrOf(gen.AlphaString())
	gens["PropertiesType"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["ProximityPlacementGroupID"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleSetEvictionPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleSetPriority"] = gen.PtrOf(gen.AlphaString())
	gens["SpotMaxPrice"] = gen.PtrOf(gen.Float64())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
	gens["VnetSubnetID"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForAgentPoolStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForAgentPoolStatus(gens map[string]gopter.Gen) {
	gens["KubeletConfig"] = gen.PtrOf(KubeletConfigStatusGenerator())
	gens["LinuxOSConfig"] = gen.PtrOf(LinuxOSConfigStatusGenerator())
	gens["PowerState"] = gen.PtrOf(PowerStateStatusGenerator())
	gens["UpgradeSettings"] = gen.PtrOf(AgentPoolUpgradeSettingsStatusGenerator())
}

func Test_ManagedClustersAgentPools_SPEC_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClustersAgentPools_SPEC via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClustersAgentPoolsSPEC, ManagedClustersAgentPoolsSPECGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClustersAgentPoolsSPEC runs a test to see if a specific instance of ManagedClustersAgentPools_SPEC round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClustersAgentPoolsSPEC(subject ManagedClustersAgentPools_SPEC) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClustersAgentPools_SPEC
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClustersAgentPools_SPEC instances for property testing - lazily instantiated by
//ManagedClustersAgentPoolsSPECGenerator()
var managedClustersAgentPoolsSPECGenerator gopter.Gen

// ManagedClustersAgentPoolsSPECGenerator returns a generator of ManagedClustersAgentPools_SPEC instances for property testing.
// We first initialize managedClustersAgentPoolsSPECGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClustersAgentPoolsSPECGenerator() gopter.Gen {
	if managedClustersAgentPoolsSPECGenerator != nil {
		return managedClustersAgentPoolsSPECGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClustersAgentPoolsSPEC(generators)
	managedClustersAgentPoolsSPECGenerator = gen.Struct(reflect.TypeOf(ManagedClustersAgentPools_SPEC{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClustersAgentPoolsSPEC(generators)
	AddRelatedPropertyGeneratorsForManagedClustersAgentPoolsSPEC(generators)
	managedClustersAgentPoolsSPECGenerator = gen.Struct(reflect.TypeOf(ManagedClustersAgentPools_SPEC{}), generators)

	return managedClustersAgentPoolsSPECGenerator
}

// AddIndependentPropertyGeneratorsForManagedClustersAgentPoolsSPEC is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClustersAgentPoolsSPEC(gens map[string]gopter.Gen) {
	gens["AvailabilityZones"] = gen.SliceOf(gen.AlphaString())
	gens["AzureName"] = gen.AlphaString()
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["EnableAutoScaling"] = gen.PtrOf(gen.Bool())
	gens["EnableEncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["EnableFIPS"] = gen.PtrOf(gen.Bool())
	gens["EnableNodePublicIP"] = gen.PtrOf(gen.Bool())
	gens["EnableUltraSSD"] = gen.PtrOf(gen.Bool())
	gens["GpuInstanceProfile"] = gen.PtrOf(gen.AlphaString())
	gens["KubeletDiskType"] = gen.PtrOf(gen.AlphaString())
	gens["MaxCount"] = gen.PtrOf(gen.Int())
	gens["MaxPods"] = gen.PtrOf(gen.Int())
	gens["MinCount"] = gen.PtrOf(gen.Int())
	gens["Mode"] = gen.PtrOf(gen.AlphaString())
	gens["NodeLabels"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["NodeTaints"] = gen.SliceOf(gen.AlphaString())
	gens["OrchestratorVersion"] = gen.PtrOf(gen.AlphaString())
	gens["OriginalVersion"] = gen.AlphaString()
	gens["OsDiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["OsDiskType"] = gen.PtrOf(gen.AlphaString())
	gens["OsSKU"] = gen.PtrOf(gen.AlphaString())
	gens["OsType"] = gen.PtrOf(gen.AlphaString())
	gens["ProximityPlacementGroupID"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleSetEvictionPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleSetPriority"] = gen.PtrOf(gen.AlphaString())
	gens["SpotMaxPrice"] = gen.PtrOf(gen.Float64())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedClustersAgentPoolsSPEC is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClustersAgentPoolsSPEC(gens map[string]gopter.Gen) {
	gens["KubeletConfig"] = gen.PtrOf(KubeletConfigSpecGenerator())
	gens["LinuxOSConfig"] = gen.PtrOf(LinuxOSConfigSpecGenerator())
	gens["UpgradeSettings"] = gen.PtrOf(AgentPoolUpgradeSettingsSpecGenerator())
}

func Test_AgentPoolUpgradeSettings_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolUpgradeSettings_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolUpgradeSettingsSpec, AgentPoolUpgradeSettingsSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolUpgradeSettingsSpec runs a test to see if a specific instance of AgentPoolUpgradeSettings_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolUpgradeSettingsSpec(subject AgentPoolUpgradeSettings_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolUpgradeSettings_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolUpgradeSettings_Spec instances for property testing - lazily instantiated by
//AgentPoolUpgradeSettingsSpecGenerator()
var agentPoolUpgradeSettingsSpecGenerator gopter.Gen

// AgentPoolUpgradeSettingsSpecGenerator returns a generator of AgentPoolUpgradeSettings_Spec instances for property testing.
func AgentPoolUpgradeSettingsSpecGenerator() gopter.Gen {
	if agentPoolUpgradeSettingsSpecGenerator != nil {
		return agentPoolUpgradeSettingsSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettingsSpec(generators)
	agentPoolUpgradeSettingsSpecGenerator = gen.Struct(reflect.TypeOf(AgentPoolUpgradeSettings_Spec{}), generators)

	return agentPoolUpgradeSettingsSpecGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettingsSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettingsSpec(gens map[string]gopter.Gen) {
	gens["MaxSurge"] = gen.PtrOf(gen.AlphaString())
}

func Test_AgentPoolUpgradeSettings_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of AgentPoolUpgradeSettings_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForAgentPoolUpgradeSettingsStatus, AgentPoolUpgradeSettingsStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForAgentPoolUpgradeSettingsStatus runs a test to see if a specific instance of AgentPoolUpgradeSettings_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForAgentPoolUpgradeSettingsStatus(subject AgentPoolUpgradeSettings_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual AgentPoolUpgradeSettings_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of AgentPoolUpgradeSettings_Status instances for property testing - lazily instantiated by
//AgentPoolUpgradeSettingsStatusGenerator()
var agentPoolUpgradeSettingsStatusGenerator gopter.Gen

// AgentPoolUpgradeSettingsStatusGenerator returns a generator of AgentPoolUpgradeSettings_Status instances for property testing.
func AgentPoolUpgradeSettingsStatusGenerator() gopter.Gen {
	if agentPoolUpgradeSettingsStatusGenerator != nil {
		return agentPoolUpgradeSettingsStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettingsStatus(generators)
	agentPoolUpgradeSettingsStatusGenerator = gen.Struct(reflect.TypeOf(AgentPoolUpgradeSettings_Status{}), generators)

	return agentPoolUpgradeSettingsStatusGenerator
}

// AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettingsStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForAgentPoolUpgradeSettingsStatus(gens map[string]gopter.Gen) {
	gens["MaxSurge"] = gen.PtrOf(gen.AlphaString())
}

func Test_KubeletConfig_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KubeletConfig_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKubeletConfigSpec, KubeletConfigSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKubeletConfigSpec runs a test to see if a specific instance of KubeletConfig_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForKubeletConfigSpec(subject KubeletConfig_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KubeletConfig_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KubeletConfig_Spec instances for property testing - lazily instantiated by KubeletConfigSpecGenerator()
var kubeletConfigSpecGenerator gopter.Gen

// KubeletConfigSpecGenerator returns a generator of KubeletConfig_Spec instances for property testing.
func KubeletConfigSpecGenerator() gopter.Gen {
	if kubeletConfigSpecGenerator != nil {
		return kubeletConfigSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubeletConfigSpec(generators)
	kubeletConfigSpecGenerator = gen.Struct(reflect.TypeOf(KubeletConfig_Spec{}), generators)

	return kubeletConfigSpecGenerator
}

// AddIndependentPropertyGeneratorsForKubeletConfigSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKubeletConfigSpec(gens map[string]gopter.Gen) {
	gens["AllowedUnsafeSysctls"] = gen.SliceOf(gen.AlphaString())
	gens["ContainerLogMaxFiles"] = gen.PtrOf(gen.Int())
	gens["ContainerLogMaxSizeMB"] = gen.PtrOf(gen.Int())
	gens["CpuCfsQuota"] = gen.PtrOf(gen.Bool())
	gens["CpuCfsQuotaPeriod"] = gen.PtrOf(gen.AlphaString())
	gens["CpuManagerPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["FailSwapOn"] = gen.PtrOf(gen.Bool())
	gens["ImageGcHighThreshold"] = gen.PtrOf(gen.Int())
	gens["ImageGcLowThreshold"] = gen.PtrOf(gen.Int())
	gens["PodMaxPids"] = gen.PtrOf(gen.Int())
	gens["TopologyManagerPolicy"] = gen.PtrOf(gen.AlphaString())
}

func Test_KubeletConfig_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of KubeletConfig_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForKubeletConfigStatus, KubeletConfigStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForKubeletConfigStatus runs a test to see if a specific instance of KubeletConfig_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForKubeletConfigStatus(subject KubeletConfig_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual KubeletConfig_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of KubeletConfig_Status instances for property testing - lazily instantiated by
//KubeletConfigStatusGenerator()
var kubeletConfigStatusGenerator gopter.Gen

// KubeletConfigStatusGenerator returns a generator of KubeletConfig_Status instances for property testing.
func KubeletConfigStatusGenerator() gopter.Gen {
	if kubeletConfigStatusGenerator != nil {
		return kubeletConfigStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForKubeletConfigStatus(generators)
	kubeletConfigStatusGenerator = gen.Struct(reflect.TypeOf(KubeletConfig_Status{}), generators)

	return kubeletConfigStatusGenerator
}

// AddIndependentPropertyGeneratorsForKubeletConfigStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForKubeletConfigStatus(gens map[string]gopter.Gen) {
	gens["AllowedUnsafeSysctls"] = gen.SliceOf(gen.AlphaString())
	gens["ContainerLogMaxFiles"] = gen.PtrOf(gen.Int())
	gens["ContainerLogMaxSizeMB"] = gen.PtrOf(gen.Int())
	gens["CpuCfsQuota"] = gen.PtrOf(gen.Bool())
	gens["CpuCfsQuotaPeriod"] = gen.PtrOf(gen.AlphaString())
	gens["CpuManagerPolicy"] = gen.PtrOf(gen.AlphaString())
	gens["FailSwapOn"] = gen.PtrOf(gen.Bool())
	gens["ImageGcHighThreshold"] = gen.PtrOf(gen.Int())
	gens["ImageGcLowThreshold"] = gen.PtrOf(gen.Int())
	gens["PodMaxPids"] = gen.PtrOf(gen.Int())
	gens["TopologyManagerPolicy"] = gen.PtrOf(gen.AlphaString())
}

func Test_LinuxOSConfig_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxOSConfig_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxOSConfigSpec, LinuxOSConfigSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxOSConfigSpec runs a test to see if a specific instance of LinuxOSConfig_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxOSConfigSpec(subject LinuxOSConfig_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxOSConfig_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxOSConfig_Spec instances for property testing - lazily instantiated by LinuxOSConfigSpecGenerator()
var linuxOSConfigSpecGenerator gopter.Gen

// LinuxOSConfigSpecGenerator returns a generator of LinuxOSConfig_Spec instances for property testing.
// We first initialize linuxOSConfigSpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxOSConfigSpecGenerator() gopter.Gen {
	if linuxOSConfigSpecGenerator != nil {
		return linuxOSConfigSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxOSConfigSpec(generators)
	linuxOSConfigSpecGenerator = gen.Struct(reflect.TypeOf(LinuxOSConfig_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxOSConfigSpec(generators)
	AddRelatedPropertyGeneratorsForLinuxOSConfigSpec(generators)
	linuxOSConfigSpecGenerator = gen.Struct(reflect.TypeOf(LinuxOSConfig_Spec{}), generators)

	return linuxOSConfigSpecGenerator
}

// AddIndependentPropertyGeneratorsForLinuxOSConfigSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxOSConfigSpec(gens map[string]gopter.Gen) {
	gens["SwapFileSizeMB"] = gen.PtrOf(gen.Int())
	gens["TransparentHugePageDefrag"] = gen.PtrOf(gen.AlphaString())
	gens["TransparentHugePageEnabled"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLinuxOSConfigSpec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxOSConfigSpec(gens map[string]gopter.Gen) {
	gens["Sysctls"] = gen.PtrOf(SysctlConfigSpecGenerator())
}

func Test_LinuxOSConfig_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of LinuxOSConfig_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForLinuxOSConfigStatus, LinuxOSConfigStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForLinuxOSConfigStatus runs a test to see if a specific instance of LinuxOSConfig_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForLinuxOSConfigStatus(subject LinuxOSConfig_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual LinuxOSConfig_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of LinuxOSConfig_Status instances for property testing - lazily instantiated by
//LinuxOSConfigStatusGenerator()
var linuxOSConfigStatusGenerator gopter.Gen

// LinuxOSConfigStatusGenerator returns a generator of LinuxOSConfig_Status instances for property testing.
// We first initialize linuxOSConfigStatusGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func LinuxOSConfigStatusGenerator() gopter.Gen {
	if linuxOSConfigStatusGenerator != nil {
		return linuxOSConfigStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxOSConfigStatus(generators)
	linuxOSConfigStatusGenerator = gen.Struct(reflect.TypeOf(LinuxOSConfig_Status{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForLinuxOSConfigStatus(generators)
	AddRelatedPropertyGeneratorsForLinuxOSConfigStatus(generators)
	linuxOSConfigStatusGenerator = gen.Struct(reflect.TypeOf(LinuxOSConfig_Status{}), generators)

	return linuxOSConfigStatusGenerator
}

// AddIndependentPropertyGeneratorsForLinuxOSConfigStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForLinuxOSConfigStatus(gens map[string]gopter.Gen) {
	gens["SwapFileSizeMB"] = gen.PtrOf(gen.Int())
	gens["TransparentHugePageDefrag"] = gen.PtrOf(gen.AlphaString())
	gens["TransparentHugePageEnabled"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForLinuxOSConfigStatus is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForLinuxOSConfigStatus(gens map[string]gopter.Gen) {
	gens["Sysctls"] = gen.PtrOf(SysctlConfigStatusGenerator())
}

func Test_SysctlConfig_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SysctlConfig_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSysctlConfigSpec, SysctlConfigSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSysctlConfigSpec runs a test to see if a specific instance of SysctlConfig_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForSysctlConfigSpec(subject SysctlConfig_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SysctlConfig_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SysctlConfig_Spec instances for property testing - lazily instantiated by SysctlConfigSpecGenerator()
var sysctlConfigSpecGenerator gopter.Gen

// SysctlConfigSpecGenerator returns a generator of SysctlConfig_Spec instances for property testing.
func SysctlConfigSpecGenerator() gopter.Gen {
	if sysctlConfigSpecGenerator != nil {
		return sysctlConfigSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSysctlConfigSpec(generators)
	sysctlConfigSpecGenerator = gen.Struct(reflect.TypeOf(SysctlConfig_Spec{}), generators)

	return sysctlConfigSpecGenerator
}

// AddIndependentPropertyGeneratorsForSysctlConfigSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSysctlConfigSpec(gens map[string]gopter.Gen) {
	gens["FsAioMaxNr"] = gen.PtrOf(gen.Int())
	gens["FsFileMax"] = gen.PtrOf(gen.Int())
	gens["FsInotifyMaxUserWatches"] = gen.PtrOf(gen.Int())
	gens["FsNrOpen"] = gen.PtrOf(gen.Int())
	gens["KernelThreadsMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreNetdevMaxBacklog"] = gen.PtrOf(gen.Int())
	gens["NetCoreOptmemMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreRmemDefault"] = gen.PtrOf(gen.Int())
	gens["NetCoreRmemMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreSomaxconn"] = gen.PtrOf(gen.Int())
	gens["NetCoreWmemDefault"] = gen.PtrOf(gen.Int())
	gens["NetCoreWmemMax"] = gen.PtrOf(gen.Int())
	gens["NetIpv4IpLocalPortRange"] = gen.PtrOf(gen.AlphaString())
	gens["NetIpv4NeighDefaultGcThresh1"] = gen.PtrOf(gen.Int())
	gens["NetIpv4NeighDefaultGcThresh2"] = gen.PtrOf(gen.Int())
	gens["NetIpv4NeighDefaultGcThresh3"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpFinTimeout"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpKeepaliveProbes"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpKeepaliveTime"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpMaxSynBacklog"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpMaxTwBuckets"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpTwReuse"] = gen.PtrOf(gen.Bool())
	gens["NetIpv4TcpkeepaliveIntvl"] = gen.PtrOf(gen.Int())
	gens["NetNetfilterNfConntrackBuckets"] = gen.PtrOf(gen.Int())
	gens["NetNetfilterNfConntrackMax"] = gen.PtrOf(gen.Int())
	gens["VmMaxMapCount"] = gen.PtrOf(gen.Int())
	gens["VmSwappiness"] = gen.PtrOf(gen.Int())
	gens["VmVfsCachePressure"] = gen.PtrOf(gen.Int())
}

func Test_SysctlConfig_Status_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MaxSize = 10
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of SysctlConfig_Status via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForSysctlConfigStatus, SysctlConfigStatusGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForSysctlConfigStatus runs a test to see if a specific instance of SysctlConfig_Status round trips to JSON and back losslessly
func RunJSONSerializationTestForSysctlConfigStatus(subject SysctlConfig_Status) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual SysctlConfig_Status
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of SysctlConfig_Status instances for property testing - lazily instantiated by SysctlConfigStatusGenerator()
var sysctlConfigStatusGenerator gopter.Gen

// SysctlConfigStatusGenerator returns a generator of SysctlConfig_Status instances for property testing.
func SysctlConfigStatusGenerator() gopter.Gen {
	if sysctlConfigStatusGenerator != nil {
		return sysctlConfigStatusGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForSysctlConfigStatus(generators)
	sysctlConfigStatusGenerator = gen.Struct(reflect.TypeOf(SysctlConfig_Status{}), generators)

	return sysctlConfigStatusGenerator
}

// AddIndependentPropertyGeneratorsForSysctlConfigStatus is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForSysctlConfigStatus(gens map[string]gopter.Gen) {
	gens["FsAioMaxNr"] = gen.PtrOf(gen.Int())
	gens["FsFileMax"] = gen.PtrOf(gen.Int())
	gens["FsInotifyMaxUserWatches"] = gen.PtrOf(gen.Int())
	gens["FsNrOpen"] = gen.PtrOf(gen.Int())
	gens["KernelThreadsMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreNetdevMaxBacklog"] = gen.PtrOf(gen.Int())
	gens["NetCoreOptmemMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreRmemDefault"] = gen.PtrOf(gen.Int())
	gens["NetCoreRmemMax"] = gen.PtrOf(gen.Int())
	gens["NetCoreSomaxconn"] = gen.PtrOf(gen.Int())
	gens["NetCoreWmemDefault"] = gen.PtrOf(gen.Int())
	gens["NetCoreWmemMax"] = gen.PtrOf(gen.Int())
	gens["NetIpv4IpLocalPortRange"] = gen.PtrOf(gen.AlphaString())
	gens["NetIpv4NeighDefaultGcThresh1"] = gen.PtrOf(gen.Int())
	gens["NetIpv4NeighDefaultGcThresh2"] = gen.PtrOf(gen.Int())
	gens["NetIpv4NeighDefaultGcThresh3"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpFinTimeout"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpKeepaliveProbes"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpKeepaliveTime"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpMaxSynBacklog"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpMaxTwBuckets"] = gen.PtrOf(gen.Int())
	gens["NetIpv4TcpTwReuse"] = gen.PtrOf(gen.Bool())
	gens["NetIpv4TcpkeepaliveIntvl"] = gen.PtrOf(gen.Int())
	gens["NetNetfilterNfConntrackBuckets"] = gen.PtrOf(gen.Int())
	gens["NetNetfilterNfConntrackMax"] = gen.PtrOf(gen.Int())
	gens["VmMaxMapCount"] = gen.PtrOf(gen.Int())
	gens["VmSwappiness"] = gen.PtrOf(gen.Int())
	gens["VmVfsCachePressure"] = gen.PtrOf(gen.Int())
}
