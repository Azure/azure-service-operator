// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	storage "github.com/Azure/azure-service-operator/v2/api/containerservice/v1api20250801/storage"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/conditions"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/configmaps"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/core"
	"github.com/Azure/azure-service-operator/v2/pkg/genruntime/secrets"
	"github.com/rotisserie/eris"
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

// +kubebuilder:rbac:groups=containerservice.azure.com,resources=fleetsupdateruns,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=containerservice.azure.com,resources={fleetsupdateruns/status,fleetsupdateruns/finalizers},verbs=get;update;patch

// +kubebuilder:object:root=true
// +kubebuilder:resource:categories={azure,containerservice}
// +kubebuilder:subresource:status
// +kubebuilder:storageversion
// +kubebuilder:printcolumn:name="Ready",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="Severity",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].severity"
// +kubebuilder:printcolumn:name="Reason",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].reason"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].message"
// Storage version of v1api20230315preview.FleetsUpdateRun
// Generator information:
// - Generated from: /containerservice/resource-manager/Microsoft.ContainerService/fleet/preview/2023-03-15-preview/fleets.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/fleets/{fleetName}/updateRuns/{updateRunName}
type FleetsUpdateRun struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              FleetsUpdateRun_Spec   `json:"spec,omitempty"`
	Status            FleetsUpdateRun_STATUS `json:"status,omitempty"`
}

var _ conditions.Conditioner = &FleetsUpdateRun{}

// GetConditions returns the conditions of the resource
func (updateRun *FleetsUpdateRun) GetConditions() conditions.Conditions {
	return updateRun.Status.Conditions
}

// SetConditions sets the conditions on the resource status
func (updateRun *FleetsUpdateRun) SetConditions(conditions conditions.Conditions) {
	updateRun.Status.Conditions = conditions
}

var _ configmaps.Exporter = &FleetsUpdateRun{}

// ConfigMapDestinationExpressions returns the Spec.OperatorSpec.ConfigMapExpressions property
func (updateRun *FleetsUpdateRun) ConfigMapDestinationExpressions() []*core.DestinationExpression {
	if updateRun.Spec.OperatorSpec == nil {
		return nil
	}
	return updateRun.Spec.OperatorSpec.ConfigMapExpressions
}

var _ secrets.Exporter = &FleetsUpdateRun{}

// SecretDestinationExpressions returns the Spec.OperatorSpec.SecretExpressions property
func (updateRun *FleetsUpdateRun) SecretDestinationExpressions() []*core.DestinationExpression {
	if updateRun.Spec.OperatorSpec == nil {
		return nil
	}
	return updateRun.Spec.OperatorSpec.SecretExpressions
}

var _ genruntime.KubernetesResource = &FleetsUpdateRun{}

// AzureName returns the Azure name of the resource
func (updateRun *FleetsUpdateRun) AzureName() string {
	return updateRun.Spec.AzureName
}

// GetAPIVersion returns the ARM API version of the resource. This is always "2023-03-15-preview"
func (updateRun FleetsUpdateRun) GetAPIVersion() string {
	return "2023-03-15-preview"
}

// GetResourceScope returns the scope of the resource
func (updateRun *FleetsUpdateRun) GetResourceScope() genruntime.ResourceScope {
	return genruntime.ResourceScopeResourceGroup
}

// GetSpec returns the specification of this resource
func (updateRun *FleetsUpdateRun) GetSpec() genruntime.ConvertibleSpec {
	return &updateRun.Spec
}

// GetStatus returns the status of this resource
func (updateRun *FleetsUpdateRun) GetStatus() genruntime.ConvertibleStatus {
	return &updateRun.Status
}

// GetSupportedOperations returns the operations supported by the resource
func (updateRun *FleetsUpdateRun) GetSupportedOperations() []genruntime.ResourceOperation {
	return []genruntime.ResourceOperation{
		genruntime.ResourceOperationDelete,
		genruntime.ResourceOperationGet,
		genruntime.ResourceOperationPut,
	}
}

// GetType returns the ARM Type of the resource. This is always "Microsoft.ContainerService/fleets/updateRuns"
func (updateRun *FleetsUpdateRun) GetType() string {
	return "Microsoft.ContainerService/fleets/updateRuns"
}

// NewEmptyStatus returns a new empty (blank) status
func (updateRun *FleetsUpdateRun) NewEmptyStatus() genruntime.ConvertibleStatus {
	return &FleetsUpdateRun_STATUS{}
}

// Owner returns the ResourceReference of the owner
func (updateRun *FleetsUpdateRun) Owner() *genruntime.ResourceReference {
	if updateRun.Spec.Owner == nil {
		return nil
	}

	group, kind := genruntime.LookupOwnerGroupKind(updateRun.Spec)
	return updateRun.Spec.Owner.AsResourceReference(group, kind)
}

// SetStatus sets the status of this resource
func (updateRun *FleetsUpdateRun) SetStatus(status genruntime.ConvertibleStatus) error {
	// If we have exactly the right type of status, assign it
	if st, ok := status.(*FleetsUpdateRun_STATUS); ok {
		updateRun.Status = *st
		return nil
	}

	// Convert status to required version
	var st FleetsUpdateRun_STATUS
	err := status.ConvertStatusTo(&st)
	if err != nil {
		return eris.Wrap(err, "failed to convert status")
	}

	updateRun.Status = st
	return nil
}

// Hub marks that this FleetsUpdateRun is the hub type for conversion
func (updateRun *FleetsUpdateRun) Hub() {}

// OriginalGVK returns a GroupValueKind for the original API version used to create the resource
func (updateRun *FleetsUpdateRun) OriginalGVK() *schema.GroupVersionKind {
	return &schema.GroupVersionKind{
		Group:   GroupVersion.Group,
		Version: updateRun.Spec.OriginalVersion,
		Kind:    "FleetsUpdateRun",
	}
}

// +kubebuilder:object:root=true
// Storage version of v1api20230315preview.FleetsUpdateRun
// Generator information:
// - Generated from: /containerservice/resource-manager/Microsoft.ContainerService/fleet/preview/2023-03-15-preview/fleets.json
// - ARM URI: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ContainerService/fleets/{fleetName}/updateRuns/{updateRunName}
type FleetsUpdateRunList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []FleetsUpdateRun `json:"items"`
}

// Storage version of v1api20230315preview.FleetsUpdateRun_Spec
type FleetsUpdateRun_Spec struct {
	// AzureName: The name of the resource in Azure. This is often the same as the name of the resource in Kubernetes but it
	// doesn't have to be.
	AzureName            string                       `json:"azureName,omitempty"`
	ManagedClusterUpdate *ManagedClusterUpdate        `json:"managedClusterUpdate,omitempty"`
	OperatorSpec         *FleetsUpdateRunOperatorSpec `json:"operatorSpec,omitempty"`
	OriginalVersion      string                       `json:"originalVersion,omitempty"`

	// +kubebuilder:validation:Required
	// Owner: The owner of the resource. The owner controls where the resource goes when it is deployed. The owner also
	// controls the resources lifecycle. When the owner is deleted the resource will also be deleted. Owner is expected to be a
	// reference to a containerservice.azure.com/Fleet resource
	Owner       *genruntime.KnownResourceReference `group:"containerservice.azure.com" json:"owner,omitempty" kind:"Fleet"`
	PropertyBag genruntime.PropertyBag             `json:"$propertyBag,omitempty"`
	Strategy    *UpdateRunStrategy                 `json:"strategy,omitempty"`
}

var _ genruntime.ConvertibleSpec = &FleetsUpdateRun_Spec{}

// ConvertSpecFrom populates our FleetsUpdateRun_Spec from the provided source
func (updateRun *FleetsUpdateRun_Spec) ConvertSpecFrom(source genruntime.ConvertibleSpec) error {
	if source == updateRun {
		return eris.New("attempted conversion between unrelated implementations of github.com/Azure/azure-service-operator/v2/pkg/genruntime/ConvertibleSpec")
	}

	return source.ConvertSpecTo(updateRun)
}

// ConvertSpecTo populates the provided destination from our FleetsUpdateRun_Spec
func (updateRun *FleetsUpdateRun_Spec) ConvertSpecTo(destination genruntime.ConvertibleSpec) error {
	if destination == updateRun {
		return eris.New("attempted conversion between unrelated implementations of github.com/Azure/azure-service-operator/v2/pkg/genruntime/ConvertibleSpec")
	}

	return destination.ConvertSpecFrom(updateRun)
}

// Storage version of v1api20230315preview.FleetsUpdateRun_STATUS
type FleetsUpdateRun_STATUS struct {
	Conditions           []conditions.Condition       `json:"conditions,omitempty"`
	ETag                 *string                      `json:"eTag,omitempty"`
	Id                   *string                      `json:"id,omitempty"`
	ManagedClusterUpdate *ManagedClusterUpdate_STATUS `json:"managedClusterUpdate,omitempty"`
	Name                 *string                      `json:"name,omitempty"`
	PropertyBag          genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
	ProvisioningState    *string                      `json:"provisioningState,omitempty"`
	Status               *UpdateRunStatus_STATUS      `json:"status,omitempty"`
	Strategy             *UpdateRunStrategy_STATUS    `json:"strategy,omitempty"`
	SystemData           *SystemData_STATUS           `json:"systemData,omitempty"`
	Type                 *string                      `json:"type,omitempty"`
}

var _ genruntime.ConvertibleStatus = &FleetsUpdateRun_STATUS{}

// ConvertStatusFrom populates our FleetsUpdateRun_STATUS from the provided source
func (updateRun *FleetsUpdateRun_STATUS) ConvertStatusFrom(source genruntime.ConvertibleStatus) error {
	if source == updateRun {
		return eris.New("attempted conversion between unrelated implementations of github.com/Azure/azure-service-operator/v2/pkg/genruntime/ConvertibleStatus")
	}

	return source.ConvertStatusTo(updateRun)
}

// ConvertStatusTo populates the provided destination from our FleetsUpdateRun_STATUS
func (updateRun *FleetsUpdateRun_STATUS) ConvertStatusTo(destination genruntime.ConvertibleStatus) error {
	if destination == updateRun {
		return eris.New("attempted conversion between unrelated implementations of github.com/Azure/azure-service-operator/v2/pkg/genruntime/ConvertibleStatus")
	}

	return destination.ConvertStatusFrom(updateRun)
}

// Storage version of v1api20230315preview.FleetsUpdateRunOperatorSpec
// Details for configuring operator behavior. Fields in this struct are interpreted by the operator directly rather than being passed to Azure
type FleetsUpdateRunOperatorSpec struct {
	ConfigMapExpressions []*core.DestinationExpression `json:"configMapExpressions,omitempty"`
	PropertyBag          genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	SecretExpressions    []*core.DestinationExpression `json:"secretExpressions,omitempty"`
}

// Storage version of v1api20230315preview.ManagedClusterUpdate
// The update to be applied to the ManagedClusters.
type ManagedClusterUpdate struct {
	PropertyBag genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	Upgrade     *ManagedClusterUpgradeSpec `json:"upgrade,omitempty"`
}

// Storage version of v1api20230315preview.ManagedClusterUpdate_STATUS
// The update to be applied to the ManagedClusters.
type ManagedClusterUpdate_STATUS struct {
	PropertyBag genruntime.PropertyBag            `json:"$propertyBag,omitempty"`
	Upgrade     *ManagedClusterUpgradeSpec_STATUS `json:"upgrade,omitempty"`
}

// Storage version of v1api20230315preview.UpdateRunStatus_STATUS
// The status of a UpdateRun.
type UpdateRunStatus_STATUS struct {
	PropertyBag genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	Stages      []UpdateStageStatus_STATUS `json:"stages,omitempty"`
	Status      *UpdateStatus_STATUS       `json:"status,omitempty"`
}

// Storage version of v1api20230315preview.UpdateRunStrategy
// Defines the update sequence of the clusters via stages and groups.
// Stages within a run are executed sequentially one
// after another.
// Groups within a stage are executed in parallel.
// Member clusters within a group are updated sequentially
// one after another.
// A valid strategy contains no duplicate groups within or across stages.
type UpdateRunStrategy struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Stages      []UpdateStage          `json:"stages,omitempty"`
}

// Storage version of v1api20230315preview.UpdateRunStrategy_STATUS
// Defines the update sequence of the clusters via stages and groups.
// Stages within a run are executed sequentially one
// after another.
// Groups within a stage are executed in parallel.
// Member clusters within a group are updated sequentially
// one after another.
// A valid strategy contains no duplicate groups within or across stages.
type UpdateRunStrategy_STATUS struct {
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Stages      []UpdateStage_STATUS   `json:"stages,omitempty"`
}

// Storage version of v1api20230315preview.ManagedClusterUpgradeSpec
// The upgrade to apply to a ManagedCluster.
type ManagedClusterUpgradeSpec struct {
	KubernetesVersion *string                `json:"kubernetesVersion,omitempty"`
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type              *string                `json:"type,omitempty"`
}

// Storage version of v1api20230315preview.ManagedClusterUpgradeSpec_STATUS
// The upgrade to apply to a ManagedCluster.
type ManagedClusterUpgradeSpec_STATUS struct {
	KubernetesVersion *string                `json:"kubernetesVersion,omitempty"`
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type              *string                `json:"type,omitempty"`
}

// Storage version of v1api20230315preview.UpdateStage
// Defines a stage which contains the groups to update and the steps to take (e.g., wait for a time period) before starting
// the next stage.
type UpdateStage struct {
	AfterStageWaitInSeconds *int                   `json:"afterStageWaitInSeconds,omitempty"`
	Groups                  []UpdateGroup          `json:"groups,omitempty"`
	Name                    *string                `json:"name,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20230315preview.UpdateStage_STATUS
// Defines a stage which contains the groups to update and the steps to take (e.g., wait for a time period) before starting
// the next stage.
type UpdateStage_STATUS struct {
	AfterStageWaitInSeconds *int                   `json:"afterStageWaitInSeconds,omitempty"`
	Groups                  []UpdateGroup_STATUS   `json:"groups,omitempty"`
	Name                    *string                `json:"name,omitempty"`
	PropertyBag             genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20230315preview.UpdateStageStatus_STATUS
// The status of a UpdateStage.
type UpdateStageStatus_STATUS struct {
	AfterStageWaitStatus *WaitStatus_STATUS         `json:"afterStageWaitStatus,omitempty"`
	Groups               []UpdateGroupStatus_STATUS `json:"groups,omitempty"`
	Name                 *string                    `json:"name,omitempty"`
	PropertyBag          genruntime.PropertyBag     `json:"$propertyBag,omitempty"`
	Status               *UpdateStatus_STATUS       `json:"status,omitempty"`
}

// Storage version of v1api20230315preview.UpdateStatus_STATUS
// The status for an operation or group of operations.
type UpdateStatus_STATUS struct {
	CompletedTime *string                `json:"completedTime,omitempty"`
	Error         *ErrorDetail_STATUS    `json:"error,omitempty"`
	PropertyBag   genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	StartTime     *string                `json:"startTime,omitempty"`
	State         *string                `json:"state,omitempty"`
}

// Storage version of v1api20230315preview.ErrorDetail_STATUS
// The error detail.
type ErrorDetail_STATUS struct {
	AdditionalInfo []ErrorAdditionalInfo_STATUS  `json:"additionalInfo,omitempty"`
	Code           *string                       `json:"code,omitempty"`
	Details        []ErrorDetail_STATUS_Unrolled `json:"details,omitempty"`
	Message        *string                       `json:"message,omitempty"`
	PropertyBag    genruntime.PropertyBag        `json:"$propertyBag,omitempty"`
	Target         *string                       `json:"target,omitempty"`
}

// AssignProperties_From_ErrorDetail_STATUS populates our ErrorDetail_STATUS from the provided source ErrorDetail_STATUS
func (detail *ErrorDetail_STATUS) AssignProperties_From_ErrorDetail_STATUS(source *storage.ErrorDetail_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalInfo
	if source.AdditionalInfo != nil {
		additionalInfoList := make([]ErrorAdditionalInfo_STATUS, len(source.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range source.AdditionalInfo {
			var additionalInfo ErrorAdditionalInfo_STATUS
			err := additionalInfo.AssignProperties_From_ErrorAdditionalInfo_STATUS(&additionalInfoItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		detail.AdditionalInfo = additionalInfoList
	} else {
		detail.AdditionalInfo = nil
	}

	// Code
	detail.Code = genruntime.ClonePointerToString(source.Code)

	// Details
	if source.Details != nil {
		detailList := make([]ErrorDetail_STATUS_Unrolled, len(source.Details))
		for detailIndex, detailItem := range source.Details {
			var detailLocal ErrorDetail_STATUS_Unrolled
			err := detailLocal.AssignProperties_From_ErrorDetail_STATUS_Unrolled(&detailItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorDetail_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detailLocal
		}
		detail.Details = detailList
	} else {
		detail.Details = nil
	}

	// Message
	detail.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	detail.Target = genruntime.ClonePointerToString(source.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		detail.PropertyBag = propertyBag
	} else {
		detail.PropertyBag = nil
	}

	// Invoke the augmentConversionForErrorDetail_STATUS interface (if implemented) to customize the conversion
	var detailAsAny any = detail
	if augmentedDetail, ok := detailAsAny.(augmentConversionForErrorDetail_STATUS); ok {
		err := augmentedDetail.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ErrorDetail_STATUS populates the provided destination ErrorDetail_STATUS from our ErrorDetail_STATUS
func (detail *ErrorDetail_STATUS) AssignProperties_To_ErrorDetail_STATUS(destination *storage.ErrorDetail_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(detail.PropertyBag)

	// AdditionalInfo
	if detail.AdditionalInfo != nil {
		additionalInfoList := make([]storage.ErrorAdditionalInfo_STATUS, len(detail.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range detail.AdditionalInfo {
			var additionalInfo storage.ErrorAdditionalInfo_STATUS
			err := additionalInfoItem.AssignProperties_To_ErrorAdditionalInfo_STATUS(&additionalInfo)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		destination.AdditionalInfo = additionalInfoList
	} else {
		destination.AdditionalInfo = nil
	}

	// Code
	destination.Code = genruntime.ClonePointerToString(detail.Code)

	// Details
	if detail.Details != nil {
		detailList := make([]storage.ErrorDetail_STATUS_Unrolled, len(detail.Details))
		for detailIndex, detailItem := range detail.Details {
			var detailLocal storage.ErrorDetail_STATUS_Unrolled
			err := detailItem.AssignProperties_To_ErrorDetail_STATUS_Unrolled(&detailLocal)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorDetail_STATUS_Unrolled() to populate field Details")
			}
			detailList[detailIndex] = detailLocal
		}
		destination.Details = detailList
	} else {
		destination.Details = nil
	}

	// Message
	destination.Message = genruntime.ClonePointerToString(detail.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(detail.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForErrorDetail_STATUS interface (if implemented) to customize the conversion
	var detailAsAny any = detail
	if augmentedDetail, ok := detailAsAny.(augmentConversionForErrorDetail_STATUS); ok {
		err := augmentedDetail.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230315preview.UpdateGroup
// A group to be updated.
type UpdateGroup struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20230315preview.UpdateGroup_STATUS
// A group to be updated.
type UpdateGroup_STATUS struct {
	Name        *string                `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
}

// Storage version of v1api20230315preview.UpdateGroupStatus_STATUS
// The status of a UpdateGroup.
type UpdateGroupStatus_STATUS struct {
	Members     []MemberUpdateStatus_STATUS `json:"members,omitempty"`
	Name        *string                     `json:"name,omitempty"`
	PropertyBag genruntime.PropertyBag      `json:"$propertyBag,omitempty"`
	Status      *UpdateStatus_STATUS        `json:"status,omitempty"`
}

// Storage version of v1api20230315preview.WaitStatus_STATUS
// The status of the wait duration.
type WaitStatus_STATUS struct {
	PropertyBag           genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Status                *UpdateStatus_STATUS   `json:"status,omitempty"`
	WaitDurationInSeconds *int                   `json:"waitDurationInSeconds,omitempty"`
}

type augmentConversionForErrorDetail_STATUS interface {
	AssignPropertiesFrom(src *storage.ErrorDetail_STATUS) error
	AssignPropertiesTo(dst *storage.ErrorDetail_STATUS) error
}

// Storage version of v1api20230315preview.ErrorAdditionalInfo_STATUS
// The resource management error additional info.
type ErrorAdditionalInfo_STATUS struct {
	Info        map[string]v1.JSON     `json:"info,omitempty"`
	PropertyBag genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Type        *string                `json:"type,omitempty"`
}

// AssignProperties_From_ErrorAdditionalInfo_STATUS populates our ErrorAdditionalInfo_STATUS from the provided source ErrorAdditionalInfo_STATUS
func (info *ErrorAdditionalInfo_STATUS) AssignProperties_From_ErrorAdditionalInfo_STATUS(source *storage.ErrorAdditionalInfo_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// Info
	if source.Info != nil {
		infoMap := make(map[string]v1.JSON, len(source.Info))
		for infoKey, infoValue := range source.Info {
			infoMap[infoKey] = *infoValue.DeepCopy()
		}
		info.Info = infoMap
	} else {
		info.Info = nil
	}

	// Type
	info.Type = genruntime.ClonePointerToString(source.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		info.PropertyBag = propertyBag
	} else {
		info.PropertyBag = nil
	}

	// Invoke the augmentConversionForErrorAdditionalInfo_STATUS interface (if implemented) to customize the conversion
	var infoAsAny any = info
	if augmentedInfo, ok := infoAsAny.(augmentConversionForErrorAdditionalInfo_STATUS); ok {
		err := augmentedInfo.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ErrorAdditionalInfo_STATUS populates the provided destination ErrorAdditionalInfo_STATUS from our ErrorAdditionalInfo_STATUS
func (info *ErrorAdditionalInfo_STATUS) AssignProperties_To_ErrorAdditionalInfo_STATUS(destination *storage.ErrorAdditionalInfo_STATUS) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(info.PropertyBag)

	// Info
	if info.Info != nil {
		infoMap := make(map[string]v1.JSON, len(info.Info))
		for infoKey, infoValue := range info.Info {
			infoMap[infoKey] = *infoValue.DeepCopy()
		}
		destination.Info = infoMap
	} else {
		destination.Info = nil
	}

	// Type
	destination.Type = genruntime.ClonePointerToString(info.Type)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForErrorAdditionalInfo_STATUS interface (if implemented) to customize the conversion
	var infoAsAny any = info
	if augmentedInfo, ok := infoAsAny.(augmentConversionForErrorAdditionalInfo_STATUS); ok {
		err := augmentedInfo.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230315preview.ErrorDetail_STATUS_Unrolled
type ErrorDetail_STATUS_Unrolled struct {
	AdditionalInfo []ErrorAdditionalInfo_STATUS `json:"additionalInfo,omitempty"`
	Code           *string                      `json:"code,omitempty"`
	Message        *string                      `json:"message,omitempty"`
	PropertyBag    genruntime.PropertyBag       `json:"$propertyBag,omitempty"`
	Target         *string                      `json:"target,omitempty"`
}

// AssignProperties_From_ErrorDetail_STATUS_Unrolled populates our ErrorDetail_STATUS_Unrolled from the provided source ErrorDetail_STATUS_Unrolled
func (unrolled *ErrorDetail_STATUS_Unrolled) AssignProperties_From_ErrorDetail_STATUS_Unrolled(source *storage.ErrorDetail_STATUS_Unrolled) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(source.PropertyBag)

	// AdditionalInfo
	if source.AdditionalInfo != nil {
		additionalInfoList := make([]ErrorAdditionalInfo_STATUS, len(source.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range source.AdditionalInfo {
			var additionalInfo ErrorAdditionalInfo_STATUS
			err := additionalInfo.AssignProperties_From_ErrorAdditionalInfo_STATUS(&additionalInfoItem)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_From_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		unrolled.AdditionalInfo = additionalInfoList
	} else {
		unrolled.AdditionalInfo = nil
	}

	// Code
	unrolled.Code = genruntime.ClonePointerToString(source.Code)

	// Message
	unrolled.Message = genruntime.ClonePointerToString(source.Message)

	// Target
	unrolled.Target = genruntime.ClonePointerToString(source.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		unrolled.PropertyBag = propertyBag
	} else {
		unrolled.PropertyBag = nil
	}

	// Invoke the augmentConversionForErrorDetail_STATUS_Unrolled interface (if implemented) to customize the conversion
	var unrolledAsAny any = unrolled
	if augmentedUnrolled, ok := unrolledAsAny.(augmentConversionForErrorDetail_STATUS_Unrolled); ok {
		err := augmentedUnrolled.AssignPropertiesFrom(source)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesFrom() for conversion")
		}
	}

	// No error
	return nil
}

// AssignProperties_To_ErrorDetail_STATUS_Unrolled populates the provided destination ErrorDetail_STATUS_Unrolled from our ErrorDetail_STATUS_Unrolled
func (unrolled *ErrorDetail_STATUS_Unrolled) AssignProperties_To_ErrorDetail_STATUS_Unrolled(destination *storage.ErrorDetail_STATUS_Unrolled) error {
	// Clone the existing property bag
	propertyBag := genruntime.NewPropertyBag(unrolled.PropertyBag)

	// AdditionalInfo
	if unrolled.AdditionalInfo != nil {
		additionalInfoList := make([]storage.ErrorAdditionalInfo_STATUS, len(unrolled.AdditionalInfo))
		for additionalInfoIndex, additionalInfoItem := range unrolled.AdditionalInfo {
			var additionalInfo storage.ErrorAdditionalInfo_STATUS
			err := additionalInfoItem.AssignProperties_To_ErrorAdditionalInfo_STATUS(&additionalInfo)
			if err != nil {
				return eris.Wrap(err, "calling AssignProperties_To_ErrorAdditionalInfo_STATUS() to populate field AdditionalInfo")
			}
			additionalInfoList[additionalInfoIndex] = additionalInfo
		}
		destination.AdditionalInfo = additionalInfoList
	} else {
		destination.AdditionalInfo = nil
	}

	// Code
	destination.Code = genruntime.ClonePointerToString(unrolled.Code)

	// Message
	destination.Message = genruntime.ClonePointerToString(unrolled.Message)

	// Target
	destination.Target = genruntime.ClonePointerToString(unrolled.Target)

	// Update the property bag
	if len(propertyBag) > 0 {
		destination.PropertyBag = propertyBag
	} else {
		destination.PropertyBag = nil
	}

	// Invoke the augmentConversionForErrorDetail_STATUS_Unrolled interface (if implemented) to customize the conversion
	var unrolledAsAny any = unrolled
	if augmentedUnrolled, ok := unrolledAsAny.(augmentConversionForErrorDetail_STATUS_Unrolled); ok {
		err := augmentedUnrolled.AssignPropertiesTo(destination)
		if err != nil {
			return eris.Wrap(err, "calling augmented AssignPropertiesTo() for conversion")
		}
	}

	// No error
	return nil
}

// Storage version of v1api20230315preview.MemberUpdateStatus_STATUS
// The status of a member update operation.
type MemberUpdateStatus_STATUS struct {
	ClusterResourceId *string                `json:"clusterResourceId,omitempty"`
	Name              *string                `json:"name,omitempty"`
	OperationId       *string                `json:"operationId,omitempty"`
	PropertyBag       genruntime.PropertyBag `json:"$propertyBag,omitempty"`
	Status            *UpdateStatus_STATUS   `json:"status,omitempty"`
}

type augmentConversionForErrorAdditionalInfo_STATUS interface {
	AssignPropertiesFrom(src *storage.ErrorAdditionalInfo_STATUS) error
	AssignPropertiesTo(dst *storage.ErrorAdditionalInfo_STATUS) error
}

type augmentConversionForErrorDetail_STATUS_Unrolled interface {
	AssignPropertiesFrom(src *storage.ErrorDetail_STATUS_Unrolled) error
	AssignPropertiesTo(dst *storage.ErrorDetail_STATUS_Unrolled) error
}

func init() {
	SchemeBuilder.Register(&FleetsUpdateRun{}, &FleetsUpdateRunList{})
}
