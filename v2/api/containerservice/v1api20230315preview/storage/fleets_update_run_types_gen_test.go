// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package storage

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ErrorAdditionalInfo_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ErrorAdditionalInfo_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForErrorAdditionalInfo_STATUS, ErrorAdditionalInfo_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForErrorAdditionalInfo_STATUS runs a test to see if a specific instance of ErrorAdditionalInfo_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForErrorAdditionalInfo_STATUS(subject ErrorAdditionalInfo_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ErrorAdditionalInfo_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ErrorAdditionalInfo_STATUS instances for property testing - lazily instantiated by
// ErrorAdditionalInfo_STATUSGenerator()
var errorAdditionalInfo_STATUSGenerator gopter.Gen

// ErrorAdditionalInfo_STATUSGenerator returns a generator of ErrorAdditionalInfo_STATUS instances for property testing.
func ErrorAdditionalInfo_STATUSGenerator() gopter.Gen {
	if errorAdditionalInfo_STATUSGenerator != nil {
		return errorAdditionalInfo_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorAdditionalInfo_STATUS(generators)
	errorAdditionalInfo_STATUSGenerator = gen.Struct(reflect.TypeOf(ErrorAdditionalInfo_STATUS{}), generators)

	return errorAdditionalInfo_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForErrorAdditionalInfo_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForErrorAdditionalInfo_STATUS(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ErrorDetail_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ErrorDetail_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForErrorDetail_STATUS, ErrorDetail_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForErrorDetail_STATUS runs a test to see if a specific instance of ErrorDetail_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForErrorDetail_STATUS(subject ErrorDetail_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ErrorDetail_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ErrorDetail_STATUS instances for property testing - lazily instantiated by ErrorDetail_STATUSGenerator()
var errorDetail_STATUSGenerator gopter.Gen

// ErrorDetail_STATUSGenerator returns a generator of ErrorDetail_STATUS instances for property testing.
// We first initialize errorDetail_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ErrorDetail_STATUSGenerator() gopter.Gen {
	if errorDetail_STATUSGenerator != nil {
		return errorDetail_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS(generators)
	errorDetail_STATUSGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS(generators)
	AddRelatedPropertyGeneratorsForErrorDetail_STATUS(generators)
	errorDetail_STATUSGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS{}), generators)

	return errorDetail_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForErrorDetail_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForErrorDetail_STATUS(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForErrorDetail_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForErrorDetail_STATUS(gens map[string]gopter.Gen) {
	gens["AdditionalInfo"] = gen.SliceOf(ErrorAdditionalInfo_STATUSGenerator())
	gens["Details"] = gen.SliceOf(ErrorDetail_STATUS_UnrolledGenerator())
}

func Test_ErrorDetail_STATUS_Unrolled_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ErrorDetail_STATUS_Unrolled via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForErrorDetail_STATUS_Unrolled, ErrorDetail_STATUS_UnrolledGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForErrorDetail_STATUS_Unrolled runs a test to see if a specific instance of ErrorDetail_STATUS_Unrolled round trips to JSON and back losslessly
func RunJSONSerializationTestForErrorDetail_STATUS_Unrolled(subject ErrorDetail_STATUS_Unrolled) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ErrorDetail_STATUS_Unrolled
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ErrorDetail_STATUS_Unrolled instances for property testing - lazily instantiated by
// ErrorDetail_STATUS_UnrolledGenerator()
var errorDetail_STATUS_UnrolledGenerator gopter.Gen

// ErrorDetail_STATUS_UnrolledGenerator returns a generator of ErrorDetail_STATUS_Unrolled instances for property testing.
// We first initialize errorDetail_STATUS_UnrolledGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ErrorDetail_STATUS_UnrolledGenerator() gopter.Gen {
	if errorDetail_STATUS_UnrolledGenerator != nil {
		return errorDetail_STATUS_UnrolledGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled(generators)
	errorDetail_STATUS_UnrolledGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS_Unrolled{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled(generators)
	AddRelatedPropertyGeneratorsForErrorDetail_STATUS_Unrolled(generators)
	errorDetail_STATUS_UnrolledGenerator = gen.Struct(reflect.TypeOf(ErrorDetail_STATUS_Unrolled{}), generators)

	return errorDetail_STATUS_UnrolledGenerator
}

// AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForErrorDetail_STATUS_Unrolled(gens map[string]gopter.Gen) {
	gens["Code"] = gen.PtrOf(gen.AlphaString())
	gens["Message"] = gen.PtrOf(gen.AlphaString())
	gens["Target"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForErrorDetail_STATUS_Unrolled is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForErrorDetail_STATUS_Unrolled(gens map[string]gopter.Gen) {
	gens["AdditionalInfo"] = gen.SliceOf(ErrorAdditionalInfo_STATUSGenerator())
}

func Test_FleetsUpdateRun_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 20
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FleetsUpdateRun via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFleetsUpdateRun, FleetsUpdateRunGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFleetsUpdateRun runs a test to see if a specific instance of FleetsUpdateRun round trips to JSON and back losslessly
func RunJSONSerializationTestForFleetsUpdateRun(subject FleetsUpdateRun) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FleetsUpdateRun
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FleetsUpdateRun instances for property testing - lazily instantiated by FleetsUpdateRunGenerator()
var fleetsUpdateRunGenerator gopter.Gen

// FleetsUpdateRunGenerator returns a generator of FleetsUpdateRun instances for property testing.
func FleetsUpdateRunGenerator() gopter.Gen {
	if fleetsUpdateRunGenerator != nil {
		return fleetsUpdateRunGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForFleetsUpdateRun(generators)
	fleetsUpdateRunGenerator = gen.Struct(reflect.TypeOf(FleetsUpdateRun{}), generators)

	return fleetsUpdateRunGenerator
}

// AddRelatedPropertyGeneratorsForFleetsUpdateRun is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFleetsUpdateRun(gens map[string]gopter.Gen) {
	gens["Spec"] = FleetsUpdateRun_SpecGenerator()
	gens["Status"] = FleetsUpdateRun_STATUSGenerator()
}

func Test_FleetsUpdateRunOperatorSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FleetsUpdateRunOperatorSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFleetsUpdateRunOperatorSpec, FleetsUpdateRunOperatorSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFleetsUpdateRunOperatorSpec runs a test to see if a specific instance of FleetsUpdateRunOperatorSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForFleetsUpdateRunOperatorSpec(subject FleetsUpdateRunOperatorSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FleetsUpdateRunOperatorSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FleetsUpdateRunOperatorSpec instances for property testing - lazily instantiated by
// FleetsUpdateRunOperatorSpecGenerator()
var fleetsUpdateRunOperatorSpecGenerator gopter.Gen

// FleetsUpdateRunOperatorSpecGenerator returns a generator of FleetsUpdateRunOperatorSpec instances for property testing.
func FleetsUpdateRunOperatorSpecGenerator() gopter.Gen {
	if fleetsUpdateRunOperatorSpecGenerator != nil {
		return fleetsUpdateRunOperatorSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	fleetsUpdateRunOperatorSpecGenerator = gen.Struct(reflect.TypeOf(FleetsUpdateRunOperatorSpec{}), generators)

	return fleetsUpdateRunOperatorSpecGenerator
}

func Test_FleetsUpdateRun_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FleetsUpdateRun_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFleetsUpdateRun_STATUS, FleetsUpdateRun_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFleetsUpdateRun_STATUS runs a test to see if a specific instance of FleetsUpdateRun_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForFleetsUpdateRun_STATUS(subject FleetsUpdateRun_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FleetsUpdateRun_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FleetsUpdateRun_STATUS instances for property testing - lazily instantiated by
// FleetsUpdateRun_STATUSGenerator()
var fleetsUpdateRun_STATUSGenerator gopter.Gen

// FleetsUpdateRun_STATUSGenerator returns a generator of FleetsUpdateRun_STATUS instances for property testing.
// We first initialize fleetsUpdateRun_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FleetsUpdateRun_STATUSGenerator() gopter.Gen {
	if fleetsUpdateRun_STATUSGenerator != nil {
		return fleetsUpdateRun_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFleetsUpdateRun_STATUS(generators)
	fleetsUpdateRun_STATUSGenerator = gen.Struct(reflect.TypeOf(FleetsUpdateRun_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFleetsUpdateRun_STATUS(generators)
	AddRelatedPropertyGeneratorsForFleetsUpdateRun_STATUS(generators)
	fleetsUpdateRun_STATUSGenerator = gen.Struct(reflect.TypeOf(FleetsUpdateRun_STATUS{}), generators)

	return fleetsUpdateRun_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForFleetsUpdateRun_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFleetsUpdateRun_STATUS(gens map[string]gopter.Gen) {
	gens["ETag"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["ProvisioningState"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForFleetsUpdateRun_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFleetsUpdateRun_STATUS(gens map[string]gopter.Gen) {
	gens["ManagedClusterUpdate"] = gen.PtrOf(ManagedClusterUpdate_STATUSGenerator())
	gens["Status"] = gen.PtrOf(UpdateRunStatus_STATUSGenerator())
	gens["Strategy"] = gen.PtrOf(UpdateRunStrategy_STATUSGenerator())
	gens["SystemData"] = gen.PtrOf(SystemData_STATUSGenerator())
}

func Test_FleetsUpdateRun_Spec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of FleetsUpdateRun_Spec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForFleetsUpdateRun_Spec, FleetsUpdateRun_SpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForFleetsUpdateRun_Spec runs a test to see if a specific instance of FleetsUpdateRun_Spec round trips to JSON and back losslessly
func RunJSONSerializationTestForFleetsUpdateRun_Spec(subject FleetsUpdateRun_Spec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual FleetsUpdateRun_Spec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of FleetsUpdateRun_Spec instances for property testing - lazily instantiated by
// FleetsUpdateRun_SpecGenerator()
var fleetsUpdateRun_SpecGenerator gopter.Gen

// FleetsUpdateRun_SpecGenerator returns a generator of FleetsUpdateRun_Spec instances for property testing.
// We first initialize fleetsUpdateRun_SpecGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func FleetsUpdateRun_SpecGenerator() gopter.Gen {
	if fleetsUpdateRun_SpecGenerator != nil {
		return fleetsUpdateRun_SpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFleetsUpdateRun_Spec(generators)
	fleetsUpdateRun_SpecGenerator = gen.Struct(reflect.TypeOf(FleetsUpdateRun_Spec{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForFleetsUpdateRun_Spec(generators)
	AddRelatedPropertyGeneratorsForFleetsUpdateRun_Spec(generators)
	fleetsUpdateRun_SpecGenerator = gen.Struct(reflect.TypeOf(FleetsUpdateRun_Spec{}), generators)

	return fleetsUpdateRun_SpecGenerator
}

// AddIndependentPropertyGeneratorsForFleetsUpdateRun_Spec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForFleetsUpdateRun_Spec(gens map[string]gopter.Gen) {
	gens["AzureName"] = gen.AlphaString()
	gens["OriginalVersion"] = gen.AlphaString()
}

// AddRelatedPropertyGeneratorsForFleetsUpdateRun_Spec is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForFleetsUpdateRun_Spec(gens map[string]gopter.Gen) {
	gens["ManagedClusterUpdate"] = gen.PtrOf(ManagedClusterUpdateGenerator())
	gens["OperatorSpec"] = gen.PtrOf(FleetsUpdateRunOperatorSpecGenerator())
	gens["Strategy"] = gen.PtrOf(UpdateRunStrategyGenerator())
}

func Test_ManagedClusterUpdate_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterUpdate via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterUpdate, ManagedClusterUpdateGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterUpdate runs a test to see if a specific instance of ManagedClusterUpdate round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterUpdate(subject ManagedClusterUpdate) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterUpdate
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterUpdate instances for property testing - lazily instantiated by
// ManagedClusterUpdateGenerator()
var managedClusterUpdateGenerator gopter.Gen

// ManagedClusterUpdateGenerator returns a generator of ManagedClusterUpdate instances for property testing.
func ManagedClusterUpdateGenerator() gopter.Gen {
	if managedClusterUpdateGenerator != nil {
		return managedClusterUpdateGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedClusterUpdate(generators)
	managedClusterUpdateGenerator = gen.Struct(reflect.TypeOf(ManagedClusterUpdate{}), generators)

	return managedClusterUpdateGenerator
}

// AddRelatedPropertyGeneratorsForManagedClusterUpdate is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterUpdate(gens map[string]gopter.Gen) {
	gens["Upgrade"] = gen.PtrOf(ManagedClusterUpgradeSpecGenerator())
}

func Test_ManagedClusterUpdate_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterUpdate_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterUpdate_STATUS, ManagedClusterUpdate_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterUpdate_STATUS runs a test to see if a specific instance of ManagedClusterUpdate_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterUpdate_STATUS(subject ManagedClusterUpdate_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterUpdate_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterUpdate_STATUS instances for property testing - lazily instantiated by
// ManagedClusterUpdate_STATUSGenerator()
var managedClusterUpdate_STATUSGenerator gopter.Gen

// ManagedClusterUpdate_STATUSGenerator returns a generator of ManagedClusterUpdate_STATUS instances for property testing.
func ManagedClusterUpdate_STATUSGenerator() gopter.Gen {
	if managedClusterUpdate_STATUSGenerator != nil {
		return managedClusterUpdate_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedClusterUpdate_STATUS(generators)
	managedClusterUpdate_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedClusterUpdate_STATUS{}), generators)

	return managedClusterUpdate_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForManagedClusterUpdate_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterUpdate_STATUS(gens map[string]gopter.Gen) {
	gens["Upgrade"] = gen.PtrOf(ManagedClusterUpgradeSpec_STATUSGenerator())
}

func Test_ManagedClusterUpgradeSpec_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterUpgradeSpec via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterUpgradeSpec, ManagedClusterUpgradeSpecGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterUpgradeSpec runs a test to see if a specific instance of ManagedClusterUpgradeSpec round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterUpgradeSpec(subject ManagedClusterUpgradeSpec) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterUpgradeSpec
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterUpgradeSpec instances for property testing - lazily instantiated by
// ManagedClusterUpgradeSpecGenerator()
var managedClusterUpgradeSpecGenerator gopter.Gen

// ManagedClusterUpgradeSpecGenerator returns a generator of ManagedClusterUpgradeSpec instances for property testing.
func ManagedClusterUpgradeSpecGenerator() gopter.Gen {
	if managedClusterUpgradeSpecGenerator != nil {
		return managedClusterUpgradeSpecGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterUpgradeSpec(generators)
	managedClusterUpgradeSpecGenerator = gen.Struct(reflect.TypeOf(ManagedClusterUpgradeSpec{}), generators)

	return managedClusterUpgradeSpecGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterUpgradeSpec is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterUpgradeSpec(gens map[string]gopter.Gen) {
	gens["KubernetesVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterUpgradeSpec_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterUpgradeSpec_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterUpgradeSpec_STATUS, ManagedClusterUpgradeSpec_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterUpgradeSpec_STATUS runs a test to see if a specific instance of ManagedClusterUpgradeSpec_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterUpgradeSpec_STATUS(subject ManagedClusterUpgradeSpec_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterUpgradeSpec_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterUpgradeSpec_STATUS instances for property testing - lazily instantiated by
// ManagedClusterUpgradeSpec_STATUSGenerator()
var managedClusterUpgradeSpec_STATUSGenerator gopter.Gen

// ManagedClusterUpgradeSpec_STATUSGenerator returns a generator of ManagedClusterUpgradeSpec_STATUS instances for property testing.
func ManagedClusterUpgradeSpec_STATUSGenerator() gopter.Gen {
	if managedClusterUpgradeSpec_STATUSGenerator != nil {
		return managedClusterUpgradeSpec_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterUpgradeSpec_STATUS(generators)
	managedClusterUpgradeSpec_STATUSGenerator = gen.Struct(reflect.TypeOf(ManagedClusterUpgradeSpec_STATUS{}), generators)

	return managedClusterUpgradeSpec_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterUpgradeSpec_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterUpgradeSpec_STATUS(gens map[string]gopter.Gen) {
	gens["KubernetesVersion"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_MemberUpdateStatus_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of MemberUpdateStatus_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForMemberUpdateStatus_STATUS, MemberUpdateStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForMemberUpdateStatus_STATUS runs a test to see if a specific instance of MemberUpdateStatus_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForMemberUpdateStatus_STATUS(subject MemberUpdateStatus_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual MemberUpdateStatus_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of MemberUpdateStatus_STATUS instances for property testing - lazily instantiated by
// MemberUpdateStatus_STATUSGenerator()
var memberUpdateStatus_STATUSGenerator gopter.Gen

// MemberUpdateStatus_STATUSGenerator returns a generator of MemberUpdateStatus_STATUS instances for property testing.
// We first initialize memberUpdateStatus_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func MemberUpdateStatus_STATUSGenerator() gopter.Gen {
	if memberUpdateStatus_STATUSGenerator != nil {
		return memberUpdateStatus_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMemberUpdateStatus_STATUS(generators)
	memberUpdateStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(MemberUpdateStatus_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForMemberUpdateStatus_STATUS(generators)
	AddRelatedPropertyGeneratorsForMemberUpdateStatus_STATUS(generators)
	memberUpdateStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(MemberUpdateStatus_STATUS{}), generators)

	return memberUpdateStatus_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForMemberUpdateStatus_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForMemberUpdateStatus_STATUS(gens map[string]gopter.Gen) {
	gens["ClusterResourceId"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["OperationId"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForMemberUpdateStatus_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForMemberUpdateStatus_STATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(UpdateStatus_STATUSGenerator())
}

func Test_UpdateGroup_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpdateGroup via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpdateGroup, UpdateGroupGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpdateGroup runs a test to see if a specific instance of UpdateGroup round trips to JSON and back losslessly
func RunJSONSerializationTestForUpdateGroup(subject UpdateGroup) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpdateGroup
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpdateGroup instances for property testing - lazily instantiated by UpdateGroupGenerator()
var updateGroupGenerator gopter.Gen

// UpdateGroupGenerator returns a generator of UpdateGroup instances for property testing.
func UpdateGroupGenerator() gopter.Gen {
	if updateGroupGenerator != nil {
		return updateGroupGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpdateGroup(generators)
	updateGroupGenerator = gen.Struct(reflect.TypeOf(UpdateGroup{}), generators)

	return updateGroupGenerator
}

// AddIndependentPropertyGeneratorsForUpdateGroup is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpdateGroup(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpdateGroupStatus_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpdateGroupStatus_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpdateGroupStatus_STATUS, UpdateGroupStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpdateGroupStatus_STATUS runs a test to see if a specific instance of UpdateGroupStatus_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUpdateGroupStatus_STATUS(subject UpdateGroupStatus_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpdateGroupStatus_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpdateGroupStatus_STATUS instances for property testing - lazily instantiated by
// UpdateGroupStatus_STATUSGenerator()
var updateGroupStatus_STATUSGenerator gopter.Gen

// UpdateGroupStatus_STATUSGenerator returns a generator of UpdateGroupStatus_STATUS instances for property testing.
// We first initialize updateGroupStatus_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpdateGroupStatus_STATUSGenerator() gopter.Gen {
	if updateGroupStatus_STATUSGenerator != nil {
		return updateGroupStatus_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpdateGroupStatus_STATUS(generators)
	updateGroupStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(UpdateGroupStatus_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpdateGroupStatus_STATUS(generators)
	AddRelatedPropertyGeneratorsForUpdateGroupStatus_STATUS(generators)
	updateGroupStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(UpdateGroupStatus_STATUS{}), generators)

	return updateGroupStatus_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUpdateGroupStatus_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpdateGroupStatus_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUpdateGroupStatus_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpdateGroupStatus_STATUS(gens map[string]gopter.Gen) {
	gens["Members"] = gen.SliceOf(MemberUpdateStatus_STATUSGenerator())
	gens["Status"] = gen.PtrOf(UpdateStatus_STATUSGenerator())
}

func Test_UpdateGroup_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpdateGroup_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpdateGroup_STATUS, UpdateGroup_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpdateGroup_STATUS runs a test to see if a specific instance of UpdateGroup_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUpdateGroup_STATUS(subject UpdateGroup_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpdateGroup_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpdateGroup_STATUS instances for property testing - lazily instantiated by UpdateGroup_STATUSGenerator()
var updateGroup_STATUSGenerator gopter.Gen

// UpdateGroup_STATUSGenerator returns a generator of UpdateGroup_STATUS instances for property testing.
func UpdateGroup_STATUSGenerator() gopter.Gen {
	if updateGroup_STATUSGenerator != nil {
		return updateGroup_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpdateGroup_STATUS(generators)
	updateGroup_STATUSGenerator = gen.Struct(reflect.TypeOf(UpdateGroup_STATUS{}), generators)

	return updateGroup_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUpdateGroup_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpdateGroup_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

func Test_UpdateRunStatus_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpdateRunStatus_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpdateRunStatus_STATUS, UpdateRunStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpdateRunStatus_STATUS runs a test to see if a specific instance of UpdateRunStatus_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUpdateRunStatus_STATUS(subject UpdateRunStatus_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpdateRunStatus_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpdateRunStatus_STATUS instances for property testing - lazily instantiated by
// UpdateRunStatus_STATUSGenerator()
var updateRunStatus_STATUSGenerator gopter.Gen

// UpdateRunStatus_STATUSGenerator returns a generator of UpdateRunStatus_STATUS instances for property testing.
func UpdateRunStatus_STATUSGenerator() gopter.Gen {
	if updateRunStatus_STATUSGenerator != nil {
		return updateRunStatus_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForUpdateRunStatus_STATUS(generators)
	updateRunStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(UpdateRunStatus_STATUS{}), generators)

	return updateRunStatus_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForUpdateRunStatus_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpdateRunStatus_STATUS(gens map[string]gopter.Gen) {
	gens["Stages"] = gen.SliceOf(UpdateStageStatus_STATUSGenerator())
	gens["Status"] = gen.PtrOf(UpdateStatus_STATUSGenerator())
}

func Test_UpdateRunStrategy_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpdateRunStrategy via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpdateRunStrategy, UpdateRunStrategyGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpdateRunStrategy runs a test to see if a specific instance of UpdateRunStrategy round trips to JSON and back losslessly
func RunJSONSerializationTestForUpdateRunStrategy(subject UpdateRunStrategy) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpdateRunStrategy
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpdateRunStrategy instances for property testing - lazily instantiated by UpdateRunStrategyGenerator()
var updateRunStrategyGenerator gopter.Gen

// UpdateRunStrategyGenerator returns a generator of UpdateRunStrategy instances for property testing.
func UpdateRunStrategyGenerator() gopter.Gen {
	if updateRunStrategyGenerator != nil {
		return updateRunStrategyGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForUpdateRunStrategy(generators)
	updateRunStrategyGenerator = gen.Struct(reflect.TypeOf(UpdateRunStrategy{}), generators)

	return updateRunStrategyGenerator
}

// AddRelatedPropertyGeneratorsForUpdateRunStrategy is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpdateRunStrategy(gens map[string]gopter.Gen) {
	gens["Stages"] = gen.SliceOf(UpdateStageGenerator())
}

func Test_UpdateRunStrategy_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpdateRunStrategy_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpdateRunStrategy_STATUS, UpdateRunStrategy_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpdateRunStrategy_STATUS runs a test to see if a specific instance of UpdateRunStrategy_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUpdateRunStrategy_STATUS(subject UpdateRunStrategy_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpdateRunStrategy_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpdateRunStrategy_STATUS instances for property testing - lazily instantiated by
// UpdateRunStrategy_STATUSGenerator()
var updateRunStrategy_STATUSGenerator gopter.Gen

// UpdateRunStrategy_STATUSGenerator returns a generator of UpdateRunStrategy_STATUS instances for property testing.
func UpdateRunStrategy_STATUSGenerator() gopter.Gen {
	if updateRunStrategy_STATUSGenerator != nil {
		return updateRunStrategy_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForUpdateRunStrategy_STATUS(generators)
	updateRunStrategy_STATUSGenerator = gen.Struct(reflect.TypeOf(UpdateRunStrategy_STATUS{}), generators)

	return updateRunStrategy_STATUSGenerator
}

// AddRelatedPropertyGeneratorsForUpdateRunStrategy_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpdateRunStrategy_STATUS(gens map[string]gopter.Gen) {
	gens["Stages"] = gen.SliceOf(UpdateStage_STATUSGenerator())
}

func Test_UpdateStage_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpdateStage via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpdateStage, UpdateStageGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpdateStage runs a test to see if a specific instance of UpdateStage round trips to JSON and back losslessly
func RunJSONSerializationTestForUpdateStage(subject UpdateStage) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpdateStage
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpdateStage instances for property testing - lazily instantiated by UpdateStageGenerator()
var updateStageGenerator gopter.Gen

// UpdateStageGenerator returns a generator of UpdateStage instances for property testing.
// We first initialize updateStageGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpdateStageGenerator() gopter.Gen {
	if updateStageGenerator != nil {
		return updateStageGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpdateStage(generators)
	updateStageGenerator = gen.Struct(reflect.TypeOf(UpdateStage{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpdateStage(generators)
	AddRelatedPropertyGeneratorsForUpdateStage(generators)
	updateStageGenerator = gen.Struct(reflect.TypeOf(UpdateStage{}), generators)

	return updateStageGenerator
}

// AddIndependentPropertyGeneratorsForUpdateStage is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpdateStage(gens map[string]gopter.Gen) {
	gens["AfterStageWaitInSeconds"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUpdateStage is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpdateStage(gens map[string]gopter.Gen) {
	gens["Groups"] = gen.SliceOf(UpdateGroupGenerator())
}

func Test_UpdateStageStatus_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpdateStageStatus_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpdateStageStatus_STATUS, UpdateStageStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpdateStageStatus_STATUS runs a test to see if a specific instance of UpdateStageStatus_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUpdateStageStatus_STATUS(subject UpdateStageStatus_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpdateStageStatus_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpdateStageStatus_STATUS instances for property testing - lazily instantiated by
// UpdateStageStatus_STATUSGenerator()
var updateStageStatus_STATUSGenerator gopter.Gen

// UpdateStageStatus_STATUSGenerator returns a generator of UpdateStageStatus_STATUS instances for property testing.
// We first initialize updateStageStatus_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpdateStageStatus_STATUSGenerator() gopter.Gen {
	if updateStageStatus_STATUSGenerator != nil {
		return updateStageStatus_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpdateStageStatus_STATUS(generators)
	updateStageStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(UpdateStageStatus_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpdateStageStatus_STATUS(generators)
	AddRelatedPropertyGeneratorsForUpdateStageStatus_STATUS(generators)
	updateStageStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(UpdateStageStatus_STATUS{}), generators)

	return updateStageStatus_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUpdateStageStatus_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpdateStageStatus_STATUS(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUpdateStageStatus_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpdateStageStatus_STATUS(gens map[string]gopter.Gen) {
	gens["AfterStageWaitStatus"] = gen.PtrOf(WaitStatus_STATUSGenerator())
	gens["Groups"] = gen.SliceOf(UpdateGroupStatus_STATUSGenerator())
	gens["Status"] = gen.PtrOf(UpdateStatus_STATUSGenerator())
}

func Test_UpdateStage_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpdateStage_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpdateStage_STATUS, UpdateStage_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpdateStage_STATUS runs a test to see if a specific instance of UpdateStage_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUpdateStage_STATUS(subject UpdateStage_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpdateStage_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpdateStage_STATUS instances for property testing - lazily instantiated by UpdateStage_STATUSGenerator()
var updateStage_STATUSGenerator gopter.Gen

// UpdateStage_STATUSGenerator returns a generator of UpdateStage_STATUS instances for property testing.
// We first initialize updateStage_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpdateStage_STATUSGenerator() gopter.Gen {
	if updateStage_STATUSGenerator != nil {
		return updateStage_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpdateStage_STATUS(generators)
	updateStage_STATUSGenerator = gen.Struct(reflect.TypeOf(UpdateStage_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpdateStage_STATUS(generators)
	AddRelatedPropertyGeneratorsForUpdateStage_STATUS(generators)
	updateStage_STATUSGenerator = gen.Struct(reflect.TypeOf(UpdateStage_STATUS{}), generators)

	return updateStage_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUpdateStage_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpdateStage_STATUS(gens map[string]gopter.Gen) {
	gens["AfterStageWaitInSeconds"] = gen.PtrOf(gen.Int())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUpdateStage_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpdateStage_STATUS(gens map[string]gopter.Gen) {
	gens["Groups"] = gen.SliceOf(UpdateGroup_STATUSGenerator())
}

func Test_UpdateStatus_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UpdateStatus_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUpdateStatus_STATUS, UpdateStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUpdateStatus_STATUS runs a test to see if a specific instance of UpdateStatus_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForUpdateStatus_STATUS(subject UpdateStatus_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UpdateStatus_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UpdateStatus_STATUS instances for property testing - lazily instantiated by
// UpdateStatus_STATUSGenerator()
var updateStatus_STATUSGenerator gopter.Gen

// UpdateStatus_STATUSGenerator returns a generator of UpdateStatus_STATUS instances for property testing.
// We first initialize updateStatus_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func UpdateStatus_STATUSGenerator() gopter.Gen {
	if updateStatus_STATUSGenerator != nil {
		return updateStatus_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpdateStatus_STATUS(generators)
	updateStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(UpdateStatus_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUpdateStatus_STATUS(generators)
	AddRelatedPropertyGeneratorsForUpdateStatus_STATUS(generators)
	updateStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(UpdateStatus_STATUS{}), generators)

	return updateStatus_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForUpdateStatus_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUpdateStatus_STATUS(gens map[string]gopter.Gen) {
	gens["CompletedTime"] = gen.PtrOf(gen.AlphaString())
	gens["StartTime"] = gen.PtrOf(gen.AlphaString())
	gens["State"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForUpdateStatus_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForUpdateStatus_STATUS(gens map[string]gopter.Gen) {
	gens["Error"] = gen.PtrOf(ErrorDetail_STATUSGenerator())
}

func Test_WaitStatus_STATUS_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of WaitStatus_STATUS via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForWaitStatus_STATUS, WaitStatus_STATUSGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForWaitStatus_STATUS runs a test to see if a specific instance of WaitStatus_STATUS round trips to JSON and back losslessly
func RunJSONSerializationTestForWaitStatus_STATUS(subject WaitStatus_STATUS) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual WaitStatus_STATUS
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of WaitStatus_STATUS instances for property testing - lazily instantiated by WaitStatus_STATUSGenerator()
var waitStatus_STATUSGenerator gopter.Gen

// WaitStatus_STATUSGenerator returns a generator of WaitStatus_STATUS instances for property testing.
// We first initialize waitStatus_STATUSGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func WaitStatus_STATUSGenerator() gopter.Gen {
	if waitStatus_STATUSGenerator != nil {
		return waitStatus_STATUSGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWaitStatus_STATUS(generators)
	waitStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(WaitStatus_STATUS{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForWaitStatus_STATUS(generators)
	AddRelatedPropertyGeneratorsForWaitStatus_STATUS(generators)
	waitStatus_STATUSGenerator = gen.Struct(reflect.TypeOf(WaitStatus_STATUS{}), generators)

	return waitStatus_STATUSGenerator
}

// AddIndependentPropertyGeneratorsForWaitStatus_STATUS is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForWaitStatus_STATUS(gens map[string]gopter.Gen) {
	gens["WaitDurationInSeconds"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForWaitStatus_STATUS is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForWaitStatus_STATUS(gens map[string]gopter.Gen) {
	gens["Status"] = gen.PtrOf(UpdateStatus_STATUSGenerator())
}
