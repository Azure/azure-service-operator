// Code generated by azure-service-operator-codegen. DO NOT EDIT.
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
package v1beta20210501

import (
	"encoding/json"
	"github.com/google/go-cmp/cmp"
	"github.com/google/go-cmp/cmp/cmpopts"
	"github.com/kr/pretty"
	"github.com/kylelemons/godebug/diff"
	"github.com/leanovate/gopter"
	"github.com/leanovate/gopter/gen"
	"github.com/leanovate/gopter/prop"
	"os"
	"reflect"
	"testing"
)

func Test_ManagedClusters_SpecARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 80
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusters_SpecARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusters_SpecARM, ManagedClusters_SpecARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusters_SpecARM runs a test to see if a specific instance of ManagedClusters_SpecARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusters_SpecARM(subject ManagedClusters_SpecARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusters_SpecARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusters_SpecARM instances for property testing - lazily instantiated by
// ManagedClusters_SpecARMGenerator()
var managedClusters_SpecARMGenerator gopter.Gen

// ManagedClusters_SpecARMGenerator returns a generator of ManagedClusters_SpecARM instances for property testing.
// We first initialize managedClusters_SpecARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusters_SpecARMGenerator() gopter.Gen {
	if managedClusters_SpecARMGenerator != nil {
		return managedClusters_SpecARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusters_SpecARM(generators)
	managedClusters_SpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusters_SpecARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusters_SpecARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusters_SpecARM(generators)
	managedClusters_SpecARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusters_SpecARM{}), generators)

	return managedClusters_SpecARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusters_SpecARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusters_SpecARM(gens map[string]gopter.Gen) {
	gens["Location"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.AlphaString()
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedClusters_SpecARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusters_SpecARM(gens map[string]gopter.Gen) {
	gens["ExtendedLocation"] = gen.PtrOf(ExtendedLocationARMGenerator())
	gens["Identity"] = gen.PtrOf(ManagedClusterIdentityARMGenerator())
	gens["Properties"] = gen.PtrOf(ManagedClusterPropertiesARMGenerator())
	gens["Sku"] = gen.PtrOf(ManagedClusterSKUARMGenerator())
}

func Test_ExtendedLocationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ExtendedLocationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForExtendedLocationARM, ExtendedLocationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForExtendedLocationARM runs a test to see if a specific instance of ExtendedLocationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForExtendedLocationARM(subject ExtendedLocationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ExtendedLocationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ExtendedLocationARM instances for property testing - lazily instantiated by
// ExtendedLocationARMGenerator()
var extendedLocationARMGenerator gopter.Gen

// ExtendedLocationARMGenerator returns a generator of ExtendedLocationARM instances for property testing.
func ExtendedLocationARMGenerator() gopter.Gen {
	if extendedLocationARMGenerator != nil {
		return extendedLocationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForExtendedLocationARM(generators)
	extendedLocationARMGenerator = gen.Struct(reflect.TypeOf(ExtendedLocationARM{}), generators)

	return extendedLocationARMGenerator
}

// AddIndependentPropertyGeneratorsForExtendedLocationARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForExtendedLocationARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ExtendedLocation_Type_EdgeZone))
}

func Test_ManagedClusterIdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterIdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterIdentityARM, ManagedClusterIdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterIdentityARM runs a test to see if a specific instance of ManagedClusterIdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterIdentityARM(subject ManagedClusterIdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterIdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterIdentityARM instances for property testing - lazily instantiated by
// ManagedClusterIdentityARMGenerator()
var managedClusterIdentityARMGenerator gopter.Gen

// ManagedClusterIdentityARMGenerator returns a generator of ManagedClusterIdentityARM instances for property testing.
func ManagedClusterIdentityARMGenerator() gopter.Gen {
	if managedClusterIdentityARMGenerator != nil {
		return managedClusterIdentityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterIdentityARM(generators)
	managedClusterIdentityARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterIdentityARM{}), generators)

	return managedClusterIdentityARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterIdentityARM(gens map[string]gopter.Gen) {
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedClusterIdentity_Type_None, ManagedClusterIdentity_Type_SystemAssigned, ManagedClusterIdentity_Type_UserAssigned))
}

func Test_ManagedClusterPropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterPropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterPropertiesARM, ManagedClusterPropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterPropertiesARM runs a test to see if a specific instance of ManagedClusterPropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterPropertiesARM(subject ManagedClusterPropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterPropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterPropertiesARM instances for property testing - lazily instantiated by
// ManagedClusterPropertiesARMGenerator()
var managedClusterPropertiesARMGenerator gopter.Gen

// ManagedClusterPropertiesARMGenerator returns a generator of ManagedClusterPropertiesARM instances for property testing.
// We first initialize managedClusterPropertiesARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterPropertiesARMGenerator() gopter.Gen {
	if managedClusterPropertiesARMGenerator != nil {
		return managedClusterPropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPropertiesARM(generators)
	managedClusterPropertiesARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPropertiesARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPropertiesARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterPropertiesARM(generators)
	managedClusterPropertiesARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPropertiesARM{}), generators)

	return managedClusterPropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterPropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterPropertiesARM(gens map[string]gopter.Gen) {
	gens["DisableLocalAccounts"] = gen.PtrOf(gen.Bool())
	gens["DiskEncryptionSetID"] = gen.PtrOf(gen.AlphaString())
	gens["DnsPrefix"] = gen.PtrOf(gen.AlphaString())
	gens["EnablePodSecurityPolicy"] = gen.PtrOf(gen.Bool())
	gens["EnableRBAC"] = gen.PtrOf(gen.Bool())
	gens["FqdnSubdomain"] = gen.PtrOf(gen.AlphaString())
	gens["KubernetesVersion"] = gen.PtrOf(gen.AlphaString())
	gens["NodeResourceGroup"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedClusterPropertiesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterPropertiesARM(gens map[string]gopter.Gen) {
	gens["AadProfile"] = gen.PtrOf(ManagedClusterAADProfileARMGenerator())
	gens["AddonProfiles"] = gen.MapOf(gen.AlphaString(), ManagedClusterAddonProfileARMGenerator())
	gens["AgentPoolProfiles"] = gen.SliceOf(ManagedClusterAgentPoolProfileARMGenerator())
	gens["ApiServerAccessProfile"] = gen.PtrOf(ManagedClusterAPIServerAccessProfileARMGenerator())
	gens["AutoScalerProfile"] = gen.PtrOf(ManagedClusterPropertiesAutoScalerProfileARMGenerator())
	gens["AutoUpgradeProfile"] = gen.PtrOf(ManagedClusterAutoUpgradeProfileARMGenerator())
	gens["HttpProxyConfig"] = gen.PtrOf(ManagedClusterHTTPProxyConfigARMGenerator())
	gens["IdentityProfile"] = gen.MapOf(gen.AlphaString(), Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARMGenerator())
	gens["LinuxProfile"] = gen.PtrOf(ContainerServiceLinuxProfileARMGenerator())
	gens["NetworkProfile"] = gen.PtrOf(ContainerServiceNetworkProfileARMGenerator())
	gens["PodIdentityProfile"] = gen.PtrOf(ManagedClusterPodIdentityProfileARMGenerator())
	gens["PrivateLinkResources"] = gen.SliceOf(PrivateLinkResourceARMGenerator())
	gens["ServicePrincipalProfile"] = gen.PtrOf(ManagedClusterServicePrincipalProfileARMGenerator())
	gens["WindowsProfile"] = gen.PtrOf(ManagedClusterWindowsProfileARMGenerator())
}

func Test_ManagedClusterSKUARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterSKUARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterSKUARM, ManagedClusterSKUARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterSKUARM runs a test to see if a specific instance of ManagedClusterSKUARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterSKUARM(subject ManagedClusterSKUARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterSKUARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterSKUARM instances for property testing - lazily instantiated by
// ManagedClusterSKUARMGenerator()
var managedClusterSKUARMGenerator gopter.Gen

// ManagedClusterSKUARMGenerator returns a generator of ManagedClusterSKUARM instances for property testing.
func ManagedClusterSKUARMGenerator() gopter.Gen {
	if managedClusterSKUARMGenerator != nil {
		return managedClusterSKUARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterSKUARM(generators)
	managedClusterSKUARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterSKUARM{}), generators)

	return managedClusterSKUARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterSKUARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterSKUARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.OneConstOf(ManagedClusterSKU_Name_Basic))
	gens["Tier"] = gen.PtrOf(gen.OneConstOf(ManagedClusterSKU_Tier_Free, ManagedClusterSKU_Tier_Paid))
}

func Test_Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForComponentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM, Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForComponentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM runs a test to see if a specific instance of Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForComponentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM(subject Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM
// instances for property testing - lazily instantiated by
// Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARMGenerator()
var componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARMGenerator gopter.Gen

// Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARMGenerator returns a generator of Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM instances for property testing.
func Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARMGenerator() gopter.Gen {
	if componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARMGenerator != nil {
		return componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForComponentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM(generators)
	componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARMGenerator = gen.Struct(reflect.TypeOf(Componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM{}), generators)

	return componentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARMGenerator
}

// AddIndependentPropertyGeneratorsForComponentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForComponentsqit0EtschemasmanagedclusterpropertiespropertiesidentityprofileadditionalpropertiesARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerServiceLinuxProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerServiceLinuxProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerServiceLinuxProfileARM, ContainerServiceLinuxProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerServiceLinuxProfileARM runs a test to see if a specific instance of ContainerServiceLinuxProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerServiceLinuxProfileARM(subject ContainerServiceLinuxProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerServiceLinuxProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerServiceLinuxProfileARM instances for property testing - lazily instantiated by
// ContainerServiceLinuxProfileARMGenerator()
var containerServiceLinuxProfileARMGenerator gopter.Gen

// ContainerServiceLinuxProfileARMGenerator returns a generator of ContainerServiceLinuxProfileARM instances for property testing.
// We first initialize containerServiceLinuxProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerServiceLinuxProfileARMGenerator() gopter.Gen {
	if containerServiceLinuxProfileARMGenerator != nil {
		return containerServiceLinuxProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceLinuxProfileARM(generators)
	containerServiceLinuxProfileARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceLinuxProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceLinuxProfileARM(generators)
	AddRelatedPropertyGeneratorsForContainerServiceLinuxProfileARM(generators)
	containerServiceLinuxProfileARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceLinuxProfileARM{}), generators)

	return containerServiceLinuxProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerServiceLinuxProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerServiceLinuxProfileARM(gens map[string]gopter.Gen) {
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerServiceLinuxProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerServiceLinuxProfileARM(gens map[string]gopter.Gen) {
	gens["Ssh"] = gen.PtrOf(ContainerServiceSshConfigurationARMGenerator())
}

func Test_ContainerServiceNetworkProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerServiceNetworkProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerServiceNetworkProfileARM, ContainerServiceNetworkProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerServiceNetworkProfileARM runs a test to see if a specific instance of ContainerServiceNetworkProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerServiceNetworkProfileARM(subject ContainerServiceNetworkProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerServiceNetworkProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerServiceNetworkProfileARM instances for property testing - lazily instantiated by
// ContainerServiceNetworkProfileARMGenerator()
var containerServiceNetworkProfileARMGenerator gopter.Gen

// ContainerServiceNetworkProfileARMGenerator returns a generator of ContainerServiceNetworkProfileARM instances for property testing.
// We first initialize containerServiceNetworkProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ContainerServiceNetworkProfileARMGenerator() gopter.Gen {
	if containerServiceNetworkProfileARMGenerator != nil {
		return containerServiceNetworkProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceNetworkProfileARM(generators)
	containerServiceNetworkProfileARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceNetworkProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceNetworkProfileARM(generators)
	AddRelatedPropertyGeneratorsForContainerServiceNetworkProfileARM(generators)
	containerServiceNetworkProfileARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceNetworkProfileARM{}), generators)

	return containerServiceNetworkProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerServiceNetworkProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerServiceNetworkProfileARM(gens map[string]gopter.Gen) {
	gens["DnsServiceIP"] = gen.PtrOf(gen.AlphaString())
	gens["DockerBridgeCidr"] = gen.PtrOf(gen.AlphaString())
	gens["LoadBalancerSku"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfile_LoadBalancerSku_Basic, ContainerServiceNetworkProfile_LoadBalancerSku_Standard))
	gens["NetworkMode"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfile_NetworkMode_Bridge, ContainerServiceNetworkProfile_NetworkMode_Transparent))
	gens["NetworkPlugin"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfile_NetworkPlugin_Azure, ContainerServiceNetworkProfile_NetworkPlugin_Kubenet))
	gens["NetworkPolicy"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfile_NetworkPolicy_Azure, ContainerServiceNetworkProfile_NetworkPolicy_Calico))
	gens["OutboundType"] = gen.PtrOf(gen.OneConstOf(ContainerServiceNetworkProfile_OutboundType_LoadBalancer, ContainerServiceNetworkProfile_OutboundType_UserDefinedRouting))
	gens["PodCidr"] = gen.PtrOf(gen.AlphaString())
	gens["ServiceCidr"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForContainerServiceNetworkProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerServiceNetworkProfileARM(gens map[string]gopter.Gen) {
	gens["LoadBalancerProfile"] = gen.PtrOf(ManagedClusterLoadBalancerProfileARMGenerator())
}

func Test_ManagedClusterAADProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterAADProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterAADProfileARM, ManagedClusterAADProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterAADProfileARM runs a test to see if a specific instance of ManagedClusterAADProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterAADProfileARM(subject ManagedClusterAADProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterAADProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterAADProfileARM instances for property testing - lazily instantiated by
// ManagedClusterAADProfileARMGenerator()
var managedClusterAADProfileARMGenerator gopter.Gen

// ManagedClusterAADProfileARMGenerator returns a generator of ManagedClusterAADProfileARM instances for property testing.
func ManagedClusterAADProfileARMGenerator() gopter.Gen {
	if managedClusterAADProfileARMGenerator != nil {
		return managedClusterAADProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAADProfileARM(generators)
	managedClusterAADProfileARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAADProfileARM{}), generators)

	return managedClusterAADProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterAADProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterAADProfileARM(gens map[string]gopter.Gen) {
	gens["AdminGroupObjectIDs"] = gen.SliceOf(gen.AlphaString())
	gens["ClientAppID"] = gen.PtrOf(gen.AlphaString())
	gens["EnableAzureRBAC"] = gen.PtrOf(gen.Bool())
	gens["Managed"] = gen.PtrOf(gen.Bool())
	gens["ServerAppID"] = gen.PtrOf(gen.AlphaString())
	gens["ServerAppSecret"] = gen.PtrOf(gen.AlphaString())
	gens["TenantID"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterAddonProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterAddonProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterAddonProfileARM, ManagedClusterAddonProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterAddonProfileARM runs a test to see if a specific instance of ManagedClusterAddonProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterAddonProfileARM(subject ManagedClusterAddonProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterAddonProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterAddonProfileARM instances for property testing - lazily instantiated by
// ManagedClusterAddonProfileARMGenerator()
var managedClusterAddonProfileARMGenerator gopter.Gen

// ManagedClusterAddonProfileARMGenerator returns a generator of ManagedClusterAddonProfileARM instances for property testing.
func ManagedClusterAddonProfileARMGenerator() gopter.Gen {
	if managedClusterAddonProfileARMGenerator != nil {
		return managedClusterAddonProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAddonProfileARM(generators)
	managedClusterAddonProfileARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAddonProfileARM{}), generators)

	return managedClusterAddonProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterAddonProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterAddonProfileARM(gens map[string]gopter.Gen) {
	gens["Config"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

func Test_ManagedClusterAgentPoolProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterAgentPoolProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterAgentPoolProfileARM, ManagedClusterAgentPoolProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterAgentPoolProfileARM runs a test to see if a specific instance of ManagedClusterAgentPoolProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterAgentPoolProfileARM(subject ManagedClusterAgentPoolProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterAgentPoolProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterAgentPoolProfileARM instances for property testing - lazily instantiated by
// ManagedClusterAgentPoolProfileARMGenerator()
var managedClusterAgentPoolProfileARMGenerator gopter.Gen

// ManagedClusterAgentPoolProfileARMGenerator returns a generator of ManagedClusterAgentPoolProfileARM instances for property testing.
// We first initialize managedClusterAgentPoolProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterAgentPoolProfileARMGenerator() gopter.Gen {
	if managedClusterAgentPoolProfileARMGenerator != nil {
		return managedClusterAgentPoolProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAgentPoolProfileARM(generators)
	managedClusterAgentPoolProfileARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAgentPoolProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAgentPoolProfileARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterAgentPoolProfileARM(generators)
	managedClusterAgentPoolProfileARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAgentPoolProfileARM{}), generators)

	return managedClusterAgentPoolProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterAgentPoolProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterAgentPoolProfileARM(gens map[string]gopter.Gen) {
	gens["AvailabilityZones"] = gen.SliceOf(gen.AlphaString())
	gens["Count"] = gen.PtrOf(gen.Int())
	gens["EnableAutoScaling"] = gen.PtrOf(gen.Bool())
	gens["EnableEncryptionAtHost"] = gen.PtrOf(gen.Bool())
	gens["EnableFIPS"] = gen.PtrOf(gen.Bool())
	gens["EnableNodePublicIP"] = gen.PtrOf(gen.Bool())
	gens["EnableUltraSSD"] = gen.PtrOf(gen.Bool())
	gens["GpuInstanceProfile"] = gen.PtrOf(gen.OneConstOf(
		ManagedClusterAgentPoolProfile_GpuInstanceProfile_MIG1G,
		ManagedClusterAgentPoolProfile_GpuInstanceProfile_MIG2G,
		ManagedClusterAgentPoolProfile_GpuInstanceProfile_MIG3G,
		ManagedClusterAgentPoolProfile_GpuInstanceProfile_MIG4G,
		ManagedClusterAgentPoolProfile_GpuInstanceProfile_MIG7G))
	gens["KubeletDiskType"] = gen.PtrOf(gen.OneConstOf(ManagedClusterAgentPoolProfile_KubeletDiskType_OS, ManagedClusterAgentPoolProfile_KubeletDiskType_Temporary))
	gens["MaxCount"] = gen.PtrOf(gen.Int())
	gens["MaxPods"] = gen.PtrOf(gen.Int())
	gens["MinCount"] = gen.PtrOf(gen.Int())
	gens["Mode"] = gen.PtrOf(gen.OneConstOf(ManagedClusterAgentPoolProfile_Mode_System, ManagedClusterAgentPoolProfile_Mode_User))
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["NodeLabels"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["NodePublicIPPrefixID"] = gen.PtrOf(gen.AlphaString())
	gens["NodeTaints"] = gen.SliceOf(gen.AlphaString())
	gens["OrchestratorVersion"] = gen.PtrOf(gen.AlphaString())
	gens["OsDiskSizeGB"] = gen.PtrOf(gen.Int())
	gens["OsDiskType"] = gen.PtrOf(gen.OneConstOf(ManagedClusterAgentPoolProfile_OsDiskType_Ephemeral, ManagedClusterAgentPoolProfile_OsDiskType_Managed))
	gens["OsSKU"] = gen.PtrOf(gen.OneConstOf(ManagedClusterAgentPoolProfile_OsSKU_CBLMariner, ManagedClusterAgentPoolProfile_OsSKU_Ubuntu))
	gens["OsType"] = gen.PtrOf(gen.OneConstOf(ManagedClusterAgentPoolProfile_OsType_Linux, ManagedClusterAgentPoolProfile_OsType_Windows))
	gens["PodSubnetID"] = gen.PtrOf(gen.AlphaString())
	gens["ProximityPlacementGroupID"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleSetEvictionPolicy"] = gen.PtrOf(gen.OneConstOf(ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_Deallocate, ManagedClusterAgentPoolProfile_ScaleSetEvictionPolicy_Delete))
	gens["ScaleSetPriority"] = gen.PtrOf(gen.OneConstOf(ManagedClusterAgentPoolProfile_ScaleSetPriority_Regular, ManagedClusterAgentPoolProfile_ScaleSetPriority_Spot))
	gens["SpotMaxPrice"] = gen.PtrOf(gen.Float64())
	gens["Tags"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.OneConstOf(ManagedClusterAgentPoolProfile_Type_AvailabilitySet, ManagedClusterAgentPoolProfile_Type_VirtualMachineScaleSets))
	gens["VmSize"] = gen.PtrOf(gen.AlphaString())
	gens["VnetSubnetID"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedClusterAgentPoolProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterAgentPoolProfileARM(gens map[string]gopter.Gen) {
	gens["KubeletConfig"] = gen.PtrOf(KubeletConfigARMGenerator())
	gens["LinuxOSConfig"] = gen.PtrOf(LinuxOSConfigARMGenerator())
	gens["UpgradeSettings"] = gen.PtrOf(AgentPoolUpgradeSettingsARMGenerator())
}

func Test_ManagedClusterAPIServerAccessProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterAPIServerAccessProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterAPIServerAccessProfileARM, ManagedClusterAPIServerAccessProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterAPIServerAccessProfileARM runs a test to see if a specific instance of ManagedClusterAPIServerAccessProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterAPIServerAccessProfileARM(subject ManagedClusterAPIServerAccessProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterAPIServerAccessProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterAPIServerAccessProfileARM instances for property testing - lazily instantiated by
// ManagedClusterAPIServerAccessProfileARMGenerator()
var managedClusterAPIServerAccessProfileARMGenerator gopter.Gen

// ManagedClusterAPIServerAccessProfileARMGenerator returns a generator of ManagedClusterAPIServerAccessProfileARM instances for property testing.
func ManagedClusterAPIServerAccessProfileARMGenerator() gopter.Gen {
	if managedClusterAPIServerAccessProfileARMGenerator != nil {
		return managedClusterAPIServerAccessProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAPIServerAccessProfileARM(generators)
	managedClusterAPIServerAccessProfileARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAPIServerAccessProfileARM{}), generators)

	return managedClusterAPIServerAccessProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterAPIServerAccessProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterAPIServerAccessProfileARM(gens map[string]gopter.Gen) {
	gens["AuthorizedIPRanges"] = gen.SliceOf(gen.AlphaString())
	gens["EnablePrivateCluster"] = gen.PtrOf(gen.Bool())
	gens["EnablePrivateClusterPublicFQDN"] = gen.PtrOf(gen.Bool())
	gens["PrivateDNSZone"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterAutoUpgradeProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterAutoUpgradeProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterAutoUpgradeProfileARM, ManagedClusterAutoUpgradeProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterAutoUpgradeProfileARM runs a test to see if a specific instance of ManagedClusterAutoUpgradeProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterAutoUpgradeProfileARM(subject ManagedClusterAutoUpgradeProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterAutoUpgradeProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterAutoUpgradeProfileARM instances for property testing - lazily instantiated by
// ManagedClusterAutoUpgradeProfileARMGenerator()
var managedClusterAutoUpgradeProfileARMGenerator gopter.Gen

// ManagedClusterAutoUpgradeProfileARMGenerator returns a generator of ManagedClusterAutoUpgradeProfileARM instances for property testing.
func ManagedClusterAutoUpgradeProfileARMGenerator() gopter.Gen {
	if managedClusterAutoUpgradeProfileARMGenerator != nil {
		return managedClusterAutoUpgradeProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterAutoUpgradeProfileARM(generators)
	managedClusterAutoUpgradeProfileARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterAutoUpgradeProfileARM{}), generators)

	return managedClusterAutoUpgradeProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterAutoUpgradeProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterAutoUpgradeProfileARM(gens map[string]gopter.Gen) {
	gens["UpgradeChannel"] = gen.PtrOf(gen.OneConstOf(
		ManagedClusterAutoUpgradeProfile_UpgradeChannel_NodeImage,
		ManagedClusterAutoUpgradeProfile_UpgradeChannel_None,
		ManagedClusterAutoUpgradeProfile_UpgradeChannel_Patch,
		ManagedClusterAutoUpgradeProfile_UpgradeChannel_Rapid,
		ManagedClusterAutoUpgradeProfile_UpgradeChannel_Stable))
}

func Test_ManagedClusterHTTPProxyConfigARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterHTTPProxyConfigARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterHTTPProxyConfigARM, ManagedClusterHTTPProxyConfigARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterHTTPProxyConfigARM runs a test to see if a specific instance of ManagedClusterHTTPProxyConfigARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterHTTPProxyConfigARM(subject ManagedClusterHTTPProxyConfigARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterHTTPProxyConfigARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterHTTPProxyConfigARM instances for property testing - lazily instantiated by
// ManagedClusterHTTPProxyConfigARMGenerator()
var managedClusterHTTPProxyConfigARMGenerator gopter.Gen

// ManagedClusterHTTPProxyConfigARMGenerator returns a generator of ManagedClusterHTTPProxyConfigARM instances for property testing.
func ManagedClusterHTTPProxyConfigARMGenerator() gopter.Gen {
	if managedClusterHTTPProxyConfigARMGenerator != nil {
		return managedClusterHTTPProxyConfigARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterHTTPProxyConfigARM(generators)
	managedClusterHTTPProxyConfigARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterHTTPProxyConfigARM{}), generators)

	return managedClusterHTTPProxyConfigARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterHTTPProxyConfigARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterHTTPProxyConfigARM(gens map[string]gopter.Gen) {
	gens["HttpProxy"] = gen.PtrOf(gen.AlphaString())
	gens["HttpsProxy"] = gen.PtrOf(gen.AlphaString())
	gens["NoProxy"] = gen.SliceOf(gen.AlphaString())
	gens["TrustedCa"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterPodIdentityProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterPodIdentityProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterPodIdentityProfileARM, ManagedClusterPodIdentityProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterPodIdentityProfileARM runs a test to see if a specific instance of ManagedClusterPodIdentityProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterPodIdentityProfileARM(subject ManagedClusterPodIdentityProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterPodIdentityProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterPodIdentityProfileARM instances for property testing - lazily instantiated by
// ManagedClusterPodIdentityProfileARMGenerator()
var managedClusterPodIdentityProfileARMGenerator gopter.Gen

// ManagedClusterPodIdentityProfileARMGenerator returns a generator of ManagedClusterPodIdentityProfileARM instances for property testing.
// We first initialize managedClusterPodIdentityProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterPodIdentityProfileARMGenerator() gopter.Gen {
	if managedClusterPodIdentityProfileARMGenerator != nil {
		return managedClusterPodIdentityProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentityProfileARM(generators)
	managedClusterPodIdentityProfileARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentityProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentityProfileARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterPodIdentityProfileARM(generators)
	managedClusterPodIdentityProfileARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentityProfileARM{}), generators)

	return managedClusterPodIdentityProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterPodIdentityProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterPodIdentityProfileARM(gens map[string]gopter.Gen) {
	gens["AllowNetworkPluginKubenet"] = gen.PtrOf(gen.Bool())
	gens["Enabled"] = gen.PtrOf(gen.Bool())
}

// AddRelatedPropertyGeneratorsForManagedClusterPodIdentityProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterPodIdentityProfileARM(gens map[string]gopter.Gen) {
	gens["UserAssignedIdentities"] = gen.SliceOf(ManagedClusterPodIdentityARMGenerator())
	gens["UserAssignedIdentityExceptions"] = gen.SliceOf(ManagedClusterPodIdentityExceptionARMGenerator())
}

func Test_ManagedClusterPropertiesAutoScalerProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterPropertiesAutoScalerProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterPropertiesAutoScalerProfileARM, ManagedClusterPropertiesAutoScalerProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterPropertiesAutoScalerProfileARM runs a test to see if a specific instance of ManagedClusterPropertiesAutoScalerProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterPropertiesAutoScalerProfileARM(subject ManagedClusterPropertiesAutoScalerProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterPropertiesAutoScalerProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterPropertiesAutoScalerProfileARM instances for property testing - lazily instantiated by
// ManagedClusterPropertiesAutoScalerProfileARMGenerator()
var managedClusterPropertiesAutoScalerProfileARMGenerator gopter.Gen

// ManagedClusterPropertiesAutoScalerProfileARMGenerator returns a generator of ManagedClusterPropertiesAutoScalerProfileARM instances for property testing.
func ManagedClusterPropertiesAutoScalerProfileARMGenerator() gopter.Gen {
	if managedClusterPropertiesAutoScalerProfileARMGenerator != nil {
		return managedClusterPropertiesAutoScalerProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPropertiesAutoScalerProfileARM(generators)
	managedClusterPropertiesAutoScalerProfileARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPropertiesAutoScalerProfileARM{}), generators)

	return managedClusterPropertiesAutoScalerProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterPropertiesAutoScalerProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterPropertiesAutoScalerProfileARM(gens map[string]gopter.Gen) {
	gens["BalanceSimilarNodeGroups"] = gen.PtrOf(gen.AlphaString())
	gens["Expander"] = gen.PtrOf(gen.OneConstOf(
		ManagedClusterPropertiesAutoScalerProfile_Expander_LeastWaste,
		ManagedClusterPropertiesAutoScalerProfile_Expander_MostPods,
		ManagedClusterPropertiesAutoScalerProfile_Expander_Priority,
		ManagedClusterPropertiesAutoScalerProfile_Expander_Random))
	gens["MaxEmptyBulkDelete"] = gen.PtrOf(gen.AlphaString())
	gens["MaxGracefulTerminationSec"] = gen.PtrOf(gen.AlphaString())
	gens["MaxNodeProvisionTime"] = gen.PtrOf(gen.AlphaString())
	gens["MaxTotalUnreadyPercentage"] = gen.PtrOf(gen.AlphaString())
	gens["NewPodScaleUpDelay"] = gen.PtrOf(gen.AlphaString())
	gens["OkTotalUnreadyCount"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownDelayAfterAdd"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownDelayAfterDelete"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownDelayAfterFailure"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownUnneededTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownUnreadyTime"] = gen.PtrOf(gen.AlphaString())
	gens["ScaleDownUtilizationThreshold"] = gen.PtrOf(gen.AlphaString())
	gens["ScanInterval"] = gen.PtrOf(gen.AlphaString())
	gens["SkipNodesWithLocalStorage"] = gen.PtrOf(gen.AlphaString())
	gens["SkipNodesWithSystemPods"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterServicePrincipalProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterServicePrincipalProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterServicePrincipalProfileARM, ManagedClusterServicePrincipalProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterServicePrincipalProfileARM runs a test to see if a specific instance of ManagedClusterServicePrincipalProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterServicePrincipalProfileARM(subject ManagedClusterServicePrincipalProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterServicePrincipalProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterServicePrincipalProfileARM instances for property testing - lazily instantiated by
// ManagedClusterServicePrincipalProfileARMGenerator()
var managedClusterServicePrincipalProfileARMGenerator gopter.Gen

// ManagedClusterServicePrincipalProfileARMGenerator returns a generator of ManagedClusterServicePrincipalProfileARM instances for property testing.
func ManagedClusterServicePrincipalProfileARMGenerator() gopter.Gen {
	if managedClusterServicePrincipalProfileARMGenerator != nil {
		return managedClusterServicePrincipalProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterServicePrincipalProfileARM(generators)
	managedClusterServicePrincipalProfileARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterServicePrincipalProfileARM{}), generators)

	return managedClusterServicePrincipalProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterServicePrincipalProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterServicePrincipalProfileARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["Secret"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterWindowsProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterWindowsProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterWindowsProfileARM, ManagedClusterWindowsProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterWindowsProfileARM runs a test to see if a specific instance of ManagedClusterWindowsProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterWindowsProfileARM(subject ManagedClusterWindowsProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterWindowsProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterWindowsProfileARM instances for property testing - lazily instantiated by
// ManagedClusterWindowsProfileARMGenerator()
var managedClusterWindowsProfileARMGenerator gopter.Gen

// ManagedClusterWindowsProfileARMGenerator returns a generator of ManagedClusterWindowsProfileARM instances for property testing.
func ManagedClusterWindowsProfileARMGenerator() gopter.Gen {
	if managedClusterWindowsProfileARMGenerator != nil {
		return managedClusterWindowsProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterWindowsProfileARM(generators)
	managedClusterWindowsProfileARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterWindowsProfileARM{}), generators)

	return managedClusterWindowsProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterWindowsProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterWindowsProfileARM(gens map[string]gopter.Gen) {
	gens["AdminPassword"] = gen.PtrOf(gen.AlphaString())
	gens["AdminUsername"] = gen.PtrOf(gen.AlphaString())
	gens["EnableCSIProxy"] = gen.PtrOf(gen.Bool())
	gens["LicenseType"] = gen.PtrOf(gen.OneConstOf(ManagedClusterWindowsProfile_LicenseType_None, ManagedClusterWindowsProfile_LicenseType_Windows_Server))
}

func Test_PrivateLinkResourceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of PrivateLinkResourceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForPrivateLinkResourceARM, PrivateLinkResourceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForPrivateLinkResourceARM runs a test to see if a specific instance of PrivateLinkResourceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForPrivateLinkResourceARM(subject PrivateLinkResourceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual PrivateLinkResourceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of PrivateLinkResourceARM instances for property testing - lazily instantiated by
// PrivateLinkResourceARMGenerator()
var privateLinkResourceARMGenerator gopter.Gen

// PrivateLinkResourceARMGenerator returns a generator of PrivateLinkResourceARM instances for property testing.
func PrivateLinkResourceARMGenerator() gopter.Gen {
	if privateLinkResourceARMGenerator != nil {
		return privateLinkResourceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForPrivateLinkResourceARM(generators)
	privateLinkResourceARMGenerator = gen.Struct(reflect.TypeOf(PrivateLinkResourceARM{}), generators)

	return privateLinkResourceARMGenerator
}

// AddIndependentPropertyGeneratorsForPrivateLinkResourceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForPrivateLinkResourceARM(gens map[string]gopter.Gen) {
	gens["GroupId"] = gen.PtrOf(gen.AlphaString())
	gens["Id"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["RequiredMembers"] = gen.SliceOf(gen.AlphaString())
	gens["Type"] = gen.PtrOf(gen.AlphaString())
}

func Test_ContainerServiceSshConfigurationARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerServiceSshConfigurationARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerServiceSshConfigurationARM, ContainerServiceSshConfigurationARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerServiceSshConfigurationARM runs a test to see if a specific instance of ContainerServiceSshConfigurationARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerServiceSshConfigurationARM(subject ContainerServiceSshConfigurationARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerServiceSshConfigurationARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerServiceSshConfigurationARM instances for property testing - lazily instantiated by
// ContainerServiceSshConfigurationARMGenerator()
var containerServiceSshConfigurationARMGenerator gopter.Gen

// ContainerServiceSshConfigurationARMGenerator returns a generator of ContainerServiceSshConfigurationARM instances for property testing.
func ContainerServiceSshConfigurationARMGenerator() gopter.Gen {
	if containerServiceSshConfigurationARMGenerator != nil {
		return containerServiceSshConfigurationARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForContainerServiceSshConfigurationARM(generators)
	containerServiceSshConfigurationARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceSshConfigurationARM{}), generators)

	return containerServiceSshConfigurationARMGenerator
}

// AddRelatedPropertyGeneratorsForContainerServiceSshConfigurationARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForContainerServiceSshConfigurationARM(gens map[string]gopter.Gen) {
	gens["PublicKeys"] = gen.SliceOf(ContainerServiceSshPublicKeyARMGenerator())
}

func Test_ManagedClusterLoadBalancerProfileARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterLoadBalancerProfileARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterLoadBalancerProfileARM, ManagedClusterLoadBalancerProfileARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterLoadBalancerProfileARM runs a test to see if a specific instance of ManagedClusterLoadBalancerProfileARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterLoadBalancerProfileARM(subject ManagedClusterLoadBalancerProfileARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterLoadBalancerProfileARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterLoadBalancerProfileARM instances for property testing - lazily instantiated by
// ManagedClusterLoadBalancerProfileARMGenerator()
var managedClusterLoadBalancerProfileARMGenerator gopter.Gen

// ManagedClusterLoadBalancerProfileARMGenerator returns a generator of ManagedClusterLoadBalancerProfileARM instances for property testing.
// We first initialize managedClusterLoadBalancerProfileARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterLoadBalancerProfileARMGenerator() gopter.Gen {
	if managedClusterLoadBalancerProfileARMGenerator != nil {
		return managedClusterLoadBalancerProfileARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfileARM(generators)
	managedClusterLoadBalancerProfileARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfileARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfileARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileARM(generators)
	managedClusterLoadBalancerProfileARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfileARM{}), generators)

	return managedClusterLoadBalancerProfileARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfileARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfileARM(gens map[string]gopter.Gen) {
	gens["AllocatedOutboundPorts"] = gen.PtrOf(gen.Int())
	gens["IdleTimeoutInMinutes"] = gen.PtrOf(gen.Int())
}

// AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileARM(gens map[string]gopter.Gen) {
	gens["EffectiveOutboundIPs"] = gen.SliceOf(ResourceReferenceARMGenerator())
	gens["ManagedOutboundIPs"] = gen.PtrOf(ManagedClusterLoadBalancerProfileManagedOutboundIPsARMGenerator())
	gens["OutboundIPPrefixes"] = gen.PtrOf(ManagedClusterLoadBalancerProfileOutboundIPPrefixesARMGenerator())
	gens["OutboundIPs"] = gen.PtrOf(ManagedClusterLoadBalancerProfileOutboundIPsARMGenerator())
}

func Test_ManagedClusterPodIdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterPodIdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterPodIdentityARM, ManagedClusterPodIdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterPodIdentityARM runs a test to see if a specific instance of ManagedClusterPodIdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterPodIdentityARM(subject ManagedClusterPodIdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterPodIdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterPodIdentityARM instances for property testing - lazily instantiated by
// ManagedClusterPodIdentityARMGenerator()
var managedClusterPodIdentityARMGenerator gopter.Gen

// ManagedClusterPodIdentityARMGenerator returns a generator of ManagedClusterPodIdentityARM instances for property testing.
// We first initialize managedClusterPodIdentityARMGenerator with a simplified generator based on the
// fields with primitive types then replacing it with a more complex one that also handles complex fields
// to ensure any cycles in the object graph properly terminate.
func ManagedClusterPodIdentityARMGenerator() gopter.Gen {
	if managedClusterPodIdentityARMGenerator != nil {
		return managedClusterPodIdentityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentityARM(generators)
	managedClusterPodIdentityARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentityARM{}), generators)

	// The above call to gen.Struct() captures the map, so create a new one
	generators = make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentityARM(generators)
	AddRelatedPropertyGeneratorsForManagedClusterPodIdentityARM(generators)
	managedClusterPodIdentityARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentityARM{}), generators)

	return managedClusterPodIdentityARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterPodIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterPodIdentityARM(gens map[string]gopter.Gen) {
	gens["BindingSelector"] = gen.PtrOf(gen.AlphaString())
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Namespace"] = gen.PtrOf(gen.AlphaString())
}

// AddRelatedPropertyGeneratorsForManagedClusterPodIdentityARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterPodIdentityARM(gens map[string]gopter.Gen) {
	gens["Identity"] = gen.PtrOf(UserAssignedIdentityARMGenerator())
}

func Test_ManagedClusterPodIdentityExceptionARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterPodIdentityExceptionARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterPodIdentityExceptionARM, ManagedClusterPodIdentityExceptionARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterPodIdentityExceptionARM runs a test to see if a specific instance of ManagedClusterPodIdentityExceptionARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterPodIdentityExceptionARM(subject ManagedClusterPodIdentityExceptionARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterPodIdentityExceptionARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterPodIdentityExceptionARM instances for property testing - lazily instantiated by
// ManagedClusterPodIdentityExceptionARMGenerator()
var managedClusterPodIdentityExceptionARMGenerator gopter.Gen

// ManagedClusterPodIdentityExceptionARMGenerator returns a generator of ManagedClusterPodIdentityExceptionARM instances for property testing.
func ManagedClusterPodIdentityExceptionARMGenerator() gopter.Gen {
	if managedClusterPodIdentityExceptionARMGenerator != nil {
		return managedClusterPodIdentityExceptionARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterPodIdentityExceptionARM(generators)
	managedClusterPodIdentityExceptionARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterPodIdentityExceptionARM{}), generators)

	return managedClusterPodIdentityExceptionARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterPodIdentityExceptionARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterPodIdentityExceptionARM(gens map[string]gopter.Gen) {
	gens["Name"] = gen.PtrOf(gen.AlphaString())
	gens["Namespace"] = gen.PtrOf(gen.AlphaString())
	gens["PodLabels"] = gen.MapOf(gen.AlphaString(), gen.AlphaString())
}

func Test_ContainerServiceSshPublicKeyARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ContainerServiceSshPublicKeyARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForContainerServiceSshPublicKeyARM, ContainerServiceSshPublicKeyARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForContainerServiceSshPublicKeyARM runs a test to see if a specific instance of ContainerServiceSshPublicKeyARM round trips to JSON and back losslessly
func RunJSONSerializationTestForContainerServiceSshPublicKeyARM(subject ContainerServiceSshPublicKeyARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ContainerServiceSshPublicKeyARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ContainerServiceSshPublicKeyARM instances for property testing - lazily instantiated by
// ContainerServiceSshPublicKeyARMGenerator()
var containerServiceSshPublicKeyARMGenerator gopter.Gen

// ContainerServiceSshPublicKeyARMGenerator returns a generator of ContainerServiceSshPublicKeyARM instances for property testing.
func ContainerServiceSshPublicKeyARMGenerator() gopter.Gen {
	if containerServiceSshPublicKeyARMGenerator != nil {
		return containerServiceSshPublicKeyARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForContainerServiceSshPublicKeyARM(generators)
	containerServiceSshPublicKeyARMGenerator = gen.Struct(reflect.TypeOf(ContainerServiceSshPublicKeyARM{}), generators)

	return containerServiceSshPublicKeyARMGenerator
}

// AddIndependentPropertyGeneratorsForContainerServiceSshPublicKeyARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForContainerServiceSshPublicKeyARM(gens map[string]gopter.Gen) {
	gens["KeyData"] = gen.PtrOf(gen.AlphaString())
}

func Test_ManagedClusterLoadBalancerProfileManagedOutboundIPsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterLoadBalancerProfileManagedOutboundIPsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterLoadBalancerProfileManagedOutboundIPsARM, ManagedClusterLoadBalancerProfileManagedOutboundIPsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterLoadBalancerProfileManagedOutboundIPsARM runs a test to see if a specific instance of ManagedClusterLoadBalancerProfileManagedOutboundIPsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterLoadBalancerProfileManagedOutboundIPsARM(subject ManagedClusterLoadBalancerProfileManagedOutboundIPsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterLoadBalancerProfileManagedOutboundIPsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterLoadBalancerProfileManagedOutboundIPsARM instances for property testing - lazily
// instantiated by ManagedClusterLoadBalancerProfileManagedOutboundIPsARMGenerator()
var managedClusterLoadBalancerProfileManagedOutboundIPsARMGenerator gopter.Gen

// ManagedClusterLoadBalancerProfileManagedOutboundIPsARMGenerator returns a generator of ManagedClusterLoadBalancerProfileManagedOutboundIPsARM instances for property testing.
func ManagedClusterLoadBalancerProfileManagedOutboundIPsARMGenerator() gopter.Gen {
	if managedClusterLoadBalancerProfileManagedOutboundIPsARMGenerator != nil {
		return managedClusterLoadBalancerProfileManagedOutboundIPsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfileManagedOutboundIPsARM(generators)
	managedClusterLoadBalancerProfileManagedOutboundIPsARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfileManagedOutboundIPsARM{}), generators)

	return managedClusterLoadBalancerProfileManagedOutboundIPsARMGenerator
}

// AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfileManagedOutboundIPsARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForManagedClusterLoadBalancerProfileManagedOutboundIPsARM(gens map[string]gopter.Gen) {
	gens["Count"] = gen.PtrOf(gen.Int())
}

func Test_ManagedClusterLoadBalancerProfileOutboundIPPrefixesARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterLoadBalancerProfileOutboundIPPrefixesARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterLoadBalancerProfileOutboundIPPrefixesARM, ManagedClusterLoadBalancerProfileOutboundIPPrefixesARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterLoadBalancerProfileOutboundIPPrefixesARM runs a test to see if a specific instance of ManagedClusterLoadBalancerProfileOutboundIPPrefixesARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterLoadBalancerProfileOutboundIPPrefixesARM(subject ManagedClusterLoadBalancerProfileOutboundIPPrefixesARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterLoadBalancerProfileOutboundIPPrefixesARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterLoadBalancerProfileOutboundIPPrefixesARM instances for property testing - lazily
// instantiated by ManagedClusterLoadBalancerProfileOutboundIPPrefixesARMGenerator()
var managedClusterLoadBalancerProfileOutboundIPPrefixesARMGenerator gopter.Gen

// ManagedClusterLoadBalancerProfileOutboundIPPrefixesARMGenerator returns a generator of ManagedClusterLoadBalancerProfileOutboundIPPrefixesARM instances for property testing.
func ManagedClusterLoadBalancerProfileOutboundIPPrefixesARMGenerator() gopter.Gen {
	if managedClusterLoadBalancerProfileOutboundIPPrefixesARMGenerator != nil {
		return managedClusterLoadBalancerProfileOutboundIPPrefixesARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileOutboundIPPrefixesARM(generators)
	managedClusterLoadBalancerProfileOutboundIPPrefixesARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfileOutboundIPPrefixesARM{}), generators)

	return managedClusterLoadBalancerProfileOutboundIPPrefixesARMGenerator
}

// AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileOutboundIPPrefixesARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileOutboundIPPrefixesARM(gens map[string]gopter.Gen) {
	gens["PublicIPPrefixes"] = gen.SliceOf(ResourceReferenceARMGenerator())
}

func Test_ManagedClusterLoadBalancerProfileOutboundIPsARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ManagedClusterLoadBalancerProfileOutboundIPsARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForManagedClusterLoadBalancerProfileOutboundIPsARM, ManagedClusterLoadBalancerProfileOutboundIPsARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForManagedClusterLoadBalancerProfileOutboundIPsARM runs a test to see if a specific instance of ManagedClusterLoadBalancerProfileOutboundIPsARM round trips to JSON and back losslessly
func RunJSONSerializationTestForManagedClusterLoadBalancerProfileOutboundIPsARM(subject ManagedClusterLoadBalancerProfileOutboundIPsARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ManagedClusterLoadBalancerProfileOutboundIPsARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ManagedClusterLoadBalancerProfileOutboundIPsARM instances for property testing - lazily instantiated by
// ManagedClusterLoadBalancerProfileOutboundIPsARMGenerator()
var managedClusterLoadBalancerProfileOutboundIPsARMGenerator gopter.Gen

// ManagedClusterLoadBalancerProfileOutboundIPsARMGenerator returns a generator of ManagedClusterLoadBalancerProfileOutboundIPsARM instances for property testing.
func ManagedClusterLoadBalancerProfileOutboundIPsARMGenerator() gopter.Gen {
	if managedClusterLoadBalancerProfileOutboundIPsARMGenerator != nil {
		return managedClusterLoadBalancerProfileOutboundIPsARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileOutboundIPsARM(generators)
	managedClusterLoadBalancerProfileOutboundIPsARMGenerator = gen.Struct(reflect.TypeOf(ManagedClusterLoadBalancerProfileOutboundIPsARM{}), generators)

	return managedClusterLoadBalancerProfileOutboundIPsARMGenerator
}

// AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileOutboundIPsARM is a factory method for creating gopter generators
func AddRelatedPropertyGeneratorsForManagedClusterLoadBalancerProfileOutboundIPsARM(gens map[string]gopter.Gen) {
	gens["PublicIPs"] = gen.SliceOf(ResourceReferenceARMGenerator())
}

func Test_ResourceReferenceARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of ResourceReferenceARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForResourceReferenceARM, ResourceReferenceARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForResourceReferenceARM runs a test to see if a specific instance of ResourceReferenceARM round trips to JSON and back losslessly
func RunJSONSerializationTestForResourceReferenceARM(subject ResourceReferenceARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual ResourceReferenceARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of ResourceReferenceARM instances for property testing - lazily instantiated by
// ResourceReferenceARMGenerator()
var resourceReferenceARMGenerator gopter.Gen

// ResourceReferenceARMGenerator returns a generator of ResourceReferenceARM instances for property testing.
func ResourceReferenceARMGenerator() gopter.Gen {
	if resourceReferenceARMGenerator != nil {
		return resourceReferenceARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForResourceReferenceARM(generators)
	resourceReferenceARMGenerator = gen.Struct(reflect.TypeOf(ResourceReferenceARM{}), generators)

	return resourceReferenceARMGenerator
}

// AddIndependentPropertyGeneratorsForResourceReferenceARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForResourceReferenceARM(gens map[string]gopter.Gen) {
	gens["Id"] = gen.PtrOf(gen.AlphaString())
}

func Test_UserAssignedIdentityARM_WhenSerializedToJson_DeserializesAsEqual(t *testing.T) {
	t.Parallel()
	parameters := gopter.DefaultTestParameters()
	parameters.MinSuccessfulTests = 100
	parameters.MaxSize = 3
	properties := gopter.NewProperties(parameters)
	properties.Property(
		"Round trip of UserAssignedIdentityARM via JSON returns original",
		prop.ForAll(RunJSONSerializationTestForUserAssignedIdentityARM, UserAssignedIdentityARMGenerator()))
	properties.TestingRun(t, gopter.NewFormatedReporter(true, 240, os.Stdout))
}

// RunJSONSerializationTestForUserAssignedIdentityARM runs a test to see if a specific instance of UserAssignedIdentityARM round trips to JSON and back losslessly
func RunJSONSerializationTestForUserAssignedIdentityARM(subject UserAssignedIdentityARM) string {
	// Serialize to JSON
	bin, err := json.Marshal(subject)
	if err != nil {
		return err.Error()
	}

	// Deserialize back into memory
	var actual UserAssignedIdentityARM
	err = json.Unmarshal(bin, &actual)
	if err != nil {
		return err.Error()
	}

	// Check for outcome
	match := cmp.Equal(subject, actual, cmpopts.EquateEmpty())
	if !match {
		actualFmt := pretty.Sprint(actual)
		subjectFmt := pretty.Sprint(subject)
		result := diff.Diff(subjectFmt, actualFmt)
		return result
	}

	return ""
}

// Generator of UserAssignedIdentityARM instances for property testing - lazily instantiated by
// UserAssignedIdentityARMGenerator()
var userAssignedIdentityARMGenerator gopter.Gen

// UserAssignedIdentityARMGenerator returns a generator of UserAssignedIdentityARM instances for property testing.
func UserAssignedIdentityARMGenerator() gopter.Gen {
	if userAssignedIdentityARMGenerator != nil {
		return userAssignedIdentityARMGenerator
	}

	generators := make(map[string]gopter.Gen)
	AddIndependentPropertyGeneratorsForUserAssignedIdentityARM(generators)
	userAssignedIdentityARMGenerator = gen.Struct(reflect.TypeOf(UserAssignedIdentityARM{}), generators)

	return userAssignedIdentityARMGenerator
}

// AddIndependentPropertyGeneratorsForUserAssignedIdentityARM is a factory method for creating gopter generators
func AddIndependentPropertyGeneratorsForUserAssignedIdentityARM(gens map[string]gopter.Gen) {
	gens["ClientId"] = gen.PtrOf(gen.AlphaString())
	gens["ObjectId"] = gen.PtrOf(gen.AlphaString())
	gens["ResourceId"] = gen.PtrOf(gen.AlphaString())
}
